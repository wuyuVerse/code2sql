{
  "multi_branch_transaction_simple": {
    "function_name": "GetByCategory",
    "orm_code": "\"gorm.io/gorm\"\n\"time\"\n)\nfunc GetByCategory(db *gorm.DB, branchIDs []uint) ([]Vendor, error) {\nvar vendors []Vendor\ntx := db.Begin()\ndefer func() {\nif r := recover(); r != nil {\ntx.Rollback()\n}\n}()\n// Branch 1: Query data\nif err := tx.Where(\"sign = ? AND branch_id IN ? AND transaction_id IS NOT NULL AND created_at >= ? AND updated_at <= ?\",\n\"completed\", branchIDs, time.Date(2023, 1, 1, 0, 0, 0, 0, time.UTC), time.Date(2023, 12, 31, 0, 0, 0, 0, time.UTC)).\nOrder(\"created_at DESC\").Limit(100).Find(&vendors).Error; err != nil {\ntx.Rollback()\nreturn nil, err\n}\n// Branch 2: Update some records\nif len(vendors) > 0 {\nif err := tx.Model(&Vendor{}).Where(\"branch_id IN ?\", branchIDs).\nUpdate(\"updated_at\", time.Now()).Error; err != nil {\ntx.Rollback()\nreturn nil, err\n}\n}\n// Branch 3: Delete some records (example)\nif len(vendors) > 10 {\nif err := tx.Where(\"branch_id = ?\", branchIDs[0]).Delete(&Vendor{}).Error; err != nil {\ntx.Rollback()\nreturn nil, err\n}\n}\nif err := tx.Commit().Error; err != nil {\nreturn nil, err\n}\nreturn vendors, nil\n}",
    "caller": "\"errors\"\n\"gorm.io/gorm\"\n\"time\"\n)\nfunc MassModify(db *gorm.DB, branchIDs []uint) ([]Transaction, error) {\nif len(branchIDs) == 0 {\nreturn nil, errors.New(\"branchIDs cannot be empty\")\n}\nvar transactions []Transaction\ntx := db.Begin()\ndefer func() {\nif r := recover(); r != nil {\ntx.Rollback()\n}\n}()\nswitch {\n// Branch 1: Process pending transactions for branches 4-6\ncase containsAny(branchIDs, []uint{4, 5, 6}):\nif err := tx.Where(\"weight = ? AND branch_id IN ? AND transaction_id IS NOT NULL AND created_at >= ? AND updated_at <= ?\",\n\"pending\", branchIDs, time.Date(2023, 6, 1, 0, 0, 0, 0, time.UTC), time.Date(2023, 12, 31, 0, 0, 0, 0, time.UTC)).\nOrder(\"created_at DESC\").Limit(50).Find(&transactions).Error; err != nil {\ntx.Rollback()\nreturn nil, err\n}\nif len(transactions) > 0 {\nif err := tx.Model(&Transaction{}).Where(\"branch_id IN ?\", branchIDs).\nUpdate(\"weight\", \"processed\").Error; err != nil {\ntx.Rollback()\nreturn nil, err\n}\n}\n// Branch 2: Process cancelled transactions for branches 7-9\ncase containsAny(branchIDs, []uint{7, 8, 9}):\nif err := tx.Where(\"weight = ? AND branch_id IN ? AND transaction_id IS NULL AND created_at >= ? AND updated_at <= ?\",\n\"cancelled\", branchIDs, time.Date(2023, 3, 1, 0, 0, 0, 0, time.UTC), time.Date(2023, 9, 30, 0, 0, 0, 0, time.UTC)).\nOrder(\"updated_at ASC\").Limit(75).Find(&transactions).Error; err != nil {\ntx.Rollback()\nreturn nil, err\n}\nif len(transactions) > 10 {\nif err := tx.Where(\"branch_id IN ?\", branchIDs).Delete(&Transaction{}).Error; err != nil {\ntx.Rollback()\nreturn nil, err\n}\n}\n// Branch 3: Process urgent transactions for branch 10\ncase containsAny(branchIDs, []uint{10}):\nif err := tx.Where(\"weight LIKE ? AND branch_id = ? AND transaction_id IS NOT NULL AND created_at >= ? AND updated_at <= ?\",\n\"%urgent%\", branchIDs[0], time.Date(2023, 1, 1, 0, 0, 0, 0, time.UTC), time.Date(2023, 6, 30, 0, 0, 0, 0, time.UTC)).\nOrder(\"created_at DESC\").Limit(25).Find(&transactions).Error; err != nil {\ntx.Rollback()\nreturn nil, err\n}\nif len(transactions) > 0 {\nif err := tx.Model(&Transaction{}).Where(\"branch_id = ?\", branchIDs[0]).\nUpdate(\"updated_at\", time.Now()).Error; err != nil {\ntx.Rollback()\nreturn nil, err\n}\n}\ndefault:\ntx.Rollback()\nreturn nil, errors.New(\"no valid branch IDs provided\")\n}\nif err := tx.Commit().Error; err != nil {\nreturn nil, err\n}\nreturn transactions, nil\n}\nfunc containsAny(slice []uint, values []uint) bool {\nfor _, v := range values {\nfor _, s := range slice {\nif s == v {\nreturn true\n}\n}\n}\nreturn false\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "查询待处理的分支4-6的记录，限制50条",
            "sql": "SELECT id, description, branch_id, transaction_id, created_at, updated_at FROM patient_records WHERE description = 'pending' AND branch_id IN (4, 5, 6) AND transaction_id IS NOT NULL AND created_at >= '2023-06-01' AND updated_at <= '2023-12-31' ORDER BY created_at DESC LIMIT 50;"
          },
          {
            "scenario": "查询已取消且无交易的分支7-9的记录，按更新时间升序",
            "sql": "SELECT id, description, branch_id, transaction_id, created_at, updated_at FROM patient_records WHERE description = 'cancelled' AND branch_id IN (7, 8, 9) AND transaction_id IS NULL AND created_at >= '2023-03-01' AND updated_at <= '2023-09-30' ORDER BY updated_at ASC LIMIT 75;"
          },
          {
            "scenario": "查询描述包含urgent且属于分支10的紧急记录，限制25条",
            "sql": "SELECT id, description, branch_id, transaction_id, created_at, updated_at FROM patient_records WHERE description LIKE '%urgent%' AND branch_id = 10 AND transaction_id IS NOT NULL AND created_at >= '2023-01-01' AND updated_at <= '2023-06-30' ORDER BY created_at DESC LIMIT 25;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "GetByCategory",
        "code_value": "type GetByCategory struct {\n    // 实体结构定义\n}"
      }
    ]
  },
  "multi_branch_transaction_medium": {
    "function_name": "MassEdit",
    "orm_code": "\"fmt\"\n\"gorm.io/driver/mysql\"\n\"gorm.io/gorm\"\n\"time\"\n)\nfunc MassEdit(db *gorm.DB, driverID int, vehicleID int, startDate string, endDate string, minModifiedAt string) ([]Paragraph, error) {\nvar results []Paragraph\ntx := db.Begin()\ndefer func() {\nif r := recover(); r != nil {\ntx.Rollback()\n}\n}()\n// Branch 1: Query records\nif err := tx.Where(\"driver_id = ? AND vehicle_id = ?\", driverID, vehicleID).\nWhere(\"schedule_date BETWEEN ? AND ?\", startDate, endDate).\nWhere(\"status IN ?\", []string{\"assigned\", \"completed\"}).\nWhere(\"modified_at > ?\", minModifiedAt).\nOrder(\"schedule_date DESC, start_time ASC\").\nLimit(50).\nFind(&results).Error; err != nil {\ntx.Rollback()\nreturn nil, fmt.Errorf(\"query failed: %v\", err)\n}\nif len(results) == 0 {\ntx.Rollback()\nreturn nil, fmt.Errorf(\"no records found\")\n}\n// Branch 2: Update first record\nfirstID := results[0].DriverID\nif err := tx.Model(&Paragraph{}).\nWhere(\"driver_id = ?\", firstID).\nUpdate(\"label\", \"updated_label\").Error; err != nil {\ntx.Rollback()\nreturn nil, fmt.Errorf(\"update failed: %v\", err)\n}\n// Branch 3: Delete last record if status is completed\nlastIdx := len(results) - 1\nlastRecord := results[lastIdx]\nif lastRecord.Status == \"completed\" {\nif err := tx.Where(\"driver_id = ? AND vehicle_id = ?\", lastRecord.DriverID, lastRecord.VehicleID).\nDelete(&Paragraph{}).Error; err != nil {\ntx.Rollback()\nreturn nil, fmt.Errorf(\"delete failed: %v\", err)\n}\n}\nif err := tx.Commit().Error; err != nil {\nreturn nil, fmt.Errorf(\"commit failed: %v\", err)\n}\nreturn results, nil\n}\nfunc main() {\ndsn := \"user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&parseTime=True&loc=Local\"\ndb, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})\nif err != nil {\npanic(\"failed to connect database\")\n}\nresults, err := MassEdit(db, 123, 456, \"2023-01-01\", \"2023-12-31\", \"2023-06-01\")\nif err != nil {\nfmt.Printf(\"Error: %v\\n\", err)\nreturn\n}\nfmt.Printf(\"Processed %d records\\n\", len(results))\n}",
    "caller": "\"fmt\"\n\"gorm.io/driver/mysql\"\n\"gorm.io/gorm\"\n\"time\"\n)\nfunc GetByStatus(db *gorm.DB, parentID int, startDate string, endDate string, minCreatedAt string) ([]Loan, error) {\nvar results []Loan\ntx := db.Begin()\ndefer func() {\nif r := recover(); r != nil {\ntx.Rollback()\n}\n}()\n// Parameter validation\nif parentID <= 0 {\ntx.Rollback()\nreturn nil, fmt.Errorf(\"invalid parent ID\")\n}\n// Branch 1: Query pending/approved activities for specific parent in date range\nif err := tx.Where(\"parent_id = ?\", parentID).\nWhere(\"activity_date BETWEEN ? AND ?\", startDate, endDate).\nWhere(\"status IN ?\", []string{\"pending\", \"approved\"}).\nWhere(\"created_at > ?\", minCreatedAt).\nOrder(\"activity_date ASC, start_time DESC\").\nLimit(30).\nFind(&results).Error; err != nil {\ntx.Rollback()\nreturn nil, fmt.Errorf(\"branch 1 query failed: %v\", err)\n}\nif len(results) == 0 {\n// Branch 2 alternative: Query completed activities from earlier period\nif err := tx.Where(\"status = ?\", \"completed\").\nWhere(\"activity_date < ?\", \"2023-06-01\").\nWhere(\"created_at < ?\", \"2023-05-01\").\nOrder(\"activity_date DESC, end_time ASC\").\nLimit(20).\nFind(&results).Error; err != nil {\ntx.Rollback()\nreturn nil, fmt.Errorf(\"branch 2 query failed: %v\", err)\n}\nif len(results) == 0 {\ntx.Rollback()\nreturn nil, fmt.Errorf(\"no records found in either branch\")\n}\n// Branch 2 operation: Update oldest record\noldestID := results[len(results)-1].ActivityID\nif err := tx.Model(&Loan{}).\nWhere(\"activity_id = ?\", oldestID).\nUpdate(\"comments\", \"auto-updated by branch 2\").Error; err != nil {\ntx.Rollback()\nreturn nil, fmt.Errorf(\"branch 2 update failed: %v\", err)\n}\n} else {\n// Branch 1 operation: Update newest record\nnewestID := results[0].ActivityID\nif err := tx.Model(&Loan{}).\nWhere(\"activity_id = ?\", newestID).\nUpdate(\"status\", \"processed\").Error; err != nil {\ntx.Rollback()\nreturn nil, fmt.Errorf(\"branch 1 update failed: %v\", err)\n}\n// Additional Branch 1 operation: Delete if status is pending and date is old\nfor _, record := range results {\nif record.Status == \"pending\" && record.ActivityDate.Before(time.Now().AddDate(0, -3, 0)) {\nif err := tx.Delete(&Loan{}, \"activity_id = ?\", record.ActivityID).Error; err != nil {\ntx.Rollback()\nreturn nil, fmt.Errorf(\"branch 1 delete failed: %v\", err)\n}\nbreak\n}\n}\n}\nif err := tx.Commit().Error; err != nil {\nreturn nil, fmt.Errorf(\"commit failed: %v\", err)\n}\nreturn results, nil\n}\nfunc main() {\ndsn := \"user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&parseTime=True&loc=Local\"\ndb, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})\nif err != nil {\npanic(\"failed to connect database\")\n}\nresults, err := GetByStatus(db, 789, \"2023-07-01\", \"2023-12-31\", \"2023-09-01\")\nif err != nil {\nfmt.Printf(\"Error: %v\\n\", err)\nreturn\n}\nfmt.Printf(\"Processed %d records\\n\", len(results))\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "查询特定banner在2023年下半年创建且状态为pending或approved的活动，按日期升序和开始时间降序排列",
            "sql": "SELECT banner_id, activity_id, activity_date, start_time, end_time, creator_id, created_at, status, location_id, comments FROM share_activities WHERE banner_id = 789 AND activity_date BETWEEN '2023-07-01' AND '2023-12-31' AND status IN ('pending', 'approved') AND created_at > '2023-09-01' ORDER BY activity_date ASC, start_time DESC LIMIT 30;"
          },
          {
            "scenario": "查询2023年上半年之前创建且已完成的活动，按日期降序和结束时间升序排列",
            "sql": "SELECT banner_id, activity_id, activity_date, start_time, end_time, creator_id, created_at, status, location_id, comments FROM share_activities WHERE status = 'completed' AND activity_date < '2023-06-01' AND created_at < '2023-05-01' ORDER BY activity_date DESC, end_time ASC LIMIT 20;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "MassEdit",
        "code_value": "type MassEdit struct {\n    // 实体结构定义\n}"
      }
    ]
  },
  "multi_branch_transaction_complex": {
    "function_name": "DropByID",
    "orm_code": "\"errors\"\n\"gorm.io/gorm\"\n)\nfunc DropByID(db *gorm.DB, id uint) error {\ntx := db.Begin()\nif tx.Error != nil {\nreturn tx.Error\n}\n// 分支1: 查询记录\nvar friend Friend\nif err := tx.Where(\"id = ?\", id).First(&friend).Error; err != nil {\ntx.Rollback()\nreturn err\n}\n// 分支2: 根据状态更新不同字段\nvar updateErr error\nswitch friend.Status {\ncase \"active\":\nupdateErr = tx.Model(&Friend{}).Where(\"id = ?\", id).\nUpdate(\"performance_score\", gorm.Expr(\"performance_score + ?\", 10)).Error\ncase \"inactive\":\nupdateErr = tx.Model(&Friend{}).Where(\"id = ?\", id).\nUpdate(\"salary\", gorm.Expr(\"salary * ?\", 1.05)).Error\ndefault:\nupdateErr = errors.New(\"invalid status\")\n}\nif updateErr != nil {\ntx.Rollback()\nreturn updateErr\n}\n// 分支3: 删除记录\nif err := tx.Where(\"id = ?\", id).Delete(&Friend{}).Error; err != nil {\ntx.Rollback()\nreturn err\n}\nreturn tx.Commit().Error\n}",
    "caller": "\"errors\"\n\"gorm.io/gorm\"\n)\nfunc UpdateByID(db *gorm.DB, id uint) error {\nif db == nil {\nreturn errors.New(\"database connection is nil\")\n}\nif id == 0 {\nreturn errors.New(\"invalid ID\")\n}\ntx := db.Begin()\nif tx.Error != nil {\nreturn tx.Error\n}\n// 分支1: 查询记录\nvar medical Medical\nif err := tx.Where(\"id = ?\", id).First(&medical).Error; err != nil {\ntx.Rollback()\nreturn err\n}\nvar updateErr error\nswitch medical.Timezone {\ncase \"EST\":\n// 分支1逻辑: 对EST时区的记录执行特定操作\nupdateErr = tx.Model(&Medical{}).Where(\"id = ?\", id).\nUpdate(\"performance_score\", gorm.Expr(\"performance_score + ?\", 15)).Error\nif updateErr == nil {\nupdateErr = tx.Model(&Medical{}).Where(\"id = ?\", id).\nUpdate(\"status\", \"processed_est\").Error\n}\ncase \"PST\":\n// 分支2逻辑: 对PST时区的记录执行特定操作\nupdateErr = tx.Model(&Medical{}).Where(\"id = ?\", id).\nUpdate(\"salary\", gorm.Expr(\"salary * ?\", 1.07)).Error\nif updateErr == nil {\nupdateErr = tx.Model(&Medical{}).Where(\"id = ?\", id).\nUpdate(\"status\", \"processed_pst\").Error\n}\ncase \"GMT\":\n// 分支3逻辑: 对GMT时区的记录执行特定操作\nupdateErr = tx.Model(&Medical{}).Where(\"id = ?\", id).\nUpdate(\"is_active\", false).Error\nif updateErr == nil {\nupdateErr = tx.Model(&Medical{}).Where(\"id = ?\", id).\nUpdate(\"status\", \"processed_gmt\").Error\n}\ndefault:\nupdateErr = errors.New(\"unsupported timezone\")\n}\nif updateErr != nil {\ntx.Rollback()\nreturn updateErr\n}\n// 分支4: 根据状态进行最终操作\nif medical.Status == \"critical\" {\nif err := tx.Model(&Medical{}).Where(\"id = ?\", id).\nUpdate(\"department\", \"Emergency\").Error; err != nil {\ntx.Rollback()\nreturn err\n}\n}\nreturn tx.Commit().Error\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "查询高风险、高保费的活跃保险政策，按保费降序和风险分数升序排列",
            "sql": "SELECT id, comment, policy_type, premium_amount, issue_date, risk_score, region, is_active FROM insurance_policies WHERE policy_type IN ('Life', 'Auto', 'Health') AND premium_amount BETWEEN 1000 AND 5000 AND issue_date > '2021-01-01' AND risk_score >= 60 AND region LIKE '%North%' AND is_active = TRUE ORDER BY premium_amount DESC, risk_score ASC LIMIT 50;"
          },
          {
            "scenario": "查询低成本、低索赔的未续订房屋保险政策，按保费升序和索赔次数降序排列",
            "sql": "SELECT id, comment, policy_type, premium_amount, renewal_date, claim_count, branch_location, is_renewed FROM insurance_policies WHERE policy_type = 'Home' AND premium_amount < 2000 AND renewal_date BETWEEN '2023-01-01' AND '2023-12-31' AND claim_count <= 2 AND branch_location LIKE '%Coastal%' AND is_renewed = FALSE ORDER BY premium_amount ASC, claim_count DESC LIMIT 30;"
          },
          {
            "scenario": "查询高保额、高评级的已批准国际旅行和宠物保险政策，按保额和客户评级降序排列",
            "sql": "SELECT id, comment, policy_type, coverage_amount, effective_date, customer_rating, service_region, is_approved FROM insurance_policies WHERE policy_type IN ('Travel', 'Pet') AND coverage_amount > 10000 AND effective_date < '2022-06-01' AND customer_rating >= 4.0 AND service_region LIKE '%International%' AND is_approved = TRUE ORDER BY coverage_amount DESC, customer_rating DESC LIMIT 20;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "DropByID",
        "code_value": "type DropByID struct {\n    // 实体结构定义\n}"
      }
    ]
  }
}