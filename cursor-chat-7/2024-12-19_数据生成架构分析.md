# 数据生成架构与Prompt设计分析

## 1. 整体架构概览

### 1.1 模块结构
```
data_processing/synthetic_data_generator/
├── generator.py         # 核心生成逻辑
├── get_sql.py          # SQL提取和验证
├── cli.py              # 命令行接口
├── config.py           # 配置管理
├── prompts.py          # 提示词模板
└── README.md           # 文档说明
```

### 1.2 核心组件功能

#### 生成器核心 (`generator.py`)
- **SyntheticDataGenerator类**：主要的数据生成引擎
- **并行处理**：支持多线程并行生成，提高效率
- **LLM集成**：使用项目的LLMClient进行AI调用
- **数据验证**：自动验证生成数据的格式正确性

#### SQL处理模块 (`get_sql.py`)
- **SQL提取**：从生成的代码中提取SQL语句
- **SQL验证**：验证SQL语句的正确性和完整性
- **SQL格式化**：统一SQL输出格式
- **重试机制**：指数退避重试机制处理API调用失败

## 2. Prompt设计架构

### 2.1 Prompt模板体系

系统采用**场景化Prompt设计**，为不同场景提供专门的提示词模板：

#### 基础Prompt模板
- `PROMPT_ORM`：通用ORM代码生成模板
- `PROMPT_CALLER`：通用调用者代码生成模板
- `PROMPT_META`：元数据生成模板

#### 场景专用Prompt模板
- `PROMPT_ORM_IF_ELSE_CALLER`：if-else+caller场景ORM生成
- `PROMPT_CALLER_IF_ELSE`：if-else+caller场景调用者生成
- `PROMPT_ORM_SWITCH`：switch场景ORM生成
- `PROMPT_CALLER_SWITCH`：switch场景调用者生成
- `PROMPT_ORM_IF_ELSE_ORM`：if-else+orm场景ORM生成
- `PROMPT_CALLER_IF_ELSE_ORM`：if-else+orm场景调用者生成
- `PROMPT_ORM_NO_WHERE`：no-where场景ORM生成
- `PROMPT_CALLER_NO_WHERE`：no-where场景调用者生成（空实现）
- `PROMPT_ORM_TABLE_MAPPING_INCOMPLETE`：表名映射不完善场景ORM生成
- `PROMPT_CALLER_TABLE_MAPPING_INCOMPLETE`：表名映射不完善场景调用者生成
- `PROMPT_ORM_CONDITION_FIELD_MAPPING`：condition_field_mapping场景ORM生成
- `PROMPT_CALLER_CONDITION_FIELD_MAPPING`：condition_field_mapping场景调用者生成

### 2.2 Prompt设计特点

#### 2.2.1 结构化输出
所有Prompt都要求LLM输出**严格的JSON格式**，确保数据的一致性和可解析性：

```json
{
    "scenario": "场景标签",
    "code_key": "方法名",
    "code_value": "完整的Go代码",
    "sql_pattern_cnt": 1,
    "callers": []
}
```

#### 2.2.2 场景化定制
每个场景都有专门的Prompt模板，包含：
- **场景描述**：明确说明场景的特点和要求
- **代码要求**：针对场景的具体实现要求
- **格式规范**：统一的输出格式要求

#### 2.2.3 多样化生成
Prompt设计确保生成内容的多样性：
- **变量名词库**：使用丰富的变量名避免重复
- **业务域多样化**：支持电商、金融、社交等多个领域
- **逻辑结构变化**：确保与参考样例完全不同

### 2.3 Prompt使用流程

#### 2.3.1 场景选择逻辑
```python
# 根据场景选择不同的ORM提示词模板
if scenario == "if-else+caller":
    orm_prompt = PROMPT_ORM_IF_ELSE_CALLER.format(...)
elif scenario == "switch":
    orm_prompt = PROMPT_ORM_SWITCH.format(...)
elif scenario == "if-else+orm":
    orm_prompt = PROMPT_ORM_IF_ELSE_ORM.format(...)
# ... 其他场景
else:
    orm_prompt = PROMPT_ORM.format(...)  # 通用模板
```

#### 2.3.2 参数注入
Prompt模板支持动态参数注入：
- `{scenario}`：场景标签
- `{scenario_desc}`：场景描述
- `{example}`：参考样例
- `{entity_examples}`：实体名示例
- `{table_examples}`：表名示例
- `{method_examples}`：方法名示例
- `{field_examples}`：字段名示例

### 2.4 场景专用Prompt分析

#### 2.4.1 if-else+caller场景
**ORM Prompt特点**：
- 要求接收`map[string]interface{}`类型的filter参数
- 内部必须包含if-else逻辑
- 至少包含两种不同的查询策略

**Caller Prompt特点**：
- 必须包含if-else条件判断逻辑
- 至少包含3个不同的条件分支
- 每个分支检查不同的参数

#### 2.4.2 switch场景
**ORM Prompt特点**：
- 必须包含switch语句
- 至少包含4个不同的case分支
- 使用常量或枚举值作为判断条件

**Caller Prompt特点**：
- 包含switch条件判断逻辑
- 每个case分支设置不同的参数值
- 必须包含default分支

#### 2.4.3 table_mapping_incomplete场景
**ORM Prompt特点**：
- 必须定义常量表示真实表名
- 使用`.Table(TableName)`明确指定表名
- 结构体名和表名必须不同

#### 2.4.4 condition_field_mapping场景
**ORM Prompt特点**：
- 必须包含条件判断与实际where条件字段不同的逻辑
- 至少包含2个不同的字段映射关系（如：region→cluster_id, category→type_id等）
- 使用if-else或switch语句进行条件判断
- 判断条件中的字段名与添加到SQL中的字段名必须不同

**Caller Prompt特点**：
- 构建包含字段映射关系的参数传递给ORM方法
- filter参数中必须包含与ORM方法中字段映射对应的原始字段名
- 至少包含2个不同的字段映射关系

## 3. 数据生成流程

### 3.1 完整生成流程
1. **加载参考数据**：从`full_scenario.json`加载真实样例
2. **场景选择**：根据指定场景选择对应的Prompt模板
3. **ORM生成**：使用场景专用Prompt生成ORM代码
4. **Caller生成**：使用场景专用Prompt生成调用者代码
5. **Meta生成**：生成相关的元数据（结构体、常量等）
6. **数据验证**：验证生成数据的格式和完整性
7. **SQL提取**：从生成的代码中提取SQL语句
8. **结果输出**：保存到指定文件

### 3.2 并行处理机制
- **多worker并行**：支持多个worker同时生成
- **线程安全**：使用锁保护共享资源
- **进度监控**：实时显示生成进度和统计信息

## 4. 支持的场景类型

系统支持18种不同的ORM场景：

1. **对象var+chunk** - 依赖对象成员变量
2. **caller+global variable** - 依赖外部全局变量
3. **caller+chunk** - 需要调用者传递参数
4. **caller的callee+caller** - 形成调用链
5. **单chunk** - 基础CRUD操作
6. **单chunk+meta(global var)** - 使用全局变量
7. **preload特殊函数** - 预加载优化
8. **association特殊函数** - 关联关系操作
9. **单chunk+meta(local var)** - 依赖局部变量
10. **单chunk+meta(对象var)** - 依赖对象变量
11. **一度caller+chunk** - 一层调用关系
12. **二度caller+chunk** - 两层调用关系
13. **对象const+chunk** - 依赖对象常量
14. **switch** - 使用switch条件语句
15. **if-else+caller** - 调用者包含条件判断
16. **if-else+orm** - ORM方法包含条件判断
17. **no-where** - 需要外部where条件
18. **table_mapping_incomplete** - 表名映射不完整
19. **condition_field_mapping** - 条件判断与实际where条件列添加的条件不同

## 5. 关键特性

### 5.1 质量保证
- **自动数据验证**：确保生成数据格式正确
- **SQL语句提取**：从代码中提取并验证SQL
- **错误重试机制**：提高生成成功率

### 5.2 多样化生成
- **丰富的变量名词库**：避免重复使用常见名词
- **多业务域支持**：电商、金融、社交等多个领域
- **逻辑结构变化**：确保与参考样例完全不同

### 5.3 性能优化
- **并行处理**：多worker同时生成提高效率
- **内存优化**：支持大批量生成
- **实时监控**：进度和统计信息实时显示

## 6. 使用方式

### 6.1 命令行接口
```bash
# 生成所有场景
python -m data_processing.synthetic_data_generator.cli

# 生成指定场景
python -m data_processing.synthetic_data_generator.cli --scenario "单chunk" --count 5

# 并行模式
python -m data_processing.synthetic_data_generator.cli --parallel --workers 8
```

### 6.2 程序化调用
```python
from data_processing.synthetic_data_generator.generator import SyntheticDataGenerator
from config.data_processing.synthetic_data_generator.config import SyntheticDataConfig

config = SyntheticDataConfig()
generator = SyntheticDataGenerator(config)
result = await generator.generate_pack("单chunk")
```

## 7. 总结

这个数据生成架构设计非常完善，具有以下特点：

1. **模块化设计**：清晰的职责分离，便于维护和扩展
2. **场景化Prompt**：为不同场景提供专门的提示词模板
3. **高质量生成**：通过验证和重试机制确保数据质量
4. **多样化输出**：丰富的名词库和多业务域支持
5. **高性能处理**：并行处理和内存优化
6. **易用性**：提供命令行和程序化两种使用方式

整个系统既保证了生成数据的质量和多样性，又提供了良好的扩展性和可维护性，是一个设计精良的AI数据生成系统。 