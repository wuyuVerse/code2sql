# 2025-07-18 SQL输出格式验证与重新生成功能

## 对话概述

本次对话主要解决了SQL生成过程中出现的格式问题，特别是LLM生成了非标准SQL类型（如`always_executed`、`conditional_execution`）的问题，并实现了严格的格式验证和自动重新生成功能。

## 问题分析

### 1. 原始问题
用户发现生成的SQL中出现了非预期的类型：
- 期望类型：`param_dependent`、`LACK_INFORMATION`、`NO_SQL_GENERATE`
- 实际生成：`always_executed`、`conditional_execution`

### 2. 问题根源
- **提示词不够明确**：LLM根据代码逻辑自行推断出新的SQL类型
- **缺乏格式验证**：没有对生成结果进行严格验证
- **缺少重新生成机制**：格式错误时无法自动修正

## 解决方案

### 1. 统一提示词模板
将`get_sql.py`中的提示词替换为标准的`validation_prompts.py`模板：

```python
# 导入标准模板
from config.data_processing.validation.validation_prompts import (
    ANALYSIS_PROMPT_TEMPLATE,
    VERIFICATION_PROMPT_TEMPLATE,
    FORMATTING_PROMPT_TEMPLATE
)

# 替换原有定义
CODE_ORM_MYSQL_SQL_EXTRACT = ANALYSIS_PROMPT_TEMPLATE
CODE_ORM_MYSQL_SQL_VERIFY = VERIFICATION_PROMPT_TEMPLATE
CODE_ORM_MYSQL_SQL_FORMAT = FORMATTING_PROMPT_TEMPLATE
```

### 2. 实现格式验证函数
在`utils/response_parser.py`中添加验证函数：

```python
def validate_sql_output_format(sql_output: dict) -> tuple[bool, str]:
    """
    验证SQL输出格式是否符合要求
    
    Args:
        sql_output: SQL输出字典
        
    Returns:
        (is_valid, error_message): 验证结果和错误信息
    """
    # 验证必需字段
    required_fields = ['type', 'variants', 'scenario', 'sql']
    for field in required_fields:
        if field not in sql_output:
            return False, f"缺少必需字段: {field}"
    
    # 验证type字段
    allowed_types = ['param_dependent', 'LACK_INFORMATION', 'NO_SQL_GENERATE']
    if sql_output['type'] not in allowed_types:
        return False, f"不支持的SQL类型: {sql_output['type']}，只允许: {allowed_types}"
    
    # 验证variants字段
    if not isinstance(sql_output['variants'], list):
        return False, "variants字段必须是数组"
    
    # 验证scenario字段
    if not isinstance(sql_output['scenario'], str):
        return False, "scenario字段必须是字符串"
    
    # 验证sql字段
    if not isinstance(sql_output['sql'], str):
        return False, "sql字段必须是字符串"
    
    return True, ""
```

### 3. 实现重新生成机制
在`get_sql.py`中添加重新生成函数：

```python
async def validate_and_regenerate_sql(
    sql_output: dict, 
    original_prompt: str, 
    max_retries: int = 3
) -> dict:
    """
    验证SQL输出格式，如果不符合要求则重新生成
    
    Args:
        sql_output: 原始SQL输出
        original_prompt: 原始提示词
        max_retries: 最大重试次数
        
    Returns:
        验证通过或重试后的SQL输出
    """
    from utils.response_parser import validate_sql_output_format
    
    # 验证格式
    is_valid, error_msg = validate_sql_output_format(sql_output)
    if is_valid:
        return sql_output
    
    # 格式不正确，尝试重新生成
    for attempt in range(max_retries):
        try:
            # 添加格式要求到提示词
            enhanced_prompt = f"{original_prompt}\n\n重要：请确保生成的SQL类型必须是以下之一：param_dependent、LACK_INFORMATION、NO_SQL_GENERATE"
            
            # 重新调用LLM
            client = openai.AsyncClient(
                base_url="http://212.64.90.3:8081/v1", 
                api_key="EMPTY"
            )
            
            response = await client.chat.completions.create(
                model="default",
                messages=[
                    {"role": "system", "content": "你是一个SQL生成专家，严格按照指定格式生成SQL。"},
                    {"role": "user", "content": enhanced_prompt},
                ],
                temperature=0.7,
                max_tokens=8096,
            )
            
            # 解析响应
            content = response.choices[0].message.content
            parsed_output = parse_model_response(content)
            
            if isinstance(parsed_output, list) and len(parsed_output) > 0:
                new_output = parsed_output[0]
                # 再次验证
                is_valid, error_msg = validate_sql_output_format(new_output)
                if is_valid:
                    return new_output
            
        except Exception as e:
            print(f"重试 {attempt + 1} 失败: {e}")
    
    # 所有重试都失败，返回原始输出并记录警告
    print(f"警告: 无法生成符合格式的SQL，使用原始输出: {error_msg}")
    return sql_output
```

### 4. 集成到现有函数
修改`verify_sql_async`和`format_sql_async`函数，在返回结果前调用验证：

```python
# 在verify_sql_async函数末尾添加
result = validate_and_regenerate_sql(result, prompt)
return result

# 在format_sql_async函数末尾添加
result = validate_and_regenerate_sql(result, prompt)
return result
```

## 功能特点

### 1. 严格格式验证
- 只允许三种标准SQL类型
- 验证所有必需字段
- 确保数据类型正确

### 2. 自动重新生成
- 格式错误时自动重试
- 最多重试3次
- 增强提示词要求

### 3. 错误处理
- 详细的错误信息
- 重试失败时的降级处理
- 不中断整体流程

### 4. 向后兼容
- 验证失败时返回原始输出
- 不影响现有功能
- 保持API兼容性

## 使用效果

### 1. 格式标准化
- 所有生成的SQL都符合标准格式
- 消除了非预期类型
- 提高了数据质量

### 2. 自动化处理
- 无需手动干预
- 自动修正格式问题
- 减少人工审核工作

### 3. 可靠性提升
- 严格的验证机制
- 多重保障措施
- 降低错误率

## 技术细节

### 1. 验证逻辑
```python
# 允许的SQL类型
allowed_types = ['param_dependent', 'LACK_INFORMATION', 'NO_SQL_GENERATE']

# 必需字段检查
required_fields = ['type', 'variants', 'scenario', 'sql']

# 数据类型验证
if not isinstance(sql_output['variants'], list):
    return False, "variants字段必须是数组"
```

### 2. 重试机制
```python
# 增强提示词
enhanced_prompt = f"{original_prompt}\n\n重要：请确保生成的SQL类型必须是以下之一：param_dependent、LACK_INFORMATION、NO_SQL_GENERATE"

# 重试循环
for attempt in range(max_retries):
    # 重新生成逻辑
    pass
```

### 3. 错误处理
```python
# 降级处理
if all_retries_failed:
    print(f"警告: 无法生成符合格式的SQL，使用原始输出: {error_msg}")
    return original_output
```

## 总结

本次实现解决了SQL生成格式不一致的问题，通过：

1. **统一提示词模板** - 使用标准化的提示词
2. **严格格式验证** - 确保输出符合预期格式
3. **自动重新生成** - 格式错误时自动修正
4. **完善错误处理** - 多重保障机制

这些改进显著提高了SQL生成的质量和可靠性，为后续的数据处理工作奠定了坚实基础。 