# 2025-07-22 合成数据生成器工作原理分析

## 对话主题
用户询问 `generator.py` 中合成数据生成器的工作原理，特别是ORM代码块的生成机制，并请求添加新的生成类型"if-else+caller"和"switch"

## 核心发现

### 1. 生成器架构
- **类名**: `SyntheticDataGenerator`
- **核心依赖**: LLM客户端、配置管理、提示词模板
- **主要功能**: 基于大语言模型生成Go语言ORM相关的合成数据

### 2. 三阶段生成流程

#### 阶段1: ORM代码块生成
- 使用 `PROMPT_ORM` 模板
- 输入: 场景标签、场景描述、参考样例、随机变量名
- 输出: 包含完整ORM方法的JSON结构

#### 阶段2: 调用者代码块生成  
- 使用 `PROMPT_CALLER` 模板
- 输入: 第一阶段生成的ORM代码块
- 输出: 一个或多个调用者方法的JSON结构

#### 阶段3: 元数据生成
- 使用 `PROMPT_META` 模板
- 输入: ORM代码块和调用者代码块
- 输出: 结构体定义、常量定义等元数据的JSON数组

### 3. ORM代码块生成详细机制

#### 3.1 输入准备阶段
```python
# 获取随机变量名
var_names = self.config.get_random_names()
# 获取场景描述
scenario_desc = self.config.get_scenario_description(scenario)
# 获取参考样例
example = self._get_scenario_example(scenario)
example_str = self._format_example_for_prompt(example)
```

**关键输入要素：**
- **场景标签**：如 `"对象var+chunk"`、`"caller+global variable"` 等
- **场景描述**：详细说明该场景的业务逻辑要求
- **参考样例**：从 `full_scenario.json` 中获取的真实样例数据
- **随机变量名**：从多样化名词库中随机选择的变量名

#### 3.2 提示词模板构建
使用 `PROMPT_ORM` 模板，包含以下关键信息：

```python
PROMPT_ORM.format(
    scenario=scenario,                    # 场景标签
    scenario_desc=scenario_desc,          # 场景描述
    example=example_str,                  # 参考样例
    **var_names                          # 随机变量名
)
```

**提示词模板特点：**
- **结构化输出**：严格要求输出JSON格式
- **多样化要求**：使用不同的变量名，避免重复
- **代码质量要求**：完整可运行的Go代码，使用GORM框架
- **长度控制**：控制在25行以内
- **场景适配**：根据场景要求实现相应的逻辑模式

#### 3.3 LLM调用与格式验证
```python
orm_response = await self.llm_client.call_async_with_format_validation(
    self.session,
    PROMPT_ORM.format(...),
    validator=lambda x: validate_synthetic_data_response(x, 'orm'),
    max_tokens=self.config.max_tokens,
    temperature=self.config.temperature,
    module="synthetic_data_generator"
)
```

**关键特性：**
- **异步调用**：使用 `aiohttp` 进行异步HTTP请求
- **格式验证**：使用专门的验证器确保输出格式正确
- **参数控制**：通过 `temperature`、`max_tokens` 等参数控制生成质量

#### 3.4 格式验证机制
`validate_synthetic_data_response` 函数会验证：

**ORM响应必需字段：**
- `scenario`：场景标签
- `code_key`：方法名
- `code_value`：完整的Go代码
- `sql_pattern_cnt`：SQL模式计数

**验证逻辑：**
```python
def validate_orm_response(data: Any) -> Union[bool, Dict[str, Any]]:
    required_fields = ['scenario', 'code_key', 'code_value', 'sql_pattern_cnt']
    missing_fields = []
    for field in required_fields:
        if field not in data:
            missing_fields.append(field)
    
    if missing_fields:
        return {
            'valid': False,
            'error': f'缺少必需字段: {missing_fields}',
            'data': data
        }
    
    return True
```

#### 3.5 生成的ORM代码示例
基于不同场景，会生成不同类型的ORM方法：

**场景：`对象var+chunk`**
```go
func (u *User) QueryByProfile() *gorm.DB {
    return db.Where("age >= ? AND city = ?", u.Age, u.City)
}
```

**场景：`caller+global variable`**
```go
func GetProductsByCategory(category string) []Product {
    var products []Product
    db.Where("category = ? AND status = ?", category, ACTIVE_STATUS).Find(&products)
    return products
}
```

### 4. 新增"if-else+caller"场景完整实现

#### 4.1 场景特点分析
根据用户提供的例子，该场景具有以下特点：

**Caller代码特点：**
```go
// Caller中的if-else逻辑
filter := make(map[string]interface{})
if req.AppId > 0 {
    filter["app_id"] = req.AppId
} else if len(req.OwnerUin) > 0 {
    filter["uin"] = req.OwnerUin
} else if len(req.Name) > 0 {
    filter["name"] = req.Name
}
```

**ORM代码特点：**
```go
// ORM方法根据传入的filter参数使用不同的查询逻辑
if name, ok := filterSource["name"]; ok {
    // 使用LIKE查询
    err = db.Where("name like ?", "%"+name.(string)+"%").Find(&bs).Error
} else {
    // 使用普通WHERE查询
    err = db.Where(filterSource).Find(&bs).Error
}
```

#### 4.2 配置文件更新
在 `config/data_processing/synthetic_data_generator/config.py` 中添加了新场景定义：
```python
"if-else+caller": "Caller代码中包含if-else条件判断，根据不同的条件构建不同的filter参数传递给ORM方法，ORM方法根据传入的参数内容使用不同的筛选条件构建SQL查询"
```

#### 4.3 提示词模板创建
在 `config/data_processing/synthetic_data_generator/prompts.py` 中创建了专门的提示词模板：

**PROMPT_ORM_IF_ELSE_CALLER：**
- 要求ORM方法接收 `map[string]interface{}` 类型的filter参数
- 要求ORM方法内部包含if-else逻辑
- 要求至少包含两种不同的查询策略
- 支持精确匹配vs模糊匹配等不同查询策略

**PROMPT_CALLER_IF_ELSE：**
- 要求Caller方法包含if-else条件判断逻辑
- 要求至少包含3个不同的条件分支
- 要求每个条件分支检查不同的参数
- 要求filter参数为 `map[string]interface{}` 类型

#### 4.4 生成器代码实现
在 `data_processing/synthetic_data_generator/generator.py` 中添加了场景特定的提示词选择逻辑：

**串行生成方法：**
```python
# 根据场景选择不同的ORM提示词模板
if scenario == "if-else+caller":
    from config.data_processing.synthetic_data_generator.prompts import PROMPT_ORM_IF_ELSE_CALLER
    orm_prompt = PROMPT_ORM_IF_ELSE_CALLER.format(
        example=example_str,
        **var_names
    )
else:
    orm_prompt = PROMPT_ORM.format(
        scenario=scenario,
        scenario_desc=scenario_desc,
        example=example_str,
        **var_names
    )
```

**并行生成方法：**
同样在并行生成方法中添加了相同的场景特定逻辑，确保两种生成模式都支持新场景。

#### 4.5 独立脚本更新
在 `data_processing/make_data.py` 中也进行了相应的更新：

**场景定义更新：**
```python
"if-else+caller": "Caller代码中包含if-else条件判断，根据不同的条件构建不同的filter参数传递给ORM方法，ORM方法根据传入的参数内容使用不同的筛选条件构建SQL查询"
```

**提示词选择逻辑：**
在串行和并行生成方法中都添加了场景特定的提示词选择逻辑，确保与主生成器保持一致。

#### 4.6 实现特点
- **全面覆盖**：所有相关的生成方法都支持新场景
- **一致性**：串行和并行生成模式使用相同的逻辑
- **可扩展性**：为未来添加新场景提供了模板
- **向后兼容**：不影响现有场景的生成

### 5. 新增"switch"场景完整实现

#### 5.1 场景特点分析
根据 `full_scenario.json` 中的真实例子，switch场景具有以下特点：

**ORM代码特点：**
```go
// ORM方法中的switch逻辑
switch o.CustomerType {
case External:
    filter["internal"] = 0
case Internal:
    filter["internal"] = 1
case Big:
    filter["big_customer"] = 1
case Small:
    filter["big_customer"] = 0
case Corporate:
    filter["corporate"] = 1
case Personal:
    filter["corporate"] = 0
default:
    return nil, utils.UnSupportedCustomerTypeError
}
```

**场景特点：**
- 使用switch语句根据不同的枚举值或状态构建不同的查询条件
- 每个case分支设置不同的filter条件或查询参数
- 必须包含default分支处理未知情况
- 使用常量或枚举值作为switch的判断条件

#### 5.2 提示词模板创建
在 `config/data_processing/synthetic_data_generator/prompts.py` 中创建了专门的提示词模板：

**PROMPT_ORM_SWITCH：**
- 要求ORM方法包含switch语句，根据不同的枚举值或状态构建不同的查询条件
- 要求switch语句至少包含4个不同的case分支
- 要求每个case分支设置不同的filter条件或查询参数
- 要求必须包含default分支处理未知情况
- 要求使用常量或枚举值作为switch的判断条件
- 代码长度控制在30行以内

**PROMPT_CALLER_SWITCH：**
- 要求Caller方法包含switch条件判断逻辑
- 要求至少包含4个不同的case分支
- 要求每个case分支设置不同的参数值或状态
- 要求必须包含default分支处理未知情况
- 要求使用常量或枚举值作为switch的判断条件
- 代码长度控制在35行以内

#### 5.3 生成器代码实现
在 `data_processing/synthetic_data_generator/generator.py` 中添加了switch场景的提示词选择逻辑：

**ORM提示词选择：**
```python
elif scenario == "switch":
    from config.data_processing.synthetic_data_generator.prompts import PROMPT_ORM_SWITCH
    orm_prompt = PROMPT_ORM_SWITCH.format(
        example=example_str,
        **var_names
    )
```

**Caller提示词选择：**
```python
elif scenario == "switch":
    from config.data_processing.synthetic_data_generator.prompts import PROMPT_CALLER_SWITCH
    caller_prompt = PROMPT_CALLER_SWITCH.format(
        orm_block=json.dumps(orm_block, ensure_ascii=False),
        example_caller=example_caller,
        **var_names
    )
```

#### 5.4 独立脚本更新
在 `data_processing/make_data.py` 中也添加了相同的switch场景支持，确保所有生成方法都支持新场景。

#### 5.5 实现特点
- **Switch逻辑**：专门针对switch语句的代码生成
- **枚举驱动**：基于枚举值或状态的条件判断
- **多分支支持**：至少4个case分支，确保足够的复杂性
- **错误处理**：包含default分支处理未知情况
- **一致性**：所有生成方法都支持switch场景

### 6. 关键特性

#### 场景驱动设计
支持多种业务场景:
- `对象var+chunk`: 依赖对象成员变量
- `caller+global variable`: 依赖全局变量  
- `preload特殊函数`: 预加载功能
- `association特殊函数`: 关联关系操作
- `if-else+caller`: **新增场景** - Caller包含条件判断，ORM根据参数动态调整查询策略
- `switch`: **新增场景** - ORM使用switch语句根据枚举值构建不同的查询条件
- 等等...

#### 变量名多样化
通过随机选择不同领域的变量名确保生成内容多样性:
- **实体名**: Product, Order, Customer, Account等
- **表名**: product_catalog, order_history, account_balances等
- **方法名**: QueryByCondition, ProcessPayment, CreateRecord等
- **字段名**: RecordId, CreationTime, CurrentStatus等

#### 并行处理能力
- 支持串行和并行两种生成模式
- 使用异步编程提高效率
- 线程安全的统计和日志记录

### 7. 输出数据结构
```json
{
    "synthetic_场景名_方法名": {
        "scenario": "场景标签",
        "code_key": "方法名", 
        "code_value": "完整的Go代码",
        "sql_pattern_cnt": 1,
        "callers": [
            {
                "code_key": "调用者方法名",
                "code_value": "调用者代码"
            }
        ],
        "code_meta_data": [
            {
                "code_key": "结构体名",
                "code_value": "类型定义代码"
            }
        ]
    }
}
```

### 8. 质量控制机制
- 自动格式验证确保LLM输出符合预期JSON格式
- 统计生成成功率和token使用量
- 支持重试和错误处理机制
- 线程安全的日志记录

### 9. 多样化保证机制
通过以下机制确保生成内容的多样性：
- **随机变量名**：从不同领域的名词库中随机选择
- **场景驱动**：不同场景生成不同类型的代码
- **样例参考**：参考真实样例但生成完全不同内容
- **参数随机化**：通过temperature等参数增加随机性

## 技术亮点
1. **智能提示词设计**: 三个专门的提示词模板确保生成内容的结构化
2. **多样化变量库**: 丰富的变量名词库确保生成内容的多样性
3. **异步并行处理**: 支持高并发生成，提高效率
4. **格式验证机制**: 确保生成数据的质量和一致性
5. **场景化配置**: 支持多种业务场景的定制化生成
6. **ORM代码生成机制**: 基于场景驱动的智能代码生成
7. **场景特定提示词**: 为不同场景提供专门的提示词模板，提高生成质量
8. **全面实现**: 所有相关文件都支持新场景，确保一致性
9. **Switch场景支持**: 专门针对switch语句的代码生成，支持枚举驱动的条件判断
10. **多分支逻辑**: 支持复杂的条件分支和错误处理

## 应用价值
这个生成器的核心价值在于能够根据不同的业务场景，自动生成高质量的、多样化的Go语言ORM代码样例，为机器学习模型提供丰富的训练数据，特别适用于代码到SQL转换模型的训练。新增的"if-else+caller"和"switch"场景进一步丰富了生成器的能力，能够生成更复杂的条件判断和动态查询逻辑，包括if-else条件判断、switch语句、枚举驱动的查询逻辑等。 