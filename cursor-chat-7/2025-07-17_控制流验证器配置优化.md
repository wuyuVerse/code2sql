# 控制流验证器配置优化

## 问题描述

用户反馈控制流验证器中的LLM调用没有使用配置文件中的设置，包括：
1. 没有使用配置文件中的最大重试次数（设置为10，但实际仍使用3次）
2. 没有使用配置文件中的重试延迟
3. 没有使用配置文件中的并发设置
4. 没有开启并发控制

## 解决方案

### 1. 添加配置文件管理器方法

在 `config/data_processing/workflow/workflow_config.py` 中添加了 `get_max_retries` 和 `get_retry_delay` 方法：

```python
def get_max_retries(self, module: str = None, component: str = None) -> int:
    """
    获取指定模块和组件的最大重试次数
    
    Args:
        module: 模块名称 (validation, workflow, synthetic_data_generator)
        component: 组件名称 (可选，如果不指定则使用模块的默认配置)
        
    Returns:
        最大重试次数
    """
    return self.config.retry.max_retries

def get_retry_delay(self, module: str = None, component: str = None) -> float:
    """
    获取指定模块和组件的重试延迟
    
    Args:
        module: 模块名称 (validation, workflow, synthetic_data_generator)
        component: 组件名称 (可选，如果不指定则使用模块的默认配置)
        
    Returns:
        重试延迟（秒）
    """
    return self.config.retry.retry_delay
```

### 2. 修复控制流验证器中的LLM调用

在 `data_processing/validation/control_flow_validator.py` 中修复了两个地方的LLM调用：

#### 2.1 修复 `validate_control_flow_records` 方法中的LLM调用

```python
# 从配置获取参数
from config.data_processing.workflow.workflow_config import get_workflow_config
from utils.llm_client import LLMClient
workflow_config = get_workflow_config()
max_tokens = workflow_config.get_max_tokens("validation", "control_flow_validator")
max_retries = workflow_config.get_max_retries("validation", "control_flow_validator")
retry_delay = workflow_config.get_retry_delay("validation", "control_flow_validator")

# 创建LLM客户端
llm_client = LLMClient(self.llm_server)

response = await llm_client.call_async_with_format_validation(
    session, 
    prompt, 
    validator=validate_json_format,
    max_tokens=max_tokens, 
    temperature=0.0,
    max_retries=max_retries,
    retry_delay=retry_delay,
    module="validation", component="control_flow_validator"
)
```

#### 2.2 修复 `_regenerate_sql_for_incorrect_record` 方法中的LLM调用

```python
# 从配置获取参数
from config.data_processing.workflow.workflow_config import get_workflow_config
workflow_config = get_workflow_config()
max_tokens = workflow_config.get_max_tokens("validation", "control_flow_validator")
max_retries = workflow_config.get_max_retries("validation", "control_flow_validator")
retry_delay = workflow_config.get_retry_delay("validation", "control_flow_validator")

response = await llm_client.call_async_with_format_validation(
    session,
    prompt,
    validator=validate_json_format,
    max_tokens=max_tokens,
    temperature=0.0,
    max_retries=max_retries,
    retry_delay=retry_delay,
    module="validation",
    component="control_flow_validator"
)
```

### 3. 添加并发控制

#### 3.1 在 `validate_control_flow_records` 方法中添加信号量控制

```python
# 创建信号量控制并发数
semaphore = asyncio.Semaphore(max_concurrent)

async def validate_with_semaphore(session: aiohttp.ClientSession, record: Dict[str, Any]) -> Dict[str, Any]:
    async with semaphore:
        return await validate_single_record(session, record)
```

#### 3.2 在重新生成SQL部分添加并发控制

```python
# 创建信号量控制重新生成的并发数
regen_semaphore = asyncio.Semaphore(max_concurrent)

async def regenerate_with_semaphore(session: aiohttp.ClientSession, result: Dict[str, Any], validation_result: Dict[str, Any]) -> Dict[str, Any]:
    async with regen_semaphore:
        regenerated_record = await self._regenerate_sql_for_incorrect_record(
            session, result['record'], validation_result
        )
        if regenerated_record:
            result['regenerated_sql'] = regenerated_record
            return result
        return result
```

## 配置文件设置

配置文件 `config/data_processing/workflow/workflow_config.yaml` 中的相关设置：

```yaml
# 重试设置
retry:
  max_retries: 10
  retry_delay: 1.0

# 格式验证设置
format_validation:
  max_retries: 10
  retry_delay: 1.0
  enabled: true
  modules:
    validation:
      control_flow_validator:
        max_retries: 10
        retry_delay: 1.0

# 并发设置
concurrency:
  control_flow_validation: 100
```

## 修改效果

1. **重试次数**：从硬编码的3次改为配置文件中的10次
2. **重试延迟**：从默认值改为配置文件中的1.0秒
3. **并发控制**：添加了信号量控制，确保并发数不超过配置文件设置
4. **配置统一**：所有LLM调用都从配置文件获取参数，避免硬编码

## 验证方法

可以通过以下方式验证修改是否生效：

1. 检查日志中的重试次数是否为10次
2. 检查并发处理是否受到控制
3. 检查LLM调用是否使用了配置文件中的参数

## 注意事项

1. 确保配置文件路径正确
2. 确保所有导入语句正确
3. 确保信号量控制不会影响性能
4. 确保错误处理机制完善

## 后续修复

### 问题描述
用户反馈控制流验证器没有检验是否符合特定模板，并且出现了文件路径错误。

### 解决方案

#### 1. 使用专门的格式验证器
将控制流验证器中的LLM调用改为使用专门的格式验证器：

```python
# 修改前
validator=validate_json_format

# 修改后  
validator=validate_control_flow_validation_response
```

#### 2. 添加正确的导入语句
```python
from utils.format_validators import validate_json_format, validate_control_flow_validation_response
```

#### 3. 改进文件保存逻辑
添加了更好的错误处理和目录创建逻辑：

```python
# 保存验证结果
try:
    validation_file = self.output_dir / "control_flow_validation_results.json"
    # 确保输出目录存在
    self.output_dir.mkdir(parents=True, exist_ok=True)
    
    with open(validation_file, 'w', encoding='utf-8') as f:
        json.dump({
            'validation_timestamp': datetime.now().isoformat(),
            'total_records': len(records),
            'validated_records': len(validated_records),
            'correct_records': correct_count,
            'incorrect_records': incorrect_count,
            'error_records': error_count,
            'validation_details': validated_records
        }, f, ensure_ascii=False, indent=2)
    
    logger.info(f"验证结果已保存到: {validation_file}")
except Exception as e:
    logger.error(f"保存验证结果失败: {e}")
    validation_file = None
```

#### 4. 改进问题记录报告保存
```python
problematic_file = None
if problematic_records:
    try:
        problematic_file = self.output_dir / "problematic_control_flow_records.json"
        # 确保输出目录存在
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        with open(problematic_file, 'w', encoding='utf-8') as f:
            json.dump(problematic_records, f, ensure_ascii=False, indent=2)
        logger.info(f"发现 {len(problematic_records)} 条有问题的控制流记录，已保存到: {problematic_file}")
    except Exception as e:
        logger.error(f"保存问题记录报告失败: {e}")
        problematic_file = None
```

### 修复效果

1. **模板验证**：现在使用专门的 `validate_control_flow_validation_response` 验证器，确保LLM响应符合控制流验证的特定模板
2. **文件路径错误**：添加了更好的错误处理和目录创建逻辑，避免文件保存失败
3. **错误处理**：改进了错误处理机制，即使文件保存失败也不会导致程序崩溃
4. **日志记录**：添加了详细的日志记录，便于调试和监控

## 冗余SQL验证器模板验证修复

### 问题描述
用户反馈冗余SQL验证器中的LLM调用也没有使用专门的格式验证器，而是使用了通用的 `validate_json_format`。

### 解决方案

#### 1. 修复新增指纹验证部分
在 `_validate_new_fingerprint_candidate` 方法中：

```python
# 修改前
validator=validate_json_format

# 修改后
validator=validate_redundant_sql_validation_response
```

#### 2. 修复缺失验证部分
在 `_validate_missing_candidate` 方法中：

```python
# 修改前
validator=validate_json_format

# 修改后
validator=validate_redundant_sql_validation_response
```

### 修复效果

1. **模板验证**：现在冗余SQL验证器的所有LLM调用都使用专门的 `validate_redundant_sql_validation_response` 验证器
2. **格式一致性**：确保LLM响应符合冗余SQL验证的特定模板结构
3. **验证准确性**：专门的验证器能够更好地验证响应格式，提高验证的准确性

### 验证方法

现在冗余SQL验证器将：
- 使用专门的格式验证器确保LLM响应符合冗余SQL验证模板
- 提供更好的格式验证和错误处理
- 确保所有验证步骤都使用正确的模板验证器

## 控制流SQL重新生成验证器创建

### 问题描述
用户反馈控制流验证器中重新生成SQL的部分还是使用了通用的 `validate_json_format`，没有使用专门的格式验证器。

### 解决方案

#### 1. 创建专门的控制流SQL重新生成验证器
在 `utils/format_validators.py` 中添加了 `validate_control_flow_sql_regeneration_response` 验证器：

```python
def validate_control_flow_sql_regeneration_response(response: str) -> Union[bool, Dict[str, Any]]:
    """验证控制流SQL重新生成响应
    
    Args:
        response: LLM响应内容
        
    Returns:
        True表示格式正确，Dict包含验证结果
    """
    # 首先尝试JSON数组格式验证
    json_result = validate_json_format(response)
    if json_result is True:
        try:
            # 尝试解析JSON数组
            if '```json' in response:
                json_match = re.search(r'```json\s*(\[.*?\])\s*```', response, re.DOTALL)
                if json_match:
                    data = json.loads(json_match.group(1))
                else:
                    return {
                        'valid': False,
                        'error': '未找到JSON数组内容',
                        'response': response[:200]
                    }
            else:
                data = json.loads(response)
            
            if not isinstance(data, list):
                return {
                    'valid': False,
                    'error': '响应不是JSON数组格式',
                    'data': data
                }
            
            # 验证数组中的每个元素
            for i, item in enumerate(data):
                if isinstance(item, str):
                    # 字符串应该是SQL语句
                    if not item.strip().endswith(';'):
                        return {
                            'valid': False,
                            'error': f'SQL语句 {i} 必须以分号结尾',
                            'item': item
                        }
                elif isinstance(item, dict):
                    # 字典应该是param_dependent类型
                    if item.get('type') != 'param_dependent':
                        return {
                            'valid': False,
                            'error': f'字典项 {i} 类型不是param_dependent',
                            'item': item
                        }
                    
                    variants = item.get('variants', [])
                    if not isinstance(variants, list):
                        return {
                            'valid': False,
                            'error': f'字典项 {i} 缺少variants数组',
                            'item': item
                        }
                    
                    for j, variant in enumerate(variants):
                        if not isinstance(variant, dict):
                            return {
                                'valid': False,
                                'error': f'变体 {j} 不是字典格式',
                                'variant': variant
                            }
                        
                        if 'scenario' not in variant or 'sql' not in variant:
                            return {
                                'valid': False,
                                'error': f'变体 {j} 缺少scenario或sql字段',
                                'variant': variant
                            }
                        
                        if not variant['sql'].strip().endswith(';'):
                            return {
                                'valid': False,
                                'error': f'变体 {j} 的SQL必须以分号结尾',
                                'variant': variant
                            }
                else:
                    return {
                        'valid': False,
                        'error': f'数组项 {i} 格式不正确',
                        'item': item
                    }
            
            return True
        except Exception as e:
            return {
                'valid': False,
                'error': f'解析控制流SQL重新生成响应失败: {str(e)}',
                'response': response[:200]
            }
    else:
        return json_result
```

#### 2. 添加验证器到映射表
```python
VALIDATORS = {
    # ... 其他验证器
    'control_flow_sql_regeneration': validate_control_flow_sql_regeneration_response,
}
```

#### 3. 修复控制流验证器中的重新生成SQL部分
```python
# 修改前
validator=validate_json_format,  # 重新生成SQL使用JSON格式验证器

# 修改后
validator=validate_control_flow_sql_regeneration_response,  # 使用专门的控制流SQL重新生成验证器
```

### 修复效果

1. **专门的格式验证**：创建了专门的控制流SQL重新生成验证器，确保LLM响应符合特定的JSON数组格式
2. **详细的格式检查**：验证器会检查：
   - 响应是否为JSON数组格式
   - 字符串项是否为有效的SQL语句（以分号结尾）
   - 字典项是否为param_dependent类型
   - 变体是否包含scenario和sql字段
   - 所有SQL语句是否以分号结尾
3. **错误处理**：提供详细的错误信息，便于调试和修复
4. **格式一致性**：确保所有控制流SQL重新生成都使用相同的格式验证标准

### 验证方法

现在控制流验证器将：
- 使用专门的格式验证器确保LLM响应符合控制流SQL重新生成的特定模板
- 提供详细的格式验证和错误处理
- 确保重新生成的SQL符合预期的JSON数组格式 