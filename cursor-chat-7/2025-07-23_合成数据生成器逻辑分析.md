# 2025-07-23 合成数据生成器逻辑分析与反向SQL生成器设计

## 对话概述

用户要求了解合成数据生成器的生成逻辑，我对其进行了全面的代码分析和架构梳理。随后用户提出了反向工作流的需求，我设计了一套完整的反向SQL生成器方案。

## 任务范围明确

### 分析目标
- 理解合成数据生成器的核心工作原理
- 分析代码架构和模块结构
- 了解数据生成流程和配置管理
- 掌握支持的场景类型和生成策略

### 涉及的核心文件
1. `data_processing/synthetic_data_generator/generator.py` - 核心生成逻辑
2. `data_processing/synthetic_data_generator/get_sql.py` - SQL生成和验证
3. `config/data_processing/synthetic_data_generator/config.py` - 配置管理
4. `config/data_processing/synthetic_data_generator/prompts.py` - 提示词模板
5. `data_processing/synthetic_data_generator/example_usage.py` - 使用示例
6. `data_processing/synthetic_data_generator/README.md` - 文档说明

## 核心架构分析

### 1. 生成器核心类 (SyntheticDataGenerator)

**主要功能：**
- 基于LLM生成合成ORM数据包
- 支持并行处理和批量生成
- 提供数据验证和统计监控

**关键方法：**
```python
class SyntheticDataGenerator:
    def __init__(self, config: SyntheticDataConfig)
    async def generate_pack(self, scenario: str) -> Dict
    async def generate_pack_parallel(self, scenario: str) -> Dict
    async def generate_multiple_packs_parallel(self, scenarios_and_counts: List[Tuple[str, int]]) -> Dict
    def validate_pack(self, pack: Dict) -> bool
```

### 2. 配置管理系统 (SyntheticDataConfig)

**配置项：**
- LLM服务器配置
- 场景定义和描述
- 变量名词库（表名、实体名、方法名等）
- 生成参数（温度、top_p、max_tokens等）

**支持的场景类型：**
1. **对象var+chunk** - ORM方法仅依赖接收者对象的成员变量
2. **caller+global variable** - 依赖外部全局常量或变量
3. **caller+chunk** - 需要调用者传递的参数chunks
4. **caller的callee+caller** - 形成调用链的ORM方法
5. **单chunk** - 最基础的CRUD操作
6. **单chunk+meta(global var)** - 使用单一数据块和全局变量
7. **preload特殊函数** - 使用预加载功能优化关联查询
8. **association特殊函数** - 处理关联关系操作
9. **单chunk+meta(local var)** - 依赖方法内部的局部变量
10. **单chunk+meta(对象var)** - 依赖对象成员变量
11. **一度caller+chunk** - 一层调用关系
12. **二度caller+chunk** - 两层调用关系
13. **对象const+chunk** - 依赖对象常量成员变量
14. **switch** - 使用switch条件语句构建动态查询
15. **if-else+caller** - Caller代码中包含if-else条件判断
16. **if-else+orm** - ORM方法内部包含if-else条件判断
17. **no-where** - 需要外部传入部分where条件

### 3. 提示词模板系统

**核心提示词：**
- `PROMPT_ORM` - 生成ORM方法的主要模板
- `PROMPT_ORM_IF_ELSE_CALLER` - if-else+caller场景专用模板
- `PROMPT_CALLER` - 生成调用者代码的模板
- `PROMPT_META` - 生成元数据的模板

**提示词特点：**
- 结构化JSON输出格式
- 多样化的变量名和实体名
- 基于真实样例但生成不同内容
- 支持不同业务域和逻辑结构

### 4. SQL生成和验证 (get_sql.py)

**主要功能：**
- 从ORM代码中提取SQL语句
- 验证SQL的正确性和完整性
- 格式化SQL输出
- 支持指数退避重试机制

**关键方法：**
```python
async def process_json_file_async(input_file, output_file, concurrency=80)
async def verify_sql_async(sql_statement, function_definition=None, ...)
async def format_sql_async(sql_statement, semaphore)
def validate_sql_completeness(sql_list)
```

## 数据生成流程

### 1. 初始化阶段
1. 加载配置文件 (`SyntheticDataConfig`)
2. 初始化LLM客户端 (`LLMClient`)
3. 加载场景样例数据 (`full_scenario.json`)
4. 设置生成参数和统计监控

### 2. 生成阶段
1. **场景选择** - 根据配置选择目标场景
2. **样例获取** - 从样例库中获取对应场景的参考样例
3. **提示词构建** - 使用模板构建LLM提示词
4. **LLM调用** - 调用LLM生成ORM代码
5. **响应解析** - 解析LLM响应并提取JSON
6. **数据验证** - 验证生成数据的格式正确性

### 3. 并行处理
- 支持多线程并行生成
- 使用线程池管理并发请求
- 提供统计监控和进度跟踪
- 自动重试失败的请求

### 4. 输出格式
```json
{
  "synthetic_scenario_method_name": {
    "scenario": "场景标签",
    "code_key": "方法名",
    "code_value": "完整的Go代码",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "调用者方法名",
        "code_value": "调用者代码"
      }
    ],
    "callees": [],
    "code_meta_data": [
      {
        "code_key": "结构体名",
        "code_value": "类型定义代码"
      }
    ]
  }
}
```

## 技术特点

### 1. 架构优势
- **模块化设计** - 配置、提示词、生成逻辑分离
- **类型安全** - 使用类型注解和验证
- **可扩展性** - 易于添加新场景和功能
- **错误处理** - 完善的异常处理和重试机制

### 2. 性能优化
- **并行处理** - 支持多线程并发生成
- **内存管理** - 分批处理大量数据
- **缓存机制** - 复用LLM连接和会话
- **统计监控** - 实时跟踪生成进度

### 3. 数据质量保证
- **格式验证** - 自动验证JSON格式正确性
- **内容验证** - 检查生成代码的完整性
- **样例参考** - 基于真实样例确保质量
- **多样化生成** - 避免重复和模式化

## 使用方式

### 1. 命令行接口
```bash
# 基本使用
python -m data_processing.synthetic_data_generator.cli

# 指定场景和数量
python -m data_processing.synthetic_data_generator.cli --scenario "单chunk" --count 5

# 并行模式
python -m data_processing.synthetic_data_generator.cli --parallel --workers 8 --count 10
```

### 2. 编程接口
```python
from config.data_processing.synthetic_data_generator.config import SyntheticDataConfig
from data_processing.synthetic_data_generator.generator import SyntheticDataGenerator

# 创建配置
config = SyntheticDataConfig(
    llm_server="v3",
    max_workers=4,
    temperature=0.7,
    max_tokens=2048
)

# 创建生成器
generator = SyntheticDataGenerator(config)

# 生成数据
pack = generator.generate_pack("单chunk")
```

## 反向SQL生成器设计方案

### 用户需求分析

用户提出了反向工作流的需求：
1. **生成完整的SQL查询** - 首先生成"全条件查询"作为基础
2. **生成对应的ORM代码和Caller代码** - 根据SQL生成相应的ORM和调用者代码
3. **通过减法生成其他SQL查询** - 通过对控制流的增加或删减生成其他SQL变体
4. **生成完整的案例** - 整合所有生成的代码成为完整案例

### 支持的场景类型

1. **if-else结构** - 简单条件判断，生成两条SQL查询
2. **if-else + caller + switch** - 复杂条件判断，生成多条SQL查询
3. **带固定参数的查询** - 固定条件，不需要条件判断
4. **动态条件查询** - 处理动态传入的多个条件，生成多条条件结合的SQL查询

### 核心架构设计

#### 1. 模块化组件架构
```
data_processing/reverse_sql_generator/
├── __init__.py              # 模块初始化
├── generator.py             # 核心生成器
├── sql_generator.py         # SQL生成器
├── orm_mapper.py           # ORM映射器
├── caller_generator.py      # Caller生成器
├── control_flow_processor.py # 控制流处理器
├── case_integrator.py       # 案例整合器
└── example_usage.py         # 使用示例
```

#### 2. 配置管理系统
```
config/data_processing/reverse_sql_generator/
├── config.py               # 配置管理
└── prompts.py              # 提示词模板
```

#### 3. 工作流程设计

**正向工作流（原有）**：
```
ORM代码 → Caller代码 → SQL生成
```

**反向工作流（新设计）**：
```
SQL生成 → ORM映射 → Caller生成 → 控制流处理 → 案例整合
```

### 核心功能实现

#### 1. SQL生成器 (SQLGenerator)
- 生成完整的"全条件查询"
- 支持不同复杂度级别（simple/medium/complex）
- 生成SQL变体（if-else、switch、动态条件）

#### 2. ORM映射器 (ORMMapper)
- 将SQL查询转换为Go语言ORM代码
- 使用GORM框架
- 支持动态参数传递

#### 3. Caller生成器 (CallerGenerator)
- 根据ORM代码生成调用者代码
- 支持if-else、switch、动态条件等复杂逻辑
- 包含参数验证和错误处理

#### 4. 控制流处理器 (ControlFlowProcessor)
- 处理if-else、switch等复杂控制流
- 生成对应的SQL变体
- 支持多层嵌套结构

#### 5. 案例整合器 (CaseIntegrator)
- 整合完整的案例数据
- 包含SQL、ORM、Caller、控制流等所有组件
- 生成标准化的输出格式

### 配置和提示词系统

#### 1. 场景配置
- **if-else+caller**: Caller代码中包含if-else条件判断
- **if-else+orm**: ORM方法内部包含if-else条件判断
- **switch**: 使用switch条件语句构建动态查询
- **dynamic_query**: 处理动态传入的多个条件
- **fixed_params**: 固定条件查询
- **complex_control**: 复杂控制流，包含多层嵌套

#### 2. 复杂度配置
- **simple**: 简单查询，基本SELECT、WHERE、ORDER BY
- **medium**: 中等复杂度，包含JOIN、GROUP BY、HAVING等
- **complex**: 复杂查询，包含子查询、窗口函数、复杂条件组合

#### 3. 提示词模板
- SQL生成提示词：生成完整SQL查询和变体
- ORM映射提示词：将SQL转换为ORM代码
- Caller生成提示词：生成调用者代码

### 使用方式

#### 1. 基本使用
```python
from config.data_processing.reverse_sql_generator.config import ReverseSQLConfig
from data_processing.reverse_sql_generator.generator import ReverseSQLGenerator

# 创建配置
config = ReverseSQLConfig(
    llm_server="v3",
    max_workers=4,
    temperature=0.7,
    max_tokens=2048
)

# 创建生成器
generator = ReverseSQLGenerator(config)

# 生成完整案例
case = await generator.generate_complete_case("if-else+caller", "simple")
```

#### 2. 特定场景生成
```python
# 生成if-else案例
if_else_case = await generator.generate_if_else_case("if-else+caller")

# 生成switch案例
switch_case = await generator.generate_switch_case("switch")

# 生成动态查询案例
dynamic_case = await generator.generate_dynamic_case("dynamic_query")
```

#### 3. 批量生成
```python
scenarios_and_complexities = [
    ("if-else+caller", "simple"),
    ("switch", "medium"),
    ("dynamic_query", "simple")
]

all_cases = await generator.generate_multiple_cases(scenarios_and_complexities)
```

### 输出格式

生成的案例包含完整的组件：
```json
{
  "reverse_if-else_caller_MethodName": {
    "scenario": "if-else+caller",
    "complexity": "simple",
    "base_sql": {
      "query": "完整的SQL查询",
      "table": "表名",
      "fields": ["字段1", "字段2"],
      "conditions": [...]
    },
    "orm_code": {
      "method_name": "方法名",
      "code": "完整的Go ORM代码",
      "parameters": [...],
      "return_type": "返回类型"
    },
    "caller_code": {
      "method_name": "调用者方法名",
      "code": "完整的Go调用者代码",
      "parameters": [...],
      "return_type": "返回类型"
    },
    "control_flow_sqls": [
      {
        "query": "SQL变体1",
        "branch": "if_branch_1",
        "description": "分支1描述"
      }
    ],
    "metadata": {
      "generated_at": "2025-07-23T10:30:00",
      "version": "1.0",
      "generator": "reverse_sql_generator"
    }
  }
}
```

## 总结

### 合成数据生成器特点
合成数据生成器是一个功能完善的ORM数据生成系统，具有以下核心特点：

1. **完整的架构设计** - 模块化、可扩展、类型安全
2. **丰富的场景支持** - 17种不同的ORM场景模式
3. **高效的并行处理** - 支持多线程并发生成
4. **可靠的质量保证** - 完善的验证和错误处理机制
5. **灵活的使用方式** - 支持命令行和编程接口

### 反向SQL生成器特点
反向SQL生成器是一个创新的反向工作流系统，具有以下核心特点：

1. **反向工作流设计** - 从SQL开始生成ORM和Caller代码
2. **SQL减法生成机制** - 通过控制流变化生成SQL变体
3. **复杂场景支持** - 支持if-else、switch、动态条件等复杂逻辑
4. **模块化架构** - 清晰的组件分离和职责划分
5. **完整的案例生成** - 整合所有组件成为完整案例
6. **工作流集成** - 完全集成到工作流管理器中
7. **命令行脚本** - 提供完整的命令行接口
8. **LLM客户端集成** - 使用统一的LLM客户端接口

### 完善后的系统架构

#### 1. 核心组件
- **ReverseSQLGenerator** - 反向SQL生成器核心类
- **SQLGenerator** - SQL生成器组件
- **ORMMapper** - ORM映射器组件
- **CallerGenerator** - Caller生成器组件
- **ControlFlowProcessor** - 控制流处理器组件
- **CaseIntegrator** - 案例整合器组件

#### 2. 工作流集成
- **WorkflowManager.generate_reverse_sql_data()** - 工作流管理器中的反向SQL生成方法
- **run_reverse_sql_generation_workflow()** - 完整工作流函数

#### 3. 脚本和示例
- **reverse_sql_generator.py** - 完整的反向SQL生成器脚本（合并了命令行接口和示例功能）

#### 4. 使用方式

**命令行使用**：
```bash
# 运行示例
python reverse_sql_generator.py --examples

# 基本使用
python reverse_sql_generator.py

# 指定场景
python reverse_sql_generator.py --scenarios if-else+caller switch dynamic_query

# 自定义参数
python reverse_sql_generator.py --llm-server v3 --temperature 0.8 --max-workers 6

# 生成多个数据包
python reverse_sql_generator.py --count-per-scenario 3 --scenarios if-else+caller
```

**编程接口使用**：
```python
from data_processing.workflow.workflow_manager import run_reverse_sql_generation_workflow

result = await run_reverse_sql_generation_workflow(
    scenarios=["if-else+caller", "switch"],
    count_per_scenario=2,
    llm_server="v3",
    temperature=0.7
)
```

**直接使用生成器**：
```python
from config.data_processing.reverse_sql_generator.config import ReverseSQLConfig
from data_processing.reverse_sql_generator.generator import ReverseSQLGenerator

config = ReverseSQLConfig(llm_server="v3")
generator = ReverseSQLGenerator(config)

case = await generator.generate_complete_case("if-else+caller", "simple")
```

这两个系统能够生成高质量的合成ORM数据，为AI训练和测试提供丰富的样本数据，支持正向和反向两种不同的生成策略，并且完全集成到现有的工作流系统中。 