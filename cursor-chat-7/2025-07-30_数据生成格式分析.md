# 数据生成格式分析总结

**日期**: 2025-07-30  
**主题**: 了解当前数据生成格式和合成数据生成器架构

## 1. 数据格式概览

### 1.1 full_scenario.json 结构

当前的数据格式基于 `datasets/full_scenario.json` 文件，该文件包含真实的ORM代码样本，每个样本具有以下结构：

```json
{
  "文件路径:行号:方法名": {
    "code_file": "文件路径",
    "code_start_line": 起始行号,
    "code_end_line": 结束行号,
    "code_start_column": 起始列号,
    "scenario": "场景标签",
    "code_key": "方法名",
    "code_value": "完整的Go代码",
    "code_label": 标签值,
    "code_type": 类型值,
    "code_version": "版本哈希",
    "sql_pattern_cnt": SQL模式数量,
    "callers": [
      {
        "code_file": "调用者文件路径",
        "code_start_line": 起始行号,
        "code_end_line": 结束行号,
        "code_key": "调用者方法名",
        "code_value": "调用者完整代码",
        "code_label": 标签值,
        "code_type": 类型值,
        "code_version": "版本哈希"
      }
    ],
    "callees": [],
    "code_meta_data": [
      {
        "code_file": "元数据文件路径",
        "code_start_line": 起始行号,
        "code_end_line": 结束行号,
        "code_key": "结构体/常量名",
        "code_value": "类型定义代码",
        "code_label": 标签值,
        "code_type": 类型值,
        "code_version": "版本哈希"
      }
    ]
  }
}
```

### 1.2 支持的场景类型

系统支持以下13种ORM场景模式：

1. **对象var+chunk** - ORM方法仅依赖接收者对象的成员变量
2. **caller+global variable** - 依赖外部全局常量或变量
3. **caller+chunk** - 需要调用者传递的参数chunks
4. **caller的callee+caller** - 形成调用链的ORM方法
5. **单chunk** - 最基础的CRUD操作
6. **单chunk+meta(global var)** - 使用单一数据块和全局变量
7. **preload特殊函数** - 使用预加载功能优化关联查询
8. **association特殊函数** - 处理关联关系操作
9. **单chunk+meta(local var)** - 依赖方法内部的局部变量
10. **单chunk+meta(对象var)** - 依赖对象成员变量
11. **一度caller+chunk** - 一层调用关系
12. **二度caller+chunk** - 两层调用关系
13. **对象const+chunk** - 依赖对象常量成员变量

## 2. 合成数据生成器架构

### 2.1 模块结构

```
data_processing/synthetic_data_generator/
├── __init__.py          # 模块初始化
├── config.py            # 配置管理
├── prompts.py           # 提示词模板
├── generator.py         # 核心生成逻辑
├── cli.py              # 命令行接口
├── get_sql.py          # SQL生成和验证
├── example_usage.py    # 使用示例
└── README.md           # 说明文档

config/data_processing/synthetic_data_generator/
├── config.py           # 配置类定义
└── prompts.py          # 提示词模板
```

### 2.2 核心组件

#### 2.2.1 配置管理 (config.py)

- **SyntheticDataConfig**: 配置类，管理LLM服务器、文件路径、生成参数等
- **SCENARIOS**: 场景定义和描述字典
- **VARIABLE_NAMES**: 变量名词库，确保生成不同的变量名

#### 2.2.2 提示词模板 (prompts.py)

- **PROMPT_ORM**: 基础ORM方法生成提示词
- **PROMPT_ORM_IF_ELSE_CALLER**: if-else+caller场景专用提示词
- **PROMPT_CALLER**: 调用者代码生成提示词
- **PROMPT_CALLER_IF_ELSE**: if-else+caller场景专用调用者提示词
- **PROMPT_META**: 元数据生成提示词

#### 2.2.3 核心生成器 (generator.py)

- **SyntheticDataGenerator**: 主要生成器类
- 支持并行和串行生成模式
- 包含数据验证和统计功能
- 使用LLMClient进行API调用

#### 2.2.4 SQL生成和验证 (get_sql.py)

- 从ORM代码中提取SQL语句
- SQL验证和格式化
- 支持条件字段映射分析
- 包含重试机制和错误处理

### 2.3 生成流程

1. **加载参考样例**: 从 `full_scenario.json` 加载真实样本
2. **场景匹配**: 根据场景标签找到对应的参考样例
3. **提示词构建**: 使用模板和变量名词库构建提示词
4. **LLM调用**: 通过LLMClient调用大语言模型
5. **数据验证**: 验证生成数据的格式正确性
6. **结果保存**: 保存到指定输出文件

## 3. 使用方式

### 3.1 命令行接口

```bash
# 生成所有场景的数据（每个场景1个包）
python -m data_processing.synthetic_data_generator.cli

# 生成指定场景的数据
python -m data_processing.synthetic_data_generator.cli --scenario "单chunk" --count 5

# 并行模式生成
python -m data_processing.synthetic_data_generator.cli --parallel --workers 8 --count 10

# 查看支持的场景
python -m data_processing.synthetic_data_generator.cli --list-scenarios

# 验证生成的数据
python -m data_processing.synthetic_data_generator.cli --validate --count 3
```

### 3.2 配置参数

- **--scenario**: 指定要生成的场景标签
- **--count**: 每个场景生成多少个包
- **--out**: 输出文件路径
- **--parallel**: 启用并行模式
- **--workers**: 并行worker数量
- **--llm-server**: LLM服务器名称
- **--temperature**: LLM温度参数
- **--max-tokens**: 最大token数

## 4. 数据质量保证

### 4.1 格式验证

- 自动验证JSON格式正确性
- 检查必需字段的完整性
- 验证代码语法和结构

### 4.2 多样性保证

- 使用变量名词库确保变量名不重复
- 支持多种业务领域（电商、金融、社交等）
- 场景特定的生成逻辑

### 4.3 错误处理

- 自动重试失败的LLM请求
- 详细的错误日志和统计信息
- 中间结果保存和恢复

## 5. 性能优化

### 5.1 并行处理

- 支持多线程并行生成
- 可配置的worker数量
- 自动负载均衡

### 5.2 内存管理

- 分批处理大量数据
- 及时释放不需要的资源
- 中间结果缓存

## 6. 与现有系统的集成

### 6.1 LLM客户端集成

- 使用项目的LLMClient替代直接API调用
- 支持多种LLM服务器配置
- 统一的错误处理和重试机制

### 6.2 配置系统集成

- 使用项目的配置管理架构
- 支持环境变量和配置文件
- 灵活的配置覆盖机制

## 7. 总结

当前的数据生成系统具有以下特点：

1. **完整性**: 支持13种不同的ORM场景模式
2. **可扩展性**: 模块化设计，易于添加新场景
3. **可靠性**: 包含完善的错误处理和验证机制
4. **高效性**: 支持并行处理，提高生成效率
5. **一致性**: 生成的数据格式与真实样本完全一致

该系统为ORM代码分析和SQL生成提供了高质量的合成数据，为后续的机器学习模型训练和测试提供了坚实的基础。

## 8. 新增场景：mutual_exclusive_conditions

### 8.1 场景特点

**mutual_exclusive_conditions** 是一个新增的场景，专门处理互斥条件的情况：

#### 核心特征：
1. **Caller层面**：使用 `if-else if-else if-else` 结构检查不同的参数（如appid、uid、name）
2. **ORM层面**：使用 `if-else` 逻辑处理不同的条件组合，每个条件对应不同的SQL查询策略
3. **互斥性**：条件之间互斥，不会同时出现，每次只会有一个条件生效

#### 典型模式：
```go
// Caller层面 - 互斥条件检查
if req.AppId > 0 {
    filter["app_id"] = req.AppId
} else if len(req.OwnerUin) > 0 {
    filter["uin"] = req.OwnerUin
} else if len(req.Name) > 0 {
    filter["name"] = req.Name
}

// ORM层面 - 互斥条件处理
if name, ok := filterSource["name"]; ok {
    // 使用模糊匹配策略
    query = query.Where("name like ?", "%"+name.(string)+"%")
} else {
    // 使用精确匹配策略
    query = query.Where(filterSource)
}
```

### 8.2 专用提示词

#### ORM生成提示词 (PROMPT_ORM_MUTUAL_EXCLUSIVE)
- 要求生成包含if-else逻辑的ORM方法
- 至少包含3个互斥条件分支
- 每个条件分支使用不同的查询策略
- 确保条件之间互斥

#### Caller生成提示词 (PROMPT_CALLER_MUTUAL_EXCLUSIVE)
- 要求生成包含if-else if-else if-else结构的调用者
- 每个条件分支检查不同的参数
- 确保条件之间互斥
- 正确传递参数给ORM方法

#### SQL生成提示词 (PROMPT_SQL_MUTUAL_EXCLUSIVE)
- 分析ORM代码中的if-else逻辑结构
- 生成基础SQL和多个SQL变体
- 每个SQL变体对应一个互斥条件
- 考虑不同条件对查询结果的影响

### 8.3 实现细节

#### 配置文件更新：
- 在 `config.py` 中添加场景定义
- 在 `prompts.py` 中添加专用提示词模板

#### 生成器支持：
- 在 `generator.py` 中添加场景处理逻辑，确保callers不为空
- 在 `get_sql.py` 中实现专业的SQL分析函数

#### SQL分析实现：
- **analyze_mutual_exclusive_sql()**: 使用标准分析提示词分析ORM代码，生成SQL语句
- **verify_mutual_exclusive_sql()**: 使用标准验证提示词验证SQL分析结果的准确性
- **generate_mutual_exclusive_sql()**: 使用专用提示词生成互斥条件的SQL变体

#### 测试验证：
- 创建 `test_mutual_exclusive.py` 测试脚本
- 包含完整的数据生成、SQL分析和验证流程
- 验证生成数据的格式和逻辑正确性

### 8.4 修正内容

#### 问题识别：
1. **WHERE条件过于简单**：只生成互斥条件，缺少其他无关的filter条件
2. **需要自由组合**：互斥条件应该与其他filter条件自由组合
3. **必须需要caller**：这个场景也应该确保callers不为空

#### 修正方案：

##### 1. 提示词优化
- **ORM提示词修正**：
  - 增加"除了互斥条件外，还必须包含其他无关的filter条件（如status、created_at、deleted_at等）"
  - 增加"其他filter条件应该与互斥条件自由组合，不相互影响"
  
- **Caller提示词修正**：
  - 增加"除了互斥条件外，还必须添加其他无关的filter条件"
  - 增加"其他filter条件应该与互斥条件自由组合，不相互影响"
  - 增加"确保caller不为空，因为filter条件信息依赖于caller的上下文"

##### 2. 生成器强制Caller生成
```python
elif scenario == "mutual_exclusive_conditions":
    # mutual_exclusive_conditions场景必须生成caller，因为filter条件信息依赖于caller
    self._thread_safe_print("  - mutual_exclusive_conditions场景必须生成caller...")
    # ... 生成逻辑 ...
    # 确保callers不为空
    if not caller_blocks:
        raise ValueError("mutual_exclusive_conditions场景必须生成caller，但生成的callers为空")
```

##### 3. 测试验证增强
- 验证ORM代码包含其他filter条件（status、created_at、deleted_at等）
- 验证Caller包含其他filter条件
- 验证SQL分析结果包含其他条件组合
- 确保callers不为空

#### 修正效果：
- ✅ WHERE条件更加丰富，包含互斥条件和其他filter条件的自由组合
- ✅ 确保callers不为空，符合业务需求
- ✅ 生成的SQL更加真实，符合实际业务场景

### 8.5 场景对比表

| 场景 | 特点 | 表名来源 | Caller要求 | SQL分析 |
|------|------|----------|------------|---------|
| mutual_exclusive_conditions | 互斥条件处理 | 硬编码或元数据 | 必须包含if-else逻辑 | 专用提示词 |
| table_name_from_caller | 动态表名 | 从caller传递 | 必须包含表名确定逻辑 | 标准分析函数 | 

### 8.6 新增场景：table_name_from_caller

#### 场景特点：
- **表名来源**: 表名信息从caller中传递过来，而不是在ORM方法内部硬编码
- **动态表名**: Caller负责确定具体的表名，ORM方法接收表名作为参数或通过其他方式获取
- **应用场景**: 适用于需要动态切换表名的场景，如多租户系统、分表查询等
- **强制要求**: 必须确保callers不为空，因为表名信息依赖于caller的上下文

#### 专用提示词设计：
- **PROMPT_ORM_TABLE_NAME_FROM_CALLER**: 生成接收表名参数的ORM方法
- **PROMPT_CALLER_TABLE_NAME_FROM_CALLER**: 生成确定表名并传递给ORM的调用者

#### 实现细节：
- 在 `config.py` 中添加场景定义
- 在 `prompts.py` 中添加专用提示词模板
- 在 `generator.py` 中添加场景处理逻辑，确保callers不为空
- 使用标准的SQL分析函数，无需修改get_sql.py

#### 生成要求：
- ORM方法必须接收表名参数（如tableName string）或通过其他方式从caller获取表名
- 不能硬编码表名，表名必须通过参数传递或动态获取
- 使用Table()方法设置动态表名
- Caller必须包含表名确定逻辑（如根据参数、配置、环境等确定表名）
- 确保callers不为空，因为表名信息依赖于caller的上下文

#### 测试验证：
- 创建 `test_table_name_from_caller.py` 测试脚本
- 验证ORM代码包含Table()方法调用
- 验证Caller包含表名确定逻辑
- 验证callers不为空
- 使用标准SQL分析函数进行SQL生成验证

### 8.7 场景对比表

| 场景 | 特点 | 表名来源 | Caller要求 | SQL分析 | 其他条件 |
|------|------|----------|------------|---------|----------|
| mutual_exclusive_conditions | 互斥条件处理 | 硬编码或元数据 | 必须包含if-else逻辑 | 专用提示词 | 自由组合其他filter条件 |
| table_name_from_caller | 动态表名 | 从caller传递 | 必须包含表名确定逻辑 | 标准分析函数 | 标准filter条件 | 