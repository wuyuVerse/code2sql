{
  "synthetic_if-else_caller_BulkUpdate": {
    "scenario": "if-else+caller",
    "code_key": "BulkUpdate",
    "code_value": "func (r *Refund) BulkUpdate(filter map[string]interface{}, updates map[string]interface{}) (int64, error) {\n\tvar affected int64\n\tvar err error\n\t\n\tif sessionToken, ok := filter[\"SessionToken\"]; ok {\n\t\terr = db.Get().Table(\"shipping_manifest\").\n\t\t\tWhere(\"session_token = ? AND status = 'pending'\", sessionToken).\n\t\t\tUpdates(updates).\n\t\t\tCount(&affected).Error\n\t} else if zone, ok := filter[\"Zone\"]; ok {\n\t\terr = db.Get().Table(\"shipping_manifest\").\n\t\t\tWhere(\"zone = ? AND format = ?\", zone, filter[\"Format\"]).\n\t\t\tUpdates(updates).\n\t\t\tCount(&affected).Error\n\t} else {\n\t\terr = db.Get().Table(\"shipping_manifest\").\n\t\t\tWhere(filter).\n\t\t\tUpdates(updates).\n\t\t\tCount(&affected).Error\n\t}\n\t\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn affected, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleShippingUpdate",
        "code_value": "func (h *ShippingHandler) HandleShippingUpdate(req *ShippingUpdateRequest) (int64, error) {\n\tif req == nil {\n\t\treturn 0, errors.New(\"nil request\")\n\t}\n\n\tfilter := make(map[string]interface{})\n\tupdates := make(map[string]interface{})\n\tupdates[\"status\"] = req.NewStatus\n\tupdates[\"updated_at\"] = time.Now()\n\n\tif req.SessionToken != \"\" {\n\t\tfilter[\"SessionToken\"] = req.SessionToken\n\t} else if req.ZoneID != 0 && req.ShippingFormat != \"\" {\n\t\tfilter[\"Zone\"] = req.ZoneID\n\t\tfilter[\"Format\"] = req.ShippingFormat\n\t} else if req.ManifestID != \"\" {\n\t\tfilter[\"manifest_id\"] = req.ManifestID\n\t} else {\n\t\treturn 0, errors.New(\"insufficient filter criteria\")\n\t}\n\n\trefundObj := &Refund{}\n\taffected, err := refundObj.BulkUpdate(filter, updates)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"bulk update failed: %v\", err)\n\t}\n\n\tif affected == 0 {\n\t\treturn 0, errors.New(\"no records updated\")\n\t}\n\n\treturn affected, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "ShippingManifest",
        "code_value": "type ShippingManifest struct {\n\tID           int       `json:\"id\" gorm:\"column:id\"`\n\tSessionToken string    `json:\"session_token\" gorm:\"column:session_token\"`\n\tZone         string    `json:\"zone\" gorm:\"column:zone\"`\n\tFormat       string    `json:\"format\" gorm:\"column:format\"`\n\tStatus       string    `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt    time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt    time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "Refund",
        "code_value": "type Refund struct {\n\tID        int       `json:\"id\" gorm:\"column:id\"`\n\tAmount    float64   `json:\"amount\" gorm:\"column:amount\"`\n\tReason    string    `json:\"reason\" gorm:\"column:reason\"`\n\tStatus    string    `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "StatusPending",
        "code_value": "const StatusPending = \"pending\""
      },
      {
        "code_key": "TableShippingManifest",
        "code_value": "const TableShippingManifest = \"shipping_manifest\""
      },
      {
        "code_key": "DefaultZone",
        "code_value": "var DefaultZone = \"east\""
      }
    ]
  },
  "synthetic_if-else_caller_ArchiveData": {
    "scenario": "if-else+caller",
    "code_key": "ArchiveData",
    "code_value": "func (p *Paragraph) ArchiveData(filterParams map[string]interface{}, pageSize int) ([]Asset, error) {\n\tvar assets []Asset\n\tdb := base.GetInstance().MainDB().Table(\"media_uploads\")\n\n\tif district, exists := filterParams[\"District\"]; exists {\n\t\tif className, exists := filterParams[\"ClassName\"]; exists {\n\t\t\tdb = db.Where(\"district = ? AND class_name LIKE ?\", district, \"%\"+className.(string)+\"%\")\n\t\t} else {\n\t\t\tdb = db.Where(\"district = ?\", district)\n\t\t}\n\t} else if longitude, exists := filterParams[\"Longitude\"]; exists {\n\t\tdb = db.Where(\"longitude > ?\", longitude)\n\t}\n\n\terr := db.Limit(pageSize).Order(\"created_at DESC\").Find(&assets).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn assets, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleMediaAssets",
        "code_value": "func (h *MediaHandler) HandleMediaAssets(req *MediaRequest) ([]Asset, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.DistrictID != \"\" {\n\t\tfilter[\"District\"] = req.DistrictID\n\t} else if req.MinLongitude > 0 {\n\t\tfilter[\"Longitude\"] = req.MinLongitude\n\t} else if req.Category != \"\" {\n\t\tfilter[\"ClassName\"] = req.Category\n\t} else {\n\t\treturn nil, fmt.Errorf(\"at least one filter parameter must be specified\")\n\t}\n\t\n\tpara := &Paragraph{}\n\tassets, err := para.ArchiveData(filter, req.PageSize)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to fetch media assets: %v\", err)\n\t}\n\t\n\tif len(assets) == 0 {\n\t\treturn nil, fmt.Errorf(\"no assets found matching the criteria\")\n\t}\n\t\n\treturn assets, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Asset",
        "code_value": "type Asset struct {\n\tID          uint      `json:\"id\" gorm:\"column:id\"`\n\tDistrict    string    `json:\"district\" gorm:\"column:district\"`\n\tClassName   string    `json:\"class_name\" gorm:\"column:class_name\"`\n\tLongitude   float64   `json:\"longitude\" gorm:\"column:longitude\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tMediaURL    string    `json:\"media_url\" gorm:\"column:media_url\"`\n}"
      },
      {
        "code_key": "FilterParams",
        "code_value": "type FilterParams struct {\n\tDistrict   string\n\tClassName  string\n\tLongitude  float64\n}"
      },
      {
        "code_key": "MediaUploadTable",
        "code_value": "const MediaUploadTable = \"media_uploads\""
      },
      {
        "code_key": "MaxPageSize",
        "code_value": "const MaxPageSize = 100"
      }
    ]
  },
  "synthetic_if-else_caller_ManageResources": {
    "scenario": "if-else+caller",
    "code_key": "ManageResources",
    "code_value": "func (h *Hospital) ManageResources(filterParams map[string]interface{}, pageSize int) ([]types.ResourceAllocation, error) {\n\tvar allocations []types.ResourceAllocation\n\tdb := base.GetInstance().MainDB().Table(\"budget_planning\")\n\n\tif dept, ok := filterParams[\"Department\"]; ok {\n\t\tif priority, hasPriority := filterParams[\"SecurityLevel\"]; hasPriority {\n\t\tdb = db.Where(\"department = ? AND security_level >= ?\", dept, priority)\n\t} else {\n\t\tdb = db.Where(\"department LIKE ?\", \"%\"+dept.(string)+\"%\")\n\t}\n\t} else if editor, ok := filterParams[\"Editor\"]; ok {\n\t\tdb = db.Where(\"editor = ? AND status = 'active'\", editor)\n\t}\n\n\terr := db.Scopes(PaginateDB(1, pageSize)).Find(&allocations).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn allocations, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleResourceAllocation",
        "code_value": "func (c *ResourceController) HandleResourceAllocation(req *types.ResourceRequest, logger *zap.Logger) ([]types.ResourceAllocation, error) {\n\tfilter := make(map[string]interface{})\n\tif req.DepartmentID != \"\" {\n\t\tfilter[\"Department\"] = req.DepartmentID\n\t\tif req.HighPriority {\n\t\t\tfilter[\"SecurityLevel\"] = 3\n\t\t}\n\t} else if req.ManagerID != 0 {\n\t\tfilter[\"Editor\"] = req.ManagerID\n\t} else if req.ProjectName != \"\" {\n\t\tif len(req.ProjectName) > 50 {\n\t\t\tlogger.Error(\"project name too long\", zap.String(\"project\", req.ProjectName))\n\t\t\treturn nil, errors.New(\"invalid project name\")\n\t\t}\n\t\tfilter[\"Department\"] = req.ProjectName\n\t} else {\n\t\treturn nil, errors.New(\"no valid filter parameters provided\")\n\t}\n\n\thospital := &Hospital{DB: c.DB}\n\tallocations, err := hospital.ManageResources(filter, req.PageSize)\n\tif err != nil {\n\t\tlogger.Error(\"failed to manage resources\", zap.Error(err))\n\t\treturn nil, fmt.Errorf(\"resource allocation error: %w\", err)\n\t}\n\treturn allocations, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "ResourceAllocation",
        "code_value": "type ResourceAllocation struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tDepartment    string    `json:\"department\" gorm:\"column:department\"`\n\tSecurityLevel int       `json:\"security_level\" gorm:\"column:security_level\"`\n\tEditor        string    `json:\"editor\" gorm:\"column:editor\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n\tAllocatedAt   time.Time `json:\"allocated_at\" gorm:\"column:allocated_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "BudgetTable",
        "code_value": "const BudgetTable = \"budget_planning\""
      },
      {
        "code_key": "ResourceStatus",
        "code_value": "const (\n\tStatusActive = \"active\"\n\tStatusPending = \"pending\"\n\tStatusArchived = \"archived\"\n)"
      },
      {
        "code_key": "DepartmentCache",
        "code_value": "var DepartmentCache = map[string]int{\n\t\"Cardiology\": 1,\n\t\"Neurology\": 2,\n\t\"Orthopedics\": 3,\n\t\"Pediatrics\": 4,\n}"
      },
      {
        "code_key": "AuditRecord",
        "code_value": "type AuditRecord struct {\n\tID        int       `json:\"id\" gorm:\"column:id\"`\n\tAction    string    `json:\"action\" gorm:\"column:action\"`\n\tEditor    string    `json:\"editor\" gorm:\"column:editor\"`\n\tCreatedAt time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tDetails   string    `json:\"details\" gorm:\"column:details\"`\n}"
      }
    ]
  },
  "synthetic_if-else_caller_AggregateByType": {
    "scenario": "if-else+caller",
    "code_key": "AggregateByType",
    "code_value": "func (a *Armor) AggregateByType(filterParams map[string]interface{}) ([]types.TrainingCertification, error) {\n    var results []types.TrainingCertification\n    db := base.GetInstance().GormDB().Table(\"training_certifications\")\n    \n    if certType, ok := filterParams[\"CertificateType\"]; ok {\n        db = db.Where(\"certificate_type = ?\", certType)\n        if level, exists := filterParams[\"AccessLevel\"]; exists {\n            db = db.Where(\"access_level > ?\", level)\n        }\n    } else if locale, ok := filterParams[\"Locale\"]; ok {\n        db = db.Where(\"locale LIKE ?\", \"%\"+locale.(string)+\"%\")\n    }\n    \n    if err := db.Find(&results).Error; err != nil {\n        if err == gorm.ErrRecordNotFound {\n            return results, nil\n        }\n        return nil, err\n    }\n    return results, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleTrainingCertification",
        "code_value": "func (t *TrainingHandler) HandleTrainingCertification(req *types.CertificationRequest) ([]types.TrainingCertification, error) {\n    filterParams := make(map[string]interface{})\n    \n    if req.CertType != \"\" {\n        filterParams[\"CertificateType\"] = req.CertType\n        if req.MinAccessLevel > 0 {\n            filterParams[\"AccessLevel\"] = req.MinAccessLevel\n        }\n    } else if req.Region != \"\" {\n        if len(req.Region) < 2 {\n            return nil, fmt.Errorf(\"invalid region code\")\n        }\n        filterParams[\"Locale\"] = req.Region\n    } else if req.Status != \"\" {\n        if req.Status != \"active\" && req.Status != \"expired\" {\n            return nil, fmt.Errorf(\"invalid status value\")\n        }\n        filterParams[\"Status\"] = req.Status\n    }\n    \n    armor := &Armor{}\n    certs, err := armor.AggregateByType(filterParams)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to aggregate certifications: %v\", err)\n    }\n    \n    return certs, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "TrainingCertification",
        "code_value": "type TrainingCertification struct {\n\tID              int       `json:\"id\" gorm:\"column:id\"`\n\tCertificateType string    `json:\"certificate_type\" gorm:\"column:certificate_type\"`\n\tAccessLevel     int       `json:\"access_level\" gorm:\"column:access_level\"`\n\tLocale          string    `json:\"locale\" gorm:\"column:locale\"`\n\tCreatedAt       time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt       time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "Armor",
        "code_value": "type Armor struct {\n\tDB *gorm.DB\n}"
      },
      {
        "code_key": "TrainingFilterParams",
        "code_value": "type TrainingFilterParams struct {\n\tCertificateType string\n\tAccessLevel     int\n\tLocale          string\n}"
      },
      {
        "code_key": "TableNameTrainingCertifications",
        "code_value": "const TableNameTrainingCertifications = \"training_certifications\""
      },
      {
        "code_key": "DefaultAccessLevel",
        "code_value": "const DefaultAccessLevel = 1"
      }
    ]
  },
  "synthetic_if-else_caller_CacheData": {
    "scenario": "if-else+caller",
    "code_key": "CacheData",
    "code_value": "func (a *Achievement) CacheData(filters map[string]interface{}, limit int) ([]types.SecurityClearance, error) {\n\tvar results []types.SecurityClearance\n\tdb := base.GetInstance().GormDriver().Table(\"security_clearances\")\n\n\tif namespace, ok := filters[\"NamespaceName\"]; ok {\n\t\tif appId, exists := filters[\"ApplicationId\"]; exists {\n\t\t\tdb = db.Where(\"namespace_name = ? AND application_id = ?\", namespace, appId)\n\t\t} else {\n\t\t\tdb = db.Where(\"namespace_name LIKE ?\", \"%\"+namespace.(string)+\"%\")\n\t\t}\n\t} else if content, ok := filters[\"Content\"]; ok {\n\t\tdb = db.Where(\"content LIKE ?\", \"%\"+content.(string)+\"%\")\n\t}\n\n\terr := db.Limit(limit).Find(&results).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleUserClearance",
        "code_value": "func (h *Handler) HandleUserClearance(req *types.ClearanceRequest, log *logger.AppLog) ([]types.SecurityClearance, error) {\n\tfilters := make(map[string]interface{})\n\t\n\tif req.UserID != \"\" {\n\t\tfilters[\"user_id\"] = req.UserID\n\t} else if req.Department != \"\" {\n\t\tif req.Level > 0 {\n\t\t\tfilters[\"department\"] = req.Department\n\t\t\tfilters[\"clearance_level\"] = req.Level\n\t\t} else {\n\t\t\tfilters[\"department\"] = req.Department\n\t\t}\n\t} else if req.ClearanceType != \"\" {\n\t\tfilters[\"clearance_type\"] = req.ClearanceType\n\t} else {\n\t\treturn nil, fmt.Errorf(\"at least one filter parameter must be provided\")\n\t}\n\n\tach := &Achievement{}\n\tresult, err := ach.CacheData(filters, req.Limit)\n\tif err != nil {\n\t\tlog.Error(\"Failed to get clearance data\", \"error\", err)\n\t\treturn nil, err\n\t}\n\t\n\treturn result, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "SecurityClearance",
        "code_value": "type SecurityClearance struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tNamespaceName string    `json:\"namespace_name\" gorm:\"column:namespace_name\"`\n\tApplicationId int       `json:\"application_id\" gorm:\"column:application_id\"`\n\tContent       string    `json:\"content\" gorm:\"column:content\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "ClearanceFilter",
        "code_value": "type ClearanceFilter struct {\n\tNamespaceName string\n\tApplicationId int\n\tContent       string\n}"
      },
      {
        "code_key": "ClearanceResponse",
        "code_value": "type ClearanceResponse struct {\n\tData      []SecurityClearance `json:\"data\"`\n\tTotal     int                 `json:\"total\"`\n\tPage      int                 `json:\"page\"`\n\tLimit     int                 `json:\"limit\"`\n\tTimestamp time.Time           `json:\"timestamp\"`\n}"
      },
      {
        "code_key": "TableSecurityClearances",
        "code_value": "const TableSecurityClearances = \"security_clearances\""
      },
      {
        "code_key": "DefaultQueryLimit",
        "code_value": "const DefaultQueryLimit = 100"
      },
      {
        "code_key": "SecurityStatus",
        "code_value": "const (\n\tStatusPending = iota\n\tStatusApproved\n\tStatusRejected\n)"
      },
      {
        "code_key": "GlobalClearanceCache",
        "code_value": "var GlobalClearanceCache = sync.Map{}"
      }
    ]
  },
  "synthetic_if-else_caller_SelectByRange": {
    "scenario": "if-else+caller",
    "code_key": "SelectByRange",
    "code_value": "func (g *Game) SelectByRange(filter map[string]interface{}, page, size int) ([]types.TournamentRecord, error) {\n\tvar records []types.TournamentRecord\n\tdb := base.GetInstance().Gorm().Table(\"tournament_brackets\").Scopes(PaginateDB(page, size))\n\n\tif module, ok := filter[\"ModuleName\"]; ok {\n\t\tdb = db.Where(\"module_name = ?\", module)\n\t\tif status, exists := filter[\"CurrentStatus\"]; exists {\n\t\t\tdb = db.Where(\"current_status = ?\", status)\n\t\t}\n\t} else if mobile, ok := filter[\"MobileNumber\"]; ok {\n\t\tdb = db.Where(\"mobile_number LIKE ?\", \"%\"+mobile.(string)+\"%\")\n\t} else {\n\t\tdb = db.Where(filter)\n\t}\n\n\terr := db.Order(\"created_at DESC\").Find(&records).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.RecordNotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleDoctorSchedule",
        "code_value": "func (s *ScheduleService) HandleDoctorSchedule(req *types.ScheduleRequest) ([]types.DoctorSchedule, error) {\n\tfilter := make(map[string]interface{})\n\tif req.DoctorID > 0 {\n\t\tfilter[\"doctor_id\"] = req.DoctorID\n\t} else if len(req.Department) > 0 {\n\t\tif len(req.Department) > 50 {\n\t\t\treturn nil, errors.New(\"department name too long\")\n\t\t}\n\t\tfilter[\"department\"] = req.Department\n\t} else if !req.StartDate.IsZero() && !req.EndDate.IsZero() {\n\t\tif req.EndDate.Before(req.StartDate) {\n\t\t\treturn nil, errors.New(\"end date must be after start date\")\n\t\t}\n\t\tfilter[\"date\"] = map[string]interface{}{\"$gte\": req.StartDate, \"$lte\": req.EndDate}\n\t} else {\n\t\treturn nil, errors.New(\"at least one filter condition required\")\n\t}\n\n\tdoctor := &model.Doctor{}\n\tschedules, err := doctor.SelectByRange(filter, req.Page, req.PageSize)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to query schedules: %w\", err)\n\t}\n\treturn schedules, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "TournamentRecord",
        "code_value": "type TournamentRecord struct {\n\tID            uint      `gorm:\"column:id;primaryKey\"`\n\tModuleName    string    `gorm:\"column:module_name\"`\n\tCurrentStatus int       `gorm:\"column:current_status\"`\n\tMobileNumber  string    `gorm:\"column:mobile_number\"`\n\tCreatedAt     time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "TournamentStatus",
        "code_value": "const (\n\tStatusPending = iota + 1\n\tStatusInProgress\n\tStatusCompleted\n\tStatusCancelled\n)"
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "TournamentFilter",
        "code_value": "type TournamentFilter struct {\n\tModuleName    string\n\tCurrentStatus int\n\tMobileNumber  string\n\tStartDate     time.Time\n\tEndDate       time.Time\n}"
      },
      {
        "code_key": "TournamentResponse",
        "code_value": "type TournamentResponse struct {\n\tRecords      []TournamentRecord `json:\"records\"`\n\tTotalCount   int                `json:\"total_count\"`\n\tCurrentPage  int                `json:\"current_page\"`\n\tTotalPages   int                `json:\"total_pages\"`\n}"
      }
    ]
  },
  "synthetic_if-else_caller_PurgeExpiredRecords": {
    "scenario": "if-else+caller",
    "code_key": "PurgeExpiredRecords",
    "code_value": "func (e *Event) PurgeExpiredRecords(filters map[string]interface{}) ([]types.NotificationEvent, error) {\n\tvar events []types.NotificationEvent\n\tquery := base.GetInstance().GormDB().Table(\"notification_queue\").Where(\"expired_at < NOW()\")\n\n\tif editor, ok := filters[\"Editor\"]; ok {\n\t\tquery = query.Where(\"editor = ? AND status = ?\", editor.(string), \"pending\")\n\t} else if timezone, ok := filters[\"Timezone\"]; ok {\n\t\tquery = query.Where(\"timezone IN (?) AND priority > 5\", timezone.([]string))\n\t} else {\n\t\tquery = query.Where(filters)\n\t}\n\n\tif err := query.Find(&events).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn events, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleExpiredNotifications",
        "code_value": "func (h *NotificationHandler) HandleExpiredNotifications(req *types.ExpiredNotificationRequest) ([]types.NotificationEvent, error) {\n\tfilters := make(map[string]interface{})\n\t\n\tif req.UserID != \"\" {\n\t\tfilters[\"Editor\"] = req.UserID\n\t} else if len(req.Regions) > 0 {\n\t\tfilters[\"Timezone\"] = req.Regions\n\t} else if req.PriorityThreshold > 0 {\n\t\tfilters[\"priority\"] = req.PriorityThreshold\n\t} else {\n\t\tfilters[\"status\"] = \"expired\"\n\t}\n\n\tevent := &Event{}\n\texpiredEvents, err := event.PurgeExpiredRecords(filters)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to purge expired records: %v\", err)\n\t}\n\n\tif len(expiredEvents) == 0 {\n\t\treturn nil, nil\n\t}\n\treturn expiredEvents, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "NotificationEvent",
        "code_value": "type NotificationEvent struct {\n\tID        uint      `gorm:\"column:id;primaryKey\"`\n\tEditor    string    `gorm:\"column:editor\"`\n\tStatus    string    `gorm:\"column:status\"`\n\tTimezone  string    `gorm:\"column:timezone\"`\n\tPriority  int       `gorm:\"column:priority\"`\n\tExpiredAt time.Time `gorm:\"column:expired_at\"`\n\tCreatedAt time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "EventFilter",
        "code_value": "type EventFilter struct {\n\tEditor   string\n\tTimezone []string\n\tStatus   string\n\tPriority int\n}"
      },
      {
        "code_key": "NotificationStatus",
        "code_value": "const (\n\tStatusPending   = \"pending\"\n\tStatusSent     = \"sent\"\n\tStatusFailed   = \"failed\"\n\tStatusCanceled = \"canceled\"\n)"
      },
      {
        "code_key": "TableName",
        "code_value": "const NotificationQueueTable = \"notification_queue\""
      },
      {
        "code_key": "PriorityThreshold",
        "code_value": "const HighPriorityThreshold = 5"
      }
    ]
  },
  "synthetic_if-else_caller_MonitorActivity": {
    "scenario": "if-else+caller",
    "code_key": "MonitorActivity",
    "code_value": "func (a *Account) MonitorActivity(filterParams map[string]interface{}, limit int) ([]types.Statement, error) {\n\tvar activities []types.Statement\n\tquery := base.GetInstance().GormDB().Table(\"exam_results\")\n\n\tif projectCode, exists := filterParams[\"ProjectCode\"]; exists {\n\t\tquery = query.Where(\"project_code = ?\", projectCode)\n\t\tif shipmentId, ok := filterParams[\"ShipmentId\"]; ok {\n\t\t\tquery = query.Where(\"shipment_id = ?\", shipmentId)\n\t\t}\n\t} else if columnName, exists := filterParams[\"ColumnName\"]; exists {\n\t\tquery = query.Where(\"column_name LIKE ?\", \"%\"+columnName.(string)+\"%\")\n\t}\n\n\tif limit > 0 {\n\t\tquery = query.Limit(limit)\n\t}\n\n\terr := query.Order(\"created_at DESC\").Find(&activities).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn activities, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleGameStatements",
        "code_value": "func (g *GameHandler) HandleGameStatements(req *types.GameStatementRequest) ([]types.Statement, error) {\n\tfilter := make(map[string]interface{})\n\tif req.GameID != \"\" {\n\t\tfilter[\"ProjectCode\"] = req.GameID\n\t\tif req.SessionID != \"\" {\n\t\t\tfilter[\"ShipmentId\"] = req.SessionID\n\t\t}\n\t} else if req.PlayerName != \"\" {\n\t\tif len(req.PlayerName) < 3 {\n\t\t\treturn nil, fmt.Errorf(\"player name must be at least 3 characters\")\n\t\t}\n\t\tfilter[\"ColumnName\"] = req.PlayerName\n\t} else if req.Status > 0 {\n\t\tfilter[\"status\"] = req.Status\n\t} else {\n\t\treturn nil, fmt.Errorf(\"at least one filter parameter is required\")\n\t}\n\n\taccount := &Account{}\n\tlimit := 0\n\tif req.Limit > 0 {\n\t\tlimit = req.Limit\n\t}\n\n\tstatements, err := account.MonitorActivity(filter, limit)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to monitor game activity: %v\", err)\n\t}\n\n\treturn statements, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Statement",
        "code_value": "type Statement struct {\n\tID          int       `json:\"id\" gorm:\"column:id\"`\n\tProjectCode string    `json:\"project_code\" gorm:\"column:project_code\"`\n\tShipmentId  string    `json:\"shipment_id\" gorm:\"column:shipment_id\"`\n\tColumnName  string    `json:\"column_name\" gorm:\"column:column_name\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "ActivityFilter",
        "code_value": "type ActivityFilter struct {\n\tProjectCode string\n\tShipmentId  string\n\tColumnName  string\n\tLimit       int\n}"
      },
      {
        "code_key": "ExamResultTable",
        "code_value": "const ExamResultTable = \"exam_results\""
      },
      {
        "code_key": "DefaultQueryLimit",
        "code_value": "const DefaultQueryLimit = 100"
      },
      {
        "code_key": "ActivityResponse",
        "code_value": "type ActivityResponse struct {\n\tStatements []Statement `json:\"statements\"`\n\tError      string      `json:\"error,omitempty\"`\n}"
      }
    ]
  },
  "synthetic_if-else_caller_MeasureEfficiency": {
    "scenario": "if-else+caller",
    "code_key": "MeasureEfficiency",
    "code_value": "func (z *Zone) MeasureEfficiency(filters map[string]interface{}, page, size int) ([]types.EfficiencyMetric, error) {\n\tmetrics := make([]types.EfficiencyMetric, 0)\n\tvar err error\n\tcomment := z.CommentFunc(SELECT_COMMENT)\n\tdb := base.GetInstance().GormDriver().Clauses(comment).Table(\"treatment_plans\")\n\n\tif functionName, exists := filters[\"FunctionName\"]; exists {\n\t\tfilter := make(map[string]interface{})\n\t\tfor k, v := range filters {\n\t\t\tif k == \"FunctionName\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfilter[k] = v\n\t\t}\n\t\terr = db.Where(\"function_name LIKE ?\", \"%\"+functionName.(string)+\"%\").\n\t\t\tOrder(\"created_at DESC\").\n\t\t\tScopes(PaginateDB(page, size)).\n\t\t\tFind(&metrics).Error\n\t} else if certificateId, exists := filters[\"CertificateId\"]; exists {\n\t\terr = db.Where(\"certificate_id = ? AND status = ?\", certificateId, \"active\").\n\t\t\tOrder(\"updated_at\").\n\t\t\tScopes(PaginateDB(page, size)).\n\t\t\tFind(&metrics).Error\n\t} else {\n\t\terr = db.Where(filters).\n\t\t\tScopes(PaginateDB(page, size)).\n\t\t\tFind(&metrics).Error\n\t}\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn metrics, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleTimelineMetrics",
        "code_value": "func (h *TimelineHandler) HandleTimelineMetrics(req *types.TimelineRequest, log *logger.AppLog) ([]types.EfficiencyMetric, error) {\n\tzone := &Zone{CommentFunc: DefaultCommentGenerator}\n\tfilters := make(map[string]interface{})\n\tpage, size := utils.ParsePagination(req.Page, req.Size)\n\n\tif req.TreatmentID != \"\" {\n\t\tfilters[\"treatment_id\"] = req.TreatmentID\n\t} else if req.PatientName != \"\" {\n\t\tif err := validatePatientName(req.PatientName); err != nil {\n\t\t\tlog.Error(\"Invalid patient name\", \"error\", err)\n\t\t\treturn nil, err\n\t\t}\n\t\tfilters[\"FunctionName\"] = req.PatientName\n\t} else if req.Status != \"\" {\n\t\tif !isValidStatus(req.Status) {\n\t\t\tlog.Error(\"Invalid status value\", \"status\", req.Status)\n\t\t\treturn nil, fmt.Errorf(\"invalid status: %s\", req.Status)\n\t\t}\n\t\tfilters[\"status\"] = req.Status\n\t\tfilters[\"CertificateId\"] = req.CertificateID\n\t} else {\n\t\tfilters[\"department\"] = req.Department\n\t}\n\n\tmetrics, err := zone.MeasureEfficiency(filters, page, size)\n\tif err != nil {\n\t\tlog.Error(\"Failed to measure efficiency\", \"error\", err)\n\t\treturn nil, fmt.Errorf(\"measurement failed: %w\", err)\n\t}\n\treturn metrics, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "EfficiencyMetric",
        "code_value": "type EfficiencyMetric struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tFunctionName  string    `json:\"function_name\" gorm:\"column:function_name\"`\n\tCertificateId string    `json:\"certificate_id\" gorm:\"column:certificate_id\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n\tEfficiency    float64   `json:\"efficiency\" gorm:\"column:efficiency\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "TreatmentPlanStatus",
        "code_value": "const (\n\tTreatmentPlanActive   = \"active\"\n\tTreatmentPlanInactive = \"inactive\"\n\tTreatmentPlanDraft    = \"draft\"\n)"
      },
      {
        "code_key": "SELECT_COMMENT",
        "code_value": "const SELECT_COMMENT = \"/* MeasureEfficiency */\""
      },
      {
        "code_key": "Zone",
        "code_value": "type Zone struct {\n\tCommentFunc func(string) string\n}"
      }
    ]
  },
  "synthetic_if-else_caller_QueryByCondition": {
    "scenario": "if-else+caller",
    "code_key": "QueryByCondition",
    "code_value": "func (p *Proposal) QueryByCondition(filter map[string]interface{}, page, size int) ([]types.ProposalRecord, error) {\n\trecords := make([]types.ProposalRecord, 0)\n\tquery := base.GetInstance().GormDriver().Table(\"progress_tracking\").Scopes(PaginateDB(page, size))\n\n\tif approval, ok := filter[\"ApprovalLevel\"]; ok {\n\t\tquery = query.Where(\"approval_level = ?\", approval)\n\t\tdelete(filter, \"ApprovalLevel\")\n\t} else if timezone, ok := filter[\"Timezone\"]; ok {\n\t\tquery = query.Where(\"timezone LIKE ?\", \"%\"+timezone.(string)+\"%\")\n\t\tdelete(filter, \"Timezone\")\n\t}\n\n\tif len(filter) > 0 {\n\t\tquery = query.Where(filter)\n\t}\n\n\terr := query.Order(\"created_at DESC\").Find(&records).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn records, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleInvestmentProposals",
        "code_value": "func (h *InvestmentHandler) HandleInvestmentProposals(req *types.InvestmentRequest, log *utils.AppLogger) ([]types.ProposalRecord, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.InvestmentID != \"\" {\n\t\tfilter[\"investment_id\"] = req.InvestmentID\n\t} else if req.Status != 0 {\n\t\tif req.Status < 1 || req.Status > 5 {\n\t\t\tlog.Error(\"Invalid status value\")\n\t\t\treturn nil, errors.New(\"invalid status parameter\")\n\t\t}\n\t\tfilter[\"ApprovalLevel\"] = req.Status\n\t} else if req.ProjectName != \"\" {\n\t\tif len(req.ProjectName) > 100 {\n\t\t\tlog.Error(\"Project name too long\")\n\t\t\treturn nil, errors.New(\"project name exceeds limit\")\n\t\t}\n\t\tfilter[\"project_name\"] = req.ProjectName\n\t} else {\n\t\tfilter[\"is_active\"] = true\n\t}\n\n\tproposal := &Proposal{}\n\trecords, err := proposal.QueryByCondition(filter, req.Page, req.Size)\n\tif err != nil {\n\t\tlog.Errorf(\"Failed to query proposals: %v\", err)\n\t\treturn nil, err\n\t}\n\t\n\treturn records, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "ProposalRecord",
        "code_value": "type ProposalRecord struct {\n\tID            uint      `json:\"id\" gorm:\"column:id\"`\n\tTitle         string    `json:\"title\" gorm:\"column:title\"`\n\tApprovalLevel int       `json:\"approval_level\" gorm:\"column:approval_level\"`\n\tTimezone      string    `json:\"timezone\" gorm:\"column:timezone\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "ApprovalStatus",
        "code_value": "const (\n\tPendingApproval = \"pending\"\n\tApproved        = \"approved\"\n\tRejected        = \"rejected\"\n)"
      },
      {
        "code_key": "TableName",
        "code_value": "const ProgressTrackingTable = \"progress_tracking\""
      },
      {
        "code_key": "ProposalFilter",
        "code_value": "type ProposalFilter struct {\n\tTitle         *string\n\tApprovalLevel *int\n\tTimezone      *string\n\tStatus        *string\n}"
      },
      {
        "code_key": "PaginationConfig",
        "code_value": "var DefaultPagination = struct {\n\tPageSize int\n\tMaxSize  int\n}{\n\tPageSize: 10,\n\tMaxSize:  100,\n}"
      }
    ]
  },
  "synthetic_if-else_caller_GenerateMetrics": {
    "scenario": "if-else+caller",
    "code_key": "GenerateMetrics",
    "code_value": "func (n *Notification) GenerateMetrics(filterParams map[string]interface{}, limit int) ([]types.NotificationMetrics, error) {\n\tvar metrics []types.NotificationMetrics\n\tdb := base.GetInstance().DefaultDriver().Table(\"player_rankings\")\n\n\tif edition, ok := filterParams[\"Edition\"]; ok {\n\t\tif currentStatus, exists := filterParams[\"CurrentStatus\"]; exists {\n\t\tdb = db.Where(\"edition = ? AND current_status = ?\", edition, currentStatus)\n\t} else {\n\t\tdb = db.Where(\"edition LIKE ?\", \"%\"+edition.(string)+\"%\")\n\t}\n\t} else if caseNumber, ok := filterParams[\"CaseNumber\"]; ok {\n\t\tdb = db.Where(\"case_number = ?\", caseNumber)\n\t} else {\n\t\tdb = db.Where(filterParams)\n\t}\n\n\terr := db.Limit(limit).Find(&metrics).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.MetricsNotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn metrics, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandlePlayerRankings",
        "code_value": "func (h *RankingHandler) HandlePlayerRankings(req *types.RankingRequest, log *logger.AppLog) ([]types.NotificationMetrics, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.PlayerID != \"\" {\n\t\tfilter[\"player_id\"] = req.PlayerID\n\t} else if req.RankRange != \"\" {\n\t\trangeParts := strings.Split(req.RankRange, \"-\")\n\t\tif len(rangeParts) != 2 {\n\t\t\tlog.Error(\"Invalid rank range format\")\n\t\t\treturn nil, utils.InvalidParamError\n\t\t}\n\t\tfilter[\"rank\"] = []interface{}{rangeParts[0], rangeParts[1]}\n\t} else if req.Region != \"\" && req.Tier != 0 {\n\t\tfilter[\"region\"] = req.Region\n\t\tfilter[\"tier\"] = req.Tier\n\t} else {\n\t\tif req.LastUpdated > 0 {\n\t\t\tfilter[\"updated_at\"] = req.LastUpdated\n\t\t}\n\t}\n\n\tnotif := &Notification{}\n\tmetrics, err := notif.GenerateMetrics(filter, req.Limit)\n\tif err != nil {\n\t\tlog.Error(fmt.Sprintf(\"Failed to generate metrics: %v\", err))\n\t\treturn nil, err\n\t}\n\t\n\tif len(metrics) == 0 {\n\t\tlog.Warn(\"No metrics found for given filters\")\n\t}\n\t\n\treturn metrics, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "NotificationMetrics",
        "code_value": "type NotificationMetrics struct {\n\tID           int       `json:\"id\" gorm:\"column:id\"`\n\tEdition      string    `json:\"edition\" gorm:\"column:edition\"`\n\tCurrentStatus string   `json:\"current_status\" gorm:\"column:current_status\"`\n\tCaseNumber   string    `json:\"case_number\" gorm:\"column:case_number\"`\n\tCreatedAt    time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt    time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "PlayerRankingTable",
        "code_value": "const PlayerRankingTable = \"player_rankings\""
      },
      {
        "code_key": "MetricsStatus",
        "code_value": "const (\n\tMetricsStatusPending = \"pending\"\n\tMetricsStatusProcessed = \"processed\"\n\tMetricsStatusFailed = \"failed\"\n)"
      },
      {
        "code_key": "NotificationFilter",
        "code_value": "type NotificationFilter struct {\n\tEdition      string `json:\"edition\"`\n\tCurrentStatus string `json:\"current_status\"`\n\tCaseNumber   string `json:\"case_number\"`\n\tLimit        int    `json:\"limit\"`\n}"
      },
      {
        "code_key": "DefaultMetricsLimit",
        "code_value": "var DefaultMetricsLimit = 100"
      }
    ]
  },
  "synthetic_if-else_caller_CompareData": {
    "scenario": "if-else+caller",
    "code_key": "CompareData",
    "code_value": "func (b *Book) CompareData(filterCriteria map[string]interface{}) ([]types.BookComparison, error) {\n\tresults := make([]types.BookComparison, 0)\n\tdb := base.GetInstance().MainDB().Table(\"account_balances\")\n\t\n\tif namespace, exists := filterCriteria[\"NamespaceName\"]; exists {\n\t\tdb = db.Where(\"namespace_name = ?\", namespace.(string))\n\t\tif publication, exists := filterCriteria[\"Publication\"]; exists {\n\t\t\tdb = db.Where(\"publication LIKE ?\", \"%\"+publication.(string)+\"%\")\n\t\t}\n\t} else if firstName, exists := filterCriteria[\"FirstName\"]; exists {\n\t\tdb = db.Where(\"first_name ILIKE ?\", firstName.(string)+\"%\")\n\t} else {\n\t\tdb = db.Where(filterCriteria)\n\t}\n\n\tif err := db.Find(&results).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.DataNotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleArticleSearch",
        "code_value": "func (h *ArticleHandler) HandleArticleSearch(req *types.ArticleSearchRequest) ([]types.ArticleComparison, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.ArticleID > 0 {\n\t\tfilter[\"article_id\"] = req.ArticleID\n\t} else if len(req.AuthorName) > 0 {\n\t\tif len(req.AuthorName) > 100 {\n\t\t\treturn nil, errors.New(\"author name too long\")\n\t\t}\n\t\tfilter[\"author_name\"] = req.AuthorName\n\t} else if len(req.Category) > 0 {\n\t\tvalidCategories := map[string]bool{\"tech\": true, \"business\": true, \"health\": true}\n\t\tif !validCategories[req.Category] {\n\t\t\treturn nil, errors.New(\"invalid category\")\n\t\t}\n\t\tfilter[\"category\"] = req.Category\n\t} else {\n\t\tfilter[\"is_published\"] = true\n\t}\n\n\tarticle := &models.Article{}\n\tresults, err := article.CompareData(filter)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to search articles: %v\", err)\n\t}\n\treturn results, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "BookComparison",
        "code_value": "type BookComparison struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tNamespaceName string    `json:\"namespace_name\" gorm:\"column:namespace_name\"`\n\tPublication   string    `json:\"publication\" gorm:\"column:publication\"`\n\tFirstName     string    `json:\"first_name\" gorm:\"column:first_name\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "BookFilter",
        "code_value": "type BookFilter struct {\n\tNamespaceName string\n\tPublication   string\n\tFirstName     string\n\tLimit         int\n\tOffset        int\n}"
      },
      {
        "code_key": "BookError",
        "code_value": "const BookError = \"book_error\""
      },
      {
        "code_key": "MaxBookLimit",
        "code_value": "const MaxBookLimit = 100"
      },
      {
        "code_key": "DefaultBookOffset",
        "code_value": "const DefaultBookOffset = 0"
      },
      {
        "code_key": "BookTableName",
        "code_value": "const BookTableName = \"account_balances\""
      }
    ]
  },
  "synthetic_if-else_caller_ScanByPattern": {
    "scenario": "if-else+caller",
    "code_key": "ScanByPattern",
    "code_value": "func (d *Document) ScanByPattern(filterParams map[string]interface{}, page, size int) ([]types.DocumentRecord, error) {\n\trecords := make([]types.DocumentRecord, 0)\n\tquery := base.GetDB().Table(\"guild_memberships\").Scopes(PaginateDB(page, size))\n\n\tif format, ok := filterParams[\"Format\"]; ok {\n\t\tquery = query.Where(\"format LIKE ?\", \"%\"+format.(string)+\"%\")\n\t\tdelete(filterParams, \"Format\")\n\t\tif len(filterParams) > 0 {\n\t\t\tquery = query.Where(filterParams)\n\t\t}\n\t} else if reactivationDate, ok := filterParams[\"ReactivationDate\"]; ok {\n\t\tquery = query.Where(\"reactivation_date > ?\", reactivationDate.(time.Time))\n\t\tdelete(filterParams, \"ReactivationDate\")\n\t\tif len(filterParams) > 0 {\n\t\t\tquery = query.Where(filterParams)\n\t\t}\n\t} else {\n\t\tquery = query.Where(filterParams)\n\t}\n\n\tif err := query.Find(&records).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn records, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleMedicalRecords",
        "code_value": "func (m *MedicalHandler) HandleMedicalRecords(req *types.MedicalRecordsRequest) ([]types.DocumentRecord, error) {\n\tfilterParams := make(map[string]interface{})\n\n\tif req.PatientID != \"\" {\n\t\tfilterParams[\"patient_id\"] = req.PatientID\n\t} else if req.AdmissionDate != \"\" {\n\t\tdate, err := time.Parse(\"2006-01-02\", req.AdmissionDate)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"invalid admission date format: %v\", err)\n\t\t}\n\t\tfilterParams[\"admission_date\"] = date\n\t} else if req.Diagnosis != \"\" {\n\t\tif len(req.Diagnosis) > 100 {\n\t\t\treturn nil, errors.New(\"diagnosis too long\")\n\t\t}\n\t\tfilterParams[\"diagnosis\"] = req.Diagnosis\n\t} else {\n\t\treturn nil, errors.New(\"at least one filter parameter required\")\n\t}\n\n\tdoc := &Document{}\n\trecords, err := doc.ScanByPattern(filterParams, req.Page, req.Size)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to scan medical records: %v\", err)\n\t}\n\n\treturn records, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "DocumentRecord",
        "code_value": "type DocumentRecord struct {\n\tID               int       `json:\"id\" gorm:\"column:id\"`\n\tTitle            string    `json:\"title\" gorm:\"column:title\"`\n\tFormat           string    `json:\"format\" gorm:\"column:format\"`\n\tReactivationDate time.Time `json:\"reactivation_date\" gorm:\"column:reactivation_date\"`\n\tCreatedAt        time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt        time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "DocumentFilterParams",
        "code_value": "type DocumentFilterParams struct {\n\tFormat           *string\n\tReactivationDate *time.Time\n\tStatus           *int\n\tAuthorID         *int64\n}"
      },
      {
        "code_key": "DocumentTableName",
        "code_value": "const DocumentTableName = \"guild_memberships\""
      },
      {
        "code_key": "DocumentStatus",
        "code_value": "const (\n\tDocumentStatusDraft = iota\n\tDocumentStatusPublished\n\tDocumentStatusArchived\n)"
      },
      {
        "code_key": "defaultPageSize",
        "code_value": "var defaultPageSize = 20"
      }
    ]
  },
  "synthetic_if-else_caller_MatchByPattern": {
    "scenario": "if-else+caller",
    "code_key": "MatchByPattern",
    "code_value": "func (p *Payment) MatchByPattern(filter map[string]interface{}, limit int) ([]types.Result, error) {\n\tvar results []types.Result\n\tvar err error\n\t\n\tif licenseKey, ok := filter[\"LicenseKey\"]; ok {\n\t\terr = base.GetDB().Table(\"account_balances\").\n\t\t\tWhere(\"license_key = ? AND classification_level = ?\", licenseKey, filter[\"ClassificationLevel\"]).\n\t\t\tLimit(limit).\n\t\t\tFind(&results).Error\n\t} else if version, ok := filter[\"Version\"]; ok {\n\t\terr = base.GetDB().Table(\"account_balances\").\n\t\t\tWhere(\"version >= ?\", version).\n\t\t\tOrder(\"created_at desc\").\n\t\t\tLimit(limit).\n\t\t\tFind(&results).Error\n\t} else {\n\t\terr = base.GetDB().Table(\"account_balances\").\n\t\t\tWhere(filter).\n\t\t\tLimit(limit).\n\t\t\tFind(&results).Error\n\t}\n\t\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleResourceAllocation",
        "code_value": "func (r *ResourceManager) HandleResourceAllocation(req *types.AllocationRequest) ([]types.Result, error) {\n\tif req == nil {\n\t\treturn nil, fmt.Errorf(\"invalid request\")\n\t}\n\n\tfilter := make(map[string]interface{})\n\tvar limit int = 10\n\n\tif req.ResourceID != \"\" {\n\t\tfilter[\"LicenseKey\"] = req.ResourceID\n\t\tfilter[\"ClassificationLevel\"] = req.Classification\n\t} else if req.MinVersion > 0 {\n\t\tfilter[\"Version\"] = req.MinVersion\n\t} else if req.Status != \"\" {\n\t\tfilter[\"status\"] = req.Status\n\t} else {\n\t\tfilter[\"is_active\"] = true\n\t}\n\n\tif req.Limit > 0 {\n\t\tlimit = req.Limit\n\t}\n\n\tpayment := &Payment{}\n\tresults, err := payment.MatchByPattern(filter, limit)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"query failed: %v\", err)\n\t}\n\n\treturn results, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Result",
        "code_value": "type Result struct {\n\tID                 int       `json:\"id\" gorm:\"column:id\"`\n\tLicenseKey         string    `json:\"license_key\" gorm:\"column:license_key\"`\n\tClassificationLevel string    `json:\"classification_level\" gorm:\"column:classification_level\"`\n\tVersion            int       `json:\"version\" gorm:\"column:version\"`\n\tCreatedAt          time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt          time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "AccountBalance",
        "code_value": "type AccountBalance struct {\n\tResult\n\tAmount float64 `json:\"amount\" gorm:\"column:amount\"`\n\tCurrency string `json:\"currency\" gorm:\"column:currency\"`\n}"
      },
      {
        "code_key": "PaymentFilter",
        "code_value": "type PaymentFilter struct {\n\tLicenseKey         string `json:\"license_key\"`\n\tClassificationLevel string `json:\"classification_level\"`\n\tVersion            int    `json:\"version\"`\n}"
      },
      {
        "code_key": "TableNameAccountBalances",
        "code_value": "const TableNameAccountBalances = \"account_balances\""
      },
      {
        "code_key": "DefaultQueryLimit",
        "code_value": "const DefaultQueryLimit = 100"
      },
      {
        "code_key": "ClassificationLevels",
        "code_value": "var ClassificationLevels = []string{\"standard\", \"premium\", \"enterprise\"}"
      }
    ]
  },
  "synthetic_if-else_caller_DetectFraud": {
    "scenario": "if-else+caller",
    "code_key": "DetectFraud",
    "code_value": "func (p *Policy) DetectFraud(filters map[string]interface{}) ([]types.FraudCase, error) {\n\tvar cases []types.FraudCase\n\tdb := base.GetInstance().GormDB().Table(\"trading_orders\")\n\n\tif district, ok := filters[\"District\"]; ok {\n\t\t// Complex query for district-based fraud detection\n\t\tdb = db.Where(\"district = ? AND suspicious_level > ?\", district, 5)\n\t} else if balance, ok := filters[\"Balance\"]; ok {\n\t\t// High balance threshold check\n\t\tdb = db.Where(\"balance > ? AND account_age < ?\", balance.(float64)*1.5, 30)\n\t} else {\n\t\t// Default suspicious pattern based on first login\n\t\tdb = db.Where(\"first_login_date < ? OR login_count > ?\", \n\t\t\ttime.Now().AddDate(0, -3, 0).Format(\"2006-01-02\"), 100)\n\t}\n\n\tif err := db.Order(\"detected_at DESC\").Find(&cases).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn cases, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleFraudDetection",
        "code_value": "func (h *FraudHandler) HandleFraudDetection(req *types.FraudDetectionRequest, log *utils.AppLogger) ([]types.FraudCase, error) {\n\tfilters := make(map[string]interface{})\n\n\tif req.TransactionID != \"\" {\n\t\tif !utils.IsValidTransactionID(req.TransactionID) {\n\t\t\tlog.Error(\"Invalid transaction ID format\")\n\t\t\treturn nil, errors.New(\"invalid transaction ID\")\n\t\t}\n\t\tfilters[\"District\"] = req.TransactionID[:3]\n\t} else if req.UserBalance > 0 {\n\t\tif req.UserBalance > 1000000 {\n\t\t\tlog.Warn(\"High balance detected\")\n\t\t}\n\t\tfilters[\"Balance\"] = req.UserBalance\n\t} else if req.IsNewUser {\n\t\tfilters[\"FirstLogin\"] = true\n\t} else {\n\t\tfilters[\"DefaultCheck\"] = true\n\t}\n\n\tpolicy := &Policy{}\n\tcases, err := policy.DetectFraud(filters)\n\tif err != nil {\n\t\tlog.Errorf(\"Fraud detection failed: %v\", err)\n\t\treturn nil, err\n\t}\n\n\tif len(cases) > 100 {\n\t\tlog.Warn(\"Excessive fraud cases detected\")\n\t}\n\n\treturn cases, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "FraudCase",
        "code_value": "type FraudCase struct {\n\tID             int       `json:\"id\" gorm:\"column:id\"`\n\tOrderID        string    `json:\"order_id\" gorm:\"column:order_id\"`\n\tDistrict       string    `json:\"district\" gorm:\"column:district\"`\n\tBalance        float64   `json:\"balance\" gorm:\"column:balance\"`\n\tSuspiciousLevel int       `json:\"suspicious_level\" gorm:\"column:suspicious_level\"`\n\tAccountAge     int       `json:\"account_age\" gorm:\"column:account_age\"`\n\tFirstLoginDate time.Time `json:\"first_login_date\" gorm:\"column:first_login_date\"`\n\tLoginCount     int       `json:\"login_count\" gorm:\"column:login_count\"`\n\tDetectedAt     time.Time `json:\"detected_at\" gorm:\"column:detected_at\"`\n}"
      },
      {
        "code_key": "FraudFilter",
        "code_value": "type FraudFilter struct {\n\tDistrict string  `json:\"district\"`\n\tBalance  float64 `json:\"balance\"`\n}"
      },
      {
        "code_key": "FraudDetectionResult",
        "code_value": "type FraudDetectionResult struct {\n\tCases  []FraudCase `json:\"cases\"`\n\tStatus string      `json:\"status\"`\n\tError  string      `json:\"error,omitempty\"`\n}"
      },
      {
        "code_key": "TableNameTradingOrders",
        "code_value": "const TableNameTradingOrders = \"trading_orders\""
      },
      {
        "code_key": "FraudDetectionThresholds",
        "code_value": "var FraudDetectionThresholds = struct {\n\tSuspiciousLevel int\n\tAccountAge      int\n\tLoginCount      int\n}{\n\tSuspiciousLevel: 5,\n\tAccountAge:      30,\n\tLoginCount:      100,\n}"
      }
    ]
  },
  "synthetic_if-else_caller_RetrieveByDate": {
    "scenario": "if-else+caller",
    "code_key": "RetrieveByDate",
    "code_value": "func (m *Medicine) RetrieveByDate(filterParams map[string]interface{}, page, size int) ([]types.MedicineRecord, error) {\n\tvar records []types.MedicineRecord\n\tdb := base.GetInstance().HealthDriver().Table(\"media_uploads\")\n\t\n\tif deadline, ok := filterParams[\"DeadlineDate\"]; ok {\n\t\t// Strategy 1: Range query for deadline dates\n\t\tdb = db.Where(\"deadline_date BETWEEN ? AND ?\", \n\t\t\ttime.Now().Format(\"2006-01-02\"),\n\t\t\ttime.Now().AddDate(0, 0, 7).Format(\"2006-01-02\"))\n\t\tdelete(filterParams, \"DeadlineDate\")\n\t\tdb = db.Where(filterParams)\n\t} else if rate, ok := filterParams[\"DiscountRate\"]; ok {\n\t\t// Strategy 2: Exact match with additional sorting\n\t\tdb = db.Where(\"discount_rate = ?\", rate).Order(\"tax_amount DESC\")\n\t\tdelete(filterParams, \"DiscountRate\")\n\t\tdb = db.Where(filterParams)\n\t} else {\n\t\tdb = db.Where(filterParams)\n\t}\n\t\n\terr := db.Scopes(PaginateDB(page, size)).Find(&records).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleMedicineCatalog",
        "code_value": "func (h *MedicineHandler) HandleMedicineCatalog(req *types.MedicineCatalogRequest) ([]types.MedicineRecord, error) {\n\tfilter := make(map[string]interface{})\n\tif req.Type != \"\" {\n\t\tfilter[\"medicine_type\"] = req.Type\n\t\tif req.SubType != \"\" {\n\t\t\tfilter[\"sub_type\"] = req.SubType\n\t\t}\n\t} else if req.IsPromotion {\n\t\tfilter[\"is_promotion\"] = true\n\t\tfilter[\"DiscountRate\"] = req.DiscountRate\n\t} else if !req.ExpiryDate.IsZero() {\n\t\tfilter[\"DeadlineDate\"] = req.ExpiryDate.Format(\"2006-01-02\")\n\t} else {\n\t\tfilter[\"status\"] = \"active\"\n\t}\n\n\tmed := &Medicine{}\n\trecords, err := med.RetrieveByDate(filter, req.Page, req.Size)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to retrieve medicine records: %v\", err)\n\t}\n\treturn records, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "MedicineRecord",
        "code_value": "type MedicineRecord struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tName          string    `json:\"name\" gorm:\"column:name\"`\n\tDeadlineDate  time.Time `json:\"deadline_date\" gorm:\"column:deadline_date\"`\n\tDiscountRate  float64   `json:\"discount_rate\" gorm:\"column:discount_rate\"`\n\tTaxAmount     float64   `json:\"tax_amount\" gorm:\"column:tax_amount\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "TableMedicine",
        "code_value": "const TableMedicine = \"medicine_records\""
      },
      {
        "code_key": "FilterParams",
        "code_value": "type FilterParams struct {\n\tDeadlineDate string  `json:\"deadline_date\"`\n\tDiscountRate float64 `json:\"discount_rate\"`\n\tName         string  `json:\"name\"`\n\tTaxAmount    float64 `json:\"tax_amount\"`\n}"
      },
      {
        "code_key": "PaginateDB",
        "code_value": "func PaginateDB(page, size int) func(db *gorm.DB) *gorm.DB {\n\treturn func(db *gorm.DB) *gorm.DB {\n\t\toffset := (page - 1) * size\n\t\treturn db.Offset(offset).Limit(size)\n\t}\n}"
      }
    ]
  },
  "synthetic_if-else_caller_DecryptInfo": {
    "scenario": "if-else+caller",
    "code_key": "DecryptInfo",
    "code_value": "func (b *Bond) DecryptInfo(filterParams map[string]interface{}) ([]types.PackageTracking, error) {\n\tvar records []types.PackageTracking\n\tdb := base.GetInstance().GormDriver().Table(\"package_tracking\")\n\n\tif apiKey, ok := filterParams[\"ApiKey\"]; ok {\n\t\tdb = db.Where(\"api_key = ?\", apiKey)\n\t\tif uniqueKey, ok := filterParams[\"UniqueKey\"]; ok {\n\t\t\tdb = db.Where(\"unique_key LIKE ?\", \"%\"+uniqueKey.(string)+\"%\")\n\t\t}\n\t} else if tableName, ok := filterParams[\"TableName\"]; ok {\n\t\tdb = db.Where(\"table_name IN (?, ?)\", tableName, tableName.(string)+\"_archive\")\n\t} else {\n\t\tdb = db.Where(filterParams)\n\t}\n\n\tif err := db.Find(&records).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.RecordNotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandlePackageTracking",
        "code_value": "func (s *TrackingService) HandlePackageTracking(req *types.TrackingRequest) ([]types.PackageTracking, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.TrackingID != \"\" {\n\t\tfilter[\"UniqueKey\"] = req.TrackingID\n\t\tfilter[\"ApiKey\"] = s.apiKey\n\t} else if req.BatchNumber > 0 {\n\t\tfilter[\"TableName\"] = fmt.Sprintf(\"batch_%d\", req.BatchNumber)\n\t} else if req.Status != \"\" {\n\t\tif !utils.IsValidStatus(req.Status) {\n\t\t\treturn nil, fmt.Errorf(\"invalid status: %s\", req.Status)\n\t\t}\n\t\tfilter[\"status\"] = req.Status\n\t} else {\n\t\treturn nil, fmt.Errorf(\"at least one filter parameter is required\")\n\t}\n\n\tbond := &Bond{}\n\trecords, err := bond.DecryptInfo(filter)\n\tif err != nil {\n\t\tif errors.Is(err, utils.RecordNotFoundError) {\n\t\t\treturn nil, fmt.Errorf(\"no tracking records found\")\n\t\t}\n\t\treturn nil, fmt.Errorf(\"query failed: %v\", err)\n\t}\n\t\n\treturn records, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "PackageTracking",
        "code_value": "type PackageTracking struct {\n\tID        uint      json:\"id\" gorm:\"primaryKey\"\n\tApiKey    string    json:\"api_key\" gorm:\"column:api_key\"\n\tUniqueKey string    json:\"unique_key\" gorm:\"column:unique_key\"\n\tTableName string    json:\"table_name\" gorm:\"column:table_name\"\n\tCreatedAt time.Time json:\"created_at\" gorm:\"column:created_at\"\n\tUpdatedAt time.Time json:\"updated_at\" gorm:\"column:updated_at\"\n}"
      },
      {
        "code_key": "TrackingFilter",
        "code_value": "type TrackingFilter struct {\n\tApiKey    string\n\tUniqueKey string\n\tTableName string\n}"
      },
      {
        "code_key": "TrackingResponse",
        "code_value": "type TrackingResponse struct {\n\tSuccess   bool\n\tData      []PackageTracking\n\tError     string\n\tTimestamp int64\n}"
      },
      {
        "code_key": "TablePackageTracking",
        "code_value": "const TablePackageTracking = \"package_tracking\""
      },
      {
        "code_key": "TablePackageArchive",
        "code_value": "const TablePackageArchive = \"package_tracking_archive\""
      },
      {
        "code_key": "ErrInvalidFilter",
        "code_value": "var ErrInvalidFilter = errors.New(\"invalid filter parameters\")"
      }
    ]
  },
  "synthetic_if-else_caller_FindByCategory": {
    "scenario": "if-else+caller",
    "code_key": "FindByCategory",
    "code_value": "func (c *Claim) FindByCategory(filterParams map[string]interface{}, page, limit int) ([]types.SurgeryClaim, error) {\n\tvar claims []types.SurgeryClaim\n\tdb := base.GetInstance().HealthDriver().Table(\"surgery_schedules\")\n\n\tif category, ok := filterParams[\"Category\"]; ok {\n\t\tif deadline, exists := filterParams[\"DeadlineDate\"]; exists {\n\t\t\tdb = db.Where(\"category = ? AND deadline_date > ?\", category, deadline)\n\t\t} else {\n\t\t\tdb = db.Where(\"category LIKE ?\", \"%\"+category.(string)+\"%\")\n\t\t}\n\t} else if location, ok := filterParams[\"LocationCode\"]; ok {\n\t\tdb = db.Where(\"location_code = ?\", location)\n\t}\n\n\terr := db.Scopes(PaginateDB(page, limit)).Order(\"created_at desc\").Find(&claims).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.NotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn claims, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleSurgeryClaims",
        "code_value": "func (h *ClaimHandler) HandleSurgeryClaims(req *types.ClaimSearchRequest, log *logger.HealthLog) ([]types.SurgeryClaim, error) {\n\tfilter := make(map[string]interface{})\n\tif req.ClaimID != \"\" {\n\t\tfilter[\"ClaimID\"] = req.ClaimID\n\t} else if req.PatientName != \"\" {\n\t\tif len(req.PatientName) > 50 {\n\t\t\tlog.Error(\"Patient name too long\")\n\t\t\treturn nil, utils.InvalidParamError\n\t\t}\n\t\tfilter[\"PatientName\"] = req.PatientName\n\t} else if req.Status != 0 {\n\t\tfilter[\"Status\"] = req.Status\n\t} else {\n\t\treturn nil, utils.MissingParamError\n\t}\n\n\tclaimObj := &Claim{}\n\tresults, err := claimObj.FindByCategory(filter, req.Page, req.Size)\n\tif err != nil {\n\t\tlog.Errorf(\"Failed to find claims: %v\", err)\n\t\treturn nil, err\n\t}\n\n\tif len(results) == 0 {\n\t\tlog.Warn(\"No claims found with given criteria\")\n\t}\n\treturn results, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "SurgeryClaim",
        "code_value": "type SurgeryClaim struct {\n\tID           int       `json:\"id\" gorm:\"column:id;primaryKey\"`\n\tCategory     string    `json:\"category\" gorm:\"column:category\"`\n\tDeadlineDate time.Time `json:\"deadlineDate\" gorm:\"column:deadline_date\"`\n\tLocationCode string    `json:\"locationCode\" gorm:\"column:location_code\"`\n\tCreatedAt    time.Time `json:\"createdAt\" gorm:\"column:created_at\"`\n\tUpdatedAt    time.Time `json:\"updatedAt\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "FilterParams",
        "code_value": "type FilterParams struct {\n\tCategory      string    \n\tDeadlineDate  time.Time \n\tLocationCode  string    \n}"
      },
      {
        "code_key": "SurgeryTable",
        "code_value": "const SurgeryTable = \"surgery_schedules\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "ClaimStatus",
        "code_value": "type ClaimStatus struct {\n\tPending   string\n\tApproved  string\n\tRejected  string\n}\n\nvar Status = ClaimStatus{\n\tPending:  \"pending\",\n\tApproved: \"approved\",\n\tRejected: \"rejected\",\n}"
      }
    ]
  },
  "synthetic_if-else_caller_ForecastDemand": {
    "scenario": "if-else+caller",
    "code_key": "ForecastDemand",
    "code_value": "func (e *Exchange) ForecastDemand(filter map[string]interface{}, limit int) ([]Result, error) {\n\tvar results []Result\n\tdb := base.GetInstance().MainDB().Table(\"medication_inventory\")\n\n\tif subject, ok := filter[\"Subject\"]; ok {\n\t\tdb = db.Where(\"subject LIKE ?\", \"%\"+subject.(string)+\"%\")\n\t\tdelete(filter, \"Subject\")\n\t}\n\n\tif postalCode, ok := filter[\"PostalCode\"]; ok {\n\t\tdb = db.Where(\"postal_code = ?\", postalCode)\n\t\tdelete(filter, \"PostalCode\")\n\t}\n\n\tif len(filter) > 0 {\n\t\tdb = db.Where(filter)\n\t}\n\n\tif limit > 0 {\n\t\tdb = db.Limit(limit)\n\t}\n\n\tif err := db.Find(&results).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleMedicationSearch",
        "code_value": "func (h *MedicationHandler) HandleMedicationSearch(req *MedicationSearchRequest) ([]Result, error) {\n\tif req == nil {\n\t\treturn nil, fmt.Errorf(\"invalid request\")\n\t}\n\n\tfilter := make(map[string]interface{})\n\tif req.MedicationID > 0 {\n\t\tfilter[\"medication_id\"] = req.MedicationID\n\t} else if req.Category != \"\" {\n\t\tif len(req.Category) > 50 {\n\t\t\treturn nil, fmt.Errorf(\"category name too long\")\n\t\t}\n\t\tfilter[\"category\"] = req.Category\n\t} else if req.MinStock > 0 {\n\t\tfilter[\"stock_quantity\"] = gorm.Expr(\"stock_quantity >= ?\", req.MinStock)\n\t} else {\n\t\tfilter[\"is_active\"] = true\n\t}\n\n\texchange := &Exchange{}\n\tresults, err := exchange.ForecastDemand(filter, req.Limit)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to forecast demand: %v\", err)\n\t}\n\n\tif len(results) == 0 && req.StrictMode {\n\t\treturn nil, fmt.Errorf(\"no results found in strict mode\")\n\t}\n\n\treturn results, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "DemandForecastResult",
        "code_value": "type DemandForecastResult struct {\n\tID           int    `json:\"id\" gorm:\"column:id\"`\n\tSubject      string `json:\"subject\" gorm:\"column:subject\"`\n\tPostalCode   string `json:\"postal_code\" gorm:\"column:postal_code\"`\n\tInventoryQty int    `json:\"inventory_qty\" gorm:\"column:inventory_qty\"`\n\tForecastDate string `json:\"forecast_date\" gorm:\"column:forecast_date\"`\n\tCreatedAt    int64  `json:\"created_at\" gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "ForecastFilter",
        "code_value": "type ForecastFilter struct {\n\tSubject    string `json:\"subject\"`\n\tPostalCode string `json:\"postal_code\"`\n\tMaxResults int    `json:\"max_results\"`\n}"
      },
      {
        "code_key": "MedicationInventoryTable",
        "code_value": "const MedicationInventoryTable = \"medication_inventory\""
      },
      {
        "code_key": "DefaultForecastLimit",
        "code_value": "const DefaultForecastLimit = 100"
      },
      {
        "code_key": "ForecastStatuses",
        "code_value": "var ForecastStatuses = map[string]int{\n\t\"Pending\":   1,\n\t\"Completed\": 2,\n\t\"Failed\":    3,\n}"
      }
    ]
  },
  "synthetic_if-else_caller_ValidateByRules": {
    "scenario": "if-else+caller",
    "code_key": "ValidateByRules",
    "code_value": "func (e *Exchange) ValidateByRules(filter map[string]interface{}) ([]types.SecurityClearance, error) {\n\tvar clearances []types.SecurityClearance\n\tquery := base.GetInstance().GormDB().Table(\"security_clearances\")\n\t\n\tif region, ok := filter[\"Region\"]; ok {\n\t\tquery = query.Where(\"region = ?\", region)\n\t\tif level, ok := filter[\"Level\"]; ok {\n\t\t\tquery = query.Where(\"clearance_level >= ?\", level)\n\t\t}\n\t} else if genre, ok := filter[\"Genre\"]; ok {\n\t\tquery = query.Where(\"genre LIKE ?\", \"%\"+genre.(string)+\"%\")\n\t} else {\n\t\tquery = query.Where(filter)\n\t}\n\t\n\tif err := query.Find(&clearances).Error; err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn clearances, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleDiagnosis",
        "code_value": "func (d *DiagnosisHandler) HandleDiagnosis(req *types.DiagnosisRequest, log *logger.MedLog) ([]types.SecurityClearance, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.PatientID != \"\" {\n\t\tfilter[\"Region\"] = \"EMEA\"\n\t\tif req.Priority > 0 {\n\t\t\tfilter[\"Level\"] = req.Priority\n\t\t}\n\t} else if req.DiagnosisCode != \"\" {\n\t\tfilter[\"Genre\"] = req.DiagnosisCode\n\t} else if req.Status != 0 {\n\t\tfilter[\"status\"] = req.Status\n\t} else {\n\t\treturn nil, fmt.Errorf(\"invalid query parameters\")\n\t}\n\n\texch := &Exchange{}\n\tresults, err := exch.ValidateByRules(filter)\n\tif err != nil {\n\t\tlog.Error(fmt.Sprintf(\"ValidateByRules failed: %v\", err))\n\t\treturn nil, err\n\t}\n\t\n\tif len(results) == 0 {\n\t\tlog.Warn(\"No matching security clearances found\")\n\t}\n\t\n\treturn results, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "SecurityClearance",
        "code_value": "type SecurityClearance struct {\n\tID             int       `gorm:\"column:id;primaryKey\"`\n\tRegion         string    `gorm:\"column:region\"`\n\tClearanceLevel int       `gorm:\"column:clearance_level\"`\n\tGenre          string    `gorm:\"column:genre\"`\n\tCreatedAt      time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt      time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "Exchange",
        "code_value": "type Exchange struct {\n\tDB *gorm.DB `gorm:\"-\"`\n}"
      },
      {
        "code_key": "TableNameSecurityClearances",
        "code_value": "const TableNameSecurityClearances = \"security_clearances\""
      },
      {
        "code_key": "ClearanceLevelThreshold",
        "code_value": "const ClearanceLevelThreshold = 3"
      },
      {
        "code_key": "DefaultRegion",
        "code_value": "const DefaultRegion = \"EMEA\""
      }
    ]
  },
  "synthetic_if-else_caller_ValidatePermissions": {
    "scenario": "if-else+caller",
    "code_key": "ValidatePermissions",
    "code_value": "func (p *Profile) ValidatePermissions(filter map[string]interface{}) ([]types.AccessControl, error) {\n\tvar permissions []types.AccessControl\n\tdb := base.GetInstance().MainDB().Table(\"contract_agreements\")\n\t\n\tif role, ok := filter[\"Role\"]; ok {\n\t\tif level, ok := filter[\"Level\"]; ok {\n\t\t\tdb = db.Where(\"role = ? AND level >= ?\", role, level)\n\t\t} else {\n\t\t\tdb = db.Where(\"role = ?\", role)\n\t\t}\n\t} else if category, ok := filter[\"Category\"]; ok {\n\t\tdb = db.Where(\"category LIKE ?\", \"%\"+category.(string)+\"%\")\n\t}\n\n\tif err := db.Find(&permissions).Error; err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn permissions, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleInsuranceClaims",
        "code_value": "func (i *InsuranceHandler) HandleInsuranceClaims(req *types.ClaimRequest, log *logger.AppLog) ([]types.ClaimResult, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.PolicyID != \"\" {\n\t\tfilter[\"Role\"] = \"policy_holder\"\n\t\tfilter[\"Level\"] = 3\n\t} else if req.ClaimAmount > 10000 {\n\t\tfilter[\"Category\"] = \"high_value\"\n\t} else if req.HospitalCode != \"\" {\n\t\tfilter[\"Role\"] = \"medical_provider\"\n\t} else {\n\t\treturn nil, fmt.Errorf(\"invalid claim parameters: need either policy ID, claim amount or hospital code\")\n\t}\n\n\tprofile := &Profile{}\n\tclaims, err := profile.ValidatePermissions(filter)\n\tif err != nil {\n\t\tlog.Error(\"Failed to validate insurance permissions\", \"error\", err)\n\t\treturn nil, fmt.Errorf(\"permission validation failed: %v\", err)\n\t}\n\n\tresults := make([]types.ClaimResult, 0, len(claims))\n\tfor _, c := range claims {\n\t\tresults = append(results, types.ClaimResult{\n\t\t\tClaimID:    c.ClaimID,\n\t\t\tStatus:     c.Status,\n\t\t\tValidUntil: c.ValidUntil,\n\t\t})\n\t}\n\n\treturn results, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "AccessControl",
        "code_value": "type AccessControl struct {\n\tID        uint   `gorm:\"primaryKey;column:id\"`\n\tRole      string `gorm:\"column:role\"`\n\tLevel     int    `gorm:\"column:level\"`\n\tCategory  string `gorm:\"column:category\"`\n\tCreatedAt int64  `gorm:\"autoCreateTime;column:created_at\"`\n\tUpdatedAt int64  `gorm:\"autoUpdateTime;column:updated_at\"`\n}"
      },
      {
        "code_key": "PermissionFilter",
        "code_value": "type PermissionFilter struct {\n\tRole     string\n\tLevel    int\n\tCategory string\n}"
      },
      {
        "code_key": "TableNameContractAgreements",
        "code_value": "const TableNameContractAgreements = \"contract_agreements\""
      },
      {
        "code_key": "DefaultAccessLevel",
        "code_value": "const DefaultAccessLevel = 1"
      },
      {
        "code_key": "AdminRole",
        "code_value": "const AdminRole = \"admin\""
      },
      {
        "code_key": "Profile",
        "code_value": "type Profile struct {\n\tID        uint   `gorm:\"primaryKey\"`\n\tUserID    string `gorm:\"uniqueIndex\"`\n\tAccess    []AccessControl\n\tCreatedAt int64  `gorm:\"autoCreateTime\"`\n}"
      }
    ]
  },
  "synthetic_if-else_caller_UpdateInventory": {
    "scenario": "if-else+caller",
    "code_key": "UpdateInventory",
    "code_value": "func (e *Equipment) UpdateInventory(filter map[string]interface{}, page, size int) ([]types.EquipmentRecord, error) {\n\tvar records []types.EquipmentRecord\n\tdb := base.GetInstance().GormDB().Table(\"grade_records\")\n\n\tif room, ok := filter[\"Room\"]; ok {\n\t\tdelete(filter, \"Room\")\n\t\terr := db.Where(\"room = ?\", room).Where(filter).Scopes(PaginateDB(page, size)).Find(&records).Error\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else if refreshKey, ok := filter[\"RefreshKey\"]; ok {\n\t\tdelete(filter, \"RefreshKey\")\n\t\terr := db.Where(\"refresh_key LIKE ?\", \"%\"+refreshKey.(string)+\"%\").Where(filter).Scopes(PaginateDB(page, size)).Find(&records).Error\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\terr := db.Where(filter).Scopes(PaginateDB(page, size)).Find(&records).Error\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn records, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleEquipmentQuery",
        "code_value": "func (h *EquipmentHandler) HandleEquipmentQuery(req *types.EquipmentQueryRequest, log *logger.AppLog) ([]types.EquipmentRecord, error) {\n\tfilter := make(map[string]interface{})\n\tpage, size := utils.Paginate(req.Page, req.Size)\n\n\tif req.EquipmentID != \"\" {\n\t\tfilter[\"equipment_id\"] = req.EquipmentID\n\t} else if req.Status != 0 {\n\t\tif req.Status < 1 || req.Status > 3 {\n\t\t\tlog.Error(\"Invalid status parameter\")\n\t\t\treturn nil, errors.New(\"invalid status value\")\n\t\t}\n\t\tfilter[\"status\"] = req.Status\n\t} else if req.Type != \"\" {\n\t\tif len(req.Type) > 20 {\n\t\t\tlog.Error(\"Type parameter too long\")\n\t\t\treturn nil, errors.New(\"type parameter exceeds limit\")\n\t\t}\n\t\tfilter[\"type\"] = req.Type\n\t} else {\n\t\tfilter[\"department\"] = req.Department\n\t}\n\n\tequipment := &Equipment{}\n\tresults, err := equipment.UpdateInventory(filter, page, size)\n\tif err != nil {\n\t\tlog.Error(fmt.Sprintf(\"Failed to query equipment: %v\", err))\n\t\treturn nil, err\n\t}\n\n\treturn results, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "EquipmentRecord",
        "code_value": "type EquipmentRecord struct {\n\tID        int    `json:\"id\" gorm:\"column:id\"`\n\tName      string `json:\"name\" gorm:\"column:name\"`\n\tRoom      string `json:\"room\" gorm:\"column:room\"`\n\tStatus    int    `json:\"status\" gorm:\"column:status\"`\n\tRefreshKey string `json:\"refresh_key\" gorm:\"column:refresh_key\"`\n\tCreatedAt int64  `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt int64  `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "InventoryResult",
        "code_value": "type InventoryResult struct {\n\tRecords []EquipmentRecord `json:\"records\"`\n\tTotal   int              `json:\"total\"`\n\tPage    int              `json:\"page\"`\n\tSize    int              `json:\"size\"`\n}"
      },
      {
        "code_key": "EquipmentFilter",
        "code_value": "type EquipmentFilter struct {\n\tRoom       *string `json:\"room\"`\n\tRefreshKey *string `json:\"refresh_key\"`\n\tStatus     *int    `json:\"status\"`\n\tName       *string `json:\"name\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "const TableName = \"equipment_records\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "StatusActive",
        "code_value": "const StatusActive = 1"
      },
      {
        "code_key": "StatusInactive",
        "code_value": "const StatusInactive = 0"
      },
      {
        "code_key": "Equipment",
        "code_value": "type Equipment struct {\n\tBaseModel\n\tCacheHandler *CacheHandler `json:\"-\"`\n}"
      }
    ]
  },
  "synthetic_if-else_caller_AuthorizeAccess": {
    "scenario": "if-else+caller",
    "code_key": "AuthorizeAccess",
    "code_value": "func (p *Player) AuthorizeAccess(filter map[string]interface{}) ([]types.PlayerAccess, error) {\n\tvar accesses []types.PlayerAccess\n\tdb := base.GetInstance().GormDriver().Table(\"user_profiles\")\n\n\tif token, exists := filter[\"SessionToken\"]; exists {\n\t\tdb = db.Where(\"session_token = ? AND status = ?\", token.(string), \"active\")\n\t\tdelete(filter, \"SessionToken\")\n\t} else if district, exists := filter[\"District\"]; exists {\n\t\tdb = db.Where(\"district LIKE ?\", \"%\"+district.(string)+\"%\")\n\t\tdelete(filter, \"District\")\n\t}\n\n\tif len(filter) > 0 {\n\t\tdb = db.Where(filter)\n\t}\n\n\tif err := db.Find(&accesses).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn accesses, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandlePlayerAccess",
        "code_value": "func (h *PlayerHandler) HandlePlayerAccess(req *types.PlayerAccessRequest) ([]types.PlayerAccess, error) {\n\tif req == nil {\n\t\treturn nil, fmt.Errorf(\"invalid request\")\n\t}\n\n\tfilter := make(map[string]interface{})\n\tif req.PlayerID != \"\" {\n\t\tfilter[\"player_id\"] = req.PlayerID\n\t} else if req.AccessLevel > 0 {\n\t\tif req.AccessLevel > 5 {\n\t\t\treturn nil, fmt.Errorf(\"invalid access level\")\n\t\t}\n\t\tfilter[\"access_level\"] = req.AccessLevel\n\t} else if req.Region != \"\" {\n\t\tif len(req.Region) > 50 {\n\t\t\treturn nil, fmt.Errorf(\"region too long\")\n\t\t}\n\t\tfilter[\"Region\"] = req.Region\n\t} else {\n\t\tfilter[\"status\"] = \"pending\"\n\t}\n\n\tplayer := &Player{}\n\taccesses, err := player.AuthorizeAccess(filter)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to authorize access: %v\", err)\n\t}\n\n\tif len(accesses) == 0 {\n\t\treturn nil, fmt.Errorf(\"no matching records found\")\n\t}\n\treturn accesses, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "PlayerAccess",
        "code_value": "type PlayerAccess struct {\n\tID          uint      `gorm:\"primaryKey\"`\n\tPlayerID    string    `gorm:\"column:player_id\"`\n\tAccessLevel int       `gorm:\"column:access_level\"`\n\tSessionToken string   `gorm:\"column:session_token\"`\n\tDistrict     string   `gorm:\"column:district\"`\n\tStatus       string   `gorm:\"column:status\"`\n\tCreatedAt    time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt    time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "AccessStatus",
        "code_value": "const (\n\tAccessActive    = \"active\"\n\tAccessSuspended = \"suspended\"\n\tAccessRevoked   = \"revoked\"\n)"
      },
      {
        "code_key": "DefaultAccessLevel",
        "code_value": "const DefaultAccessLevel = 1"
      },
      {
        "code_key": "UserProfileTable",
        "code_value": "const UserProfileTable = \"user_profiles\""
      },
      {
        "code_key": "AccessFilter",
        "code_value": "type AccessFilter struct {\n\tPlayerIDs    []string `json:\"player_ids\"`\n\tMinLevel     int      `json:\"min_level\"`\n\tExcludeZones []string `json:\"exclude_zones\"`\n}"
      }
    ]
  },
  "synthetic_if-else_caller_FilterByAttribute": {
    "scenario": "if-else+caller",
    "code_key": "FilterByAttribute",
    "code_value": "func (m *Magazine) FilterByAttribute(filters map[string]interface{}, page, size int) ([]types.MagazinePublication, error) {\n\tvar publications []types.MagazinePublication\n\tvar err error\n\tquery := base.GetInstance().Db().Table(\"asset_inventory\").Order(\"publication_date\")\n\n\tif topic, ok := filters[\"topic\"]; ok {\n\t\tquery = query.Where(\"topic LIKE ?\", \"%\"+topic.(string)+\"%\")\n\t\tdelete(filters, \"topic\")\n\t}\n\n\tif limit, ok := filters[\"limit\"]; ok {\n\t\tquery = query.Where(\"monthly_limit > ?\", limit.(int))\n\t\tdelete(filters, \"limit\")\n\t}\n\n\terr = query.Scopes(PaginateDB(page, size)).Where(filters).Find(&publications).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn publications, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn publications, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleArmorSearch",
        "code_value": "func (a *ArmorHandler) HandleArmorSearch(req *types.ArmorSearchRequest) ([]types.ArmorItem, error) {\n\tfilters := make(map[string]interface{})\n\tif req.MinDefense > 0 {\n\t\tfilters[\"defense\"] = req.MinDefense\n\t} else if req.Material != \"\" {\n\t\tif !utils.IsValidMaterial(req.Material) {\n\t\t\treturn nil, fmt.Errorf(\"invalid material type: %s\", req.Material)\n\t\t}\n\t\tfilters[\"material\"] = req.Material\n\t} else if req.Rarity > 0 {\n\t\tif req.Rarity > 5 {\n\t\t\treturn nil, fmt.Errorf(\"rarity must be between 1-5\")\n\t\t}\n\t\tfilters[\"rarity\"] = req.Rarity\n\t}\n\n\tmag := &Magazine{}\n\tpage, size := utils.GetPagination(req.Page, req.PageSize)\n\titems, err := mag.FilterByAttribute(filters, page, size)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to search armor: %v\", err)\n\t}\n\treturn items, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "MagazinePublication",
        "code_value": "type MagazinePublication struct {\n\tID              int       `json:\"id\" gorm:\"column:id\"`\n\tTitle           string    `json:\"title\" gorm:\"column:title\"`\n\tTopic           string    `json:\"topic\" gorm:\"column:topic\"`\n\tPublicationDate time.Time `json:\"publication_date\" gorm:\"column:publication_date\"`\n\tMonthlyLimit    int       `json:\"monthly_limit\" gorm:\"column:monthly_limit\"`\n\tCreatedAt       time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt       time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "PublicationFilter",
        "code_value": "type PublicationFilter struct {\n\tTopic        *string \n\tMonthlyLimit *int    \n\tStatus       *string \n\tPublisherID  *int    \n}"
      },
      {
        "code_key": "PublicationResponse",
        "code_value": "type PublicationResponse struct {\n\tPublications []MagazinePublication `json:\"publications\"`\n\tTotalCount   int                   `json:\"total_count\"`\n\tPage         int                   `json:\"page\"`\n\tSize         int                   `json:\"size\"`\n}"
      },
      {
        "code_key": "TableNamePublications",
        "code_value": "const TableNamePublications = \"magazine_publications\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "MaxPageSize",
        "code_value": "const MaxPageSize = 100"
      },
      {
        "code_key": "PublicationStatus",
        "code_value": "var PublicationStatus = struct {\n\tDraft     string\n\tPublished string\n\tArchived  string\n}{\n\tDraft:     \"draft\",\n\tPublished: \"published\",\n\tArchived:  \"archived\",\n}"
      }
    ]
  },
  "synthetic_if-else_caller_SyncWithExternal": {
    "scenario": "if-else+caller",
    "code_key": "SyncWithExternal",
    "code_value": "func (e *Equipment) SyncWithExternal(filterParams map[string]interface{}) ([]types.EquipmentRecord, error) {\n\trecords := make([]types.EquipmentRecord, 0)\n\tdb := base.GetInstance().MainDB().Table(\"tournament_brackets\")\n\n\tif edition, ok := filterParams[\"Edition\"]; ok {\n\t\tif method, ok := filterParams[\"MethodName\"]; ok {\n\t\tdb = db.Where(\"edition = ? AND method_name = ?\", edition.(string), method.(string))\n\t\t} else {\n\t\t\tdb = db.Where(\"edition LIKE ?\", \"%\"+edition.(string)+\"%\")\n\t\t}\n\t} else if content, ok := filterParams[\"Content\"]; ok {\n\t\tdb = db.Where(\"content LIKE ?\", \"%\"+content.(string)+\"%\")\n\t} else {\n\t\tdb = db.Where(filterParams)\n\t}\n\n\tif err := db.Order(\"created_at DESC\").Find(&records).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleEquipmentSearch",
        "code_value": "func (h *EquipmentHandler) HandleEquipmentSearch(req *types.EquipmentSearchRequest) ([]types.EquipmentRecord, error) {\n\tfilter := make(map[string]interface{})\n\n\tif req.SerialNumber != \"\" {\n\t\tif len(req.SerialNumber) < 5 {\n\t\t\treturn nil, errors.New(\"serial number too short\")\n\t\t}\n\t\tfilter[\"SerialNumber\"] = req.SerialNumber\n\t} else if req.Location != \"\" {\n\t\tif !validateLocation(req.Location) {\n\t\t\treturn nil, errors.New(\"invalid location format\")\n\t\t}\n\t\tfilter[\"Location\"] = req.Location\n\t} else if req.Status != 0 {\n\t\tif req.Status < 1 || req.Status > 4 {\n\t\t\treturn nil, errors.New(\"invalid status value\")\n\t\t}\n\t\tfilter[\"Status\"] = req.Status\n\t} else {\n\t\tfilter[\"LastMaintained\"] = time.Now().AddDate(0, -3, 0)\n\t}\n\n\tequipment := &Equipment{}\n\trecords, err := equipment.SyncWithExternal(filter)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to sync equipment: %v\", err)\n\t}\n\n\tif len(records) == 0 {\n\t\treturn nil, errors.New(\"no matching equipment found\")\n\t}\n\n\treturn records, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "EquipmentRecord",
        "code_value": "type EquipmentRecord struct {\n\tID        uint      `gorm:\"primaryKey\"`\n\tEdition   string    `gorm:\"column:edition\"`\n\tMethodName string   `gorm:\"column:method_name\"`\n\tContent   string    `gorm:\"column:content\"`\n\tCreatedAt time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "TournamentFilter",
        "code_value": "type TournamentFilter struct {\n\tEdition    string\n\tMethodName string\n\tContent    string\n}"
      },
      {
        "code_key": "EquipmentStatus",
        "code_value": "const (\n\tEquipmentActive = \"active\"\n\tEquipmentInactive = \"inactive\"\n\tEquipmentPending = \"pending\"\n)"
      },
      {
        "code_key": "MaxRetryAttempts",
        "code_value": "const MaxRetryAttempts = 3"
      },
      {
        "code_key": "DefaultPagination",
        "code_value": "var DefaultPagination = struct {\n\tPage    int\n\tPerPage int\n}{\n\tPage:    1,\n\tPerPage: 20,\n}"
      }
    ]
  },
  "synthetic_if-else_caller_PreventAttack": {
    "scenario": "if-else+caller",
    "code_key": "PreventAttack",
    "code_value": "func (s *Semester) PreventAttack(filters map[string]interface{}) ([]types.Currency, error) {\n\tvar currencies []types.Currency\n\tdb := base.GetInstance().GormDB().Table(\"grade_records\")\n\n\tif territory, exists := filters[\"Territory\"]; exists {\n\t\tif method, ok := filters[\"AttackMethod\"]; ok {\n\t\t\tdb = db.Where(\"territory = ? AND attack_method = ?\", territory, method)\n\t\t} else {\n\t\t\tdb = db.Where(\"territory LIKE ?\", \"%\" + territory.(string) + \"%\")\n\t\t}\n\t} else if amount, exists := filters[\"TotalAmount\"]; exists {\n\t\tdb = db.Where(\"total_amount > ?\", amount)\n\t}\n\n\terr := db.Find(&currencies).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn currencies, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleCurrencyReport",
        "code_value": "func (c *CurrencyController) HandleCurrencyReport(req *types.CurrencyReportRequest) ([]types.Currency, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.Threshold > 0 {\n\t\tfilter[\"TotalAmount\"] = req.Threshold\n\t} else if req.Region != \"\" {\n\t\tif req.Method != \"\" {\n\t\t\tfilter[\"Territory\"] = req.Region\n\t\t\tfilter[\"AttackMethod\"] = req.Method\n\t\t} else {\n\t\t\tfilter[\"Territory\"] = req.Region\n\t\t}\n\t} else if req.Status != \"\" {\n\t\tfilter[\"status\"] = req.Status\n\t} else {\n\t\treturn nil, errors.New(\"invalid query parameters\")\n\t}\n\n\tsemester := &Semester{}\n\tresults, err := semester.PreventAttack(filter)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to fetch currency data: %v\", err)\n\t}\n\n\tif len(results) == 0 {\n\t\treturn nil, errors.New(\"no matching records found\")\n\t}\n\treturn results, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Currency",
        "code_value": "type Currency struct {\n\tID          int     `json:\"id\" gorm:\"column:id\"`\n\tTerritory   string  `json:\"territory\" gorm:\"column:territory\"`\n\tAmount      float64 `json:\"amount\" gorm:\"column:total_amount\"`\n\tMethod      string  `json:\"method\" gorm:\"column:attack_method\"`\n\tCreatedAt   int64   `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt   int64   `json:\"updated_at\" gorm:\"column:updated_at\"`"
      },
      {
        "code_key": "AttackFilter",
        "code_value": "type AttackFilter struct {\n\tTerritory    string\n\tAttackMethod string\n\tTotalAmount  float64"
      },
      {
        "code_key": "TableGradeRecords",
        "code_value": "const TableGradeRecords = \"grade_records\""
      },
      {
        "code_key": "DefaultCurrencyLimit",
        "code_value": "const DefaultCurrencyLimit = 1000"
      },
      {
        "code_key": "DefenseStatus",
        "code_value": "type DefenseStatus struct {\n\tActive   bool\n\tLastScan int64"
      }
    ]
  },
  "synthetic_if-else_caller_RebuildIndex": {
    "scenario": "if-else+caller",
    "code_key": "RebuildIndex",
    "code_value": "func (f *Forecast) RebuildIndex(filterParams map[string]interface{}, limit int) ([]types.PlayerProfile, error) {\n\tvar profiles []types.PlayerProfile\n\tdb := base.GetInstance().GormDriver().Table(\"player_profiles\")\n\n\tif registrationTime, exists := filterParams[\"RegistrationTime\"]; exists {\n\t\tdb = db.Where(\"registration_time > ?\", registrationTime).Order(\"registration_time desc\")\n\t} else if floor, exists := filterParams[\"Floor\"]; exists {\n\t\tfilter := make(map[string]interface{})\n\t\tfor k, v := range filterParams {\n\t\t\tif k != \"Floor\" {\n\t\t\t\tfilter[k] = v\n\t\t\t}\n\t\t}\n\t\tdb = db.Where(filter).Where(\"floor >= ?\", floor.(int))\n\t}\n\n\tif limit > 0 {\n\t\tdb = db.Limit(limit)\n\t}\n\n\tif err := db.Find(&profiles).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn profiles, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandlePlayerProfiles",
        "code_value": "func (s *ProfileService) HandlePlayerProfiles(req *types.ProfileRequest) ([]types.PlayerProfile, error) {\n\tfilter := make(map[string]interface{})\n\tvar limit int\n\n\tif req.PlayerID != \"\" {\n\t\tfilter[\"player_id\"] = req.PlayerID\n\t} else if req.TeamID > 0 {\n\t\tfilter[\"team_id\"] = req.TeamID\n\t\tif req.MinScore > 0 {\n\t\t\tfilter[\"score\"] = req.MinScore\n\t\t}\n\t} else if req.Region != \"\" {\n\t\tif err := validateRegion(req.Region); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"invalid region: %v\", err)\n\t\t}\n\t\tfilter[\"region\"] = req.Region\n\t\tlimit = 100\n\t} else {\n\t\treturn nil, errors.New(\"at least one filter parameter is required\")\n\t}\n\n\tif req.Limit > 0 {\n\t\tlimit = req.Limit\n\t}\n\n\tforecast := new(Forecast)\n\tprofiles, err := forecast.RebuildIndex(filter, limit)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to rebuild index: %v\", err)\n\t}\n\treturn profiles, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "PlayerScore",
        "code_value": "type PlayerScore struct {\n\tID        int       `json:\"id\" gorm:\"primaryKey\"`\n\tPlayerID  int       `json:\"player_id\" gorm:\"index\"`\n\tScore     float64   `json:\"score\"`\n\tCreatedAt time.Time `json:\"created_at\"`\n\tUpdatedAt time.Time `json:\"updated_at\"`\n}"
      },
      {
        "code_key": "ScoreFilter",
        "code_value": "type ScoreFilter struct {\n\tMinScore     float64 `json:\"min_score\"`\n\tMaxScore     float64 `json:\"max_score\"`\n\tPlayerIDs    []int   `json:\"player_ids\"`\n\tCreatedAfter string  `json:\"created_after\"`\n}"
      },
      {
        "code_key": "ScoreResult",
        "code_value": "type ScoreResult struct {\n\tScores []PlayerScore `json:\"scores\"`\n\tTotal  int           `json:\"total\"`\n}"
      },
      {
        "code_key": "TablePlayerScores",
        "code_value": "const TablePlayerScores = \"player_scores\""
      },
      {
        "code_key": "DefaultScoreLimit",
        "code_value": "const DefaultScoreLimit = 50"
      }
    ]
  },
  "synthetic_if-else_caller_ListWithPaging": {
    "scenario": "if-else+caller",
    "code_key": "ListWithPaging",
    "code_value": "func (p *Profile) ListWithPaging(filter map[string]interface{}, page, size int) ([]types.ProfileDetail, error) {\n\tprofiles := make([]types.ProfileDetail, 0)\n\tdb := base.GetInstance().MainDriver().Table(\"maintenance_logs\").Order(\"created_at DESC\")\n\n\tif category, ok := filter[\"Category\"]; ok {\n\t\tdelete(filter, \"Category\")\n\t\tdb = db.Where(\"category LIKE ?\", \"%\"+category.(string)+\"%\")\n\t\tif len(filter) > 0 {\n\t\t\tdb = db.Where(filter)\n\t\t}\n\t} else if taskID, ok := filter[\"TaskId\"]; ok {\n\t\tdelete(filter, \"TaskId\")\n\t\tdb = db.Where(\"task_id = ?\", taskID)\n\t\tif len(filter) > 0 {\n\t\t\tdb = db.Where(filter)\n\t\t}\n\t} else {\n\t\tdb = db.Where(filter)\n\t}\n\n\terr := db.Scopes(PaginateDB(page, size)).Find(&profiles).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn profiles, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn profiles, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleSpellSearch",
        "code_value": "func (s *SpellService) HandleSpellSearch(req *types.SpellSearchRequest, log *logger.MagicLog) ([]types.SpellDetail, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.SpellID != \"\" {\n\t\tfilter[\"spell_id\"] = req.SpellID\n\t} else if req.CasterLevel > 0 {\n\t\tfilter[\"min_level\"] = req.CasterLevel\n\t} else if req.ElementType != \"\" {\n\t\tif !utils.IsValidElement(req.ElementType) {\n\t\t\tlog.Error(\"Invalid element type\")\n\t\t\treturn nil, errors.New(\"invalid element type\")\n\t\t}\n\t\tfilter[\"element\"] = req.ElementType\n\t} else {\n\t\tif req.Name != \"\" {\n\t\t\tfilter[\"name\"] = req.Name\n\t\t}\n\t}\n\n\tspellRepo := &Spell{DB: s.DB}\n\tpage, size := utils.GetPagination(req.Page, req.Size)\n\tspells, err := spellRepo.ListWithPaging(filter, page, size)\n\tif err != nil {\n\t\tlog.ErrorV(fmt.Sprintf(\"Search spells failed: %v\", err))\n\t\treturn nil, err\n\t}\n\treturn spells, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "ProfileDetail",
        "code_value": "type ProfileDetail struct {\n\tID        uint      `json:\"id\" gorm:\"primaryKey\"`\n\tName      string    `json:\"name\" gorm:\"column:name\"`\n\tCategory  string    `json:\"category\" gorm:\"column:category\"`\n\tTaskID    string    `json:\"task_id\" gorm:\"column:task_id\"`\n\tCreatedAt time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "MaintenanceLogTable",
        "code_value": "const MaintenanceLogTable = \"maintenance_logs\""
      },
      {
        "code_key": "ProfileFilter",
        "code_value": "type ProfileFilter struct {\n\tCategory string `json:\"category\"`\n\tTaskID   string `json:\"task_id\"`\n\tStatus   int    `json:\"status\"`\n}"
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "MaxPageSize",
        "code_value": "const MaxPageSize = 100"
      },
      {
        "code_key": "ProfileStatus",
        "code_value": "const (\n\tProfileStatusActive = 1\n\tProfileStatusInactive = 2\n\tProfileStatusArchived = 3\n)"
      }
    ]
  },
  "synthetic_if-else_caller_AnalyzePerformance": {
    "scenario": "if-else+caller",
    "code_key": "AnalyzePerformance",
    "code_value": "func (t *Tracking) AnalyzePerformance(filterParams map[string]interface{}, limit int) ([]types.PerformanceMetric, error) {\n\tvar metrics []types.PerformanceMetric\n\tdb := base.GetInstance().GormDriver().Table(\"trading_orders\")\n\n\tif campaignId, ok := filterParams[\"campaign_id\"]; ok {\n\t\tdb = db.Where(\"campaign_id = ? AND status = ?\", campaignId, \"active\")\n\t} else if dateRange, ok := filterParams[\"date_range\"]; ok {\n\t\trangeValues := dateRange.([]string)\n\t\tdb = db.Where(\"created_at BETWEEN ? AND ?\", rangeValues[0], rangeValues[1])\n\t}\n\n\tif className, ok := filterParams[\"class_name\"]; ok {\n\t\tdb = db.Where(\"class_name LIKE ?\", \"%\"+className.(string)+\"%\")\n\t}\n\n\terr := db.Order(\"transaction_id DESC\").Limit(limit).Find(&metrics).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn metrics, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleCampaignMetrics",
        "code_value": "func (s *AnalyticsService) HandleCampaignMetrics(req *types.CampaignMetricsRequest, logger *log.Logger) ([]types.PerformanceMetric, error) {\n\tif req == nil {\n\t\tlogger.Println(\"[HandleCampaignMetrics] Invalid request\")\n\t\treturn nil, fmt.Errorf(\"invalid request\")\n\t}\n\n\tfilters := make(map[string]interface{})\n\tif req.CampaignID != \"\" {\n\t\tfilters[\"campaign_id\"] = req.CampaignID\n\t} else if req.StartDate != \"\" && req.EndDate != \"\" {\n\t\tfilters[\"date_range\"] = []string{req.StartDate, req.EndDate}\n\t} else if req.ClassName != \"\" {\n\t\tif len(req.ClassName) > 50 {\n\t\t\tlogger.Println(\"[HandleCampaignMetrics] Class name too long\")\n\t\t\treturn nil, fmt.Errorf(\"class name exceeds maximum length\")\n\t\t}\n\t\tfilters[\"class_name\"] = req.ClassName\n\t}\n\n\ttracker := &Tracking{}\n\tresult, err := tracker.AnalyzePerformance(filters, req.Limit)\n\tif err != nil {\n\t\tlogger.Printf(\"[HandleCampaignMetrics] Error analyzing performance: %v\", err)\n\t\treturn nil, err\n\t}\n\n\tif len(result) == 0 {\n\t\tlogger.Println(\"[HandleCampaignMetrics] No metrics found\")\n\t}\n\n\treturn result, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "PerformanceMetric",
        "code_value": "type PerformanceMetric struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tCampaignID    string    `json:\"campaign_id\" gorm:\"column:campaign_id\"`\n\tClassName     string    `json:\"class_name\" gorm:\"column:class_name\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n\tTransactionID string    `json:\"transaction_id\" gorm:\"column:transaction_id\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tValue         float64   `json:\"value\" gorm:\"column:value\"`\n}"
      },
      {
        "code_key": "TrackingOrderStatus",
        "code_value": "const (\n\tOrderStatusActive   = \"active\"\n\tOrderStatusPending  = \"pending\"\n\tOrderStatusCanceled = \"canceled\"\n)"
      },
      {
        "code_key": "DefaultQueryLimit",
        "code_value": "const DefaultQueryLimit = 100"
      },
      {
        "code_key": "TrackingTableName",
        "code_value": "const TrackingTableName = \"trading_orders\""
      },
      {
        "code_key": "PerformanceFilter",
        "code_value": "type PerformanceFilter struct {\n\tCampaignID *string   `json:\"campaign_id\"`\n\tDateRange  []string  `json:\"date_range\"`\n\tClassName  *string   `json:\"class_name\"`\n}"
      }
    ]
  },
  "synthetic_if-else_caller_GenerateReport": {
    "scenario": "if-else+caller",
    "code_key": "GenerateReport",
    "code_value": "func (v *Video) GenerateReport(filterParams map[string]interface{}, pageSize, pageNum int) ([]types.Layout, error) {\n\tvar layouts []types.Layout\n\tdb := base.GetInstance().GormDriver().Table(\"market_data\")\n\n\tif region, ok := filterParams[\"region\"]; ok {\n\t\tdelete(filterParams, \"region\")\n\t\tdb = db.Where(\"region LIKE ?\", \"%\"+region.(string)+\"%\")\n\t}\n\n\tif len(filterParams) > 0 {\n\t\tdb = db.Where(filterParams)\n\t}\n\n\tif err := db.Scopes(Paginate(pageSize, pageNum)).Order(\"created_at DESC\").Find(&layouts).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.DataNotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn layouts, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleVideoReport",
        "code_value": "func (v *VideoHandler) HandleVideoReport(req *types.VideoReportRequest, log *logger.AppLog) ([]types.Layout, error) {\n\tfilterParams := make(map[string]interface{})\n\tif req.VideoID != \"\" {\n\t\tfilterParams[\"video_id\"] = req.VideoID\n\t} else if req.CreatorName != \"\" {\n\t\tif len(req.CreatorName) > 50 {\n\t\t\tlog.Error(\"CreatorName too long\")\n\t\t\treturn nil, errors.New(\"invalid creator name\")\n\t\t}\n\t\tfilterParams[\"creator\"] = req.CreatorName\n\t} else if req.Status > 0 {\n\t\tif req.Status < 1 || req.Status > 5 {\n\t\t\tlog.Error(\"Invalid status value\")\n\t\t\treturn nil, errors.New(\"invalid status\")\n\t\t}\n\t\tfilterParams[\"status\"] = req.Status\n\t} else {\n\t\tfilterParams[\"is_active\"] = true\n\t}\n\n\tif req.Region != \"\" {\n\t\tfilterParams[\"region\"] = req.Region\n\t}\n\n\tvideo := &Video{}\n\tpageSize := 20\n\tif req.PageSize > 0 {\n\t\tpageSize = req.PageSize\n\t}\n\n\tlayouts, err := video.GenerateReport(filterParams, pageSize, req.PageNum)\n\tif err != nil {\n\t\tlog.Errorf(\"Generate report failed: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn layouts, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Layout",
        "code_value": "type Layout struct {\n\tID          uint      `gorm:\"primaryKey\"`\n\tRegion      string    `gorm:\"column:region\"`\n\tMarketValue float64   `gorm:\"column:market_value\"`\n\tCreatedAt   time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt   time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "ReportFilter",
        "code_value": "type ReportFilter struct {\n\tRegion       string `json:\"region\"`\n\tMarketType   string `json:\"market_type\"`\n\tMinValue     int    `json:\"min_value\"`\n\tMaxValue     int    `json:\"max_value\"`\n\tActiveStatus bool   `json:\"active_status\"`\n}"
      },
      {
        "code_key": "MarketTable",
        "code_value": "const MarketTable = \"market_data\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "VideoManager",
        "code_value": "type VideoManager struct {\n\tDB *gorm.DB\n}"
      }
    ]
  },
  "synthetic_if-else_caller_SearchByKeyword": {
    "scenario": "if-else+caller",
    "code_key": "SearchByKeyword",
    "code_value": "func (s *Story) SearchByKeyword(filterParams map[string]interface{}, page, size int) ([]types.StoryContent, error) {\n\tresults := make([]types.StoryContent, 0)\n\tvar err error\n\tdb := base.GetInstance().MainDB().Table(\"treatment_plans\")\n\n\tif keyword, ok := filterParams[\"keyword\"]; ok {\n\t\tfilter := make(map[string]interface{})\n\t\tfor k, v := range filterParams {\n\t\t\tif k == \"keyword\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfilter[k] = v\n\t\t}\n\t\terr = db.Where(filter).Where(\"title LIKE ? OR description LIKE ?\", \n\t\t\t\"%\"+keyword.(string)+\"%\", \"%\"+keyword.(string)+\"%\").\n\t\t\tOrder(\"created_at DESC\").Scopes(PaginateDB(page, size)).Find(&results).Error\n\t} else {\n\t\terr = db.Where(filterParams).Order(\"created_at DESC\").\n\t\t\tScopes(PaginateDB(page, size)).Find(&results).Error\n\t}\n\n\tif err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn results, utils.NotFoundError\n\t\t}\n\t\treturn results, err\n\t}\n\treturn results, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleStoryQuery",
        "code_value": "func (h *StoryHandler) HandleStoryQuery(req *types.StoryQueryRequest, log *logger.AppLog) ([]types.StoryContent, error) {\n\tpage, size := utils.GetPagination(req.Page, req.Size)\n\tfilter := make(map[string]interface{})\n\n\tif req.ID > 0 {\n\t\tfilter[\"id\"] = req.ID\n\t} else if req.Author != \"\" {\n\t\tif len(req.Author) > 100 {\n\t\t\tlog.Error(\"author name too long\")\n\t\t\treturn nil, utils.InvalidParamError\n\t\t}\n\t\tfilter[\"author\"] = req.Author\n\t} else if req.Status != \"\" {\n\t\tif !utils.IsValidStatus(req.Status) {\n\t\t\tlog.Error(\"invalid status value\")\n\t\t\treturn nil, utils.InvalidParamError\n\t\t}\n\t\tfilter[\"status\"] = req.Status\n\t} else {\n\t\tfilter[\"is_featured\"] = true\n\t}\n\n\tif req.Keyword != \"\" {\n\t\tfilter[\"keyword\"] = req.Keyword\n\t}\n\n\tstory := &model.Story{}\n\tcontents, err := story.SearchByKeyword(filter, page, size)\n\tif err != nil {\n\t\tlog.Error(fmt.Sprintf(\"SearchByKeyword failed: %v\", err))\n\t\treturn nil, err\n\t}\n\n\treturn contents, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "StoryContent",
        "code_value": "type StoryContent struct {\n\tID          int       `json:\"id\" gorm:\"column:id\"`\n\tTitle       string    `json:\"title\" gorm:\"column:title\"`\n\tDescription string    `json:\"description\" gorm:\"column:description\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt   time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "StoryResponse",
        "code_value": "type StoryResponse struct {\n\tData       []StoryContent `json:\"data\"`\n\tTotalCount int            `json:\"total_count\"`\n\tPage       int            `json:\"page\"`\n\tSize       int            `json:\"size\"`\n\tStatus     string         `json:\"status\"`\n}"
      },
      {
        "code_key": "StoryFilterParams",
        "code_value": "type StoryFilterParams struct {\n\tKeyword     string `json:\"keyword\"`\n\tCategory    string `json:\"category\"`\n\tAuthorID    int    `json:\"author_id\"`\n\tPublishDate string `json:\"publish_date\"`\n}"
      },
      {
        "code_key": "TreatmentPlansTable",
        "code_value": "const TreatmentPlansTable = \"treatment_plans\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      }
    ]
  },
  "synthetic_if-else_caller_EvaluateResults": {
    "scenario": "if-else+caller",
    "code_key": "EvaluateResults",
    "code_value": "func (t *Tracking) EvaluateResults(filterParams map[string]interface{}, limit int) ([]types.LabTestRecord, error) {\n\tvar records []types.LabTestRecord\n\tdb := base.GetInstance().IvcDriver().Table(\"lab_test_results\")\n\n\tif reactivationDate, exists := filterParams[\"ReactivationDate\"]; exists {\n\t\tdb = db.Where(\"reactivation_date > ?\", reactivationDate)\n\t\tif room, exists := filterParams[\"Room\"]; exists {\n\t\t\tdb = db.Where(\"room = ?\", room)\n\t\t}\n\t} else if subCategory, exists := filterParams[\"SubCategory\"]; exists {\n\t\tdb = db.Where(\"sub_category LIKE ?\", \"%\"+subCategory.(string)+\"%\")\n\t}\n\n\terr := db.Order(\"created_at DESC\").Limit(limit).Find(&records).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleCertificateAnalysis",
        "code_value": "func (s *CertService) HandleCertificateAnalysis(req *types.CertAnalysisRequest) ([]types.LabTestRecord, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.CertID != \"\" {\n\t\tfilter[\"ReactivationDate\"] = time.Now().AddDate(0, -6, 0) // 6 months ago\n\t\tfilter[\"Room\"] = \"certification\"\n\t} else if req.AnalysisType == \"full\" {\n\t\tif req.StartDate.IsZero() || req.EndDate.IsZero() {\n\t\t\treturn nil, fmt.Errorf(\"start and end dates are required for full analysis\")\n\t\t}\n\t\tfilter[\"ReactivationDate\"] = req.StartDate\n\t} else if req.Keyword != \"\" {\n\t\tif len(req.Keyword) < 3 {\n\t\t\treturn nil, fmt.Errorf(\"search keyword must be at least 3 characters\")\n\t\t}\n\t\tfilter[\"SubCategory\"] = req.Keyword\n\t} else {\n\t\treturn nil, fmt.Errorf(\"no valid filter parameters provided\")\n\t}\n\n\ttracker := &Tracking{}\n\tresults, err := tracker.EvaluateResults(filter, 100)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to evaluate results: %v\", err)\n\t}\n\t\n\tif len(results) == 0 {\n\t\treturn nil, fmt.Errorf(\"no records found matching criteria\")\n\t}\n\treturn results, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "LabTestRecord",
        "code_value": "type LabTestRecord struct {\n\tID               int       `json:\"id\" gorm:\"column:id\"`\n\tTestName         string    `json:\"test_name\" gorm:\"column:test_name\"`\n\tSubCategory      string    `json:\"sub_category\" gorm:\"column:sub_category\"`\n\tRoom             string    `json:\"room\" gorm:\"column:room\"`\n\tReactivationDate time.Time `json:\"reactivation_date\" gorm:\"column:reactivation_date\"`\n\tCreatedAt        time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt        time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "FilterParams",
        "code_value": "type FilterParams struct {\n\tReactivationDate *time.Time\n\tRoom            *string\n\tSubCategory     *string\n}"
      },
      {
        "code_key": "LabTestTable",
        "code_value": "const LabTestTable = \"lab_test_results\""
      },
      {
        "code_key": "DefaultQueryLimit",
        "code_value": "const DefaultQueryLimit = 100"
      },
      {
        "code_key": "TestStatus",
        "code_value": "const (\n\tTestStatusPending = \"pending\"\n\tTestStatusCompleted = \"completed\"\n\tTestStatusFailed = \"failed\"\n)"
      }
    ]
  },
  "synthetic_if-else_caller_FindVaccinationRecords": {
    "scenario": "if-else+caller",
    "code_key": "FindVaccinationRecords",
    "code_value": "func (v *Vaccination) FindVaccinationRecords(filter map[string]interface{}, page, size int) ([]types.VaccinationRecord, error) {\n\tvar records []types.VaccinationRecord\n\tdb := base.GetInstance().HealthDB().Table(\"vaccination_records\")\n\t\n\tif batchNo, ok := filter[\"batch_no\"]; ok {\n\t\tdelete(filter, \"batch_no\")\n\t\tdb = db.Where(filter).Where(\"batch_no LIKE ?\", \"%\"+batchNo.(string)+\"%\")\n\t} else if facilityId, ok := filter[\"facility_id\"]; ok {\n\t\tdelete(filter, \"facility_id\")\n\t\tdb = db.Where(filter).Where(\"facility_id = ?\", facilityId.(int))\n\t} else {\n\t\tdb = db.Where(filter)\n\t}\n\t\n\terr := db.Scopes(PaginateDB(page, size)).Find(&records).Error\n\tif err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn nil, utils.RecordNotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleVaccinationQuery",
        "code_value": "func (h *VaccinationHandler) HandleVaccinationQuery(req *types.VaccinationQueryRequest) ([]types.VaccinationRecord, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.PatientID != \"\" {\n\t\tfilter[\"patient_id\"] = req.PatientID\n\t} else if req.VaccineType != \"\" {\n\t\tif !utils.IsValidVaccineType(req.VaccineType) {\n\t\t\treturn nil, utils.InvalidParamError\n\t\t}\n\t\tfilter[\"vaccine_type\"] = req.VaccineType\n\t} else if req.Status != 0 {\n\t\tif req.Status < 1 || req.Status > 3 {\n\t\t\treturn nil, utils.InvalidParamError\n\t\t}\n\t\tfilter[\"status\"] = req.Status\n\t} else {\n\t\treturn nil, utils.MissingParamError\n\t}\n\t\n\tvaccination := &model.Vaccination{}\n\tpage, size := utils.ParsePagination(req.Page, req.Size)\n\t\n\trecords, err := vaccination.FindVaccinationRecords(filter, page, size)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "VaccinationRecord",
        "code_value": "type VaccinationRecord struct {\n\tID          int       `json:\"id\" gorm:\"column:id\"`\n\tPatientID   string    `json:\"patient_id\" gorm:\"column:patient_id\"`\n\tVaccineType string    `json:\"vaccine_type\" gorm:\"column:vaccine_type\"`\n\tBatchNo     string    `json:\"batch_no\" gorm:\"column:batch_no\"`\n\tFacilityID  int       `json:\"facility_id\" gorm:\"column:facility_id\"`\n\tAdminDate   time.Time `json:\"admin_date\" gorm:\"column:administered_at\"`\n\tDoseNumber  int       `json:\"dose_number\" gorm:\"column:dose_number\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt   time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "VaccinationFilter",
        "code_value": "type VaccinationFilter struct {\n\tPatientID   *string    `json:\"patient_id\"`\n\tVaccineType *string    `json:\"vaccine_type\"`\n\tBatchNo     *string    `json:\"batch_no\"`\n\tFacilityID  *int       `json:\"facility_id\"`\n\tStartDate   *time.Time `json:\"start_date\"`\n\tEndDate     *time.Time `json:\"end_date\"`\n}"
      },
      {
        "code_key": "VaccinationTableName",
        "code_value": "const VaccinationTableName = \"vaccination_records\""
      },
      {
        "code_key": "VaccinationStatus",
        "code_value": "const (\n\tVaccinationPending = \"PENDING\"\n\tVaccinationCompleted = \"COMPLETED\"\n\tVaccinationCancelled = \"CANCELLED\"\n)"
      },
      {
        "code_key": "PaginateDB",
        "code_value": "func PaginateDB(page, size int) func(db *gorm.DB) *gorm.DB {\n\treturn func(db *gorm.DB) *gorm.DB {\n\t\toffset := (page - 1) * size\n\t\treturn db.Offset(offset).Limit(size)\n\t}\n}"
      }
    ]
  },
  "synthetic_if-else_caller_QueryDiagnosticResults": {
    "scenario": "if-else+caller",
    "code_key": "QueryDiagnosticResults",
    "code_value": "func (d *Diagnostic) QueryDiagnosticResults(filters map[string]interface{}, page, size int) ([]types.DiagnosticRecord, error) {\n\tvar records []types.DiagnosticRecord\n\tdb := base.GetInstance().PrimaryDB().Table(\"diagnostic_results\").Order(\"RegistrationTime DESC\")\n\n\tif approval, ok := filters[\"ApprovalLevel\"]; ok {\n\t\t// Exact match for approval level\n\t\tdelete(filters, \"ApprovalLevel\")\n\t\tdb = db.Where(\"approval_level = ?\", approval).Where(filters)\n\t} else if address, ok := filters[\"WorkAddress\"]; ok {\n\t\t// Partial match for work address\n\t\tdelete(filters, \"WorkAddress\")\n\t\tdb = db.Where(\"work_address LIKE ?\", \"%\"+address.(string)+\"%\").Where(filters)\n\t} else {\n\t\tdb = db.Where(filters)\n\t}\n\n\terr := db.Scopes(PaginateDB(page, size)).Find(&records).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleResourceAccessLogs",
        "code_value": "func (h *ResourceHandler) HandleResourceAccessLogs(req *types.AccessLogRequest, logger *log.Logger) ([]types.DiagnosticRecord, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.ResourceID != \"\" {\n\t\tfilter[\"resource_id\"] = req.ResourceID\n\t} else if req.UserEmail != \"\" {\n\t\tif !strings.Contains(req.UserEmail, \"@\") {\n\t\t\tlogger.Printf(\"Invalid email format: %s\", req.UserEmail)\n\t\t\treturn nil, fmt.Errorf(\"invalid email format\")\n\t\t}\n\t\tfilter[\"user_email\"] = req.UserEmail\n\t} else if req.Status != 0 {\n\t\tif req.Status < 1 || req.Status > 3 {\n\t\t\tlogger.Printf(\"Invalid status value: %d\", req.Status)\n\t\t\treturn nil, fmt.Errorf(\"status must be 1-3\")\n\t\t}\n\t\tfilter[\"status\"] = req.Status\n\t} else {\n\t\tfilter[\"timestamp\"] = req.TimeRange\n\t}\n\n\td := &Diagnostic{}\n\tresult, err := d.QueryDiagnosticResults(filter, req.Page, req.PageSize)\n\tif err != nil {\n\t\tlogger.Printf(\"Query failed: %v\", err)\n\t\treturn nil, fmt.Errorf(\"query failed: %w\", err)\n\t}\n\treturn result, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "DiagnosticRecord",
        "code_value": "type DiagnosticRecord struct {\n\tID                int       `json:\"id\" gorm:\"column:id\"`\n\tPatientName       string    `json:\"patient_name\" gorm:\"column:patient_name\"`\n\tRegistrationTime  time.Time `json:\"registration_time\" gorm:\"column:registration_time\"`\n\tApprovalLevel     int       `json:\"approval_level\" gorm:\"column:approval_level\"`\n\tWorkAddress       string    `json:\"work_address\" gorm:\"column:work_address\"`\n\tDiagnosisCode     string    `json:\"diagnosis_code\" gorm:\"column:diagnosis_code\"`\n\tStatus            int       `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt         time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt         time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "DiagnosticFilterRequest",
        "code_value": "type DiagnosticFilterRequest struct {\n\tPatientName   string `json:\"patient_name\"`\n\tApprovalLevel int    `json:\"approval_level\"`\n\tWorkAddress   string `json:\"work_address\"`\n\tStatus        int    `json:\"status\"`\n\tPage          int    `json:\"page\"`\n\tPageSize      int    `json:\"page_size\"`\n}"
      },
      {
        "code_key": "DiagnosticResultResponse",
        "code_value": "type DiagnosticResultResponse struct {\n\tRecords       []DiagnosticRecord `json:\"records\"`\n\tTotalCount    int                `json:\"total_count\"`\n\tCurrentPage   int                `json:\"current_page\"`\n\tTotalPages    int                `json:\"total_pages\"`\n}"
      },
      {
        "code_key": "DiagnosticStatus",
        "code_value": "const (\n\tStatusPending  = 0\n\tStatusApproved = 1\n\tStatusRejected = 2\n)"
      },
      {
        "code_key": "TableDiagnosticResults",
        "code_value": "const TableDiagnosticResults = \"diagnostic_results\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      }
    ]
  },
  "synthetic_if-else_caller_LoadBalance": {
    "scenario": "if-else+caller",
    "code_key": "LoadBalance",
    "code_value": "func (p *Publication) LoadBalance(filter map[string]interface{}) ([]types.ContentDistribution, error) {\n\tvar distributions []types.ContentDistribution\n\tdb := base.GetInstance().PrimaryDB().Table(\"content_reports\")\n\n\tif region, ok := filter[\"Region\"]; ok {\n\t\tdelete(filter, \"Region\")\n\t\tdb = db.Where(\"region LIKE ?\", \"%\"+region.(string)+\"%\")\n\t}\n\n\tif priority, ok := filter[\"Priority\"]; ok {\n\t\tdb = db.Where(\"priority_level = ?\", priority.(int))\n\t\tdelete(filter, \"Priority\")\n\t}\n\n\tif len(filter) > 0 {\n\t\tdb = db.Where(filter)\n\t}\n\n\tif err := db.Find(&distributions).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.NotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn distributions, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleContentDistribution",
        "code_value": "func (h *ContentHandler) HandleContentDistribution(req *types.ContentDistributionRequest) ([]types.ContentDistribution, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.ContentID != \"\" {\n\t\tfilter[\"content_id\"] = req.ContentID\n\t} else if req.Status != 0 {\n\t\tif req.Status < 1 || req.Status > 3 {\n\t\t\treturn nil, fmt.Errorf(\"invalid status value: %d\", req.Status)\n\t\t}\n\t\tfilter[\"status\"] = req.Status\n\t} else if req.CreatedAfter != \"\" {\n\t\tif _, err := time.Parse(time.RFC3339, req.CreatedAfter); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"invalid date format: %v\", err)\n\t\t}\n\t\tfilter[\"created_at > ?\"] = req.CreatedAfter\n\t} else {\n\t\treturn nil, fmt.Errorf(\"at least one filter parameter is required\")\n\t}\n\t\n\tif req.Region != \"\" {\n\t\tfilter[\"Region\"] = req.Region\n\t}\n\t\n\tif req.Priority != 0 {\n\t\tfilter[\"Priority\"] = req.Priority\n\t}\n\t\n\tpub := &Publication{}\n\treturn pub.LoadBalance(filter)\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "ContentDistribution",
        "code_value": "type ContentDistribution struct {\n\tID             int       `json:\"id\" gorm:\"column:id\"`\n\tContentID      string    `json:\"content_id\" gorm:\"column:content_id\"`\n\tRegion         string    `json:\"region\" gorm:\"column:region\"`\n\tPriorityLevel  int       `json:\"priority_level\" gorm:\"column:priority_level\"`\n\tDistributionAt time.Time `json:\"distribution_at\" gorm:\"column:distribution_at\"`\n\tStatus         int       `json:\"status\" gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "DistributionStatus",
        "code_value": "const (\n\tStatusPending = iota\n\tStatusProcessing\n\tStatusCompleted\n\tStatusFailed\n)"
      },
      {
        "code_key": "ContentTable",
        "code_value": "const ContentTable = \"content_reports\""
      },
      {
        "code_key": "DistributionFilter",
        "code_value": "type DistributionFilter struct {\n\tRegion   string\n\tPriority int\n\tStatus   int\n\tContentIDs []string\n}"
      }
    ]
  },
  "synthetic_if-else_caller_TrackLabResults": {
    "scenario": "if-else+caller",
    "code_key": "TrackLabResults",
    "code_value": "func (l *Lab) TrackLabResults(filterParams map[string]interface{}, page, size int) ([]types.LabTestResult, error) {\n\tresults := make([]types.LabTestResult, 0)\n\tdb := base.GetInstance().LabDriver().Table(\"lab_test_results\")\n\n\tif area, exists := filterParams[\"Area\"]; exists {\n\t\t// Filter by area with exact match and sort by CreationTime\n\t\terr := db.Where(\"area = ?\", area).\n\t\t\tOrder(\"creation_time desc\").\n\t\t\tScopes(PaginateDB(page, size)).\n\t\t\tFind(&results).Error\n\t\treturn results, err\n\t} else if desc, exists := filterParams[\"Description\"]; exists {\n\t\t// Filter by description with partial match\n\t\terr := db.Where(\"description LIKE ?\", \"%\"+desc.(string)+\"%\").\n\t\t\tOrder(\"id\").\n\t\t\tScopes(PaginateDB(page, size)).\n\t\t\tFind(&results).Error\n\t\treturn results, err\n\t}\n\n\t// Default query without area or description filters\n\terr := db.Where(filterParams).\n\t\tOrder(\"id\").\n\t\tScopes(PaginateDB(page, size)).\n\t\tFind(&results).Error\n\treturn results, err\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleTestResults",
        "code_value": "func (h *LabHandler) HandleTestResults(req *types.QueryLabResultsRequest) ([]types.LabTestResult, error) {\n\tfilterParams := make(map[string]interface{})\n\tif req.PatientID != \"\" {\n\t\tfilterParams[\"PatientID\"] = req.PatientID\n\t} else if req.TestCode != \"\" {\n\t\tfilterParams[\"TestCode\"] = req.TestCode\n\t} else if req.Status > 0 {\n\t\tif req.Status < 1 || req.Status > 3 {\n\t\t\treturn nil, fmt.Errorf(\"invalid status value\")\n\t\t}\n\t\tfilterParams[\"Status\"] = req.Status\n\t}\n\n\tlab := &Lab{}\n\tpage, size := utils.GetPaginationParams(req.Page, req.Size)\n\tresults, err := lab.TrackLabResults(filterParams, page, size)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to track lab results: %v\", err)\n\t}\n\treturn results, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "LabTestResult",
        "code_value": "type LabTestResult struct {\n\tID           int       `json:\"id\" gorm:\"column:id\"`\n\tArea         string    `json:\"area\" gorm:\"column:area\"`\n\tDescription  string    `json:\"description\" gorm:\"column:description\"`\n\tResultValue  float64   `json:\"result_value\" gorm:\"column:result_value\"`\n\tCreationTime time.Time `json:\"creation_time\" gorm:\"column:creation_time\"`\n\tStatus       int       `json:\"status\" gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "LabFilterRequest",
        "code_value": "type LabFilterRequest struct {\n\tArea        *string `json:\"area,omitempty\"`\n\tDescription *string `json:\"description,omitempty\"`\n\tPage        int     `json:\"page\"`\n\tSize        int     `json:\"size\"`\n}"
      },
      {
        "code_key": "LabTestResponse",
        "code_value": "type LabTestResponse struct {\n\tResults     []LabTestResult `json:\"results\"`\n\tTotalCount  int             `json:\"total_count\"`\n\tCurrentPage int             `json:\"current_page\"`\n}"
      },
      {
        "code_key": "LabTestStatus",
        "code_value": "const (\n\tLabStatusPending   = 0\n\tLabStatusApproved = 1\n\tLabStatusRejected = 2\n)"
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      }
    ]
  },
  "synthetic_if-else_caller_MergeRecords": {
    "scenario": "if-else+caller",
    "code_key": "MergeRecords",
    "code_value": "func (p *Paragraph) MergeRecords(filterParams map[string]interface{}, page, size int) ([]types.ResourceAllocation, error) {\n\tvar allocations []types.ResourceAllocation\n\tdb := base.GetInstance().GormDB().Table(\"resource_allocation\")\n\t\n\tif region, exists := filterParams[\"Region\"]; exists {\n\t\tif activationDate, ok := filterParams[\"ActivationDate\"]; ok {\n\t\t\tdb = db.Where(\"region = ? AND activation_date >= ?\", region, activationDate)\n\t\t} else {\n\t\t\tdb = db.Where(\"region LIKE ?\", \"%\"+region.(string)+\"%\")\n\t\t}\n\t} else if scheduledTime, exists := filterParams[\"ScheduledTime\"]; exists {\n\t\tdb = db.Where(\"scheduled_time BETWEEN ? AND ?\", \n\t\t\tscheduledTime.([]interface{})[0], \n\t\t\tscheduledTime.([]interface{})[1])\n\t}\n\t\n\terr := db.Scopes(PaginateDB(page, size)).Find(&allocations).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.RecordNotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn allocations, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleProjectAllocation",
        "code_value": "func (p *ProjectHandler) HandleProjectAllocation(req *types.ProjectAllocationRequest, log *logger.ProjectLog) ([]types.ResourceAllocation, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.ProjectID != \"\" {\n\t\tfilter[\"Region\"] = \"region_\" + req.ProjectID[:3]\n\t} else if req.TimeRange != nil {\n\t\tif len(req.TimeRange) == 2 {\n\t\t\tfilter[\"ScheduledTime\"] = []interface{}{req.TimeRange[0], req.TimeRange[1]}\n\t\t} else {\n\t\t\treturn nil, utils.InvalidParamError\n\t\t}\n\t} else if req.Status != \"\" {\n\t\tfilter[\"ActivationDate\"] = time.Now().AddDate(0, 0, -7)\n\t} else {\n\t\treturn nil, utils.MissingParamError\n\t}\n\t\n\tpara := &Paragraph{}\n\tallocations, err := para.MergeRecords(filter, req.Page, req.Size)\n\tif err != nil {\n\t\tlog.ErrorV(fmt.Sprintf(\"[HandleProjectAllocation] MergeRecords failed: %v\", err), utils.OperationErr)\n\t\treturn nil, err\n\t}\n\t\n\treturn allocations, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "ResourceAllocation",
        "code_value": "type ResourceAllocation struct {\n\tID             int       `json:\"id\" gorm:\"column:id\"`\n\tRegion         string    `json:\"region\" gorm:\"column:region\"`\n\tActivationDate time.Time `json:\"activation_date\" gorm:\"column:activation_date\"`\n\tScheduledTime  time.Time `json:\"scheduled_time\" gorm:\"column:scheduled_time\"`\n\tResourceID     int       `json:\"resource_id\" gorm:\"column:resource_id\"`\n\tStatus         int       `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt      time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt      time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "AllocationFilter",
        "code_value": "type AllocationFilter struct {\n\tRegion         *string    `json:\"region\"`\n\tActivationDate *time.Time `json:\"activation_date\"`\n\tScheduledTime  [2]time.Time `json:\"scheduled_time\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "const TableName = \"resource_allocation\""
      },
      {
        "code_key": "AllocationStatus",
        "code_value": "const (\n\tAllocationPending = iota\n\tAllocationActive\n\tAllocationCompleted\n\tAllocationCancelled\n)"
      },
      {
        "code_key": "defaultPageSize",
        "code_value": "var defaultPageSize = 20"
      }
    ]
  },
  "synthetic_if-else_caller_CleanupOldData": {
    "scenario": "if-else+caller",
    "code_key": "CleanupOldData",
    "code_value": "func (p *Patient) CleanupOldData(filter map[string]interface{}) (int64, error) {\n    var count int64\n    db := base.GetInstance().MainDB().Table(\"surgery_schedules\")\n    \n    if lastAccess, exists := filter[\"LastAccessTime\"]; exists {\n        // Cleanup strategy 1: Delete records older than specified timestamp\n        result := db.Where(\"last_access_time < ?\", lastAccess).Delete(&Layout{})\n        if result.Error != nil {\n            return 0, result.Error\n        }\n        count = result.RowsAffected\n    } else if taskId, exists := filter[\"TaskId\"]; exists {\n        // Cleanup strategy 2: Delete records matching specific task ID pattern\n        result := db.Where(\"task_id LIKE ?\", \"%\"+taskId.(string)+\"%\").Delete(&Layout{})\n        if result.Error != nil {\n            return 0, result.Error\n        }\n        count = result.RowsAffected\n    } else {\n        // Default cleanup strategy\n        result := db.Where(filter).Delete(&Layout{})\n        if result.Error != nil {\n            return 0, result.Error\n        }\n        count = result.RowsAffected\n    }\n    \n    return count, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandlePatientRecords",
        "code_value": "func (h *PatientHandler) HandlePatientRecords(req *types.PatientRecordsRequest) (int64, error) {\n    if req == nil {\n        return 0, errors.New(\"request cannot be nil\")\n    }\n    \n    patient := &Patient{}\n    criteria := make(map[string]interface{})\n    \n    if req.ExpiredBefore > 0 {\n        criteria[\"LastAccessTime\"] = req.ExpiredBefore\n    } else if len(req.TreatmentCode) > 0 {\n        if !utils.IsValidTreatmentCode(req.TreatmentCode) {\n            return 0, errors.New(\"invalid treatment code format\")\n        }\n        criteria[\"TaskId\"] = req.TreatmentCode\n    } else if req.Status != \"\" {\n        if req.Status != \"active\" && req.Status != \"archived\" {\n            return 0, errors.New(\"invalid status value\")\n        }\n        criteria[\"status\"] = req.Status\n    } else {\n        criteria[\"department\"] = req.Department\n    }\n    \n    affected, err := patient.CleanupOldData(criteria)\n    if err != nil {\n        return 0, fmt.Errorf(\"failed to cleanup records: %v\", err)\n    }\n    \n    return affected, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "SurgerySchedule",
        "code_value": "type SurgerySchedule struct {\n\tID             int64     `json:\"id\" gorm:\"column:id;primary_key\"`\n\tTaskID         string    `json:\"task_id\" gorm:\"column:task_id\"`\n\tLastAccessTime time.Time `json:\"last_access_time\" gorm:\"column:last_access_time\"`\n\tStatus         int       `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt      time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt      time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "CleanupRequest",
        "code_value": "type CleanupRequest struct {\n\tLastAccessTime *time.Time `json:\"last_access_time,omitempty\"`\n\tTaskID         *string    `json:\"task_id,omitempty\"`\n\tFilters        map[string]interface{} `json:\"filters,omitempty\"`\n}"
      },
      {
        "code_key": "CleanupResponse",
        "code_value": "type CleanupResponse struct {\n\tDeletedCount int64  `json:\"deleted_count\"`\n\tError        string `json:\"error,omitempty\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "const TableName = \"surgery_schedules\""
      },
      {
        "code_key": "CleanupStatus",
        "code_value": "const (\n\tCleanupPending = iota\n\tCleanupInProgress\n\tCleanupCompleted\n\tCleanupFailed\n)"
      },
      {
        "code_key": "DefaultCleanupWindow",
        "code_value": "var DefaultCleanupWindow = 30 * 24 * time.Hour"
      }
    ]
  },
  "synthetic_if-else_caller_OptimizeRoutes": {
    "scenario": "if-else+caller",
    "code_key": "OptimizeRoutes",
    "code_value": "func (e *Exchange) OptimizeRoutes(filterParams map[string]interface{}) ([]types.Tournament, error) {\n\tvar tournaments []types.Tournament\n\tdb := base.GetInstance().MainDB().Table(\"health_metrics\")\n\n\tif routeId, exists := filterParams[\"RouteId\"]; exists {\n\t\tdb = db.Where(\"route_id = ?\", routeId)\n\t\tif priority, hasPriority := filterParams[\"Priority\"]; hasPriority {\n\t\t\tdb = db.Where(\"priority > ?\", priority)\n\t\t}\n\t} else if location, hasLocation := filterParams[\"Location\"]; hasLocation {\n\t\tdb = db.Where(\"location LIKE ?\", \"%\"+location.(string)+\"%\")\n\t}\n\n\terr := db.Order(\"scheduled_time desc\").Find(&tournaments).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn tournaments, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleTournamentSearch",
        "code_value": "func (h *TournamentHandler) HandleTournamentSearch(req *types.TournamentSearchRequest) ([]types.Tournament, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.RouteID != \"\" {\n\t\tfilter[\"RouteId\"] = req.RouteID\n\t\tif req.MinPriority > 0 {\n\t\t\tfilter[\"Priority\"] = req.MinPriority\n\t\t}\n\t} else if req.Location != \"\" {\n\t\tif len(req.Location) < 3 {\n\t\t\treturn nil, errors.New(\"location query too short\")\n\t\t}\n\t\tfilter[\"Location\"] = req.Location\n\t} else if req.Status != 0 {\n\t\tfilter[\"Status\"] = req.Status\n\t} else {\n\t\treturn nil, errors.New(\"no valid search criteria provided\")\n\t}\n\n\texchange := &Exchange{}\n\tresults, err := exchange.OptimizeRoutes(filter)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to optimize routes: %v\", err)\n\t}\n\t\n\tif len(results) == 0 {\n\t\treturn nil, errors.New(\"no tournaments found matching criteria\")\n\t}\n\treturn results, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Tournament",
        "code_value": "type Tournament struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tRouteID       string    `json:\"route_id\" gorm:\"column:route_id\"`\n\tPriority      int       `json:\"priority\" gorm:\"column:priority\"`\n\tLocation      string    `json:\"location\" gorm:\"column:location\"`\n\tScheduledTime time.Time `json:\"scheduled_time\" gorm:\"column:scheduled_time\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "RouteFilterParams",
        "code_value": "type RouteFilterParams struct {\n\tRouteId  string\n\tPriority int\n\tLocation string\n}"
      },
      {
        "code_key": "TableNameTournament",
        "code_value": "const TableNameTournament = \"health_metrics\""
      },
      {
        "code_key": "TournamentStatus",
        "code_value": "const (\n\tTournamentPending   = \"pending\"\n\tTournamentActive    = \"active\"\n\tTournamentCompleted = \"completed\"\n)"
      },
      {
        "code_key": "DefaultPriority",
        "code_value": "const DefaultPriority = 5"
      }
    ]
  },
  "synthetic_if-else_caller_FetchWithFilter": {
    "scenario": "if-else+caller",
    "code_key": "FetchWithFilter",
    "code_value": "func (a *Author) FetchWithFilter(filter map[string]interface{}, page, limit int) ([]types.AuthorProfile, error) {\n\tvar profiles []types.AuthorProfile\n\tdb := base.GetInstance().GormDB().Table(\"trending_topics\")\n\n\tif activationDate, ok := filter[\"ActivationDate\"]; ok {\n\t\tdb = db.Where(\"activation_date > ?\", activationDate)\n\t\tdelete(filter, \"ActivationDate\")\n\t}\n\n\tif subCategory, ok := filter[\"SubCategory\"]; ok {\n\t\tdb = db.Where(\"sub_category LIKE ?\", \"%\"+subCategory.(string)+\"%\")\n\t\tdelete(filter, \"SubCategory\")\n\t} else {\n\t\tdb = db.Where(filter)\n\t}\n\n\terr := db.Scopes(PaginateDB(page, limit)).Order(\"created_at DESC\").Find(&profiles).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.RecordNotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn profiles, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleTrendingAuthors",
        "code_value": "func HandleTrendingAuthors(req *types.TrendingAuthorsRequest, log *logger.AppLog) ([]types.AuthorProfile, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.MinFollowers > 0 {\n\t\tfilter[\"follower_count\"] = fmt.Sprintf(\">%d\", req.MinFollowers)\n\t} else if len(req.Category) > 0 {\n\t\tif err := validateCategory(req.Category); err != nil {\n\t\t\tlog.Error(\"Invalid category\", \"error\", err)\n\t\t\treturn nil, err\n\t\t}\n\t\tfilter[\"SubCategory\"] = req.Category\n\t} else if !req.LastActive.IsZero() {\n\t\tfilter[\"ActivationDate\"] = req.LastActive\n\t} else {\n\t\tfilter[\"is_verified\"] = true\n\t}\n\n\tauthor := &Author{}\n\tprofiles, err := author.FetchWithFilter(filter, req.Page, req.PageSize)\n\tif err != nil {\n\t\tlog.Error(\"Failed to fetch authors\", \"error\", err)\n\t\treturn nil, err\n\t}\n\n\tif len(profiles) == 0 {\n\t\tlog.Warn(\"No matching authors found\", \"filter\", filter)\n\t}\n\treturn profiles, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "AuthorProfile",
        "code_value": "type AuthorProfile struct {\n\tID             int       `json:\"id\" gorm:\"column:id\"`\n\tName           string    `json:\"name\" gorm:\"column:name\"`\n\tActivationDate time.Time `json:\"activation_date\" gorm:\"column:activation_date\"`\n\tSubCategory    string    `json:\"sub_category\" gorm:\"column:sub_category\"`\n\tCreatedAt      time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt      time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "FilterConstants",
        "code_value": "const (\n\tDefaultPageSize = 20\n\tMaxPageSize     = 100\n)"
      },
      {
        "code_key": "TableNames",
        "code_value": "var TableNames = struct {\n\tTrendingTopics string\n}{\n\tTrendingTopics: \"trending_topics\",\n}"
      },
      {
        "code_key": "QueryResult",
        "code_value": "type QueryResult struct {\n\tTotal   int              `json:\"total\"`\n\tPage    int              `json:\"page\"`\n\tLimit   int              `json:\"limit\"`\n\tResults []AuthorProfile `json:\"results\"`\n}"
      },
      {
        "code_key": "ErrorMessages",
        "code_value": "var ErrorMessages = struct {\n\tRecordNotFound string\n}{\n\tRecordNotFound: \"record not found\",\n}"
      }
    ]
  },
  "synthetic_if-else_caller_GroupByCategory": {
    "scenario": "if-else+caller",
    "code_key": "GroupByCategory",
    "code_value": "func (m *Marketplace) GroupByCategory(filterParams map[string]interface{}, limit int) ([]types.BudgetPlan, error) {\n\tvar plans []types.BudgetPlan\n\tdb := base.GetInstance().MarketplaceDriver().Table(\"budget_planning\")\n\n\tif territory, ok := filterParams[\"Territory\"]; ok {\n\t\tdb = db.Where(\"Territory = ?\", territory).Order(\"created_at DESC\")\n\t} else if refCode, ok := filterParams[\"ReferenceCode\"]; ok {\n\t\tdb = db.Where(\"reference_code LIKE ?\", \"%\"+refCode.(string)+\"%\").Order(\"amount ASC\")\n\t}\n\n\terr := db.Limit(limit).Find(&plans).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn plans, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleProductCatalog",
        "code_value": "func (p *ProductManager) HandleProductCatalog(req *types.ProductCatalogRequest) ([]types.BudgetPlan, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.CategoryID > 0 {\n\t\tfilter[\"Territory\"] = req.CategoryID\n\t} else if len(req.ProductCode) > 0 {\n\t\tif len(req.ProductCode) < 4 {\n\t\t\treturn nil, fmt.Errorf(\"product code must be at least 4 characters\")\n\t\t}\n\t\tfilter[\"ReferenceCode\"] = req.ProductCode\n\t} else if req.PriceRange != nil {\n\t\tif req.PriceRange.Min >= req.PriceRange.Max {\n\t\t\treturn nil, fmt.Errorf(\"invalid price range\")\n\t\t}\n\t\tfilter[\"Status\"] = \"active\"\n\t}\n\n\tmarketplace := &Marketplace{}\n\treturn marketplace.GroupByCategory(filter, req.PageSize)\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "BudgetPlan",
        "code_value": "type BudgetPlan struct {\n\tID            int       `gorm:\"column:id;primaryKey\"`\n\tTerritory     string    `gorm:\"column:territory\"`\n\tReferenceCode string    `gorm:\"column:reference_code\"`\n\tAmount        float64   `gorm:\"column:amount\"`\n\tCreatedAt     time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "FilterParams",
        "code_value": "type FilterParams struct {\n\tTerritory     string\n\tReferenceCode string\n}"
      },
      {
        "code_key": "BudgetTable",
        "code_value": "const BudgetTable = \"budget_planning\""
      },
      {
        "code_key": "DefaultLimit",
        "code_value": "const DefaultLimit = 100"
      }
    ]
  },
  "synthetic_if-else_caller_MonitorHealth": {
    "scenario": "if-else+caller",
    "code_key": "MonitorHealth",
    "code_value": "func (c *Coupon) MonitorHealth(filterParams map[string]interface{}) ([]types.DoctorProfile, error) {\n\tvar profiles []types.DoctorProfile\n\tdb := base.GetInstance().HealthDriver().Table(\"doctor_profiles\")\n\n\tif status, exists := filterParams[\"Status\"]; exists {\n\t\tif lastAccess, hasAccess := filterParams[\"LastAccessTime\"]; hasAccess {\n\t\t\tdb = db.Where(\"status = ? AND last_access_time > ?\", status, lastAccess)\n\t\t} else {\n\t\t\tdb = db.Where(\"status = ?\", status)\n\t\t}\n\t} else if category, hasCategory := filterParams[\"SubCategory\"]; hasCategory {\n\t\tdb = db.Where(\"sub_category LIKE ?\", \"%\"+category.(string)+\"%\")\n\t} else {\n\t\treturn nil, errors.New(\"invalid filter parameters\")\n\t}\n\n\tif err := db.Find(&profiles).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn profiles, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleDoctorProfileSearch",
        "code_value": "func (s *SearchService) HandleDoctorProfileSearch(searchReq *types.DoctorSearchRequest, logger *log.Logger) ([]types.DoctorProfile, error) {\n\tfilterCriteria := make(map[string]interface{})\n\t\n\tif searchReq.Status != \"\" {\n\t\tfilterCriteria[\"Status\"] = searchReq.Status\n\t\tif searchReq.LastActiveDate != \"\" {\n\t\t\tt, err := time.Parse(time.RFC3339, searchReq.LastActiveDate)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Printf(\"Invalid date format: %v\", err)\n\t\t\t\treturn nil, fmt.Errorf(\"invalid date format\")\n\t\t\t}\n\t\t\tfilterCriteria[\"LastAccessTime\"] = t\n\t\t}\n\t} else if searchReq.Specialization != \"\" {\n\t\tfilterCriteria[\"SubCategory\"] = searchReq.Specialization\n\t} else if searchReq.MinRating > 0 {\n\t\tfilterCriteria[\"Rating\"] = searchReq.MinRating\n\t} else {\n\t\treturn nil, fmt.Errorf(\"at least one search criteria must be provided\")\n\t}\n\n\tcouponSvc := &Coupon{}\n\tresults, err := couponSvc.MonitorHealth(filterCriteria)\n\tif err != nil {\n\t\tlogger.Printf(\"Health monitoring failed: %v\", err)\n\t\treturn nil, fmt.Errorf(\"search failed\")\n\t}\n\n\treturn results, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "DoctorProfile",
        "code_value": "type DoctorProfile struct {\n\tID              int       `json:\"id\" gorm:\"column:id\"`\n\tName            string    `json:\"name\" gorm:\"column:name\"`\n\tSpecialization  string    `json:\"specialization\" gorm:\"column:specialization\"`\n\tStatus          string    `json:\"status\" gorm:\"column:status\"`\n\tLastAccessTime  time.Time `json:\"last_access_time\" gorm:\"column:last_access_time\"`\n\tSubCategory     string    `json:\"sub_category\" gorm:\"column:sub_category\"`\n\tCreatedAt       time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt       time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "HealthStatus",
        "code_value": "const (\n\tActiveStatus   = \"active\"\n\tInactiveStatus = \"inactive\"\n\tPendingStatus  = \"pending\"\n)"
      },
      {
        "code_key": "DoctorFilter",
        "code_value": "type DoctorFilter struct {\n\tStatus         *string\n\tLastAccessTime *time.Time\n\tSubCategory    *string\n}"
      },
      {
        "code_key": "TableNameDoctor",
        "code_value": "const TableNameDoctor = \"doctor_profiles\""
      }
    ]
  },
  "synthetic_if-else_caller_ApproveRequest": {
    "scenario": "if-else+caller",
    "code_key": "ApproveRequest",
    "code_value": "func (v *Video) ApproveRequest(filters map[string]interface{}) ([]types.VideoApproval, error) {\n\tvar approvals []types.VideoApproval\n\tdb := base.GetInstance().GormDriver().Table(\"dispatch_orders\")\n\n\tif edition, ok := filters[\"Edition\"]; ok {\n\t\tif region, ok := filters[\"Region\"]; ok {\n\t\t\tdb = db.Where(\"edition = ? AND region = ?\", edition, region)\n\t\t} else {\n\t\t\tdb = db.Where(\"edition LIKE ?\", \"%\"+edition.(string)+\"%\")\n\t\t}\n\t} else if code, ok := filters[\"LocationCode\"]; ok {\n\t\tdb = db.Where(\"location_code = ?\", code)\n\t}\n\n\tif err := db.Find(&approvals).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn approvals, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleDriverApprovals",
        "code_value": "func (h *DriverHandler) HandleDriverApprovals(req *types.DriverApprovalRequest) ([]types.VideoApproval, error) {\n\tfilters := make(map[string]interface{})\n\n\tif req.DriverID != \"\" {\n\t\tfilters[\"LocationCode\"] = req.DriverID\n\t} else if req.Edition != \"\" {\n\t\tfilters[\"Edition\"] = req.Edition\n\t\tif req.Region != \"\" {\n\t\t\tfilters[\"Region\"] = req.Region\n\t\t}\n\t} else if req.Status != \"\" {\n\t\tif !utils.IsValidStatus(req.Status) {\n\t\t\treturn nil, fmt.Errorf(\"invalid status: %s\", req.Status)\n\t\t}\n\t\tfilters[\"Status\"] = req.Status\n\t}\n\n\tdriver := &Video{}\n\tapprovals, err := driver.ApproveRequest(filters)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get driver approvals: %v\", err)\n\t}\n\n\tif len(approvals) == 0 && req.RequireNonEmpty {\n\t\treturn nil, fmt.Errorf(\"no approvals found but require non-empty result\")\n\t}\n\n\treturn approvals, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "VideoApproval",
        "code_value": "type VideoApproval struct {\n\tID           int       `json:\"id\" gorm:\"column:id\"`\n\tEdition      string    `json:\"edition\" gorm:\"column:edition\"`\n\tRegion       string    `json:\"region\" gorm:\"column:region\"`\n\tLocationCode string    `json:\"location_code\" gorm:\"column:location_code\"`\n\tStatus       int       `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt    time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt    time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "ApprovalStatus",
        "code_value": "const (\n\tPending  ApprovalStatus = iota\n\tApproved\n\tRejected\n)"
      },
      {
        "code_key": "VideoFilter",
        "code_value": "type VideoFilter struct {\n\tEdition      string\n\tRegion       string\n\tLocationCode string\n}"
      },
      {
        "code_key": "DispatchOrderTable",
        "code_value": "const DispatchOrderTable = \"dispatch_orders\""
      },
      {
        "code_key": "DefaultRegion",
        "code_value": "var DefaultRegion = \"US\""
      }
    ]
  },
  "synthetic_if-else_caller_SortByField": {
    "scenario": "if-else+caller",
    "code_key": "SortByField",
    "code_value": "func (p *Project) SortByField(filterParams map[string]interface{}, orderField string) ([]types.SocialPost, error) {\n\tvar posts []types.SocialPost\n\tdb := base.GetInstance().MainDB().Table(\"social_posts\")\n\n\tif summary, exists := filterParams[\"Summary\"]; exists {\n\t\tdb = db.Where(\"summary LIKE ?\", \"%\"+summary.(string)+\"%\")\n\t\tif creationTime, hasTime := filterParams[\"CreationTime\"]; hasTime {\n\t\t\tdb = db.Where(\"created_at > ?\", creationTime)\n\t\t}\n\t} else {\n\t\tdb = db.Where(filterParams)\n\t}\n\n\terr := db.Order(orderField).Find(&posts).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn posts, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleVideoCollection",
        "code_value": "func (v *VideoHandler) HandleVideoCollection(req *types.VideoCollectionRequest, log *logger.AppLog) ([]types.SocialPost, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.CategoryID > 0 {\n\t\tfilter[\"category_id\"] = req.CategoryID\n\t\tif req.IsPremium {\n\t\t\tfilter[\"is_premium\"] = true\n\t\t}\n\t} else if len(req.AuthorName) > 0 {\n\t\tif err := validateAuthorName(req.AuthorName); err != nil {\n\t\t\tlog.Error(\"Invalid author name\", err)\n\t\t\treturn nil, err\n\t\t}\n\t\tfilter[\"author\"] = req.AuthorName\n\t} else if req.MinDuration > 0 {\n\t\tfilter[\"duration\"] = gorm.Expr(\"duration >= ?\", req.MinDuration)\n\t} else {\n\t\tfilter[\"is_featured\"] = true\n\t}\n\n\tvideoProject := &Project{}\n\tresults, err := videoProject.SortByField(filter, req.SortBy)\n\tif err != nil {\n\t\tlog.Error(\"Failed to fetch videos\", err)\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}\n\nfunc validateAuthorName(name string) error {\n\tif len(name) < 2 || len(name) > 50 {\n\t\treturn errors.New(\"author name must be 2-50 characters\")\n\t}\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "SocialPost",
        "code_value": "type SocialPost struct {\n\tID          uint      json:\"id\" gorm:\"primaryKey\"\n\tSummary     string    json:\"summary\" gorm:\"column:summary\"\n\tContent     string    json:\"content\" gorm:\"column:content\"\n\tCreatedAt   time.Time json:\"created_at\" gorm:\"column:created_at\"\n\tUpdatedAt   time.Time json:\"updated_at\" gorm:\"column:updated_at\"\n\tAuthorID    uint      json:\"author_id\" gorm:\"column:author_id\"\n\tLikeCount   int       json:\"like_count\" gorm:\"column:like_count\"\n\tCommentCount int      json:\"comment_count\" gorm:\"column:comment_count\"\n}"
      },
      {
        "code_key": "PostFilter",
        "code_value": "type PostFilter struct {\n\tSummary      *string\n\tCreationTime *time.Time\n\tAuthorID     *uint\n\tMinLikes     *int\n}"
      },
      {
        "code_key": "SortDirection",
        "code_value": "type SortDirection string\n\nconst (\n\tSortAsc  SortDirection = \"ASC\"\n\tSortDesc SortDirection = \"DESC\"\n)"
      },
      {
        "code_key": "TableSocialPosts",
        "code_value": "const TableSocialPosts = \"social_posts\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "MaxPostSummaryLength",
        "code_value": "const MaxPostSummaryLength = 140"
      },
      {
        "code_key": "PostCache",
        "code_value": "var PostCache = make(map[uint]types.SocialPost)"
      },
      {
        "code_key": "PopularPostThreshold",
        "code_value": "const PopularPostThreshold = 1000"
      }
    ]
  },
  "synthetic_if-else_caller_CalculateByFormula": {
    "scenario": "if-else+caller",
    "code_key": "CalculateByFormula",
    "code_value": "func (m *Media) CalculateByFormula(filterParams map[string]interface{}, page, limit int) ([]types.MediaContent, error) {\n\tcontents := make([]types.MediaContent, 0)\n\tdb := base.GetInstance().MediaDriver().Table(\"content_archive\")\n\n\tif category, ok := filterParams[\"CategoryType\"]; ok {\n\t\tif title, exists := filterParams[\"Title\"]; exists {\n\t\t\tdb = db.Where(\"category_type = ? AND title LIKE ?\", category, \"%\"+title.(string)+\"%\")\n\t\t} else {\n\t\t\tdb = db.Where(\"category_type = ?\", category)\n\t\t}\n\t} else if expiration, ok := filterParams[\"ExpirationTime\"]; ok {\n\t\tdb = db.Where(\"expiration_time > ?\", expiration)\n\t}\n\n\terr := db.Scopes(PaginateDB(page, limit)).Order(\"created_at DESC\").Find(&contents).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn contents, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn contents, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleMediaContent",
        "code_value": "func (h *MediaHandler) HandleMediaContent(req *types.MediaContentRequest, log *logger.AppLog) ([]types.MediaContent, error) {\n\tfilter := make(map[string]interface{})\n\tif req.ContentID != \"\" {\n\t\tfilter[\"ContentID\"] = req.ContentID\n\t} else if req.Author != \"\" {\n\t\tif len(req.Author) > 50 {\n\t\t\tlog.Error(\"Author name too long\")\n\t\t\treturn nil, errors.New(\"invalid author name\")\n\t\t}\n\t\tfilter[\"Author\"] = req.Author\n\t} else if req.Status != 0 {\n\t\tif req.Status < 1 || req.Status > 3 {\n\t\t\tlog.Error(\"Invalid status value\")\n\t\t\treturn nil, errors.New(\"invalid status\")\n\t\t}\n\t\tfilter[\"Status\"] = req.Status\n\t} else {\n\t\tfilter[\"IsFeatured\"] = true\n\t}\n\n\tmedia := &Media{}\n\tpage, size := utils.NormalizePagination(req.Page, req.PageSize)\n\tcontents, err := media.CalculateByFormula(filter, page, size)\n\tif err != nil {\n\t\tlog.Error(\"Failed to query media content\", err)\n\t\treturn nil, err\n\t}\n\treturn contents, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "MediaContent",
        "code_value": "type MediaContent struct {\n\tID            uint      `gorm:\"column:id;primaryKey\"`\n\tTitle         string    `gorm:\"column:title\"`\n\tCategoryType  string    `gorm:\"column:category_type\"`\n\tExpirationTime time.Time `gorm:\"column:expiration_time\"`\n\tCreatedAt     time.Time `gorm:\"column:created_at\"`\n\tContentData   []byte    `gorm:\"column:content_data;type:jsonb\"`\n}"
      },
      {
        "code_key": "ContentArchiveTable",
        "code_value": "const ContentArchiveTable = \"content_archive\""
      },
      {
        "code_key": "FilterParams",
        "code_value": "type FilterParams struct {\n\tCategoryType   string \n\tTitle          string \n\tExpirationTime time.Time\n}"
      },
      {
        "code_key": "PaginationConfig",
        "code_value": "var PaginationConfig = struct {\n\tDefaultPage  int\n\tDefaultLimit int\n}{\n\tDefaultPage:  1,\n\tDefaultLimit: 20,\n}"
      },
      {
        "code_key": "MediaResponse",
        "code_value": "type MediaResponse struct {\n\tContents     []MediaContent\n\tCurrentPage  int\n\tTotalPages   int\n\tTotalRecords int64\n}"
      }
    ]
  },
  "synthetic_if-else_caller_CountByStatus": {
    "scenario": "if-else+caller",
    "code_key": "CountByStatus",
    "code_value": "func (m *Medicine) CountByStatus(filter map[string]interface{}) (int64, error) {\n\tvar count int64\n\tdb := base.GetInstance().GormDB().Table(\"project_assignments\")\n\n\tif status, ok := filter[\"Status\"]; ok {\n\t\tif trackingId, ok := filter[\"TrackingId\"]; ok {\n\t\t\tdb = db.Where(\"status = ? AND tracking_id = ?\", status, trackingId)\n\t\t} else {\n\t\t\tdb = db.Where(\"status = ?\", status)\n\t\t}\n\t} else if apiKey, ok := filter[\"ApiKey\"]; ok {\n\t\tdb = db.Where(\"api_key LIKE ?\", \"%\"+apiKey.(string)+\"%\")\n\t} else {\n\t\tdb = db.Where(filter)\n\t}\n\n\terr := db.Count(&count).Error\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn count, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleMedicineCount",
        "code_value": "func (s *MedicineService) HandleMedicineCount(req *types.MedicineCountRequest) (int64, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.Status != \"\" {\n\t\tfilter[\"Status\"] = req.Status\n\t\tif req.TrackingID != \"\" {\n\t\t\tfilter[\"TrackingId\"] = req.TrackingID\n\t\t}\n\t} else if req.APIKey != \"\" {\n\t\tif len(req.APIKey) < 5 {\n\t\t\treturn 0, errors.New(\"API key too short\")\n\t\t}\n\t\tfilter[\"ApiKey\"] = req.APIKey\n\t} else if req.Category != \"\" {\n\t\tfilter[\"category\"] = req.Category\n\t} else {\n\t\treturn 0, errors.New(\"at least one filter parameter required\")\n\t}\n\n\tmed := &Medicine{}\n\tcount, err := med.CountByStatus(filter)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to count medicines: %v\", err)\n\t}\n\t\n\treturn count, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "ProjectAssignment",
        "code_value": "type ProjectAssignment struct {\n\tID        uint      `gorm:\"primaryKey\"`\n\tStatus    string    `gorm:\"column:status\"`\n\tTrackingID string   `gorm:\"column:tracking_id\"`\n\tApiKey    string    `gorm:\"column:api_key\"`\n\tCreatedAt time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "AssignmentStatus",
        "code_value": "const (\n\tAssignmentPending = \"pending\"\n\tAssignmentActive = \"active\"\n\tAssignmentCompleted = \"completed\"\n)"
      },
      {
        "code_key": "TableProjectAssignments",
        "code_value": "const TableProjectAssignments = \"project_assignments\""
      },
      {
        "code_key": "AssignmentFilter",
        "code_value": "type AssignmentFilter struct {\n\tStatus    string\n\tTrackingID string\n\tApiKey    string\n}"
      }
    ]
  },
  "synthetic_if-else_caller_CalculateDiscount": {
    "scenario": "if-else+caller",
    "code_key": "CalculateDiscount",
    "code_value": "func (p *Prescription) CalculateDiscount(filterParams map[string]interface{}) ([]types.MedicineDiscount, error) {\n\tvar discounts []types.MedicineDiscount\n\tdb := base.GetInstance().PharmacyDB().Table(\"prescription_discounts\")\n\n\tif medicineType, ok := filterParams[\"MedicineType\"]; ok {\n\t\t// Exact match for MedicineType combined with date range\n\t\tstartDate := filterParams[\"StartDate\"].(string)\n\t\tendDate := filterParams[\"EndDate\"].(string)\n\t\treturn discounts, db.Where(\"medicine_type = ? AND valid_from <= ? AND valid_to >= ?\", \n\t\t\tmedicineType, startDate, endDate).Find(&discounts).Error\n\t} else {\n\t\t// Range query based on discount percentage\n\t\tminDiscount := filterParams[\"MinDiscount\"].(float64)\n\t\tmaxDiscount := filterParams[\"MaxDiscount\"].(float64)\n\t\treturn discounts, db.Where(\"discount_percentage BETWEEN ? AND ?\", \n\t\t\tminDiscount, maxDiscount).Order(\"medicine_name\").Find(&discounts).Error\n\t}\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleMedicineDiscount",
        "code_value": "func (s *DiscountService) HandleMedicineDiscount(req *types.DiscountRequest) ([]types.MedicineDiscount, error) {\n\tfilterParams := make(map[string]interface{})\n\t\n\tif req.MedicineType != \"\" {\n\t\tif req.StartDate == \"\" || req.EndDate == \"\" {\n\t\t\treturn nil, errors.New(\"date range required for medicine type query\")\n\t\t}\n\t\tfilterParams[\"MedicineType\"] = req.MedicineType\n\t\tfilterParams[\"StartDate\"] = req.StartDate\n\t\tfilterParams[\"EndDate\"] = req.EndDate\n\t} else if req.MinDiscount > 0 || req.MaxDiscount > 0 {\n\t\tif req.MinDiscount < 0 || req.MaxDiscount > 100 {\n\t\t\treturn nil, errors.New(\"invalid discount range\")\n\t\t}\n\t\tfilterParams[\"MinDiscount\"] = req.MinDiscount\n\t\tfilterParams[\"MaxDiscount\"] = req.MaxDiscount\n\t} else if req.MedicineName != \"\" {\n\t\tfilterParams[\"MedicineType\"] = req.MedicineName\n\t\tfilterParams[\"StartDate\"] = \"1970-01-01\"\n\t\tfilterParams[\"EndDate\"] = \"2100-01-01\"\n\t} else {\n\t\treturn nil, errors.New(\"no valid filter parameters provided\")\n\t}\n\t\n\tprescription := &Prescription{}\n\treturn prescription.CalculateDiscount(filterParams)\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "MedicineDiscount",
        "code_value": "type MedicineDiscount struct {\n\tID                int     `json:\"id\" gorm:\"column:id\"`\n\tMedicineType      string  `json:\"medicine_type\" gorm:\"column:medicine_type\"`\n\tMedicineName      string  `json:\"medicine_name\" gorm:\"column:medicine_name\"`\n\tDiscountPercentage float64 `json:\"discount_percentage\" gorm:\"column:discount_percentage\"`\n\tValidFrom         string  `json:\"valid_from\" gorm:\"column:valid_from\"`\n\tValidTo           string  `json:\"valid_to\" gorm:\"column:valid_to\"`\n\tCreatedAt         int64   `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt         int64   `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "Prescription",
        "code_value": "type Prescription struct {\n\tID         int       `json:\"id\" gorm:\"column:id\"`\n\tPatientID  string    `json:\"patient_id\" gorm:\"column:patient_id\"`\n\tDoctorID   string    `json:\"doctor_id\" gorm:\"column:doctor_id\"`\n\tIssueDate  time.Time `json:\"issue_date\" gorm:\"column:issue_date\"`\n\tExpiryDate time.Time `json:\"expiry_date\" gorm:\"column:expiry_date\"`\n\tStatus     string    `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt  time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt  time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "TableNamePrescriptionDiscounts",
        "code_value": "const TableNamePrescriptionDiscounts = \"prescription_discounts\""
      },
      {
        "code_key": "DiscountStatus",
        "code_value": "const (\n\tDiscountStatusActive   = \"ACTIVE\"\n\tDiscountStatusExpired  = \"EXPIRED\"\n\tDiscountStatusPending  = \"PENDING\"\n\tDiscountStatusArchived = \"ARCHIVED\"\n)"
      },
      {
        "code_key": "PharmacyDBInstance",
        "code_value": "var PharmacyDBInstance *gorm.DB"
      }
    ]
  },
  "synthetic_if-else_caller_GetByStatus": {
    "scenario": "if-else+caller",
    "code_key": "GetByStatus",
    "code_value": "func (i *Image) GetByStatus(filterParams map[string]interface{}, page, size int) ([]types.ImageRecord, error) {\n\tvar results []types.ImageRecord\n\tdb := base.GetInstance().MainDB().Table(\"progress_tracking\")\n\n\tif dimension, ok := filterParams[\"Dimension\"]; ok {\n\t\t// Range query for dimension\n\t\tdb = db.Where(\"dimension BETWEEN ? AND ?\", dimension.(float64)-0.5, dimension.(float64)+0.5)\n\t\tdelete(filterParams, \"Dimension\")\n\t}\n\n\tif len(filterParams) > 0 {\n\t\tdb = db.Where(filterParams)\n\t}\n\n\terr := db.Scopes(PaginateDB(page, size)).Order(\"created_at DESC\").Find(&results).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.RecordNotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleImageSearch",
        "code_value": "func (h *ImageHandler) HandleImageSearch(req *types.ImageSearchRequest, log *logger.AppLog) ([]types.ImageRecord, error) {\n\tfilterParams := make(map[string]interface{})\n\n\tif req.Status != \"\" {\n\t\tif !utils.IsValidStatus(req.Status) {\n\t\t\tlog.Error(\"Invalid status parameter\")\n\t\t\treturn nil, utils.InvalidParamError\n\t\t}\n\t\tfilterParams[\"status\"] = req.Status\n\t} else if req.UserID > 0 {\n\t\tfilterParams[\"user_id\"] = req.UserID\n\t} else if req.Category != \"\" {\n\t\tif len(req.Category) > 50 {\n\t\t\tlog.Error(\"Category name too long\")\n\t\t\treturn nil, utils.InvalidParamError\n\t\t}\n\t\tfilterParams[\"category\"] = req.Category\n\t} else {\n\t\treturn nil, utils.MissingParamError\n\t}\n\n\tif req.Dimension > 0 {\n\t\tfilterParams[\"Dimension\"] = req.Dimension\n\t}\n\n\timg := &Image{}\n\tpage, size := utils.GetPagination(req.Page, req.Size)\n\tresults, err := img.GetByStatus(filterParams, page, size)\n\tif err != nil {\n\t\tlog.Errorf(\"Failed to get images: %v\", err)\n\t\treturn nil, err\n\t}\n\n\treturn results, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "ImageRecord",
        "code_value": "type ImageRecord struct {\n\tID          uint      json:\"id\" gorm:\"column:id;primaryKey\"\n\tDimension   float64   json:\"dimension\" gorm:\"column:dimension\"\n\tStatus      string    json:\"status\" gorm:\"column:status\"\n\tCreatedAt   time.Time json:\"created_at\" gorm:\"column:created_at\"\n\tUpdatedAt   time.Time json:\"updated_at\" gorm:\"column:updated_at\"\n}"
      },
      {
        "code_key": "FilterParams",
        "code_value": "type FilterParams struct {\n\tDimension *float64 \n\tStatus    string   \n\tAppID     int      \n}"
      },
      {
        "code_key": "TableProgressTracking",
        "code_value": "const TableProgressTracking = \"progress_tracking\""
      },
      {
        "code_key": "ImageStatus",
        "code_value": "const (\n\tImageStatusPending   = \"PENDING\"\n\tImageStatusApproved = \"APPROVED\"\n\tImageStatusRejected = \"REJECTED\"\n)"
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      }
    ]
  },
  "synthetic_if-else_caller_ProcessPayment": {
    "scenario": "if-else+caller",
    "code_key": "ProcessPayment",
    "code_value": "func (i *Insurance) ProcessPayment(filterParams map[string]interface{}) ([]types.InsurancePolicy, error) {\n\tvar policies []types.InsurancePolicy\n\tquery := base.GetInstance().DB().Table(\"insurance_policies\")\n\n\tif policyNum, ok := filterParams[\"policy_number\"]; ok {\n\t\t// Exact match for policy number\n\t\tquery = query.Where(\"policy_number = ?\", policyNum)\n\t} else if clientID, ok := filterParams[\"client_id\"]; ok {\n\t\t// Range query for payment date when clientID is provided\n\t\tif startDate, dateOk := filterParams[\"start_date\"]; dateOk {\n\t\t\tquery = query.Where(\"client_id = ? AND payment_date >= ?\", clientID, startDate)\n\t\t} else {\n\t\t\tquery = query.Where(\"client_id = ?\", clientID)\n\t\t}\n\t} else {\n\t\t// Default query for unpaid policies\n\t\tquery = query.Where(\"payment_status = ?\", \"unpaid\")\n\t}\n\n\tif err := query.Find(&policies).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn policies, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleEmployeeBonus",
        "code_value": "func (s *BonusService) HandleEmployeeBonus(req *types.BonusRequest) ([]types.BonusRecord, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.EmployeeID != \"\" {\n\t\tfilter[\"employee_id\"] = req.EmployeeID\n\t} else if req.Department != \"\" {\n\t\tif req.Quarter > 0 {\n\t\t\tfilter[\"department\"] = req.Department\n\t\t\tfilter[\"quarter\"] = req.Quarter\n\t\t} else {\n\t\t\tfilter[\"department\"] = req.Department\n\t\t}\n\t} else if req.Status != \"\" {\n\t\tif !utils.IsValidBonusStatus(req.Status) {\n\t\t\treturn nil, fmt.Errorf(\"invalid bonus status: %s\", req.Status)\n\t\t}\n\t\tfilter[\"status\"] = req.Status\n\t} else {\n\t\tfilter[\"year\"] = time.Now().Year()\n\t}\n\n\tbonus := &models.Bonus{}\n\trecords, err := bonus.ProcessPayment(filter)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to process bonus: %v\", err)\n\t}\n\treturn records, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "InsurancePolicy",
        "code_value": "type InsurancePolicy struct {\n\tID            uint      `gorm:\"column:id;primaryKey\"`\n\tPolicyNumber  string    `gorm:\"column:policy_number;uniqueIndex\"`\n\tClientID      uint      `gorm:\"column:client_id;index\"`\n\tPaymentDate   time.Time `gorm:\"column:payment_date\"`\n\tPaymentStatus string    `gorm:\"column:payment_status;default:'unpaid'\"`\n\tPremiumAmount float64   `gorm:\"column:premium_amount\"`\n\tCreatedAt     time.Time `gorm:\"column:created_at;autoCreateTime\"`\n\tUpdatedAt     time.Time `gorm:\"column:updated_at;autoUpdateTime\"`\n}"
      },
      {
        "code_key": "PaymentStatus",
        "code_value": "const (\n\tPaymentStatusUnpaid  = \"unpaid\"\n\tPaymentStatusPending = \"pending\"\n\tPaymentStatusPaid    = \"paid\"\n)"
      },
      {
        "code_key": "InsuranceFilterParams",
        "code_value": "type InsuranceFilterParams struct {\n\tPolicyNumber *string    `json:\"policy_number\"`\n\tClientID     *uint      `json:\"client_id\"`\n\tStartDate    *time.Time `json:\"start_date\"`\n}"
      },
      {
        "code_key": "Client",
        "code_value": "type Client struct {\n\tID        uint      `gorm:\"column:id;primaryKey\"`\n\tName      string    `gorm:\"column:name\"`\n\tEmail     string    `gorm:\"column:email;uniqueIndex\"`\n\tCreatedAt time.Time `gorm:\"column:created_at;autoCreateTime\"`\n\tUpdatedAt time.Time `gorm:\"column:updated_at;autoUpdateTime\"`\n}"
      },
      {
        "code_key": "TableNameInsurancePolicies",
        "code_value": "const TableNameInsurancePolicies = \"insurance_policies\""
      }
    ]
  },
  "synthetic_if-else_caller_ScheduleDelivery": {
    "scenario": "if-else+caller",
    "code_key": "ScheduleDelivery",
    "code_value": "func (t *Textbook) ScheduleDelivery(filterParams map[string]interface{}) ([]types.Chapter, error) {\n\tvar chapters []types.Chapter\n\tdb := base.GetInstance().GormDriver().Table(\"subscription_tiers\")\n\n\tif language, ok := filterParams[\"Language\"]; ok {\n\t\tif region, ok := filterParams[\"RegionCode\"]; ok {\n\t\t\tdb = db.Where(\"language = ? AND region_code = ?\", language.(string), region.(string))\n\t\t} else {\n\t\t\tdb = db.Where(\"language like ?\", \"%\"+language.(string)+\"%\")\n\t\t}\n\t} else if street, ok := filterParams[\"Street\"]; ok {\n\t\tdb = db.Where(\"delivery_address like ?\", \"%\"+street.(string)+\"%\")\n\t}\n\n\tif err := db.Order(\"created_at desc\").Find(&chapters).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn chapters, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleCourseDelivery",
        "code_value": "func (m *MaterialHandler) HandleCourseDelivery(req *types.CourseDeliveryRequest) ([]types.Chapter, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.CourseID != \"\" {\n\t\tfilter[\"Language\"] = req.Language\n\t\tfilter[\"RegionCode\"] = req.Region\n\t} else if req.Address != \"\" {\n\t\tfilter[\"Street\"] = req.Address\n\t} else if req.Status != 0 {\n\t\tif req.Status == types.ExpressDelivery {\n\t\t\tfilter[\"Language\"] = \"en\"\n\t\t} else {\n\t\t\tfilter[\"Language\"] = req.Language\n\t\t}\n\t} else {\n\t\treturn nil, errors.New(\"invalid delivery parameters\")\n\t}\n\n\ttextbook := &Textbook{}\n\tchapters, err := textbook.ScheduleDelivery(filter)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to schedule delivery: %v\", err)\n\t}\n\t\n\tif len(chapters) == 0 {\n\t\treturn nil, errors.New(\"no chapters found\")\n\t}\n\t\n\treturn chapters, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Chapter",
        "code_value": "type Chapter struct {\n\tID          int       `json:\"id\" gorm:\"column:id\"`\n\tTitle       string    `json:\"title\" gorm:\"column:title\"`\n\tContent     string    `json:\"content\" gorm:\"column:content\"`\n\tLanguage    string    `json:\"language\" gorm:\"column:language\"`\n\tRegionCode  string    `json:\"region_code\" gorm:\"column:region_code\"`\n\tDeliveryAddress string `json:\"delivery_address\" gorm:\"column:delivery_address\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "Textbook",
        "code_value": "type Textbook struct {\n\tID        int       `json:\"id\" gorm:\"column:id\"`\n\tISBN      string    `json:\"isbn\" gorm:\"column:isbn\"`\n\tTitle     string    `json:\"title\" gorm:\"column:title\"`\n\tAuthor    string    `json:\"author\" gorm:\"column:author\"`\n\tPublished time.Time `json:\"published\" gorm:\"column:published\"`\n}"
      },
      {
        "code_key": "SubscriptionTier",
        "code_value": "type SubscriptionTier struct {\n\tID          int    `json:\"id\" gorm:\"column:id\"`\n\tName        string `json:\"name\" gorm:\"column:name\"`\n\tDescription string `json:\"description\" gorm:\"column:description\"`\n\tPriority    int    `json:\"priority\" gorm:\"column:priority\"`\n}"
      },
      {
        "code_key": "DeliveryStatus",
        "code_value": "const (\n\tPendingStatus   = \"pending\"\n\tShippedStatus   = \"shipped\"\n\tDeliveredStatus = \"delivered\"\n\tCancelledStatus = \"cancelled\"\n)"
      },
      {
        "code_key": "MaxDeliveryAttempts",
        "code_value": "const MaxDeliveryAttempts = 3"
      },
      {
        "code_key": "SupportedLanguages",
        "code_value": "var SupportedLanguages = []string{\"en\", \"es\", \"fr\", \"de\", \"ja\"}"
      }
    ]
  },
  "synthetic_if-else_caller_TrackBehavior": {
    "scenario": "if-else+caller",
    "code_key": "TrackBehavior",
    "code_value": "func (t *Tracking) TrackBehavior(filterParams map[string]interface{}, limit int) ([]types.BehaviorLog, error) {\n\tvar logs []types.BehaviorLog\n\tdb := base.GetInstance().GormClient().Table(\"tournament_brackets\")\n\t\n\tif score, exists := filterParams[\"Score\"]; exists {\n\t\tif score.(int) > 80 {\n\t\t\tdb = db.Where(\"Score > ? AND CurrentStatus = ?\", score, \"active\")\n\t\t} else {\n\t\t\tdb = db.Where(\"Score <= ?\", score)\n\t\t}\n\t} else if discountRate, exists := filterParams[\"DiscountRate\"]; exists {\n\t\tdb = db.Where(\"DiscountRate BETWEEN ? AND ?\", discountRate.(float64)-0.1, discountRate.(float64)+0.1)\n\t}\n\t\n\terr := db.Order(\"created_at DESC\").Limit(limit).Find(&logs).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn logs, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleProgressTracking",
        "code_value": "func (h *Handler) HandleProgressTracking(req *types.ProgressRequest) ([]types.BehaviorLog, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.UserID != \"\" {\n\t\tfilter[\"Score\"] = 85 // Will trigger the first branch in ORM\n\t} else if req.CampaignID > 0 {\n\t\tfilter[\"DiscountRate\"] = 0.5 // Will trigger the second branch in ORM\n\t} else if req.StartTime != \"\" && req.EndTime != \"\" {\n\t\tfilter[\"TimeRange\"] = true\n\t\thandleTimeRangeFilter(filter, req.StartTime, req.EndTime)\n\t} else {\n\t\treturn nil, errors.New(\"invalid filter parameters\")\n\t}\n\n\ttracker := &Tracking{}\n\tlogs, err := tracker.TrackBehavior(filter, req.Limit)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"track behavior failed: %v\", err)\n\t}\n\t\n\tif len(logs) == 0 {\n\t\treturn nil, errors.New(\"no matching records found\")\n\t}\n\treturn logs, nil\n}\n\nfunc handleTimeRangeFilter(filter map[string]interface{}, start, end string) {\n\tfilter[\"StartTime\"] = start\n\tfilter[\"EndTime\"] = end\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "BehaviorLog",
        "code_value": "type BehaviorLog struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tUserID        string    `json:\"user_id\" gorm:\"column:user_id\"`\n\tActionType    string    `json:\"action_type\" gorm:\"column:action_type\"`\n\tScore         int       `json:\"score\" gorm:\"column:score\"`\n\tDiscountRate  float64   `json:\"discount_rate\" gorm:\"column:discount_rate\"`\n\tCurrentStatus string    `json:\"current_status\" gorm:\"column:current_status\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "BehaviorFilter",
        "code_value": "type BehaviorFilter struct {\n\tScore        *int     `json:\"score\"`\n\tDiscountRate *float64 `json:\"discount_rate\"`\n\tLimit        int      `json:\"limit\"`\n}"
      },
      {
        "code_key": "BehaviorResponse",
        "code_value": "type BehaviorResponse struct {\n\tLogs  []BehaviorLog `json:\"logs\"`\n\tCount int           `json:\"count\"`\n\tError string        `json:\"error,omitempty\"`\n}"
      },
      {
        "code_key": "BehaviorStatus",
        "code_value": "const (\n\tBehaviorStatusActive  = \"active\"\n\tBehaviorStatusPending = \"pending\"\n\tBehaviorStatusExpired = \"expired\"\n)"
      },
      {
        "code_key": "DefaultBehaviorLimit",
        "code_value": "const DefaultBehaviorLimit = 100"
      },
      {
        "code_key": "BehaviorTableName",
        "code_value": "const BehaviorTableName = \"user_behaviors\""
      }
    ]
  },
  "synthetic_if-else_caller_LoadByType": {
    "scenario": "if-else+caller",
    "code_key": "LoadByType",
    "code_value": "func (c *Certificate) LoadByType(filterParams map[string]interface{}, page, size int) ([]types.CertificateRecord, error) {\n\tvar records []types.CertificateRecord\n\tdb := base.GetDB().Table(\"comment_moderation\")\n\t\n\tif certType, ok := filterParams[\"CertificateType\"]; ok {\n\t\tquery := make(map[string]interface{})\n\t\tfor k, v := range filterParams {\n\t\t\tif k != \"CertificateType\" {\n\t\t\t\tquery[k] = v\n\t\t\t}\n\t\t}\n\t\tdb = db.Where(query).Where(\"cert_type = ?\", certType)\n\t} else if nickName, ok := filterParams[\"NickName\"]; ok {\n\t\tdb = db.Where(\"nick_name LIKE ?\", \"%\"+nickName.(string)+\"%\")\n\t} else {\n\t\tdb = db.Where(filterParams)\n\t}\n\t\n\terr := db.Scopes(PaginateDB(page, size)).Order(\"created_at DESC\").Find(&records).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleSellerCertificates",
        "code_value": "func (s *SellerService) HandleSellerCertificates(req *types.SellerCertRequest, log *logger.BizLog) ([]types.CertificateRecord, error) {\n\tfilter := make(map[string]interface{})\n\tpage, size := utils.NormalizePagination(req.Page, req.Size)\n\t\n\tif req.SellerID != \"\" {\n\t\tfilter[\"seller_id\"] = req.SellerID\n\t} else if req.CompanyName != \"\" {\n\t\tif len(req.CompanyName) > 100 {\n\t\t\tlog.Error(\"CompanyName too long\")\n\t\t\treturn nil, errors.New(\"invalid company name\")\n\t\t}\n\t\tfilter[\"company_name\"] = req.CompanyName\n\t} else if req.CertStatus != 0 {\n\t\tif req.CertStatus < 1 || req.CertStatus > 5 {\n\t\t\tlog.Error(\"Invalid cert status\")\n\t\t\treturn nil, errors.New(\"invalid certificate status\")\n\t\t}\n\t\tfilter[\"status\"] = req.CertStatus\n\t} else {\n\t\tfilter[\"is_active\"] = true\n\t}\n\t\n\tcert := &Certificate{}\n\trecords, err := cert.LoadByType(filter, page, size)\n\tif err != nil {\n\t\tlog.Errorf(\"Failed to load certificates: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "CertificateRecord",
        "code_value": "type CertificateRecord struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tCertificateType string    `json:\"certificate_type\" gorm:\"column:cert_type\"`\n\tNickName      string    `json:\"nick_name\" gorm:\"column:nick_name\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "Certificate",
        "code_value": "type Certificate struct {\n\tbase.Model\n\tRecords []CertificateRecord `json:\"records\" gorm:\"-\"`"
      },
      {
        "code_key": "CertificateFilter",
        "code_value": "type CertificateFilter struct {\n\tCertificateType string `json:\"certificate_type\"`\n\tNickName       string `json:\"nick_name\"`\n\tPage           int    `json:\"page\"`\n\tSize           int    `json:\"size\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "const TableName = \"certificate_records\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "MaxPageSize",
        "code_value": "const MaxPageSize = 100"
      }
    ]
  },
  "synthetic_if-else_orm_CountByStatus": {
    "scenario": "if-else+orm",
    "code_key": "CountByStatus",
    "code_value": "func (a *Auction) CountByStatus(filters map[string]interface{}) (int64, error) {\n\tvar count int64\n\tvar err error\n\t\n\tif status, ok := filters[\"status\"]; ok {\n\t\terr = base.GetDB().Table(\"subscription_tiers\").\n\t\t\tWhere(\"status = ? AND end_date > ?\", status, time.Now().Unix()).\n\t\t\tCount(&count).Error\n\t} else if module, ok := filters[\"module\"]; ok {\n\t\terr = base.GetDB().Table(\"subscription_tiers\").\n\t\t\tWhere(\"module_name LIKE ? AND floor > ?\", \"%\"+module.(string)+\"%\", filters[\"floor\"]).\n\t\t\tCount(&count).Error\n\t} else if endDate, ok := filters[\"end_date\"]; ok {\n\t\terr = base.GetDB().Table(\"subscription_tiers\").\n\t\t\tWhere(\"end_date BETWEEN ? AND ?\", \n\t\t\t\tendDate.(int64)-86400, \n\t\t\t\tendDate.(int64)+86400).\n\t\t\tCount(&count).Error\n\t} else {\n\t\terr = base.GetDB().Table(\"subscription_tiers\").\n\t\t\tWhere(filters).Count(&count).Error\n\t}\n\t\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to count auction records: %v\", err)\n\t}\n\treturn count, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandleSubscriptionStats",
        "code_value": "func (s *SubscriptionService) HandleSubscriptionStats(req *types.SubscriptionStatsRequest) (*types.SubscriptionStatsResponse, error) {\n\tfilters := make(map[string]interface{})\n\t\n\tif req.Status != \"\" {\n\t\tfilters[\"status\"] = req.Status\n\t} else if req.SearchModule != \"\" {\n\t\tfilters[\"module\"] = req.SearchModule\n\t\tfilters[\"floor\"] = req.MinFloor\n\t} else if req.TargetDate > 0 {\n\t\tfilters[\"end_date\"] = req.TargetDate\n\t} else {\n\t\tfilters[\"active\"] = true\n\t}\n\t\n\tauction := &models.Auction{}\n\ttotal, err := auction.CountByStatus(filters)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get subscription stats: %v\", err)\n\t}\n\t\n\treturn &types.SubscriptionStatsResponse{\n\t\tTotalCount: total,\n\t\tFilterType: determineFilterType(filters),\n\t}, nil\n}\n\nfunc determineFilterType(filters map[string]interface{}) string {\n\tif _, ok := filters[\"status\"]; ok {\n\t\treturn \"status\"\n\t} else if _, ok := filters[\"module\"]; ok {\n\t\treturn \"module\"\n\t} else if _, ok := filters[\"end_date\"]; ok {\n\t\treturn \"date_range\"\n\t}\n\treturn \"default\"\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "SubscriptionTier",
        "code_value": "type SubscriptionTier struct {\n\tID        int64     `json:\"id\" gorm:\"column:id\"`\n\tName      string    `json:\"name\" gorm:\"column:name\"`\n\tStatus    string    `json:\"status\" gorm:\"column:status\"`\n\tModule    string    `json:\"module\" gorm:\"column:module_name\"`\n\tFloor     float64   `json:\"floor\" gorm:\"column:floor\"`\n\tEndDate   int64     `json:\"end_date\" gorm:\"column:end_date\"`\n\tCreatedAt time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "AuctionFilter",
        "code_value": "type AuctionFilter struct {\n\tStatus  *string  `json:\"status,omitempty\"`\n\tModule  *string  `json:\"module,omitempty\"`\n\tFloor   *float64 `json:\"floor,omitempty\"`\n\tEndDate *int64   `json:\"end_date,omitempty\"`\n}"
      },
      {
        "code_key": "TableSubscriptionTiers",
        "code_value": "const TableSubscriptionTiers = \"subscription_tiers\""
      },
      {
        "code_key": "AuctionStatus",
        "code_value": "const (\n\tAuctionActive   = \"active\"\n\tAuctionExpired  = \"expired\"\n\tAuctionPending  = \"pending\"\n\tAuctionArchived = \"archived\"\n)"
      },
      {
        "code_key": "DefaultFloorValue",
        "code_value": "const DefaultFloorValue = 0.0"
      }
    ]
  },
  "synthetic_if-else_orm_MonitorHealth": {
    "scenario": "if-else+orm",
    "code_key": "MonitorHealth",
    "code_value": "func (s *Surgery) MonitorHealth(filters map[string]interface{}, limit int) ([]types.VaccinationRecord, error) {\n\tvar records []types.VaccinationRecord\n\tdb := base.GetInstance().MedDriver().Table(\"vaccination_records\")\n\n\tif patientID, ok := filters[\"patient_id\"]; ok {\n\t\terr := db.Where(\"patient_id = ?\", patientID).Limit(limit).Find(&records).Error\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to query by patient_id: %v\", err)\n\t\t}\n\t} else if vaccineType, ok := filters[\"vaccine_type\"]; ok {\n\t\terr := db.Where(\"vaccine_type LIKE ?\", \"%\"+vaccineType.(string)+\"%\").Order(\"injection_date DESC\").Limit(limit).Find(&records).Error\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to query by vaccine_type: %v\", err)\n\t\t}\n\t} else if dateRange, ok := filters[\"date_range\"]; ok {\n\t\tdates := dateRange.([]string)\n\t\tif len(dates) != 2 {\n\t\t\treturn nil, errors.New(\"invalid date range format\")\n\t\t}\n\t\terr := db.Where(\"injection_date BETWEEN ? AND ?\", dates[0], dates[1]).Limit(limit).Find(&records).Error\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to query by date_range: %v\", err)\n\t\t}\n\t} else {\n\t\terr := db.Limit(limit).Find(&records).Error\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to query all records: %v\", err)\n\t\t}\n\t}\n\n\treturn records, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandleVaccineRecords",
        "code_value": "func (h *HealthHandler) HandleVaccineRecords(req *types.VaccineQueryRequest) ([]types.VaccinationRecord, error) {\n\tif req.Limit <= 0 {\n\t\treturn nil, errors.New(\"limit must be positive\")\n\t}\n\n\tqueryFilters := make(map[string]interface{})\n\n\tswitch {\n\tcase req.PatientID != \"\":\n\t\tqueryFilters[\"patient_id\"] = req.PatientID\n\tcase req.VaccineType != \"\":\n\t\tqueryFilters[\"vaccine_type\"] = req.VaccineType\n\tcase req.StartDate != \"\" && req.EndDate != \"\":\n\t\tqueryFilters[\"date_range\"] = []string{req.StartDate, req.EndDate}\n\t}\n\n\tsvc := &Surgery{}\n\trecords, err := svc.MonitorHealth(queryFilters, req.Limit)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to query vaccine records: %v\", err)\n\t}\n\n\tif len(records) == 0 {\n\t\treturn nil, errors.New(\"no matching records found\")\n\t}\n\n\treturn records, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "VaccinationRecord",
        "code_value": "type VaccinationRecord struct {\n\tID            int       `json:\"id\" gorm:\"column:id;primaryKey\"`\n\tPatientID     string    `json:\"patient_id\" gorm:\"column:patient_id;index\"`\n\tVaccineType   string    `json:\"vaccine_type\" gorm:\"column:vaccine_type\"`\n\tInjectionDate time.Time `json:\"injection_date\" gorm:\"column:injection_date\"`\n\tDoseNumber    int       `json:\"dose_number\" gorm:\"column:dose_number\"`\n\tClinicName    string    `json:\"clinic_name\" gorm:\"column:clinic_name\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "HealthMonitorRequest",
        "code_value": "type HealthMonitorRequest struct {\n\tFilters map[string]interface{} `json:\"filters\"`\n\tLimit   int                    `json:\"limit\" validate:\"gt=0\"`\n}"
      },
      {
        "code_key": "HealthStatusResponse",
        "code_value": "type HealthStatusResponse struct {\n\tRecords      []VaccinationRecord `json:\"records\"`\n\tTotalCount   int                 `json:\"total_count\"`\n\tLastUpdated  time.Time           `json:\"last_updated\"`\n\tStatus       string              `json:\"status\"`\n}"
      },
      {
        "code_key": "TableNameVaccinationRecords",
        "code_value": "const TableNameVaccinationRecords = \"vaccination_records\""
      },
      {
        "code_key": "DefaultQueryLimit",
        "code_value": "const DefaultQueryLimit = 100"
      }
    ]
  },
  "synthetic_if-else_orm_LoadBalance": {
    "scenario": "if-else+orm",
    "code_key": "LoadBalance",
    "code_value": "func (b *Budget) LoadBalance(filterParams map[string]interface{}, pageSize int) ([]types.CostAllocation, error) {\n\tallocations := make([]types.CostAllocation, 0)\n\tquery := base.GetInstance().GormDB().Table(\"vendor_contracts\").Order(\"EndDate DESC\")\n\n\tif method, ok := filterParams[\"MethodName\"]; ok {\n\t\tquery = query.Where(\"method_name LIKE ?\", \"%\"+method.(string)+\"%\")\n\t} else if timeRange, ok := filterParams[\"LastAccessTime\"]; ok {\n\t\ttimeValue := timeRange.(time.Time)\n\t\tquery = query.Where(\"last_access_time > ?\", timeValue.Format(time.RFC3339))\n\t} else if amount, ok := filterParams[\"ThresholdAmount\"]; ok {\n\t\tquery = query.Where(\"allocated_amount >= ?\", amount.(float64))\n\t} else {\n\t\tquery = query.Limit(pageSize)\n\t}\n\n\terr := query.Find(&allocations).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, fmt.Errorf(\"no matching records found\")\n\t\t}\n\t\treturn nil, fmt.Errorf(\"database error: %v\", err)\n\t}\n\n\treturn allocations, nil\n}",
    "sql_pattern_cnt": 3,
    "callers": [
      {
        "code_key": "HandleResourceAllocation",
        "code_value": "func (r *ResourceManager) HandleResourceAllocation(req *types.AllocationRequest) ([]types.CostAllocation, error) {\n\tif req == nil {\n\t\treturn nil, fmt.Errorf(\"invalid request\")\n\t}\n\n\tfilters := make(map[string]interface{})\n\tvar pageLimit int\n\n\tif req.MethodFilter != \"\" {\n\t\tfilters[\"MethodName\"] = req.MethodFilter\n\t} else if !req.LastAccessed.IsZero() {\n\t\tfilters[\"LastAccessTime\"] = req.LastAccessed\n\t} else if req.MinAmount > 0 {\n\t\tfilters[\"ThresholdAmount\"] = req.MinAmount\n\t} else {\n\t\tpageLimit = 50\n\t}\n\n\tbudget := &Budget{}\n\tallocations, err := budget.LoadBalance(filters, pageLimit)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to load allocations: %v\", err)\n\t}\n\n\treturn allocations, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "CostAllocation",
        "code_value": "type CostAllocation struct {\n\tID               int       `json:\"id\" gorm:\"column:id\"`\n\tMethodName       string    `json:\"method_name\" gorm:\"column:method_name\"`\n\tLastAccessTime   time.Time `json:\"last_access_time\" gorm:\"column:last_access_time\"`\n\tAllocatedAmount  float64   `json:\"allocated_amount\" gorm:\"column:allocated_amount\"`\n\tEndDate          time.Time `json:\"end_date\" gorm:\"column:end_date\"`\n\tVendorID         string    `json:\"vendor_id\" gorm:\"column:vendor_id\"`\n\tContractNumber   string    `json:\"contract_number\" gorm:\"column:contract_number\"`"
      },
      {
        "code_key": "BudgetFilter",
        "code_value": "type BudgetFilter struct {\n\tMethodName      string\n\tLastAccessTime  time.Time\n\tThresholdAmount float64"
      },
      {
        "code_key": "TableName",
        "code_value": "const TableName = \"vendor_contracts\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 100"
      },
      {
        "code_key": "QueryBuilder",
        "code_value": "var QueryBuilder = map[string]func(*gorm.DB, interface{}) *gorm.DB{\n\t\"MethodName\":      func(db *gorm.DB, val interface{}) *gorm.DB { return db.Where(\"method_name LIKE ?\", \"%\"+val.(string)+\"%\") },\n\t\"LastAccessTime\":  func(db *gorm.DB, val interface{}) *gorm.DB { return db.Where(\"last_access_time > ?\", val.(time.Time).Format(time.RFC3339)) },\n\t\"ThresholdAmount\": func(db *gorm.DB, val interface{}) *gorm.DB { return db.Where(\"allocated_amount >= ?\", val.(float64)) }\n}"
      }
    ]
  },
  "synthetic_if-else_orm_GroupByCategory": {
    "scenario": "if-else+orm",
    "code_key": "GroupByCategory",
    "code_value": "func (m *Module) GroupByCategory(filterParams map[string]interface{}, pageSize int) ([]types.MediaGroup, error) {\n\tvar results []types.MediaGroup\n\tquery := base.GetInstance().MainDB().Table(\"media_library\")\n\n\tif category, ok := filterParams[\"category\"]; ok {\n\t\tquery = query.Where(\"category = ?\", category.(string))\n\t} else if priority, ok := filterParams[\"priority\"]; ok {\n\t\tquery = query.Where(\"priority_rank > ?\", priority.(int))\n\t} else if area, ok := filterParams[\"area\"]; ok {\n\t\tquery = query.Where(\"area LIKE ?\", \"%\"+area.(string)+\"%\")\n\t} else {\n\t\tquery = query.Where(filterParams)\n\t}\n\n\terr := query.Order(\"floor DESC\").Limit(pageSize).Find(&results).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, fmt.Errorf(\"no records found\")\n\t\t}\n\t\treturn nil, fmt.Errorf(\"database error: %v\", err)\n\t}\n\treturn results, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandleMediaLibrary",
        "code_value": "func (s *MediaService) HandleMediaLibrary(req *types.QueryMediaRequest) ([]types.MediaGroup, error) {\n\tif req.PageSize <= 0 {\n\t\treturn nil, fmt.Errorf(\"invalid page size\")\n\t}\n\n\tfilter := make(map[string]interface{})\n\tif req.Category != \"\" {\n\t\tfilter[\"category\"] = req.Category\n\t} else if req.Priority > 0 {\n\t\tfilter[\"priority\"] = req.Priority\n\t} else if req.Area != \"\" {\n\t\tfilter[\"area\"] = req.Area\n\t} else {\n\t\tfilter[\"status\"] = \"active\"\n\t}\n\n\tmediaModule := &Module{}\n\tresults, err := mediaModule.GroupByCategory(filter, req.PageSize)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"query failed: %v\", err)\n\t}\n\n\tif len(results) == 0 {\n\t\treturn nil, fmt.Errorf(\"no matching records\")\n\t}\n\n\treturn results, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "MediaGroup",
        "code_value": "type MediaGroup struct {\n\tID          int       `json:\"id\" gorm:\"column:id\"`\n\tCategory    string    `json:\"category\" gorm:\"column:category\"`\n\tPriorityRank int      `json:\"priority_rank\" gorm:\"column:priority_rank\"`\n\tArea        string    `json:\"area\" gorm:\"column:area\"`\n\tFloor       int       `json:\"floor\" gorm:\"column:floor\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt   time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "FilterParams",
        "code_value": "type FilterParams struct {\n\tCategory string `json:\"category\"`\n\tPriority int    `json:\"priority\"`\n\tArea     string `json:\"area\"`\n}"
      },
      {
        "code_key": "MediaLibraryTable",
        "code_value": "const MediaLibraryTable = \"media_library\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "PriorityLevels",
        "code_value": "var PriorityLevels = map[string]int{\n\t\"high\":   3,\n\t\"medium\": 2,\n\t\"low\":    1\n}"
      }
    ]
  },
  "synthetic_if-else_orm_OptimizeRoutes": {
    "scenario": "if-else+orm",
    "code_key": "OptimizeRoutes",
    "code_value": "func (t *Teacher) OptimizeRoutes(filterParams map[string]interface{}) ([]types.RouteOptimization, error) {\n\tvar routes []types.RouteOptimization\n\tdb := base.GetInstance().GormDB().Table(\"logistics_hubs\")\n\n\tif building, ok := filterParams[\"Building\"]; ok {\n\t\tdb = db.Where(\"building = ?\", building).Order(\"distance ASC\")\n\t} else if locale, ok := filterParams[\"Locale\"]; ok {\n\t\tdb = db.Where(\"locale LIKE ?\", \"%\"+locale.(string)+\"%\").Order(\"capacity DESC\")\n\t} else if requestId, ok := filterParams[\"RequestId\"]; ok {\n\t\tdb = db.Joins(\"JOIN return_requests ON logistics_hubs.id = return_requests.hub_id\").\n\t\t\tWhere(\"return_requests.request_id = ?\", requestId).Order(\"return_requests.created_at DESC\")\n\t} else {\n\t\tdb = db.Where(\"status = ?\", \"active\").Order(\"created_at DESC\")\n\t}\n\n\terr := db.Find(&routes).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, fmt.Errorf(\"no routes found matching criteria\")\n\t\t}\n\t\treturn nil, fmt.Errorf(\"database error: %v\", err)\n\t}\n\n\treturn routes, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandleRouteOptimization",
        "code_value": "func (s *RouteService) HandleRouteOptimization(req *types.RouteRequest) ([]types.RouteOptimization, error) {\n\tif req == nil {\n\t\treturn nil, fmt.Errorf(\"invalid request parameters\")\n\t}\n\n\tfilterCriteria := make(map[string]interface{})\n\n\tswitch {\n\tcase req.BuildingID != \"\":\n\t\tfilterCriteria[\"Building\"] = req.BuildingID\n\tcase req.LocaleQuery != \"\":\n\t\tfilterCriteria[\"Locale\"] = req.LocaleQuery\n\tcase req.ReturnRequestID != \"\":\n\t\tfilterCriteria[\"RequestId\"] = req.ReturnRequestID\n\t}\n\n\troutePlanner := &Teacher{}\n\toptimizedRoutes, err := routePlanner.OptimizeRoutes(filterCriteria)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to optimize routes: %v\", err)\n\t}\n\n\tif len(optimizedRoutes) == 0 {\n\t\treturn nil, fmt.Errorf(\"no routes available for given criteria\")\n\t}\n\n\treturn optimizedRoutes, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "RouteOptimization",
        "code_value": "type RouteOptimization struct {\n\tID        uint      `gorm:\"column:id;primaryKey\" json:\"id\"`\n\tBuilding  string    `gorm:\"column:building\" json:\"building\"`\n\tLocale    string    `gorm:\"column:locale\" json:\"locale\"`\n\tDistance  float64   `gorm:\"column:distance\" json:\"distance\"`\n\tCapacity  int       `gorm:\"column:capacity\" json:\"capacity\"`\n\tStatus    string    `gorm:\"column:status\" json:\"status\"`\n\tCreatedAt time.Time `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt time.Time `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "ReturnRequest",
        "code_value": "type ReturnRequest struct {\n\tID        uint      `gorm:\"column:id;primaryKey\" json:\"id\"`\n\tRequestId string    `gorm:\"column:request_id\" json:\"request_id\"`\n\tHubId     uint      `gorm:\"column:hub_id\" json:\"hub_id\"`\n\tCreatedAt time.Time `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "LogisticsHubStatus",
        "code_value": "const (\n\tHubStatusActive   = \"active\"\n\tHubStatusInactive = \"inactive\"\n\tHubStatusPending  = \"pending\"\n)"
      },
      {
        "code_key": "DefaultPaginationLimit",
        "code_value": "const DefaultPaginationLimit = 50"
      },
      {
        "code_key": "HubTableName",
        "code_value": "const HubTableName = \"logistics_hubs\""
      },
      {
        "code_key": "RequestTableName",
        "code_value": "const RequestTableName = \"return_requests\""
      },
      {
        "code_key": "OptimizationCache",
        "code_value": "var OptimizationCache = sync.Map{}"
      }
    ]
  },
  "synthetic_if-else_orm_ValidateByRules": {
    "scenario": "if-else+orm",
    "code_key": "ValidateByRules",
    "code_value": "func (a *Achievement) ValidateByRules(validationParams map[string]interface{}) ([]types.AchievementRecord, error) {\n\tvar records []types.AchievementRecord\n\tdb := base.GetInstance().MainDB().Table(\"maintenance_logs\")\n\n\tif editor, ok := validationParams[\"Editor\"]; ok {\n\t\terr := db.Where(\"editor = ? AND status = ?\", editor.(string), \"pending\")\n\t\t\t.Order(\"created_at DESC\").Find(&records).Error\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to query by editor: %v\", err)\n\t\t}\n\t} else if subject, ok := validationParams[\"Subject\"]; ok {\n\t\terr := db.Where(\"subject LIKE ?\", \"%\"+subject.(string)+\"%\")\n\t\t\t.Limit(100).Find(&records).Error\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to query by subject: %v\", err)\n\t\t}\n\t} else if shipmentID, ok := validationParams[\"ShipmentId\"]; ok {\n\t\terr := db.Joins(\"LEFT JOIN department_structure ON maintenance_logs.department_id = department_structure.id\")\n\t\t\t.Where(\"shipment_id = ? AND department_structure.region = ?\", \n\t\t\t\tshipmentID.(string), \"east\").Find(&records).Error\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to query by shipment: %v\", err)\n\t\t}\n\t} else {\n\t\terr := db.Where(validationParams).Find(&records).Error\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to query with default params: %v\", err)\n\t\t}\n\t}\n\n\tif len(records) == 0 {\n\t\treturn nil, utils.RecordNotFoundError\n\t}\n\treturn records, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandleMaintenanceLogs",
        "code_value": "func (s *MaintenanceService) HandleMaintenanceLogs(req *types.MaintenanceLogRequest) ([]types.AchievementRecord, error) {\n\tif req == nil {\n\t\treturn nil, fmt.Errorf(\"invalid request parameters\")\n\t}\n\n\tvalidator := &Achievement{}\n\tparams := make(map[string]interface{})\n\n\tswitch {\n\tcase req.Editor != \"\":\n\t\tparams[\"Editor\"] = req.Editor\n\tcase req.Subject != \"\":\n\t\tparams[\"Subject\"] = req.Subject\n\tcase req.ShipmentID != \"\":\n\t\tparams[\"ShipmentId\"] = req.ShipmentID\n\tdefault:\n\t\tparams[\"status\"] = \"active\"\n\t}\n\n\tresults, err := validator.ValidateByRules(params)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"validation failed: %v\", err)\n\t}\n\n\treturn results, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "AchievementRecord",
        "code_value": "type AchievementRecord struct {\n\tID          int       `json:\"id\" gorm:\"column:id\"`\n\tEditor      string    `json:\"editor\" gorm:\"column:editor\"`\n\tSubject     string    `json:\"subject\" gorm:\"column:subject\"`\n\tShipmentId  string    `json:\"shipment_id\" gorm:\"column:shipment_id\"`\n\tDepartmentId int      `json:\"department_id\" gorm:\"column:department_id\"`\n\tStatus      string    `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt   time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "ValidationStatus",
        "code_value": "const (\n\tStatusPending  = \"pending\"\n\tStatusApproved = \"approved\"\n\tStatusRejected = \"rejected\"\n)"
      },
      {
        "code_key": "QueryRegion",
        "code_value": "const EastRegion = \"east\""
      },
      {
        "code_key": "MaintenanceLogTable",
        "code_value": "const MaintenanceLogTable = \"maintenance_logs\""
      },
      {
        "code_key": "DepartmentStructure",
        "code_value": "type DepartmentStructure struct {\n\tID        int    `json:\"id\" gorm:\"column:id\"`\n\tRegion    string `json:\"region\" gorm:\"column:region\"`\n\tParentID  int    `json:\"parent_id\" gorm:\"column:parent_id\"`\n\tIsActive  bool   `json:\"is_active\" gorm:\"column:is_active\"`\n}"
      },
      {
        "code_key": "MaxQueryLimit",
        "code_value": "const DefaultQueryLimit = 100"
      }
    ]
  },
  "synthetic_if-else_orm_SearchByKeyword": {
    "scenario": "if-else+orm",
    "code_key": "SearchByKeyword",
    "code_value": "func (p *Publication) SearchByKeyword(filter map[string]interface{}, page, size int) ([]types.PublicationDetail, error) {\n\tresults := make([]types.PublicationDetail, 0)\n\tdb := base.GetInstance().GormDB().Table(\"publication\")\n\n\tif keyword, ok := filter[\"keyword\"]; ok {\n\t\tdb = db.Where(\"title LIKE ? OR abstract LIKE ?\", \n\t\t\t\"%\"+keyword.(string)+\"%\", \n\t\t\t\"%\"+keyword.(string)+\"%\")\n\t} else if authorId, ok := filter[\"author_id\"]; ok {\n\t\tdb = db.Where(\"author_id = ? AND status = ?\", \n\t\t\tauthorId.(int), \n\t\t\ttypes.Published)\n\t} else if deliveryCode, ok := filter[\"delivery_code\"]; ok {\n\t\tdb = db.Where(\"delivery_code = ?\", deliveryCode.(string))\n\t} else {\n\t\tdb = db.Where(filter)\n\t}\n\n\terr := db.Order(\"created_at DESC\").\n\t\tScopes(PaginateDB(page, size)).\n\t\tFind(&results).Error\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn results, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandleMediaSearch",
        "code_value": "func (m *MediaHandler) HandleMediaSearch(req *types.MediaSearchRequest) ([]types.PublicationDetail, error) {\n\tif req.Page <= 0 || req.Size <= 0 {\n\t\treturn nil, errors.New(\"invalid pagination parameters\")\n\t}\n\t\n\tfilter := make(map[string]interface{})\n\tif req.Keyword != \"\" {\n\t\tfilter[\"keyword\"] = req.Keyword\n\t} else if req.AuthorID > 0 {\n\t\tfilter[\"author_id\"] = req.AuthorID\n\t} else if req.DeliveryCode != \"\" {\n\t\tfilter[\"delivery_code\"] = req.DeliveryCode\n\t} else {\n\t\tfilter[\"status\"] = types.Published\n\t}\n\t\n\tpub := &Publication{}\n\tresults, err := pub.SearchByKeyword(filter, req.Page, req.Size)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"search failed: %v\", err)\n\t}\n\t\n\treturn results, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "PublicationDetail",
        "code_value": "type PublicationDetail struct {\n\tID           int       `json:\"id\" gorm:\"column:id\"`\n\tTitle        string    `json:\"title\" gorm:\"column:title\"`\n\tAbstract     string    `json:\"abstract\" gorm:\"column:abstract\"`\n\tAuthorID     int       `json:\"author_id\" gorm:\"column:author_id\"`\n\tDeliveryCode string    `json:\"delivery_code\" gorm:\"column:delivery_code\"`\n\tStatus       int       `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt    time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt    time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "PublicationStatus",
        "code_value": "const (\n\tDraft     = 0\n\tPublished = 1\n\tArchived  = 2\n)"
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "PublicationFilter",
        "code_value": "type PublicationFilter struct {\n\tKeyword      string `json:\"keyword\"`\n\tAuthorID     int    `json:\"author_id\"`\n\tDeliveryCode string `json:\"delivery_code\"`\n\tStatus       int    `json:\"status\"`\n}"
      },
      {
        "code_key": "Paginator",
        "code_value": "type Paginator struct {\n\tPage  int `json:\"page\"`\n\tSize  int `json:\"size\"`\n\tTotal int `json:\"total\"`\n}"
      }
    ]
  },
  "synthetic_if-else_orm_SelectByRange": {
    "scenario": "if-else+orm",
    "code_key": "SelectByRange",
    "code_value": "func (p *Project) SelectByRange(filter map[string]interface{}) ([]types.BudgetAllocation, error) {\n\tvar allocations []types.BudgetAllocation\n\tdb := base.GetInstance().GpsDriver().Table(\"expense_reports\")\n\n\tif region, ok := filter[\"RegionCode\"]; ok {\n\t\tdb = db.Where(\"region_code = ?\", region).Order(\"allocated_at DESC\")\n\t} else if dateFrom, ok := filter[\"DateFrom\"]; ok {\n\t\tdateTo, hasDateTo := filter[\"DateTo\"]\n\t\tif hasDateTo {\n\t\t\tdb = db.Where(\"allocated_at BETWEEN ? AND ?\", dateFrom, dateTo)\n\t\t} else {\n\t\t\tdb = db.Where(\"allocated_at >= ?\", dateFrom)\n\t\t}\n\t} else if zipCode, ok := filter[\"ZipCode\"]; ok {\n\t\tdb = db.Where(\"zip_code LIKE ?\", \"%\"+zipCode.(string)+\"%\")\n\t} else {\n\t\tdb = db.Limit(100)\n\t}\n\n\tif department, ok := filter[\"Department\"]; ok {\n\t\tdb = db.Where(\"department = ?\", department)\n\t}\n\n\terr := db.Find(&allocations).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn allocations, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandleBudgetAllocations",
        "code_value": "func (h *BudgetHandler) HandleBudgetAllocations(req *types.BudgetRequest) ([]types.BudgetAllocation, error) {\n\tif req == nil {\n\t\treturn nil, errors.New(\"invalid request\")\n\t}\n\n\tfilterParams := make(map[string]interface{})\n\tif req.Region != \"\" {\n\t\tfilterParams[\"RegionCode\"] = req.Region\n\t} else if !req.StartDate.IsZero() {\n\t\tfilterParams[\"DateFrom\"] = req.StartDate\n\t\tif !req.EndDate.IsZero() {\n\t\t\tfilterParams[\"DateTo\"] = req.EndDate\n\t\t}\n\t} else if req.PostalCode != \"\" {\n\t\tfilterParams[\"ZipCode\"] = req.PostalCode\n\t}\n\n\tif req.DepartmentID > 0 {\n\t\tfilterParams[\"Department\"] = req.DepartmentID\n\t}\n\n\tproject := &Project{}\n\tallocations, err := project.SelectByRange(filterParams)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get budget allocations: %w\", err)\n\t}\n\treturn allocations, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "BudgetAllocation",
        "code_value": "type BudgetAllocation struct {\n\tID          int       `json:\"id\" gorm:\"column:id\"`\n\tRegionCode  string    `json:\"region_code\" gorm:\"column:region_code\"`\n\tDepartment  string    `json:\"department\" gorm:\"column:department\"`\n\tZipCode     string    `json:\"zip_code\" gorm:\"column:zip_code\"`\n\tAmount      float64   `json:\"amount\" gorm:\"column:amount\"`\n\tAllocatedAt time.Time `json:\"allocated_at\" gorm:\"column:allocated_at\"`\n}"
      },
      {
        "code_key": "ExpenseFilter",
        "code_value": "type ExpenseFilter struct {\n\tRegionCode string\n\tDateFrom   time.Time\n\tDateTo     time.Time\n\tZipCode    string\n\tDepartment string\n}"
      },
      {
        "code_key": "TableExpenseReports",
        "code_value": "const TableExpenseReports = \"expense_reports\""
      },
      {
        "code_key": "DefaultQueryLimit",
        "code_value": "const DefaultQueryLimit = 100"
      },
      {
        "code_key": "BudgetResponse",
        "code_value": "type BudgetResponse struct {\n\tAllocations []BudgetAllocation `json:\"allocations\"`\n\tTotal       float64            `json:\"total\"`\n\tLimit       int                `json:\"limit\"`\n}"
      }
    ]
  },
  "synthetic_if-else_orm_CompareData": {
    "scenario": "if-else+orm",
    "code_key": "CompareData",
    "code_value": "func (m *Message) CompareData(filter map[string]interface{}, limit int) ([]types.MessageData, error) {\n\tvar results []types.MessageData\n\tvar err error\n\t\n\tif priority, ok := filter[\"Priority\"]; ok {\n\t\terr = db.Get().Table(\"grade_records\").\n\t\t\tWhere(\"priority = ? AND status != ?\", priority.(int), \"archived\").\n\t\t\tOrder(\"created_at desc\").\n\t\t\tLimit(limit).\n\t\t\tFind(&results).Error\n\t} else if author, ok := filter[\"Author\"]; ok {\n\t\terr = db.Get().Table(\"grade_records\").\n\t\t\tWhere(\"author LIKE ? AND permission_type IN (?)\", \"%\"+author.(string)+\"%\", []string{\"read\", \"write\"}).\n\t\t\tOrder(\"updated_at desc\").\n\t\t\tLimit(limit).\n\t\t\tFind(&results).Error\n\t} else if connectionStr, ok := filter[\"ConnectionString\"]; ok {\n\t\terr = db.Get().Table(\"grade_records\").\n\t\t\tWhere(\"connection_string = ?\", connectionStr.(string)).\n\t\t\tOrder(\"id asc\").\n\t\t\tLimit(limit).\n\t\t\tFind(&results).Error\n\t} else {\n\t\terr = db.Get().Table(\"grade_records\").\n\t\t\tWhere(filter).\n\t\t\tOrder(\"created_at desc\").\n\t\t\tLimit(limit).\n\t\t\tFind(&results).Error\n\t}\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to compare data: %w\", err)\n\t}\n\treturn results, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandleMessageFilter",
        "code_value": "func (s *MessageService) HandleMessageFilter(req *types.FilterRequest, log *logger.AppLog) ([]types.MessageData, error) {\n\tif req.Limit <= 0 {\n\t\treturn nil, fmt.Errorf(\"invalid limit parameter\")\n\t}\n\n\tfilterConditions := make(map[string]interface{})\n\tif req.Priority > 0 {\n\t\tfilterConditions[\"Priority\"] = req.Priority\n\t} else if req.Author != \"\" {\n\t\tif len(req.Author) > 100 {\n\t\t\treturn nil, fmt.Errorf(\"author name too long\")\n\t\t}\n\t\tfilterConditions[\"Author\"] = req.Author\n\t} else if req.ConnectionString != \"\" {\n\t\tfilterConditions[\"ConnectionString\"] = req.ConnectionString\n\t} else {\n\t\tfilterConditions[\"Status\"] = \"active\"\n\t}\n\n\tmsgObj := &Message{ID: req.MessageID}\n\tfilteredData, err := msgObj.CompareData(filterConditions, req.Limit)\n\tif err != nil {\n\t\tlog.Error(fmt.Sprintf(\"Message filter failed: %v\", err))\n\t\treturn nil, fmt.Errorf(\"message filtering error\")\n\t}\n\n\tif len(filteredData) == 0 {\n\t\tlog.Info(\"No messages found matching criteria\")\n\t\treturn nil, nil\n\t}\n\n\treturn filteredData, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "MessageData",
        "code_value": "type MessageData struct {\n\tID              int       `json:\"id\" gorm:\"column:id\"`\n\tPriority        int       `json:\"priority\" gorm:\"column:priority\"`\n\tAuthor          string    `json:\"author\" gorm:\"column:author\"`\n\tConnectionString string   `json:\"connection_string\" gorm:\"column:connection_string\"`\n\tStatus          string    `json:\"status\" gorm:\"column:status\"`\n\tPermissionType  string    `json:\"permission_type\" gorm:\"column:permission_type\"`\n\tCreatedAt       time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt       time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "Message",
        "code_value": "type Message struct {\n\tDB *gorm.DB `json:\"-\"`\n}"
      },
      {
        "code_key": "GradeRecordStatus",
        "code_value": "const (\n\tGradeRecordActive  = \"active\"\n\tGradeRecordArchived = \"archived\"\n\tGradeRecordPending = \"pending\"\n)"
      },
      {
        "code_key": "PermissionTypes",
        "code_value": "var PermissionTypes = []string{\"read\", \"write\", \"admin\"}"
      },
      {
        "code_key": "DefaultLimit",
        "code_value": "const DefaultLimit = 100"
      }
    ]
  },
  "synthetic_if-else_orm_EvaluateResults": {
    "scenario": "if-else+orm",
    "code_key": "EvaluateResults",
    "code_value": "func (b *Buyer) EvaluateResults(filterCriteria map[string]interface{}, limit int) ([]types.PurchaseEvaluation, error) {\n\tresults := make([]types.PurchaseEvaluation, 0)\n\tdb := base.GetInstance().MainDB().Table(\"like_records\")\n\n\tif rating, ok := filterCriteria[\"min_rating\"]; ok {\n\t\tdb = db.Where(\"rating >= ?\", rating).Order(\"created_at DESC\")\n\t} else if floor, ok := filterCriteria[\"floor\"]; ok {\n\t\tdb = db.Where(\"floor = ? AND is_verified = ?\", floor, true).Order(\"rating DESC\")\n\t} else if lastName, ok := filterCriteria[\"last_name\"]; ok {\n\t\tdb = db.Where(\"last_name LIKE ?\", \"%\"+lastName.(string)+\"%\").Order(\"updated_at DESC\")\n\t} else {\n\t\tdb = db.Where(filterCriteria).Order(\"id DESC\")\n\t}\n\n\terr := db.Limit(limit).Find(&results).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn results, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to evaluate results: %w\", err)\n\t}\n\n\treturn results, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandlePurchaseEvaluation",
        "code_value": "func (s *PurchaseService) HandlePurchaseEvaluation(req *types.EvaluationRequest) ([]types.PurchaseEvaluation, error) {\n\tif req.Limit <= 0 {\n\t\treturn nil, fmt.Errorf(\"limit must be positive\")\n\t}\n\n\tfilter := make(map[string]interface{})\n\tif req.MinRating > 0 {\n\t\tfilter[\"min_rating\"] = req.MinRating\n\t} else if req.Floor != \"\" {\n\t\tfilter[\"floor\"] = req.Floor\n\t} else if req.LastName != \"\" {\n\t\tfilter[\"last_name\"] = req.LastName\n\t} else {\n\t\tfilter[\"status\"] = \"completed\"\n\t}\n\n\tbuyer := &Buyer{}\n\treturn buyer.EvaluateResults(filter, req.Limit)\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "PurchaseEvaluation",
        "code_value": "type PurchaseEvaluation struct {\n\tID          int       `json:\"id\" gorm:\"column:id\"`\n\tRating      float64   `json:\"rating\" gorm:\"column:rating\"`\n\tFloor       string    `json:\"floor\" gorm:\"column:floor\"`\n\tIsVerified  bool      `json:\"is_verified\" gorm:\"column:is_verified\"`\n\tLastName    string    `json:\"last_name\" gorm:\"column:last_name\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt   time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "BuyerEvaluationParams",
        "code_value": "type BuyerEvaluationParams struct {\n\tMinRating  float64                `json:\"min_rating\"`\n\tFloor      string                 `json:\"floor\"`\n\tLastName   string                 `json:\"last_name\"`\n\tExtraFilters map[string]interface{} `json:\"extra_filters\"`\n}"
      },
      {
        "code_key": "TableLikeRecords",
        "code_value": "const TableLikeRecords = \"like_records\""
      },
      {
        "code_key": "DefaultEvaluationLimit",
        "code_value": "const DefaultEvaluationLimit = 100"
      },
      {
        "code_key": "EvaluationStatus",
        "code_value": "type EvaluationStatus string\n\nconst (\n\tStatusPending   EvaluationStatus = \"pending\"\n\tStatusApproved  EvaluationStatus = \"approved\"\n\tStatusRejected  EvaluationStatus = \"rejected\"\n)"
      }
    ]
  },
  "synthetic_if-else_orm_FilterMarketEvents": {
    "scenario": "if-else+orm",
    "code_key": "FilterMarketEvents",
    "code_value": "func (v *Vendor) FilterMarketEvents(criteria map[string]interface{}, page, size int) ([]types.MarketEvent, error) {\n\tvar events []types.MarketEvent\n\tdb := base.GetInstance().GormDB().Table(\"market_data\")\n\t\n\tif theme, ok := criteria[\"Theme\"]; ok {\n\t\tdb = db.Where(\"theme LIKE ?\", \"%\"+theme.(string)+\"%\")\n\t} else if trackingID, ok := criteria[\"TrackingId\"]; ok {\n\t\tdb = db.Where(\"tracking_id = ?\", trackingID.(string))\n\t} else if deliveryCode, ok := criteria[\"DeliveryCode\"]; ok {\n\t\tdb = db.Where(\"delivery_code IN ?\", strings.Split(deliveryCode.(string), \",\"))\n\t}\n\t\n\terr := db.Scopes(PaginateDB(page, size)).\n\t\tOrder(\"created_at DESC\").\n\t\tFind(&events).Error\n\t\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.ErrNotFound\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to query market events: %w\", err)\n\t}\n\treturn events, nil\n}",
    "sql_pattern_cnt": 3,
    "callers": [
      {
        "code_key": "HandleMarketEventSearch",
        "code_value": "func (s *MarketService) HandleMarketEventSearch(req *types.SearchMarketEventsRequest) ([]types.MarketEvent, error) {\n\tsearchCriteria := make(map[string]interface{})\n\tif req.Theme != \"\" {\n\t\tsearchCriteria[\"Theme\"] = req.Theme\n\t} else if req.TrackingID != \"\" {\n\t\tsearchCriteria[\"TrackingId\"] = req.TrackingID\n\t} else if req.DeliveryCodes != \"\" {\n\t\tsearchCriteria[\"DeliveryCode\"] = req.DeliveryCodes\n\t} else {\n\t\treturn nil, fmt.Errorf(\"at least one search parameter must be provided\")\n\t}\n\n\tvendor := &Vendor{DB: s.DB}\n\tevents, err := vendor.FilterMarketEvents(searchCriteria, req.Page, req.Size)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"market event search failed: %w\", err)\n\t}\n\n\tif len(events) == 0 {\n\t\treturn nil, fmt.Errorf(\"no market events found matching criteria\")\n\t}\n\treturn events, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "MarketEvent",
        "code_value": "type MarketEvent struct {\n\tID           uint      `json:\"id\" gorm:\"primaryKey\"`\n\tTheme        string    `json:\"theme\" gorm:\"column:theme\"`\n\tTrackingId   string    `json:\"tracking_id\" gorm:\"column:tracking_id\"`\n\tDeliveryCode string    `json:\"delivery_code\" gorm:\"column:delivery_code\"`\n\tCreatedAt    time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt    time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "EventFilterCriteria",
        "code_value": "type EventFilterCriteria struct {\n\tTheme        *string\n\tTrackingId   *string\n\tDeliveryCode *string\n}"
      },
      {
        "code_key": "MarketEventResponse",
        "code_value": "type MarketEventResponse struct {\n\tEvents      []MarketEvent `json:\"events\"`\n\tTotalCount  int          `json:\"total_count\"`\n\tCurrentPage int          `json:\"current_page\"`\n\tPageSize    int          `json:\"page_size\"`\n}"
      },
      {
        "code_key": "TableNameMarketData",
        "code_value": "const TableNameMarketData = \"market_data\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "MaxPageSize",
        "code_value": "const MaxPageSize = 100"
      },
      {
        "code_key": "EventStatus",
        "code_value": "const (\n\tEventStatusPending   = \"pending\"\n\tEventStatusActive    = \"active\"\n\tEventStatusCompleted = \"completed\"\n\tEventStatusCancelled = \"cancelled\"\n)"
      },
      {
        "code_key": "eventStatusMap",
        "code_value": "var eventStatusMap = map[string]int{\n\t\"pending\":   0,\n\t\"active\":    1,\n\t\"completed\": 2,\n\t\"cancelled\": 3,\n}"
      }
    ]
  },
  "synthetic_if-else_orm_PredictTrends": {
    "scenario": "if-else+orm",
    "code_key": "PredictTrends",
    "code_value": "func (s *Semester) PredictTrends(filterParams map[string]interface{}) ([]types.ExamTrend, error) {\n\ttrends := make([]types.ExamTrend, 0)\n\tvar err error\n\n\tquery := base.GetInstance().IvcDriver().Table(\"exam_results\").Order(\"created_at DESC\")\n\n\tif subject, ok := filterParams[\"subject\"]; ok {\n\t\tquery = query.Where(\"subject = ?\", subject.(string))\n\t} else if scoreRange, ok := filterParams[\"score_range\"]; ok {\n\t\trangeValues := scoreRange.([]int)\n\t\tif len(rangeValues) == 2 {\n\t\t\tquery = query.Where(\"score BETWEEN ? AND ?\", rangeValues[0], rangeValues[1])\n\t\t}\n\t} else if studentId, ok := filterParams[\"student_id\"]; ok {\n\t\tquery = query.Where(\"student_id LIKE ?\", \"%\"+studentId.(string)+\"%\")\n\t} else {\n\t\tquery = query.Limit(100)\n\t}\n\n\terr = query.Find(&trends).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn trends, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\n\treturn trends, nil\n}",
    "sql_pattern_cnt": 3,
    "callers": [
      {
        "code_key": "HandleExamTrends",
        "code_value": "func (h *ExamHandler) HandleExamTrends(req *types.ExamTrendRequest) ([]types.ExamTrend, error) {\n\tif req == nil {\n\t\treturn nil, fmt.Errorf(\"request cannot be nil\")\n\t}\n\n\tfilterCriteria := make(map[string]interface{})\n\n\tsemester := &models.Semester{ID: req.SemesterID}\n\n\tswitch req.FilterType {\n\tcase \"subject\":\n\t\tif req.Subject == \"\" {\n\t\t\treturn nil, fmt.Errorf(\"subject cannot be empty\")\n\t\t}\n\t\tfilterCriteria[\"subject\"] = req.Subject\n\tcase \"score_range\":\n\t\tif len(req.ScoreRange) != 2 {\n\t\t\treturn nil, fmt.Errorf(\"score range must have 2 values\")\n\t\t}\n\t\tfilterCriteria[\"score_range\"] = req.ScoreRange\n\tcase \"student\":\n\t\tif req.StudentID == \"\" {\n\t\t\treturn nil, fmt.Errorf(\"student ID cannot be empty\")\n\t\t}\n\t\tfilterCriteria[\"student_id\"] = req.StudentID\n\tdefault:\n\t\t// No filter applied, will use default limit\n\t}\n\n\ttrendResults, err := semester.PredictTrends(filterCriteria)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to predict trends: %v\", err)\n\t}\n\n\treturn trendResults, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "ExamTrend",
        "code_value": "type ExamTrend struct {\n\tID        int       `json:\"id\" gorm:\"column:id\"`\n\tStudentID string    `json:\"student_id\" gorm:\"column:student_id\"`\n\tSubject   string    `json:\"subject\" gorm:\"column:subject\"`\n\tScore     int       `json:\"score\" gorm:\"column:score\"`\n\tCreatedAt time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "TrendFilter",
        "code_value": "type TrendFilter struct {\n\tSubject    string `json:\"subject\"`\n\tScoreRange []int  `json:\"score_range\"`\n\tStudentID  string `json:\"student_id\"`\n}"
      },
      {
        "code_key": "ExamResultTable",
        "code_value": "const ExamResultTable = \"exam_results\""
      },
      {
        "code_key": "DefaultLimit",
        "code_value": "const DefaultLimit = 100"
      },
      {
        "code_key": "TrendResponse",
        "code_value": "type TrendResponse struct {\n\tData  []ExamTrend `json:\"data\"`\n\tTotal int         `json:\"total\"`\n\tError string      `json:\"error,omitempty\"`\n}"
      }
    ]
  },
  "synthetic_if-else_orm_DecryptInfo": {
    "scenario": "if-else+orm",
    "code_key": "DecryptInfo",
    "code_value": "func (i *Image) DecryptInfo(filterParams map[string]interface{}) ([]types.ImageRecord, error) {\n\tvar results []types.ImageRecord\n\tdb := base.GetInstance().MainDB().Table(\"training_certifications\")\n\t\n\tif encryptionKey, ok := filterParams[\"EncryptionKey\"]; ok {\n\t\terr := db.Where(\"encryption_key = ? AND is_active = ?\", encryptionKey, true).\n\t\t\tOrder(\"created_at DESC\").Find(&results).Error\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to decrypt with key: %v\", err)\n\t\t}\n\t} else if language, ok := filterParams[\"Language\"]; ok {\n\t\terr := db.Where(\"language = ? AND timezone = ?\", language, filterParams[\"Timezone\"]).\n\t\t\tOrder(\"sequence_number ASC\").Find(&results).Error\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"language query failed: %v\", err)\n\t\t}\n\t} else if sequenceNum, ok := filterParams[\"SequenceNumber\"]; ok {\n\t\terr := db.Where(\"sequence_number > ?\", sequenceNum).\n\t\t\tLimit(100).Find(&results).Error\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"sequence query failed: %v\", err)\n\t\t}\n\t} else {\n\t\terr := db.Where(filterParams).Find(&results).Error\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"generic query failed: %v\", err)\n\t\t}\n\t}\n\t\n\tif len(results) == 0 {\n\t\treturn nil, db.ErrRecordNotFound\n\t}\n\treturn results, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandleImageDecryption",
        "code_value": "func (s *ImageService) HandleImageDecryption(req *types.ImageDecryptionRequest) ([]types.ImageRecord, error) {\n\tif req == nil {\n\t\treturn nil, fmt.Errorf(\"request cannot be nil\")\n\t}\n\n\tfilterCriteria := make(map[string]interface{})\n\tif req.EncryptionKey != \"\" {\n\t\tfilterCriteria[\"EncryptionKey\"] = req.EncryptionKey\n\t} else if req.Language != \"\" {\n\t\tfilterCriteria[\"Language\"] = req.Language\n\t\tfilterCriteria[\"Timezone\"] = req.Timezone\n\t} else if req.SequenceNum > 0 {\n\t\tfilterCriteria[\"SequenceNumber\"] = req.SequenceNum\n\t} else {\n\t\tfilterCriteria[\"IsActive\"] = true\n\t}\n\n\timgProcessor := &Image{Metadata: req.Metadata}\n\tdecryptedResults, err := imgProcessor.DecryptInfo(filterCriteria)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"image decryption failed: %v\", err)\n\t}\n\n\tif len(decryptedResults) == 0 {\n\t\treturn nil, fmt.Errorf(\"no matching records found\")\n\t}\n\treturn decryptedResults, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "ImageRecord",
        "code_value": "type ImageRecord struct {\n\tID            uint      `json:\"id\" gorm:\"primaryKey\"`\n\tEncryptionKey string    `json:\"encryption_key\" gorm:\"column:encryption_key\"`\n\tIsActive      bool      `json:\"is_active\" gorm:\"column:is_active\"`\n\tLanguage      string    `json:\"language\" gorm:\"column:language\"`\n\tTimezone      string    `json:\"timezone\" gorm:\"column:timezone\"`\n\tSequenceNumber int       `json:\"sequence_number\" gorm:\"column:sequence_number\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tImageData     []byte    `json:\"image_data\" gorm:\"column:image_data\"`\n}"
      },
      {
        "code_key": "TrainingCertification",
        "code_value": "type TrainingCertification struct {\n\tImageRecord\n\tExpiryDate    time.Time `json:\"expiry_date\" gorm:\"column:expiry_date\"`\n\tCertification string    `json:\"certification\" gorm:\"column:certification\"`\n}"
      },
      {
        "code_key": "DecryptionParams",
        "code_value": "type DecryptionParams struct {\n\tEncryptionKey  string `json:\"encryption_key\"`\n\tLanguage       string `json:\"language\"`\n\tTimezone       string `json:\"timezone\"`\n\tSequenceNumber int    `json:\"sequence_number\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "const TableName = \"training_certifications\""
      },
      {
        "code_key": "MaxQueryLimit",
        "code_value": "const MaxQueryLimit = 100"
      },
      {
        "code_key": "DefaultLanguage",
        "code_value": "const DefaultLanguage = \"en_US\""
      }
    ]
  },
  "synthetic_if-else_orm_ManageResources": {
    "scenario": "if-else+orm",
    "code_key": "ManageResources",
    "code_value": "func (n *Notification) ManageResources(filter map[string]interface{}, page, size int) ([]types.NotificationResource, error) {\n\tresources := make([]types.NotificationResource, 0)\n\tdb := base.GetInstance().GormDB().Table(\"shipping_manifest\")\n\n\tif timezone, ok := filter[\"Timezone\"]; ok {\n\t\tdb = db.Where(\"timezone = ?\", timezone).Order(\"created_at desc\")\n\t} else if indexName, ok := filter[\"IndexName\"]; ok {\n\t\tdb = db.Where(\"index_name LIKE ?\", \"%\"+indexName.(string)+\"%\").Order(\"updated_at asc\")\n\t} else if functionName, ok := filter[\"FunctionName\"]; ok {\n\t\tdb = db.Where(\"function_name = ? AND status = ?\", functionName, \"active\").Order(\"priority desc\")\n\t} else {\n\t\tdb = db.Where(filter).Order(\"id\")\n\t}\n\n\terr := db.Scopes(PaginateDB(page, size)).Find(&resources).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn resources, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn resources, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandleShippingNotifications",
        "code_value": "func (h *NotificationHandler) HandleShippingNotifications(req *types.ShippingNotificationRequest) ([]types.NotificationResource, error) {\n\tpage, size := utils.Paginate(req.Page, req.Size)\n\tcriteria := make(map[string]interface{})\n\n\tif req.Timezone != \"\" {\n\t\tcriteria[\"Timezone\"] = req.Timezone\n\t} else if req.IndexPattern != \"\" {\n\t\tif len(req.IndexPattern) > 64 {\n\t\t\treturn nil, fmt.Errorf(\"index pattern too long\")\n\t\t}\n\t\tcriteria[\"IndexName\"] = req.IndexPattern\n\t} else if req.FunctionIdentifier != \"\" {\n\t\tcriteria[\"FunctionName\"] = req.FunctionIdentifier\n\t} else {\n\t\tcriteria[\"status\"] = \"pending\"\n\t}\n\n\tnotifier := &Notification{}\n\tresults, err := notifier.ManageResources(criteria, page, size)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to fetch notifications: %v\", err)\n\t}\n\treturn results, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "NotificationResource",
        "code_value": "type NotificationResource struct {\n\tID          int       `json:\"id\" gorm:\"column:id\"`\n\tTimezone    string    `json:\"timezone\" gorm:\"column:timezone\"`\n\tIndexName   string    `json:\"index_name\" gorm:\"column:index_name\"`\n\tFunctionName string   `json:\"function_name\" gorm:\"column:function_name\"`\n\tStatus      string    `json:\"status\" gorm:\"column:status\"`\n\tPriority    int       `json:\"priority\" gorm:\"column:priority\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt   time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "ResourceFilter",
        "code_value": "type ResourceFilter struct {\n\tTimezone    *string\n\tIndexName   *string\n\tFunctionName *string\n\tStatus      *string\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "const TableName = \"shipping_manifest\""
      },
      {
        "code_key": "ResourceStatus",
        "code_value": "const (\n\tStatusActive   = \"active\"\n\tStatusInactive = \"inactive\"\n\tStatusPending  = \"pending\"\n)"
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "PriorityLevels",
        "code_value": "var PriorityLevels = map[string]int{\n\t\"low\":    1,\n\t\"medium\": 2,\n\t\"high\":   3\n}"
      }
    ]
  },
  "synthetic_if-else_orm_MatchByPattern": {
    "scenario": "if-else+orm",
    "code_key": "MatchByPattern",
    "code_value": "func (s *Share) MatchByPattern(filterParams map[string]interface{}, limit int) ([]types.LabTestResult, error) {\n\tresults := make([]types.LabTestResult, 0)\n\tdb := base.GetInstance().GormDB().Table(\"lab_test_results\")\n\n\tif trackingId, ok := filterParams[\"TrackingId\"]; ok {\n\t\tif status, statusExists := filterParams[\"Status\"]; statusExists {\n\t\t\tdb = db.Where(\"tracking_id = ? AND status = ?\", trackingId, status)\n\t\t} else {\n\t\t\tdb = db.Where(\"tracking_id LIKE ?\", \"%\"+trackingId.(string)+\"%\")\n\t\t}\n\t} else if workAddress, ok := filterParams[\"WorkAddress\"]; ok {\n\t\tdb = db.Where(\"work_address = ?\", workAddress).Order(\"created_at DESC\")\n\t} else if fullName, ok := filterParams[\"FullName\"]; ok {\n\t\tdb = db.Where(\"full_name ILIKE ?\", \"%\"+fullName.(string)+\"%\").Limit(limit)\n\t} else {\n\t\tdb = db.Where(filterParams).Limit(limit)\n\t}\n\n\terr := db.Find(&results).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to query lab test results: %v\", err)\n\t}\n\treturn results, nil\n}",
    "sql_pattern_cnt": 3,
    "callers": [
      {
        "code_key": "HandleLabTestResults",
        "code_value": "func (h *LabTestHandler) HandleLabTestResults(req *types.LabTestRequest) ([]types.LabTestResult, error) {\n\tfilterOpts := make(map[string]interface{})\n\tif req.TrackingID != \"\" {\n\t\tfilterOpts[\"TrackingId\"] = req.TrackingID\n\t\tif req.Status != \"\" {\n\t\t\tfilterOpts[\"Status\"] = req.Status\n\t\t}\n\t} else if req.WorkAddress != \"\" {\n\t\tfilterOpts[\"WorkAddress\"] = req.WorkAddress\n\t} else if req.PatientName != \"\" {\n\t\tfilterOpts[\"FullName\"] = req.PatientName\n\t} else {\n\t\tif req.StartDate != \"\" {\n\t\t\tfilterOpts[\"created_at\"] = gorm.Expr(\"created_at >= ?\", req.StartDate)\n\t\t}\n\t}\n\n\tlabTestRepo := &Share{}\n\tresults, err := labTestRepo.MatchByPattern(filterOpts, req.Limit)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to retrieve lab test results: %v\", err)\n\t}\n\treturn results, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "LabTestResult",
        "code_value": "type LabTestResult struct {\n\tID          uint      `gorm:\"primaryKey;column:id\"`\n\tTrackingId  string    `gorm:\"column:tracking_id;index\"`\n\tFullName    string    `gorm:\"column:full_name\"`\n\tWorkAddress string    `gorm:\"column:work_address\"`\n\tStatus      string    `gorm:\"column:status\"`\n\tCreatedAt   time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt   time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "const TableName = \"lab_test_results\""
      },
      {
        "code_key": "StatusPending",
        "code_value": "const StatusPending = \"pending\""
      },
      {
        "code_key": "StatusCompleted",
        "code_value": "const StatusCompleted = \"completed\""
      },
      {
        "code_key": "LabTestRequest",
        "code_value": "type LabTestRequest struct {\n\tTrackingId  string `json:\"tracking_id\"`\n\tFullName    string `json:\"full_name\"`\n\tWorkAddress string `json:\"work_address\"`\n\tStatus      string `json:\"status\"`\n\tLimit       int    `json:\"limit\"`\n}"
      },
      {
        "code_key": "LabTestResponse",
        "code_value": "type LabTestResponse struct {\n\tResults  []LabTestResult `json:\"results\"`\n\tError    string          `json:\"error,omitempty\"`\n\tDuration string          `json:\"duration\"`\n}"
      },
      {
        "code_key": "DefaultLimit",
        "code_value": "const DefaultLimit = 100"
      }
    ]
  },
  "synthetic_if-else_orm_TrackBehavior": {
    "scenario": "if-else+orm",
    "code_key": "TrackBehavior",
    "code_value": "func (p *Patient) TrackBehavior(filterParams map[string]interface{}, limit int) ([]types.BehaviorRecord, error) {\n\tvar records []types.BehaviorRecord\n\tdb := base.GetInstance().HealthDriver().Table(\"quest_progress\")\n\n\tif sessionID, ok := filterParams[\"session_id\"]; ok {\n\t\terr := db.Where(\"session_id = ? AND volume > ?\", sessionID, 0).\n\t\t\tOrder(\"created_at desc\").\n\t\t\tLimit(limit).\n\t\t\tFind(&records).Error\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else if variableName, ok := filterParams[\"variable_name\"]; ok {\n\t\terr := db.Where(\"variable_name LIKE ? AND work_address IS NOT NULL\", \"%\"+variableName.(string)+\"%\").\n\t\t\tOrder(\"updated_at desc\").\n\t\t\tLimit(limit).\n\t\t\tFind(&records).Error\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else if timestamp, ok := filterParams[\"start_time\"]; ok {\n\t\tendTime := filterParams[\"end_time\"]\n\t\terr := db.Where(\"created_at BETWEEN ? AND ?\", timestamp, endTime).\n\t\t\tSelect(\"session_id, variable_name, COUNT(*) as volume\").\n\t\t\tGroup(\"session_id, variable_name\").\n\t\t\tLimit(limit).\n\t\t\tFind(&records).Error\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\terr := db.Where(filterParams).\n\t\t\tOrder(\"id desc\").\n\t\t\tLimit(limit).\n\t\t\tFind(&records).Error\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn records, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandleBehaviorTracking",
        "code_value": "func (s *BehaviorService) HandleBehaviorTracking(req *types.BehaviorTrackingRequest) ([]types.BehaviorRecord, error) {\n\tif req.Limit <= 0 {\n\t\treturn nil, fmt.Errorf(\"invalid limit parameter\")\n\t}\n\n\tfilterCriteria := make(map[string]interface{})\n\tif req.SessionID != \"\" {\n\t\tfilterCriteria[\"session_id\"] = req.SessionID\n\t} else if req.VariableName != \"\" {\n\t\tfilterCriteria[\"variable_name\"] = req.VariableName\n\t} else if !req.StartTime.IsZero() {\n\t\tfilterCriteria[\"start_time\"] = req.StartTime\n\t\tfilterCriteria[\"end_time\"] = req.EndTime\n\t} else {\n\t\tfilterCriteria[\"patient_id\"] = req.PatientID\n\t}\n\n\tpatientObj := &Patient{ID: req.PatientID}\n\tbehaviorRecords, err := patientObj.TrackBehavior(filterCriteria, req.Limit)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to track behavior: %v\", err)\n\t}\n\n\treturn behaviorRecords, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "BehaviorRecord",
        "code_value": "type BehaviorRecord struct {\n\tID          int       `json:\"id\" gorm:\"column:id\"`\n\tSessionID   string    `json:\"session_id\" gorm:\"column:session_id\"`\n\tVariableName string   `json:\"variable_name\" gorm:\"column:variable_name\"`\n\tVolume      int       `json:\"volume\" gorm:\"column:volume\"`\n\tWorkAddress string    `json:\"work_address\" gorm:\"column:work_address\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt   time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "BehaviorQueryParams",
        "code_value": "type BehaviorQueryParams struct {\n\tSessionID   string `json:\"session_id\"`\n\tVariableName string `json:\"variable_name\"`\n\tStartTime   time.Time `json:\"start_time\"`\n\tEndTime     time.Time `json:\"end_time\"`\n}"
      },
      {
        "code_key": "MaxQueryLimit",
        "code_value": "const MaxQueryLimit = 100"
      },
      {
        "code_key": "QuestProgressTable",
        "code_value": "const QuestProgressTable = \"quest_progress\""
      },
      {
        "code_key": "BehaviorResponse",
        "code_value": "type BehaviorResponse struct {\n\tRecords    []BehaviorRecord `json:\"records\"`\n\tTotalCount int              `json:\"total_count\"`\n\tLimit      int              `json:\"limit\"`\n}"
      }
    ]
  },
  "synthetic_if-else_orm_FetchWithFilter": {
    "scenario": "if-else+orm",
    "code_key": "FetchWithFilter",
    "code_value": "func (g *Game) FetchWithFilter(filterParams map[string]interface{}, page, limit int) ([]types.GameRecord, error) {\n\tvar records []types.GameRecord\n\tvar err error\n\n\tdb := base.GetInstance().GormDB().Table(\"training_modules\")\n\n\tif locale, ok := filterParams[\"Locale\"]; ok {\n\t\tdb = db.Where(\"locale = ?\", locale.(string))\n\t\tif balance, ok := filterParams[\"Balance\"]; ok {\n\t\t\tdb = db.Where(\"balance > ?\", balance.(float64))\n\t\t}\n\t} else if timezone, ok := filterParams[\"Timezone\"]; ok {\n\t\tdb = db.Where(\"timezone LIKE ?\", \"%\"+timezone.(string)+\"%\")\n\t} else if minScore, ok := filterParams[\"MinScore\"]; ok {\n\t\tdb = db.Where(\"score >= ?\", minScore.(int))\n\t} else {\n\t\tdb = db.Where(filterParams)\n\t}\n\n\terr = db.Scopes(PaginateDB(page, limit)).\n\t\tOrder(\"created_at DESC\").\n\t\tFind(&records).Error\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.ErrNotFound\n\t\t}\n\t\treturn nil, err\n\t}\n\n\treturn records, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandleGameRecords",
        "code_value": "func (h *GameHandler) HandleGameRecords(req *types.GameRecordsRequest) ([]types.GameRecord, error) {\n\tif req.Page <= 0 || req.Limit <= 0 {\n\t\treturn nil, errors.New(\"invalid pagination parameters\")\n\t}\n\n\tfilters := make(map[string]interface{})\n\tif req.Locale != \"\" {\n\t\tfilters[\"Locale\"] = req.Locale\n\t\tif req.Balance > 0 {\n\t\t\tfilters[\"Balance\"] = req.Balance\n\t\t}\n\t} else if req.Timezone != \"\" {\n\t\tfilters[\"Timezone\"] = req.Timezone\n\t} else if req.MinScore > 0 {\n\t\tfilters[\"MinScore\"] = req.MinScore\n\t} else {\n\t\tfilters[\"status\"] = \"active\"\n\t}\n\n\tgameService := &Game{}\n\trecords, err := gameService.FetchWithFilter(filters, req.Page, req.Limit)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to fetch game records: %v\", err)\n\t}\n\n\treturn records, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "GameRecord",
        "code_value": "type GameRecord struct {\n\tID        uint      `json:\"id\" gorm:\"primaryKey\"`\n\tLocale    string    `json:\"locale\" gorm:\"column:locale\"`\n\tBalance   float64   `json:\"balance\" gorm:\"column:balance\"`\n\tTimezone  string    `json:\"timezone\" gorm:\"column:timezone\"`\n\tScore     int       `json:\"score\" gorm:\"column:score\"`\n\tCreatedAt time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "TrainingModuleTable",
        "code_value": "const TrainingModuleTable = \"training_modules\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "ScoreThresholds",
        "code_value": "var ScoreThresholds = map[string]int{\n\t\"Beginner\": 100,\n\t\"Intermediate\": 500,\n\t\"Advanced\": 1000\n}"
      },
      {
        "code_key": "GameFilterParams",
        "code_value": "type GameFilterParams struct {\n\tLocale   *string\n\tBalance  *float64\n\tTimezone *string\n\tMinScore *int\n}"
      },
      {
        "code_key": "GameResponse",
        "code_value": "type GameResponse struct {\n\tRecords    []GameRecord `json:\"records\"`\n\tTotalCount int64       `json:\"total_count\"`\n\tPage       int         `json:\"page\"`\n\tPageSize   int         `json:\"page_size\"`\n}"
      }
    ]
  },
  "synthetic_if-else_orm_FilterByAttribute": {
    "scenario": "if-else+orm",
    "code_key": "FilterByAttribute",
    "code_value": "func (e *Employee) FilterByAttribute(filterParams map[string]interface{}, page, limit int) ([]types.EmployeeProfile, error) {\n\tprofiles := make([]types.EmployeeProfile, 0)\n\tdb := base.GetInstance().MainDB().Table(\"character_inventory\")\n\n\tif certID, ok := filterParams[\"CertificateId\"]; ok {\n\t\tdb = db.Where(\"certificate_id = ?\", certID)\n\t} else if district, ok := filterParams[\"District\"]; ok {\n\t\t// Partial match for district names\n\t\tdb = db.Where(\"district LIKE ?\", \"%\"+district.(string)+\"%\")\n\t} else if country, ok := filterParams[\"Country\"]; ok {\n\t\t// Exact match for country with additional filter\n\t\tfilter := map[string]interface{}{\n\t\t\t\"country\": country,\n\t\t\t\"status\": \"active\",\n\t\t}\n\t\tdb = db.Where(filter)\n\t} else {\n\t\t// Default case with pagination only\n\t\treturn profiles, nil\n\t}\n\n\terr := db.Scopes(PaginateDB(page, limit)).\n\t\tOrder(\"created_at DESC\").\n\t\tFind(&profiles).Error\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn profiles, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"database error: %w\", err)\n\t}\n\treturn profiles, nil\n}",
    "sql_pattern_cnt": 3,
    "callers": [
      {
        "code_key": "HandleEmployeeProfiles",
        "code_value": "func (h *EmployeeHandler) HandleEmployeeProfiles(req *types.EmployeeFilterRequest) ([]types.EmployeeProfile, error) {\n\tif req.Page <= 0 || req.Limit <= 0 {\n\t\treturn nil, fmt.Errorf(\"invalid pagination parameters\")\n\t}\n\n\tfilterCriteria := make(map[string]interface{})\n\tif req.CertificateID != \"\" {\n\t\tfilterCriteria[\"CertificateId\"] = req.CertificateID\n\t} else if req.District != \"\" {\n\t\tfilterCriteria[\"District\"] = req.District\n\t} else if req.Country != \"\" {\n\t\tfilterCriteria[\"Country\"] = req.Country\n\t}\n\n\temp := &Employee{}\n\tprofiles, err := emp.FilterByAttribute(filterCriteria, req.Page, req.Limit)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to filter employee profiles: %w\", err)\n\t}\n\n\tif len(profiles) == 0 {\n\t\treturn []types.EmployeeProfile{}, nil\n\t}\n\treturn profiles, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "EmployeeProfile",
        "code_value": "type EmployeeProfile struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tCertificateID string    `json:\"certificate_id\" gorm:\"column:certificate_id\"`\n\tDistrict      string    `json:\"district\" gorm:\"column:district\"`\n\tCountry       string    `json:\"country\" gorm:\"column:country\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "FilterPolicy",
        "code_value": "type FilterPolicy struct {\n\tCertificate string\n\tRegion      string\n\tNation      string\n}"
      },
      {
        "code_key": "InventoryTable",
        "code_value": "const InventoryTable = \"character_inventory\""
      },
      {
        "code_key": "ActiveStatus",
        "code_value": "const ActiveStatus = \"active\""
      }
    ]
  },
  "synthetic_if-else_orm_ScheduleDelivery": {
    "scenario": "if-else+orm",
    "code_key": "ScheduleDelivery",
    "code_value": "func (d *Department) ScheduleDelivery(filterParams map[string]interface{}, pageSize int) ([]types.DeliverySchedule, error) {\n\tvar schedules []types.DeliverySchedule\n\tdb := base.GetInstance().Driver().Table(\"delivery_zones\")\n\n\tif zoneID, ok := filterParams[\"zone_id\"]; ok {\n\t\tdb = db.Where(\"zone_id = ?\", zoneID)\n\t} else if priority, ok := filterParams[\"priority_level\"]; ok {\n\t\tdb = db.Where(\"priority >= ?\", priority).Order(\"priority DESC\")\n\t} else if contact, ok := filterParams[\"contact_info\"]; ok {\n\t\tdb = db.Where(\"contact_info LIKE ?\", \"%\"+contact.(string)+\"%\")\n\t} else {\n\t\tdb = db.Where(filterParams)\n\t}\n\n\terr := db.Limit(pageSize).Find(&schedules).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.RecordNotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn schedules, nil\n}",
    "sql_pattern_cnt": 3,
    "callers": [
      {
        "code_key": "HandleDeliveryScheduling",
        "code_value": "func (s *DeliveryService) HandleDeliveryScheduling(req *types.DeliveryScheduleRequest, log *logger.SvcLogger) ([]types.DeliverySchedule, error) {\n\tfilterCriteria := make(map[string]interface{})\n\n\tif req.ZoneID != \"\" {\n\t\tfilterCriteria[\"zone_id\"] = req.ZoneID\n\t} else if req.PriorityThreshold > 0 {\n\t\tfilterCriteria[\"priority_level\"] = req.PriorityThreshold\n\t} else if req.ContactQuery != \"\" {\n\t\tif len(req.ContactQuery) > 100 {\n\t\t\tlog.Warn(\"contact info query too long, truncating\")\n\t\t\treq.ContactQuery = req.ContactQuery[:100]\n\t\t}\n\t\tfilterCriteria[\"contact_info\"] = req.ContactQuery\n\t} else {\n\t\tfilterCriteria[\"status\"] = \"pending\"\n\t}\n\n\tdept := &Department{Code: req.DeptCode}\n\tmaxResults := utils.Min(req.MaxResults, 1000)\n\n\tschedules, err := dept.ScheduleDelivery(filterCriteria, maxResults)\n\tif err != nil {\n\t\tlog.Error(fmt.Sprintf(\"Delivery scheduling failed: %v\", err))\n\t\treturn nil, fmt.Errorf(\"failed to schedule deliveries: %w\", err)\n\t}\n\n\tif len(schedules) == 0 {\n\t\tlog.Info(\"No delivery schedules found matching criteria\")\n\t}\n\n\treturn schedules, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "DeliverySchedule",
        "code_value": "type DeliverySchedule struct {\n\tID           int       `json:\"id\" gorm:\"column:id\"`\n\tZoneID       int       `json:\"zone_id\" gorm:\"column:zone_id\"`\n\tPriority     int       `json:\"priority\" gorm:\"column:priority\"`\n\tContactInfo  string    `json:\"contact_info\" gorm:\"column:contact_info\"`\n\tDeliveryDate time.Time `json:\"delivery_date\" gorm:\"column:delivery_date\"`\n\tCreatedAt    time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt    time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "ShipmentStatus",
        "code_value": "const (\n\tShipmentPending    = \"PENDING\"\n\tShipmentProcessing = \"PROCESSING\"\n\tShipmentDispatched = \"DISPATCHED\"\n\tShipmentDelivered  = \"DELIVERED\"\n\tShipmentCancelled  = \"CANCELLED\"\n)"
      },
      {
        "code_key": "MarketplaceDeliveryZones",
        "code_value": "var MarketplaceDeliveryZones = map[int]string{\n\t1: \"North America\",\n\t2: \"Europe\",\n\t3: \"Asia Pacific\",\n\t4: \"Middle East\",\n\t5: \"Africa\",\n}"
      },
      {
        "code_key": "DeliveryFilter",
        "code_value": "type DeliveryFilter struct {\n\tZoneID       *int    `json:\"zone_id\"`\n\tPriority     *int    `json:\"priority\"`\n\tContactInfo  *string `json:\"contact_info\"`\n\tDeliveryDate *string `json:\"delivery_date\"`\n}"
      },
      {
        "code_key": "DeliveryZoneTable",
        "code_value": "const DeliveryZoneTable = \"delivery_zones\""
      }
    ]
  },
  "synthetic_if-else_orm_AuditChanges": {
    "scenario": "if-else+orm",
    "code_key": "AuditChanges",
    "code_value": "func (p *Project) AuditChanges(filterParams map[string]interface{}, limit int) ([]types.AuditRecord, error) {\n\tvar records []types.AuditRecord\n\tdb := base.GetInstance().MainDB().Table(\"share_activities\")\n\n\tif region, ok := filterParams[\"RegionCode\"]; ok {\n\t\tdb = db.Where(\"region_code = ? AND status = ?\", region.(string), \"pending\")\n\t} else if email, ok := filterParams[\"EmailAddress\"]; ok {\n\t\tdb = db.Where(\"initiator_email LIKE ?\", \"%\"+email.(string)+\"%\")\n\t} else if postalCode, ok := filterParams[\"PostalCode\"]; ok {\n\t\tdb = db.Where(\"postal_code IN (?) AND action_type = ?\", []string{postalCode.(string), \"backup\"}, \"modification\")\n\t} else {\n\t\tdb = db.Where(filterParams)\n\t}\n\n\terr := db.Order(\"created_at DESC\").Limit(limit).Find(&records).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to audit changes: %w\", err)\n\t}\n\n\treturn records, nil\n}",
    "sql_pattern_cnt": 3,
    "callers": [
      {
        "code_key": "HandleAuditRecords",
        "code_value": "func (s *AuditService) HandleAuditRecords(req *types.AuditRequest) ([]types.AuditRecord, error) {\n\tif req.Limit <= 0 || req.Limit > 100 {\n\t\treturn nil, fmt.Errorf(\"invalid limit value: %d\", req.Limit)\n\t}\n\n\tfilterCriteria := make(map[string]interface{})\n\tif req.SearchByRegion {\n\t\tif len(req.RegionCode) == 0 {\n\t\t\treturn nil, fmt.Errorf(\"region code required\")\n\t\t}\n\t\tfilterCriteria[\"RegionCode\"] = req.RegionCode\n\t} else if req.SearchByEmail {\n\t\tif len(req.Email) == 0 {\n\t\t\treturn nil, fmt.Errorf(\"email required\")\n\t\t}\n\t\tfilterCriteria[\"EmailAddress\"] = req.Email\n\t} else if req.SearchByPostalCode {\n\t\tif len(req.PostalCode) == 0 {\n\t\t\treturn nil, fmt.Errorf(\"postal code required\")\n\t\t}\n\t\tfilterCriteria[\"PostalCode\"] = req.PostalCode\n\t} else {\n\t\tfilterCriteria[\"status\"] = \"active\"\n\t}\n\n\tproject := &Project{}\n\tauditLogs, err := project.AuditChanges(filterCriteria, req.Limit)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to fetch audit records: %w\", err)\n\t}\n\n\treturn auditLogs, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "AuditRecord",
        "code_value": "type AuditRecord struct {\n\tID           int       `json:\"id\" gorm:\"column:id\"`\n\tRegionCode   string    `json:\"region_code\" gorm:\"column:region_code\"`\n\tEmailAddress string    `json:\"email_address\" gorm:\"column:initiator_email\"`\n\tPostalCode   string    `json:\"postal_code\" gorm:\"column:postal_code\"`\n\tActionType   string    `json:\"action_type\" gorm:\"column:action_type\"`\n\tStatus       string    `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt    time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt    time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "AuditStatus",
        "code_value": "const (\n\tAuditPending    = \"pending\"\n\tAuditApproved   = \"approved\"\n\tAuditRejected   = \"rejected\"\n\tAuditModification = \"modification\"\n)"
      },
      {
        "code_key": "AuditAction",
        "code_value": "const (\n\tActionCreate   = \"create\"\n\tActionUpdate   = \"update\"\n\tActionDelete   = \"delete\"\n\tActionBackup   = \"backup\"\n)"
      },
      {
        "code_key": "AuditFilter",
        "code_value": "type AuditFilter struct {\n\tRegionCode   string\n\tEmailAddress string\n\tPostalCode   string\n\tActionType   string\n\tStatus       string\n}"
      },
      {
        "code_key": "auditTableName",
        "code_value": "const auditTableName = \"share_activities\""
      }
    ]
  },
  "synthetic_if-else_orm_AggregateByType": {
    "scenario": "if-else+orm",
    "code_key": "AggregateByType",
    "code_value": "func (r *Ranking) AggregateByType(filterParams map[string]interface{}) ([]types.RankingResult, error) {\n\tresults := make([]types.RankingResult, 0)\n\tdb := base.GetDB().Table(\"player_profiles\")\n\n\tif category, ok := filterParams[\"category\"]; ok {\n\t\tdb = db.Where(\"category = ?\", category).\n\t\t\tOrder(\"score DESC\").\n\t\t\tSelect(\"player_id, MAX(score) as max_score\")\n\t} else if timeRange, ok := filterParams[\"time_range\"]; ok {\n\t\tdb = db.Where(\"created_at BETWEEN ? AND ?\", \n\t\t\ttimeRange.([]time.Time)[0], \n\t\t\ttimeRange.([]time.Time)[1]).\n\t\t\tGroup(\"player_id\").\n\t\t\tSelect(\"player_id, COUNT(*) as total_matches\")\n\t} else if keywords, ok := filterParams[\"keywords\"]; ok {\n\t\tdb = db.Where(\"keywords LIKE ?\", \"%\"+keywords.(string)+\"%\").\n\t\t\tOrder(\"created_at DESC\").\n\t\t\tSelect(\"DISTINCT player_id, keywords\")\n\t} else {\n\t\treturn nil, errors.New(\"invalid filter parameters\")\n\t}\n\n\tif err := db.Find(&results).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}",
    "sql_pattern_cnt": 3,
    "callers": [
      {
        "code_key": "HandlePlayerStats",
        "code_value": "func (s *StatsService) HandlePlayerStats(req *types.PlayerStatsRequest) ([]types.RankingResult, error) {\n\tif req == nil {\n\t\treturn nil, errors.New(\"nil request\")\n\t}\n\n\tfilterOpts := make(map[string]interface{})\n\n\tif req.Category != \"\" {\n\t\tfilterOpts[\"category\"] = req.Category\n\t} else if req.StartTime != nil && req.EndTime != nil {\n\t\tfilterOpts[\"time_range\"] = []time.Time{*req.StartTime, *req.EndTime}\n\t} else if req.SearchText != \"\" {\n\t\tfilterOpts[\"keywords\"] = req.SearchText\n\t} else {\n\t\treturn nil, errors.New(\"invalid filter criteria\")\n\t}\n\n\trankProcessor := &Ranking{}\n\tstats, err := rankProcessor.AggregateByType(filterOpts)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to aggregate stats: %w\", err)\n\t}\n\n\treturn stats, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "RankingResult",
        "code_value": "type RankingResult struct {\n\tPlayerID    string    `json:\"player_id\"`\n\tMaxScore    int       `json:\"max_score,omitempty\"`\n\tTotalMatches int      `json:\"total_matches,omitempty\"`\n\tKeywords     string   `json:\"keywords,omitempty\"`\n}"
      },
      {
        "code_key": "PlayerProfile",
        "code_value": "type PlayerProfile struct {\n\tID        uint      `gorm:\"primaryKey\"`\n\tPlayerID  string    `gorm:\"column:player_id;index\"`\n\tScore     int       `gorm:\"column:score\"`\n\tCategory  string    `gorm:\"column:category\"`\n\tKeywords  string    `gorm:\"column:keywords\"`\n\tCreatedAt time.Time `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "FilterParams",
        "code_value": "type FilterParams struct {\n\tCategory   string\n\tTimeRange  []time.Time\n\tKeywords   string\n}"
      },
      {
        "code_key": "TablePlayerProfiles",
        "code_value": "const TablePlayerProfiles = \"player_profiles\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "RankingCategories",
        "code_value": "var RankingCategories = []string{\"pvp\", \"pve\", \"weekly\", \"monthly\"}"
      }
    ]
  },
  "synthetic_if-else_orm_RebuildIndex": {
    "scenario": "if-else+orm",
    "code_key": "RebuildIndex",
    "code_value": "func (p *Policy) RebuildIndex(criteria map[string]interface{}, limit int) ([]types.FraudAlert, error) {\n\tvar alerts []types.FraudAlert\n\tdb := base.GetInstance().GormDB().Table(\"fraud_alerts\")\n\n\tif rating, exists := criteria[\"Rating\"]; exists {\n\t\tdb = db.Where(\"rating >= ?\", rating).Order(\"created_at DESC\")\n\t} else if category, exists := criteria[\"Category\"]; exists {\n\t\tdb = db.Where(\"category = ? AND status = 'active'\", category).Order(\"priority ASC\")\n\t} else if author, exists := criteria[\"Author\"]; exists {\n\t\tdb = db.Where(\"author LIKE ?\", \"%\"+author.(string)+\"%\").Order(\"updated_at DESC\")\n\t} else {\n\t\tdb = db.Where(\"status = 'pending'\").Order(\"id ASC\")\n\t}\n\n\tif limit > 0 {\n\t\tdb = db.Limit(limit)\n\t}\n\n\terr := db.Find(&alerts).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to rebuild index: %w\", err)\n\t}\n\n\treturn alerts, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandleFraudAlerts",
        "code_value": "func (s *FraudAlertService) HandleFraudAlerts(req *types.FraudAlertRequest) ([]types.FraudAlert, error) {\n\tif req == nil {\n\t\treturn nil, fmt.Errorf(\"invalid request: nil\")\n\t}\n\n\tfilterParams := make(map[string]interface{})\n\tvar resultLimit int\n\n\tswitch req.FilterType {\n\tcase \"rating\":\n\t\tif req.MinRating < 1 || req.MinRating > 5 {\n\t\t\treturn nil, fmt.Errorf(\"invalid rating value: must be between 1-5\")\n\t\t}\n\t\tfilterParams[\"Rating\"] = req.MinRating\n\tcase \"category\":\n\t\tif req.Category == \"\" {\n\t\t\treturn nil, fmt.Errorf(\"category cannot be empty\")\n\t\t}\n\t\tfilterParams[\"Category\"] = req.Category\n\tcase \"author\":\n\t\tif req.AuthorName == \"\" {\n\t\t\treturn nil, fmt.Errorf(\"author name cannot be empty\")\n\t\t}\n\t\tfilterParams[\"Author\"] = req.AuthorName\n\t}\n\n\tif req.MaxResults > 0 {\n\t\tresultLimit = req.MaxResults\n\t}\n\n\tpolicy := &Policy{}\n\talerts, err := policy.RebuildIndex(filterParams, resultLimit)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to fetch alerts: %w\", err)\n\t}\n\n\treturn alerts, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "FraudAlert",
        "code_value": "type FraudAlert struct {\n\tID        uint      `json:\"id\" gorm:\"primaryKey\"`\n\tRating    int       `json:\"rating\" gorm:\"column:rating\"`\n\tCategory  string    `json:\"category\" gorm:\"column:category\"`\n\tStatus    string    `json:\"status\" gorm:\"column:status\"`\n\tPriority  int       `json:\"priority\" gorm:\"column:priority\"`\n\tAuthor    string    `json:\"author\" gorm:\"column:author\"`\n\tCreatedAt time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`"
      },
      {
        "code_key": "AlertStatus",
        "code_value": "const (\n\tAlertStatusPending = \"pending\"\n\tAlertStatusActive  = \"active\"\n\tAlertStatusClosed  = \"closed\"\n)"
      },
      {
        "code_key": "Policy",
        "code_value": "type Policy struct {\n\tDB *gorm.DB `json:\"-\"`\n}"
      },
      {
        "code_key": "TableFraudAlerts",
        "code_value": "const TableFraudAlerts = \"fraud_alerts\""
      }
    ]
  },
  "synthetic_if-else_orm_SearchInventoryRecords": {
    "scenario": "if-else+orm",
    "code_key": "SearchInventoryRecords",
    "code_value": "func (i *Inventory) SearchInventoryRecords(criteria map[string]interface{}, limit int) ([]types.InventoryRecord, error) {\n\tvar records []types.InventoryRecord\n\tdb := base.GetInstance().GormDB().Table(\"inventory_claims\")\n\n\tif itemCode, ok := criteria[\"item_code\"]; ok {\n\t\tdb = db.Where(\"item_code LIKE ?\", \"%\"+itemCode.(string)+\"%\")\n\t} else if location, ok := criteria[\"location\"]; ok {\n\t\tdb = db.Where(\"location = ? AND status = ?\", location.(string), \"active\")\n\t} else if minBalance, ok := criteria[\"min_balance\"]; ok {\n\t\tdb = db.Where(\"current_balance >= ?\", minBalance.(int))\n\t\tif maxBalance, ok := criteria[\"max_balance\"]; ok {\n\t\t\tdb = db.Where(\"current_balance <= ?\", maxBalance.(int))\n\t\t}\n\t} else {\n\t\tdb = db.Where(criteria)\n\t}\n\n\terr := db.Order(\"last_updated DESC\").Limit(limit).Find(&records).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to search inventory: %w\", err)\n\t}\n\treturn records, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandleInventorySearch",
        "code_value": "func (s *InventoryService) HandleInventorySearch(filter *types.InventoryFilter) ([]types.InventoryRecord, error) {\n\tif filter == nil {\n\t\treturn nil, fmt.Errorf(\"filter parameters cannot be empty\")\n\t}\n\n\tsearchCriteria := make(map[string]interface{})\n\n\tif filter.ItemCode != \"\" {\n\t\tsearchCriteria[\"item_code\"] = filter.ItemCode\n\t} else if filter.Location != \"\" {\n\t\tsearchCriteria[\"location\"] = filter.Location\n\t} else if filter.MinBalance > 0 {\n\t\tsearchCriteria[\"min_balance\"] = filter.MinBalance\n\t\tif filter.MaxBalance > 0 {\n\t\t\tsearchCriteria[\"max_balance\"] = filter.MaxBalance\n\t\t}\n\t} else {\n\t\tsearchCriteria[\"status\"] = \"active\"\n\t}\n\n\tinventory := &Inventory{}\n\trecords, err := inventory.SearchInventoryRecords(searchCriteria, filter.Limit)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"inventory search failed: %w\", err)\n\t}\n\treturn records, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "InventoryRecord",
        "code_value": "type InventoryRecord struct {\n\tID            int       `json:\"id\" gorm:\"column:id;primaryKey\"`\n\tItemCode      string    `json:\"item_code\" gorm:\"column:item_code\"`\n\tLocation      string    `json:\"location\" gorm:\"column:location\"`\n\tCurrentBalance int       `json:\"current_balance\" gorm:\"column:current_balance\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n\tLastUpdated   time.Time `json:\"last_updated\" gorm:\"column:last_updated\"`\n}"
      },
      {
        "code_key": "InventoryQueryParams",
        "code_value": "type InventoryQueryParams struct {\n\tItemCode   *string `json:\"item_code\"`\n\tLocation   *string `json:\"location\"`\n\tMinBalance *int    `json:\"min_balance\"`\n\tMaxBalance *int    `json:\"max_balance\"`\n\tLimit      int     `json:\"limit\"`\n}"
      },
      {
        "code_key": "InventoryStatus",
        "code_value": "const (\n\tInventoryStatusActive   = \"active\"\n\tInventoryStatusInactive = \"inactive\"\n\tInventoryStatusArchived = \"archived\"\n)"
      },
      {
        "code_key": "DefaultInventoryLimit",
        "code_value": "const DefaultInventoryLimit = 100"
      },
      {
        "code_key": "InventoryTableName",
        "code_value": "const InventoryTableName = \"inventory_claims\""
      },
      {
        "code_key": "InventoryReport",
        "code_value": "type InventoryReport struct {\n\tInventoryRecord\n\tAdditionalNotes string `json:\"additional_notes\"`\n}"
      }
    ]
  },
  "synthetic_if-else_orm_MeasureEfficiency": {
    "scenario": "if-else+orm",
    "code_key": "MeasureEfficiency",
    "code_value": "func (s *Skill) MeasureEfficiency(filter map[string]interface{}) ([]types.EfficiencyMetric, error) {\n\tmetrics := make([]types.EfficiencyMetric, 0)\n\tvar err error\n\tquery := base.GetInstance().Driver().Table(\"diagnostic_results\")\n\n\tif approvalLevel, ok := filter[\"ApprovalLevel\"]; ok {\n\t\tquery = query.Where(\"approval_level = ? AND access_level >= ?\", \n\t\t\tapprovalLevel, filter[\"MinAccessLevel\"])\n\t} else if timeRange, ok := filter[\"TimeRange\"]; ok {\n\t\ttr := timeRange.(map[string]interface{})\n\t\tquery = query.Where(\"modification_date BETWEEN ? AND ?\", \n\t\t\ttr[\"Start\"], tr[\"End\"]).Order(\"efficiency_score DESC\")\n\t} else if pattern, ok := filter[\"SkillPattern\"]; ok {\n\t\tquery = query.Where(\"skill_name LIKE ?\", \"%\"+pattern.(string)+\"%\")\n\t} else {\n\t\tquery = query.Where(filter)\n\t}\n\n\terr = query.Find(&metrics).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn metrics, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to measure efficiency: %w\", err)\n\t}\n\treturn metrics, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandleAppointmentEfficiency",
        "code_value": "func (h *AppointmentHandler) HandleAppointmentEfficiency(req *types.EfficiencyRequest) ([]types.EfficiencyMetric, error) {\n\tif req == nil {\n\t\treturn nil, fmt.Errorf(\"invalid request\")\n\t}\n\n\tefficiencyFilter := make(map[string]interface{})\n\n\tswitch {\n\tcase req.ApprovalLevel > 0:\n\t\tefficiencyFilter[\"ApprovalLevel\"] = req.ApprovalLevel\n\t\tefficiencyFilter[\"MinAccessLevel\"] = 3\n\tcase !req.TimeRange.Start.IsZero() && !req.TimeRange.End.IsZero():\n\t\tefficiencyFilter[\"TimeRange\"] = map[string]interface{}{\n\t\t\t\"Start\": req.TimeRange.Start,\n\t\t\t\"End\": req.TimeRange.End,\n\t\t}\n\tcase req.SkillPattern != \"\":\n\t\tefficiencyFilter[\"SkillPattern\"] = req.SkillPattern\n\tdefault:\n\t\tefficiencyFilter[\"status\"] = \"completed\"\n\t}\n\n\tskillObj := &Skill{Code: req.SkillCode}\n\tresults, err := skillObj.MeasureEfficiency(efficiencyFilter)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to handle appointment efficiency: %w\", err)\n\t}\n\n\treturn results, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "EfficiencyMetric",
        "code_value": "type EfficiencyMetric struct {\n\tID               int       `json:\"id\" gorm:\"column:id\"`\n\tSkillName        string    `json:\"skill_name\" gorm:\"column:skill_name\"`\n\tEfficiencyScore  float64   `json:\"efficiency_score\" gorm:\"column:efficiency_score\"`\n\tApprovalLevel    int       `json:\"approval_level\" gorm:\"column:approval_level\"`\n\tAccessLevel      int       `json:\"access_level\" gorm:\"column:access_level\"`\n\tModificationDate time.Time `json:\"modification_date\" gorm:\"column:modification_date\"`\n}"
      },
      {
        "code_key": "FilterParams",
        "code_value": "type FilterParams struct {\n\tApprovalLevel  interface{} `json:\"approval_level\"`\n\tMinAccessLevel int         `json:\"min_access_level\"`\n\tTimeRange      interface{} `json:\"time_range\"`\n\tSkillPattern   string      `json:\"skill_pattern\"`\n}"
      },
      {
        "code_key": "TimeRange",
        "code_value": "type TimeRange struct {\n\tStart time.Time `json:\"start\"`\n\tEnd   time.Time `json:\"end\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "const TableName = \"diagnostic_results\""
      },
      {
        "code_key": "DefaultAccessLevel",
        "code_value": "const DefaultAccessLevel = 3"
      },
      {
        "code_key": "ScoreThreshold",
        "code_value": "const ScoreThreshold = 0.85"
      }
    ]
  },
  "synthetic_if-else_orm_SortByField": {
    "scenario": "if-else+orm",
    "code_key": "SortByField",
    "code_value": "func (a *Appointment) SortByField(filterParams map[string]interface{}, page int, size int) ([]types.HealthMetrics, error) {\n\tresults := make([]types.HealthMetrics, 0)\n\tvar err error\n\t\n\tquery := base.GetInstance().GormDB().Table(\"health_metrics\")\n\t\n\tif unitPrice, exists := filterParams[\"UnitPrice\"]; exists {\n\t\terr = query.Where(\"unit_price = ?\", unitPrice).\n\t\t\tOrder(\"sequence_number DESC\").\n\t\t\tScopes(PaginateDB(page, size)).\n\t\t\tFind(&results).Error\n\t} else if activationDate, exists := filterParams[\"ActivationDate\"]; exists {\n\t\terr = query.Where(\"activation_date > ?\", activationDate).\n\t\t\tOrder(\"unit_price ASC\").\n\t\t\tScopes(PaginateDB(page, size)).\n\t\t\tFind(&results).Error\n\t} else if sequenceNum, exists := filterParams[\"SequenceNumber\"]; exists {\n\t\terr = query.Where(\"sequence_number LIKE ?\", \"%\"+sequenceNum.(string)+\"%\").\n\t\t\tOrder(\"activation_date DESC\").\n\t\t\tScopes(PaginateDB(page, size)).\n\t\t\tFind(&results).Error\n\t} else {\n\t\terr = query.Order(\"id ASC\").\n\t\t\tScopes(PaginateDB(page, size)).\n\t\t\tFind(&results).Error\n\t}\n\t\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn results, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"database error: %v\", err)\n\t}\n\treturn results, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandleHealthMetrics",
        "code_value": "func (h *HealthHandler) HandleHealthMetrics(req *types.HealthMetricsRequest) ([]types.HealthMetrics, error) {\n\tif req.Page <= 0 || req.Size <= 0 {\n\t\treturn nil, fmt.Errorf(\"invalid pagination parameters\")\n\t}\n\t\n\tfilterCriteria := make(map[string]interface{})\n\tif req.UnitPrice > 0 {\n\t\tfilterCriteria[\"UnitPrice\"] = req.UnitPrice\n\t} else if !req.ActivationDate.IsZero() {\n\t\tfilterCriteria[\"ActivationDate\"] = req.ActivationDate\n\t} else if req.SequenceNumber != \"\" {\n\t\tfilterCriteria[\"SequenceNumber\"] = req.SequenceNumber\n\t}\n\t\n\tappt := &Appointment{}\n\tresults, err := appt.SortByField(filterCriteria, req.Page, req.Size)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to query health metrics: %v\", err)\n\t}\n\t\n\tif len(results) == 0 {\n\t\treturn nil, fmt.Errorf(\"no matching records found\")\n\t}\n\treturn results, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "HealthMetrics",
        "code_value": "type HealthMetrics struct {\n\tID             uint      `gorm:\"primaryKey;column:id\"`\n\tUnitPrice      float64   `gorm:\"column:unit_price\"`\n\tActivationDate time.Time `gorm:\"column:activation_date\"`\n\tSequenceNumber string    `gorm:\"column:sequence_number\"`\n\tCreatedAt      time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt      time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "Appointment",
        "code_value": "type Appointment struct {\n\tID        uint      `gorm:\"primaryKey;column:id\"`\n\tPatientID string    `gorm:\"column:patient_id\"`\n\tDoctorID  string    `gorm:\"column:doctor_id\"`\n\tStatus    string    `gorm:\"column:status\"`\n\tCreatedAt time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "FilterParams",
        "code_value": "type FilterParams struct {\n\tUnitPrice      *float64\n\tActivationDate *time.Time\n\tSequenceNumber *string\n}"
      },
      {
        "code_key": "TableNameHealthMetrics",
        "code_value": "const TableNameHealthMetrics = \"health_metrics\""
      },
      {
        "code_key": "TableNameAppointments",
        "code_value": "const TableNameAppointments = \"appointments\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      }
    ]
  },
  "synthetic_if-else_orm_CheckIntegrity": {
    "scenario": "if-else+orm",
    "code_key": "CheckIntegrity",
    "code_value": "func (m *Media) CheckIntegrity(filters map[string]interface{}) ([]types.SymptomRecord, error) {\n\trecords := make([]types.SymptomRecord, 0)\n\tdb := base.GetInstance().GormDB().Table(\"content_categories\")\n\t\n\tif format, ok := filters[\"Format\"]; ok {\n\t\t// Exact match for format with additional status filter\n\t\tif status, ok := filters[\"status\"]; ok {\n\t\t\tdb = db.Where(\"format = ? AND status = ?\", format, status)\n\t\t} else {\n\t\t\tdb = db.Where(\"format = ?\", format)\n\t\t}\n\t} else if connStr, ok := filters[\"ConnectionString\"]; ok {\n\t\t// Partial match for connection string\n\t\tdb = db.Where(\"connection_string LIKE ?\", \"%\"+connStr.(string)+\"%\")\n\t} else if displayName, ok := filters[\"DisplayName\"]; ok {\n\t\t// Combined condition with created_at range\n\t\tif startDate, ok := filters[\"start_date\"]; ok {\n\t\t\tdb = db.Where(\"display_name = ? AND created_at >= ?\", displayName, startDate)\n\t\t} else {\n\t\t\tdb = db.Where(\"display_name = ?\", displayName)\n\t\t}\n\t} else {\n\t\t// Default case with basic filtering\n\t\tdb = db.Where(filters)\n\t}\n\n\tif err := db.Order(\"created_at DESC\").Find(&records).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"database error: %w\", err)\n\t}\n\treturn records, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandleMediaRecords",
        "code_value": "func (s *MediaService) HandleMediaRecords(req *types.MediaQueryRequest) ([]types.SymptomRecord, error) {\n\tif req == nil {\n\t\treturn nil, fmt.Errorf(\"invalid request: nil parameter\")\n\t}\n\n\tmediaObj := &Media{}\n\tqueryFilters := make(map[string]interface{})\n\n\tswitch req.QueryType {\n\tcase \"format\":\n\t\tqueryFilters[\"Format\"] = req.Format\n\t\tif req.Status != \"\" {\n\t\t\tqueryFilters[\"status\"] = req.Status\n\t\t}\n\tcase \"connection\":\n\t\tqueryFilters[\"ConnectionString\"] = req.ConnectionStr\n\tcase \"display\":\n\t\tqueryFilters[\"DisplayName\"] = req.DisplayName\n\t\tif !req.StartDate.IsZero() {\n\t\t\tqueryFilters[\"start_date\"] = req.StartDate\n\t\t}\n\tdefault:\n\t\tif len(req.BasicFilters) > 0 {\n\t\t\tqueryFilters = req.BasicFilters\n\t\t}\n\t}\n\n\trecords, err := mediaObj.CheckIntegrity(queryFilters)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to check media integrity: %w\", err)\n\t}\n\treturn records, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "SymptomRecord",
        "code_value": "type SymptomRecord struct {\n\tID          int       `json:\"id\" gorm:\"primaryKey\"`\n\tFormat      string    `json:\"format\" gorm:\"column:format\"`\n\tStatus      string    `json:\"status\" gorm:\"column:status\"`\n\tDisplayName string    `json:\"display_name\" gorm:\"column:display_name\"`\n\tConnString  string    `json:\"connection_string\" gorm:\"column:connection_string\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "Media",
        "code_value": "type Media struct {\n\tID          uint   `gorm:\"primaryKey\"`\n\tContentType string `gorm:\"column:content_type\"`\n\tContentID   string `gorm:\"column:content_id\"`\n\tStoragePath string `gorm:\"column:storage_path\"`\n}"
      },
      {
        "code_key": "ContentCategoryTable",
        "code_value": "const ContentCategoryTable = \"content_categories\""
      },
      {
        "code_key": "MediaStatus",
        "code_value": "const (\n\tMediaStatusActive = \"active\"\n\tMediaStatusDraft = \"draft\"\n\tMediaStatusArchived = \"archived\"\n)"
      }
    ]
  },
  "synthetic_if-else_orm_UpdateEntity": {
    "scenario": "if-else+orm",
    "code_key": "UpdateEntity",
    "code_value": "func (p *Patient) UpdateEntity(filterParams map[string]interface{}, updateData map[string]interface{}) (int64, error) {\n\tvar affectedRows int64\n\tvar err error\n\n\tdb := base.GetInstance().HealthDriver().Table(\"inventory_items\")\n\n\tif netValue, ok := filterParams[\"NetValue\"]; ok {\n\t\t// Fuzzy match on NetValue and exact match on Status\n\t\terr = db.Where(\"net_value LIKE ?\", \"%\"+netValue.(string)+\"%\").\n\t\t\tWhere(\"status = ?\", filterParams[\"Status\"]).\n\t\t\tUpdates(updateData).\n\t\t\tError\n\t} else if approvalLevel, ok := filterParams[\"ApprovalLevel\"]; ok {\n\t\t// Range query on ApprovalLevel with Credits check\n\t\terr = db.Where(\"approval_level BETWEEN ? AND ?\", \n\t\t\tapprovalLevel.(int)-1, approvalLevel.(int)+1).\n\t\t\tWhere(\"credits > ?\", filterParams[\"MinCredits\"]).\n\t\t\tUpdates(updateData).\n\t\t\tError\n\t} else if department, ok := filterParams[\"Department\"]; ok {\n\t\t// Exact match on Department with date range\n\t\terr = db.Where(\"department = ?\", department).\n\t\t\tWhere(\"created_at BETWEEN ? AND ?\", \n\t\t\tfilterParams[\"StartDate\"], filterParams[\"EndDate\"]).\n\t\t\tUpdates(updateData).\n\t\t\tError\n\t} else {\n\t\t// Default update without specific filters\n\t\terr = db.Updates(updateData).Error\n\t}\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn 0, nil\n\t\t}\n\t\treturn 0, fmt.Errorf(\"failed to update entity: %v\", err)\n\t}\n\n\taffectedRows = db.RowsAffected\n\treturn affectedRows, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandlePatientUpdate",
        "code_value": "func (s *PatientService) HandlePatientUpdate(updateReq *PatientUpdateRequest) (int64, error) {\n\tif updateReq == nil {\n\t\treturn 0, fmt.Errorf(\"update request cannot be nil\")\n\t}\n\n\tfilterParams := make(map[string]interface{})\n\tupdateFields := make(map[string]interface{})\n\n\t// Build different query strategies based on input\n\tif updateReq.NetValue != \"\" {\n\t\tfilterParams[\"NetValue\"] = updateReq.NetValue\n\t\tfilterParams[\"Status\"] = updateReq.Status\n\t} else if updateReq.ApprovalLevel > 0 {\n\t\tfilterParams[\"ApprovalLevel\"] = updateReq.ApprovalLevel\n\t\tfilterParams[\"MinCredits\"] = updateReq.MinCredits\n\t} else if updateReq.Department != \"\" {\n\t\tfilterParams[\"Department\"] = updateReq.Department\n\t\tfilterParams[\"StartDate\"] = updateReq.StartDate\n\t\tfilterParams[\"EndDate\"] = updateReq.EndDate\n\t}\n\n\t// Set update fields\n\tif updateReq.Name != \"\" {\n\t\tupdateFields[\"name\"] = updateReq.Name\n\t}\n\tif updateReq.Age > 0 {\n\t\tupdateFields[\"age\"] = updateReq.Age\n\t}\n\n\tpatient := &Patient{}\n\taffected, err := patient.UpdateEntity(filterParams, updateFields)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to update patient: %v\", err)\n\t}\n\n\treturn affected, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "InventoryItem",
        "code_value": "type InventoryItem struct {\n\tID            int       `json:\"id\" gorm:\"column:id;primaryKey\"`\n\tNetValue      string    `json:\"net_value\" gorm:\"column:net_value\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n\tApprovalLevel int       `json:\"approval_level\" gorm:\"column:approval_level\"`\n\tCredits       float64   `json:\"credits\" gorm:\"column:credits\"`\n\tDepartment    string    `json:\"department\" gorm:\"column:department\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`"
      },
      {
        "code_key": "InventoryStatus",
        "code_value": "const (\n\tInventoryStatusPending  = \"pending\"\n\tInventoryStatusApproved = \"approved\"\n\tInventoryStatusRejected = \"rejected\"\n)"
      },
      {
        "code_key": "UpdateRequest",
        "code_value": "type UpdateRequest struct {\n\tFilterParams map[string]interface{} `json:\"filter_params\"`\n\tUpdateData   map[string]interface{} `json:\"update_data\"`"
      },
      {
        "code_key": "DefaultApprovalRange",
        "code_value": "const DefaultApprovalRange = 2"
      },
      {
        "code_key": "DepartmentList",
        "code_value": "var DepartmentList = []string{\"HR\", \"Finance\", \"IT\", \"Operations\"}"
      }
    ]
  },
  "synthetic_if-else_orm_ProcessPayment": {
    "scenario": "if-else+orm",
    "code_key": "ProcessPayment",
    "code_value": "func (i *Invoice) ProcessPayment(filterParams map[string]interface{}, pageSize int) ([]types.PaymentRecord, error) {\n\tpayments := make([]types.PaymentRecord, 0)\n\tdb := base.GetInstance().OrmDriver().Table(\"player_profiles\")\n\n\tif district, ok := filterParams[\"District\"]; ok {\n\t\tdb = db.Where(\"district = ?\", district)\n\t} else if apiKey, ok := filterParams[\"ApiKey\"]; ok {\n\t\tdb = db.Where(\"api_key LIKE ?\", \"%\"+apiKey.(string)+\"%\")\n\t} else if date, ok := filterParams[\"ActivationDate\"]; ok {\n\t\tdb = db.Where(\"activation_date > ?\", date)\n\t} else {\n\t\tdb = db.Where(filterParams)\n\t}\n\n\terr := db.Limit(pageSize).Find(&payments).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn payments, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to process payments: %w\", err)\n\t}\n\treturn payments, nil\n}",
    "sql_pattern_cnt": 3,
    "callers": [
      {
        "code_key": "HandlePaymentRecords",
        "code_value": "func (s *PaymentService) HandlePaymentRecords(req *types.PaymentRequest, logger *log.Logger) ([]types.PaymentRecord, error) {\n\tif req.PageSize <= 0 {\n\t\treturn nil, fmt.Errorf(\"invalid page size: %d\", req.PageSize)\n\t}\n\n\tfilters := make(map[string]interface{})\n\tif req.District != \"\" {\n\t\tfilters[\"District\"] = req.District\n\t} else if req.ApiKey != \"\" {\n\t\tfilters[\"ApiKey\"] = req.ApiKey\n\t} else if !req.SinceDate.IsZero() {\n\t\tfilters[\"ActivationDate\"] = req.SinceDate\n\t} else {\n\t\tfilters[\"status\"] = \"active\"\n\t}\n\n\tinvoice := &Invoice{}\n\trecords, err := invoice.ProcessPayment(filters, req.PageSize)\n\tif err != nil {\n\t\tlogger.Printf(\"Failed to process payments: %v\", err)\n\t\treturn nil, fmt.Errorf(\"payment processing failed: %w\", err)\n\t}\n\n\tif len(records) == 0 {\n\t\tlogger.Println(\"No payment records found\")\n\t}\n\treturn records, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "PaymentRecord",
        "code_value": "type PaymentRecord struct {\n\tID             int       `json:\"id\" gorm:\"column:id;primaryKey\"`\n\tTransactionID  string    `json:\"transaction_id\" gorm:\"column:transaction_id\"`\n\tAmount         float64   `json:\"amount\" gorm:\"column:amount\"`\n\tDistrict       string    `json:\"district\" gorm:\"column:district\"`\n\tApiKey         string    `json:\"api_key\" gorm:\"column:api_key\"`\n\tActivationDate time.Time `json:\"activation_date\" gorm:\"column:activation_date\"`\n\tCreatedAt      time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt      time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "Invoice",
        "code_value": "type Invoice struct {\n\tID          int       `json:\"id\" gorm:\"column:id;primaryKey\"`\n\tInvoiceNo   string    `json:\"invoice_no\" gorm:\"column:invoice_no\"`\n\tStatus      string    `json:\"status\" gorm:\"column:status\"`\n\tTotalAmount float64   `json:\"total_amount\" gorm:\"column:total_amount\"`\n\tDueDate     time.Time `json:\"due_date\" gorm:\"column:due_date\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "PaymentStatus",
        "code_value": "const (\n\tPaymentPending   = \"PENDING\"\n\tPaymentCompleted = \"COMPLETED\"\n\tPaymentFailed    = \"FAILED\"\n\tPaymentRefunded  = \"REFUNDED\"\n)"
      },
      {
        "code_key": "TableNames",
        "code_value": "const (\n\tPlayerProfilesTable = \"player_profiles\"\n\tPaymentsTable       = \"payment_records\"\n\tInvoicesTable       = \"invoices\"\n)"
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 50"
      }
    ]
  },
  "synthetic_if-else_orm_LoadByType": {
    "scenario": "if-else+orm",
    "code_key": "LoadByType",
    "code_value": "func (l *Label) LoadByType(filter map[string]interface{}, page, size int) ([]types.ContentLabel, error) {\n\tlabels := make([]types.ContentLabel, 0)\n\tdb := base.GetInstance().MainDB().Table(\"content_reports\")\n\n\tif contentType, ok := filter[\"content_type\"]; ok {\n\t\tdb = db.Where(\"content_type = ?\", contentType).Order(\"created_at desc\")\n\t} else if title, ok := filter[\"title\"]; ok {\n\t\tdb = db.Where(\"title like ?\", \"%\"+title.(string)+\"%\").Order(\"title asc\")\n\t} else if activeOnly, ok := filter[\"active_only\"]; ok && activeOnly.(bool) {\n\t\tdb = db.Where(\"status = ?\", \"active\").Order(\"updated_at desc\")\n\t} else {\n\t\tdb = db.Where(filter).Order(\"id\")\n\t}\n\n\terr := db.Scopes(PaginateDB(page, size)).Find(&labels).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to load labels: %w\", err)\n\t}\n\treturn labels, nil\n}",
    "sql_pattern_cnt": 3,
    "callers": [
      {
        "code_key": "HandleArmor",
        "code_value": "func (a *Armor) HandleArmor(req *types.ArmorRequest, log *logger.BattleLog) ([]types.ContentLabel, error) {\n\tpageReq := req.Pagination\n\tpage, size := model.GetPagination(&pageReq)\n\tcriteria := make(map[string]interface{})\n\n\tif len(req.ArmorType) > 0 {\n\t\tcriteria[\"content_type\"] = req.ArmorType\n\t} else if len(req.Description) > 0 {\n\t\tcriteria[\"title\"] = req.Description\n\t} else if req.ActiveOnly {\n\t\tcriteria[\"active_only\"] = true\n\t}\n\n\tarmorObj := &Label{Code: model.NewCode(req.RequestID, model.HandleArmorFlow)}\n\tresults, err := armorObj.LoadByType(criteria, page, size)\n\tif err != nil {\n\t\tlog.Error(fmt.Sprintf(\"[HandleArmor] LoadByType failed: %v\", err), utils.DatabaseError)\n\t\treturn nil, err\n\t}\n\n\tif len(results) == 0 {\n\t\tlog.Info(\"[HandleArmor] No armor records found\")\n\t\treturn nil, nil\n\t}\n\n\treturn results, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "ContentLabel",
        "code_value": "type ContentLabel struct {\n\tID          int       `gorm:\"column:id;primaryKey\"`\n\tContentType string    `gorm:\"column:content_type\"`\n\tTitle       string    `gorm:\"column:title\"`\n\tStatus      string    `gorm:\"column:status\"`\n\tCreatedAt   time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt   time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "LabelFilter",
        "code_value": "type LabelFilter struct {\n\tContentType string\n\tTitle       string\n\tActiveOnly  bool\n}"
      },
      {
        "code_key": "TableNameConstants",
        "code_value": "const (\n\tLabelsTable = \"content_labels\"\n\tReportsTable = \"content_reports\"\n)"
      },
      {
        "code_key": "LabelStatus",
        "code_value": "const (\n\tLabelStatusActive = \"active\"\n\tLabelStatusInactive = \"inactive\"\n\tLabelStatusPending = \"pending\"\n)"
      },
      {
        "code_key": "ContentTypes",
        "code_value": "var ContentTypes = []string{\n\t\"article\",\n\t\"video\",\n\t\"image\",\n\t\"audio\",\n}"
      }
    ]
  },
  "synthetic_if-else_orm_SearchDoctorByConditions": {
    "scenario": "if-else+orm",
    "code_key": "SearchDoctorByConditions",
    "code_value": "func (d *Doctor) SearchDoctorByConditions(params map[string]interface{}, limit int) ([]types.DoctorProfile, error) {\n\tvar profiles []types.DoctorProfile\n\tquery := base.GetInstance().ClinicDB().Table(\"player_rankings\").Select(\"*\")\n\n\tif specialization, ok := params[\"specialization\"]; ok {\n\t\tquery = query.Where(\"specialization = ?\", specialization)\n\t} else if phone, ok := params[\"phone_number\"]; ok {\n\t\tquery = query.Where(\"phone_number LIKE ?\", \"%\"+phone.(string)+\"%\")\n\t} else if zone, ok := params[\"zone\"]; ok {\n\t\tquery = query.Where(\"zone = ? AND is_active = true\", zone)\n\t} else {\n\t\tquery = query.Where(\"rating > 4.5\").Order(\"creation_time DESC\")\n\t}\n\n\tif limit > 0 {\n\t\tquery = query.Limit(limit)\n\t}\n\n\tif err := query.Find(&profiles).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, fmt.Errorf(\"no doctors found matching criteria\")\n\t\t}\n\t\treturn nil, fmt.Errorf(\"database error: %w\", err)\n\t}\n\n\treturn profiles, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandleDoctorSearch",
        "code_value": "func HandleDoctorSearch(criteria *types.DoctorSearchCriteria) ([]types.DoctorProfile, error) {\n\tif criteria == nil {\n\t\treturn nil, fmt.Errorf(\"search criteria cannot be nil\")\n\t}\n\n\tsearchParams := make(map[string]interface{})\n\tif criteria.Specialization != \"\" {\n\t\tsearchParams[\"specialization\"] = criteria.Specialization\n\t} else if criteria.PhoneNumber != \"\" {\n\t\tsearchParams[\"phone_number\"] = criteria.PhoneNumber\n\t} else if criteria.ZoneID > 0 {\n\t\tsearchParams[\"zone\"] = criteria.ZoneID\n\t}\n\n\tdoctorDB := &Doctor{}\n\tprofiles, err := doctorDB.SearchDoctorByConditions(searchParams, criteria.Limit)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to search doctors: %w\", err)\n\t}\n\n\tif len(profiles) == 0 {\n\t\treturn nil, fmt.Errorf(\"no matching doctors found\")\n\t}\n\n\treturn profiles, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "DoctorProfile",
        "code_value": "type DoctorProfile struct {\n\tID              int       `json:\"id\" gorm:\"column:id\"`\n\tName            string    `json:\"name\" gorm:\"column:name\"`\n\tSpecialization  string    `json:\"specialization\" gorm:\"column:specialization\"`\n\tPhoneNumber     string    `json:\"phone_number\" gorm:\"column:phone_number\"`\n\tZone            string    `json:\"zone\" gorm:\"column:zone\"`\n\tRating          float64   `json:\"rating\" gorm:\"column:rating\"`\n\tIsActive        bool      `json:\"is_active\" gorm:\"column:is_active\"`\n\tCreationTime    time.Time `json:\"creation_time\" gorm:\"column:creation_time\"`\n}"
      },
      {
        "code_key": "DoctorSearchRequest",
        "code_value": "type DoctorSearchRequest struct {\n\tSpecialization string `json:\"specialization\"`\n\tPhoneNumber    string `json:\"phone_number\"`\n\tZone           string `json:\"zone\"`\n\tLimit          int    `json:\"limit\"`\n}"
      },
      {
        "code_key": "DoctorTableName",
        "code_value": "const DoctorTableName = \"player_rankings\""
      },
      {
        "code_key": "MinHighRating",
        "code_value": "const MinHighRating = 4.5"
      },
      {
        "code_key": "DefaultQueryLimit",
        "code_value": "const DefaultQueryLimit = 20"
      },
      {
        "code_key": "DoctorStatus",
        "code_value": "type DoctorStatus struct {\n\tActive   bool `json:\"active\"`\n\tVerified bool `json:\"verified\"`\n}"
      }
    ]
  },
  "synthetic_if-else_orm_FindMagazineByCriteria": {
    "scenario": "if-else+orm",
    "code_key": "FindMagazineByCriteria",
    "code_value": "func (m *Magazine) FindMagazineByCriteria(filter map[string]interface{}, page, size int) ([]types.MagazineRecord, error) {\n\tvar records []types.MagazineRecord\n\tdb := base.GetInstance().GormDB().Table(\"magazines\")\n\n\tif percentage, ok := filter[\"Percentage\"]; ok {\n\t\tdb = db.Where(\"percentage > ?\", percentage.(float64))\n\t} else if publication, ok := filter[\"Publication\"]; ok {\n\t\tdb = db.Where(\"publication_date BETWEEN ? AND ?\", \n\t\t\tpublication.(map[string]interface{})[\"start\"], \n\t\t\tpublication.(map[string]interface{})[\"end\"])\n\t} else if area, ok := filter[\"Area\"]; ok {\n\t\tdb = db.Where(\"area LIKE ?\", \"%\"+area.(string)+\"%\")\n\t} else {\n\t\tdb = db.Where(filter)\n\t}\n\n\terr := db.Scopes(PaginateDB(page, size)).\n\t\tOrder(\"created_at DESC\").\n\t\tFind(&records).Error\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandleMagazineSearch",
        "code_value": "func (s *MagazineService) HandleMagazineSearch(req *types.SearchMagazineRequest) ([]types.MagazineRecord, error) {\n\tcriteria := make(map[string]interface{})\n\t\n\tif req.PercentageThreshold > 0 {\n\t\tcriteria[\"Percentage\"] = req.PercentageThreshold\n\t} else if !req.PublicationRange.Start.IsZero() && !req.PublicationRange.End.IsZero() {\n\t\tcriteria[\"Publication\"] = map[string]interface{}{\n\t\t\t\"start\": req.PublicationRange.Start,\n\t\t\t\"end\": req.PublicationRange.End,\n\t\t}\n\t} else if req.Region != \"\" {\n\t\tcriteria[\"Area\"] = req.Region\n\t} else {\n\t\tcriteria[\"status\"] = \"active\"\n\t}\n\n\tmagazineModel := &Magazine{}\n\tresults, err := magazineModel.FindMagazineByCriteria(criteria, req.Page, req.Size)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to search magazines: %w\", err)\n\t}\n\t\n\tif len(results) == 0 {\n\t\treturn nil, nil\n\t}\n\treturn results, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "MagazineRecord",
        "code_value": "type MagazineRecord struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tTitle         string    `json:\"title\" gorm:\"column:title\"`\n\tPercentage    float64   `json:\"percentage\" gorm:\"column:percentage\"`\n\tArea          string    `json:\"area\" gorm:\"column:area\"`\n\tPublicationDate time.Time `json:\"publication_date\" gorm:\"column:publication_date\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "MagazineFilter",
        "code_value": "type MagazineFilter struct {\n\tPercentage *float64             `json:\"percentage\"`\n\tPublication *PublicationRange   `json:\"publication\"`\n\tArea      *string              `json:\"area\"`\n}"
      },
      {
        "code_key": "PublicationRange",
        "code_value": "type PublicationRange struct {\n\tStart time.Time `json:\"start\"`\n\tEnd   time.Time `json:\"end\"`\n}"
      },
      {
        "code_key": "MagazineTable",
        "code_value": "const MagazineTable = \"magazines\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "MagazineStatus",
        "code_value": "const (\n\tMagazineActive   = \"active\"\n\tMagazineArchived = \"archived\"\n\tMagazineDraft    = \"draft\"\n)"
      }
    ]
  },
  "synthetic_if-else_orm_FindVendorContracts": {
    "scenario": "if-else+orm",
    "code_key": "FindVendorContracts",
    "code_value": "func (r *Report) FindVendorContracts(filter map[string]interface{}, page, size int) ([]types.VendorContract, error) {\n\tvar contracts []types.VendorContract\n\tdb := base.GetInstance().GormDB().Table(\"vendor_management\")\n\n\tif region, ok := filter[\"Continent\"]; ok {\n\t\tdb = db.Where(\"continent = ?\", region).Order(\"EntityId desc\")\n\t} else if code, ok := filter[\"Room\"]; ok {\n\t\tdb = db.Where(\"room LIKE ?\", \"%\"+code.(string)+\"%\").Order(\"created_at asc\")\n\t} else if status, ok := filter[\"Active\"]; ok {\n\t\tdb = db.Where(\"is_active = ? AND expiration_date > NOW()\", status).Order(\"expiration_date desc\")\n\t} else {\n\t\tdb = db.Where(filter).Order(\"EntityId\")\n\t}\n\n\terr := db.Scopes(PaginateDB(page, size)).Find(&contracts).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, fmt.Errorf(\"no contracts found\")\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn contracts, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandleMediaContracts",
        "code_value": "func (m *MediaHandler) HandleMediaContracts(req *types.MediaContractRequest, log *logger.MediaLog) ([]types.VendorContract, error) {\n\tpageReq := req.Pagination\n\tpage, size := model.CalcPagination(&pageReq)\n\tfilter := make(map[string]interface{})\n\n\tif req.Region != \"\" {\n\t\tfilter[\"Continent\"] = req.Region\n\t} else if req.RoomCode != \"\" {\n\t\tif len(req.RoomCode) > 20 {\n\t\t\tlog.Error(\"RoomCode too long\")\n\t\t\treturn nil, errors.New(\"invalid room code\")\n\t\t}\n\t\tfilter[\"Room\"] = req.RoomCode\n\t} else if req.OnlyActive {\n\t\tfilter[\"Active\"] = true\n\t} else {\n\t\tfilter[\"EntityId\"] = req.EntityID\n\t}\n\n\treport := &Report{Context: m.Context}\n\tcontracts, err := report.FindVendorContracts(filter, page, size)\n\tif err != nil {\n\t\tlog.Errorf(\"Failed to find contracts: %v\", err)\n\t\treturn nil, fmt.Errorf(\"contract query failed\")\n\t}\n\treturn contracts, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "VendorContract",
        "code_value": "type VendorContract struct {\n\tEntityId        int       `json:\"entityId\" gorm:\"column:entity_id\"`\n\tVendorName      string    `json:\"vendorName\" gorm:\"column:vendor_name\"`\n\tContinent       string    `json:\"continent\" gorm:\"column:continent\"`\n\tRoom            string    `json:\"room\" gorm:\"column:room\"`\n\tIsActive        bool      `json:\"isActive\" gorm:\"column:is_active\"`\n\tExpirationDate  time.Time `json:\"expirationDate\" gorm:\"column:expiration_date\"`\n\tCreatedAt       time.Time `json:\"createdAt\" gorm:\"column:created_at\"`\n\tUpdatedAt       time.Time `json:\"updatedAt\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "ContractStatus",
        "code_value": "type ContractStatus struct {\n\tActive    string `json:\"active\"`\n\tExpired   string `json:\"expired\"`\n\tPending   string `json:\"pending\"`\n\tCancelled string `json:\"cancelled\"`\n}"
      },
      {
        "code_key": "TableNameVendorManagement",
        "code_value": "const TableNameVendorManagement = \"vendor_management\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "ContractFilter",
        "code_value": "type ContractFilter struct {\n\tContinent *string\n\tRoom      *string\n\tActive    *bool\n}"
      },
      {
        "code_key": "VendorResponse",
        "code_value": "type VendorResponse struct {\n\tSuccess   bool              `json:\"success\"`\n\tContracts []VendorContract `json:\"contracts\"`\n\tPage      int              `json:\"page\"`\n\tTotal     int64            `json:\"total\"`\n}"
      }
    ]
  },
  "synthetic_if-else_orm_PurgeExpiredRecords": {
    "scenario": "if-else+orm",
    "code_key": "PurgeExpiredRecords",
    "code_value": "func (p *Publication) PurgeExpiredRecords(criteria map[string]interface{}) (int64, error) {\n\tvar count int64\n\tvar err error\n\t\n\tif edition, ok := criteria[\"edition\"]; ok {\n\t\terr = db.Table(\"publications\").\n\t\t\tWhere(\"edition = ? AND expiration_date < NOW()\", edition).\n\t\t\tCount(&count).\n\t\t\tDelete(&Publication{}).Error\n\t} else if rating, ok := criteria[\"rating\"]; ok {\n\t\terr = db.Table(\"publications\").\n\t\t\tWhere(\"rating < ? AND expiration_date < NOW()\", rating).\n\t\t\tCount(&count).\n\t\t\tDelete(&Publication{}).Error\n\t} else if latitude, ok := criteria[\"latitude\"]; ok {\n\t\tlongitude := criteria[\"longitude\"]\n\t\terr = db.Table(\"publications\").\n\t\t\tWhere(\"latitude BETWEEN ? AND ? AND longitude BETWEEN ? AND ? AND expiration_date < NOW()\", \n\t\t\t\tlatitude.(float64)-0.5, latitude.(float64)+0.5,\n\t\t\t\tlongitude.(float64)-0.5, longitude.(float64)+0.5).\n\t\t\tCount(&count).\n\t\t\tDelete(&Publication{}).Error\n\t} else {\n\t\terr = db.Table(\"publications\").\n\t\t\tWhere(\"expiration_date < NOW()\").\n\t\t\tCount(&count).\n\t\t\tDelete(&Publication{}).Error\n\t}\n\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to purge records: %v\", err)\n\t}\n\treturn count, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandlePublicationCleanup",
        "code_value": "func (s *PublicationService) HandlePublicationCleanup(cleanupType string, value interface{}) (int64, error) {\n\tcriteria := make(map[string]interface{})\n\tswitch cleanupType {\n\tcase \"edition\":\n\t\tif edition, ok := value.(string); ok {\n\t\t\tcriteria[\"edition\"] = edition\n\t\t} else {\n\t\t\treturn 0, fmt.Errorf(\"invalid edition value type\")\n\t\t}\n\tcase \"rating\":\n\t\tif rating, ok := value.(float64); ok {\n\t\t\tcriteria[\"rating\"] = rating\n\t\t} else {\n\t\t\treturn 0, fmt.Errorf(\"invalid rating value type\")\n\t\t}\n\tcase \"location\":\n\t\tif coords, ok := value.(map[string]float64); ok {\n\t\t\tcriteria[\"latitude\"] = coords[\"latitude\"]\n\t\t\tcriteria[\"longitude\"] = coords[\"longitude\"]\n\t\t} else {\n\t\t\treturn 0, fmt.Errorf(\"invalid location coordinates\")\n\t\t}\n\tdefault:\n\t\t// No criteria, will trigger default purge\n\t}\n\n\tpub := &Publication{}\n\tdeletedCount, err := pub.PurgeExpiredRecords(criteria)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"publication cleanup failed: %v\", err)\n\t}\n\treturn deletedCount, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Publication",
        "code_value": "type Publication struct {\n\tID            uint      `gorm:\"primaryKey\"`\n\tTitle         string    `gorm:\"column:title\"`\n\tEdition       string    `gorm:\"column:edition\"`\n\tRating        float64   `gorm:\"column:rating\"`\n\tLatitude      float64   `gorm:\"column:latitude\"`\n\tLongitude     float64   `gorm:\"column:longitude\"`\n\tExpirationDate time.Time `gorm:\"column:expiration_date\"`\n\tCreatedAt     time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "PurgeCriteria",
        "code_value": "type PurgeCriteria struct {\n\tEdition   string\n\tRating    float64\n\tLatitude  float64\n\tLongitude float64\n}"
      },
      {
        "code_key": "PublicationTable",
        "code_value": "const PublicationTable = \"publications\""
      },
      {
        "code_key": "DefaultRadius",
        "code_value": "const DefaultRadius = 0.5"
      },
      {
        "code_key": "MaxBatchSize",
        "code_value": "var MaxBatchSize = 1000"
      }
    ]
  },
  "synthetic_if-else_orm_ForecastDemand": {
    "scenario": "if-else+orm",
    "code_key": "ForecastDemand",
    "code_value": "func (b *Book) ForecastDemand(filterParams map[string]interface{}) ([]types.InventoryProjection, error) {\n\tvar projections []types.InventoryProjection\n\tvar err error\n\n\tquery := base.GetInstance().MainDriver().Table(\"warehouse_locations\").Order(\"registration_time DESC\")\n\n\tif locationCode, ok := filterParams[\"location_code\"]; ok {\n\t\tquery = query.Where(\"location_code = ?\", locationCode.(string))\n\t} else if parameterName, ok := filterParams[\"parameter_name\"]; ok {\n\t\tquery = query.Where(\"parameter_name LIKE ?\", \"%\"+parameterName.(string)+\"%\")\n\t} else if configKey, ok := filterParams[\"configuration_key\"]; ok {\n\t\tquery = query.Where(\"configuration_key IN (?)\", configKey.([]string))\n\t} else {\n\t\treturn nil, errors.New(\"invalid filter parameters provided\")\n\t}\n\n\terr = query.Find(&projections).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"database error: %w\", err)\n\t}\n\n\treturn projections, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleInventoryProjection",
        "code_value": "func (h *InventoryHandler) HandleInventoryProjection(req *types.InventoryProjectionRequest) ([]types.InventoryProjection, error) {\n\tbook := &Book{}\n\tfilters := make(map[string]interface{})\n\n\tswitch req.FilterType {\n\tcase \"location\":\n\t\tif req.LocationCode == \"\" {\n\t\t\treturn nil, errors.New(\"location code cannot be empty\")\n\t\t}\n\t\tfilters[\"location_code\"] = req.LocationCode\n\tcase \"parameter\":\n\t\tif req.ParameterName == \"\" {\n\t\t\treturn nil, errors.New(\"parameter name cannot be empty\")\n\t\t}\n\t\tfilters[\"parameter_name\"] = req.ParameterName\n\tcase \"config\":\n\t\tif len(req.ConfigKeys) == 0 {\n\t\t\treturn nil, errors.New(\"config keys cannot be empty\")\n\t\t}\n\t\tfilters[\"configuration_key\"] = req.ConfigKeys\n\tdefault:\n\t\treturn nil, errors.New(\"invalid filter type\")\n\t}\n\n\tresults, err := book.ForecastDemand(filters)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to forecast demand: %w\", err)\n\t}\n\treturn results, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "InventoryProjection",
        "code_value": "type InventoryProjection struct {\n\tID               int       `json:\"id\" gorm:\"column:id\"`\n\tLocationCode     string    `json:\"location_code\" gorm:\"column:location_code\"`\n\tParameterName    string    `json:\"parameter_name\" gorm:\"column:parameter_name\"`\n\tConfigurationKey string    `json:\"configuration_key\" gorm:\"column:configuration_key\"`\n\tProjectedValue   float64   `json:\"projected_value\" gorm:\"column:projected_value\"`\n\tRegistrationTime time.Time `json:\"registration_time\" gorm:\"column:registration_time\"`\n}"
      },
      {
        "code_key": "FilterParams",
        "code_value": "type FilterParams struct {\n\tLocationCode     string\n\tParameterName    string\n\tConfigurationKey []string\n}"
      },
      {
        "code_key": "WarehouseTable",
        "code_value": "const WarehouseTable = \"warehouse_locations\""
      },
      {
        "code_key": "DefaultSortField",
        "code_value": "const DefaultSortField = \"registration_time DESC\""
      },
      {
        "code_key": "ErrInvalidFilter",
        "code_value": "var ErrInvalidFilter = errors.New(\"invalid filter parameters provided\")"
      },
      {
        "code_key": "ProjectionFields",
        "code_value": "var ProjectionFields = []string{\"id\", \"location_code\", \"parameter_name\", \"configuration_key\", \"projected_value\", \"registration_time\"}"
      }
    ]
  },
  "synthetic_if-else_orm_CalculateDiscount": {
    "scenario": "if-else+orm",
    "code_key": "CalculateDiscount",
    "code_value": "func (p *Proposal) CalculateDiscount(filter map[string]interface{}) ([]types.DiscountRate, error) {\n\trates := make([]types.DiscountRate, 0)\n\tvar err error\n\tdb := base.GetInstance().GormDB().Table(\"expense_reports\")\n\n\tif minBalance, ok := filter[\"min_balance\"]; ok {\n\t\terr = db.Where(\"balance >= ? AND access_level IN ?\", \n\t\t\tminBalance, []int{2, 3}).Order(\"case_number desc\").Find(&rates).Error\n\t} else if maxDuration, ok := filter[\"max_duration\"]; ok {\n\t\terr = db.Where(\"duration_days <= ? AND status = ?\", \n\t\t\tmaxDuration, \"active\").Order(\"balance asc\").Find(&rates).Error\n\t} else if searchTerm, ok := filter[\"search_term\"]; ok {\n\t\terr = db.Where(\"notes LIKE ?\", \"%\"+searchTerm.(string)+\"%\")\n\t\t\t.Limit(50).Find(&rates).Error\n\t} else {\n\t\terr = db.Where(filter).Find(&rates).Error\n\t}\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn rates, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn rates, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandleDiscountCalculation",
        "code_value": "func (s *DiscountService) HandleDiscountCalculation(request *types.DiscountRequest, log *logger.AppLog) ([]types.DiscountRate, error) {\n\tif request == nil {\n\t\tlog.Error(\"nil request parameter\")\n\t\treturn nil, errors.New(\"invalid request\")\n\t}\n\n\tfilterParams := make(map[string]interface{})\n\tif request.MinBalanceThreshold > 0 {\n\t\tfilterParams[\"min_balance\"] = request.MinBalanceThreshold\n\t} else if request.MaxDurationDays > 0 {\n\t\tfilterParams[\"max_duration\"] = request.MaxDurationDays\n\t} else if len(request.SearchKeyword) > 0 {\n\t\tfilterParams[\"search_term\"] = request.SearchKeyword\n\t} else {\n\t\tfilterParams[\"status\"] = \"pending\"\n\t}\n\n\tproposal := &Proposal{ClientID: request.ClientID}\n\tdiscountRates, err := proposal.CalculateDiscount(filterParams)\n\tif err != nil {\n\t\tlog.Errorf(\"failed to calculate discounts: %v\", err)\n\t\treturn nil, fmt.Errorf(\"calculation error: %w\", err)\n\t}\n\n\tif len(discountRates) == 0 {\n\t\tlog.Warn(\"no discount rates found for given criteria\")\n\t}\n\treturn discountRates, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "DiscountRate",
        "code_value": "type DiscountRate struct {\n\tID          int     `json:\"id\" gorm:\"column:id\"`\n\tCaseNumber  string  `json:\"case_number\" gorm:\"column:case_number\"`\n\tBalance     float64 `json:\"balance\" gorm:\"column:balance\"`\n\tDurationDays int     `json:\"duration_days\" gorm:\"column:duration_days\"`\n\tAccessLevel int     `json:\"access_level\" gorm:\"column:access_level\"`\n\tStatus      string  `json:\"status\" gorm:\"column:status\"`\n\tNotes       string  `json:\"notes\" gorm:\"column:notes\"`\n\tRateValue   float64 `json:\"rate_value\" gorm:\"column:rate_value\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt   time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "Proposal",
        "code_value": "type Proposal struct {\n\tID          int       `json:\"id\" gorm:\"column:id\"`\n\tTitle       string    `json:\"title\" gorm:\"column:title\"`\n\tDescription string    `json:\"description\" gorm:\"column:description\"`\n\tBudget      float64   `json:\"budget\" gorm:\"column:budget\"`\n\tStatus      string    `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt   time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "ExpenseReportStatus",
        "code_value": "const (\n\tExpenseReportStatusDraft    = \"draft\"\n\tExpenseReportStatusActive   = \"active\"\n\tExpenseReportStatusApproved = \"approved\"\n\tExpenseReportStatusRejected = \"rejected\"\n)"
      },
      {
        "code_key": "AccessLevels",
        "code_value": "var AccessLevels = map[int]string{\n\t1: \"viewer\",\n\t2: \"editor\",\n\t3: \"admin\"\n}"
      },
      {
        "code_key": "DiscountThresholds",
        "code_value": "type DiscountThresholds struct {\n\tMinBalance   float64 `json:\"min_balance\"`\n\tMaxDuration  int     `json:\"max_duration\"`\n\tSearchTerm   string  `json:\"search_term\"`\n\tAccessLevels []int   `json:\"access_levels\"`\n}"
      }
    ]
  },
  "synthetic_if-else_orm_FindByExamZone": {
    "scenario": "if-else+orm",
    "code_key": "FindByExamZone",
    "code_value": "func (d *Doctor) FindByExamZone(filter map[string]interface{}, page, size int) ([]types.ExamResult, error) {\n\tresults := make([]types.ExamResult, 0)\n\tdb := base.GetInstance().ClinicDB().Table(\"exam_results\")\n\n\tif zone, ok := filter[\"Zone\"]; ok {\n\t\tif status, ok := filter[\"Status\"]; ok {\n\t\t\tdb = db.Where(\"zone = ? AND status = ?\", zone.(string), status.(string))\n\t\t} else {\n\t\t\tdb = db.Where(\"zone LIKE ?\", \"%\"+zone.(string)+\"%\")\n\t\t}\n\t} else if room, ok := filter[\"Room\"]; ok {\n\t\tdb = db.Where(\"room = ?\", room.(string)).Order(\"created_at DESC\")\n\t} else if middleName, ok := filter[\"MiddleName\"]; ok {\n\t\tdb = db.Where(\"middle_name LIKE ?\", \"%\"+middleName.(string)+\"%\").Limit(50)\n\t} else {\n\t\tdb = db.Where(filter)\n\t}\n\n\terr := db.Scopes(PaginateDB(page, size)).Find(&results).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn results, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandleExamResults",
        "code_value": "func (h *ExamHandler) HandleExamResults(req *types.ExamQueryRequest) ([]types.ExamResult, error) {\n\tif req.Page <= 0 || req.Size <= 0 {\n\t\treturn nil, fmt.Errorf(\"invalid pagination parameters\")\n\t}\n\n\tcriteria := make(map[string]interface{})\n\tdoc := &Doctor{}\n\n\tif req.ZoneCode != \"\" {\n\t\tcriteria[\"Zone\"] = req.ZoneCode\n\t\tif req.StatusFilter != \"\" {\n\t\t\tcriteria[\"Status\"] = req.StatusFilter\n\t\t}\n\t} else if req.RoomNumber != \"\" {\n\t\tcriteria[\"Room\"] = req.RoomNumber\n\t} else if req.SearchName != \"\" {\n\t\tif len(req.SearchName) > 50 {\n\t\t\treturn nil, fmt.Errorf(\"name too long\")\n\t\t}\n\t\tcriteria[\"MiddleName\"] = req.SearchName\n\t}\n\n\texamData, err := doc.FindByExamZone(criteria, req.Page, req.Size)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"query failed: %v\", err)\n\t}\n\treturn examData, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "ExamResult",
        "code_value": "type ExamResult struct {\n\tID          uint      `gorm:\"column:id;primaryKey\"`\n\tZone        string    `gorm:\"column:zone\"`\n\tRoom        string    `gorm:\"column:room\"`\n\tMiddleName  string    `gorm:\"column:middle_name\"`\n\tStatus      string    `gorm:\"column:status\"`\n\tCreatedAt   time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt   time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "ExamResponse",
        "code_value": "type ExamResponse struct {\n\tResults     []ExamResult `json:\"results\"`\n\tTotalCount  int          `json:\"total_count\"`\n\tCurrentPage int          `json:\"current_page\"`\n\tPageSize    int          `json:\"page_size\"`\n}"
      },
      {
        "code_key": "ExamFilter",
        "code_value": "type ExamFilter struct {\n\tZone       string \n\tRoom       string \n\tMiddleName string \n\tStatus     string \n}"
      },
      {
        "code_key": "ExamStatus",
        "code_value": "const (\n\tExamStatusPending   = \"pending\"\n\tExamStatusInProgress = \"in_progress\"\n\tExamStatusCompleted = \"completed\"\n)"
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "ResultTable",
        "code_value": "const ResultTable = \"exam_results\""
      }
    ]
  },
  "synthetic_if-else_orm_ListWithPaging": {
    "scenario": "if-else+orm",
    "code_key": "ListWithPaging",
    "code_value": "func (g *Guild) ListWithPaging(filter map[string]interface{}, page, size int) ([]types.GuildMember, error) {\n\tmembers := make([]types.GuildMember, 0)\n\tdb := base.GetInstance().GuildDriver().Table(\"skill_trees\")\n\n\tif role, ok := filter[\"role\"]; ok {\n\t\tif role == \"admin\" {\n\t\t\tdb = db.Where(\"role = ?\", role).Order(\"join_date desc\")\n\t\t} else {\n\t\t\tdb = db.Where(\"role IN (?, ?)\", \"member\", \"moderator\")\n\t\t}\n\t} else if mobile, ok := filter[\"mobile\"]; ok {\n\t\tdb = db.Where(\"mobile_number LIKE ?\", \"%\"+mobile.(string)+\"%\")\n\t} else if location, ok := filter[\"location\"]; ok {\n\t\tloc := location.(map[string]float64)\n\t\tdb = db.Where(\"longitude BETWEEN ? AND ?\", loc[\"min\"], loc[\"max\"])\n\t} else {\n\t\tdb = db.Where(filter)\n\t}\n\n\terr := db.Scopes(PaginateDB(page, size)).Find(&members).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn members, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to list guild members: %w\", err)\n\t}\n\treturn members, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandleGuildMemberQuery",
        "code_value": "func (h *GuildHandler) HandleGuildMemberQuery(req *types.GuildMemberQueryRequest) ([]types.GuildMember, error) {\n\tif req.Page <= 0 || req.Size <= 0 {\n\t\treturn nil, fmt.Errorf(\"invalid pagination parameters\")\n\t}\n\n\tfilter := make(map[string]interface{})\n\tif req.Role != \"\" {\n\t\tfilter[\"role\"] = req.Role\n\t} else if req.MobileNumber != \"\" {\n\t\tfilter[\"mobile\"] = req.MobileNumber\n\t} else if req.LocationRange != nil {\n\t\tfilter[\"location\"] = map[string]float64{\n\t\t\t\"min\": req.LocationRange.MinLongitude,\n\t\t\t\"max\": req.LocationRange.MaxLongitude,\n\t\t}\n\t}\n\n\tguild := &Guild{}\n\tmembers, err := guild.ListWithPaging(filter, req.Page, req.Size)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to query guild members: %w\", err)\n\t}\n\treturn members, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "GuildMember",
        "code_value": "type GuildMember struct {\n\tID          uint      `json:\"id\" gorm:\"column:id\"`\n\tName        string    `json:\"name\" gorm:\"column:name\"`\n\tRole        string    `json:\"role\" gorm:\"column:role\"`\n\tMobileNumber string   `json:\"mobile_number\" gorm:\"column:mobile_number\"`\n\tLongitude   float64   `json:\"longitude\" gorm:\"column:longitude\"`\n\tLatitude    float64   `json:\"latitude\" gorm:\"column:latitude\"`\n\tJoinDate    time.Time `json:\"join_date\" gorm:\"column:join_date\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "const TableName = \"skill_trees\""
      },
      {
        "code_key": "MemberRoles",
        "code_value": "var MemberRoles = []string{\"member\", \"moderator\", \"admin\"}"
      },
      {
        "code_key": "LocationRange",
        "code_value": "type LocationRange struct {\n\tMin float64 `json:\"min\"`\n\tMax float64 `json:\"max\"`\n}"
      },
      {
        "code_key": "MemberFilter",
        "code_value": "type MemberFilter struct {\n\tRole     string        `json:\"role\"`\n\tMobile   string        `json:\"mobile\"`\n\tLocation LocationRange `json:\"location\"`\n}"
      }
    ]
  },
  "synthetic_if-else_orm_DetectFraud": {
    "scenario": "if-else+orm",
    "code_key": "DetectFraud",
    "code_value": "func (v *Vendor) DetectFraud(filter map[string]interface{}) ([]types.FraudReport, error) {\n\treports := make([]types.FraudReport, 0)\n\tdb := base.GetInstance().GormDB().Table(\"content_reports\")\n\n\tif location, ok := filter[\"LocationCode\"]; ok {\n\t\tdb = db.Where(\"location_code = ? AND status = ?\", location.(string), \"pending\")\n\t} else if deadline, ok := filter[\"DeadlineDate\"]; ok {\n\t\tdb = db.Where(\"deadline_date < ? AND severity > ?\", deadline.(string), 5)\n\t} else if invoice, ok := filter[\"InvoiceNumber\"]; ok {\n\t\tdb = db.Where(\"invoice_number LIKE ?\", \"%\"+invoice.(string)+\"%\")\n\t} else {\n\t\tdb = db.Where(\"priority = ?\", 1)\n\t}\n\n\tif err := db.Order(\"created_at DESC\").Find(&reports).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn reports, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandleFraudDetection",
        "code_value": "func (s *FraudService) HandleFraudDetection(criteria *types.FraudCriteria) ([]types.FraudReport, error) {\n\tif criteria == nil {\n\t\treturn nil, errors.New(\"invalid criteria\")\n\t}\n\n\tfilterParams := make(map[string]interface{})\n\n\tif criteria.Region != \"\" {\n\t\tfilterParams[\"LocationCode\"] = criteria.Region\n\t} else if !criteria.ExpiryDate.IsZero() {\n\t\tfilterParams[\"DeadlineDate\"] = criteria.ExpiryDate.Format(\"2006-01-02\")\n\t} else if criteria.InvoiceRef != \"\" {\n\t\tif len(criteria.InvoiceRef) < 3 {\n\t\t\treturn nil, errors.New(\"invoice reference too short\")\n\t\t}\n\t\tfilterParams[\"InvoiceNumber\"] = criteria.InvoiceRef\n\t}\n\n\tvendor := &Vendor{}\n\treports, err := vendor.DetectFraud(filterParams)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"fraud detection failed: %w\", err)\n\t}\n\n\tif len(reports) == 0 {\n\t\treturn nil, nil\n\t}\n\treturn reports, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "FraudReport",
        "code_value": "type FraudReport struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tLocationCode  string    `json:\"location_code\" gorm:\"column:location_code\"`\n\tInvoiceNumber string    `json:\"invoice_number\" gorm:\"column:invoice_number\"`\n\tDeadlineDate  time.Time `json:\"deadline_date\" gorm:\"column:deadline_date\"`\n\tSeverity      int       `json:\"severity\" gorm:\"column:severity\"`\n\tPriority      int       `json:\"priority\" gorm:\"column:priority\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "ReportStatus",
        "code_value": "const (\n\tReportStatusPending  = \"pending\"\n\tReportStatusResolved = \"resolved\"\n\tReportStatusRejected = \"rejected\"\n)"
      },
      {
        "code_key": "FraudFilter",
        "code_value": "type FraudFilter struct {\n\tLocationCode string    `json:\"LocationCode\"`\n\tDeadlineDate time.Time `json:\"DeadlineDate\"`\n\tInvoiceNumber string   `json:\"InvoiceNumber\"`\n}"
      },
      {
        "code_key": "ContentReportTable",
        "code_value": "const ContentReportTable = \"content_reports\""
      },
      {
        "code_key": "SeverityThreshold",
        "code_value": "const SeverityThreshold = 5"
      }
    ]
  },
  "synthetic_if-else_orm_AnalyzePerformance": {
    "scenario": "if-else+orm",
    "code_key": "AnalyzePerformance",
    "code_value": "func (s *Semester) AnalyzePerformance(criteria map[string]interface{}, page, size int) ([]types.GradeRecord, error) {\n\tgr := make([]types.GradeRecord, 0)\n\tvar err error\n\n\tdb := base.GetInstance().GormDriver().Table(\"grade_records\")\n\t\n\tif course, ok := criteria[\"course_title\"]; ok {\n\t\tdb = db.Where(\"course_title LIKE ?\", \"%\"+course.(string)+\"%\")\n\t} else if score, ok := criteria[\"min_score\"]; ok {\n\t\tif maxScore, ok := criteria[\"max_score\"]; ok {\n\t\t\tdb = db.Where(\"score BETWEEN ? AND ?\", score, maxScore)\n\t\t} else {\n\t\t\tdb = db.Where(\"score >= ?\", score)\n\t\t}\n\t} else if department, ok := criteria[\"department_id\"]; ok {\n\t\tdb = db.Joins(\"JOIN department_structure ON grade_records.student_id = department_structure.student_id\")\n\t\t\t.Where(\"department_structure.department_id = ?\", department)\n\t} else {\n\t\tdb = db.Where(criteria)\n\t}\n\n\terr = db.Scopes(PaginateDB(page, size)).Order(\"student_id\").Find(&gr).Error\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn gr, utils.RecordNotFoundError\n\t\t}\n\t\treturn gr, err\n\t}\n\treturn gr, nil\n}",
    "sql_pattern_cnt": 3,
    "callers": [
      {
        "code_key": "HandleStudentPerformance",
        "code_value": "func (h *StudentHandler) HandleStudentPerformance(req *types.PerformanceRequest, log *logger.AcademicLog) ([]types.GradeRecord, error) {\n\tif req.Page <= 0 || req.Size <= 0 {\n\t\treturn nil, utils.NewError(\"invalid pagination parameters\")\n\t}\n\n\tfilterCriteria := make(map[string]interface{})\n\tif req.CourseTitle != \"\" {\n\t\tfilterCriteria[\"course_title\"] = req.CourseTitle\n\t} else if req.MinScore > 0 {\n\t\tfilterCriteria[\"min_score\"] = req.MinScore\n\t\tif req.MaxScore > req.MinScore {\n\t\t\tfilterCriteria[\"max_score\"] = req.MaxScore\n\t\t}\n\t} else if req.DepartmentID != \"\" {\n\t\tif !utils.IsValidDepartment(req.DepartmentID) {\n\t\t\treturn nil, utils.NewError(\"invalid department ID\")\n\t\t}\n\t\tfilterCriteria[\"department_id\"] = req.DepartmentID\n\t} else {\n\t\tfilterCriteria[\"semester_id\"] = req.SemesterID\n\t}\n\n\tcurrentSemester := &models.Semester{ID: req.SemesterID}\n\tresults, err := currentSemester.AnalyzePerformance(filterCriteria, req.Page, req.Size)\n\tif err != nil {\n\t\tlog.Error(\"failed to analyze performance\", zap.Error(err))\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "GradeRecord",
        "code_value": "type GradeRecord struct {\n\tID         int     `json:\"id\" gorm:\"column:id;primaryKey\"`\n\tStudentID  string  `json:\"student_id\" gorm:\"column:student_id\"`\n\tCourseTitle string `json:\"course_title\" gorm:\"column:course_title\"`\n\tScore      float64 `json:\"score\" gorm:\"column:score\"`\n\tSemesterID int     `json:\"semester_id\" gorm:\"column:semester_id\"`\n\tCreatedAt  int64   `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt  int64   `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "DepartmentStructure",
        "code_value": "type DepartmentStructure struct {\n\tID           int    `json:\"id\" gorm:\"column:id;primaryKey\"`\n\tStudentID    string `json:\"student_id\" gorm:\"column:student_id\"`\n\tDepartmentID int    `json:\"department_id\" gorm:\"column:department_id\"`\n\tJoinDate     int64  `json:\"join_date\" gorm:\"column:join_date\"`\n}"
      },
      {
        "code_key": "PerformanceRequest",
        "code_value": "type PerformanceRequest struct {\n\tCourseTitle string  `json:\"course_title\"`\n\tMinScore    float64 `json:\"min_score\"`\n\tMaxScore    float64 `json:\"max_score\"`\n\tDepartmentID int    `json:\"department_id\"`\n\tPage       int     `json:\"page\"`\n\tSize       int     `json:\"size\"`\n}"
      },
      {
        "code_key": "TableGradeRecords",
        "code_value": "const TableGradeRecords = \"grade_records\""
      },
      {
        "code_key": "TableDepartmentStructure",
        "code_value": "const TableDepartmentStructure = \"department_structure\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      }
    ]
  },
  "synthetic_if-else_orm_QueryByCondition": {
    "scenario": "if-else+orm",
    "code_key": "QueryByCondition",
    "code_value": "func (s *Story) QueryByCondition(filters map[string]interface{}, page, size int) ([]types.StoryRecord, error) {\n\tvar records []types.StoryRecord\n\tdb := base.GetInstance().MainDB().Table(\"author_profiles\")\n\t\n\tif subject, ok := filters[\"Subject\"].(string); ok {\n\t\tdb = db.Where(\"subject LIKE ?\", \"%\" + subject + \"%\")\n\t} else if recordId, ok := filters[\"RecordId\"].(int); ok {\n\t\tdb = db.Where(\"id = ?\", recordId)\n\t} else if location, ok := filters[\"Latitude\"].(float64); ok {\n\t\tdb = db.Where(\"ABS(latitude - ?) < 0.1\", location)\n\t} else {\n\t\tdb = db.Where(filters)\n\t}\n\n\terr := db.Scopes(Paginate(page, size)).\n\t\tOrder(\"created_at DESC\").\n\t\tFind(&records).Error\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"query failed: %w\", err)\n\t}\n\treturn records, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandleStorySearch",
        "code_value": "func (h *StoryHandler) HandleStorySearch(req *types.StorySearchRequest) ([]types.StoryRecord, error) {\n\tsearchParams := make(map[string]interface{})\n\t\n\tif req.Subject != \"\" {\n\t\tsearchParams[\"Subject\"] = req.Subject\n\t} else if req.RecordID > 0 {\n\t\tsearchParams[\"RecordId\"] = req.RecordID\n\t} else if req.Latitude != 0 {\n\t\tsearchParams[\"Latitude\"] = req.Latitude\n\t} else {\n\t\tsearchParams[\"author_id\"] = req.AuthorID\n\t}\n\n\tpage, size := h.normalizePagination(req.Page, req.Size)\n\tstory := &Story{}\n\n\tresults, err := story.QueryByCondition(searchParams, page, size)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"story search failed: %w\", err)\n\t}\n\treturn results, nil\n}\n\nfunc (h *StoryHandler) normalizePagination(page, size int) (int, int) {\n\tif page <= 0 {\n\t\tpage = 1\n\t}\n\tif size <= 0 || size > 100 {\n\t\tsize = 20\n\t}\n\treturn page, size\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "CarrierRecord",
        "code_value": "type CarrierRecord struct {\n\tID        int       `json:\"id\" gorm:\"column:id;primaryKey\"`\n\tTitle     string    `json:\"title\" gorm:\"column:title\"`\n\tBody      string    `json:\"body\" gorm:\"column:body\"`\n\tLat       float64   `json:\"lat\" gorm:\"column:latitude\"`\n\tLng       float64   `json:\"lng\" gorm:\"column:longitude\"`\n\tCreatedAt time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tStatus    int       `json:\"status\" gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "MatchFilter",
        "code_value": "type MatchFilter struct {\n\tTitle    string  `json:\"title\"`\n\tCarrierID int     `json:\"carrier_id\"`\n\tLat      float64 `json:\"lat\"`\n\tRadius   float64 `json:\"radius\"`\n}"
      },
      {
        "code_key": "TableAuthorProfiles",
        "code_value": "const TableAuthorProfiles = \"author_profiles\""
      },
      {
        "code_key": "DefaultQueryLimit",
        "code_value": "const DefaultQueryLimit = 50"
      },
      {
        "code_key": "MaxQueryLimit",
        "code_value": "const MaxQueryLimit = 200"
      },
      {
        "code_key": "QueryOrder",
        "code_value": "const (\n\tOrderNewest = \"DESC\"\n\tOrderOldest = \"ASC\"\n)"
      }
    ]
  },
  "synthetic_if-else_orm_FindByCategory": {
    "scenario": "if-else+orm",
    "code_key": "FindByCategory",
    "code_value": "func (s *Score) FindByCategory(filter map[string]interface{}, limit int) ([]types.EquipmentScore, error) {\n\tvar scores []types.EquipmentScore\n\tdb := base.GetInstance().GormDB().Table(\"market_data\")\n\t\n\tif category, ok := filter[\"category\"]; ok {\n\t\tdb = db.Where(\"category = ? AND status = ?\", category.(string), \"active\")\n\t} else if netValue, ok := filter[\"net_value\"]; ok {\n\t\tminValue := netValue.(float64) * 0.9\n\t\tmaxValue := netValue.(float64) * 1.1\n\t\tdb = db.Where(\"net_value BETWEEN ? AND ?\", minValue, maxValue)\n\t} else if timezone, ok := filter[\"timezone\"]; ok {\n\t\tdb = db.Where(\"timezone LIKE ?\", \"%\"+timezone.(string)+\"%\")\n\t} else {\n\t\treturn nil, errors.New(\"invalid filter parameters\")\n\t}\n\t\n\terr := db.Order(\"tracking_id DESC\").Limit(limit).Find(&scores).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn scores, nil\n}",
    "sql_pattern_cnt": 3,
    "callers": [
      {
        "code_key": "HandleEquipmentScores",
        "code_value": "func (h *EquipmentHandler) HandleEquipmentScores(req *types.EquipmentScoreRequest) ([]types.EquipmentScore, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.Category != \"\" {\n\t\tfilter[\"category\"] = req.Category\n\t} else if req.NetValue > 0 {\n\t\tfilter[\"net_value\"] = req.NetValue\n\t} else if req.Timezone != \"\" {\n\t\tfilter[\"timezone\"] = req.Timezone\n\t} else {\n\t\treturn nil, errors.New(\"at least one filter parameter is required\")\n\t}\n\t\n\tlimit := 20\n\tif req.Limit > 0 {\n\t\tlimit = req.Limit\n\t}\n\t\n\tscoreModel := &Score{}\n\tresult, err := scoreModel.FindByCategory(filter, limit)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to fetch equipment scores: %v\", err)\n\t}\n\t\n\treturn result, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "EquipmentScore",
        "code_value": "type EquipmentScore struct {\n\tID          uint    `gorm:\"column:id;primaryKey\"`\n\tTrackingID  string  `gorm:\"column:tracking_id\"`\n\tCategory    string  `gorm:\"column:category\"`\n\tNetValue    float64 `gorm:\"column:net_value\"`\n\tTimezone    string  `gorm:\"column:timezone\"`\n\tStatus      string  `gorm:\"column:status\"`\n\tCreatedAt   int64   `gorm:\"column:created_at\"`\n\tUpdatedAt   int64   `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "MarketDataTable",
        "code_value": "const MarketDataTable = \"market_data\""
      },
      {
        "code_key": "StatusActive",
        "code_value": "const StatusActive = \"active\""
      },
      {
        "code_key": "ScoreFilter",
        "code_value": "type ScoreFilter struct {\n\tCategory string\n\tNetValue float64\n\tTimezone string\n}"
      },
      {
        "code_key": "BaseScore",
        "code_value": "type BaseScore struct {\n\tEquipmentScore\n\t*ScoreFilter\n}"
      }
    ]
  },
  "synthetic_if-else_orm_MonitorActivity": {
    "scenario": "if-else+orm",
    "code_key": "MonitorActivity",
    "code_value": "func (e *Employee) MonitorActivity(filterParams map[string]interface{}, pageSize int) ([]types.SecurityLog, error) {\n\tlogs := make([]types.SecurityLog, 0)\n\tdb := base.GetInstance().GormDB().Table(\"dispatch_orders\")\n\n\tif ip, ok := filterParams[\"ip_address\"]; ok {\n\t\tdb = db.Where(\"ip_address LIKE ?\", \"%\"+ip.(string)+\"%\")\n\t} else if caseNum, ok := filterParams[\"case_number\"]; ok {\n\t\tdb = db.Where(\"case_number = ?\", caseNum)\n\t} else if subCat, ok := filterParams[\"sub_category\"]; ok {\n\t\tdb = db.Where(\"sub_category IN ?\", subCat.([]string))\n\t}\n\n\tdb = db.Order(\"timestamp DESC\")\n\tif pageSize > 0 {\n\t\tdb = db.Limit(pageSize)\n\t}\n\n\terr := db.Find(&logs).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn logs, nil\n}",
    "sql_pattern_cnt": 3,
    "callers": [
      {
        "code_key": "HandleSecurityLogs",
        "code_value": "func (s *SecurityService) HandleSecurityLogs(req *types.SecurityLogRequest) ([]types.SecurityLog, error) {\n\tif req == nil {\n\t\treturn nil, fmt.Errorf(\"invalid request parameters\")\n\t}\n\n\tfilterOpts := make(map[string]interface{})\n\tif req.SearchIP != \"\" {\n\t\tfilterOpts[\"ip_address\"] = req.SearchIP\n\t} else if req.CaseID != 0 {\n\t\tfilterOpts[\"case_number\"] = strconv.Itoa(req.CaseID)\n\t} else if len(req.SubCategories) > 0 {\n\t\tfilterOpts[\"sub_category\"] = req.SubCategories\n\t}\n\n\temp := &Employee{ID: req.UserID}\n\tlogs, err := emp.MonitorActivity(filterOpts, req.PageSize)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to monitor activity: %v\", err)\n\t}\n\n\tif len(logs) == 0 {\n\t\treturn nil, nil\n\t}\n\treturn logs, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "SecurityLog",
        "code_value": "type SecurityLog struct {\n\tID          uint      `gorm:\"column:id;primaryKey\"`\n\tIPAddress   string    `gorm:\"column:ip_address\"`\n\tCaseNumber  string    `gorm:\"column:case_number\"`\n\tSubCategory string    `gorm:\"column:sub_category\"`\n\tTimestamp   time.Time `gorm:\"column:timestamp\"`\n\tDetails     string    `gorm:\"column:details\"`\n}"
      },
      {
        "code_key": "Employee",
        "code_value": "type Employee struct {\n\tID        uint   `gorm:\"column:id;primaryKey\"`\n\tName      string `gorm:\"column:name\"`\n\tDepartment string `gorm:\"column:department\"`\n\tEmail     string `gorm:\"column:email\"`\n}"
      },
      {
        "code_key": "TableNameSecurityLog",
        "code_value": "const TableNameSecurityLog = \"security_logs\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "LogFilterParams",
        "code_value": "type LogFilterParams struct {\n\tIPAddress  string\n\tCaseNumber string\n\tSubCategory []string\n}"
      }
    ]
  },
  "synthetic_if-else_orm_ScanByPattern": {
    "scenario": "if-else+orm",
    "code_key": "ScanByPattern",
    "code_value": "func (c *Chapter) ScanByPattern(filterCriteria map[string]interface{}, limit int) ([]types.EventLog, error) {\n\tvar events []types.EventLog\n\terr := base.GetInstance().MainDB().Table(\"patient_records\")\n\tif ratio, ok := filterCriteria[\"Ratio\"]; ok {\n\t\terr = err.Where(\"ratio > ?\", ratio).Order(\"ExpirationTime DESC\").Limit(limit).Find(&events).Error\n\t} else if code, ok := filterCriteria[\"DeliveryCode\"]; ok {\n\t\terr = err.Where(\"delivery_code LIKE ?\", \"%\"+code.(string)+\"%\").Order(\"created_at ASC\").Limit(limit).Find(&events).Error\n\t} else if timeRange, ok := filterCriteria[\"TimeRange\"]; ok {\n\t\trangeValue := timeRange.(map[string]interface{})\n\t\terr = err.Where(\"ExpirationTime BETWEEN ? AND ?\", rangeValue[\"start\"], rangeValue[\"end\"]).Limit(limit).Find(&events).Error\n\t} else {\n\t\terr = err.Order(\"id\").Limit(limit).Find(&events).Error\n\t}\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn events, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"database error: %v\", err)\n\t}\n\treturn events, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandlePatientRecordSearch",
        "code_value": "func (s *RecordService) HandlePatientRecordSearch(req *types.RecordSearchRequest) ([]types.EventLog, error) {\n\tcriteria := make(map[string]interface{})\n\tif req.FilterByRatio {\n\t\tcriteria[\"Ratio\"] = req.MinRatio\n\t} else if req.FilterByDeliveryCode {\n\t\tif len(req.DeliveryCodePrefix) < 3 {\n\t\t\treturn nil, fmt.Errorf(\"delivery code must be at least 3 characters\")\n\t\t}\n\t\tcriteria[\"DeliveryCode\"] = req.DeliveryCodePrefix\n\t} else if req.FilterByTimeRange {\n\t\tif req.StartTime.IsZero() || req.EndTime.IsZero() {\n\t\t\treturn nil, fmt.Errorf(\"invalid time range\")\n\t\t}\n\t\tcriteria[\"TimeRange\"] = map[string]interface{}{\n\t\t\t\"start\": req.StartTime,\n\t\t\t\"end\": req.EndTime,\n\t\t}\n\t}\n\n\tchapter := &Chapter{}\n\tresults, err := chapter.ScanByPattern(criteria, req.MaxResults)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"search failed: %v\", err)\n\t}\n\treturn results, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "EventLog",
        "code_value": "type EventLog struct {\n\tID             uint      `json:\"id\" gorm:\"column:id;primaryKey\"`\n\tRatio          float64   `json:\"ratio\" gorm:\"column:ratio\"`\n\tDeliveryCode   string    `json:\"delivery_code\" gorm:\"column:delivery_code\"`\n\tExpirationTime time.Time `json:\"expiration_time\" gorm:\"column:expiration_time\"`\n\tCreatedAt      time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "ScanFilterCriteria",
        "code_value": "type ScanFilterCriteria struct {\n\tRatio        float64            \n\tDeliveryCode string            \n\tTimeRange    map[string]interface{} \n}"
      },
      {
        "code_key": "PatientRecordTable",
        "code_value": "const PatientRecordTable = \"patient_records\""
      },
      {
        "code_key": "DefaultQueryLimit",
        "code_value": "const DefaultQueryLimit = 100"
      },
      {
        "code_key": "ErrorMessages",
        "code_value": "var ErrorMessages = map[string]string{\n\t\"RecordNotFound\": \"No matching records found\",\n\t\"DBError\":       \"Database operation failed\"\n}"
      },
      {
        "code_key": "TimeFormatLayout",
        "code_value": "const TimeFormatLayout = \"2006-01-02 15:04:05\""
      }
    ]
  },
  "synthetic_if-else_orm_MigrateData": {
    "scenario": "if-else+orm",
    "code_key": "MigrateData",
    "code_value": "func (s *Stock) MigrateData(filter map[string]interface{}, page, size int) ([]types.PriceHistory, error) {\n\tph := make([]types.PriceHistory, 0)\n\tvar err error\n\tdb := base.GetInstance().GormDB().Table(\"price_history\")\n\n\tif symbol, ok := filter[\"symbol\"]; ok {\n\t\terr = db.Where(\"symbol LIKE ?\", \"%\"+symbol.(string)+\"%\")\n\t\t\t.Scopes(PaginateDB(page, size))\n\t\t\t.Order(\"record_date DESC\")\n\t\t\t.Find(&ph).Error\n\t} else if status, ok := filter[\"CurrentStatus\"]; ok {\n\t\terr = db.Where(\"CurrentStatus = ? AND record_date > ?\", \n\t\t\tstatus.(string), time.Now().AddDate(0, -1, 0))\n\t\t\t.Scopes(PaginateDB(page, size))\n\t\t\t.Find(&ph).Error\n\t} else if rangeFilter, ok := filter[\"price_range\"]; ok {\n\t\trangeVal := rangeFilter.([]float64)\n\t\terr = db.Where(\"price BETWEEN ? AND ?\", \n\t\t\trangeVal[0], rangeVal[1])\n\t\t\t.Scopes(PaginateDB(page, size))\n\t\t\t.Find(&ph).Error\n\t} else {\n\t\terr = db.Scopes(PaginateDB(page, size))\n\t\t\t.Order(\"record_date DESC\")\n\t\t\t.Find(&ph).Error\n\t}\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn ph, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandleStockData",
        "code_value": "func (h *StockHandler) HandleStockData(req *types.StockQueryRequest) ([]types.PriceHistory, error) {\n\tif req.Page <= 0 || req.Size <= 0 {\n\t\treturn nil, fmt.Errorf(\"invalid pagination parameters\")\n\t}\n\n\tqueryFilters := make(map[string]interface{})\n\tif req.Symbol != \"\" {\n\t\tqueryFilters[\"symbol\"] = req.Symbol\n\t} else if req.Status != \"\" {\n\t\tqueryFilters[\"CurrentStatus\"] = req.Status\n\t} else if req.MinPrice > 0 && req.MaxPrice > req.MinPrice {\n\t\tqueryFilters[\"price_range\"] = []float64{req.MinPrice, req.MaxPrice}\n\t}\n\n\tstockModel := &Stock{}\n\tresult, err := stockModel.MigrateData(queryFilters, req.Page, req.Size)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to migrate stock data: %v\", err)\n\t}\n\n\tif len(result) == 0 {\n\t\treturn nil, nil\n\t}\n\treturn result, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "PriceHistory",
        "code_value": "type PriceHistory struct {\n\tID          int       `json:\"id\" gorm:\"column:id\"`\n\tSymbol      string    `json:\"symbol\" gorm:\"column:symbol\"`\n\tPrice       float64   `json:\"price\" gorm:\"column:price\"`\n\tRecordDate  time.Time `json:\"record_date\" gorm:\"column:record_date\"`\n\tCurrentStatus string  `json:\"current_status\" gorm:\"column:current_status\"`\n}"
      },
      {
        "code_key": "StockFilter",
        "code_value": "type StockFilter struct {\n\tSymbol       *string    `json:\"symbol\"`\n\tCurrentStatus *string   `json:\"current_status\"`\n\tPriceRange   []float64  `json:\"price_range\"`\n}"
      },
      {
        "code_key": "PaginatedResponse",
        "code_value": "type PaginatedResponse struct {\n\tData         []PriceHistory `json:\"data\"`\n\tPage         int            `json:\"page\"`\n\tSize         int            `json:\"size\"`\n\tTotalRecords int64          `json:\"total_records\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "const TableName = \"price_history\""
      },
      {
        "code_key": "PriceStatus",
        "code_value": "const (\n\tPriceActive   = \"ACTIVE\"\n\tPriceInactive = \"INACTIVE\"\n\tPricePending  = \"PENDING\"\n)"
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      }
    ]
  },
  "synthetic_if-else_orm_ValidateOrder": {
    "scenario": "if-else+orm",
    "code_key": "ValidateOrder",
    "code_value": "func (r *Review) ValidateOrder(filterParams map[string]interface{}) (*types.ReviewResult, error) {\n\tvar result types.ReviewResult\n\tdb := base.GetInstance().MainDB().Table(\"maintenance_logs\")\n\t\n\tif editor, ok := filterParams[\"Editor\"]; ok {\n\t\terr := db.Where(\"editor = ? AND status = ?\", editor.(string), \"pending\").First(&result).Error\n\t\tif err != nil {\n\t\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\t\treturn nil, fmt.Errorf(\"no pending reviews for editor: %v\", editor)\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t} else if level, ok := filterParams[\"ApprovalLevel\"]; ok {\n\t\terr := db.Where(\"approval_level > ?\", level.(int)).Order(\"created_at desc\").First(&result).Error\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to find high priority review: %v\", err)\n\t\t}\n\t} else if subject, ok := filterParams[\"Subject\"]; ok {\n\t\terr := db.Where(\"subject LIKE ?\", \"%\"+subject.(string)+\"%\").First(&result).Error\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"subject search failed: %v\", err)\n\t\t}\n\t} else {\n\t\treturn nil, errors.New(\"invalid filter parameters\")\n\t}\n\t\n\treturn &result, nil\n}",
    "sql_pattern_cnt": 3,
    "callers": [
      {
        "code_key": "HandleMaintenanceReview",
        "code_value": "func (s *MaintenanceService) HandleMaintenanceReview(req *types.ReviewRequest) (*types.ReviewResult, error) {\n\tif req == nil {\n\t\treturn nil, errors.New(\"empty request\")\n\t}\n\n\treviewObj := &Review{}\n\tfilterCriteria := make(map[string]interface{})\n\n\t// Trigger different ORM branches based on request\n\tswitch {\n\tcase req.EditorID != \"\":\n\t\tfilterCriteria[\"Editor\"] = req.EditorID\n\tcase req.MinApprovalLevel > 0:\n\t\tfilterCriteria[\"ApprovalLevel\"] = req.MinApprovalLevel\n\tcase req.SearchTerm != \"\":\n\t\tfilterCriteria[\"Subject\"] = req.SearchTerm\n\tdefault:\n\t\treturn nil, errors.New(\"invalid review criteria\")\n\t}\n\n\tresult, err := reviewObj.ValidateOrder(filterCriteria)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"review validation failed: %v\", err)\n\t}\n\n\treturn result, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "ReviewResult",
        "code_value": "type ReviewResult struct {\n\tID            uint      `gorm:\"column:id\"`\n\tEditor        string    `gorm:\"column:editor\"`\n\tSubject       string    `gorm:\"column:subject\"`\n\tStatus        string    `gorm:\"column:status\"`\n\tApprovalLevel int       `gorm:\"column:approval_level\"`\n\tContent       string    `gorm:\"column:content\"`\n\tCreatedAt     time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "ReviewStatus",
        "code_value": "const (\n\tReviewStatusPending   = \"pending\"\n\tReviewStatusApproved = \"approved\"\n\tReviewStatusRejected = \"rejected\"\n)"
      },
      {
        "code_key": "ReviewTable",
        "code_value": "const ReviewTable = \"maintenance_logs\""
      },
      {
        "code_key": "ApprovalThreshold",
        "code_value": "var ApprovalThreshold = map[string]int{\n\t\"low\":    1,\n\t\"medium\": 3,\n\t\"high\":   5\n}"
      },
      {
        "code_key": "ReviewFilter",
        "code_value": "type ReviewFilter struct {\n\tEditor        *string\n\tSubject       *string\n\tApprovalLevel *int\n\tStatus        *string\n}"
      }
    ]
  },
  "synthetic_if-else_orm_FilterMediaUploads": {
    "scenario": "if-else+orm",
    "code_key": "FilterMediaUploads",
    "code_value": "func (d *Diploma) FilterMediaUploads(filterParams map[string]interface{}) ([]types.MediaUpload, error) {\n\tvar uploads []types.MediaUpload\n\tdb := base.GetInstance().GormDB().Table(\"media_uploads\")\n\n\tif topic, ok := filterParams[\"Topic\"]; ok {\n\t\tdb = db.Where(\"topic LIKE ?\", \"%\"+topic.(string)+\"%\")\n\t} else if postalCode, ok := filterParams[\"PostalCode\"]; ok {\n\t\tdb = db.Where(\"postal_code = ?\", postalCode.(string))\n\t} else if modDate, ok := filterParams[\"ModificationDate\"]; ok {\n\t\tdb = db.Where(\"modification_date > ?\", modDate.(string)).Order(\"modification_date DESC\")\n\t} else {\n\t\tdb = db.Limit(100).Order(\"id DESC\")\n\t}\n\n\tif err := db.Find(&uploads).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to query media uploads: %w\", err)\n\t}\n\n\treturn uploads, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandleMediaSearch",
        "code_value": "func (m *MediaManager) HandleMediaSearch(searchReq *types.MediaSearchRequest) ([]types.MediaUpload, error) {\n\tif searchReq == nil {\n\t\treturn nil, fmt.Errorf(\"search request cannot be nil\")\n\t}\n\n\tfilters := make(map[string]interface{})\n\tif searchReq.TopicKeyword != \"\" {\n\t\tfilters[\"Topic\"] = searchReq.TopicKeyword\n\t} else if searchReq.LocationCode != \"\" {\n\t\tif len(searchReq.LocationCode) != 6 {\n\t\t\treturn nil, fmt.Errorf(\"invalid postal code format\")\n\t\t}\n\t\tfilters[\"PostalCode\"] = searchReq.LocationCode\n\t} else if searchReq.LastUpdated != \"\" {\n\t\tif _, err := time.Parse(\"2006-01-02\", searchReq.LastUpdated); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"invalid date format\")\n\t\t}\n\t\tfilters[\"ModificationDate\"] = searchReq.LastUpdated\n\t}\n\n\tdiploma := &Diploma{}\n\tresults, err := diploma.FilterMediaUploads(filters)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to filter media: %v\", err)\n\t}\n\n\treturn results, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "MediaUploadRequest",
        "code_value": "type MediaUploadRequest struct {\n\tTopic            string `json:\"topic\"`\n\tPostalCode       string `json:\"postal_code\"`\n\tModificationDate string `json:\"modification_date\"`\n}"
      },
      {
        "code_key": "MediaUploadResponse",
        "code_value": "type MediaUploadResponse struct {\n\tUploads []MediaUpload `json:\"uploads\"`\n\tError   string       `json:\"error,omitempty\"`\n}"
      },
      {
        "code_key": "Theme",
        "code_value": "type Theme struct {\n\tID          int    `gorm:\"column:id\"`\n\tName        string `gorm:\"column:name\"`\n\tDescription string `gorm:\"column:description\"`\n\tCreatedAt   string `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "Forecast",
        "code_value": "type Forecast struct {\n\ttypes.Theme\n\n\tLocation string `gorm:\"column:location\"`\n\tDate     string `gorm:\"column:date\"`\n}"
      },
      {
        "code_key": "const",
        "code_value": "const (\n\tMediaUploadTable = \"media_uploads\"\n\tDefaultLimit     = 100\n)"
      },
      {
        "code_key": "var",
        "code_value": "var (\n\tDefaultFilterParams = map[string]interface{}{\"Limit\": DefaultLimit}\n)"
      }
    ]
  },
  "synthetic_if-else_orm_QueryWidgetAccessRecords": {
    "scenario": "if-else+orm",
    "code_key": "QueryWidgetAccessRecords",
    "code_value": "func (w *Widget) QueryWidgetAccessRecords(filter map[string]interface{}, page int, size int) ([]types.AccessRecord, error) {\n\tvar records []types.AccessRecord\n\tvar err error\n\tquery := base.GetInstance().GormDB().Table(\"widget_access_records\")\n\n\tif method, ok := filter[\"MethodName\"]; ok {\n\t\tquery = query.Where(\"method_name LIKE ?\", \"%\"+method.(string)+\"%\")\n\t} else if level, ok := filter[\"AccessLevel\"]; ok {\n\t\tquery = query.Where(\"access_level = ?\", level.(int))\n\t} else if key, ok := filter[\"PublicKey\"]; ok {\n\t\tquery = query.Where(\"public_key = ? AND is_verified = ?\", key.(string), true)\n\t} else {\n\t\tquery = query.Where(filter)\n\t}\n\n\terr = query.Order(\"created_at DESC\").Scopes(PaginateDB(page, size)).Find(&records).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to query access records: %w\", err)\n\t}\n\treturn records, nil\n}",
    "sql_pattern_cnt": 3,
    "callers": [
      {
        "code_key": "HandleWidgetAccessRecords",
        "code_value": "func (h *WidgetHandler) HandleWidgetAccessRecords(req *types.QueryWidgetAccessRequest) ([]types.AccessRecord, error) {\n\tif req.Page <= 0 || req.Size <= 0 {\n\t\treturn nil, fmt.Errorf(\"invalid pagination parameters\")\n\t}\n\n\tqueryParams := make(map[string]interface{})\n\n\tswitch {\n\tcase req.MethodName != \"\":\n\t\tqueryParams[\"MethodName\"] = req.MethodName\n\tcase req.AccessLevel > 0:\n\t\tqueryParams[\"AccessLevel\"] = req.AccessLevel\n\tcase req.PublicKey != \"\":\n\t\tqueryParams[\"PublicKey\"] = req.PublicKey\n\tdefault:\n\t\tqueryParams[\"created_at\"] = req.StartTime\n\t}\n\n\twidgetDAO := &Widget{}\n\taccessLogs, err := widgetDAO.QueryWidgetAccessRecords(queryParams, req.Page, req.Size)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to query access records: %w\", err)\n\t}\n\n\treturn accessLogs, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "AccessRecord",
        "code_value": "type AccessRecord struct {\n\tID          uint      `gorm:\"column:id;primaryKey\"`\n\tMethodName  string    `gorm:\"column:method_name\"`\n\tAccessLevel int       `gorm:\"column:access_level\"`\n\tPublicKey   string    `gorm:\"column:public_key\"`\n\tIsVerified  bool      `gorm:\"column:is_verified\"`\n\tCreatedAt   time.Time `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "WidgetQueryParams",
        "code_value": "type WidgetQueryParams struct {\n\tMethodName  string\n\tAccessLevel int\n\tPublicKey   string\n}"
      },
      {
        "code_key": "TableNameWidgetAccessRecords",
        "code_value": "const TableNameWidgetAccessRecords = \"widget_access_records\""
      },
      {
        "code_key": "AccessLevels",
        "code_value": "const (\n\tAccessLevelBasic = 1\n\tAccessLevelAdmin = 2\n\tAccessLevelSuper = 3\n)"
      },
      {
        "code_key": "PaginateDB",
        "code_value": "func PaginateDB(page, size int) func(db *gorm.DB) *gorm.DB {\n\treturn func(db *gorm.DB) *gorm.DB {\n\t\toffset := (page - 1) * size\n\t\treturn db.Offset(offset).Limit(size)\n\t}\n}"
      }
    ]
  },
  "synthetic_if-else_orm_RefreshIndex": {
    "scenario": "if-else+orm",
    "code_key": "RefreshIndex",
    "code_value": "func (p *Pallet) RefreshIndex(filter map[string]interface{}) ([]types.Score, error) {\n\tscores := make([]types.Score, 0)\n\tdb := base.GetInstance().DbDriver().Table(\"leaderboards\")\n\n\tif projectCode, ok := filter[\"ProjectCode\"]; ok {\n\t\tif err := db.Where(\"project_code = ? AND is_active = ?\", projectCode, true).\n\t\t\tOrder(\"created_at DESC\").Find(&scores).Error; err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else if startDate, ok := filter[\"StartDate\"]; ok {\n\t\tif err := db.Where(\"start_date > ?\", startDate).\n\t\t\tGroup(\"transaction_id\").Having(\"COUNT(*) > 1\").Find(&scores).Error; err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else if region, ok := filter[\"Region\"]; ok {\n\t\tif err := db.Where(\"region LIKE ?\", \"%\"+region.(string)+\"%\").\n\t\t\tLimit(100).Find(&scores).Error; err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\tif err := db.Where(filter).Find(&scores).Error; err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif len(scores) == 0 {\n\t\treturn nil, db.ErrRecordNotFound\n\t}\n\treturn scores, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandleScoreRefresh",
        "code_value": "func HandleScoreRefresh(req *types.ScoreRefreshRequest) ([]types.Score, error) {\n\tif req == nil {\n\t\treturn nil, fmt.Errorf(\"request cannot be nil\")\n\t}\n\n\tpallet := &Pallet{}\n\tqueryConditions := make(map[string]interface{})\n\n\tswitch req.QueryType {\n\tcase \"by_project\":\n\t\tif req.ProjectCode == \"\" {\n\t\t\treturn nil, fmt.Errorf(\"project code required for this query type\")\n\t\t}\n\t\tqueryConditions[\"ProjectCode\"] = req.ProjectCode\n\tcase \"by_date\":\n\t\tif req.StartDate.IsZero() {\n\t\t\treturn nil, fmt.Errorf(\"start date required for this query type\")\n\t\t}\n\t\tqueryConditions[\"StartDate\"] = req.StartDate\n\tcase \"by_region\":\n\t\tif req.Region == \"\" {\n\t\t\treturn nil, fmt.Errorf(\"region required for this query type\")\n\t\t}\n\t\tqueryConditions[\"Region\"] = req.Region\n\tdefault:\n\t\tqueryConditions[\"is_active\"] = true\n\t}\n\n\tresults, err := pallet.RefreshIndex(queryConditions)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to refresh scores: %w\", err)\n\t}\n\treturn results, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Score",
        "code_value": "type Score struct {\n\tID          int       `json:\"id\" gorm:\"column:id\"`\n\tProjectCode string    `json:\"project_code\" gorm:\"column:project_code\"`\n\tIsActive    bool      `json:\"is_active\" gorm:\"column:is_active\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tStartDate   time.Time `json:\"start_date\" gorm:\"column:start_date\"`\n\tRegion      string    `json:\"region\" gorm:\"column:region\"`\n\tTransactionID string  `json:\"transaction_id\" gorm:\"column:transaction_id\"`\n}"
      },
      {
        "code_key": "LeaderboardFilter",
        "code_value": "type LeaderboardFilter struct {\n\tProjectCode string\n\tStartDate   time.Time\n\tRegion      string\n}"
      },
      {
        "code_key": "TableLeaderboard",
        "code_value": "const TableLeaderboard = \"leaderboards\""
      },
      {
        "code_key": "DefaultScoreLimit",
        "code_value": "const DefaultScoreLimit = 100"
      },
      {
        "code_key": "ScoreBatchSize",
        "code_value": "var ScoreBatchSize = 50"
      }
    ]
  },
  "synthetic_if-else_orm_UpdateMediaLibraryStatus": {
    "scenario": "if-else+orm",
    "code_key": "UpdateMediaLibraryStatus",
    "code_value": "func (m *MediaLibrary) UpdateMediaLibraryStatus(filter map[string]interface{}, status string) ([]types.MediaItem, error) {\n\titems := make([]types.MediaItem, 0)\n\tdb := base.GetInstance().GormDB().Table(\"media_library\")\n\n\tif category, ok := filter[\"category\"]; ok {\n\t\tdb = db.Where(\"category = ? AND current_status != ?\", category, status)\n\t} else if code, ok := filter[\"delivery_code\"]; ok {\n\t\tdb = db.Where(\"delivery_code LIKE ?\", \"%\"+code.(string)+\"%\")\n\t} else if idRange, ok := filter[\"id_range\"]; ok {\n\t\trangeVal := idRange.([]int)\n\t\tif len(rangeVal) == 2 {\n\t\t\tdb = db.Where(\"id BETWEEN ? AND ?\", rangeVal[0], rangeVal[1])\n\t\t}\n\t} else {\n\t\tdb = db.Where(filter)\n\t}\n\n\terr := db.Model(&types.MediaItem{}).\n\t\tUpdate(\"current_status\", status).\n\t\tFind(&items).Error\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, fmt.Errorf(\"no matching records found\")\n\t\t}\n\t\treturn nil, err\n\t}\n\n\treturn items, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandleMediaStatusUpdate",
        "code_value": "func (s *MediaService) HandleMediaStatusUpdate(req *types.MediaStatusUpdateRequest) ([]types.MediaItem, error) {\n\tif req.Status == \"\" {\n\t\treturn nil, fmt.Errorf(\"status cannot be empty\")\n\t}\n\n\tfilterParams := make(map[string]interface{})\n\tif req.Category != \"\" {\n\t\tfilterParams[\"category\"] = req.Category\n\t} else if req.DeliveryCode != \"\" {\n\t\tfilterParams[\"delivery_code\"] = req.DeliveryCode\n\t} else if len(req.IDRange) == 2 {\n\t\tfilterParams[\"id_range\"] = req.IDRange\n\t} else {\n\t\tfilterParams[\"upload_date\"] = req.UploadDate\n\t}\n\n\tmediaLib := &MediaLibrary{}\n\tupdatedItems, err := mediaLib.UpdateMediaLibraryStatus(filterParams, req.Status)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to update media status: %v\", err)\n\t}\n\n\tif len(updatedItems) == 0 {\n\t\treturn nil, fmt.Errorf(\"no items matched the criteria\")\n\t}\n\n\treturn updatedItems, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "MediaItem",
        "code_value": "type MediaItem struct {\n\tID            int       `json:\"id\" gorm:\"column:id;primaryKey\"`\n\tCategory      string    `json:\"category\" gorm:\"column:category\"`\n\tDeliveryCode  string    `json:\"delivery_code\" gorm:\"column:delivery_code\"`\n\tCurrentStatus string    `json:\"current_status\" gorm:\"column:current_status\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "MediaStatus",
        "code_value": "const (\n\tMediaStatusPending   = \"pending\"\n\tMediaStatusApproved  = \"approved\"\n\tMediaStatusRejected  = \"rejected\"\n\tMediaStatusArchived  = \"archived\"\n)"
      },
      {
        "code_key": "MediaLibraryTable",
        "code_value": "const MediaLibraryTable = \"media_library\""
      },
      {
        "code_key": "DefaultMediaCategory",
        "code_value": "var DefaultMediaCategory = map[string]bool{\n\t\"video\":    true,\n\t\"audio\":    true,\n\t\"image\":    true,\n\t\"document\": true,\n}"
      },
      {
        "code_key": "MediaFilter",
        "code_value": "type MediaFilter struct {\n\tCategory     string `json:\"category\"`\n\tDeliveryCode string `json:\"delivery_code\"`\n\tIDRange      []int  `json:\"id_range\"`\n}"
      }
    ]
  },
  "synthetic_if-else_orm_OptimizePerformance": {
    "scenario": "if-else+orm",
    "code_key": "OptimizePerformance",
    "code_value": "func (d *Document) OptimizePerformance(filterParams map[string]interface{}, limit int) ([]types.PerformanceMetric, error) {\n\tmetrics := make([]types.PerformanceMetric, 0)\n\tvar err error\n\n\tquery := base.GetInstance().GormDB().Table(\"quest_progress\")\n\n\tif region, ok := filterParams[\"Region\"]; ok {\n\t\tquery = query.Where(\"region = ?\", region.(string))\n\t} else if session, ok := filterParams[\"SessionToken\"]; ok {\n\t\tquery = query.Where(\"session_token = ? AND status = 'active'\", session.(string))\n\t} else if duration, ok := filterParams[\"Duration\"]; ok {\n\t\tdurationInt := duration.(int)\n\t\tquery = query.Where(\"duration > ? AND completed_at IS NOT NULL\", durationInt)\n\t} else {\n\t\tquery = query.Where(\"is_benchmark = true\")\n\t}\n\n\terr = query.Order(\"score DESC\").Limit(limit).Find(&metrics).Error\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn metrics, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to fetch performance metrics: %w\", err)\n\t}\n\n\treturn metrics, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandlePerformanceMetrics",
        "code_value": "func (h *PerformanceHandler) HandlePerformanceMetrics(criteria *types.PerformanceCriteria) ([]types.PerformanceMetric, error) {\n\tif criteria == nil {\n\t\treturn nil, fmt.Errorf(\"performance criteria cannot be nil\")\n\t}\n\n\tdoc := &Document{}\n\tfilters := make(map[string]interface{})\n\t\n\tif criteria.Region != \"\" {\n\t\tfilters[\"Region\"] = criteria.Region\n\t} else if criteria.SessionToken != \"\" {\n\t\tfilters[\"SessionToken\"] = criteria.SessionToken\n\t} else if criteria.MinDuration > 0 {\n\t\tfilters[\"Duration\"] = criteria.MinDuration\n\t}\n\n\tresult, err := doc.OptimizePerformance(filters, criteria.MaxResults)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to optimize performance: %w\", err)\n\t}\n\n\tif len(result) == 0 {\n\t\treturn nil, fmt.Errorf(\"no performance metrics found\")\n\t}\n\n\treturn result, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "PerformanceMetric",
        "code_value": "type PerformanceMetric struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tRegion        string    `json:\"region\" gorm:\"column:region\"`\n\tSessionToken  string    `json:\"session_token\" gorm:\"column:session_token\"`\n\tScore         float64   `json:\"score\" gorm:\"column:score\"`\n\tDuration      int       `json:\"duration\" gorm:\"column:duration\"`\n\tCompletedAt   time.Time `json:\"completed_at\" gorm:\"column:completed_at\"`\n\tIsBenchmark   bool      `json:\"is_benchmark\" gorm:\"column:is_benchmark\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "Document",
        "code_value": "type Document struct {\n\tID        string `json:\"id\" gorm:\"primaryKey\"`\n\tContent   string `json:\"content\" gorm:\"type:text\"`\n\tVersion   int    `json:\"version\" gorm:\"default:1\"`\n\tIsActive  bool   `json:\"is_active\" gorm:\"default:true\"`\n\tCreatedBy string `json:\"created_by\" gorm:\"size:255\"`\n}"
      },
      {
        "code_key": "TableNamePerformance",
        "code_value": "const TableNamePerformance = \"quest_progress\""
      },
      {
        "code_key": "StatusActive",
        "code_value": "const StatusActive = \"active\""
      },
      {
        "code_key": "DefaultLimit",
        "code_value": "const DefaultLimit = 100"
      },
      {
        "code_key": "FilterParams",
        "code_value": "type FilterParams struct {\n\tRegion       string\n\tSessionToken string\n\tDuration     int\n}"
      }
    ]
  },
  "synthetic_if-else_orm_QueryProgressByConditions": {
    "scenario": "if-else+orm",
    "code_key": "QueryProgressByConditions",
    "code_value": "func (p *Progress) QueryProgressByConditions(criteria map[string]interface{}, page, limit int) ([]types.ProgressDetail, error) {\n    var records []types.ProgressDetail\n    db := base.GetInstance().MainDB().Table(\"progress_tracking\")\n    \n    if locale, ok := criteria[\"Locale\"]; ok {\n        db = db.Where(\"locale = ?\", locale.(string))\n    } else if summary, ok := criteria[\"Summary\"]; ok {\n        db = db.Where(\"summary LIKE ?\", \"%\"+summary.(string)+\"%\")\n    } else if threshold, ok := criteria[\"Threshold\"]; ok {\n        db = db.Where(\"completion_rate >= ?\", threshold.(float64))\n    } else {\n        db = db.Where(criteria)\n    }\n    \n    err := db.Order(\"updated_at DESC\").\n        Scopes(PaginateDB(page, limit)).\n        Find(&records).Error\n    \n    if err != nil {\n        if errors.Is(err, gorm.ErrRecordNotFound) {\n            return nil, nil\n        }\n        return nil, fmt.Errorf(\"query progress failed: %w\", err)\n    }\n    return records, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandleContainerProgress",
        "code_value": "func (h *ContainerHandler) HandleContainerProgress(req *types.ContainerProgressRequest) ([]types.ProgressDetail, error) {\n    if req.Page <= 0 || req.Limit <= 0 {\n        return nil, fmt.Errorf(\"invalid pagination parameters\")\n    }\n    \n    searchParams := make(map[string]interface{})\n    \n    if req.Locale != \"\" {\n        searchParams[\"Locale\"] = req.Locale\n    } else if req.SummaryKeyword != \"\" {\n        searchParams[\"Summary\"] = req.SummaryKeyword\n    } else if req.MinCompletionRate > 0 {\n        searchParams[\"Threshold\"] = req.MinCompletionRate\n    } else {\n        searchParams[\"container_id\"] = req.ContainerID\n    }\n    \n    progressTracker := &Progress{}\n    results, err := progressTracker.QueryProgressByConditions(searchParams, req.Page, req.Limit)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to query container progress: %w\", err)\n    }\n    \n    return results, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "ProgressTracking",
        "code_value": "type ProgressTracking struct {\n\tID             int       `json:\"id\" gorm:\"column:id;primaryKey\"`\n\tLocale         string    `json:\"locale\" gorm:\"column:locale\"`\n\tSummary        string    `json:\"summary\" gorm:\"column:summary\"`\n\tCompletionRate float64   `json:\"completion_rate\" gorm:\"column:completion_rate\"`\n\tCreatedAt      time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt      time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "ProgressDetail",
        "code_value": "type ProgressDetail struct {\n\tID             int       `json:\"id\"`\n\tLocale         string    `json:\"locale\"`\n\tSummary        string    `json:\"summary\"`\n\tCompletionRate float64   `json:\"completion_rate\"`\n\tLastUpdated    time.Time `json:\"last_updated\"`\n}"
      },
      {
        "code_key": "ProgressQueryRequest",
        "code_value": "type ProgressQueryRequest struct {\n\tLocale   string  `json:\"locale\"`\n\tSummary  string  `json:\"summary\"`\n\tThreshold float64 `json:\"threshold\"`\n\tPage     int     `json:\"page\"`\n\tLimit    int     `json:\"limit\"`\n}"
      },
      {
        "code_key": "ProgressTable",
        "code_value": "const ProgressTable = \"progress_tracking\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "MaxQueryLimit",
        "code_value": "const MaxQueryLimit = 100"
      },
      {
        "code_key": "ProgressStatus",
        "code_value": "type ProgressStatus struct {\n\tPending   string `json:\"pending\"`\n\tCompleted string `json:\"completed\"`\n\tFailed    string `json:\"failed\"`\n}"
      },
      {
        "code_key": "StatusValues",
        "code_value": "var StatusValues = ProgressStatus{\n\tPending:   \"pending\",\n\tCompleted: \"completed\",\n\tFailed:    \"failed\",\n}"
      }
    ]
  },
  "synthetic_if-else_orm_AssignTask": {
    "scenario": "if-else+orm",
    "code_key": "AssignTask",
    "code_value": "func (m *Magazine) AssignTask(filterParams map[string]interface{}, page, limit int) ([]types.TaskAssignment, error) {\n\tassignments := make([]types.TaskAssignment, 0)\n\tvar err error\n\n\tif ticketNumber, ok := filterParams[\"TicketNumber\"]; ok {\n\t\tquery := base.GetDB().Table(\"share_activities\").Where(\"ticket_number = ?\", ticketNumber)\n\t\tif language, ok := filterParams[\"Language\"]; ok {\n\t\t\tquery = query.Where(\"language = ?\", language)\n\t\t}\n\t\terr = query.Scopes(PaginateDB(page, limit)).Find(&assignments).Error\n\t} else if firstLoginDate, ok := filterParams[\"FirstLoginDate\"]; ok {\n\t\tstartDate := firstLoginDate.(string) + \" 00:00:00\"\n\t\tendDate := firstLoginDate.(string) + \" 23:59:59\"\n\t\terr = base.GetDB().Table(\"transit_times\")\n\t\t\t.Where(\"created_at BETWEEN ? AND ?\", startDate, endDate)\n\t\t\t.Scopes(PaginateDB(page, limit))\n\t\t\t.Find(&assignments).Error\n\t} else {\n\t\terr = base.GetDB().Table(\"prescription_data\")\n\t\t\t.Where(filterParams)\n\t\t\t.Scopes(PaginateDB(page, limit))\n\t\t\t.Find(&assignments).Error\n\t}\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn assignments, nil\n}",
    "sql_pattern_cnt": 3,
    "callers": [
      {
        "code_key": "HandleTaskAssignment",
        "code_value": "func (s *TaskService) HandleTaskAssignment(req *types.TaskAssignmentRequest) ([]types.TaskAssignment, error) {\n\tmag := &Magazine{}\n\tfilters := make(map[string]interface{})\n\n\tswitch req.SearchType {\n\tcase \"byTicket\":\n\t\tif req.TicketNumber == \"\" {\n\t\t\treturn nil, errors.New(\"ticket number required\")\n\t\t}\n\t\tfilters[\"TicketNumber\"] = req.TicketNumber\n\t\tif req.Language != \"\" {\n\t\t\tfilters[\"Language\"] = req.Language\n\t\t}\n\tcase \"byDate\":\n\t\tif req.FirstLoginDate == \"\" {\n\t\t\treturn nil, errors.New(\"date required\")\n\t\t}\n\t\tfilters[\"FirstLoginDate\"] = req.FirstLoginDate\n\tdefault:\n\t\tif req.Status != \"\" {\n\t\t\tfilters[\"status\"] = req.Status\n\t\t}\n\t}\n\n\tpage := 1\n\tif req.Page > 0 {\n\t\tpage = req.Page\n\t}\n\tlimit := 10\n\tif req.Limit > 0 && req.Limit < 100 {\n\t\tlimit = req.Limit\n\t}\n\n\treturn mag.AssignTask(filters, page, limit)\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "TaskAssignment",
        "code_value": "type TaskAssignment struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tTicketNumber  string    `json:\"ticket_number\" gorm:\"column:ticket_number\"`\n\tLanguage      string    `json:\"language\" gorm:\"column:language\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n\tAssigneeID    int       `json:\"assignee_id\" gorm:\"column:assignee_id\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "TaskFilterParams",
        "code_value": "type TaskFilterParams struct {\n\tTicketNumber   *string `json:\"ticket_number\"`\n\tLanguage       *string `json:\"language\"`\n\tFirstLoginDate *string `json:\"first_login_date\"`\n\tAssigneeID     *int    `json:\"assignee_id\"`\n}"
      },
      {
        "code_key": "TaskStatus",
        "code_value": "const (\n\tTaskStatusPending   = \"pending\"\n\tTaskStatusAssigned = \"assigned\"\n\tTaskStatusCompleted = \"completed\"\n\tTaskStatusRejected = \"rejected\"\n)"
      },
      {
        "code_key": "TaskTables",
        "code_value": "var TaskTables = struct {\n\tShareActivities  string\n\tTransitTimes     string\n\tPrescriptionData string\n}{\n\tShareActivities:  \"share_activities\",\n\tTransitTimes:     \"transit_times\",\n\tPrescriptionData: \"prescription_data\",\n}"
      },
      {
        "code_key": "AssignmentResponse",
        "code_value": "type AssignmentResponse struct {\n\tSuccess   bool               `json:\"success\"`\n\tMessage   string             `json:\"message\"`\n\tData      []TaskAssignment   `json:\"data\"`\n\tPage      int                `json:\"page\"`\n\tPageSize  int                `json:\"page_size\"`\n\tTotal     int64              `json:\"total\"`\n}"
      }
    ]
  },
  "synthetic_if-else_orm_ValidatePolicy": {
    "scenario": "if-else+orm",
    "code_key": "ValidatePolicy",
    "code_value": "func (p *Policy) ValidatePolicy(filter map[string]interface{}) ([]types.PolicyRecord, error) {\n\tvar records []types.PolicyRecord\n\tdb := base.GetInstance().Db().Table(\"content_archive\")\n\n\tif zone, ok := filter[\"Zone\"]; ok {\n\t\tdb = db.Where(\"zone = ?\", zone).Order(\"created_at DESC\")\n\t} else if privateKey, ok := filter[\"PrivateKey\"]; ok {\n\t\tdb = db.Where(\"private_key LIKE ?\", \"%\"+privateKey.(string)+\"%\").Order(\"updated_at\")\n\t} else if totalAmount, ok := filter[\"TotalAmount\"]; ok {\n\t\tamount := totalAmount.(float64)\n\t\tdb = db.Where(\"total_amount > ? AND total_amount < ?\", amount*0.9, amount*1.1)\n\t} else {\n\t\treturn nil, errors.New(\"invalid filter parameters\")\n\t}\n\n\tif err := db.Find(&records).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"database error: %w\", err)\n\t}\n\n\treturn records, nil\n}",
    "sql_pattern_cnt": 3,
    "callers": [
      {
        "code_key": "HandlePolicySearch",
        "code_value": "func (s *PolicyService) HandlePolicySearch(searchReq *types.PolicySearchRequest) ([]types.PolicyRecord, error) {\n\tif searchReq == nil {\n\t\treturn nil, errors.New(\"invalid request\")\n\t}\n\n\tqueryFilters := make(map[string]interface{})\n\n\tswitch {\n\tcase searchReq.ZoneID != \"\":\n\t\tqueryFilters[\"Zone\"] = searchReq.ZoneID\n\tcase searchReq.KeyFragment != \"\":\n\t\tif len(searchReq.KeyFragment) < 4 {\n\t\t\treturn nil, errors.New(\"key fragment too short\")\n\t\t}\n\t\tqueryFilters[\"PrivateKey\"] = searchReq.KeyFragment\n\tcase searchReq.ApproxAmount > 0:\n\t\tqueryFilters[\"TotalAmount\"] = searchReq.ApproxAmount\n\tdefault:\n\t\treturn nil, errors.New(\"no valid search criteria provided\")\n\t}\n\n\tpolicy := &Policy{}\n\trecords, err := policy.ValidatePolicy(queryFilters)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"policy validation failed: %w\", err)\n\t}\n\n\treturn records, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "PolicyRecord",
        "code_value": "type PolicyRecord struct {\n\tID          uint      `json:\"id\" gorm:\"column:id\"`\n\tZone        string    `json:\"zone\" gorm:\"column:zone\"`\n\tPrivateKey  string    `json:\"private_key\" gorm:\"column:private_key\"`\n\tTotalAmount float64   `json:\"total_amount\" gorm:\"column:total_amount\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt   time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "PolicyFilter",
        "code_value": "type PolicyFilter struct {\n\tZone       string  `json:\"zone\"`\n\tPrivateKey string  `json:\"private_key\"`\n\tTotalAmount float64 `json:\"total_amount\"`\n}"
      },
      {
        "code_key": "ContentArchiveTable",
        "code_value": "const ContentArchiveTable = \"content_archive\""
      },
      {
        "code_key": "ErrorMessages",
        "code_value": "var ErrorMessages = map[string]string{\n\t\"InvalidFilter\": \"invalid filter parameters\",\n\t\"DatabaseError\": \"database error\",\n\t\"NotFound\": \"record not found\"\n}"
      },
      {
        "code_key": "PolicyValidationThreshold",
        "code_value": "const PolicyValidationThreshold = 0.1"
      },
      {
        "code_key": "PolicyResponse",
        "code_value": "type PolicyResponse struct {\n\tRecords []PolicyRecord `json:\"records\"`\n\tError   string        `json:\"error,omitempty\"`\n}"
      }
    ]
  },
  "synthetic_if-else_orm_QueryGameSessions": {
    "scenario": "if-else+orm",
    "code_key": "QueryGameSessions",
    "code_value": "func (s *Student) QueryGameSessions(filter map[string]interface{}, page, size int) ([]types.GameSession, error) {\n\tvar sessions []types.GameSession\n\tdb := base.GetInstance().GormDB().Table(\"game_sessions\")\n\n\tif version, ok := filter[\"Version\"]; ok {\n\t\tdb = db.Where(\"version = ?\", version).Order(\"created_at desc\")\n\t} else if rank, ok := filter[\"PriorityRank\"]; ok {\n\t\tdb = db.Where(\"priority_rank > ?\", rank).Order(\"priority_rank asc\")\n\t} else if building, ok := filter[\"Building\"]; ok {\n\t\tdb = db.Where(\"building LIKE ?\", \"%\"+building.(string)+\"%\").Order(\"building asc\")\n\t} else {\n\t\tdb = db.Order(\"id desc\")\n\t}\n\n\terr := db.Scopes(Paginate(page, size)).Find(&sessions).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn sessions, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandleGameSessionQuery",
        "code_value": "func (h *GameSessionHandler) HandleGameSessionQuery(req *types.GameSessionQueryRequest) ([]types.GameSession, error) {\n\tif req.Page <= 0 || req.Size <= 0 {\n\t\treturn nil, fmt.Errorf(\"invalid pagination parameters\")\n\t}\n\n\tcriteria := make(map[string]interface{})\n\tif req.Version != \"\" {\n\t\tcriteria[\"Version\"] = req.Version\n\t} else if req.PriorityRank > 0 {\n\t\tcriteria[\"PriorityRank\"] = req.PriorityRank\n\t} else if req.Building != \"\" {\n\t\tcriteria[\"Building\"] = req.Building\n\t}\n\n\tstudent := &Student{}\n\tresults, err := student.QueryGameSessions(criteria, req.Page, req.Size)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"query failed: %v\", err)\n\t}\n\treturn results, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "GameSession",
        "code_value": "type GameSession struct {\n\tID           uint      `gorm:\"column:id;primaryKey\"`\n\tVersion      string    `gorm:\"column:version\"`\n\tPriorityRank int       `gorm:\"column:priority_rank\"`\n\tBuilding     string    `gorm:\"column:building\"`\n\tCreatedAt    time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt    time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "SessionFilter",
        "code_value": "type SessionFilter struct {\n\tVersion      *string\n\tPriorityRank *int\n\tBuilding     *string\n}"
      },
      {
        "code_key": "GameSessionResponse",
        "code_value": "type GameSessionResponse struct {\n\tSessions []GameSession `json:\"sessions\"`\n\tPage     int           `json:\"page\"`\n\tPageSize int           `json:\"page_size\"`\n\tTotal    int64         `json:\"total\"`\n}"
      },
      {
        "code_key": "TableNameGameSessions",
        "code_value": "const TableNameGameSessions = \"game_sessions\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "MaxPageSize",
        "code_value": "const MaxPageSize = 100"
      },
      {
        "code_key": "SessionStatusActive",
        "code_value": "const SessionStatusActive = \"active\""
      },
      {
        "code_key": "SessionStatusInactive",
        "code_value": "const SessionStatusInactive = \"inactive\""
      }
    ]
  },
  "synthetic_if-else_orm_FetchCurrencyRates": {
    "scenario": "if-else+orm",
    "code_key": "FetchCurrencyRates",
    "code_value": "func (c *Currency) FetchCurrencyRates(filter map[string]interface{}) ([]types.ExchangeRate, error) {\n\trates := make([]types.ExchangeRate, 0)\n\tvar err error\n\n\tif code, ok := filter[\"LocationCode\"]; ok {\n\t\terr = base.GetDB().Table(\"investment_portfolios\").\n\t\t\tWhere(\"location_code = ? AND status = ?\", code.(string), \"active\").\n\t\t\tOrder(\"effective_date DESC\").\n\t\t\tFind(&rates).Error\n\t} else if dateRange, ok := filter[\"DateRange\"]; ok {\n\t\trangeVal := dateRange.([]string)\n\t\terr = base.GetDB().Table(\"investment_portfolios\").\n\t\t\tWhere(\"effective_date BETWEEN ? AND ?\", rangeVal[0], rangeVal[1]).\n\t\t\tGroup(\"currency_type\").\n\t\t\tFind(&rates).Error\n\t} else if threshold, ok := filter[\"RateThreshold\"]; ok {\n\t\terr = base.GetDB().Table(\"investment_portfolios\").\n\t\t\tWhere(\"conversion_rate > ?\", threshold.(float64)).\n\t\t\tLimit(100).\n\t\t\tFind(&rates).Error\n\t} else {\n\t\terr = base.GetDB().Table(\"investment_portfolios\").\n\t\t\tWhere(filter).\n\t\t\tFind(&rates).Error\n\t}\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, fmt.Errorf(\"no matching currency rates found\")\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn rates, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandleCurrencyRateRequest",
        "code_value": "func HandleCurrencyRateRequest(criteria *types.CurrencyRateCriteria) ([]types.ExchangeRate, error) {\n\tif criteria == nil {\n\t\treturn nil, fmt.Errorf(\"criteria cannot be nil\")\n\t}\n\n\tcurrencyDB := &Currency{}\n\tqueryParams := make(map[string]interface{})\n\n\tif criteria.Location != \"\" {\n\t\tqueryParams[\"LocationCode\"] = criteria.Location\n\t} else if !criteria.StartDate.IsZero() && !criteria.EndDate.IsZero() {\n\t\tqueryParams[\"DateRange\"] = []string{criteria.StartDate.Format(\"2006-01-02\"), criteria.EndDate.Format(\"2006-01-02\")}\n\t} else if criteria.MinRate > 0 {\n\t\tqueryParams[\"RateThreshold\"] = criteria.MinRate\n\t} else {\n\t\treturn nil, fmt.Errorf(\"no valid query criteria provided\")\n\t}\n\n\texchangeRates, err := currencyDB.FetchCurrencyRates(queryParams)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to fetch currency rates: %v\", err)\n\t}\n\n\tif len(exchangeRates) == 0 {\n\t\treturn nil, fmt.Errorf(\"no rates found for given criteria\")\n\t}\n\n\treturn exchangeRates, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "ExchangeRate",
        "code_value": "type ExchangeRate struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tCurrencyType  string    `json:\"currency_type\" gorm:\"column:currency_type\"`\n\tLocationCode  string    `json:\"location_code\" gorm:\"column:location_code\"`\n\tConversionRate float64   `json:\"conversion_rate\" gorm:\"column:conversion_rate\"`\n\tEffectiveDate time.Time `json:\"effective_date\" gorm:\"column:effective_date\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "CurrencyFilter",
        "code_value": "type CurrencyFilter struct {\n\tLocationCode  interface{} `json:\"LocationCode\"`\n\tDateRange     interface{} `json:\"DateRange\"`\n\tRateThreshold interface{} `json:\"RateThreshold\"`\n}"
      },
      {
        "code_key": "TableInvestmentPortfolios",
        "code_value": "const TableInvestmentPortfolios = \"investment_portfolios\""
      },
      {
        "code_key": "StatusActive",
        "code_value": "const StatusActive = \"active\""
      },
      {
        "code_key": "DefaultRateLimit",
        "code_value": "const DefaultRateLimit = 100"
      },
      {
        "code_key": "CurrencyErrorMessages",
        "code_value": "var CurrencyErrorMessages = map[string]string{\n\t\"NotFound\": \"no matching currency rates found\",\n\t\"InvalidFilter\": \"invalid filter parameters provided\"\n}"
      }
    ]
  },
  "synthetic_if-else_orm_ScaleCapacity": {
    "scenario": "if-else+orm",
    "code_key": "ScaleCapacity",
    "code_value": "func (v *Vehicle) ScaleCapacity(filters map[string]interface{}) ([]types.VehicleCapacity, error) {\n\tcapacities := make([]types.VehicleCapacity, 0)\n\tdb := base.GetInstance().GormDriver().Table(\"package_tracking\")\n\n\tif floor, ok := filters[\"Floor\"]; ok {\n\t\tdb = db.Where(\"floor = ? AND available = ?\", floor.(int), true)\n\t} else if shipmentId, ok := filters[\"ShipmentId\"]; ok {\n\t\tdb = db.Where(\"shipment_id LIKE ?\", \"%\"+shipmentId.(string)+\"%\").Order(\"created_at DESC\")\n\t} else if deliveryCode, ok := filters[\"DeliveryCode\"]; ok {\n\t\tfilter := map[string]interface{}{\n\t\t\t\"delivery_code\": deliveryCode,\n\t\t\t\"status\":         \"active\",\n\t\t}\n\t\tdb = db.Where(filter).Limit(100)\n\t} else {\n\t\tdb = db.Where(filters).Order(\"id ASC\")\n\t}\n\n\terr := db.Find(&capacities).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn capacities, nil\n}",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_key": "HandleCapacity",
        "code_value": "func (h *CapacityHandler) HandleCapacity(req *types.CapacityRequest) ([]types.VehicleCapacity, error) {\n\tif req == nil {\n\t\treturn nil, errors.New(\"invalid request\")\n\t}\n\n\tvehicle := &Vehicle{}\n\tfilters := make(map[string]interface{})\n\n\tswitch {\n\tcase req.Floor > 0:\n\t\tfilters[\"Floor\"] = req.Floor\n\tcase req.ShipmentID != \"\":\n\t\tfilters[\"ShipmentId\"] = req.ShipmentID\n\tcase req.DeliveryCode != \"\":\n\t\tfilters[\"DeliveryCode\"] = req.DeliveryCode\n\tdefault:\n\t\tfilters[\"region\"] = req.Region\n\t\tfilters[\"vehicle_type\"] = req.VehicleType\n\t}\n\n\tcapacities, err := vehicle.ScaleCapacity(filters)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get capacities: %v\", err)\n\t}\n\treturn capacities, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "VehicleCapacity",
        "code_value": "type VehicleCapacity struct {\n\tID           int       `json:\"id\" gorm:\"column:id\"`\n\tShipmentId   string    `json:\"shipment_id\" gorm:\"column:shipment_id\"`\n\tDeliveryCode string    `json:\"delivery_code\" gorm:\"column:delivery_code\"`\n\tFloor        int       `json:\"floor\" gorm:\"column:floor\"`\n\tAvailable    bool      `json:\"available\" gorm:\"column:available\"`\n\tStatus       string    `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt    time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt    time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "CapacityStatus",
        "code_value": "const (\n\tCapacityStatusActive   = \"active\"\n\tCapacityStatusInactive = \"inactive\"\n\tCapacityStatusPending  = \"pending\"\n)"
      },
      {
        "code_key": "VehicleFilter",
        "code_value": "type VehicleFilter struct {\n\tFloor        *int\n\tShipmentId   *string\n\tDeliveryCode *string\n\tStatus       *string\n}"
      },
      {
        "code_key": "PackageTrackingTable",
        "code_value": "const PackageTrackingTable = \"package_tracking\""
      },
      {
        "code_key": "DefaultCapacityLimit",
        "code_value": "var DefaultCapacityLimit = 100"
      }
    ]
  }
}