[
  {
    "function_name": "BulkUpdate",
    "orm_code": "func (r *Refund) BulkUpdate(filter map[string]interface{}, updates map[string]interface{}) (int64, error) {\n\tvar affected int64\n\tvar err error\n\t\n\tif sessionToken, ok := filter[\"SessionToken\"]; ok {\n\t\terr = db.Get().Table(\"shipping_manifest\").\n\t\t\tWhere(\"session_token = ? AND status = 'pending'\", sessionToken).\n\t\t\tUpdates(updates).\n\t\t\tCount(&affected).Error\n\t} else if zone, ok := filter[\"Zone\"]; ok {\n\t\terr = db.Get().Table(\"shipping_manifest\").\n\t\t\tWhere(\"zone = ? AND format = ?\", zone, filter[\"Format\"]).\n\t\t\tUpdates(updates).\n\t\t\tCount(&affected).Error\n\t} else {\n\t\terr = db.Get().Table(\"shipping_manifest\").\n\t\t\tWhere(filter).\n\t\t\tUpdates(updates).\n\t\t\tCount(&affected).Error\n\t}\n\t\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn affected, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "filter contains SessionToken",
            "sql": "UPDATE shipping_manifest SET status = 'processed' WHERE session_token = 'token123' AND status = 'pending'; SELECT COUNT(*) FROM shipping_manifest WHERE session_token = 'token123' AND status = 'pending';"
          },
          {
            "scenario": "filter contains Zone but not SessionToken",
            "sql": "UPDATE shipping_manifest SET status = 'processed', zone = 'west' WHERE zone = 'east' AND format = 'standard'; SELECT COUNT(*) FROM shipping_manifest WHERE zone = 'east' AND format = 'standard';"
          },
          {
            "scenario": "filter contains neither SessionToken nor Zone",
            "sql": "UPDATE shipping_manifest SET status = 'processed' WHERE status = 'pending'; SELECT COUNT(*) FROM shipping_manifest WHERE status = 'pending';"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ShippingManifest",
        "code_value": "type ShippingManifest struct {\n\tID           int       `json:\"id\" gorm:\"column:id\"`\n\tSessionToken string    `json:\"session_token\" gorm:\"column:session_token\"`\n\tZone         string    `json:\"zone\" gorm:\"column:zone\"`\n\tFormat       string    `json:\"format\" gorm:\"column:format\"`\n\tStatus       string    `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt    time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt    time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "Refund",
        "code_value": "type Refund struct {\n\tID        int       `json:\"id\" gorm:\"column:id\"`\n\tAmount    float64   `json:\"amount\" gorm:\"column:amount\"`\n\tReason    string    `json:\"reason\" gorm:\"column:reason\"`\n\tStatus    string    `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "StatusPending",
        "code_value": "const StatusPending = \"pending\""
      },
      {
        "code_key": "TableShippingManifest",
        "code_value": "const TableShippingManifest = \"shipping_manifest\""
      },
      {
        "code_key": "DefaultZone",
        "code_value": "var DefaultZone = \"east\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "BulkUpdate",
    "orm_code": "func (r *Refund) BulkUpdate(filter map[string]interface{}, updates map[string]interface{}) (int64, error) {\n\tvar affected int64\n\tvar err error\n\t\n\tif sessionToken, ok := filter[\"SessionToken\"]; ok {\n\t\terr = db.Get().Table(\"shipping_manifest\").\n\t\t\tWhere(\"session_token = ? AND status = 'pending'\", sessionToken).\n\t\t\tUpdates(updates).\n\t\t\tCount(&affected).Error\n\t} else if zone, ok := filter[\"Zone\"]; ok {\n\t\terr = db.Get().Table(\"shipping_manifest\").\n\t\t\tWhere(\"zone = ? AND format = ?\", zone, filter[\"Format\"]).\n\t\t\tUpdates(updates).\n\t\t\tCount(&affected).Error\n\t} else {\n\t\terr = db.Get().Table(\"shipping_manifest\").\n\t\t\tWhere(filter).\n\t\t\tUpdates(updates).\n\t\t\tCount(&affected).Error\n\t}\n\t\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn affected, nil\n}",
    "caller": "func (h *ShippingHandler) HandleShippingUpdate(req *ShippingUpdateRequest) (int64, error) {\n\tif req == nil {\n\t\treturn 0, errors.New(\"nil request\")\n\t}\n\n\tfilter := make(map[string]interface{})\n\tupdates := make(map[string]interface{})\n\tupdates[\"status\"] = req.NewStatus\n\tupdates[\"updated_at\"] = time.Now()\n\n\tif req.SessionToken != \"\" {\n\t\tfilter[\"SessionToken\"] = req.SessionToken\n\t} else if req.ZoneID != 0 && req.ShippingFormat != \"\" {\n\t\tfilter[\"Zone\"] = req.ZoneID\n\t\tfilter[\"Format\"] = req.ShippingFormat\n\t} else if req.ManifestID != \"\" {\n\t\tfilter[\"manifest_id\"] = req.ManifestID\n\t} else {\n\t\treturn 0, errors.New(\"insufficient filter criteria\")\n\t}\n\n\trefundObj := &Refund{}\n\taffected, err := refundObj.BulkUpdate(filter, updates)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"bulk update failed: %v\", err)\n\t}\n\n\tif affected == 0 {\n\t\treturn 0, errors.New(\"no records updated\")\n\t}\n\n\treturn affected, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "基于SessionToken更新",
            "sql": "UPDATE shipping_manifest SET status = ?, updated_at = ? WHERE session_token = ? AND status = 'pending'; SELECT COUNT(*) FROM shipping_manifest WHERE session_token = ? AND status = 'pending';"
          },
          {
            "scenario": "基于Zone和Format更新",
            "sql": "UPDATE shipping_manifest SET status = ?, updated_at = ? WHERE zone = ? AND format = ?; SELECT COUNT(*) FROM shipping_manifest WHERE zone = ? AND format = ?;"
          },
          {
            "scenario": "基于manifest_id等其他条件更新",
            "sql": "UPDATE shipping_manifest SET status = ?, updated_at = ? WHERE manifest_id = ?; SELECT COUNT(*) FROM shipping_manifest WHERE manifest_id = ?;"
          }
        ]
      },
      {
        "type": "LACK_INFORMATION",
        "variants": [
          {
            "scenario": "缺少manifest_id字段定义，使用代码中直接传递的字段名",
            "sql": "manifest_id"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "OTHER"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "ShippingManifest",
        "code_value": "type ShippingManifest struct {\n\tID           int       `json:\"id\" gorm:\"column:id\"`\n\tSessionToken string    `json:\"session_token\" gorm:\"column:session_token\"`\n\tZone         string    `json:\"zone\" gorm:\"column:zone\"`\n\tFormat       string    `json:\"format\" gorm:\"column:format\"`\n\tStatus       string    `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt    time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt    time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "Refund",
        "code_value": "type Refund struct {\n\tID        int       `json:\"id\" gorm:\"column:id\"`\n\tAmount    float64   `json:\"amount\" gorm:\"column:amount\"`\n\tReason    string    `json:\"reason\" gorm:\"column:reason\"`\n\tStatus    string    `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "StatusPending",
        "code_value": "const StatusPending = \"pending\""
      },
      {
        "code_key": "TableShippingManifest",
        "code_value": "const TableShippingManifest = \"shipping_manifest\""
      },
      {
        "code_key": "DefaultZone",
        "code_value": "var DefaultZone = \"east\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ArchiveData",
    "orm_code": "func (p *Paragraph) ArchiveData(filterParams map[string]interface{}, pageSize int) ([]Asset, error) {\n\tvar assets []Asset\n\tdb := base.GetInstance().MainDB().Table(\"media_uploads\")\n\n\tif district, exists := filterParams[\"District\"]; exists {\n\t\tif className, exists := filterParams[\"ClassName\"]; exists {\n\t\t\tdb = db.Where(\"district = ? AND class_name LIKE ?\", district, \"%\"+className.(string)+\"%\")\n\t\t} else {\n\t\t\tdb = db.Where(\"district = ?\", district)\n\t\t}\n\t} else if longitude, exists := filterParams[\"Longitude\"]; exists {\n\t\tdb = db.Where(\"longitude > ?\", longitude)\n\t}\n\n\terr := db.Limit(pageSize).Order(\"created_at DESC\").Find(&assets).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn assets, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "同时提供District和ClassName参数",
            "sql": "SELECT id, district, class_name, longitude, created_at, media_url FROM media_uploads WHERE district = ? AND class_name LIKE ? ORDER BY created_at DESC LIMIT ?;"
          },
          {
            "scenario": "只提供District参数",
            "sql": "SELECT id, district, class_name, longitude, created_at, media_url FROM media_uploads WHERE district = ? ORDER BY created_at DESC LIMIT ?;"
          },
          {
            "scenario": "只提供Longitude参数",
            "sql": "SELECT id, district, class_name, longitude, created_at, media_url FROM media_uploads WHERE longitude > ? ORDER BY created_at DESC LIMIT ?;"
          },
          {
            "scenario": "不提供任何过滤参数",
            "sql": "SELECT id, district, class_name, longitude, created_at, media_url FROM media_uploads ORDER BY created_at DESC LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Asset",
        "code_value": "type Asset struct {\n\tID          uint      `json:\"id\" gorm:\"column:id\"`\n\tDistrict    string    `json:\"district\" gorm:\"column:district\"`\n\tClassName   string    `json:\"class_name\" gorm:\"column:class_name\"`\n\tLongitude   float64   `json:\"longitude\" gorm:\"column:longitude\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tMediaURL    string    `json:\"media_url\" gorm:\"column:media_url\"`\n}"
      },
      {
        "code_key": "FilterParams",
        "code_value": "type FilterParams struct {\n\tDistrict   string\n\tClassName  string\n\tLongitude  float64\n}"
      },
      {
        "code_key": "MediaUploadTable",
        "code_value": "const MediaUploadTable = \"media_uploads\""
      },
      {
        "code_key": "MaxPageSize",
        "code_value": "const MaxPageSize = 100"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ArchiveData",
    "orm_code": "func (p *Paragraph) ArchiveData(filterParams map[string]interface{}, pageSize int) ([]Asset, error) {\n\tvar assets []Asset\n\tdb := base.GetInstance().MainDB().Table(\"media_uploads\")\n\n\tif district, exists := filterParams[\"District\"]; exists {\n\t\tif className, exists := filterParams[\"ClassName\"]; exists {\n\t\t\tdb = db.Where(\"district = ? AND class_name LIKE ?\", district, \"%\"+className.(string)+\"%\")\n\t\t} else {\n\t\t\tdb = db.Where(\"district = ?\", district)\n\t\t}\n\t} else if longitude, exists := filterParams[\"Longitude\"]; exists {\n\t\tdb = db.Where(\"longitude > ?\", longitude)\n\t}\n\n\terr := db.Limit(pageSize).Order(\"created_at DESC\").Find(&assets).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn assets, nil\n}",
    "caller": "func (h *MediaHandler) HandleMediaAssets(req *MediaRequest) ([]Asset, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.DistrictID != \"\" {\n\t\tfilter[\"District\"] = req.DistrictID\n\t} else if req.MinLongitude > 0 {\n\t\tfilter[\"Longitude\"] = req.MinLongitude\n\t} else if req.Category != \"\" {\n\t\tfilter[\"ClassName\"] = req.Category\n\t} else {\n\t\treturn nil, fmt.Errorf(\"at least one filter parameter must be specified\")\n\t}\n\t\n\tpara := &Paragraph{}\n\tassets, err := para.ArchiveData(filter, req.PageSize)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to fetch media assets: %v\", err)\n\t}\n\t\n\tif len(assets) == 0 {\n\t\treturn nil, fmt.Errorf(\"no assets found matching the criteria\")\n\t}\n\t\n\treturn assets, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按DistrictID和类别名称查询",
            "sql": "SELECT id, district, class_name, longitude, created_at, media_url FROM media_uploads WHERE district = ? AND class_name LIKE ? ORDER BY created_at DESC LIMIT ?;"
          },
          {
            "scenario": "仅按DistrictID查询",
            "sql": "SELECT id, district, class_name, longitude, created_at, media_url FROM media_uploads WHERE district = ? ORDER BY created_at DESC LIMIT ?;"
          },
          {
            "scenario": "按最小经度查询",
            "sql": "SELECT id, district, class_name, longitude, created_at, media_url FROM media_uploads WHERE longitude > ? ORDER BY created_at DESC LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Asset",
        "code_value": "type Asset struct {\n\tID          uint      `json:\"id\" gorm:\"column:id\"`\n\tDistrict    string    `json:\"district\" gorm:\"column:district\"`\n\tClassName   string    `json:\"class_name\" gorm:\"column:class_name\"`\n\tLongitude   float64   `json:\"longitude\" gorm:\"column:longitude\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tMediaURL    string    `json:\"media_url\" gorm:\"column:media_url\"`\n}"
      },
      {
        "code_key": "FilterParams",
        "code_value": "type FilterParams struct {\n\tDistrict   string\n\tClassName  string\n\tLongitude  float64\n}"
      },
      {
        "code_key": "MediaUploadTable",
        "code_value": "const MediaUploadTable = \"media_uploads\""
      },
      {
        "code_key": "MaxPageSize",
        "code_value": "const MaxPageSize = 100"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ManageResources",
    "orm_code": "func (h *Hospital) ManageResources(filterParams map[string]interface{}, pageSize int) ([]types.ResourceAllocation, error) {\n\tvar allocations []types.ResourceAllocation\n\tdb := base.GetInstance().MainDB().Table(\"budget_planning\")\n\n\tif dept, ok := filterParams[\"Department\"]; ok {\n\t\tif priority, hasPriority := filterParams[\"SecurityLevel\"]; hasPriority {\n\t\tdb = db.Where(\"department = ? AND security_level >= ?\", dept, priority)\n\t} else {\n\t\tdb = db.Where(\"department LIKE ?\", \"%\"+dept.(string)+\"%\")\n\t}\n\t} else if editor, ok := filterParams[\"Editor\"]; ok {\n\t\tdb = db.Where(\"editor = ? AND status = 'active'\", editor)\n\t}\n\n\terr := db.Scopes(PaginateDB(1, pageSize)).Find(&allocations).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn allocations, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Timezone parameter exists",
            "sql": "SELECT id, timezone, index_name, function_name, status, priority, created_at, updated_at FROM shipping_manifest WHERE timezone = 'UTC' ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "IndexName parameter exists",
            "sql": "SELECT id, timezone, index_name, function_name, status, priority, created_at, updated_at FROM shipping_manifest WHERE index_name LIKE '%test%' ORDER BY updated_at ASC LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "FunctionName parameter exists",
            "sql": "SELECT id, timezone, index_name, function_name, status, priority, created_at, updated_at FROM shipping_manifest WHERE function_name = 'process' AND status = 'active' ORDER BY priority DESC LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "Other filter parameters exist",
            "sql": "SELECT id, timezone, index_name, function_name, status, priority, created_at, updated_at FROM shipping_manifest WHERE status = 'pending' ORDER BY id LIMIT 20 OFFSET 0;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "ResourceAllocation",
        "code_value": "type ResourceAllocation struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tDepartment    string    `json:\"department\" gorm:\"column:department\"`\n\tSecurityLevel int       `json:\"security_level\" gorm:\"column:security_level\"`\n\tEditor        string    `json:\"editor\" gorm:\"column:editor\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n\tAllocatedAt   time.Time `json:\"allocated_at\" gorm:\"column:allocated_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "BudgetTable",
        "code_value": "const BudgetTable = \"budget_planning\""
      },
      {
        "code_key": "ResourceStatus",
        "code_value": "const (\n\tStatusActive = \"active\"\n\tStatusPending = \"pending\"\n\tStatusArchived = \"archived\"\n)"
      },
      {
        "code_key": "DepartmentCache",
        "code_value": "var DepartmentCache = map[string]int{\n\t\"Cardiology\": 1,\n\t\"Neurology\": 2,\n\t\"Orthopedics\": 3,\n\t\"Pediatrics\": 4,\n}"
      },
      {
        "code_key": "AuditRecord",
        "code_value": "type AuditRecord struct {\n\tID        int       `json:\"id\" gorm:\"column:id\"`\n\tAction    string    `json:\"action\" gorm:\"column:action\"`\n\tEditor    string    `json:\"editor\" gorm:\"column:editor\"`\n\tCreatedAt time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tDetails   string    `json:\"details\" gorm:\"column:details\"`\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ManageResources",
    "orm_code": "func (h *Hospital) ManageResources(filterParams map[string]interface{}, pageSize int) ([]types.ResourceAllocation, error) {\n\tvar allocations []types.ResourceAllocation\n\tdb := base.GetInstance().MainDB().Table(\"budget_planning\")\n\n\tif dept, ok := filterParams[\"Department\"]; ok {\n\t\tif priority, hasPriority := filterParams[\"SecurityLevel\"]; hasPriority {\n\t\tdb = db.Where(\"department = ? AND security_level >= ?\", dept, priority)\n\t} else {\n\t\tdb = db.Where(\"department LIKE ?\", \"%\"+dept.(string)+\"%\")\n\t}\n\t} else if editor, ok := filterParams[\"Editor\"]; ok {\n\t\tdb = db.Where(\"editor = ? AND status = 'active'\", editor)\n\t}\n\n\terr := db.Scopes(PaginateDB(1, pageSize)).Find(&allocations).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn allocations, nil\n}",
    "caller": "func (c *ResourceController) HandleResourceAllocation(req *types.ResourceRequest, logger *zap.Logger) ([]types.ResourceAllocation, error) {\n\tfilter := make(map[string]interface{})\n\tif req.DepartmentID != \"\" {\n\t\tfilter[\"Department\"] = req.DepartmentID\n\t\tif req.HighPriority {\n\t\t\tfilter[\"SecurityLevel\"] = 3\n\t\t}\n\t} else if req.ManagerID != 0 {\n\t\tfilter[\"Editor\"] = req.ManagerID\n\t} else if req.ProjectName != \"\" {\n\t\tif len(req.ProjectName) > 50 {\n\t\t\tlogger.Error(\"project name too long\", zap.String(\"project\", req.ProjectName))\n\t\t\treturn nil, errors.New(\"invalid project name\")\n\t\t}\n\t\tfilter[\"Department\"] = req.ProjectName\n\t} else {\n\t\treturn nil, errors.New(\"no valid filter parameters provided\")\n\t}\n\n\thospital := &Hospital{DB: c.DB}\n\tallocations, err := hospital.ManageResources(filter, req.PageSize)\n\tif err != nil {\n\t\tlogger.Error(\"failed to manage resources\", zap.Error(err))\n\t\treturn nil, fmt.Errorf(\"resource allocation error: %w\", err)\n\t}\n\treturn allocations, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "DepartmentID provided and HighPriority is true",
            "sql": "SELECT id, department, security_level, editor, status, allocated_at, updated_at FROM budget_planning WHERE department = ? AND security_level >= ? LIMIT ? OFFSET 0;"
          },
          {
            "scenario": "DepartmentID provided but HighPriority is false",
            "sql": "SELECT id, department, security_level, editor, status, allocated_at, updated_at FROM budget_planning WHERE department LIKE ? LIMIT ? OFFSET 0;"
          },
          {
            "scenario": "ManagerID provided",
            "sql": "SELECT id, department, security_level, editor, status, allocated_at, updated_at FROM budget_planning WHERE editor = ? AND status = 'active' LIMIT ? OFFSET 0;"
          },
          {
            "scenario": "ProjectName provided",
            "sql": "SELECT id, department, security_level, editor, status, allocated_at, updated_at FROM budget_planning WHERE department LIKE ? LIMIT ? OFFSET 0;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ResourceAllocation",
        "code_value": "type ResourceAllocation struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tDepartment    string    `json:\"department\" gorm:\"column:department\"`\n\tSecurityLevel int       `json:\"security_level\" gorm:\"column:security_level\"`\n\tEditor        string    `json:\"editor\" gorm:\"column:editor\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n\tAllocatedAt   time.Time `json:\"allocated_at\" gorm:\"column:allocated_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "BudgetTable",
        "code_value": "const BudgetTable = \"budget_planning\""
      },
      {
        "code_key": "ResourceStatus",
        "code_value": "const (\n\tStatusActive = \"active\"\n\tStatusPending = \"pending\"\n\tStatusArchived = \"archived\"\n)"
      },
      {
        "code_key": "DepartmentCache",
        "code_value": "var DepartmentCache = map[string]int{\n\t\"Cardiology\": 1,\n\t\"Neurology\": 2,\n\t\"Orthopedics\": 3,\n\t\"Pediatrics\": 4,\n}"
      },
      {
        "code_key": "AuditRecord",
        "code_value": "type AuditRecord struct {\n\tID        int       `json:\"id\" gorm:\"column:id\"`\n\tAction    string    `json:\"action\" gorm:\"column:action\"`\n\tEditor    string    `json:\"editor\" gorm:\"column:editor\"`\n\tCreatedAt time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tDetails   string    `json:\"details\" gorm:\"column:details\"`\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ManageResources",
    "orm_code": "func (h *Hospital) ManageResources(filterParams map[string]interface{}, pageSize int) ([]types.ResourceAllocation, error) {\n\tvar allocations []types.ResourceAllocation\n\tdb := base.GetInstance().MainDB().Table(\"budget_planning\")\n\n\tif dept, ok := filterParams[\"Department\"]; ok {\n\t\tif priority, hasPriority := filterParams[\"SecurityLevel\"]; hasPriority {\n\t\tdb = db.Where(\"department = ? AND security_level >= ?\", dept, priority)\n\t} else {\n\t\tdb = db.Where(\"department LIKE ?\", \"%\"+dept.(string)+\"%\")\n\t}\n\t} else if editor, ok := filterParams[\"Editor\"]; ok {\n\t\tdb = db.Where(\"editor = ? AND status = 'active'\", editor)\n\t}\n\n\terr := db.Scopes(PaginateDB(1, pageSize)).Find(&allocations).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn allocations, nil\n}",
    "caller": "func (h *NotificationHandler) HandleShippingNotifications(req *types.ShippingNotificationRequest) ([]types.NotificationResource, error) {\n\tpage, size := utils.Paginate(req.Page, req.Size)\n\tcriteria := make(map[string]interface{})\n\n\tif req.Timezone != \"\" {\n\t\tcriteria[\"Timezone\"] = req.Timezone\n\t} else if req.IndexPattern != \"\" {\n\t\tif len(req.IndexPattern) > 64 {\n\t\t\treturn nil, fmt.Errorf(\"index pattern too long\")\n\t\t}\n\t\tcriteria[\"IndexName\"] = req.IndexPattern\n\t} else if req.FunctionIdentifier != \"\" {\n\t\tcriteria[\"FunctionName\"] = req.FunctionIdentifier\n\t} else {\n\t\tcriteria[\"status\"] = \"pending\"\n\t}\n\n\tnotifier := &Notification{}\n\tresults, err := notifier.ManageResources(criteria, page, size)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to fetch notifications: %v\", err)\n\t}\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "传入Timezone参数",
            "sql": "SELECT id, timezone, index_name, function_name, status, priority, created_at, updated_at FROM shipping_manifest WHERE timezone = 'UTC' ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "传入IndexName参数",
            "sql": "SELECT id, timezone, index_name, function_name, status, priority, created_at, updated_at FROM shipping_manifest WHERE index_name LIKE '%test%' ORDER BY updated_at ASC LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "传入FunctionName参数",
            "sql": "SELECT id, timezone, index_name, function_name, status, priority, created_at, updated_at FROM shipping_manifest WHERE function_name = 'processOrder' AND status = 'active' ORDER BY priority DESC LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "默认情况（不传特定参数）",
            "sql": "SELECT id, timezone, index_name, function_name, status, priority, created_at, updated_at FROM shipping_manifest WHERE status = 'pending' ORDER BY id LIMIT 20 OFFSET 0;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "ResourceAllocation",
        "code_value": "type ResourceAllocation struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tDepartment    string    `json:\"department\" gorm:\"column:department\"`\n\tSecurityLevel int       `json:\"security_level\" gorm:\"column:security_level\"`\n\tEditor        string    `json:\"editor\" gorm:\"column:editor\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n\tAllocatedAt   time.Time `json:\"allocated_at\" gorm:\"column:allocated_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "BudgetTable",
        "code_value": "const BudgetTable = \"budget_planning\""
      },
      {
        "code_key": "ResourceStatus",
        "code_value": "const (\n\tStatusActive = \"active\"\n\tStatusPending = \"pending\"\n\tStatusArchived = \"archived\"\n)"
      },
      {
        "code_key": "DepartmentCache",
        "code_value": "var DepartmentCache = map[string]int{\n\t\"Cardiology\": 1,\n\t\"Neurology\": 2,\n\t\"Orthopedics\": 3,\n\t\"Pediatrics\": 4,\n}"
      },
      {
        "code_key": "AuditRecord",
        "code_value": "type AuditRecord struct {\n\tID        int       `json:\"id\" gorm:\"column:id\"`\n\tAction    string    `json:\"action\" gorm:\"column:action\"`\n\tEditor    string    `json:\"editor\" gorm:\"column:editor\"`\n\tCreatedAt time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tDetails   string    `json:\"details\" gorm:\"column:details\"`\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "AggregateByType",
    "orm_code": "func (a *Armor) AggregateByType(filterParams map[string]interface{}) ([]types.TrainingCertification, error) {\n    var results []types.TrainingCertification\n    db := base.GetInstance().GormDB().Table(\"training_certifications\")\n    \n    if certType, ok := filterParams[\"CertificateType\"]; ok {\n        db = db.Where(\"certificate_type = ?\", certType)\n        if level, exists := filterParams[\"AccessLevel\"]; exists {\n            db = db.Where(\"access_level > ?\", level)\n        }\n    } else if locale, ok := filterParams[\"Locale\"]; ok {\n        db = db.Where(\"locale LIKE ?\", \"%\"+locale.(string)+\"%\")\n    }\n    \n    if err := db.Find(&results).Error; err != nil {\n        if err == gorm.ErrRecordNotFound {\n            return results, nil\n        }\n        return nil, err\n    }\n    return results, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "category parameter provided",
            "sql": "SELECT player_id, MAX(score) as max_score FROM player_profiles WHERE category = ? ORDER BY score DESC;"
          },
          {
            "scenario": "time_range parameter provided",
            "sql": "SELECT player_id, COUNT(*) as total_matches FROM player_profiles WHERE created_at BETWEEN ? AND ? GROUP BY player_id;"
          },
          {
            "scenario": "keywords parameter provided",
            "sql": "SELECT DISTINCT player_id, keywords FROM player_profiles WHERE keywords LIKE ? ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "TrainingCertification",
        "code_value": "type TrainingCertification struct {\n\tID              int       `json:\"id\" gorm:\"column:id\"`\n\tCertificateType string    `json:\"certificate_type\" gorm:\"column:certificate_type\"`\n\tAccessLevel     int       `json:\"access_level\" gorm:\"column:access_level\"`\n\tLocale          string    `json:\"locale\" gorm:\"column:locale\"`\n\tCreatedAt       time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt       time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "Armor",
        "code_value": "type Armor struct {\n\tDB *gorm.DB\n}"
      },
      {
        "code_key": "TrainingFilterParams",
        "code_value": "type TrainingFilterParams struct {\n\tCertificateType string\n\tAccessLevel     int\n\tLocale          string\n}"
      },
      {
        "code_key": "TableNameTrainingCertifications",
        "code_value": "const TableNameTrainingCertifications = \"training_certifications\""
      },
      {
        "code_key": "DefaultAccessLevel",
        "code_value": "const DefaultAccessLevel = 1"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "AggregateByType",
    "orm_code": "func (a *Armor) AggregateByType(filterParams map[string]interface{}) ([]types.TrainingCertification, error) {\n    var results []types.TrainingCertification\n    db := base.GetInstance().GormDB().Table(\"training_certifications\")\n    \n    if certType, ok := filterParams[\"CertificateType\"]; ok {\n        db = db.Where(\"certificate_type = ?\", certType)\n        if level, exists := filterParams[\"AccessLevel\"]; exists {\n            db = db.Where(\"access_level > ?\", level)\n        }\n    } else if locale, ok := filterParams[\"Locale\"]; ok {\n        db = db.Where(\"locale LIKE ?\", \"%\"+locale.(string)+\"%\")\n    }\n    \n    if err := db.Find(&results).Error; err != nil {\n        if err == gorm.ErrRecordNotFound {\n            return results, nil\n        }\n        return nil, err\n    }\n    return results, nil\n}",
    "caller": "func (t *TrainingHandler) HandleTrainingCertification(req *types.CertificationRequest) ([]types.TrainingCertification, error) {\n    filterParams := make(map[string]interface{})\n    \n    if req.CertType != \"\" {\n        filterParams[\"CertificateType\"] = req.CertType\n        if req.MinAccessLevel > 0 {\n            filterParams[\"AccessLevel\"] = req.MinAccessLevel\n        }\n    } else if req.Region != \"\" {\n        if len(req.Region) < 2 {\n            return nil, fmt.Errorf(\"invalid region code\")\n        }\n        filterParams[\"Locale\"] = req.Region\n    } else if req.Status != \"\" {\n        if req.Status != \"active\" && req.Status != \"expired\" {\n            return nil, fmt.Errorf(\"invalid status value\")\n        }\n        filterParams[\"Status\"] = req.Status\n    }\n    \n    armor := &Armor{}\n    certs, err := armor.AggregateByType(filterParams)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to aggregate certifications: %v\", err)\n    }\n    \n    return certs, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "提供CertType和MinAccessLevel",
            "sql": "SELECT id, certificate_type, access_level, locale, created_at, updated_at FROM training_certifications WHERE certificate_type = ? AND access_level > ?;"
          },
          {
            "scenario": "只提供CertType",
            "sql": "SELECT id, certificate_type, access_level, locale, created_at, updated_at FROM training_certifications WHERE certificate_type = ?;"
          },
          {
            "scenario": "提供Region（Locale）",
            "sql": "SELECT id, certificate_type, access_level, locale, created_at, updated_at FROM training_certifications WHERE locale LIKE ?;"
          },
          {
            "scenario": "无任何过滤条件",
            "sql": "SELECT id, certificate_type, access_level, locale, created_at, updated_at FROM training_certifications;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "TrainingCertification",
        "code_value": "type TrainingCertification struct {\n\tID              int       `json:\"id\" gorm:\"column:id\"`\n\tCertificateType string    `json:\"certificate_type\" gorm:\"column:certificate_type\"`\n\tAccessLevel     int       `json:\"access_level\" gorm:\"column:access_level\"`\n\tLocale          string    `json:\"locale\" gorm:\"column:locale\"`\n\tCreatedAt       time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt       time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "Armor",
        "code_value": "type Armor struct {\n\tDB *gorm.DB\n}"
      },
      {
        "code_key": "TrainingFilterParams",
        "code_value": "type TrainingFilterParams struct {\n\tCertificateType string\n\tAccessLevel     int\n\tLocale          string\n}"
      },
      {
        "code_key": "TableNameTrainingCertifications",
        "code_value": "const TableNameTrainingCertifications = \"training_certifications\""
      },
      {
        "code_key": "DefaultAccessLevel",
        "code_value": "const DefaultAccessLevel = 1"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "AggregateByType",
    "orm_code": "func (a *Armor) AggregateByType(filterParams map[string]interface{}) ([]types.TrainingCertification, error) {\n    var results []types.TrainingCertification\n    db := base.GetInstance().GormDB().Table(\"training_certifications\")\n    \n    if certType, ok := filterParams[\"CertificateType\"]; ok {\n        db = db.Where(\"certificate_type = ?\", certType)\n        if level, exists := filterParams[\"AccessLevel\"]; exists {\n            db = db.Where(\"access_level > ?\", level)\n        }\n    } else if locale, ok := filterParams[\"Locale\"]; ok {\n        db = db.Where(\"locale LIKE ?\", \"%\"+locale.(string)+\"%\")\n    }\n    \n    if err := db.Find(&results).Error; err != nil {\n        if err == gorm.ErrRecordNotFound {\n            return results, nil\n        }\n        return nil, err\n    }\n    return results, nil\n}",
    "caller": "func (s *StatsService) HandlePlayerStats(req *types.PlayerStatsRequest) ([]types.RankingResult, error) {\n\tif req == nil {\n\t\treturn nil, errors.New(\"nil request\")\n\t}\n\n\tfilterOpts := make(map[string]interface{})\n\n\tif req.Category != \"\" {\n\t\tfilterOpts[\"category\"] = req.Category\n\t} else if req.StartTime != nil && req.EndTime != nil {\n\t\tfilterOpts[\"time_range\"] = []time.Time{*req.StartTime, *req.EndTime}\n\t} else if req.SearchText != \"\" {\n\t\tfilterOpts[\"keywords\"] = req.SearchText\n\t} else {\n\t\treturn nil, errors.New(\"invalid filter criteria\")\n\t}\n\n\trankProcessor := &Ranking{}\n\tstats, err := rankProcessor.AggregateByType(filterOpts)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to aggregate stats: %w\", err)\n\t}\n\n\treturn stats, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按category过滤",
            "sql": "SELECT player_id, MAX(score) as max_score FROM player_profiles WHERE category = ? ORDER BY score DESC;"
          },
          {
            "scenario": "按时间范围过滤",
            "sql": "SELECT player_id, COUNT(*) as total_matches FROM player_profiles WHERE created_at BETWEEN ? AND ? GROUP BY player_id;"
          },
          {
            "scenario": "按keywords搜索",
            "sql": "SELECT DISTINCT player_id, keywords FROM player_profiles WHERE keywords LIKE ? ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "TrainingCertification",
        "code_value": "type TrainingCertification struct {\n\tID              int       `json:\"id\" gorm:\"column:id\"`\n\tCertificateType string    `json:\"certificate_type\" gorm:\"column:certificate_type\"`\n\tAccessLevel     int       `json:\"access_level\" gorm:\"column:access_level\"`\n\tLocale          string    `json:\"locale\" gorm:\"column:locale\"`\n\tCreatedAt       time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt       time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "Armor",
        "code_value": "type Armor struct {\n\tDB *gorm.DB\n}"
      },
      {
        "code_key": "TrainingFilterParams",
        "code_value": "type TrainingFilterParams struct {\n\tCertificateType string\n\tAccessLevel     int\n\tLocale          string\n}"
      },
      {
        "code_key": "TableNameTrainingCertifications",
        "code_value": "const TableNameTrainingCertifications = \"training_certifications\""
      },
      {
        "code_key": "DefaultAccessLevel",
        "code_value": "const DefaultAccessLevel = 1"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CacheData",
    "orm_code": "func (a *Achievement) CacheData(filters map[string]interface{}, limit int) ([]types.SecurityClearance, error) {\n\tvar results []types.SecurityClearance\n\tdb := base.GetInstance().GormDriver().Table(\"security_clearances\")\n\n\tif namespace, ok := filters[\"NamespaceName\"]; ok {\n\t\tif appId, exists := filters[\"ApplicationId\"]; exists {\n\t\t\tdb = db.Where(\"namespace_name = ? AND application_id = ?\", namespace, appId)\n\t\t} else {\n\t\t\tdb = db.Where(\"namespace_name LIKE ?\", \"%\"+namespace.(string)+\"%\")\n\t\t}\n\t} else if content, ok := filters[\"Content\"]; ok {\n\t\tdb = db.Where(\"content LIKE ?\", \"%\"+content.(string)+\"%\")\n\t}\n\n\terr := db.Limit(limit).Find(&results).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "提供NamespaceName和ApplicationId",
            "sql": "SELECT id, namespace_name, application_id, content, created_at, updated_at FROM security_clearances WHERE namespace_name = ? AND application_id = ? LIMIT ?;"
          },
          {
            "scenario": "仅提供NamespaceName",
            "sql": "SELECT id, namespace_name, application_id, content, created_at, updated_at FROM security_clearances WHERE namespace_name LIKE ? LIMIT ?;"
          },
          {
            "scenario": "仅提供Content",
            "sql": "SELECT id, namespace_name, application_id, content, created_at, updated_at FROM security_clearances WHERE content LIKE ? LIMIT ?;"
          },
          {
            "scenario": "不提供任何过滤条件",
            "sql": "SELECT id, namespace_name, application_id, content, created_at, updated_at FROM security_clearances LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "SecurityClearance",
        "code_value": "type SecurityClearance struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tNamespaceName string    `json:\"namespace_name\" gorm:\"column:namespace_name\"`\n\tApplicationId int       `json:\"application_id\" gorm:\"column:application_id\"`\n\tContent       string    `json:\"content\" gorm:\"column:content\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "ClearanceFilter",
        "code_value": "type ClearanceFilter struct {\n\tNamespaceName string\n\tApplicationId int\n\tContent       string\n}"
      },
      {
        "code_key": "ClearanceResponse",
        "code_value": "type ClearanceResponse struct {\n\tData      []SecurityClearance `json:\"data\"`\n\tTotal     int                 `json:\"total\"`\n\tPage      int                 `json:\"page\"`\n\tLimit     int                 `json:\"limit\"`\n\tTimestamp time.Time           `json:\"timestamp\"`\n}"
      },
      {
        "code_key": "TableSecurityClearances",
        "code_value": "const TableSecurityClearances = \"security_clearances\""
      },
      {
        "code_key": "DefaultQueryLimit",
        "code_value": "const DefaultQueryLimit = 100"
      },
      {
        "code_key": "SecurityStatus",
        "code_value": "const (\n\tStatusPending = iota\n\tStatusApproved\n\tStatusRejected\n)"
      },
      {
        "code_key": "GlobalClearanceCache",
        "code_value": "var GlobalClearanceCache = sync.Map{}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CacheData",
    "orm_code": "func (a *Achievement) CacheData(filters map[string]interface{}, limit int) ([]types.SecurityClearance, error) {\n\tvar results []types.SecurityClearance\n\tdb := base.GetInstance().GormDriver().Table(\"security_clearances\")\n\n\tif namespace, ok := filters[\"NamespaceName\"]; ok {\n\t\tif appId, exists := filters[\"ApplicationId\"]; exists {\n\t\t\tdb = db.Where(\"namespace_name = ? AND application_id = ?\", namespace, appId)\n\t\t} else {\n\t\t\tdb = db.Where(\"namespace_name LIKE ?\", \"%\"+namespace.(string)+\"%\")\n\t\t}\n\t} else if content, ok := filters[\"Content\"]; ok {\n\t\tdb = db.Where(\"content LIKE ?\", \"%\"+content.(string)+\"%\")\n\t}\n\n\terr := db.Limit(limit).Find(&results).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}",
    "caller": "func (h *Handler) HandleUserClearance(req *types.ClearanceRequest, log *logger.AppLog) ([]types.SecurityClearance, error) {\n\tfilters := make(map[string]interface{})\n\t\n\tif req.UserID != \"\" {\n\t\tfilters[\"user_id\"] = req.UserID\n\t} else if req.Department != \"\" {\n\t\tif req.Level > 0 {\n\t\t\tfilters[\"department\"] = req.Department\n\t\t\tfilters[\"clearance_level\"] = req.Level\n\t\t} else {\n\t\t\tfilters[\"department\"] = req.Department\n\t\t}\n\t} else if req.ClearanceType != \"\" {\n\t\tfilters[\"clearance_type\"] = req.ClearanceType\n\t} else {\n\t\treturn nil, fmt.Errorf(\"at least one filter parameter must be provided\")\n\t}\n\n\tach := &Achievement{}\n\tresult, err := ach.CacheData(filters, req.Limit)\n\tif err != nil {\n\t\tlog.Error(\"Failed to get clearance data\", \"error\", err)\n\t\treturn nil, err\n\t}\n\t\n\treturn result, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "只提供user_id",
            "sql": "SELECT id, namespace_name, application_id, content, created_at, updated_at FROM security_clearances WHERE user_id = ? LIMIT ?;"
          },
          {
            "scenario": "只提供department",
            "sql": "SELECT id, namespace_name, application_id, content, created_at, updated_at FROM security_clearances WHERE department = ? LIMIT ?;"
          },
          {
            "scenario": "同时提供department和clearance_level",
            "sql": "SELECT id, namespace_name, application_id, content, created_at, updated_at FROM security_clearances WHERE department = ? AND clearance_level = ? LIMIT ?;"
          },
          {
            "scenario": "只提供clearance_type",
            "sql": "SELECT id, namespace_name, application_id, content, created_at, updated_at FROM security_clearances WHERE clearance_type = ? LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "SecurityClearance",
        "code_value": "type SecurityClearance struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tNamespaceName string    `json:\"namespace_name\" gorm:\"column:namespace_name\"`\n\tApplicationId int       `json:\"application_id\" gorm:\"column:application_id\"`\n\tContent       string    `json:\"content\" gorm:\"column:content\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "ClearanceFilter",
        "code_value": "type ClearanceFilter struct {\n\tNamespaceName string\n\tApplicationId int\n\tContent       string\n}"
      },
      {
        "code_key": "ClearanceResponse",
        "code_value": "type ClearanceResponse struct {\n\tData      []SecurityClearance `json:\"data\"`\n\tTotal     int                 `json:\"total\"`\n\tPage      int                 `json:\"page\"`\n\tLimit     int                 `json:\"limit\"`\n\tTimestamp time.Time           `json:\"timestamp\"`\n}"
      },
      {
        "code_key": "TableSecurityClearances",
        "code_value": "const TableSecurityClearances = \"security_clearances\""
      },
      {
        "code_key": "DefaultQueryLimit",
        "code_value": "const DefaultQueryLimit = 100"
      },
      {
        "code_key": "SecurityStatus",
        "code_value": "const (\n\tStatusPending = iota\n\tStatusApproved\n\tStatusRejected\n)"
      },
      {
        "code_key": "GlobalClearanceCache",
        "code_value": "var GlobalClearanceCache = sync.Map{}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "SelectByRange",
    "orm_code": "func (g *Game) SelectByRange(filter map[string]interface{}, page, size int) ([]types.TournamentRecord, error) {\n\tvar records []types.TournamentRecord\n\tdb := base.GetInstance().Gorm().Table(\"tournament_brackets\").Scopes(PaginateDB(page, size))\n\n\tif module, ok := filter[\"ModuleName\"]; ok {\n\t\tdb = db.Where(\"module_name = ?\", module)\n\t\tif status, exists := filter[\"CurrentStatus\"]; exists {\n\t\t\tdb = db.Where(\"current_status = ?\", status)\n\t\t}\n\t} else if mobile, ok := filter[\"MobileNumber\"]; ok {\n\t\tdb = db.Where(\"mobile_number LIKE ?\", \"%\"+mobile.(string)+\"%\")\n\t} else {\n\t\tdb = db.Where(filter)\n\t}\n\n\terr := db.Order(\"created_at DESC\").Find(&records).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.RecordNotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "提供RegionCode参数",
            "sql": "SELECT id, region_code, department, zip_code, amount, allocated_at FROM expense_reports WHERE region_code = ? AND department = ? ORDER BY allocated_at DESC;"
          },
          {
            "scenario": "提供DateFrom参数，不提供DateTo参数",
            "sql": "SELECT id, region_code, department, zip_code, amount, allocated_at FROM expense_reports WHERE allocated_at >= ? AND department = ? LIMIT 100;"
          },
          {
            "scenario": "提供DateFrom和DateTo参数",
            "sql": "SELECT id, region_code, department, zip_code, amount, allocated_at FROM expense_reports WHERE allocated_at BETWEEN ? AND ? LIMIT 100;"
          },
          {
            "scenario": "提供ZipCode参数",
            "sql": "SELECT id, region_code, department, zip_code, amount, allocated_at FROM expense_reports WHERE zip_code LIKE ? AND department = ? LIMIT 100;"
          },
          {
            "scenario": "无主要过滤条件",
            "sql": "SELECT id, region_code, department, zip_code, amount, allocated_at FROM expense_reports WHERE department = ? LIMIT 100;"
          },
          {
            "scenario": "完全无过滤条件",
            "sql": "SELECT id, region_code, department, zip_code, amount, allocated_at FROM expense_reports LIMIT 100;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "TournamentRecord",
        "code_value": "type TournamentRecord struct {\n\tID            uint      `gorm:\"column:id;primaryKey\"`\n\tModuleName    string    `gorm:\"column:module_name\"`\n\tCurrentStatus int       `gorm:\"column:current_status\"`\n\tMobileNumber  string    `gorm:\"column:mobile_number\"`\n\tCreatedAt     time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "TournamentStatus",
        "code_value": "const (\n\tStatusPending = iota + 1\n\tStatusInProgress\n\tStatusCompleted\n\tStatusCancelled\n)"
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "TournamentFilter",
        "code_value": "type TournamentFilter struct {\n\tModuleName    string\n\tCurrentStatus int\n\tMobileNumber  string\n\tStartDate     time.Time\n\tEndDate       time.Time\n}"
      },
      {
        "code_key": "TournamentResponse",
        "code_value": "type TournamentResponse struct {\n\tRecords      []TournamentRecord `json:\"records\"`\n\tTotalCount   int                `json:\"total_count\"`\n\tCurrentPage  int                `json:\"current_page\"`\n\tTotalPages   int                `json:\"total_pages\"`\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "SelectByRange",
    "orm_code": "func (g *Game) SelectByRange(filter map[string]interface{}, page, size int) ([]types.TournamentRecord, error) {\n\tvar records []types.TournamentRecord\n\tdb := base.GetInstance().Gorm().Table(\"tournament_brackets\").Scopes(PaginateDB(page, size))\n\n\tif module, ok := filter[\"ModuleName\"]; ok {\n\t\tdb = db.Where(\"module_name = ?\", module)\n\t\tif status, exists := filter[\"CurrentStatus\"]; exists {\n\t\t\tdb = db.Where(\"current_status = ?\", status)\n\t\t}\n\t} else if mobile, ok := filter[\"MobileNumber\"]; ok {\n\t\tdb = db.Where(\"mobile_number LIKE ?\", \"%\"+mobile.(string)+\"%\")\n\t} else {\n\t\tdb = db.Where(filter)\n\t}\n\n\terr := db.Order(\"created_at DESC\").Find(&records).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.RecordNotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "caller": "func (s *ScheduleService) HandleDoctorSchedule(req *types.ScheduleRequest) ([]types.DoctorSchedule, error) {\n\tfilter := make(map[string]interface{})\n\tif req.DoctorID > 0 {\n\t\tfilter[\"doctor_id\"] = req.DoctorID\n\t} else if len(req.Department) > 0 {\n\t\tif len(req.Department) > 50 {\n\t\t\treturn nil, errors.New(\"department name too long\")\n\t\t}\n\t\tfilter[\"department\"] = req.Department\n\t} else if !req.StartDate.IsZero() && !req.EndDate.IsZero() {\n\t\tif req.EndDate.Before(req.StartDate) {\n\t\t\treturn nil, errors.New(\"end date must be after start date\")\n\t\t}\n\t\tfilter[\"date\"] = map[string]interface{}{\"$gte\": req.StartDate, \"$lte\": req.EndDate}\n\t} else {\n\t\treturn nil, errors.New(\"at least one filter condition required\")\n\t}\n\n\tdoctor := &model.Doctor{}\n\tschedules, err := doctor.SelectByRange(filter, req.Page, req.PageSize)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to query schedules: %w\", err)\n\t}\n\treturn schedules, nil\n}",
    "sql_statement_list": [
      {
        "type": "LACK_INFORMATION",
        "variants": [
          {
            "scenario": "调用者传递的过滤字段(doctor_id/department/date)与目标表tournament_brackets的字段不匹配",
            "sql": ""
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "当filter中包含ModuleName时",
            "sql": "SELECT id, module_name, current_status, mobile_number, created_at, updated_at FROM tournament_brackets WHERE module_name = ? AND current_status = ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "当filter中包含MobileNumber时",
            "sql": "SELECT id, module_name, current_status, mobile_number, created_at, updated_at FROM tournament_brackets WHERE mobile_number LIKE ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "当filter中包含其他键值对时",
            "sql": "SELECT id, module_name, current_status, mobile_number, created_at, updated_at FROM tournament_brackets WHERE [filter_key] = ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "OTHER",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "TournamentRecord",
        "code_value": "type TournamentRecord struct {\n\tID            uint      `gorm:\"column:id;primaryKey\"`\n\tModuleName    string    `gorm:\"column:module_name\"`\n\tCurrentStatus int       `gorm:\"column:current_status\"`\n\tMobileNumber  string    `gorm:\"column:mobile_number\"`\n\tCreatedAt     time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "TournamentStatus",
        "code_value": "const (\n\tStatusPending = iota + 1\n\tStatusInProgress\n\tStatusCompleted\n\tStatusCancelled\n)"
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "TournamentFilter",
        "code_value": "type TournamentFilter struct {\n\tModuleName    string\n\tCurrentStatus int\n\tMobileNumber  string\n\tStartDate     time.Time\n\tEndDate       time.Time\n}"
      },
      {
        "code_key": "TournamentResponse",
        "code_value": "type TournamentResponse struct {\n\tRecords      []TournamentRecord `json:\"records\"`\n\tTotalCount   int                `json:\"total_count\"`\n\tCurrentPage  int                `json:\"current_page\"`\n\tTotalPages   int                `json:\"total_pages\"`\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "SelectByRange",
    "orm_code": "func (g *Game) SelectByRange(filter map[string]interface{}, page, size int) ([]types.TournamentRecord, error) {\n\tvar records []types.TournamentRecord\n\tdb := base.GetInstance().Gorm().Table(\"tournament_brackets\").Scopes(PaginateDB(page, size))\n\n\tif module, ok := filter[\"ModuleName\"]; ok {\n\t\tdb = db.Where(\"module_name = ?\", module)\n\t\tif status, exists := filter[\"CurrentStatus\"]; exists {\n\t\t\tdb = db.Where(\"current_status = ?\", status)\n\t\t}\n\t} else if mobile, ok := filter[\"MobileNumber\"]; ok {\n\t\tdb = db.Where(\"mobile_number LIKE ?\", \"%\"+mobile.(string)+\"%\")\n\t} else {\n\t\tdb = db.Where(filter)\n\t}\n\n\terr := db.Order(\"created_at DESC\").Find(&records).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.RecordNotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "caller": "func (h *BudgetHandler) HandleBudgetAllocations(req *types.BudgetRequest) ([]types.BudgetAllocation, error) {\n\tif req == nil {\n\t\treturn nil, errors.New(\"invalid request\")\n\t}\n\n\tfilterParams := make(map[string]interface{})\n\tif req.Region != \"\" {\n\t\tfilterParams[\"RegionCode\"] = req.Region\n\t} else if !req.StartDate.IsZero() {\n\t\tfilterParams[\"DateFrom\"] = req.StartDate\n\t\tif !req.EndDate.IsZero() {\n\t\t\tfilterParams[\"DateTo\"] = req.EndDate\n\t\t}\n\t} else if req.PostalCode != \"\" {\n\t\tfilterParams[\"ZipCode\"] = req.PostalCode\n\t}\n\n\tif req.DepartmentID > 0 {\n\t\tfilterParams[\"Department\"] = req.DepartmentID\n\t}\n\n\tproject := &Project{}\n\tallocations, err := project.SelectByRange(filterParams)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get budget allocations: %w\", err)\n\t}\n\treturn allocations, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "RegionCode only",
            "sql": "SELECT * FROM expense_reports WHERE region_code = ? ORDER BY allocated_at DESC;"
          },
          {
            "scenario": "RegionCode with Department",
            "sql": "SELECT * FROM expense_reports WHERE region_code = ? AND department = ? ORDER BY allocated_at DESC;"
          },
          {
            "scenario": "DateFrom only",
            "sql": "SELECT * FROM expense_reports WHERE allocated_at >= ? LIMIT 100;"
          },
          {
            "scenario": "DateFrom with Department",
            "sql": "SELECT * FROM expense_reports WHERE allocated_at >= ? AND department = ? LIMIT 100;"
          },
          {
            "scenario": "DateFrom and DateTo",
            "sql": "SELECT * FROM expense_reports WHERE allocated_at BETWEEN ? AND ? LIMIT 100;"
          },
          {
            "scenario": "DateFrom and DateTo with Department",
            "sql": "SELECT * FROM expense_reports WHERE allocated_at BETWEEN ? AND ? AND department = ? LIMIT 100;"
          },
          {
            "scenario": "ZipCode only",
            "sql": "SELECT * FROM expense_reports WHERE zip_code LIKE ? LIMIT 100;"
          },
          {
            "scenario": "ZipCode with Department",
            "sql": "SELECT * FROM expense_reports WHERE zip_code LIKE ? AND department = ? LIMIT 100;"
          },
          {
            "scenario": "No specific condition",
            "sql": "SELECT * FROM expense_reports LIMIT 100;"
          },
          {
            "scenario": "Department only",
            "sql": "SELECT * FROM expense_reports WHERE department = ? LIMIT 100;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "TournamentRecord",
        "code_value": "type TournamentRecord struct {\n\tID            uint      `gorm:\"column:id;primaryKey\"`\n\tModuleName    string    `gorm:\"column:module_name\"`\n\tCurrentStatus int       `gorm:\"column:current_status\"`\n\tMobileNumber  string    `gorm:\"column:mobile_number\"`\n\tCreatedAt     time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "TournamentStatus",
        "code_value": "const (\n\tStatusPending = iota + 1\n\tStatusInProgress\n\tStatusCompleted\n\tStatusCancelled\n)"
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "TournamentFilter",
        "code_value": "type TournamentFilter struct {\n\tModuleName    string\n\tCurrentStatus int\n\tMobileNumber  string\n\tStartDate     time.Time\n\tEndDate       time.Time\n}"
      },
      {
        "code_key": "TournamentResponse",
        "code_value": "type TournamentResponse struct {\n\tRecords      []TournamentRecord `json:\"records\"`\n\tTotalCount   int                `json:\"total_count\"`\n\tCurrentPage  int                `json:\"current_page\"`\n\tTotalPages   int                `json:\"total_pages\"`\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "PurgeExpiredRecords",
    "orm_code": "func (e *Event) PurgeExpiredRecords(filters map[string]interface{}) ([]types.NotificationEvent, error) {\n\tvar events []types.NotificationEvent\n\tquery := base.GetInstance().GormDB().Table(\"notification_queue\").Where(\"expired_at < NOW()\")\n\n\tif editor, ok := filters[\"Editor\"]; ok {\n\t\tquery = query.Where(\"editor = ? AND status = ?\", editor.(string), \"pending\")\n\t} else if timezone, ok := filters[\"Timezone\"]; ok {\n\t\tquery = query.Where(\"timezone IN (?) AND priority > 5\", timezone.([]string))\n\t} else {\n\t\tquery = query.Where(filters)\n\t}\n\n\tif err := query.Find(&events).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn events, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "包含edition条件",
            "sql": "SELECT COUNT(*) FROM publications WHERE edition = ? AND expiration_date < NOW();"
          },
          {
            "scenario": "包含edition条件",
            "sql": "DELETE FROM publications WHERE edition = ? AND expiration_date < NOW();"
          },
          {
            "scenario": "包含rating条件",
            "sql": "SELECT COUNT(*) FROM publications WHERE rating < ? AND expiration_date < NOW();"
          },
          {
            "scenario": "包含rating条件",
            "sql": "DELETE FROM publications WHERE rating < ? AND expiration_date < NOW();"
          },
          {
            "scenario": "包含latitude和longitude条件",
            "sql": "SELECT COUNT(*) FROM publications WHERE latitude BETWEEN ? AND ? AND longitude BETWEEN ? AND ? AND expiration_date < NOW();"
          },
          {
            "scenario": "包含latitude和longitude条件",
            "sql": "DELETE FROM publications WHERE latitude BETWEEN ? AND ? AND longitude BETWEEN ? AND ? AND expiration_date < NOW();"
          },
          {
            "scenario": "无特定条件",
            "sql": "SELECT COUNT(*) FROM publications WHERE expiration_date < NOW();"
          },
          {
            "scenario": "无特定条件",
            "sql": "DELETE FROM publications WHERE expiration_date < NOW();"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "NotificationEvent",
        "code_value": "type NotificationEvent struct {\n\tID        uint      `gorm:\"column:id;primaryKey\"`\n\tEditor    string    `gorm:\"column:editor\"`\n\tStatus    string    `gorm:\"column:status\"`\n\tTimezone  string    `gorm:\"column:timezone\"`\n\tPriority  int       `gorm:\"column:priority\"`\n\tExpiredAt time.Time `gorm:\"column:expired_at\"`\n\tCreatedAt time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "EventFilter",
        "code_value": "type EventFilter struct {\n\tEditor   string\n\tTimezone []string\n\tStatus   string\n\tPriority int\n}"
      },
      {
        "code_key": "NotificationStatus",
        "code_value": "const (\n\tStatusPending   = \"pending\"\n\tStatusSent     = \"sent\"\n\tStatusFailed   = \"failed\"\n\tStatusCanceled = \"canceled\"\n)"
      },
      {
        "code_key": "TableName",
        "code_value": "const NotificationQueueTable = \"notification_queue\""
      },
      {
        "code_key": "PriorityThreshold",
        "code_value": "const HighPriorityThreshold = 5"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "PurgeExpiredRecords",
    "orm_code": "func (e *Event) PurgeExpiredRecords(filters map[string]interface{}) ([]types.NotificationEvent, error) {\n\tvar events []types.NotificationEvent\n\tquery := base.GetInstance().GormDB().Table(\"notification_queue\").Where(\"expired_at < NOW()\")\n\n\tif editor, ok := filters[\"Editor\"]; ok {\n\t\tquery = query.Where(\"editor = ? AND status = ?\", editor.(string), \"pending\")\n\t} else if timezone, ok := filters[\"Timezone\"]; ok {\n\t\tquery = query.Where(\"timezone IN (?) AND priority > 5\", timezone.([]string))\n\t} else {\n\t\tquery = query.Where(filters)\n\t}\n\n\tif err := query.Find(&events).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn events, nil\n}",
    "caller": "func (h *NotificationHandler) HandleExpiredNotifications(req *types.ExpiredNotificationRequest) ([]types.NotificationEvent, error) {\n\tfilters := make(map[string]interface{})\n\t\n\tif req.UserID != \"\" {\n\t\tfilters[\"Editor\"] = req.UserID\n\t} else if len(req.Regions) > 0 {\n\t\tfilters[\"Timezone\"] = req.Regions\n\t} else if req.PriorityThreshold > 0 {\n\t\tfilters[\"priority\"] = req.PriorityThreshold\n\t} else {\n\t\tfilters[\"status\"] = \"expired\"\n\t}\n\n\tevent := &Event{}\n\texpiredEvents, err := event.PurgeExpiredRecords(filters)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to purge expired records: %v\", err)\n\t}\n\n\tif len(expiredEvents) == 0 {\n\t\treturn nil, nil\n\t}\n\treturn expiredEvents, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "req.UserID不为空",
            "sql": "SELECT id, editor, status, timezone, priority, expired_at, created_at, updated_at FROM notification_queue WHERE expired_at < NOW() AND editor = ? AND status = ?;"
          },
          {
            "scenario": "req.UserID为空但req.Regions不为空",
            "sql": "SELECT id, editor, status, timezone, priority, expired_at, created_at, updated_at FROM notification_queue WHERE expired_at < NOW() AND timezone IN (?) AND priority > 5;"
          },
          {
            "scenario": "req.UserID和req.Regions都为空，但req.PriorityThreshold > 0",
            "sql": "SELECT id, editor, status, timezone, priority, expired_at, created_at, updated_at FROM notification_queue WHERE expired_at < NOW() AND priority = ?;"
          },
          {
            "scenario": "所有条件都为空",
            "sql": "SELECT id, editor, status, timezone, priority, expired_at, created_at, updated_at FROM notification_queue WHERE expired_at < NOW() AND status = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "NotificationEvent",
        "code_value": "type NotificationEvent struct {\n\tID        uint      `gorm:\"column:id;primaryKey\"`\n\tEditor    string    `gorm:\"column:editor\"`\n\tStatus    string    `gorm:\"column:status\"`\n\tTimezone  string    `gorm:\"column:timezone\"`\n\tPriority  int       `gorm:\"column:priority\"`\n\tExpiredAt time.Time `gorm:\"column:expired_at\"`\n\tCreatedAt time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "EventFilter",
        "code_value": "type EventFilter struct {\n\tEditor   string\n\tTimezone []string\n\tStatus   string\n\tPriority int\n}"
      },
      {
        "code_key": "NotificationStatus",
        "code_value": "const (\n\tStatusPending   = \"pending\"\n\tStatusSent     = \"sent\"\n\tStatusFailed   = \"failed\"\n\tStatusCanceled = \"canceled\"\n)"
      },
      {
        "code_key": "TableName",
        "code_value": "const NotificationQueueTable = \"notification_queue\""
      },
      {
        "code_key": "PriorityThreshold",
        "code_value": "const HighPriorityThreshold = 5"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "PurgeExpiredRecords",
    "orm_code": "func (e *Event) PurgeExpiredRecords(filters map[string]interface{}) ([]types.NotificationEvent, error) {\n\tvar events []types.NotificationEvent\n\tquery := base.GetInstance().GormDB().Table(\"notification_queue\").Where(\"expired_at < NOW()\")\n\n\tif editor, ok := filters[\"Editor\"]; ok {\n\t\tquery = query.Where(\"editor = ? AND status = ?\", editor.(string), \"pending\")\n\t} else if timezone, ok := filters[\"Timezone\"]; ok {\n\t\tquery = query.Where(\"timezone IN (?) AND priority > 5\", timezone.([]string))\n\t} else {\n\t\tquery = query.Where(filters)\n\t}\n\n\tif err := query.Find(&events).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn events, nil\n}",
    "caller": "func (s *PublicationService) HandlePublicationCleanup(cleanupType string, value interface{}) (int64, error) {\n\tcriteria := make(map[string]interface{})\n\tswitch cleanupType {\n\tcase \"edition\":\n\t\tif edition, ok := value.(string); ok {\n\t\t\tcriteria[\"edition\"] = edition\n\t\t} else {\n\t\t\treturn 0, fmt.Errorf(\"invalid edition value type\")\n\t\t}\n\tcase \"rating\":\n\t\tif rating, ok := value.(float64); ok {\n\t\t\tcriteria[\"rating\"] = rating\n\t\t} else {\n\t\t\treturn 0, fmt.Errorf(\"invalid rating value type\")\n\t\t}\n\tcase \"location\":\n\t\tif coords, ok := value.(map[string]float64); ok {\n\t\t\tcriteria[\"latitude\"] = coords[\"latitude\"]\n\t\t\tcriteria[\"longitude\"] = coords[\"longitude\"]\n\t\t} else {\n\t\t\treturn 0, fmt.Errorf(\"invalid location coordinates\")\n\t\t}\n\tdefault:\n\t\t// No criteria, will trigger default purge\n\t}\n\n\tpub := &Publication{}\n\tdeletedCount, err := pub.PurgeExpiredRecords(criteria)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"publication cleanup failed: %v\", err)\n\t}\n\treturn deletedCount, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按版本(edition)清理",
            "sql": "SELECT COUNT(*) FROM publications WHERE edition = ? AND expiration_date < NOW();"
          },
          {
            "scenario": "按版本(edition)清理",
            "sql": "DELETE FROM publications WHERE edition = ? AND expiration_date < NOW();"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按评分(rating)清理",
            "sql": "SELECT COUNT(*) FROM publications WHERE rating < ? AND expiration_date < NOW();"
          },
          {
            "scenario": "按评分(rating)清理",
            "sql": "DELETE FROM publications WHERE rating < ? AND expiration_date < NOW();"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按地理位置(location)清理",
            "sql": "SELECT COUNT(*) FROM publications WHERE latitude BETWEEN ? AND ? AND longitude BETWEEN ? AND ? AND expiration_date < NOW();"
          },
          {
            "scenario": "按地理位置(location)清理",
            "sql": "DELETE FROM publications WHERE latitude BETWEEN ? AND ? AND longitude BETWEEN ? AND ? AND expiration_date < NOW();"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "默认清理所有过期的",
            "sql": "SELECT COUNT(*) FROM publications WHERE expiration_date < NOW();"
          },
          {
            "scenario": "默认清理所有过期的",
            "sql": "DELETE FROM publications WHERE expiration_date < NOW();"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "NotificationEvent",
        "code_value": "type NotificationEvent struct {\n\tID        uint      `gorm:\"column:id;primaryKey\"`\n\tEditor    string    `gorm:\"column:editor\"`\n\tStatus    string    `gorm:\"column:status\"`\n\tTimezone  string    `gorm:\"column:timezone\"`\n\tPriority  int       `gorm:\"column:priority\"`\n\tExpiredAt time.Time `gorm:\"column:expired_at\"`\n\tCreatedAt time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "EventFilter",
        "code_value": "type EventFilter struct {\n\tEditor   string\n\tTimezone []string\n\tStatus   string\n\tPriority int\n}"
      },
      {
        "code_key": "NotificationStatus",
        "code_value": "const (\n\tStatusPending   = \"pending\"\n\tStatusSent     = \"sent\"\n\tStatusFailed   = \"failed\"\n\tStatusCanceled = \"canceled\"\n)"
      },
      {
        "code_key": "TableName",
        "code_value": "const NotificationQueueTable = \"notification_queue\""
      },
      {
        "code_key": "PriorityThreshold",
        "code_value": "const HighPriorityThreshold = 5"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "MonitorActivity",
    "orm_code": "func (a *Account) MonitorActivity(filterParams map[string]interface{}, limit int) ([]types.Statement, error) {\n\tvar activities []types.Statement\n\tquery := base.GetInstance().GormDB().Table(\"exam_results\")\n\n\tif projectCode, exists := filterParams[\"ProjectCode\"]; exists {\n\t\tquery = query.Where(\"project_code = ?\", projectCode)\n\t\tif shipmentId, ok := filterParams[\"ShipmentId\"]; ok {\n\t\t\tquery = query.Where(\"shipment_id = ?\", shipmentId)\n\t\t}\n\t} else if columnName, exists := filterParams[\"ColumnName\"]; exists {\n\t\tquery = query.Where(\"column_name LIKE ?\", \"%\"+columnName.(string)+\"%\")\n\t}\n\n\tif limit > 0 {\n\t\tquery = query.Limit(limit)\n\t}\n\n\terr := query.Order(\"created_at DESC\").Find(&activities).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn activities, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按IP地址模糊查询",
            "sql": "SELECT id, ip_address, case_number, sub_category, timestamp, details FROM dispatch_orders WHERE ip_address LIKE '%?%' ORDER BY timestamp DESC LIMIT ?;"
          },
          {
            "scenario": "按案例编号精确查询",
            "sql": "SELECT id, ip_address, case_number, sub_category, timestamp, details FROM dispatch_orders WHERE case_number = ? ORDER BY timestamp DESC LIMIT ?;"
          },
          {
            "scenario": "按子类别集合查询",
            "sql": "SELECT id, ip_address, case_number, sub_category, timestamp, details FROM dispatch_orders WHERE sub_category IN (?) ORDER BY timestamp DESC LIMIT ?;"
          },
          {
            "scenario": "无过滤条件，仅分页查询",
            "sql": "SELECT id, ip_address, case_number, sub_category, timestamp, details FROM dispatch_orders ORDER BY timestamp DESC LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "Statement",
        "code_value": "type Statement struct {\n\tID          int       `json:\"id\" gorm:\"column:id\"`\n\tProjectCode string    `json:\"project_code\" gorm:\"column:project_code\"`\n\tShipmentId  string    `json:\"shipment_id\" gorm:\"column:shipment_id\"`\n\tColumnName  string    `json:\"column_name\" gorm:\"column:column_name\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "ActivityFilter",
        "code_value": "type ActivityFilter struct {\n\tProjectCode string\n\tShipmentId  string\n\tColumnName  string\n\tLimit       int\n}"
      },
      {
        "code_key": "ExamResultTable",
        "code_value": "const ExamResultTable = \"exam_results\""
      },
      {
        "code_key": "DefaultQueryLimit",
        "code_value": "const DefaultQueryLimit = 100"
      },
      {
        "code_key": "ActivityResponse",
        "code_value": "type ActivityResponse struct {\n\tStatements []Statement `json:\"statements\"`\n\tError      string      `json:\"error,omitempty\"`\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "MonitorActivity",
    "orm_code": "func (a *Account) MonitorActivity(filterParams map[string]interface{}, limit int) ([]types.Statement, error) {\n\tvar activities []types.Statement\n\tquery := base.GetInstance().GormDB().Table(\"exam_results\")\n\n\tif projectCode, exists := filterParams[\"ProjectCode\"]; exists {\n\t\tquery = query.Where(\"project_code = ?\", projectCode)\n\t\tif shipmentId, ok := filterParams[\"ShipmentId\"]; ok {\n\t\t\tquery = query.Where(\"shipment_id = ?\", shipmentId)\n\t\t}\n\t} else if columnName, exists := filterParams[\"ColumnName\"]; exists {\n\t\tquery = query.Where(\"column_name LIKE ?\", \"%\"+columnName.(string)+\"%\")\n\t}\n\n\tif limit > 0 {\n\t\tquery = query.Limit(limit)\n\t}\n\n\terr := query.Order(\"created_at DESC\").Find(&activities).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn activities, nil\n}",
    "caller": "func (g *GameHandler) HandleGameStatements(req *types.GameStatementRequest) ([]types.Statement, error) {\n\tfilter := make(map[string]interface{})\n\tif req.GameID != \"\" {\n\t\tfilter[\"ProjectCode\"] = req.GameID\n\t\tif req.SessionID != \"\" {\n\t\t\tfilter[\"ShipmentId\"] = req.SessionID\n\t\t}\n\t} else if req.PlayerName != \"\" {\n\t\tif len(req.PlayerName) < 3 {\n\t\t\treturn nil, fmt.Errorf(\"player name must be at least 3 characters\")\n\t\t}\n\t\tfilter[\"ColumnName\"] = req.PlayerName\n\t} else if req.Status > 0 {\n\t\tfilter[\"status\"] = req.Status\n\t} else {\n\t\treturn nil, fmt.Errorf(\"at least one filter parameter is required\")\n\t}\n\n\taccount := &Account{}\n\tlimit := 0\n\tif req.Limit > 0 {\n\t\tlimit = req.Limit\n\t}\n\n\tstatements, err := account.MonitorActivity(filter, limit)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to monitor game activity: %v\", err)\n\t}\n\n\treturn statements, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "GameID and SessionID provided",
            "sql": "SELECT id, project_code, shipment_id, column_name, created_at FROM exam_results WHERE project_code = ? AND shipment_id = ? ORDER BY created_at DESC LIMIT ?;"
          },
          {
            "scenario": "Only GameID provided",
            "sql": "SELECT id, project_code, shipment_id, column_name, created_at FROM exam_results WHERE project_code = ? ORDER BY created_at DESC LIMIT ?;"
          },
          {
            "scenario": "PlayerName (ColumnName) provided",
            "sql": "SELECT id, project_code, shipment_id, column_name, created_at FROM exam_results WHERE column_name LIKE ? ORDER BY created_at DESC LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Statement",
        "code_value": "type Statement struct {\n\tID          int       `json:\"id\" gorm:\"column:id\"`\n\tProjectCode string    `json:\"project_code\" gorm:\"column:project_code\"`\n\tShipmentId  string    `json:\"shipment_id\" gorm:\"column:shipment_id\"`\n\tColumnName  string    `json:\"column_name\" gorm:\"column:column_name\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "ActivityFilter",
        "code_value": "type ActivityFilter struct {\n\tProjectCode string\n\tShipmentId  string\n\tColumnName  string\n\tLimit       int\n}"
      },
      {
        "code_key": "ExamResultTable",
        "code_value": "const ExamResultTable = \"exam_results\""
      },
      {
        "code_key": "DefaultQueryLimit",
        "code_value": "const DefaultQueryLimit = 100"
      },
      {
        "code_key": "ActivityResponse",
        "code_value": "type ActivityResponse struct {\n\tStatements []Statement `json:\"statements\"`\n\tError      string      `json:\"error,omitempty\"`\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "MonitorActivity",
    "orm_code": "func (a *Account) MonitorActivity(filterParams map[string]interface{}, limit int) ([]types.Statement, error) {\n\tvar activities []types.Statement\n\tquery := base.GetInstance().GormDB().Table(\"exam_results\")\n\n\tif projectCode, exists := filterParams[\"ProjectCode\"]; exists {\n\t\tquery = query.Where(\"project_code = ?\", projectCode)\n\t\tif shipmentId, ok := filterParams[\"ShipmentId\"]; ok {\n\t\t\tquery = query.Where(\"shipment_id = ?\", shipmentId)\n\t\t}\n\t} else if columnName, exists := filterParams[\"ColumnName\"]; exists {\n\t\tquery = query.Where(\"column_name LIKE ?\", \"%\"+columnName.(string)+\"%\")\n\t}\n\n\tif limit > 0 {\n\t\tquery = query.Limit(limit)\n\t}\n\n\terr := query.Order(\"created_at DESC\").Find(&activities).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn activities, nil\n}",
    "caller": "func (s *SecurityService) HandleSecurityLogs(req *types.SecurityLogRequest) ([]types.SecurityLog, error) {\n\tif req == nil {\n\t\treturn nil, fmt.Errorf(\"invalid request parameters\")\n\t}\n\n\tfilterOpts := make(map[string]interface{})\n\tif req.SearchIP != \"\" {\n\t\tfilterOpts[\"ip_address\"] = req.SearchIP\n\t} else if req.CaseID != 0 {\n\t\tfilterOpts[\"case_number\"] = strconv.Itoa(req.CaseID)\n\t} else if len(req.SubCategories) > 0 {\n\t\tfilterOpts[\"sub_category\"] = req.SubCategories\n\t}\n\n\temp := &Employee{ID: req.UserID}\n\tlogs, err := emp.MonitorActivity(filterOpts, req.PageSize)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to monitor activity: %v\", err)\n\t}\n\n\tif len(logs) == 0 {\n\t\treturn nil, nil\n\t}\n\treturn logs, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按IP地址搜索",
            "sql": "SELECT * FROM dispatch_orders WHERE ip_address LIKE '%192.168%' ORDER BY timestamp DESC LIMIT 10;"
          },
          {
            "scenario": "按案件编号搜索",
            "sql": "SELECT * FROM dispatch_orders WHERE case_number = '12345' ORDER BY timestamp DESC LIMIT 20;"
          },
          {
            "scenario": "按子分类搜索",
            "sql": "SELECT * FROM dispatch_orders WHERE sub_category IN ('login', 'logout') ORDER BY timestamp DESC LIMIT 5;"
          },
          {
            "scenario": "无过滤条件",
            "sql": "SELECT * FROM dispatch_orders ORDER BY timestamp DESC LIMIT 15;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "Statement",
        "code_value": "type Statement struct {\n\tID          int       `json:\"id\" gorm:\"column:id\"`\n\tProjectCode string    `json:\"project_code\" gorm:\"column:project_code\"`\n\tShipmentId  string    `json:\"shipment_id\" gorm:\"column:shipment_id\"`\n\tColumnName  string    `json:\"column_name\" gorm:\"column:column_name\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "ActivityFilter",
        "code_value": "type ActivityFilter struct {\n\tProjectCode string\n\tShipmentId  string\n\tColumnName  string\n\tLimit       int\n}"
      },
      {
        "code_key": "ExamResultTable",
        "code_value": "const ExamResultTable = \"exam_results\""
      },
      {
        "code_key": "DefaultQueryLimit",
        "code_value": "const DefaultQueryLimit = 100"
      },
      {
        "code_key": "ActivityResponse",
        "code_value": "type ActivityResponse struct {\n\tStatements []Statement `json:\"statements\"`\n\tError      string      `json:\"error,omitempty\"`\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "MeasureEfficiency",
    "orm_code": "func (z *Zone) MeasureEfficiency(filters map[string]interface{}, page, size int) ([]types.EfficiencyMetric, error) {\n\tmetrics := make([]types.EfficiencyMetric, 0)\n\tvar err error\n\tcomment := z.CommentFunc(SELECT_COMMENT)\n\tdb := base.GetInstance().GormDriver().Clauses(comment).Table(\"treatment_plans\")\n\n\tif functionName, exists := filters[\"FunctionName\"]; exists {\n\t\tfilter := make(map[string]interface{})\n\t\tfor k, v := range filters {\n\t\t\tif k == \"FunctionName\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfilter[k] = v\n\t\t}\n\t\terr = db.Where(\"function_name LIKE ?\", \"%\"+functionName.(string)+\"%\").\n\t\t\tOrder(\"created_at DESC\").\n\t\t\tScopes(PaginateDB(page, size)).\n\t\t\tFind(&metrics).Error\n\t} else if certificateId, exists := filters[\"CertificateId\"]; exists {\n\t\terr = db.Where(\"certificate_id = ? AND status = ?\", certificateId, \"active\").\n\t\t\tOrder(\"updated_at\").\n\t\t\tScopes(PaginateDB(page, size)).\n\t\t\tFind(&metrics).Error\n\t} else {\n\t\terr = db.Where(filters).\n\t\t\tScopes(PaginateDB(page, size)).\n\t\t\tFind(&metrics).Error\n\t}\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn metrics, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "包含ApprovalLevel和MinAccessLevel的条件",
            "sql": "SELECT diagnostic_results.id, diagnostic_results.skill_name, diagnostic_results.efficiency_score, diagnostic_results.approval_level, diagnostic_results.access_level, diagnostic_results.modification_date FROM diagnostic_results WHERE approval_level = ? AND access_level >= ?;"
          },
          {
            "scenario": "包含TimeRange的条件并按efficiency_score降序排序",
            "sql": "SELECT diagnostic_results.id, diagnostic_results.skill_name, diagnostic_results.efficiency_score, diagnostic_results.approval_level, diagnostic_results.access_level, diagnostic_results.modification_date FROM diagnostic_results WHERE modification_date BETWEEN ? AND ? ORDER BY efficiency_score DESC;"
          },
          {
            "scenario": "包含SkillPattern的模糊匹配条件",
            "sql": "SELECT diagnostic_results.id, diagnostic_results.skill_name, diagnostic_results.efficiency_score, diagnostic_results.approval_level, diagnostic_results.access_level, diagnostic_results.modification_date FROM diagnostic_results WHERE skill_name LIKE ?;"
          },
          {
            "scenario": "直接应用filter的条件",
            "sql": "SELECT diagnostic_results.id, diagnostic_results.skill_name, diagnostic_results.efficiency_score, diagnostic_results.approval_level, diagnostic_results.access_level, diagnostic_results.modification_date FROM diagnostic_results WHERE access_level = ? AND efficiency_score > ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "EfficiencyMetric",
        "code_value": "type EfficiencyMetric struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tFunctionName  string    `json:\"function_name\" gorm:\"column:function_name\"`\n\tCertificateId string    `json:\"certificate_id\" gorm:\"column:certificate_id\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n\tEfficiency    float64   `json:\"efficiency\" gorm:\"column:efficiency\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "TreatmentPlanStatus",
        "code_value": "const (\n\tTreatmentPlanActive   = \"active\"\n\tTreatmentPlanInactive = \"inactive\"\n\tTreatmentPlanDraft    = \"draft\"\n)"
      },
      {
        "code_key": "SELECT_COMMENT",
        "code_value": "const SELECT_COMMENT = \"/* MeasureEfficiency */\""
      },
      {
        "code_key": "Zone",
        "code_value": "type Zone struct {\n\tCommentFunc func(string) string\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "MeasureEfficiency",
    "orm_code": "func (z *Zone) MeasureEfficiency(filters map[string]interface{}, page, size int) ([]types.EfficiencyMetric, error) {\n\tmetrics := make([]types.EfficiencyMetric, 0)\n\tvar err error\n\tcomment := z.CommentFunc(SELECT_COMMENT)\n\tdb := base.GetInstance().GormDriver().Clauses(comment).Table(\"treatment_plans\")\n\n\tif functionName, exists := filters[\"FunctionName\"]; exists {\n\t\tfilter := make(map[string]interface{})\n\t\tfor k, v := range filters {\n\t\t\tif k == \"FunctionName\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfilter[k] = v\n\t\t}\n\t\terr = db.Where(\"function_name LIKE ?\", \"%\"+functionName.(string)+\"%\").\n\t\t\tOrder(\"created_at DESC\").\n\t\t\tScopes(PaginateDB(page, size)).\n\t\t\tFind(&metrics).Error\n\t} else if certificateId, exists := filters[\"CertificateId\"]; exists {\n\t\terr = db.Where(\"certificate_id = ? AND status = ?\", certificateId, \"active\").\n\t\t\tOrder(\"updated_at\").\n\t\t\tScopes(PaginateDB(page, size)).\n\t\t\tFind(&metrics).Error\n\t} else {\n\t\terr = db.Where(filters).\n\t\t\tScopes(PaginateDB(page, size)).\n\t\t\tFind(&metrics).Error\n\t}\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn metrics, nil\n}",
    "caller": "func (h *TimelineHandler) HandleTimelineMetrics(req *types.TimelineRequest, log *logger.AppLog) ([]types.EfficiencyMetric, error) {\n\tzone := &Zone{CommentFunc: DefaultCommentGenerator}\n\tfilters := make(map[string]interface{})\n\tpage, size := utils.ParsePagination(req.Page, req.Size)\n\n\tif req.TreatmentID != \"\" {\n\t\tfilters[\"treatment_id\"] = req.TreatmentID\n\t} else if req.PatientName != \"\" {\n\t\tif err := validatePatientName(req.PatientName); err != nil {\n\t\t\tlog.Error(\"Invalid patient name\", \"error\", err)\n\t\t\treturn nil, err\n\t\t}\n\t\tfilters[\"FunctionName\"] = req.PatientName\n\t} else if req.Status != \"\" {\n\t\tif !isValidStatus(req.Status) {\n\t\t\tlog.Error(\"Invalid status value\", \"status\", req.Status)\n\t\t\treturn nil, fmt.Errorf(\"invalid status: %s\", req.Status)\n\t\t}\n\t\tfilters[\"status\"] = req.Status\n\t\tfilters[\"CertificateId\"] = req.CertificateID\n\t} else {\n\t\tfilters[\"department\"] = req.Department\n\t}\n\n\tmetrics, err := zone.MeasureEfficiency(filters, page, size)\n\tif err != nil {\n\t\tlog.Error(\"Failed to measure efficiency\", \"error\", err)\n\t\treturn nil, fmt.Errorf(\"measurement failed: %w\", err)\n\t}\n\treturn metrics, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "req.TreatmentID不为空",
            "sql": "SELECT id, function_name, certificate_id, status, efficiency, created_at, updated_at FROM treatment_plans WHERE treatment_id = ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "req.PatientName不为空",
            "sql": "SELECT id, function_name, certificate_id, status, efficiency, created_at, updated_at FROM treatment_plans WHERE function_name LIKE ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "req.Status不为空且有效的状态值",
            "sql": "SELECT id, function_name, certificate_id, status, efficiency, created_at, updated_at FROM treatment_plans WHERE certificate_id = ? AND status = ? ORDER BY updated_at LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "默认情况（department不为空）",
            "sql": "SELECT id, function_name, certificate_id, status, efficiency, created_at, updated_at FROM treatment_plans WHERE department = ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "EfficiencyMetric",
        "code_value": "type EfficiencyMetric struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tFunctionName  string    `json:\"function_name\" gorm:\"column:function_name\"`\n\tCertificateId string    `json:\"certificate_id\" gorm:\"column:certificate_id\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n\tEfficiency    float64   `json:\"efficiency\" gorm:\"column:efficiency\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "TreatmentPlanStatus",
        "code_value": "const (\n\tTreatmentPlanActive   = \"active\"\n\tTreatmentPlanInactive = \"inactive\"\n\tTreatmentPlanDraft    = \"draft\"\n)"
      },
      {
        "code_key": "SELECT_COMMENT",
        "code_value": "const SELECT_COMMENT = \"/* MeasureEfficiency */\""
      },
      {
        "code_key": "Zone",
        "code_value": "type Zone struct {\n\tCommentFunc func(string) string\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "MeasureEfficiency",
    "orm_code": "func (z *Zone) MeasureEfficiency(filters map[string]interface{}, page, size int) ([]types.EfficiencyMetric, error) {\n\tmetrics := make([]types.EfficiencyMetric, 0)\n\tvar err error\n\tcomment := z.CommentFunc(SELECT_COMMENT)\n\tdb := base.GetInstance().GormDriver().Clauses(comment).Table(\"treatment_plans\")\n\n\tif functionName, exists := filters[\"FunctionName\"]; exists {\n\t\tfilter := make(map[string]interface{})\n\t\tfor k, v := range filters {\n\t\t\tif k == \"FunctionName\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfilter[k] = v\n\t\t}\n\t\terr = db.Where(\"function_name LIKE ?\", \"%\"+functionName.(string)+\"%\").\n\t\t\tOrder(\"created_at DESC\").\n\t\t\tScopes(PaginateDB(page, size)).\n\t\t\tFind(&metrics).Error\n\t} else if certificateId, exists := filters[\"CertificateId\"]; exists {\n\t\terr = db.Where(\"certificate_id = ? AND status = ?\", certificateId, \"active\").\n\t\t\tOrder(\"updated_at\").\n\t\t\tScopes(PaginateDB(page, size)).\n\t\t\tFind(&metrics).Error\n\t} else {\n\t\terr = db.Where(filters).\n\t\t\tScopes(PaginateDB(page, size)).\n\t\t\tFind(&metrics).Error\n\t}\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn metrics, nil\n}",
    "caller": "func (h *AppointmentHandler) HandleAppointmentEfficiency(req *types.EfficiencyRequest) ([]types.EfficiencyMetric, error) {\n\tif req == nil {\n\t\treturn nil, fmt.Errorf(\"invalid request\")\n\t}\n\n\tefficiencyFilter := make(map[string]interface{})\n\n\tswitch {\n\tcase req.ApprovalLevel > 0:\n\t\tefficiencyFilter[\"ApprovalLevel\"] = req.ApprovalLevel\n\t\tefficiencyFilter[\"MinAccessLevel\"] = 3\n\tcase !req.TimeRange.Start.IsZero() && !req.TimeRange.End.IsZero():\n\t\tefficiencyFilter[\"TimeRange\"] = map[string]interface{}{\n\t\t\t\"Start\": req.TimeRange.Start,\n\t\t\t\"End\": req.TimeRange.End,\n\t\t}\n\tcase req.SkillPattern != \"\":\n\t\tefficiencyFilter[\"SkillPattern\"] = req.SkillPattern\n\tdefault:\n\t\tefficiencyFilter[\"status\"] = \"completed\"\n\t}\n\n\tskillObj := &Skill{Code: req.SkillCode}\n\tresults, err := skillObj.MeasureEfficiency(efficiencyFilter)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to handle appointment efficiency: %w\", err)\n\t}\n\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "ApprovalLevel > 0",
            "sql": "SELECT id, skill_name, efficiency_score, approval_level, access_level, modification_date FROM diagnostic_results WHERE approval_level = ? AND access_level >= ?;"
          },
          {
            "scenario": "TimeRange with valid start and end",
            "sql": "SELECT id, skill_name, efficiency_score, approval_level, access_level, modification_date FROM diagnostic_results WHERE modification_date BETWEEN ? AND ? ORDER BY efficiency_score DESC;"
          },
          {
            "scenario": "SkillPattern not empty",
            "sql": "SELECT id, skill_name, efficiency_score, approval_level, access_level, modification_date FROM diagnostic_results WHERE skill_name LIKE ?;"
          },
          {
            "scenario": "Default case",
            "sql": "SELECT id, skill_name, efficiency_score, approval_level, access_level, modification_date FROM diagnostic_results WHERE status = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "EfficiencyMetric",
        "code_value": "type EfficiencyMetric struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tFunctionName  string    `json:\"function_name\" gorm:\"column:function_name\"`\n\tCertificateId string    `json:\"certificate_id\" gorm:\"column:certificate_id\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n\tEfficiency    float64   `json:\"efficiency\" gorm:\"column:efficiency\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "TreatmentPlanStatus",
        "code_value": "const (\n\tTreatmentPlanActive   = \"active\"\n\tTreatmentPlanInactive = \"inactive\"\n\tTreatmentPlanDraft    = \"draft\"\n)"
      },
      {
        "code_key": "SELECT_COMMENT",
        "code_value": "const SELECT_COMMENT = \"/* MeasureEfficiency */\""
      },
      {
        "code_key": "Zone",
        "code_value": "type Zone struct {\n\tCommentFunc func(string) string\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "QueryByCondition",
    "orm_code": "func (p *Proposal) QueryByCondition(filter map[string]interface{}, page, size int) ([]types.ProposalRecord, error) {\n\trecords := make([]types.ProposalRecord, 0)\n\tquery := base.GetInstance().GormDriver().Table(\"progress_tracking\").Scopes(PaginateDB(page, size))\n\n\tif approval, ok := filter[\"ApprovalLevel\"]; ok {\n\t\tquery = query.Where(\"approval_level = ?\", approval)\n\t\tdelete(filter, \"ApprovalLevel\")\n\t} else if timezone, ok := filter[\"Timezone\"]; ok {\n\t\tquery = query.Where(\"timezone LIKE ?\", \"%\"+timezone.(string)+\"%\")\n\t\tdelete(filter, \"Timezone\")\n\t}\n\n\tif len(filter) > 0 {\n\t\tquery = query.Where(filter)\n\t}\n\n\terr := query.Order(\"created_at DESC\").Find(&records).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn records, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Subject condition",
            "sql": "SELECT * FROM author_profiles WHERE subject LIKE '%test%' ORDER BY created_at DESC LIMIT 10 OFFSET 0;"
          },
          {
            "scenario": "RecordId condition",
            "sql": "SELECT * FROM author_profiles WHERE id = 123 ORDER BY created_at DESC LIMIT 10 OFFSET 0;"
          },
          {
            "scenario": "Latitude condition",
            "sql": "SELECT * FROM author_profiles WHERE ABS(latitude - 40.7128) < 0.1 ORDER BY created_at DESC LIMIT 10 OFFSET 0;"
          },
          {
            "scenario": "Other filter conditions",
            "sql": "SELECT * FROM author_profiles WHERE title = 'test' AND status = 1 ORDER BY created_at DESC LIMIT 10 OFFSET 0;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "ProposalRecord",
        "code_value": "type ProposalRecord struct {\n\tID            uint      `json:\"id\" gorm:\"column:id\"`\n\tTitle         string    `json:\"title\" gorm:\"column:title\"`\n\tApprovalLevel int       `json:\"approval_level\" gorm:\"column:approval_level\"`\n\tTimezone      string    `json:\"timezone\" gorm:\"column:timezone\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "ApprovalStatus",
        "code_value": "const (\n\tPendingApproval = \"pending\"\n\tApproved        = \"approved\"\n\tRejected        = \"rejected\"\n)"
      },
      {
        "code_key": "TableName",
        "code_value": "const ProgressTrackingTable = \"progress_tracking\""
      },
      {
        "code_key": "ProposalFilter",
        "code_value": "type ProposalFilter struct {\n\tTitle         *string\n\tApprovalLevel *int\n\tTimezone      *string\n\tStatus        *string\n}"
      },
      {
        "code_key": "PaginationConfig",
        "code_value": "var DefaultPagination = struct {\n\tPageSize int\n\tMaxSize  int\n}{\n\tPageSize: 10,\n\tMaxSize:  100,\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "QueryByCondition",
    "orm_code": "func (p *Proposal) QueryByCondition(filter map[string]interface{}, page, size int) ([]types.ProposalRecord, error) {\n\trecords := make([]types.ProposalRecord, 0)\n\tquery := base.GetInstance().GormDriver().Table(\"progress_tracking\").Scopes(PaginateDB(page, size))\n\n\tif approval, ok := filter[\"ApprovalLevel\"]; ok {\n\t\tquery = query.Where(\"approval_level = ?\", approval)\n\t\tdelete(filter, \"ApprovalLevel\")\n\t} else if timezone, ok := filter[\"Timezone\"]; ok {\n\t\tquery = query.Where(\"timezone LIKE ?\", \"%\"+timezone.(string)+\"%\")\n\t\tdelete(filter, \"Timezone\")\n\t}\n\n\tif len(filter) > 0 {\n\t\tquery = query.Where(filter)\n\t}\n\n\terr := query.Order(\"created_at DESC\").Find(&records).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn records, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "caller": "func (h *InvestmentHandler) HandleInvestmentProposals(req *types.InvestmentRequest, log *utils.AppLogger) ([]types.ProposalRecord, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.InvestmentID != \"\" {\n\t\tfilter[\"investment_id\"] = req.InvestmentID\n\t} else if req.Status != 0 {\n\t\tif req.Status < 1 || req.Status > 5 {\n\t\t\tlog.Error(\"Invalid status value\")\n\t\t\treturn nil, errors.New(\"invalid status parameter\")\n\t\t}\n\t\tfilter[\"ApprovalLevel\"] = req.Status\n\t} else if req.ProjectName != \"\" {\n\t\tif len(req.ProjectName) > 100 {\n\t\t\tlog.Error(\"Project name too long\")\n\t\t\treturn nil, errors.New(\"project name exceeds limit\")\n\t\t}\n\t\tfilter[\"project_name\"] = req.ProjectName\n\t} else {\n\t\tfilter[\"is_active\"] = true\n\t}\n\n\tproposal := &Proposal{}\n\trecords, err := proposal.QueryByCondition(filter, req.Page, req.Size)\n\tif err != nil {\n\t\tlog.Errorf(\"Failed to query proposals: %v\", err)\n\t\treturn nil, err\n\t}\n\t\n\treturn records, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "filter contains investment_id",
            "sql": "SELECT id, title, approval_level, timezone, status, created_at, updated_at FROM progress_tracking WHERE investment_id = ? AND is_active = ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "filter contains ApprovalLevel",
            "sql": "SELECT id, title, approval_level, timezone, status, created_at, updated_at FROM progress_tracking WHERE approval_level = ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "filter contains project_name",
            "sql": "SELECT id, title, approval_level, timezone, status, created_at, updated_at FROM progress_tracking WHERE project_name = ? AND is_active = ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "default filter with is_active only",
            "sql": "SELECT id, title, approval_level, timezone, status, created_at, updated_at FROM progress_tracking WHERE is_active = ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ProposalRecord",
        "code_value": "type ProposalRecord struct {\n\tID            uint      `json:\"id\" gorm:\"column:id\"`\n\tTitle         string    `json:\"title\" gorm:\"column:title\"`\n\tApprovalLevel int       `json:\"approval_level\" gorm:\"column:approval_level\"`\n\tTimezone      string    `json:\"timezone\" gorm:\"column:timezone\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "ApprovalStatus",
        "code_value": "const (\n\tPendingApproval = \"pending\"\n\tApproved        = \"approved\"\n\tRejected        = \"rejected\"\n)"
      },
      {
        "code_key": "TableName",
        "code_value": "const ProgressTrackingTable = \"progress_tracking\""
      },
      {
        "code_key": "ProposalFilter",
        "code_value": "type ProposalFilter struct {\n\tTitle         *string\n\tApprovalLevel *int\n\tTimezone      *string\n\tStatus        *string\n}"
      },
      {
        "code_key": "PaginationConfig",
        "code_value": "var DefaultPagination = struct {\n\tPageSize int\n\tMaxSize  int\n}{\n\tPageSize: 10,\n\tMaxSize:  100,\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "QueryByCondition",
    "orm_code": "func (p *Proposal) QueryByCondition(filter map[string]interface{}, page, size int) ([]types.ProposalRecord, error) {\n\trecords := make([]types.ProposalRecord, 0)\n\tquery := base.GetInstance().GormDriver().Table(\"progress_tracking\").Scopes(PaginateDB(page, size))\n\n\tif approval, ok := filter[\"ApprovalLevel\"]; ok {\n\t\tquery = query.Where(\"approval_level = ?\", approval)\n\t\tdelete(filter, \"ApprovalLevel\")\n\t} else if timezone, ok := filter[\"Timezone\"]; ok {\n\t\tquery = query.Where(\"timezone LIKE ?\", \"%\"+timezone.(string)+\"%\")\n\t\tdelete(filter, \"Timezone\")\n\t}\n\n\tif len(filter) > 0 {\n\t\tquery = query.Where(filter)\n\t}\n\n\terr := query.Order(\"created_at DESC\").Find(&records).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn records, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "caller": "func (h *StoryHandler) HandleStorySearch(req *types.StorySearchRequest) ([]types.StoryRecord, error) {\n\tsearchParams := make(map[string]interface{})\n\t\n\tif req.Subject != \"\" {\n\t\tsearchParams[\"Subject\"] = req.Subject\n\t} else if req.RecordID > 0 {\n\t\tsearchParams[\"RecordId\"] = req.RecordID\n\t} else if req.Latitude != 0 {\n\t\tsearchParams[\"Latitude\"] = req.Latitude\n\t} else {\n\t\tsearchParams[\"author_id\"] = req.AuthorID\n\t}\n\n\tpage, size := h.normalizePagination(req.Page, req.Size)\n\tstory := &Story{}\n\n\tresults, err := story.QueryByCondition(searchParams, page, size)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"story search failed: %w\", err)\n\t}\n\treturn results, nil\n}\n\nfunc (h *StoryHandler) normalizePagination(page, size int) (int, int) {\n\tif page <= 0 {\n\t\tpage = 1\n\t}\n\tif size <= 0 || size > 100 {\n\t\tsize = 20\n\t}\n\treturn page, size\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Subject not empty",
            "sql": "SELECT * FROM author_profiles WHERE subject LIKE '%?%' ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "RecordID > 0",
            "sql": "SELECT * FROM author_profiles WHERE id = ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "Latitude != 0",
            "sql": "SELECT * FROM author_profiles WHERE ABS(latitude - ?) < 0.1 ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "Default case (AuthorID not empty)",
            "sql": "SELECT * FROM author_profiles WHERE author_id = ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "ProposalRecord",
        "code_value": "type ProposalRecord struct {\n\tID            uint      `json:\"id\" gorm:\"column:id\"`\n\tTitle         string    `json:\"title\" gorm:\"column:title\"`\n\tApprovalLevel int       `json:\"approval_level\" gorm:\"column:approval_level\"`\n\tTimezone      string    `json:\"timezone\" gorm:\"column:timezone\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "ApprovalStatus",
        "code_value": "const (\n\tPendingApproval = \"pending\"\n\tApproved        = \"approved\"\n\tRejected        = \"rejected\"\n)"
      },
      {
        "code_key": "TableName",
        "code_value": "const ProgressTrackingTable = \"progress_tracking\""
      },
      {
        "code_key": "ProposalFilter",
        "code_value": "type ProposalFilter struct {\n\tTitle         *string\n\tApprovalLevel *int\n\tTimezone      *string\n\tStatus        *string\n}"
      },
      {
        "code_key": "PaginationConfig",
        "code_value": "var DefaultPagination = struct {\n\tPageSize int\n\tMaxSize  int\n}{\n\tPageSize: 10,\n\tMaxSize:  100,\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "GenerateMetrics",
    "orm_code": "func (n *Notification) GenerateMetrics(filterParams map[string]interface{}, limit int) ([]types.NotificationMetrics, error) {\n\tvar metrics []types.NotificationMetrics\n\tdb := base.GetInstance().DefaultDriver().Table(\"player_rankings\")\n\n\tif edition, ok := filterParams[\"Edition\"]; ok {\n\t\tif currentStatus, exists := filterParams[\"CurrentStatus\"]; exists {\n\t\tdb = db.Where(\"edition = ? AND current_status = ?\", edition, currentStatus)\n\t} else {\n\t\tdb = db.Where(\"edition LIKE ?\", \"%\"+edition.(string)+\"%\")\n\t}\n\t} else if caseNumber, ok := filterParams[\"CaseNumber\"]; ok {\n\t\tdb = db.Where(\"case_number = ?\", caseNumber)\n\t} else {\n\t\tdb = db.Where(filterParams)\n\t}\n\n\terr := db.Limit(limit).Find(&metrics).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.MetricsNotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn metrics, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "提供Edition和CurrentStatus",
            "sql": "SELECT id, edition, current_status, case_number, created_at, updated_at FROM player_rankings WHERE edition = ? AND current_status = ? LIMIT ?;"
          },
          {
            "scenario": "仅提供Edition（使用LIKE模糊匹配）",
            "sql": "SELECT id, edition, current_status, case_number, created_at, updated_at FROM player_rankings WHERE edition LIKE ? LIMIT ?;"
          },
          {
            "scenario": "仅提供CaseNumber",
            "sql": "SELECT id, edition, current_status, case_number, created_at, updated_at FROM player_rankings WHERE case_number = ? LIMIT ?;"
          },
          {
            "scenario": "提供其他过滤条件",
            "sql": "SELECT id, edition, current_status, case_number, created_at, updated_at FROM player_rankings WHERE created_at = ? LIMIT ?;"
          },
          {
            "scenario": "不提供任何过滤条件",
            "sql": "SELECT id, edition, current_status, case_number, created_at, updated_at FROM player_rankings LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "NotificationMetrics",
        "code_value": "type NotificationMetrics struct {\n\tID           int       `json:\"id\" gorm:\"column:id\"`\n\tEdition      string    `json:\"edition\" gorm:\"column:edition\"`\n\tCurrentStatus string   `json:\"current_status\" gorm:\"column:current_status\"`\n\tCaseNumber   string    `json:\"case_number\" gorm:\"column:case_number\"`\n\tCreatedAt    time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt    time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "PlayerRankingTable",
        "code_value": "const PlayerRankingTable = \"player_rankings\""
      },
      {
        "code_key": "MetricsStatus",
        "code_value": "const (\n\tMetricsStatusPending = \"pending\"\n\tMetricsStatusProcessed = \"processed\"\n\tMetricsStatusFailed = \"failed\"\n)"
      },
      {
        "code_key": "NotificationFilter",
        "code_value": "type NotificationFilter struct {\n\tEdition      string `json:\"edition\"`\n\tCurrentStatus string `json:\"current_status\"`\n\tCaseNumber   string `json:\"case_number\"`\n\tLimit        int    `json:\"limit\"`\n}"
      },
      {
        "code_key": "DefaultMetricsLimit",
        "code_value": "var DefaultMetricsLimit = 100"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "GenerateMetrics",
    "orm_code": "func (n *Notification) GenerateMetrics(filterParams map[string]interface{}, limit int) ([]types.NotificationMetrics, error) {\n\tvar metrics []types.NotificationMetrics\n\tdb := base.GetInstance().DefaultDriver().Table(\"player_rankings\")\n\n\tif edition, ok := filterParams[\"Edition\"]; ok {\n\t\tif currentStatus, exists := filterParams[\"CurrentStatus\"]; exists {\n\t\tdb = db.Where(\"edition = ? AND current_status = ?\", edition, currentStatus)\n\t} else {\n\t\tdb = db.Where(\"edition LIKE ?\", \"%\"+edition.(string)+\"%\")\n\t}\n\t} else if caseNumber, ok := filterParams[\"CaseNumber\"]; ok {\n\t\tdb = db.Where(\"case_number = ?\", caseNumber)\n\t} else {\n\t\tdb = db.Where(filterParams)\n\t}\n\n\terr := db.Limit(limit).Find(&metrics).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.MetricsNotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn metrics, nil\n}",
    "caller": "func (h *RankingHandler) HandlePlayerRankings(req *types.RankingRequest, log *logger.AppLog) ([]types.NotificationMetrics, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.PlayerID != \"\" {\n\t\tfilter[\"player_id\"] = req.PlayerID\n\t} else if req.RankRange != \"\" {\n\t\trangeParts := strings.Split(req.RankRange, \"-\")\n\t\tif len(rangeParts) != 2 {\n\t\t\tlog.Error(\"Invalid rank range format\")\n\t\t\treturn nil, utils.InvalidParamError\n\t\t}\n\t\tfilter[\"rank\"] = []interface{}{rangeParts[0], rangeParts[1]}\n\t} else if req.Region != \"\" && req.Tier != 0 {\n\t\tfilter[\"region\"] = req.Region\n\t\tfilter[\"tier\"] = req.Tier\n\t} else {\n\t\tif req.LastUpdated > 0 {\n\t\t\tfilter[\"updated_at\"] = req.LastUpdated\n\t\t}\n\t}\n\n\tnotif := &Notification{}\n\tmetrics, err := notif.GenerateMetrics(filter, req.Limit)\n\tif err != nil {\n\t\tlog.Error(fmt.Sprintf(\"Failed to generate metrics: %v\", err))\n\t\treturn nil, err\n\t}\n\t\n\tif len(metrics) == 0 {\n\t\tlog.Warn(\"No metrics found for given filters\")\n\t}\n\t\n\treturn metrics, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "player_id condition",
            "sql": "SELECT `id`, `edition`, `current_status`, `case_number`, `created_at`, `updated_at` FROM `player_rankings` WHERE `player_id` = ? LIMIT ?;"
          },
          {
            "scenario": "rank range condition",
            "sql": "SELECT `id`, `edition`, `current_status`, `case_number`, `created_at`, `updated_at` FROM `player_rankings` WHERE `rank` BETWEEN ? AND ? LIMIT ?;"
          },
          {
            "scenario": "region and tier combination condition",
            "sql": "SELECT `id`, `edition`, `current_status`, `case_number`, `created_at`, `updated_at` FROM `player_rankings` WHERE `region` = ? AND `tier` = ? LIMIT ?;"
          },
          {
            "scenario": "updated_at condition",
            "sql": "SELECT `id`, `edition`, `current_status`, `case_number`, `created_at`, `updated_at` FROM `player_rankings` WHERE `updated_at` = ? LIMIT ?;"
          },
          {
            "scenario": "Edition and CurrentStatus combination condition",
            "sql": "SELECT `id`, `edition`, `current_status`, `case_number`, `created_at`, `updated_at` FROM `player_rankings` WHERE `edition` = ? AND `current_status` = ? LIMIT ?;"
          },
          {
            "scenario": "Edition fuzzy match condition",
            "sql": "SELECT `id`, `edition`, `current_status`, `case_number`, `created_at`, `updated_at` FROM `player_rankings` WHERE `edition` LIKE ? LIMIT ?;"
          },
          {
            "scenario": "CaseNumber condition",
            "sql": "SELECT `id`, `edition`, `current_status`, `case_number`, `created_at`, `updated_at` FROM `player_rankings` WHERE `case_number` = ? LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "NotificationMetrics",
        "code_value": "type NotificationMetrics struct {\n\tID           int       `json:\"id\" gorm:\"column:id\"`\n\tEdition      string    `json:\"edition\" gorm:\"column:edition\"`\n\tCurrentStatus string   `json:\"current_status\" gorm:\"column:current_status\"`\n\tCaseNumber   string    `json:\"case_number\" gorm:\"column:case_number\"`\n\tCreatedAt    time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt    time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "PlayerRankingTable",
        "code_value": "const PlayerRankingTable = \"player_rankings\""
      },
      {
        "code_key": "MetricsStatus",
        "code_value": "const (\n\tMetricsStatusPending = \"pending\"\n\tMetricsStatusProcessed = \"processed\"\n\tMetricsStatusFailed = \"failed\"\n)"
      },
      {
        "code_key": "NotificationFilter",
        "code_value": "type NotificationFilter struct {\n\tEdition      string `json:\"edition\"`\n\tCurrentStatus string `json:\"current_status\"`\n\tCaseNumber   string `json:\"case_number\"`\n\tLimit        int    `json:\"limit\"`\n}"
      },
      {
        "code_key": "DefaultMetricsLimit",
        "code_value": "var DefaultMetricsLimit = 100"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CompareData",
    "orm_code": "func (b *Book) CompareData(filterCriteria map[string]interface{}) ([]types.BookComparison, error) {\n\tresults := make([]types.BookComparison, 0)\n\tdb := base.GetInstance().MainDB().Table(\"account_balances\")\n\t\n\tif namespace, exists := filterCriteria[\"NamespaceName\"]; exists {\n\t\tdb = db.Where(\"namespace_name = ?\", namespace.(string))\n\t\tif publication, exists := filterCriteria[\"Publication\"]; exists {\n\t\t\tdb = db.Where(\"publication LIKE ?\", \"%\"+publication.(string)+\"%\")\n\t\t}\n\t} else if firstName, exists := filterCriteria[\"FirstName\"]; exists {\n\t\tdb = db.Where(\"first_name ILIKE ?\", firstName.(string)+\"%\")\n\t} else {\n\t\tdb = db.Where(filterCriteria)\n\t}\n\n\tif err := db.Find(&results).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.DataNotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "filter contains Priority key",
            "sql": "SELECT id, priority, author, connection_string, status, permission_type, created_at, updated_at FROM grade_records WHERE priority = ? AND status != 'archived' ORDER BY created_at DESC LIMIT ?;"
          },
          {
            "scenario": "filter contains Author key",
            "sql": "SELECT id, priority, author, connection_string, status, permission_type, created_at, updated_at FROM grade_records WHERE author LIKE ? AND permission_type IN ('read', 'write') ORDER BY updated_at DESC LIMIT ?;"
          },
          {
            "scenario": "filter contains ConnectionString key",
            "sql": "SELECT id, priority, author, connection_string, status, permission_type, created_at, updated_at FROM grade_records WHERE connection_string = ? ORDER BY id ASC LIMIT ?;"
          },
          {
            "scenario": "filter contains other keys",
            "sql": "SELECT id, priority, author, connection_string, status, permission_type, created_at, updated_at FROM grade_records WHERE status = ? AND permission_type = ? ORDER BY created_at DESC LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "BookComparison",
        "code_value": "type BookComparison struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tNamespaceName string    `json:\"namespace_name\" gorm:\"column:namespace_name\"`\n\tPublication   string    `json:\"publication\" gorm:\"column:publication\"`\n\tFirstName     string    `json:\"first_name\" gorm:\"column:first_name\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "BookFilter",
        "code_value": "type BookFilter struct {\n\tNamespaceName string\n\tPublication   string\n\tFirstName     string\n\tLimit         int\n\tOffset        int\n}"
      },
      {
        "code_key": "BookError",
        "code_value": "const BookError = \"book_error\""
      },
      {
        "code_key": "MaxBookLimit",
        "code_value": "const MaxBookLimit = 100"
      },
      {
        "code_key": "DefaultBookOffset",
        "code_value": "const DefaultBookOffset = 0"
      },
      {
        "code_key": "BookTableName",
        "code_value": "const BookTableName = \"account_balances\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CompareData",
    "orm_code": "func (b *Book) CompareData(filterCriteria map[string]interface{}) ([]types.BookComparison, error) {\n\tresults := make([]types.BookComparison, 0)\n\tdb := base.GetInstance().MainDB().Table(\"account_balances\")\n\t\n\tif namespace, exists := filterCriteria[\"NamespaceName\"]; exists {\n\t\tdb = db.Where(\"namespace_name = ?\", namespace.(string))\n\t\tif publication, exists := filterCriteria[\"Publication\"]; exists {\n\t\t\tdb = db.Where(\"publication LIKE ?\", \"%\"+publication.(string)+\"%\")\n\t\t}\n\t} else if firstName, exists := filterCriteria[\"FirstName\"]; exists {\n\t\tdb = db.Where(\"first_name ILIKE ?\", firstName.(string)+\"%\")\n\t} else {\n\t\tdb = db.Where(filterCriteria)\n\t}\n\n\tif err := db.Find(&results).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.DataNotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}",
    "caller": "func (h *ArticleHandler) HandleArticleSearch(req *types.ArticleSearchRequest) ([]types.ArticleComparison, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.ArticleID > 0 {\n\t\tfilter[\"article_id\"] = req.ArticleID\n\t} else if len(req.AuthorName) > 0 {\n\t\tif len(req.AuthorName) > 100 {\n\t\t\treturn nil, errors.New(\"author name too long\")\n\t\t}\n\t\tfilter[\"author_name\"] = req.AuthorName\n\t} else if len(req.Category) > 0 {\n\t\tvalidCategories := map[string]bool{\"tech\": true, \"business\": true, \"health\": true}\n\t\tif !validCategories[req.Category] {\n\t\t\treturn nil, errors.New(\"invalid category\")\n\t\t}\n\t\tfilter[\"category\"] = req.Category\n\t} else {\n\t\tfilter[\"is_published\"] = true\n\t}\n\n\tarticle := &models.Article{}\n\tresults, err := article.CompareData(filter)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to search articles: %v\", err)\n\t}\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "article_id有值",
            "sql": "SELECT id, namespace_name, publication, first_name, created_at, updated_at FROM account_balances WHERE article_id = ?;"
          },
          {
            "scenario": "author_name有值且长度<=100",
            "sql": "SELECT id, namespace_name, publication, first_name, created_at, updated_at FROM account_balances WHERE author_name = ?;"
          },
          {
            "scenario": "category有值且有效",
            "sql": "SELECT id, namespace_name, publication, first_name, created_at, updated_at FROM account_balances WHERE category = ?;"
          },
          {
            "scenario": "默认情况（无特定条件）",
            "sql": "SELECT id, namespace_name, publication, first_name, created_at, updated_at FROM account_balances WHERE is_published = true;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "BookComparison",
        "code_value": "type BookComparison struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tNamespaceName string    `json:\"namespace_name\" gorm:\"column:namespace_name\"`\n\tPublication   string    `json:\"publication\" gorm:\"column:publication\"`\n\tFirstName     string    `json:\"first_name\" gorm:\"column:first_name\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "BookFilter",
        "code_value": "type BookFilter struct {\n\tNamespaceName string\n\tPublication   string\n\tFirstName     string\n\tLimit         int\n\tOffset        int\n}"
      },
      {
        "code_key": "BookError",
        "code_value": "const BookError = \"book_error\""
      },
      {
        "code_key": "MaxBookLimit",
        "code_value": "const MaxBookLimit = 100"
      },
      {
        "code_key": "DefaultBookOffset",
        "code_value": "const DefaultBookOffset = 0"
      },
      {
        "code_key": "BookTableName",
        "code_value": "const BookTableName = \"account_balances\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CompareData",
    "orm_code": "func (b *Book) CompareData(filterCriteria map[string]interface{}) ([]types.BookComparison, error) {\n\tresults := make([]types.BookComparison, 0)\n\tdb := base.GetInstance().MainDB().Table(\"account_balances\")\n\t\n\tif namespace, exists := filterCriteria[\"NamespaceName\"]; exists {\n\t\tdb = db.Where(\"namespace_name = ?\", namespace.(string))\n\t\tif publication, exists := filterCriteria[\"Publication\"]; exists {\n\t\t\tdb = db.Where(\"publication LIKE ?\", \"%\"+publication.(string)+\"%\")\n\t\t}\n\t} else if firstName, exists := filterCriteria[\"FirstName\"]; exists {\n\t\tdb = db.Where(\"first_name ILIKE ?\", firstName.(string)+\"%\")\n\t} else {\n\t\tdb = db.Where(filterCriteria)\n\t}\n\n\tif err := db.Find(&results).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.DataNotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}",
    "caller": "func (s *MessageService) HandleMessageFilter(req *types.FilterRequest, log *logger.AppLog) ([]types.MessageData, error) {\n\tif req.Limit <= 0 {\n\t\treturn nil, fmt.Errorf(\"invalid limit parameter\")\n\t}\n\n\tfilterConditions := make(map[string]interface{})\n\tif req.Priority > 0 {\n\t\tfilterConditions[\"Priority\"] = req.Priority\n\t} else if req.Author != \"\" {\n\t\tif len(req.Author) > 100 {\n\t\t\treturn nil, fmt.Errorf(\"author name too long\")\n\t\t}\n\t\tfilterConditions[\"Author\"] = req.Author\n\t} else if req.ConnectionString != \"\" {\n\t\tfilterConditions[\"ConnectionString\"] = req.ConnectionString\n\t} else {\n\t\tfilterConditions[\"Status\"] = \"active\"\n\t}\n\n\tmsgObj := &Message{ID: req.MessageID}\n\tfilteredData, err := msgObj.CompareData(filterConditions, req.Limit)\n\tif err != nil {\n\t\tlog.Error(fmt.Sprintf(\"Message filter failed: %v\", err))\n\t\treturn nil, fmt.Errorf(\"message filtering error\")\n\t}\n\n\tif len(filteredData) == 0 {\n\t\tlog.Info(\"No messages found matching criteria\")\n\t\treturn nil, nil\n\t}\n\n\treturn filteredData, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Priority filter condition",
            "sql": "SELECT id, priority, author, connection_string, status, permission_type, created_at, updated_at FROM grade_records WHERE priority = ? AND status != ? ORDER BY created_at DESC LIMIT ?;"
          },
          {
            "scenario": "Author filter condition",
            "sql": "SELECT id, priority, author, connection_string, status, permission_type, created_at, updated_at FROM grade_records WHERE author LIKE ? AND permission_type IN (?, ?) ORDER BY updated_at DESC LIMIT ?;"
          },
          {
            "scenario": "ConnectionString filter condition",
            "sql": "SELECT id, priority, author, connection_string, status, permission_type, created_at, updated_at FROM grade_records WHERE connection_string = ? ORDER BY id ASC LIMIT ?;"
          },
          {
            "scenario": "Default filter condition",
            "sql": "SELECT id, priority, author, connection_string, status, permission_type, created_at, updated_at FROM grade_records WHERE status = ? ORDER BY created_at DESC LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "BookComparison",
        "code_value": "type BookComparison struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tNamespaceName string    `json:\"namespace_name\" gorm:\"column:namespace_name\"`\n\tPublication   string    `json:\"publication\" gorm:\"column:publication\"`\n\tFirstName     string    `json:\"first_name\" gorm:\"column:first_name\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "BookFilter",
        "code_value": "type BookFilter struct {\n\tNamespaceName string\n\tPublication   string\n\tFirstName     string\n\tLimit         int\n\tOffset        int\n}"
      },
      {
        "code_key": "BookError",
        "code_value": "const BookError = \"book_error\""
      },
      {
        "code_key": "MaxBookLimit",
        "code_value": "const MaxBookLimit = 100"
      },
      {
        "code_key": "DefaultBookOffset",
        "code_value": "const DefaultBookOffset = 0"
      },
      {
        "code_key": "BookTableName",
        "code_value": "const BookTableName = \"account_balances\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ScanByPattern",
    "orm_code": "func (d *Document) ScanByPattern(filterParams map[string]interface{}, page, size int) ([]types.DocumentRecord, error) {\n\trecords := make([]types.DocumentRecord, 0)\n\tquery := base.GetDB().Table(\"guild_memberships\").Scopes(PaginateDB(page, size))\n\n\tif format, ok := filterParams[\"Format\"]; ok {\n\t\tquery = query.Where(\"format LIKE ?\", \"%\"+format.(string)+\"%\")\n\t\tdelete(filterParams, \"Format\")\n\t\tif len(filterParams) > 0 {\n\t\t\tquery = query.Where(filterParams)\n\t\t}\n\t} else if reactivationDate, ok := filterParams[\"ReactivationDate\"]; ok {\n\t\tquery = query.Where(\"reactivation_date > ?\", reactivationDate.(time.Time))\n\t\tdelete(filterParams, \"ReactivationDate\")\n\t\tif len(filterParams) > 0 {\n\t\t\tquery = query.Where(filterParams)\n\t\t}\n\t} else {\n\t\tquery = query.Where(filterParams)\n\t}\n\n\tif err := query.Find(&records).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn records, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "filterCriteria contains Ratio key",
            "sql": "SELECT * FROM patient_records WHERE ratio > ? ORDER BY expiration_time DESC LIMIT ?;"
          },
          {
            "scenario": "filterCriteria contains DeliveryCode key",
            "sql": "SELECT * FROM patient_records WHERE delivery_code LIKE ? ORDER BY created_at ASC LIMIT ?;"
          },
          {
            "scenario": "filterCriteria contains TimeRange key",
            "sql": "SELECT * FROM patient_records WHERE expiration_time BETWEEN ? AND ? LIMIT ?;"
          },
          {
            "scenario": "filterCriteria is empty",
            "sql": "SELECT * FROM patient_records ORDER BY id LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "DocumentRecord",
        "code_value": "type DocumentRecord struct {\n\tID               int       `json:\"id\" gorm:\"column:id\"`\n\tTitle            string    `json:\"title\" gorm:\"column:title\"`\n\tFormat           string    `json:\"format\" gorm:\"column:format\"`\n\tReactivationDate time.Time `json:\"reactivation_date\" gorm:\"column:reactivation_date\"`\n\tCreatedAt        time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt        time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "DocumentFilterParams",
        "code_value": "type DocumentFilterParams struct {\n\tFormat           *string\n\tReactivationDate *time.Time\n\tStatus           *int\n\tAuthorID         *int64\n}"
      },
      {
        "code_key": "DocumentTableName",
        "code_value": "const DocumentTableName = \"guild_memberships\""
      },
      {
        "code_key": "DocumentStatus",
        "code_value": "const (\n\tDocumentStatusDraft = iota\n\tDocumentStatusPublished\n\tDocumentStatusArchived\n)"
      },
      {
        "code_key": "defaultPageSize",
        "code_value": "var defaultPageSize = 20"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ScanByPattern",
    "orm_code": "func (d *Document) ScanByPattern(filterParams map[string]interface{}, page, size int) ([]types.DocumentRecord, error) {\n\trecords := make([]types.DocumentRecord, 0)\n\tquery := base.GetDB().Table(\"guild_memberships\").Scopes(PaginateDB(page, size))\n\n\tif format, ok := filterParams[\"Format\"]; ok {\n\t\tquery = query.Where(\"format LIKE ?\", \"%\"+format.(string)+\"%\")\n\t\tdelete(filterParams, \"Format\")\n\t\tif len(filterParams) > 0 {\n\t\t\tquery = query.Where(filterParams)\n\t\t}\n\t} else if reactivationDate, ok := filterParams[\"ReactivationDate\"]; ok {\n\t\tquery = query.Where(\"reactivation_date > ?\", reactivationDate.(time.Time))\n\t\tdelete(filterParams, \"ReactivationDate\")\n\t\tif len(filterParams) > 0 {\n\t\t\tquery = query.Where(filterParams)\n\t\t}\n\t} else {\n\t\tquery = query.Where(filterParams)\n\t}\n\n\tif err := query.Find(&records).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn records, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "caller": "func (m *MedicalHandler) HandleMedicalRecords(req *types.MedicalRecordsRequest) ([]types.DocumentRecord, error) {\n\tfilterParams := make(map[string]interface{})\n\n\tif req.PatientID != \"\" {\n\t\tfilterParams[\"patient_id\"] = req.PatientID\n\t} else if req.AdmissionDate != \"\" {\n\t\tdate, err := time.Parse(\"2006-01-02\", req.AdmissionDate)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"invalid admission date format: %v\", err)\n\t\t}\n\t\tfilterParams[\"admission_date\"] = date\n\t} else if req.Diagnosis != \"\" {\n\t\tif len(req.Diagnosis) > 100 {\n\t\t\treturn nil, errors.New(\"diagnosis too long\")\n\t\t}\n\t\tfilterParams[\"diagnosis\"] = req.Diagnosis\n\t} else {\n\t\treturn nil, errors.New(\"at least one filter parameter required\")\n\t}\n\n\tdoc := &Document{}\n\trecords, err := doc.ScanByPattern(filterParams, req.Page, req.Size)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to scan medical records: %v\", err)\n\t}\n\n\treturn records, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按PatientID过滤",
            "sql": "SELECT id, title, format, reactivation_date, created_at, updated_at FROM guild_memberships WHERE patient_id = '12345' LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "按AdmissionDate过滤",
            "sql": "SELECT id, title, format, reactivation_date, created_at, updated_at FROM guild_memberships WHERE admission_date = '2023-01-15 00:00:00' LIMIT 10 OFFSET 10;"
          },
          {
            "scenario": "按Diagnosis过滤",
            "sql": "SELECT id, title, format, reactivation_date, created_at, updated_at FROM guild_memberships WHERE diagnosis = 'Hypertension' LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "按Format模糊匹配过滤",
            "sql": "SELECT id, title, format, reactivation_date, created_at, updated_at FROM guild_memberships WHERE format LIKE '%PDF%' LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "按ReactivationDate过滤",
            "sql": "SELECT id, title, format, reactivation_date, created_at, updated_at FROM guild_memberships WHERE reactivation_date > '2023-01-01 00:00:00' LIMIT 20 OFFSET 0;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "DocumentRecord",
        "code_value": "type DocumentRecord struct {\n\tID               int       `json:\"id\" gorm:\"column:id\"`\n\tTitle            string    `json:\"title\" gorm:\"column:title\"`\n\tFormat           string    `json:\"format\" gorm:\"column:format\"`\n\tReactivationDate time.Time `json:\"reactivation_date\" gorm:\"column:reactivation_date\"`\n\tCreatedAt        time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt        time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "DocumentFilterParams",
        "code_value": "type DocumentFilterParams struct {\n\tFormat           *string\n\tReactivationDate *time.Time\n\tStatus           *int\n\tAuthorID         *int64\n}"
      },
      {
        "code_key": "DocumentTableName",
        "code_value": "const DocumentTableName = \"guild_memberships\""
      },
      {
        "code_key": "DocumentStatus",
        "code_value": "const (\n\tDocumentStatusDraft = iota\n\tDocumentStatusPublished\n\tDocumentStatusArchived\n)"
      },
      {
        "code_key": "defaultPageSize",
        "code_value": "var defaultPageSize = 20"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ScanByPattern",
    "orm_code": "func (d *Document) ScanByPattern(filterParams map[string]interface{}, page, size int) ([]types.DocumentRecord, error) {\n\trecords := make([]types.DocumentRecord, 0)\n\tquery := base.GetDB().Table(\"guild_memberships\").Scopes(PaginateDB(page, size))\n\n\tif format, ok := filterParams[\"Format\"]; ok {\n\t\tquery = query.Where(\"format LIKE ?\", \"%\"+format.(string)+\"%\")\n\t\tdelete(filterParams, \"Format\")\n\t\tif len(filterParams) > 0 {\n\t\t\tquery = query.Where(filterParams)\n\t\t}\n\t} else if reactivationDate, ok := filterParams[\"ReactivationDate\"]; ok {\n\t\tquery = query.Where(\"reactivation_date > ?\", reactivationDate.(time.Time))\n\t\tdelete(filterParams, \"ReactivationDate\")\n\t\tif len(filterParams) > 0 {\n\t\t\tquery = query.Where(filterParams)\n\t\t}\n\t} else {\n\t\tquery = query.Where(filterParams)\n\t}\n\n\tif err := query.Find(&records).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn records, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "caller": "func (s *RecordService) HandlePatientRecordSearch(req *types.RecordSearchRequest) ([]types.EventLog, error) {\n\tcriteria := make(map[string]interface{})\n\tif req.FilterByRatio {\n\t\tcriteria[\"Ratio\"] = req.MinRatio\n\t} else if req.FilterByDeliveryCode {\n\t\tif len(req.DeliveryCodePrefix) < 3 {\n\t\t\treturn nil, fmt.Errorf(\"delivery code must be at least 3 characters\")\n\t\t}\n\t\tcriteria[\"DeliveryCode\"] = req.DeliveryCodePrefix\n\t} else if req.FilterByTimeRange {\n\t\tif req.StartTime.IsZero() || req.EndTime.IsZero() {\n\t\t\treturn nil, fmt.Errorf(\"invalid time range\")\n\t\t}\n\t\tcriteria[\"TimeRange\"] = map[string]interface{}{\n\t\t\t\"start\": req.StartTime,\n\t\t\t\"end\": req.EndTime,\n\t\t}\n\t}\n\n\tchapter := &Chapter{}\n\tresults, err := chapter.ScanByPattern(criteria, req.MaxResults)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"search failed: %v\", err)\n\t}\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "FilterByRatio = true",
            "sql": "SELECT `id`, `ratio`, `delivery_code`, `expiration_time`, `created_at` FROM `patient_records` WHERE ratio > ? ORDER BY ExpirationTime DESC LIMIT ?;"
          },
          {
            "scenario": "FilterByDeliveryCode = true",
            "sql": "SELECT `id`, `ratio`, `delivery_code`, `expiration_time`, `created_at` FROM `patient_records` WHERE delivery_code LIKE ? ORDER BY created_at ASC LIMIT ?;"
          },
          {
            "scenario": "FilterByTimeRange = true",
            "sql": "SELECT `id`, `ratio`, `delivery_code`, `expiration_time`, `created_at` FROM `patient_records` WHERE ExpirationTime BETWEEN ? AND ? LIMIT ?;"
          },
          {
            "scenario": "默认查询（无筛选条件）",
            "sql": "SELECT `id`, `ratio`, `delivery_code`, `expiration_time`, `created_at` FROM `patient_records` ORDER BY id LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "DocumentRecord",
        "code_value": "type DocumentRecord struct {\n\tID               int       `json:\"id\" gorm:\"column:id\"`\n\tTitle            string    `json:\"title\" gorm:\"column:title\"`\n\tFormat           string    `json:\"format\" gorm:\"column:format\"`\n\tReactivationDate time.Time `json:\"reactivation_date\" gorm:\"column:reactivation_date\"`\n\tCreatedAt        time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt        time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "DocumentFilterParams",
        "code_value": "type DocumentFilterParams struct {\n\tFormat           *string\n\tReactivationDate *time.Time\n\tStatus           *int\n\tAuthorID         *int64\n}"
      },
      {
        "code_key": "DocumentTableName",
        "code_value": "const DocumentTableName = \"guild_memberships\""
      },
      {
        "code_key": "DocumentStatus",
        "code_value": "const (\n\tDocumentStatusDraft = iota\n\tDocumentStatusPublished\n\tDocumentStatusArchived\n)"
      },
      {
        "code_key": "defaultPageSize",
        "code_value": "var defaultPageSize = 20"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "MatchByPattern",
    "orm_code": "func (p *Payment) MatchByPattern(filter map[string]interface{}, limit int) ([]types.Result, error) {\n\tvar results []types.Result\n\tvar err error\n\t\n\tif licenseKey, ok := filter[\"LicenseKey\"]; ok {\n\t\terr = base.GetDB().Table(\"account_balances\").\n\t\t\tWhere(\"license_key = ? AND classification_level = ?\", licenseKey, filter[\"ClassificationLevel\"]).\n\t\t\tLimit(limit).\n\t\t\tFind(&results).Error\n\t} else if version, ok := filter[\"Version\"]; ok {\n\t\terr = base.GetDB().Table(\"account_balances\").\n\t\t\tWhere(\"version >= ?\", version).\n\t\t\tOrder(\"created_at desc\").\n\t\t\tLimit(limit).\n\t\t\tFind(&results).Error\n\t} else {\n\t\terr = base.GetDB().Table(\"account_balances\").\n\t\t\tWhere(filter).\n\t\t\tLimit(limit).\n\t\t\tFind(&results).Error\n\t}\n\t\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "提供TrackingId和Status参数",
            "sql": "SELECT id, tracking_id, full_name, work_address, status, created_at, updated_at FROM lab_test_results WHERE tracking_id = ? AND status = ?;"
          },
          {
            "scenario": "只提供TrackingId参数",
            "sql": "SELECT id, tracking_id, full_name, work_address, status, created_at, updated_at FROM lab_test_results WHERE tracking_id LIKE ?;"
          },
          {
            "scenario": "提供WorkAddress参数",
            "sql": "SELECT id, tracking_id, full_name, work_address, status, created_at, updated_at FROM lab_test_results WHERE work_address = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "提供FullName参数",
            "sql": "SELECT id, tracking_id, full_name, work_address, status, created_at, updated_at FROM lab_test_results WHERE full_name ILIKE ? LIMIT ?;"
          },
          {
            "scenario": "提供其他参数组合",
            "sql": "SELECT id, tracking_id, full_name, work_address, status, created_at, updated_at FROM lab_test_results WHERE ? LIMIT ?;"
          },
          {
            "scenario": "不提供任何过滤参数",
            "sql": "SELECT id, tracking_id, full_name, work_address, status, created_at, updated_at FROM lab_test_results LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "Result",
        "code_value": "type Result struct {\n\tID                 int       `json:\"id\" gorm:\"column:id\"`\n\tLicenseKey         string    `json:\"license_key\" gorm:\"column:license_key\"`\n\tClassificationLevel string    `json:\"classification_level\" gorm:\"column:classification_level\"`\n\tVersion            int       `json:\"version\" gorm:\"column:version\"`\n\tCreatedAt          time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt          time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "AccountBalance",
        "code_value": "type AccountBalance struct {\n\tResult\n\tAmount float64 `json:\"amount\" gorm:\"column:amount\"`\n\tCurrency string `json:\"currency\" gorm:\"column:currency\"`\n}"
      },
      {
        "code_key": "PaymentFilter",
        "code_value": "type PaymentFilter struct {\n\tLicenseKey         string `json:\"license_key\"`\n\tClassificationLevel string `json:\"classification_level\"`\n\tVersion            int    `json:\"version\"`\n}"
      },
      {
        "code_key": "TableNameAccountBalances",
        "code_value": "const TableNameAccountBalances = \"account_balances\""
      },
      {
        "code_key": "DefaultQueryLimit",
        "code_value": "const DefaultQueryLimit = 100"
      },
      {
        "code_key": "ClassificationLevels",
        "code_value": "var ClassificationLevels = []string{\"standard\", \"premium\", \"enterprise\"}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "MatchByPattern",
    "orm_code": "func (p *Payment) MatchByPattern(filter map[string]interface{}, limit int) ([]types.Result, error) {\n\tvar results []types.Result\n\tvar err error\n\t\n\tif licenseKey, ok := filter[\"LicenseKey\"]; ok {\n\t\terr = base.GetDB().Table(\"account_balances\").\n\t\t\tWhere(\"license_key = ? AND classification_level = ?\", licenseKey, filter[\"ClassificationLevel\"]).\n\t\t\tLimit(limit).\n\t\t\tFind(&results).Error\n\t} else if version, ok := filter[\"Version\"]; ok {\n\t\terr = base.GetDB().Table(\"account_balances\").\n\t\t\tWhere(\"version >= ?\", version).\n\t\t\tOrder(\"created_at desc\").\n\t\t\tLimit(limit).\n\t\t\tFind(&results).Error\n\t} else {\n\t\terr = base.GetDB().Table(\"account_balances\").\n\t\t\tWhere(filter).\n\t\t\tLimit(limit).\n\t\t\tFind(&results).Error\n\t}\n\t\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}",
    "caller": "func (r *ResourceManager) HandleResourceAllocation(req *types.AllocationRequest) ([]types.Result, error) {\n\tif req == nil {\n\t\treturn nil, fmt.Errorf(\"invalid request\")\n\t}\n\n\tfilter := make(map[string]interface{})\n\tvar limit int = 10\n\n\tif req.ResourceID != \"\" {\n\t\tfilter[\"LicenseKey\"] = req.ResourceID\n\t\tfilter[\"ClassificationLevel\"] = req.Classification\n\t} else if req.MinVersion > 0 {\n\t\tfilter[\"Version\"] = req.MinVersion\n\t} else if req.Status != \"\" {\n\t\tfilter[\"status\"] = req.Status\n\t} else {\n\t\tfilter[\"is_active\"] = true\n\t}\n\n\tif req.Limit > 0 {\n\t\tlimit = req.Limit\n\t}\n\n\tpayment := &Payment{}\n\tresults, err := payment.MatchByPattern(filter, limit)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"query failed: %v\", err)\n\t}\n\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "有LicenseKey和ClassificationLevel参数",
            "sql": "SELECT id, license_key, classification_level, version, created_at, updated_at, amount, currency FROM account_balances WHERE license_key = ? AND classification_level = ? LIMIT ?;"
          },
          {
            "scenario": "有Version参数",
            "sql": "SELECT id, license_key, classification_level, version, created_at, updated_at, amount, currency FROM account_balances WHERE version >= ? ORDER BY created_at desc LIMIT ?;"
          },
          {
            "scenario": "有status参数",
            "sql": "SELECT id, license_key, classification_level, version, created_at, updated_at, amount, currency FROM account_balances WHERE status = ? LIMIT ?;"
          },
          {
            "scenario": "默认只有is_active参数",
            "sql": "SELECT id, license_key, classification_level, version, created_at, updated_at, amount, currency FROM account_balances WHERE is_active = ? LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Result",
        "code_value": "type Result struct {\n\tID                 int       `json:\"id\" gorm:\"column:id\"`\n\tLicenseKey         string    `json:\"license_key\" gorm:\"column:license_key\"`\n\tClassificationLevel string    `json:\"classification_level\" gorm:\"column:classification_level\"`\n\tVersion            int       `json:\"version\" gorm:\"column:version\"`\n\tCreatedAt          time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt          time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "AccountBalance",
        "code_value": "type AccountBalance struct {\n\tResult\n\tAmount float64 `json:\"amount\" gorm:\"column:amount\"`\n\tCurrency string `json:\"currency\" gorm:\"column:currency\"`\n}"
      },
      {
        "code_key": "PaymentFilter",
        "code_value": "type PaymentFilter struct {\n\tLicenseKey         string `json:\"license_key\"`\n\tClassificationLevel string `json:\"classification_level\"`\n\tVersion            int    `json:\"version\"`\n}"
      },
      {
        "code_key": "TableNameAccountBalances",
        "code_value": "const TableNameAccountBalances = \"account_balances\""
      },
      {
        "code_key": "DefaultQueryLimit",
        "code_value": "const DefaultQueryLimit = 100"
      },
      {
        "code_key": "ClassificationLevels",
        "code_value": "var ClassificationLevels = []string{\"standard\", \"premium\", \"enterprise\"}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "MatchByPattern",
    "orm_code": "func (p *Payment) MatchByPattern(filter map[string]interface{}, limit int) ([]types.Result, error) {\n\tvar results []types.Result\n\tvar err error\n\t\n\tif licenseKey, ok := filter[\"LicenseKey\"]; ok {\n\t\terr = base.GetDB().Table(\"account_balances\").\n\t\t\tWhere(\"license_key = ? AND classification_level = ?\", licenseKey, filter[\"ClassificationLevel\"]).\n\t\t\tLimit(limit).\n\t\t\tFind(&results).Error\n\t} else if version, ok := filter[\"Version\"]; ok {\n\t\terr = base.GetDB().Table(\"account_balances\").\n\t\t\tWhere(\"version >= ?\", version).\n\t\t\tOrder(\"created_at desc\").\n\t\t\tLimit(limit).\n\t\t\tFind(&results).Error\n\t} else {\n\t\terr = base.GetDB().Table(\"account_balances\").\n\t\t\tWhere(filter).\n\t\t\tLimit(limit).\n\t\t\tFind(&results).Error\n\t}\n\t\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}",
    "caller": "func (h *LabTestHandler) HandleLabTestResults(req *types.LabTestRequest) ([]types.LabTestResult, error) {\n\tfilterOpts := make(map[string]interface{})\n\tif req.TrackingID != \"\" {\n\t\tfilterOpts[\"TrackingId\"] = req.TrackingID\n\t\tif req.Status != \"\" {\n\t\t\tfilterOpts[\"Status\"] = req.Status\n\t\t}\n\t} else if req.WorkAddress != \"\" {\n\t\tfilterOpts[\"WorkAddress\"] = req.WorkAddress\n\t} else if req.PatientName != \"\" {\n\t\tfilterOpts[\"FullName\"] = req.PatientName\n\t} else {\n\t\tif req.StartDate != \"\" {\n\t\t\tfilterOpts[\"created_at\"] = gorm.Expr(\"created_at >= ?\", req.StartDate)\n\t\t}\n\t}\n\n\tlabTestRepo := &Share{}\n\tresults, err := labTestRepo.MatchByPattern(filterOpts, req.Limit)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to retrieve lab test results: %v\", err)\n\t}\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "提供TrackingID和Status",
            "sql": "SELECT * FROM lab_test_results WHERE tracking_id = ? AND status = ?;"
          },
          {
            "scenario": "仅提供TrackingID",
            "sql": "SELECT * FROM lab_test_results WHERE tracking_id LIKE ?;"
          },
          {
            "scenario": "提供WorkAddress",
            "sql": "SELECT * FROM lab_test_results WHERE work_address = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "提供FullName",
            "sql": "SELECT * FROM lab_test_results WHERE full_name ILIKE ? LIMIT ?;"
          },
          {
            "scenario": "默认情况(调用者else分支)",
            "sql": "SELECT * FROM lab_test_results WHERE created_at >= ? LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "Result",
        "code_value": "type Result struct {\n\tID                 int       `json:\"id\" gorm:\"column:id\"`\n\tLicenseKey         string    `json:\"license_key\" gorm:\"column:license_key\"`\n\tClassificationLevel string    `json:\"classification_level\" gorm:\"column:classification_level\"`\n\tVersion            int       `json:\"version\" gorm:\"column:version\"`\n\tCreatedAt          time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt          time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "AccountBalance",
        "code_value": "type AccountBalance struct {\n\tResult\n\tAmount float64 `json:\"amount\" gorm:\"column:amount\"`\n\tCurrency string `json:\"currency\" gorm:\"column:currency\"`\n}"
      },
      {
        "code_key": "PaymentFilter",
        "code_value": "type PaymentFilter struct {\n\tLicenseKey         string `json:\"license_key\"`\n\tClassificationLevel string `json:\"classification_level\"`\n\tVersion            int    `json:\"version\"`\n}"
      },
      {
        "code_key": "TableNameAccountBalances",
        "code_value": "const TableNameAccountBalances = \"account_balances\""
      },
      {
        "code_key": "DefaultQueryLimit",
        "code_value": "const DefaultQueryLimit = 100"
      },
      {
        "code_key": "ClassificationLevels",
        "code_value": "var ClassificationLevels = []string{\"standard\", \"premium\", \"enterprise\"}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "DetectFraud",
    "orm_code": "func (p *Policy) DetectFraud(filters map[string]interface{}) ([]types.FraudCase, error) {\n\tvar cases []types.FraudCase\n\tdb := base.GetInstance().GormDB().Table(\"trading_orders\")\n\n\tif district, ok := filters[\"District\"]; ok {\n\t\t// Complex query for district-based fraud detection\n\t\tdb = db.Where(\"district = ? AND suspicious_level > ?\", district, 5)\n\t} else if balance, ok := filters[\"Balance\"]; ok {\n\t\t// High balance threshold check\n\t\tdb = db.Where(\"balance > ? AND account_age < ?\", balance.(float64)*1.5, 30)\n\t} else {\n\t\t// Default suspicious pattern based on first login\n\t\tdb = db.Where(\"first_login_date < ? OR login_count > ?\", \n\t\t\ttime.Now().AddDate(0, -3, 0).Format(\"2006-01-02\"), 100)\n\t}\n\n\tif err := db.Order(\"detected_at DESC\").Find(&cases).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn cases, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "提供LocationCode",
            "sql": "SELECT id, location_code, invoice_number, deadline_date, severity, priority, status, created_at, updated_at FROM content_reports WHERE location_code = ? AND status = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "未提供LocationCode但提供DeadlineDate",
            "sql": "SELECT id, location_code, invoice_number, deadline_date, severity, priority, status, created_at, updated_at FROM content_reports WHERE deadline_date < ? AND severity > ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "未提供LocationCode和DeadlineDate但提供InvoiceNumber",
            "sql": "SELECT id, location_code, invoice_number, deadline_date, severity, priority, status, created_at, updated_at FROM content_reports WHERE invoice_number LIKE ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "未提供任何过滤条件",
            "sql": "SELECT id, location_code, invoice_number, deadline_date, severity, priority, status, created_at, updated_at FROM content_reports WHERE priority = ? ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "FraudCase",
        "code_value": "type FraudCase struct {\n\tID             int       `json:\"id\" gorm:\"column:id\"`\n\tOrderID        string    `json:\"order_id\" gorm:\"column:order_id\"`\n\tDistrict       string    `json:\"district\" gorm:\"column:district\"`\n\tBalance        float64   `json:\"balance\" gorm:\"column:balance\"`\n\tSuspiciousLevel int       `json:\"suspicious_level\" gorm:\"column:suspicious_level\"`\n\tAccountAge     int       `json:\"account_age\" gorm:\"column:account_age\"`\n\tFirstLoginDate time.Time `json:\"first_login_date\" gorm:\"column:first_login_date\"`\n\tLoginCount     int       `json:\"login_count\" gorm:\"column:login_count\"`\n\tDetectedAt     time.Time `json:\"detected_at\" gorm:\"column:detected_at\"`\n}"
      },
      {
        "code_key": "FraudFilter",
        "code_value": "type FraudFilter struct {\n\tDistrict string  `json:\"district\"`\n\tBalance  float64 `json:\"balance\"`\n}"
      },
      {
        "code_key": "FraudDetectionResult",
        "code_value": "type FraudDetectionResult struct {\n\tCases  []FraudCase `json:\"cases\"`\n\tStatus string      `json:\"status\"`\n\tError  string      `json:\"error,omitempty\"`\n}"
      },
      {
        "code_key": "TableNameTradingOrders",
        "code_value": "const TableNameTradingOrders = \"trading_orders\""
      },
      {
        "code_key": "FraudDetectionThresholds",
        "code_value": "var FraudDetectionThresholds = struct {\n\tSuspiciousLevel int\n\tAccountAge      int\n\tLoginCount      int\n}{\n\tSuspiciousLevel: 5,\n\tAccountAge:      30,\n\tLoginCount:      100,\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "DetectFraud",
    "orm_code": "func (p *Policy) DetectFraud(filters map[string]interface{}) ([]types.FraudCase, error) {\n\tvar cases []types.FraudCase\n\tdb := base.GetInstance().GormDB().Table(\"trading_orders\")\n\n\tif district, ok := filters[\"District\"]; ok {\n\t\t// Complex query for district-based fraud detection\n\t\tdb = db.Where(\"district = ? AND suspicious_level > ?\", district, 5)\n\t} else if balance, ok := filters[\"Balance\"]; ok {\n\t\t// High balance threshold check\n\t\tdb = db.Where(\"balance > ? AND account_age < ?\", balance.(float64)*1.5, 30)\n\t} else {\n\t\t// Default suspicious pattern based on first login\n\t\tdb = db.Where(\"first_login_date < ? OR login_count > ?\", \n\t\t\ttime.Now().AddDate(0, -3, 0).Format(\"2006-01-02\"), 100)\n\t}\n\n\tif err := db.Order(\"detected_at DESC\").Find(&cases).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn cases, nil\n}",
    "caller": "func (h *FraudHandler) HandleFraudDetection(req *types.FraudDetectionRequest, log *utils.AppLogger) ([]types.FraudCase, error) {\n\tfilters := make(map[string]interface{})\n\n\tif req.TransactionID != \"\" {\n\t\tif !utils.IsValidTransactionID(req.TransactionID) {\n\t\t\tlog.Error(\"Invalid transaction ID format\")\n\t\t\treturn nil, errors.New(\"invalid transaction ID\")\n\t\t}\n\t\tfilters[\"District\"] = req.TransactionID[:3]\n\t} else if req.UserBalance > 0 {\n\t\tif req.UserBalance > 1000000 {\n\t\t\tlog.Warn(\"High balance detected\")\n\t\t}\n\t\tfilters[\"Balance\"] = req.UserBalance\n\t} else if req.IsNewUser {\n\t\tfilters[\"FirstLogin\"] = true\n\t} else {\n\t\tfilters[\"DefaultCheck\"] = true\n\t}\n\n\tpolicy := &Policy{}\n\tcases, err := policy.DetectFraud(filters)\n\tif err != nil {\n\t\tlog.Errorf(\"Fraud detection failed: %v\", err)\n\t\treturn nil, err\n\t}\n\n\tif len(cases) > 100 {\n\t\tlog.Warn(\"Excessive fraud cases detected\")\n\t}\n\n\treturn cases, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "TransactionID不为空，使用District条件过滤",
            "sql": "SELECT id, order_id, district, balance, suspicious_level, account_age, first_login_date, login_count, detected_at FROM trading_orders WHERE district = ? AND suspicious_level > ? ORDER BY detected_at DESC;"
          },
          {
            "scenario": "UserBalance > 0，使用Balance条件过滤",
            "sql": "SELECT id, order_id, district, balance, suspicious_level, account_age, first_login_date, login_count, detected_at FROM trading_orders WHERE balance > ? AND account_age < ? ORDER BY detected_at DESC;"
          },
          {
            "scenario": "IsNewUser为true，使用默认条件",
            "sql": "SELECT id, order_id, district, balance, suspicious_level, account_age, first_login_date, login_count, detected_at FROM trading_orders WHERE first_login_date < ? OR login_count > ? ORDER BY detected_at DESC;"
          },
          {
            "scenario": "默认检查，使用与IsNewUser相同的默认条件",
            "sql": "SELECT id, order_id, district, balance, suspicious_level, account_age, first_login_date, login_count, detected_at FROM trading_orders WHERE first_login_date < ? OR login_count > ? ORDER BY detected_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "FraudCase",
        "code_value": "type FraudCase struct {\n\tID             int       `json:\"id\" gorm:\"column:id\"`\n\tOrderID        string    `json:\"order_id\" gorm:\"column:order_id\"`\n\tDistrict       string    `json:\"district\" gorm:\"column:district\"`\n\tBalance        float64   `json:\"balance\" gorm:\"column:balance\"`\n\tSuspiciousLevel int       `json:\"suspicious_level\" gorm:\"column:suspicious_level\"`\n\tAccountAge     int       `json:\"account_age\" gorm:\"column:account_age\"`\n\tFirstLoginDate time.Time `json:\"first_login_date\" gorm:\"column:first_login_date\"`\n\tLoginCount     int       `json:\"login_count\" gorm:\"column:login_count\"`\n\tDetectedAt     time.Time `json:\"detected_at\" gorm:\"column:detected_at\"`\n}"
      },
      {
        "code_key": "FraudFilter",
        "code_value": "type FraudFilter struct {\n\tDistrict string  `json:\"district\"`\n\tBalance  float64 `json:\"balance\"`\n}"
      },
      {
        "code_key": "FraudDetectionResult",
        "code_value": "type FraudDetectionResult struct {\n\tCases  []FraudCase `json:\"cases\"`\n\tStatus string      `json:\"status\"`\n\tError  string      `json:\"error,omitempty\"`\n}"
      },
      {
        "code_key": "TableNameTradingOrders",
        "code_value": "const TableNameTradingOrders = \"trading_orders\""
      },
      {
        "code_key": "FraudDetectionThresholds",
        "code_value": "var FraudDetectionThresholds = struct {\n\tSuspiciousLevel int\n\tAccountAge      int\n\tLoginCount      int\n}{\n\tSuspiciousLevel: 5,\n\tAccountAge:      30,\n\tLoginCount:      100,\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "DetectFraud",
    "orm_code": "func (p *Policy) DetectFraud(filters map[string]interface{}) ([]types.FraudCase, error) {\n\tvar cases []types.FraudCase\n\tdb := base.GetInstance().GormDB().Table(\"trading_orders\")\n\n\tif district, ok := filters[\"District\"]; ok {\n\t\t// Complex query for district-based fraud detection\n\t\tdb = db.Where(\"district = ? AND suspicious_level > ?\", district, 5)\n\t} else if balance, ok := filters[\"Balance\"]; ok {\n\t\t// High balance threshold check\n\t\tdb = db.Where(\"balance > ? AND account_age < ?\", balance.(float64)*1.5, 30)\n\t} else {\n\t\t// Default suspicious pattern based on first login\n\t\tdb = db.Where(\"first_login_date < ? OR login_count > ?\", \n\t\t\ttime.Now().AddDate(0, -3, 0).Format(\"2006-01-02\"), 100)\n\t}\n\n\tif err := db.Order(\"detected_at DESC\").Find(&cases).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn cases, nil\n}",
    "caller": "func (s *FraudService) HandleFraudDetection(criteria *types.FraudCriteria) ([]types.FraudReport, error) {\n\tif criteria == nil {\n\t\treturn nil, errors.New(\"invalid criteria\")\n\t}\n\n\tfilterParams := make(map[string]interface{})\n\n\tif criteria.Region != \"\" {\n\t\tfilterParams[\"LocationCode\"] = criteria.Region\n\t} else if !criteria.ExpiryDate.IsZero() {\n\t\tfilterParams[\"DeadlineDate\"] = criteria.ExpiryDate.Format(\"2006-01-02\")\n\t} else if criteria.InvoiceRef != \"\" {\n\t\tif len(criteria.InvoiceRef) < 3 {\n\t\t\treturn nil, errors.New(\"invoice reference too short\")\n\t\t}\n\t\tfilterParams[\"InvoiceNumber\"] = criteria.InvoiceRef\n\t}\n\n\tvendor := &Vendor{}\n\treports, err := vendor.DetectFraud(filterParams)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"fraud detection failed: %w\", err)\n\t}\n\n\tif len(reports) == 0 {\n\t\treturn nil, nil\n\t}\n\treturn reports, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Region参数传递",
            "sql": "SELECT id, location_code, invoice_number, deadline_date, severity, priority, status, created_at, updated_at FROM content_reports WHERE location_code = ? AND status = 'pending' ORDER BY created_at DESC;"
          },
          {
            "scenario": "ExpiryDate参数传递",
            "sql": "SELECT id, location_code, invoice_number, deadline_date, severity, priority, status, created_at, updated_at FROM content_reports WHERE deadline_date < ? AND severity > 5 ORDER BY created_at DESC;"
          },
          {
            "scenario": "InvoiceRef参数传递",
            "sql": "SELECT id, location_code, invoice_number, deadline_date, severity, priority, status, created_at, updated_at FROM content_reports WHERE invoice_number LIKE ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "无特殊参数（默认情况）",
            "sql": "SELECT id, location_code, invoice_number, deadline_date, severity, priority, status, created_at, updated_at FROM content_reports WHERE priority = 1 ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "FraudCase",
        "code_value": "type FraudCase struct {\n\tID             int       `json:\"id\" gorm:\"column:id\"`\n\tOrderID        string    `json:\"order_id\" gorm:\"column:order_id\"`\n\tDistrict       string    `json:\"district\" gorm:\"column:district\"`\n\tBalance        float64   `json:\"balance\" gorm:\"column:balance\"`\n\tSuspiciousLevel int       `json:\"suspicious_level\" gorm:\"column:suspicious_level\"`\n\tAccountAge     int       `json:\"account_age\" gorm:\"column:account_age\"`\n\tFirstLoginDate time.Time `json:\"first_login_date\" gorm:\"column:first_login_date\"`\n\tLoginCount     int       `json:\"login_count\" gorm:\"column:login_count\"`\n\tDetectedAt     time.Time `json:\"detected_at\" gorm:\"column:detected_at\"`\n}"
      },
      {
        "code_key": "FraudFilter",
        "code_value": "type FraudFilter struct {\n\tDistrict string  `json:\"district\"`\n\tBalance  float64 `json:\"balance\"`\n}"
      },
      {
        "code_key": "FraudDetectionResult",
        "code_value": "type FraudDetectionResult struct {\n\tCases  []FraudCase `json:\"cases\"`\n\tStatus string      `json:\"status\"`\n\tError  string      `json:\"error,omitempty\"`\n}"
      },
      {
        "code_key": "TableNameTradingOrders",
        "code_value": "const TableNameTradingOrders = \"trading_orders\""
      },
      {
        "code_key": "FraudDetectionThresholds",
        "code_value": "var FraudDetectionThresholds = struct {\n\tSuspiciousLevel int\n\tAccountAge      int\n\tLoginCount      int\n}{\n\tSuspiciousLevel: 5,\n\tAccountAge:      30,\n\tLoginCount:      100,\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "RetrieveByDate",
    "orm_code": "func (m *Medicine) RetrieveByDate(filterParams map[string]interface{}, page, size int) ([]types.MedicineRecord, error) {\n\tvar records []types.MedicineRecord\n\tdb := base.GetInstance().HealthDriver().Table(\"media_uploads\")\n\t\n\tif deadline, ok := filterParams[\"DeadlineDate\"]; ok {\n\t\t// Strategy 1: Range query for deadline dates\n\t\tdb = db.Where(\"deadline_date BETWEEN ? AND ?\", \n\t\t\ttime.Now().Format(\"2006-01-02\"),\n\t\t\ttime.Now().AddDate(0, 0, 7).Format(\"2006-01-02\"))\n\t\tdelete(filterParams, \"DeadlineDate\")\n\t\tdb = db.Where(filterParams)\n\t} else if rate, ok := filterParams[\"DiscountRate\"]; ok {\n\t\t// Strategy 2: Exact match with additional sorting\n\t\tdb = db.Where(\"discount_rate = ?\", rate).Order(\"tax_amount DESC\")\n\t\tdelete(filterParams, \"DiscountRate\")\n\t\tdb = db.Where(filterParams)\n\t} else {\n\t\tdb = db.Where(filterParams)\n\t}\n\t\n\terr := db.Scopes(PaginateDB(page, size)).Find(&records).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "包含DeadlineDate参数",
            "sql": "SELECT id, name, deadline_date, discount_rate, tax_amount, created_at, updated_at FROM media_uploads WHERE deadline_date BETWEEN ? AND ? AND name = ? LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "包含DiscountRate参数",
            "sql": "SELECT id, name, deadline_date, discount_rate, tax_amount, created_at, updated_at FROM media_uploads WHERE discount_rate = ? AND tax_amount = ? ORDER BY tax_amount DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "不包含特殊参数",
            "sql": "SELECT id, name, deadline_date, discount_rate, tax_amount, created_at, updated_at FROM media_uploads WHERE name = ? AND tax_amount = ? LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "MedicineRecord",
        "code_value": "type MedicineRecord struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tName          string    `json:\"name\" gorm:\"column:name\"`\n\tDeadlineDate  time.Time `json:\"deadline_date\" gorm:\"column:deadline_date\"`\n\tDiscountRate  float64   `json:\"discount_rate\" gorm:\"column:discount_rate\"`\n\tTaxAmount     float64   `json:\"tax_amount\" gorm:\"column:tax_amount\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "TableMedicine",
        "code_value": "const TableMedicine = \"medicine_records\""
      },
      {
        "code_key": "FilterParams",
        "code_value": "type FilterParams struct {\n\tDeadlineDate string  `json:\"deadline_date\"`\n\tDiscountRate float64 `json:\"discount_rate\"`\n\tName         string  `json:\"name\"`\n\tTaxAmount    float64 `json:\"tax_amount\"`\n}"
      },
      {
        "code_key": "PaginateDB",
        "code_value": "func PaginateDB(page, size int) func(db *gorm.DB) *gorm.DB {\n\treturn func(db *gorm.DB) *gorm.DB {\n\t\toffset := (page - 1) * size\n\t\treturn db.Offset(offset).Limit(size)\n\t}\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "RetrieveByDate",
    "orm_code": "func (m *Medicine) RetrieveByDate(filterParams map[string]interface{}, page, size int) ([]types.MedicineRecord, error) {\n\tvar records []types.MedicineRecord\n\tdb := base.GetInstance().HealthDriver().Table(\"media_uploads\")\n\t\n\tif deadline, ok := filterParams[\"DeadlineDate\"]; ok {\n\t\t// Strategy 1: Range query for deadline dates\n\t\tdb = db.Where(\"deadline_date BETWEEN ? AND ?\", \n\t\t\ttime.Now().Format(\"2006-01-02\"),\n\t\t\ttime.Now().AddDate(0, 0, 7).Format(\"2006-01-02\"))\n\t\tdelete(filterParams, \"DeadlineDate\")\n\t\tdb = db.Where(filterParams)\n\t} else if rate, ok := filterParams[\"DiscountRate\"]; ok {\n\t\t// Strategy 2: Exact match with additional sorting\n\t\tdb = db.Where(\"discount_rate = ?\", rate).Order(\"tax_amount DESC\")\n\t\tdelete(filterParams, \"DiscountRate\")\n\t\tdb = db.Where(filterParams)\n\t} else {\n\t\tdb = db.Where(filterParams)\n\t}\n\t\n\terr := db.Scopes(PaginateDB(page, size)).Find(&records).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "caller": "func (h *MedicineHandler) HandleMedicineCatalog(req *types.MedicineCatalogRequest) ([]types.MedicineRecord, error) {\n\tfilter := make(map[string]interface{})\n\tif req.Type != \"\" {\n\t\tfilter[\"medicine_type\"] = req.Type\n\t\tif req.SubType != \"\" {\n\t\t\tfilter[\"sub_type\"] = req.SubType\n\t\t}\n\t} else if req.IsPromotion {\n\t\tfilter[\"is_promotion\"] = true\n\t\tfilter[\"DiscountRate\"] = req.DiscountRate\n\t} else if !req.ExpiryDate.IsZero() {\n\t\tfilter[\"DeadlineDate\"] = req.ExpiryDate.Format(\"2006-01-02\")\n\t} else {\n\t\tfilter[\"status\"] = \"active\"\n\t}\n\n\tmed := &Medicine{}\n\trecords, err := med.RetrieveByDate(filter, req.Page, req.Size)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to retrieve medicine records: %v\", err)\n\t}\n\treturn records, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按药品类型和子类型查询",
            "sql": "SELECT id, name, deadline_date, discount_rate, tax_amount, created_at, updated_at FROM media_uploads WHERE medicine_type = ? AND sub_type = ? LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "促销药品查询",
            "sql": "SELECT id, name, deadline_date, discount_rate, tax_amount, created_at, updated_at FROM media_uploads WHERE is_promotion = ? AND discount_rate = ? ORDER BY tax_amount DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "按过期日期范围查询",
            "sql": "SELECT id, name, deadline_date, discount_rate, tax_amount, created_at, updated_at FROM media_uploads WHERE deadline_date BETWEEN ? AND ? LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "默认查询（活跃状态）",
            "sql": "SELECT id, name, deadline_date, discount_rate, tax_amount, created_at, updated_at FROM media_uploads WHERE status = ? LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "MedicineRecord",
        "code_value": "type MedicineRecord struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tName          string    `json:\"name\" gorm:\"column:name\"`\n\tDeadlineDate  time.Time `json:\"deadline_date\" gorm:\"column:deadline_date\"`\n\tDiscountRate  float64   `json:\"discount_rate\" gorm:\"column:discount_rate\"`\n\tTaxAmount     float64   `json:\"tax_amount\" gorm:\"column:tax_amount\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "TableMedicine",
        "code_value": "const TableMedicine = \"medicine_records\""
      },
      {
        "code_key": "FilterParams",
        "code_value": "type FilterParams struct {\n\tDeadlineDate string  `json:\"deadline_date\"`\n\tDiscountRate float64 `json:\"discount_rate\"`\n\tName         string  `json:\"name\"`\n\tTaxAmount    float64 `json:\"tax_amount\"`\n}"
      },
      {
        "code_key": "PaginateDB",
        "code_value": "func PaginateDB(page, size int) func(db *gorm.DB) *gorm.DB {\n\treturn func(db *gorm.DB) *gorm.DB {\n\t\toffset := (page - 1) * size\n\t\treturn db.Offset(offset).Limit(size)\n\t}\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "DecryptInfo",
    "orm_code": "func (b *Bond) DecryptInfo(filterParams map[string]interface{}) ([]types.PackageTracking, error) {\n\tvar records []types.PackageTracking\n\tdb := base.GetInstance().GormDriver().Table(\"package_tracking\")\n\n\tif apiKey, ok := filterParams[\"ApiKey\"]; ok {\n\t\tdb = db.Where(\"api_key = ?\", apiKey)\n\t\tif uniqueKey, ok := filterParams[\"UniqueKey\"]; ok {\n\t\t\tdb = db.Where(\"unique_key LIKE ?\", \"%\"+uniqueKey.(string)+\"%\")\n\t\t}\n\t} else if tableName, ok := filterParams[\"TableName\"]; ok {\n\t\tdb = db.Where(\"table_name IN (?, ?)\", tableName, tableName.(string)+\"_archive\")\n\t} else {\n\t\tdb = db.Where(filterParams)\n\t}\n\n\tif err := db.Find(&records).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.RecordNotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "filterParams包含EncryptionKey",
            "sql": "SELECT id, encryption_key, is_active, language, timezone, sequence_number, created_at, image_data, expiry_date, certification FROM training_certifications WHERE encryption_key = ? AND is_active = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "filterParams包含Language但不包含EncryptionKey",
            "sql": "SELECT id, encryption_key, is_active, language, timezone, sequence_number, created_at, image_data, expiry_date, certification FROM training_certifications WHERE language = ? AND timezone = ? ORDER BY sequence_number ASC;"
          },
          {
            "scenario": "filterParams包含SequenceNumber但不包含前两种key",
            "sql": "SELECT id, encryption_key, is_active, language, timezone, sequence_number, created_at, image_data, expiry_date, certification FROM training_certifications WHERE sequence_number > ? ORDER BY sequence_number ASC LIMIT 100;"
          },
          {
            "scenario": "filterParams不包含上述任何特殊key",
            "sql": "SELECT id, encryption_key, is_active, language, timezone, sequence_number, created_at, image_data, expiry_date, certification FROM training_certifications;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "PackageTracking",
        "code_value": "type PackageTracking struct {\n\tID        uint      json:\"id\" gorm:\"primaryKey\"\n\tApiKey    string    json:\"api_key\" gorm:\"column:api_key\"\n\tUniqueKey string    json:\"unique_key\" gorm:\"column:unique_key\"\n\tTableName string    json:\"table_name\" gorm:\"column:table_name\"\n\tCreatedAt time.Time json:\"created_at\" gorm:\"column:created_at\"\n\tUpdatedAt time.Time json:\"updated_at\" gorm:\"column:updated_at\"\n}"
      },
      {
        "code_key": "TrackingFilter",
        "code_value": "type TrackingFilter struct {\n\tApiKey    string\n\tUniqueKey string\n\tTableName string\n}"
      },
      {
        "code_key": "TrackingResponse",
        "code_value": "type TrackingResponse struct {\n\tSuccess   bool\n\tData      []PackageTracking\n\tError     string\n\tTimestamp int64\n}"
      },
      {
        "code_key": "TablePackageTracking",
        "code_value": "const TablePackageTracking = \"package_tracking\""
      },
      {
        "code_key": "TablePackageArchive",
        "code_value": "const TablePackageArchive = \"package_tracking_archive\""
      },
      {
        "code_key": "ErrInvalidFilter",
        "code_value": "var ErrInvalidFilter = errors.New(\"invalid filter parameters\")"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "DecryptInfo",
    "orm_code": "func (b *Bond) DecryptInfo(filterParams map[string]interface{}) ([]types.PackageTracking, error) {\n\tvar records []types.PackageTracking\n\tdb := base.GetInstance().GormDriver().Table(\"package_tracking\")\n\n\tif apiKey, ok := filterParams[\"ApiKey\"]; ok {\n\t\tdb = db.Where(\"api_key = ?\", apiKey)\n\t\tif uniqueKey, ok := filterParams[\"UniqueKey\"]; ok {\n\t\t\tdb = db.Where(\"unique_key LIKE ?\", \"%\"+uniqueKey.(string)+\"%\")\n\t\t}\n\t} else if tableName, ok := filterParams[\"TableName\"]; ok {\n\t\tdb = db.Where(\"table_name IN (?, ?)\", tableName, tableName.(string)+\"_archive\")\n\t} else {\n\t\tdb = db.Where(filterParams)\n\t}\n\n\tif err := db.Find(&records).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.RecordNotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "caller": "func (s *TrackingService) HandlePackageTracking(req *types.TrackingRequest) ([]types.PackageTracking, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.TrackingID != \"\" {\n\t\tfilter[\"UniqueKey\"] = req.TrackingID\n\t\tfilter[\"ApiKey\"] = s.apiKey\n\t} else if req.BatchNumber > 0 {\n\t\tfilter[\"TableName\"] = fmt.Sprintf(\"batch_%d\", req.BatchNumber)\n\t} else if req.Status != \"\" {\n\t\tif !utils.IsValidStatus(req.Status) {\n\t\t\treturn nil, fmt.Errorf(\"invalid status: %s\", req.Status)\n\t\t}\n\t\tfilter[\"status\"] = req.Status\n\t} else {\n\t\treturn nil, fmt.Errorf(\"at least one filter parameter is required\")\n\t}\n\n\tbond := &Bond{}\n\trecords, err := bond.DecryptInfo(filter)\n\tif err != nil {\n\t\tif errors.Is(err, utils.RecordNotFoundError) {\n\t\t\treturn nil, fmt.Errorf(\"no tracking records found\")\n\t\t}\n\t\treturn nil, fmt.Errorf(\"query failed: %v\", err)\n\t}\n\t\n\treturn records, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "TrackingID not empty",
            "sql": "SELECT id, api_key, unique_key, table_name, created_at, updated_at FROM package_tracking WHERE api_key = 'some-api-key' AND unique_key LIKE '%track123%';"
          },
          {
            "scenario": "BatchNumber > 0",
            "sql": "SELECT id, api_key, unique_key, table_name, created_at, updated_at FROM package_tracking WHERE table_name IN ('batch_123', 'batch_123_archive');"
          },
          {
            "scenario": "Status not empty",
            "sql": "SELECT id, api_key, unique_key, table_name, created_at, updated_at FROM package_tracking WHERE status = 'shipped';"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PackageTracking",
        "code_value": "type PackageTracking struct {\n\tID        uint      json:\"id\" gorm:\"primaryKey\"\n\tApiKey    string    json:\"api_key\" gorm:\"column:api_key\"\n\tUniqueKey string    json:\"unique_key\" gorm:\"column:unique_key\"\n\tTableName string    json:\"table_name\" gorm:\"column:table_name\"\n\tCreatedAt time.Time json:\"created_at\" gorm:\"column:created_at\"\n\tUpdatedAt time.Time json:\"updated_at\" gorm:\"column:updated_at\"\n}"
      },
      {
        "code_key": "TrackingFilter",
        "code_value": "type TrackingFilter struct {\n\tApiKey    string\n\tUniqueKey string\n\tTableName string\n}"
      },
      {
        "code_key": "TrackingResponse",
        "code_value": "type TrackingResponse struct {\n\tSuccess   bool\n\tData      []PackageTracking\n\tError     string\n\tTimestamp int64\n}"
      },
      {
        "code_key": "TablePackageTracking",
        "code_value": "const TablePackageTracking = \"package_tracking\""
      },
      {
        "code_key": "TablePackageArchive",
        "code_value": "const TablePackageArchive = \"package_tracking_archive\""
      },
      {
        "code_key": "ErrInvalidFilter",
        "code_value": "var ErrInvalidFilter = errors.New(\"invalid filter parameters\")"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "DecryptInfo",
    "orm_code": "func (b *Bond) DecryptInfo(filterParams map[string]interface{}) ([]types.PackageTracking, error) {\n\tvar records []types.PackageTracking\n\tdb := base.GetInstance().GormDriver().Table(\"package_tracking\")\n\n\tif apiKey, ok := filterParams[\"ApiKey\"]; ok {\n\t\tdb = db.Where(\"api_key = ?\", apiKey)\n\t\tif uniqueKey, ok := filterParams[\"UniqueKey\"]; ok {\n\t\t\tdb = db.Where(\"unique_key LIKE ?\", \"%\"+uniqueKey.(string)+\"%\")\n\t\t}\n\t} else if tableName, ok := filterParams[\"TableName\"]; ok {\n\t\tdb = db.Where(\"table_name IN (?, ?)\", tableName, tableName.(string)+\"_archive\")\n\t} else {\n\t\tdb = db.Where(filterParams)\n\t}\n\n\tif err := db.Find(&records).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.RecordNotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "caller": "func (s *ImageService) HandleImageDecryption(req *types.ImageDecryptionRequest) ([]types.ImageRecord, error) {\n\tif req == nil {\n\t\treturn nil, fmt.Errorf(\"request cannot be nil\")\n\t}\n\n\tfilterCriteria := make(map[string]interface{})\n\tif req.EncryptionKey != \"\" {\n\t\tfilterCriteria[\"EncryptionKey\"] = req.EncryptionKey\n\t} else if req.Language != \"\" {\n\t\tfilterCriteria[\"Language\"] = req.Language\n\t\tfilterCriteria[\"Timezone\"] = req.Timezone\n\t} else if req.SequenceNum > 0 {\n\t\tfilterCriteria[\"SequenceNumber\"] = req.SequenceNum\n\t} else {\n\t\tfilterCriteria[\"IsActive\"] = true\n\t}\n\n\timgProcessor := &Image{Metadata: req.Metadata}\n\tdecryptedResults, err := imgProcessor.DecryptInfo(filterCriteria)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"image decryption failed: %v\", err)\n\t}\n\n\tif len(decryptedResults) == 0 {\n\t\treturn nil, fmt.Errorf(\"no matching records found\")\n\t}\n\treturn decryptedResults, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "EncryptionKey provided",
            "sql": "SELECT id, encryption_key, is_active, language, timezone, sequence_number, created_at, image_data, expiry_date, certification FROM training_certifications WHERE encryption_key = ? AND is_active = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "Language provided",
            "sql": "SELECT id, encryption_key, is_active, language, timezone, sequence_number, created_at, image_data, expiry_date, certification FROM training_certifications WHERE language = ? AND timezone = ? ORDER BY sequence_number ASC;"
          },
          {
            "scenario": "SequenceNumber provided",
            "sql": "SELECT id, encryption_key, is_active, language, timezone, sequence_number, created_at, image_data, expiry_date, certification FROM training_certifications WHERE sequence_number > ? LIMIT 100;"
          },
          {
            "scenario": "Default case (IsActive=true)",
            "sql": "SELECT id, encryption_key, is_active, language, timezone, sequence_number, created_at, image_data, expiry_date, certification FROM training_certifications WHERE is_active = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "PackageTracking",
        "code_value": "type PackageTracking struct {\n\tID        uint      json:\"id\" gorm:\"primaryKey\"\n\tApiKey    string    json:\"api_key\" gorm:\"column:api_key\"\n\tUniqueKey string    json:\"unique_key\" gorm:\"column:unique_key\"\n\tTableName string    json:\"table_name\" gorm:\"column:table_name\"\n\tCreatedAt time.Time json:\"created_at\" gorm:\"column:created_at\"\n\tUpdatedAt time.Time json:\"updated_at\" gorm:\"column:updated_at\"\n}"
      },
      {
        "code_key": "TrackingFilter",
        "code_value": "type TrackingFilter struct {\n\tApiKey    string\n\tUniqueKey string\n\tTableName string\n}"
      },
      {
        "code_key": "TrackingResponse",
        "code_value": "type TrackingResponse struct {\n\tSuccess   bool\n\tData      []PackageTracking\n\tError     string\n\tTimestamp int64\n}"
      },
      {
        "code_key": "TablePackageTracking",
        "code_value": "const TablePackageTracking = \"package_tracking\""
      },
      {
        "code_key": "TablePackageArchive",
        "code_value": "const TablePackageArchive = \"package_tracking_archive\""
      },
      {
        "code_key": "ErrInvalidFilter",
        "code_value": "var ErrInvalidFilter = errors.New(\"invalid filter parameters\")"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "FindByCategory",
    "orm_code": "func (c *Claim) FindByCategory(filterParams map[string]interface{}, page, limit int) ([]types.SurgeryClaim, error) {\n\tvar claims []types.SurgeryClaim\n\tdb := base.GetInstance().HealthDriver().Table(\"surgery_schedules\")\n\n\tif category, ok := filterParams[\"Category\"]; ok {\n\t\tif deadline, exists := filterParams[\"DeadlineDate\"]; exists {\n\t\t\tdb = db.Where(\"category = ? AND deadline_date > ?\", category, deadline)\n\t\t} else {\n\t\t\tdb = db.Where(\"category LIKE ?\", \"%\"+category.(string)+\"%\")\n\t\t}\n\t} else if location, ok := filterParams[\"LocationCode\"]; ok {\n\t\tdb = db.Where(\"location_code = ?\", location)\n\t}\n\n\terr := db.Scopes(PaginateDB(page, limit)).Order(\"created_at desc\").Find(&claims).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.NotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn claims, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "filter包含category参数",
            "sql": "SELECT id, tracking_id, category, net_value, timezone, status, created_at, updated_at FROM market_data WHERE category = ? AND status = ? ORDER BY tracking_id DESC LIMIT ?;"
          },
          {
            "scenario": "filter包含net_value参数",
            "sql": "SELECT id, tracking_id, category, net_value, timezone, status, created_at, updated_at FROM market_data WHERE net_value BETWEEN ? AND ? ORDER BY tracking_id DESC LIMIT ?;"
          },
          {
            "scenario": "filter包含timezone参数",
            "sql": "SELECT id, tracking_id, category, net_value, timezone, status, created_at, updated_at FROM market_data WHERE timezone LIKE ? ORDER BY tracking_id DESC LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "SurgeryClaim",
        "code_value": "type SurgeryClaim struct {\n\tID           int       `json:\"id\" gorm:\"column:id;primaryKey\"`\n\tCategory     string    `json:\"category\" gorm:\"column:category\"`\n\tDeadlineDate time.Time `json:\"deadlineDate\" gorm:\"column:deadline_date\"`\n\tLocationCode string    `json:\"locationCode\" gorm:\"column:location_code\"`\n\tCreatedAt    time.Time `json:\"createdAt\" gorm:\"column:created_at\"`\n\tUpdatedAt    time.Time `json:\"updatedAt\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "FilterParams",
        "code_value": "type FilterParams struct {\n\tCategory      string    \n\tDeadlineDate  time.Time \n\tLocationCode  string    \n}"
      },
      {
        "code_key": "SurgeryTable",
        "code_value": "const SurgeryTable = \"surgery_schedules\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "ClaimStatus",
        "code_value": "type ClaimStatus struct {\n\tPending   string\n\tApproved  string\n\tRejected  string\n}\n\nvar Status = ClaimStatus{\n\tPending:  \"pending\",\n\tApproved: \"approved\",\n\tRejected: \"rejected\",\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "FindByCategory",
    "orm_code": "func (c *Claim) FindByCategory(filterParams map[string]interface{}, page, limit int) ([]types.SurgeryClaim, error) {\n\tvar claims []types.SurgeryClaim\n\tdb := base.GetInstance().HealthDriver().Table(\"surgery_schedules\")\n\n\tif category, ok := filterParams[\"Category\"]; ok {\n\t\tif deadline, exists := filterParams[\"DeadlineDate\"]; exists {\n\t\t\tdb = db.Where(\"category = ? AND deadline_date > ?\", category, deadline)\n\t\t} else {\n\t\t\tdb = db.Where(\"category LIKE ?\", \"%\"+category.(string)+\"%\")\n\t\t}\n\t} else if location, ok := filterParams[\"LocationCode\"]; ok {\n\t\tdb = db.Where(\"location_code = ?\", location)\n\t}\n\n\terr := db.Scopes(PaginateDB(page, limit)).Order(\"created_at desc\").Find(&claims).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.NotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn claims, nil\n}",
    "caller": "func (h *ClaimHandler) HandleSurgeryClaims(req *types.ClaimSearchRequest, log *logger.HealthLog) ([]types.SurgeryClaim, error) {\n\tfilter := make(map[string]interface{})\n\tif req.ClaimID != \"\" {\n\t\tfilter[\"ClaimID\"] = req.ClaimID\n\t} else if req.PatientName != \"\" {\n\t\tif len(req.PatientName) > 50 {\n\t\t\tlog.Error(\"Patient name too long\")\n\t\t\treturn nil, utils.InvalidParamError\n\t\t}\n\t\tfilter[\"PatientName\"] = req.PatientName\n\t} else if req.Status != 0 {\n\t\tfilter[\"Status\"] = req.Status\n\t} else {\n\t\treturn nil, utils.MissingParamError\n\t}\n\n\tclaimObj := &Claim{}\n\tresults, err := claimObj.FindByCategory(filter, req.Page, req.Size)\n\tif err != nil {\n\t\tlog.Errorf(\"Failed to find claims: %v\", err)\n\t\treturn nil, err\n\t}\n\n\tif len(results) == 0 {\n\t\tlog.Warn(\"No claims found with given criteria\")\n\t}\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "NO_SQL_GENERATE",
        "variants": [
          {
            "scenario": "调用者传递的参数键与函数期望的参数键不匹配，无法生成SQL",
            "sql": ""
          }
        ]
      }
    ],
    "sql_types": [
      "OTHER"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "SurgeryClaim",
        "code_value": "type SurgeryClaim struct {\n\tID           int       `json:\"id\" gorm:\"column:id;primaryKey\"`\n\tCategory     string    `json:\"category\" gorm:\"column:category\"`\n\tDeadlineDate time.Time `json:\"deadlineDate\" gorm:\"column:deadline_date\"`\n\tLocationCode string    `json:\"locationCode\" gorm:\"column:location_code\"`\n\tCreatedAt    time.Time `json:\"createdAt\" gorm:\"column:created_at\"`\n\tUpdatedAt    time.Time `json:\"updatedAt\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "FilterParams",
        "code_value": "type FilterParams struct {\n\tCategory      string    \n\tDeadlineDate  time.Time \n\tLocationCode  string    \n}"
      },
      {
        "code_key": "SurgeryTable",
        "code_value": "const SurgeryTable = \"surgery_schedules\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "ClaimStatus",
        "code_value": "type ClaimStatus struct {\n\tPending   string\n\tApproved  string\n\tRejected  string\n}\n\nvar Status = ClaimStatus{\n\tPending:  \"pending\",\n\tApproved: \"approved\",\n\tRejected: \"rejected\",\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "FindByCategory",
    "orm_code": "func (c *Claim) FindByCategory(filterParams map[string]interface{}, page, limit int) ([]types.SurgeryClaim, error) {\n\tvar claims []types.SurgeryClaim\n\tdb := base.GetInstance().HealthDriver().Table(\"surgery_schedules\")\n\n\tif category, ok := filterParams[\"Category\"]; ok {\n\t\tif deadline, exists := filterParams[\"DeadlineDate\"]; exists {\n\t\t\tdb = db.Where(\"category = ? AND deadline_date > ?\", category, deadline)\n\t\t} else {\n\t\t\tdb = db.Where(\"category LIKE ?\", \"%\"+category.(string)+\"%\")\n\t\t}\n\t} else if location, ok := filterParams[\"LocationCode\"]; ok {\n\t\tdb = db.Where(\"location_code = ?\", location)\n\t}\n\n\terr := db.Scopes(PaginateDB(page, limit)).Order(\"created_at desc\").Find(&claims).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.NotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn claims, nil\n}",
    "caller": "func (h *EquipmentHandler) HandleEquipmentScores(req *types.EquipmentScoreRequest) ([]types.EquipmentScore, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.Category != \"\" {\n\t\tfilter[\"category\"] = req.Category\n\t} else if req.NetValue > 0 {\n\t\tfilter[\"net_value\"] = req.NetValue\n\t} else if req.Timezone != \"\" {\n\t\tfilter[\"timezone\"] = req.Timezone\n\t} else {\n\t\treturn nil, errors.New(\"at least one filter parameter is required\")\n\t}\n\t\n\tlimit := 20\n\tif req.Limit > 0 {\n\t\tlimit = req.Limit\n\t}\n\t\n\tscoreModel := &Score{}\n\tresult, err := scoreModel.FindByCategory(filter, limit)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to fetch equipment scores: %v\", err)\n\t}\n\t\n\treturn result, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按category查询",
            "sql": "SELECT id, tracking_id, category, net_value, timezone, status, created_at, updated_at FROM market_data WHERE category = ? AND status = ? ORDER BY tracking_id DESC LIMIT 20;"
          },
          {
            "scenario": "按net_value范围查询",
            "sql": "SELECT id, tracking_id, category, net_value, timezone, status, created_at, updated_at FROM market_data WHERE net_value BETWEEN ? AND ? ORDER BY tracking_id DESC LIMIT 20;"
          },
          {
            "scenario": "按timezone模糊查询",
            "sql": "SELECT id, tracking_id, category, net_value, timezone, status, created_at, updated_at FROM market_data WHERE timezone LIKE ? ORDER BY tracking_id DESC LIMIT 20;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "SurgeryClaim",
        "code_value": "type SurgeryClaim struct {\n\tID           int       `json:\"id\" gorm:\"column:id;primaryKey\"`\n\tCategory     string    `json:\"category\" gorm:\"column:category\"`\n\tDeadlineDate time.Time `json:\"deadlineDate\" gorm:\"column:deadline_date\"`\n\tLocationCode string    `json:\"locationCode\" gorm:\"column:location_code\"`\n\tCreatedAt    time.Time `json:\"createdAt\" gorm:\"column:created_at\"`\n\tUpdatedAt    time.Time `json:\"updatedAt\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "FilterParams",
        "code_value": "type FilterParams struct {\n\tCategory      string    \n\tDeadlineDate  time.Time \n\tLocationCode  string    \n}"
      },
      {
        "code_key": "SurgeryTable",
        "code_value": "const SurgeryTable = \"surgery_schedules\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "ClaimStatus",
        "code_value": "type ClaimStatus struct {\n\tPending   string\n\tApproved  string\n\tRejected  string\n}\n\nvar Status = ClaimStatus{\n\tPending:  \"pending\",\n\tApproved: \"approved\",\n\tRejected: \"rejected\",\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ForecastDemand",
    "orm_code": "func (e *Exchange) ForecastDemand(filter map[string]interface{}, limit int) ([]Result, error) {\n\tvar results []Result\n\tdb := base.GetInstance().MainDB().Table(\"medication_inventory\")\n\n\tif subject, ok := filter[\"Subject\"]; ok {\n\t\tdb = db.Where(\"subject LIKE ?\", \"%\"+subject.(string)+\"%\")\n\t\tdelete(filter, \"Subject\")\n\t}\n\n\tif postalCode, ok := filter[\"PostalCode\"]; ok {\n\t\tdb = db.Where(\"postal_code = ?\", postalCode)\n\t\tdelete(filter, \"PostalCode\")\n\t}\n\n\tif len(filter) > 0 {\n\t\tdb = db.Where(filter)\n\t}\n\n\tif limit > 0 {\n\t\tdb = db.Limit(limit)\n\t}\n\n\tif err := db.Find(&results).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "使用location_code过滤",
            "sql": "SELECT id, location_code, parameter_name, configuration_key, projected_value, registration_time FROM warehouse_locations WHERE location_code = ? ORDER BY registration_time DESC;"
          },
          {
            "scenario": "使用parameter_name模糊匹配",
            "sql": "SELECT id, location_code, parameter_name, configuration_key, projected_value, registration_time FROM warehouse_locations WHERE parameter_name LIKE ? ORDER BY registration_time DESC;"
          },
          {
            "scenario": "使用configuration_key IN条件",
            "sql": "SELECT id, location_code, parameter_name, configuration_key, projected_value, registration_time FROM warehouse_locations WHERE configuration_key IN (?) ORDER BY registration_time DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "DemandForecastResult",
        "code_value": "type DemandForecastResult struct {\n\tID           int    `json:\"id\" gorm:\"column:id\"`\n\tSubject      string `json:\"subject\" gorm:\"column:subject\"`\n\tPostalCode   string `json:\"postal_code\" gorm:\"column:postal_code\"`\n\tInventoryQty int    `json:\"inventory_qty\" gorm:\"column:inventory_qty\"`\n\tForecastDate string `json:\"forecast_date\" gorm:\"column:forecast_date\"`\n\tCreatedAt    int64  `json:\"created_at\" gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "ForecastFilter",
        "code_value": "type ForecastFilter struct {\n\tSubject    string `json:\"subject\"`\n\tPostalCode string `json:\"postal_code\"`\n\tMaxResults int    `json:\"max_results\"`\n}"
      },
      {
        "code_key": "MedicationInventoryTable",
        "code_value": "const MedicationInventoryTable = \"medication_inventory\""
      },
      {
        "code_key": "DefaultForecastLimit",
        "code_value": "const DefaultForecastLimit = 100"
      },
      {
        "code_key": "ForecastStatuses",
        "code_value": "var ForecastStatuses = map[string]int{\n\t\"Pending\":   1,\n\t\"Completed\": 2,\n\t\"Failed\":    3,\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ForecastDemand",
    "orm_code": "func (e *Exchange) ForecastDemand(filter map[string]interface{}, limit int) ([]Result, error) {\n\tvar results []Result\n\tdb := base.GetInstance().MainDB().Table(\"medication_inventory\")\n\n\tif subject, ok := filter[\"Subject\"]; ok {\n\t\tdb = db.Where(\"subject LIKE ?\", \"%\"+subject.(string)+\"%\")\n\t\tdelete(filter, \"Subject\")\n\t}\n\n\tif postalCode, ok := filter[\"PostalCode\"]; ok {\n\t\tdb = db.Where(\"postal_code = ?\", postalCode)\n\t\tdelete(filter, \"PostalCode\")\n\t}\n\n\tif len(filter) > 0 {\n\t\tdb = db.Where(filter)\n\t}\n\n\tif limit > 0 {\n\t\tdb = db.Limit(limit)\n\t}\n\n\tif err := db.Find(&results).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}",
    "caller": "func (h *MedicationHandler) HandleMedicationSearch(req *MedicationSearchRequest) ([]Result, error) {\n\tif req == nil {\n\t\treturn nil, fmt.Errorf(\"invalid request\")\n\t}\n\n\tfilter := make(map[string]interface{})\n\tif req.MedicationID > 0 {\n\t\tfilter[\"medication_id\"] = req.MedicationID\n\t} else if req.Category != \"\" {\n\t\tif len(req.Category) > 50 {\n\t\t\treturn nil, fmt.Errorf(\"category name too long\")\n\t\t}\n\t\tfilter[\"category\"] = req.Category\n\t} else if req.MinStock > 0 {\n\t\tfilter[\"stock_quantity\"] = gorm.Expr(\"stock_quantity >= ?\", req.MinStock)\n\t} else {\n\t\tfilter[\"is_active\"] = true\n\t}\n\n\texchange := &Exchange{}\n\tresults, err := exchange.ForecastDemand(filter, req.Limit)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to forecast demand: %v\", err)\n\t}\n\n\tif len(results) == 0 && req.StrictMode {\n\t\treturn nil, fmt.Errorf(\"no results found in strict mode\")\n\t}\n\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "medication_id > 0",
            "sql": "SELECT id, subject, postal_code, inventory_qty, forecast_date, created_at FROM medication_inventory WHERE medication_id = ? LIMIT ?;"
          },
          {
            "scenario": "category not empty and length <= 50",
            "sql": "SELECT id, subject, postal_code, inventory_qty, forecast_date, created_at FROM medication_inventory WHERE category = ? LIMIT ?;"
          },
          {
            "scenario": "min_stock > 0",
            "sql": "SELECT id, subject, postal_code, inventory_qty, forecast_date, created_at FROM medication_inventory WHERE stock_quantity >= ? LIMIT ?;"
          },
          {
            "scenario": "default case (no specific conditions)",
            "sql": "SELECT id, subject, postal_code, inventory_qty, forecast_date, created_at FROM medication_inventory WHERE is_active = true LIMIT ?;"
          },
          {
            "scenario": "medication_id > 0 with Subject filter",
            "sql": "SELECT id, subject, postal_code, inventory_qty, forecast_date, created_at FROM medication_inventory WHERE subject LIKE ? AND medication_id = ? LIMIT ?;"
          },
          {
            "scenario": "medication_id > 0 with PostalCode filter",
            "sql": "SELECT id, subject, postal_code, inventory_qty, forecast_date, created_at FROM medication_inventory WHERE postal_code = ? AND medication_id = ? LIMIT ?;"
          },
          {
            "scenario": "category with Subject and PostalCode filters",
            "sql": "SELECT id, subject, postal_code, inventory_qty, forecast_date, created_at FROM medication_inventory WHERE subject LIKE ? AND postal_code = ? AND category = ? LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "DemandForecastResult",
        "code_value": "type DemandForecastResult struct {\n\tID           int    `json:\"id\" gorm:\"column:id\"`\n\tSubject      string `json:\"subject\" gorm:\"column:subject\"`\n\tPostalCode   string `json:\"postal_code\" gorm:\"column:postal_code\"`\n\tInventoryQty int    `json:\"inventory_qty\" gorm:\"column:inventory_qty\"`\n\tForecastDate string `json:\"forecast_date\" gorm:\"column:forecast_date\"`\n\tCreatedAt    int64  `json:\"created_at\" gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "ForecastFilter",
        "code_value": "type ForecastFilter struct {\n\tSubject    string `json:\"subject\"`\n\tPostalCode string `json:\"postal_code\"`\n\tMaxResults int    `json:\"max_results\"`\n}"
      },
      {
        "code_key": "MedicationInventoryTable",
        "code_value": "const MedicationInventoryTable = \"medication_inventory\""
      },
      {
        "code_key": "DefaultForecastLimit",
        "code_value": "const DefaultForecastLimit = 100"
      },
      {
        "code_key": "ForecastStatuses",
        "code_value": "var ForecastStatuses = map[string]int{\n\t\"Pending\":   1,\n\t\"Completed\": 2,\n\t\"Failed\":    3,\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ForecastDemand",
    "orm_code": "func (e *Exchange) ForecastDemand(filter map[string]interface{}, limit int) ([]Result, error) {\n\tvar results []Result\n\tdb := base.GetInstance().MainDB().Table(\"medication_inventory\")\n\n\tif subject, ok := filter[\"Subject\"]; ok {\n\t\tdb = db.Where(\"subject LIKE ?\", \"%\"+subject.(string)+\"%\")\n\t\tdelete(filter, \"Subject\")\n\t}\n\n\tif postalCode, ok := filter[\"PostalCode\"]; ok {\n\t\tdb = db.Where(\"postal_code = ?\", postalCode)\n\t\tdelete(filter, \"PostalCode\")\n\t}\n\n\tif len(filter) > 0 {\n\t\tdb = db.Where(filter)\n\t}\n\n\tif limit > 0 {\n\t\tdb = db.Limit(limit)\n\t}\n\n\tif err := db.Find(&results).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}",
    "caller": "func (h *InventoryHandler) HandleInventoryProjection(req *types.InventoryProjectionRequest) ([]types.InventoryProjection, error) {\n\tbook := &Book{}\n\tfilters := make(map[string]interface{})\n\n\tswitch req.FilterType {\n\tcase \"location\":\n\t\tif req.LocationCode == \"\" {\n\t\t\treturn nil, errors.New(\"location code cannot be empty\")\n\t\t}\n\t\tfilters[\"location_code\"] = req.LocationCode\n\tcase \"parameter\":\n\t\tif req.ParameterName == \"\" {\n\t\t\treturn nil, errors.New(\"parameter name cannot be empty\")\n\t\t}\n\t\tfilters[\"parameter_name\"] = req.ParameterName\n\tcase \"config\":\n\t\tif len(req.ConfigKeys) == 0 {\n\t\t\treturn nil, errors.New(\"config keys cannot be empty\")\n\t\t}\n\t\tfilters[\"configuration_key\"] = req.ConfigKeys\n\tdefault:\n\t\treturn nil, errors.New(\"invalid filter type\")\n\t}\n\n\tresults, err := book.ForecastDemand(filters)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to forecast demand: %w\", err)\n\t}\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按location_code过滤",
            "sql": "SELECT id, location_code, parameter_name, configuration_key, projected_value, registration_time FROM warehouse_locations WHERE location_code = 'WH001' ORDER BY registration_time DESC;"
          },
          {
            "scenario": "按parameter_name模糊匹配",
            "sql": "SELECT id, location_code, parameter_name, configuration_key, projected_value, registration_time FROM warehouse_locations WHERE parameter_name LIKE '%demand%' ORDER BY registration_time DESC;"
          },
          {
            "scenario": "按configuration_key IN条件",
            "sql": "SELECT id, location_code, parameter_name, configuration_key, projected_value, registration_time FROM warehouse_locations WHERE configuration_key IN ('CFG001', 'CFG002') ORDER BY registration_time DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "DemandForecastResult",
        "code_value": "type DemandForecastResult struct {\n\tID           int    `json:\"id\" gorm:\"column:id\"`\n\tSubject      string `json:\"subject\" gorm:\"column:subject\"`\n\tPostalCode   string `json:\"postal_code\" gorm:\"column:postal_code\"`\n\tInventoryQty int    `json:\"inventory_qty\" gorm:\"column:inventory_qty\"`\n\tForecastDate string `json:\"forecast_date\" gorm:\"column:forecast_date\"`\n\tCreatedAt    int64  `json:\"created_at\" gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "ForecastFilter",
        "code_value": "type ForecastFilter struct {\n\tSubject    string `json:\"subject\"`\n\tPostalCode string `json:\"postal_code\"`\n\tMaxResults int    `json:\"max_results\"`\n}"
      },
      {
        "code_key": "MedicationInventoryTable",
        "code_value": "const MedicationInventoryTable = \"medication_inventory\""
      },
      {
        "code_key": "DefaultForecastLimit",
        "code_value": "const DefaultForecastLimit = 100"
      },
      {
        "code_key": "ForecastStatuses",
        "code_value": "var ForecastStatuses = map[string]int{\n\t\"Pending\":   1,\n\t\"Completed\": 2,\n\t\"Failed\":    3,\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ValidateByRules",
    "orm_code": "func (e *Exchange) ValidateByRules(filter map[string]interface{}) ([]types.SecurityClearance, error) {\n\tvar clearances []types.SecurityClearance\n\tquery := base.GetInstance().GormDB().Table(\"security_clearances\")\n\t\n\tif region, ok := filter[\"Region\"]; ok {\n\t\tquery = query.Where(\"region = ?\", region)\n\t\tif level, ok := filter[\"Level\"]; ok {\n\t\t\tquery = query.Where(\"clearance_level >= ?\", level)\n\t\t}\n\t} else if genre, ok := filter[\"Genre\"]; ok {\n\t\tquery = query.Where(\"genre LIKE ?\", \"%\"+genre.(string)+\"%\")\n\t} else {\n\t\tquery = query.Where(filter)\n\t}\n\t\n\tif err := query.Find(&clearances).Error; err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn clearances, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "validationParams contains Editor parameter",
            "sql": "SELECT * FROM maintenance_logs WHERE editor = ? AND status = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "validationParams contains Subject parameter",
            "sql": "SELECT * FROM maintenance_logs WHERE subject LIKE ? LIMIT 100;"
          },
          {
            "scenario": "validationParams contains ShipmentId parameter",
            "sql": "SELECT maintenance_logs.* FROM maintenance_logs LEFT JOIN department_structure ON maintenance_logs.department_id = department_structure.id WHERE shipment_id = ? AND department_structure.region = ?;"
          },
          {
            "scenario": "validationParams contains other parameters",
            "sql": "SELECT * FROM maintenance_logs WHERE status = ? AND department_id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "SecurityClearance",
        "code_value": "type SecurityClearance struct {\n\tID             int       `gorm:\"column:id;primaryKey\"`\n\tRegion         string    `gorm:\"column:region\"`\n\tClearanceLevel int       `gorm:\"column:clearance_level\"`\n\tGenre          string    `gorm:\"column:genre\"`\n\tCreatedAt      time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt      time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "Exchange",
        "code_value": "type Exchange struct {\n\tDB *gorm.DB `gorm:\"-\"`\n}"
      },
      {
        "code_key": "TableNameSecurityClearances",
        "code_value": "const TableNameSecurityClearances = \"security_clearances\""
      },
      {
        "code_key": "ClearanceLevelThreshold",
        "code_value": "const ClearanceLevelThreshold = 3"
      },
      {
        "code_key": "DefaultRegion",
        "code_value": "const DefaultRegion = \"EMEA\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ValidateByRules",
    "orm_code": "func (e *Exchange) ValidateByRules(filter map[string]interface{}) ([]types.SecurityClearance, error) {\n\tvar clearances []types.SecurityClearance\n\tquery := base.GetInstance().GormDB().Table(\"security_clearances\")\n\t\n\tif region, ok := filter[\"Region\"]; ok {\n\t\tquery = query.Where(\"region = ?\", region)\n\t\tif level, ok := filter[\"Level\"]; ok {\n\t\t\tquery = query.Where(\"clearance_level >= ?\", level)\n\t\t}\n\t} else if genre, ok := filter[\"Genre\"]; ok {\n\t\tquery = query.Where(\"genre LIKE ?\", \"%\"+genre.(string)+\"%\")\n\t} else {\n\t\tquery = query.Where(filter)\n\t}\n\t\n\tif err := query.Find(&clearances).Error; err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn clearances, nil\n}",
    "caller": "func (d *DiagnosisHandler) HandleDiagnosis(req *types.DiagnosisRequest, log *logger.MedLog) ([]types.SecurityClearance, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.PatientID != \"\" {\n\t\tfilter[\"Region\"] = \"EMEA\"\n\t\tif req.Priority > 0 {\n\t\t\tfilter[\"Level\"] = req.Priority\n\t\t}\n\t} else if req.DiagnosisCode != \"\" {\n\t\tfilter[\"Genre\"] = req.DiagnosisCode\n\t} else if req.Status != 0 {\n\t\tfilter[\"status\"] = req.Status\n\t} else {\n\t\treturn nil, fmt.Errorf(\"invalid query parameters\")\n\t}\n\n\texch := &Exchange{}\n\tresults, err := exch.ValidateByRules(filter)\n\tif err != nil {\n\t\tlog.Error(fmt.Sprintf(\"ValidateByRules failed: %v\", err))\n\t\treturn nil, err\n\t}\n\t\n\tif len(results) == 0 {\n\t\tlog.Warn(\"No matching security clearances found\")\n\t}\n\t\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "患者ID存在且优先级>0",
            "sql": "SELECT id, region, clearance_level, genre, created_at, updated_at FROM security_clearances WHERE region = 'EMEA' AND clearance_level >= ?;"
          },
          {
            "scenario": "患者ID存在但优先级未设置",
            "sql": "SELECT id, region, clearance_level, genre, created_at, updated_at FROM security_clearances WHERE region = 'EMEA';"
          },
          {
            "scenario": "诊断代码存在",
            "sql": "SELECT id, region, clearance_level, genre, created_at, updated_at FROM security_clearances WHERE genre LIKE ?;"
          },
          {
            "scenario": "状态不为0",
            "sql": "SELECT id, region, clearance_level, genre, created_at, updated_at FROM security_clearances WHERE status = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "SecurityClearance",
        "code_value": "type SecurityClearance struct {\n\tID             int       `gorm:\"column:id;primaryKey\"`\n\tRegion         string    `gorm:\"column:region\"`\n\tClearanceLevel int       `gorm:\"column:clearance_level\"`\n\tGenre          string    `gorm:\"column:genre\"`\n\tCreatedAt      time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt      time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "Exchange",
        "code_value": "type Exchange struct {\n\tDB *gorm.DB `gorm:\"-\"`\n}"
      },
      {
        "code_key": "TableNameSecurityClearances",
        "code_value": "const TableNameSecurityClearances = \"security_clearances\""
      },
      {
        "code_key": "ClearanceLevelThreshold",
        "code_value": "const ClearanceLevelThreshold = 3"
      },
      {
        "code_key": "DefaultRegion",
        "code_value": "const DefaultRegion = \"EMEA\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ValidateByRules",
    "orm_code": "func (e *Exchange) ValidateByRules(filter map[string]interface{}) ([]types.SecurityClearance, error) {\n\tvar clearances []types.SecurityClearance\n\tquery := base.GetInstance().GormDB().Table(\"security_clearances\")\n\t\n\tif region, ok := filter[\"Region\"]; ok {\n\t\tquery = query.Where(\"region = ?\", region)\n\t\tif level, ok := filter[\"Level\"]; ok {\n\t\t\tquery = query.Where(\"clearance_level >= ?\", level)\n\t\t}\n\t} else if genre, ok := filter[\"Genre\"]; ok {\n\t\tquery = query.Where(\"genre LIKE ?\", \"%\"+genre.(string)+\"%\")\n\t} else {\n\t\tquery = query.Where(filter)\n\t}\n\t\n\tif err := query.Find(&clearances).Error; err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn clearances, nil\n}",
    "caller": "func (s *MaintenanceService) HandleMaintenanceLogs(req *types.MaintenanceLogRequest) ([]types.AchievementRecord, error) {\n\tif req == nil {\n\t\treturn nil, fmt.Errorf(\"invalid request parameters\")\n\t}\n\n\tvalidator := &Achievement{}\n\tparams := make(map[string]interface{})\n\n\tswitch {\n\tcase req.Editor != \"\":\n\t\tparams[\"Editor\"] = req.Editor\n\tcase req.Subject != \"\":\n\t\tparams[\"Subject\"] = req.Subject\n\tcase req.ShipmentID != \"\":\n\t\tparams[\"ShipmentId\"] = req.ShipmentID\n\tdefault:\n\t\tparams[\"status\"] = \"active\"\n\t}\n\n\tresults, err := validator.ValidateByRules(params)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"validation failed: %v\", err)\n\t}\n\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Editor参数非空",
            "sql": "SELECT maintenance_logs.id, maintenance_logs.editor, maintenance_logs.subject, maintenance_logs.shipment_id, maintenance_logs.department_id, maintenance_logs.status, maintenance_logs.created_at, maintenance_logs.updated_at FROM maintenance_logs WHERE editor = ? AND status = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "Subject参数非空",
            "sql": "SELECT maintenance_logs.id, maintenance_logs.editor, maintenance_logs.subject, maintenance_logs.shipment_id, maintenance_logs.department_id, maintenance_logs.status, maintenance_logs.created_at, maintenance_logs.updated_at FROM maintenance_logs WHERE subject LIKE ? LIMIT 100;"
          },
          {
            "scenario": "ShipmentId参数非空",
            "sql": "SELECT maintenance_logs.id, maintenance_logs.editor, maintenance_logs.subject, maintenance_logs.shipment_id, maintenance_logs.department_id, maintenance_logs.status, maintenance_logs.created_at, maintenance_logs.updated_at FROM maintenance_logs LEFT JOIN department_structure ON maintenance_logs.department_id = department_structure.id WHERE shipment_id = ? AND department_structure.region = ?;"
          },
          {
            "scenario": "默认参数",
            "sql": "SELECT maintenance_logs.id, maintenance_logs.editor, maintenance_logs.subject, maintenance_logs.shipment_id, maintenance_logs.department_id, maintenance_logs.status, maintenance_logs.created_at, maintenance_logs.updated_at FROM maintenance_logs WHERE status = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "SecurityClearance",
        "code_value": "type SecurityClearance struct {\n\tID             int       `gorm:\"column:id;primaryKey\"`\n\tRegion         string    `gorm:\"column:region\"`\n\tClearanceLevel int       `gorm:\"column:clearance_level\"`\n\tGenre          string    `gorm:\"column:genre\"`\n\tCreatedAt      time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt      time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "Exchange",
        "code_value": "type Exchange struct {\n\tDB *gorm.DB `gorm:\"-\"`\n}"
      },
      {
        "code_key": "TableNameSecurityClearances",
        "code_value": "const TableNameSecurityClearances = \"security_clearances\""
      },
      {
        "code_key": "ClearanceLevelThreshold",
        "code_value": "const ClearanceLevelThreshold = 3"
      },
      {
        "code_key": "DefaultRegion",
        "code_value": "const DefaultRegion = \"EMEA\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ValidatePermissions",
    "orm_code": "func (p *Profile) ValidatePermissions(filter map[string]interface{}) ([]types.AccessControl, error) {\n\tvar permissions []types.AccessControl\n\tdb := base.GetInstance().MainDB().Table(\"contract_agreements\")\n\t\n\tif role, ok := filter[\"Role\"]; ok {\n\t\tif level, ok := filter[\"Level\"]; ok {\n\t\t\tdb = db.Where(\"role = ? AND level >= ?\", role, level)\n\t\t} else {\n\t\t\tdb = db.Where(\"role = ?\", role)\n\t\t}\n\t} else if category, ok := filter[\"Category\"]; ok {\n\t\tdb = db.Where(\"category LIKE ?\", \"%\"+category.(string)+\"%\")\n\t}\n\n\tif err := db.Find(&permissions).Error; err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn permissions, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "filter contains both Role and Level",
            "sql": "SELECT id, role, level, category, created_at, updated_at FROM contract_agreements WHERE role = ? AND level >= ?;"
          },
          {
            "scenario": "filter contains only Role",
            "sql": "SELECT id, role, level, category, created_at, updated_at FROM contract_agreements WHERE role = ?;"
          },
          {
            "scenario": "filter contains only Category",
            "sql": "SELECT id, role, level, category, created_at, updated_at FROM contract_agreements WHERE category LIKE ?;"
          },
          {
            "scenario": "filter is empty",
            "sql": "SELECT id, role, level, category, created_at, updated_at FROM contract_agreements;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "AccessControl",
        "code_value": "type AccessControl struct {\n\tID        uint   `gorm:\"primaryKey;column:id\"`\n\tRole      string `gorm:\"column:role\"`\n\tLevel     int    `gorm:\"column:level\"`\n\tCategory  string `gorm:\"column:category\"`\n\tCreatedAt int64  `gorm:\"autoCreateTime;column:created_at\"`\n\tUpdatedAt int64  `gorm:\"autoUpdateTime;column:updated_at\"`\n}"
      },
      {
        "code_key": "PermissionFilter",
        "code_value": "type PermissionFilter struct {\n\tRole     string\n\tLevel    int\n\tCategory string\n}"
      },
      {
        "code_key": "TableNameContractAgreements",
        "code_value": "const TableNameContractAgreements = \"contract_agreements\""
      },
      {
        "code_key": "DefaultAccessLevel",
        "code_value": "const DefaultAccessLevel = 1"
      },
      {
        "code_key": "AdminRole",
        "code_value": "const AdminRole = \"admin\""
      },
      {
        "code_key": "Profile",
        "code_value": "type Profile struct {\n\tID        uint   `gorm:\"primaryKey\"`\n\tUserID    string `gorm:\"uniqueIndex\"`\n\tAccess    []AccessControl\n\tCreatedAt int64  `gorm:\"autoCreateTime\"`\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ValidatePermissions",
    "orm_code": "func (p *Profile) ValidatePermissions(filter map[string]interface{}) ([]types.AccessControl, error) {\n\tvar permissions []types.AccessControl\n\tdb := base.GetInstance().MainDB().Table(\"contract_agreements\")\n\t\n\tif role, ok := filter[\"Role\"]; ok {\n\t\tif level, ok := filter[\"Level\"]; ok {\n\t\t\tdb = db.Where(\"role = ? AND level >= ?\", role, level)\n\t\t} else {\n\t\t\tdb = db.Where(\"role = ?\", role)\n\t\t}\n\t} else if category, ok := filter[\"Category\"]; ok {\n\t\tdb = db.Where(\"category LIKE ?\", \"%\"+category.(string)+\"%\")\n\t}\n\n\tif err := db.Find(&permissions).Error; err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn permissions, nil\n}",
    "caller": "func (i *InsuranceHandler) HandleInsuranceClaims(req *types.ClaimRequest, log *logger.AppLog) ([]types.ClaimResult, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.PolicyID != \"\" {\n\t\tfilter[\"Role\"] = \"policy_holder\"\n\t\tfilter[\"Level\"] = 3\n\t} else if req.ClaimAmount > 10000 {\n\t\tfilter[\"Category\"] = \"high_value\"\n\t} else if req.HospitalCode != \"\" {\n\t\tfilter[\"Role\"] = \"medical_provider\"\n\t} else {\n\t\treturn nil, fmt.Errorf(\"invalid claim parameters: need either policy ID, claim amount or hospital code\")\n\t}\n\n\tprofile := &Profile{}\n\tclaims, err := profile.ValidatePermissions(filter)\n\tif err != nil {\n\t\tlog.Error(\"Failed to validate insurance permissions\", \"error\", err)\n\t\treturn nil, fmt.Errorf(\"permission validation failed: %v\", err)\n\t}\n\n\tresults := make([]types.ClaimResult, 0, len(claims))\n\tfor _, c := range claims {\n\t\tresults = append(results, types.ClaimResult{\n\t\t\tClaimID:    c.ClaimID,\n\t\t\tStatus:     c.Status,\n\t\t\tValidUntil: c.ValidUntil,\n\t\t})\n\t}\n\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "有PolicyID",
            "sql": "SELECT id, role, level, category, created_at, updated_at FROM contract_agreements WHERE role = 'policy_holder' AND level >= 3;"
          },
          {
            "scenario": "无PolicyID但ClaimAmount>10000",
            "sql": "SELECT id, role, level, category, created_at, updated_at FROM contract_agreements WHERE category LIKE '%high_value%';"
          },
          {
            "scenario": "无PolicyID且ClaimAmount≤10000但有HospitalCode",
            "sql": "SELECT id, role, level, category, created_at, updated_at FROM contract_agreements WHERE role = 'medical_provider';"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "AccessControl",
        "code_value": "type AccessControl struct {\n\tID        uint   `gorm:\"primaryKey;column:id\"`\n\tRole      string `gorm:\"column:role\"`\n\tLevel     int    `gorm:\"column:level\"`\n\tCategory  string `gorm:\"column:category\"`\n\tCreatedAt int64  `gorm:\"autoCreateTime;column:created_at\"`\n\tUpdatedAt int64  `gorm:\"autoUpdateTime;column:updated_at\"`\n}"
      },
      {
        "code_key": "PermissionFilter",
        "code_value": "type PermissionFilter struct {\n\tRole     string\n\tLevel    int\n\tCategory string\n}"
      },
      {
        "code_key": "TableNameContractAgreements",
        "code_value": "const TableNameContractAgreements = \"contract_agreements\""
      },
      {
        "code_key": "DefaultAccessLevel",
        "code_value": "const DefaultAccessLevel = 1"
      },
      {
        "code_key": "AdminRole",
        "code_value": "const AdminRole = \"admin\""
      },
      {
        "code_key": "Profile",
        "code_value": "type Profile struct {\n\tID        uint   `gorm:\"primaryKey\"`\n\tUserID    string `gorm:\"uniqueIndex\"`\n\tAccess    []AccessControl\n\tCreatedAt int64  `gorm:\"autoCreateTime\"`\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "UpdateInventory",
    "orm_code": "func (e *Equipment) UpdateInventory(filter map[string]interface{}, page, size int) ([]types.EquipmentRecord, error) {\n\tvar records []types.EquipmentRecord\n\tdb := base.GetInstance().GormDB().Table(\"grade_records\")\n\n\tif room, ok := filter[\"Room\"]; ok {\n\t\tdelete(filter, \"Room\")\n\t\terr := db.Where(\"room = ?\", room).Where(filter).Scopes(PaginateDB(page, size)).Find(&records).Error\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else if refreshKey, ok := filter[\"RefreshKey\"]; ok {\n\t\tdelete(filter, \"RefreshKey\")\n\t\terr := db.Where(\"refresh_key LIKE ?\", \"%\"+refreshKey.(string)+\"%\").Where(filter).Scopes(PaginateDB(page, size)).Find(&records).Error\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\terr := db.Where(filter).Scopes(PaginateDB(page, size)).Find(&records).Error\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn records, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "filter包含Room键",
            "sql": "SELECT id, name, room, status, refresh_key, created_at, updated_at FROM grade_records WHERE room = ? AND status = ? LIMIT 10 OFFSET 0;"
          },
          {
            "scenario": "filter包含RefreshKey键",
            "sql": "SELECT id, name, room, status, refresh_key, created_at, updated_at FROM grade_records WHERE refresh_key LIKE ? AND name = ? LIMIT 5 OFFSET 5;"
          },
          {
            "scenario": "filter不包含特殊键",
            "sql": "SELECT id, name, room, status, refresh_key, created_at, updated_at FROM grade_records WHERE status = ? AND name = ? LIMIT 20 OFFSET 0;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "EquipmentRecord",
        "code_value": "type EquipmentRecord struct {\n\tID        int    `json:\"id\" gorm:\"column:id\"`\n\tName      string `json:\"name\" gorm:\"column:name\"`\n\tRoom      string `json:\"room\" gorm:\"column:room\"`\n\tStatus    int    `json:\"status\" gorm:\"column:status\"`\n\tRefreshKey string `json:\"refresh_key\" gorm:\"column:refresh_key\"`\n\tCreatedAt int64  `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt int64  `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "InventoryResult",
        "code_value": "type InventoryResult struct {\n\tRecords []EquipmentRecord `json:\"records\"`\n\tTotal   int              `json:\"total\"`\n\tPage    int              `json:\"page\"`\n\tSize    int              `json:\"size\"`\n}"
      },
      {
        "code_key": "EquipmentFilter",
        "code_value": "type EquipmentFilter struct {\n\tRoom       *string `json:\"room\"`\n\tRefreshKey *string `json:\"refresh_key\"`\n\tStatus     *int    `json:\"status\"`\n\tName       *string `json:\"name\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "const TableName = \"equipment_records\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "StatusActive",
        "code_value": "const StatusActive = 1"
      },
      {
        "code_key": "StatusInactive",
        "code_value": "const StatusInactive = 0"
      },
      {
        "code_key": "Equipment",
        "code_value": "type Equipment struct {\n\tBaseModel\n\tCacheHandler *CacheHandler `json:\"-\"`\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "UpdateInventory",
    "orm_code": "func (e *Equipment) UpdateInventory(filter map[string]interface{}, page, size int) ([]types.EquipmentRecord, error) {\n\tvar records []types.EquipmentRecord\n\tdb := base.GetInstance().GormDB().Table(\"grade_records\")\n\n\tif room, ok := filter[\"Room\"]; ok {\n\t\tdelete(filter, \"Room\")\n\t\terr := db.Where(\"room = ?\", room).Where(filter).Scopes(PaginateDB(page, size)).Find(&records).Error\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else if refreshKey, ok := filter[\"RefreshKey\"]; ok {\n\t\tdelete(filter, \"RefreshKey\")\n\t\terr := db.Where(\"refresh_key LIKE ?\", \"%\"+refreshKey.(string)+\"%\").Where(filter).Scopes(PaginateDB(page, size)).Find(&records).Error\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\terr := db.Where(filter).Scopes(PaginateDB(page, size)).Find(&records).Error\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn records, nil\n}",
    "caller": "func (h *EquipmentHandler) HandleEquipmentQuery(req *types.EquipmentQueryRequest, log *logger.AppLog) ([]types.EquipmentRecord, error) {\n\tfilter := make(map[string]interface{})\n\tpage, size := utils.Paginate(req.Page, req.Size)\n\n\tif req.EquipmentID != \"\" {\n\t\tfilter[\"equipment_id\"] = req.EquipmentID\n\t} else if req.Status != 0 {\n\t\tif req.Status < 1 || req.Status > 3 {\n\t\t\tlog.Error(\"Invalid status parameter\")\n\t\t\treturn nil, errors.New(\"invalid status value\")\n\t\t}\n\t\tfilter[\"status\"] = req.Status\n\t} else if req.Type != \"\" {\n\t\tif len(req.Type) > 20 {\n\t\t\tlog.Error(\"Type parameter too long\")\n\t\t\treturn nil, errors.New(\"type parameter exceeds limit\")\n\t\t}\n\t\tfilter[\"type\"] = req.Type\n\t} else {\n\t\tfilter[\"department\"] = req.Department\n\t}\n\n\tequipment := &Equipment{}\n\tresults, err := equipment.UpdateInventory(filter, page, size)\n\tif err != nil {\n\t\tlog.Error(fmt.Sprintf(\"Failed to query equipment: %v\", err))\n\t\treturn nil, err\n\t}\n\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "LACK_INFORMATION",
        "variants": [
          {
            "scenario": "PaginateDB函数实现未提供，假设它会添加标准分页逻辑",
            "sql": "SELECT id, name, room, status, refresh_key, created_at, updated_at FROM grade_records WHERE equipment_id = ? LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "grade_records表与EquipmentRecord结构体映射不一致，可能导致字段映射问题",
            "sql": ""
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "equipment_id条件",
            "sql": "SELECT id, name, room, status, refresh_key, created_at, updated_at FROM grade_records WHERE equipment_id = ? LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "status条件",
            "sql": "SELECT id, name, room, status, refresh_key, created_at, updated_at FROM grade_records WHERE status = ? LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "type条件",
            "sql": "SELECT id, name, room, status, refresh_key, created_at, updated_at FROM grade_records WHERE type = ? LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "department条件",
            "sql": "SELECT id, name, room, status, refresh_key, created_at, updated_at FROM grade_records WHERE department = ? LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "SELECT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "EquipmentRecord",
        "code_value": "type EquipmentRecord struct {\n\tID        int    `json:\"id\" gorm:\"column:id\"`\n\tName      string `json:\"name\" gorm:\"column:name\"`\n\tRoom      string `json:\"room\" gorm:\"column:room\"`\n\tStatus    int    `json:\"status\" gorm:\"column:status\"`\n\tRefreshKey string `json:\"refresh_key\" gorm:\"column:refresh_key\"`\n\tCreatedAt int64  `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt int64  `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "InventoryResult",
        "code_value": "type InventoryResult struct {\n\tRecords []EquipmentRecord `json:\"records\"`\n\tTotal   int              `json:\"total\"`\n\tPage    int              `json:\"page\"`\n\tSize    int              `json:\"size\"`\n}"
      },
      {
        "code_key": "EquipmentFilter",
        "code_value": "type EquipmentFilter struct {\n\tRoom       *string `json:\"room\"`\n\tRefreshKey *string `json:\"refresh_key\"`\n\tStatus     *int    `json:\"status\"`\n\tName       *string `json:\"name\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "const TableName = \"equipment_records\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "StatusActive",
        "code_value": "const StatusActive = 1"
      },
      {
        "code_key": "StatusInactive",
        "code_value": "const StatusInactive = 0"
      },
      {
        "code_key": "Equipment",
        "code_value": "type Equipment struct {\n\tBaseModel\n\tCacheHandler *CacheHandler `json:\"-\"`\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "AuthorizeAccess",
    "orm_code": "func (p *Player) AuthorizeAccess(filter map[string]interface{}) ([]types.PlayerAccess, error) {\n\tvar accesses []types.PlayerAccess\n\tdb := base.GetInstance().GormDriver().Table(\"user_profiles\")\n\n\tif token, exists := filter[\"SessionToken\"]; exists {\n\t\tdb = db.Where(\"session_token = ? AND status = ?\", token.(string), \"active\")\n\t\tdelete(filter, \"SessionToken\")\n\t} else if district, exists := filter[\"District\"]; exists {\n\t\tdb = db.Where(\"district LIKE ?\", \"%\"+district.(string)+\"%\")\n\t\tdelete(filter, \"District\")\n\t}\n\n\tif len(filter) > 0 {\n\t\tdb = db.Where(filter)\n\t}\n\n\tif err := db.Find(&accesses).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn accesses, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "filter包含SessionToken",
            "sql": "SELECT id, player_id, access_level, session_token, district, status, created_at, updated_at FROM user_profiles WHERE session_token = ? AND status = ? AND access_level = ?;"
          },
          {
            "scenario": "filter包含District但不包含SessionToken",
            "sql": "SELECT id, player_id, access_level, session_token, district, status, created_at, updated_at FROM user_profiles WHERE district LIKE ? AND status = ?;"
          },
          {
            "scenario": "filter同时包含SessionToken和District",
            "sql": "SELECT id, player_id, access_level, session_token, district, status, created_at, updated_at FROM user_profiles WHERE session_token = ? AND status = ?;"
          },
          {
            "scenario": "filter不包含SessionToken或District",
            "sql": "SELECT id, player_id, access_level, session_token, district, status, created_at, updated_at FROM user_profiles WHERE access_level = ? AND status = ?;"
          },
          {
            "scenario": "filter为空",
            "sql": "SELECT id, player_id, access_level, session_token, district, status, created_at, updated_at FROM user_profiles;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PlayerAccess",
        "code_value": "type PlayerAccess struct {\n\tID          uint      `gorm:\"primaryKey\"`\n\tPlayerID    string    `gorm:\"column:player_id\"`\n\tAccessLevel int       `gorm:\"column:access_level\"`\n\tSessionToken string   `gorm:\"column:session_token\"`\n\tDistrict     string   `gorm:\"column:district\"`\n\tStatus       string   `gorm:\"column:status\"`\n\tCreatedAt    time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt    time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "AccessStatus",
        "code_value": "const (\n\tAccessActive    = \"active\"\n\tAccessSuspended = \"suspended\"\n\tAccessRevoked   = \"revoked\"\n)"
      },
      {
        "code_key": "DefaultAccessLevel",
        "code_value": "const DefaultAccessLevel = 1"
      },
      {
        "code_key": "UserProfileTable",
        "code_value": "const UserProfileTable = \"user_profiles\""
      },
      {
        "code_key": "AccessFilter",
        "code_value": "type AccessFilter struct {\n\tPlayerIDs    []string `json:\"player_ids\"`\n\tMinLevel     int      `json:\"min_level\"`\n\tExcludeZones []string `json:\"exclude_zones\"`\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "AuthorizeAccess",
    "orm_code": "func (p *Player) AuthorizeAccess(filter map[string]interface{}) ([]types.PlayerAccess, error) {\n\tvar accesses []types.PlayerAccess\n\tdb := base.GetInstance().GormDriver().Table(\"user_profiles\")\n\n\tif token, exists := filter[\"SessionToken\"]; exists {\n\t\tdb = db.Where(\"session_token = ? AND status = ?\", token.(string), \"active\")\n\t\tdelete(filter, \"SessionToken\")\n\t} else if district, exists := filter[\"District\"]; exists {\n\t\tdb = db.Where(\"district LIKE ?\", \"%\"+district.(string)+\"%\")\n\t\tdelete(filter, \"District\")\n\t}\n\n\tif len(filter) > 0 {\n\t\tdb = db.Where(filter)\n\t}\n\n\tif err := db.Find(&accesses).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn accesses, nil\n}",
    "caller": "func (h *PlayerHandler) HandlePlayerAccess(req *types.PlayerAccessRequest) ([]types.PlayerAccess, error) {\n\tif req == nil {\n\t\treturn nil, fmt.Errorf(\"invalid request\")\n\t}\n\n\tfilter := make(map[string]interface{})\n\tif req.PlayerID != \"\" {\n\t\tfilter[\"player_id\"] = req.PlayerID\n\t} else if req.AccessLevel > 0 {\n\t\tif req.AccessLevel > 5 {\n\t\t\treturn nil, fmt.Errorf(\"invalid access level\")\n\t\t}\n\t\tfilter[\"access_level\"] = req.AccessLevel\n\t} else if req.Region != \"\" {\n\t\tif len(req.Region) > 50 {\n\t\t\treturn nil, fmt.Errorf(\"region too long\")\n\t\t}\n\t\tfilter[\"Region\"] = req.Region\n\t} else {\n\t\tfilter[\"status\"] = \"pending\"\n\t}\n\n\tplayer := &Player{}\n\taccesses, err := player.AuthorizeAccess(filter)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to authorize access: %v\", err)\n\t}\n\n\tif len(accesses) == 0 {\n\t\treturn nil, fmt.Errorf(\"no matching records found\")\n\t}\n\treturn accesses, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "提供PlayerID",
            "sql": "SELECT * FROM user_profiles WHERE player_id = 'player123';"
          },
          {
            "scenario": "提供AccessLevel (1-5)",
            "sql": "SELECT * FROM user_profiles WHERE access_level = 3;"
          },
          {
            "scenario": "提供Region",
            "sql": "SELECT * FROM user_profiles WHERE district LIKE '%North%';"
          },
          {
            "scenario": "无特定条件 (默认status=pending)",
            "sql": "SELECT * FROM user_profiles WHERE status = 'pending';"
          },
          {
            "scenario": "提供SessionToken",
            "sql": "SELECT * FROM user_profiles WHERE session_token = 'token123' AND status = 'active';"
          },
          {
            "scenario": "组合条件",
            "sql": "SELECT * FROM user_profiles WHERE player_id = 'player123' AND access_level = 3 AND status = 'active';"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PlayerAccess",
        "code_value": "type PlayerAccess struct {\n\tID          uint      `gorm:\"primaryKey\"`\n\tPlayerID    string    `gorm:\"column:player_id\"`\n\tAccessLevel int       `gorm:\"column:access_level\"`\n\tSessionToken string   `gorm:\"column:session_token\"`\n\tDistrict     string   `gorm:\"column:district\"`\n\tStatus       string   `gorm:\"column:status\"`\n\tCreatedAt    time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt    time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "AccessStatus",
        "code_value": "const (\n\tAccessActive    = \"active\"\n\tAccessSuspended = \"suspended\"\n\tAccessRevoked   = \"revoked\"\n)"
      },
      {
        "code_key": "DefaultAccessLevel",
        "code_value": "const DefaultAccessLevel = 1"
      },
      {
        "code_key": "UserProfileTable",
        "code_value": "const UserProfileTable = \"user_profiles\""
      },
      {
        "code_key": "AccessFilter",
        "code_value": "type AccessFilter struct {\n\tPlayerIDs    []string `json:\"player_ids\"`\n\tMinLevel     int      `json:\"min_level\"`\n\tExcludeZones []string `json:\"exclude_zones\"`\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "FilterByAttribute",
    "orm_code": "func (m *Magazine) FilterByAttribute(filters map[string]interface{}, page, size int) ([]types.MagazinePublication, error) {\n\tvar publications []types.MagazinePublication\n\tvar err error\n\tquery := base.GetInstance().Db().Table(\"asset_inventory\").Order(\"publication_date\")\n\n\tif topic, ok := filters[\"topic\"]; ok {\n\t\tquery = query.Where(\"topic LIKE ?\", \"%\"+topic.(string)+\"%\")\n\t\tdelete(filters, \"topic\")\n\t}\n\n\tif limit, ok := filters[\"limit\"]; ok {\n\t\tquery = query.Where(\"monthly_limit > ?\", limit.(int))\n\t\tdelete(filters, \"limit\")\n\t}\n\n\terr = query.Scopes(PaginateDB(page, size)).Where(filters).Find(&publications).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn publications, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn publications, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "CertificateId condition (exact match)",
            "sql": "SELECT id, certificate_id, district, country, status, created_at, updated_at FROM character_inventory WHERE certificate_id = ? ORDER BY created_at DESC LIMIT 10 OFFSET 0;"
          },
          {
            "scenario": "District condition (partial match)",
            "sql": "SELECT id, certificate_id, district, country, status, created_at, updated_at FROM character_inventory WHERE district LIKE ? ORDER BY created_at DESC LIMIT 10 OFFSET 0;"
          },
          {
            "scenario": "Country condition (exact match with additional status filter)",
            "sql": "SELECT id, certificate_id, district, country, status, created_at, updated_at FROM character_inventory WHERE country = ? AND status = 'active' ORDER BY created_at DESC LIMIT 10 OFFSET 0;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "MagazinePublication",
        "code_value": "type MagazinePublication struct {\n\tID              int       `json:\"id\" gorm:\"column:id\"`\n\tTitle           string    `json:\"title\" gorm:\"column:title\"`\n\tTopic           string    `json:\"topic\" gorm:\"column:topic\"`\n\tPublicationDate time.Time `json:\"publication_date\" gorm:\"column:publication_date\"`\n\tMonthlyLimit    int       `json:\"monthly_limit\" gorm:\"column:monthly_limit\"`\n\tCreatedAt       time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt       time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "PublicationFilter",
        "code_value": "type PublicationFilter struct {\n\tTopic        *string \n\tMonthlyLimit *int    \n\tStatus       *string \n\tPublisherID  *int    \n}"
      },
      {
        "code_key": "PublicationResponse",
        "code_value": "type PublicationResponse struct {\n\tPublications []MagazinePublication `json:\"publications\"`\n\tTotalCount   int                   `json:\"total_count\"`\n\tPage         int                   `json:\"page\"`\n\tSize         int                   `json:\"size\"`\n}"
      },
      {
        "code_key": "TableNamePublications",
        "code_value": "const TableNamePublications = \"magazine_publications\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "MaxPageSize",
        "code_value": "const MaxPageSize = 100"
      },
      {
        "code_key": "PublicationStatus",
        "code_value": "var PublicationStatus = struct {\n\tDraft     string\n\tPublished string\n\tArchived  string\n}{\n\tDraft:     \"draft\",\n\tPublished: \"published\",\n\tArchived:  \"archived\",\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "FilterByAttribute",
    "orm_code": "func (m *Magazine) FilterByAttribute(filters map[string]interface{}, page, size int) ([]types.MagazinePublication, error) {\n\tvar publications []types.MagazinePublication\n\tvar err error\n\tquery := base.GetInstance().Db().Table(\"asset_inventory\").Order(\"publication_date\")\n\n\tif topic, ok := filters[\"topic\"]; ok {\n\t\tquery = query.Where(\"topic LIKE ?\", \"%\"+topic.(string)+\"%\")\n\t\tdelete(filters, \"topic\")\n\t}\n\n\tif limit, ok := filters[\"limit\"]; ok {\n\t\tquery = query.Where(\"monthly_limit > ?\", limit.(int))\n\t\tdelete(filters, \"limit\")\n\t}\n\n\terr = query.Scopes(PaginateDB(page, size)).Where(filters).Find(&publications).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn publications, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn publications, nil\n}",
    "caller": "func (a *ArmorHandler) HandleArmorSearch(req *types.ArmorSearchRequest) ([]types.ArmorItem, error) {\n\tfilters := make(map[string]interface{})\n\tif req.MinDefense > 0 {\n\t\tfilters[\"defense\"] = req.MinDefense\n\t} else if req.Material != \"\" {\n\t\tif !utils.IsValidMaterial(req.Material) {\n\t\t\treturn nil, fmt.Errorf(\"invalid material type: %s\", req.Material)\n\t\t}\n\t\tfilters[\"material\"] = req.Material\n\t} else if req.Rarity > 0 {\n\t\tif req.Rarity > 5 {\n\t\t\treturn nil, fmt.Errorf(\"rarity must be between 1-5\")\n\t\t}\n\t\tfilters[\"rarity\"] = req.Rarity\n\t}\n\n\tmag := &Magazine{}\n\tpage, size := utils.GetPagination(req.Page, req.PageSize)\n\titems, err := mag.FilterByAttribute(filters, page, size)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to search armor: %v\", err)\n\t}\n\treturn items, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "查询defense条件",
            "sql": "SELECT * FROM asset_inventory WHERE defense = ? ORDER BY publication_date LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "查询material条件",
            "sql": "SELECT * FROM asset_inventory WHERE material = ? ORDER BY publication_date LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "查询rarity条件",
            "sql": "SELECT * FROM asset_inventory WHERE rarity = ? ORDER BY publication_date LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "查询topic条件（特殊处理）",
            "sql": "SELECT * FROM asset_inventory WHERE topic LIKE ? ORDER BY publication_date LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "查询limit条件（特殊处理）",
            "sql": "SELECT * FROM asset_inventory WHERE monthly_limit > ? ORDER BY publication_date LIMIT ? OFFSET ?;"
          }
        ]
      },
      {
        "type": "NO_SQL_GENERATE",
        "variants": [
          {
            "scenario": "表名不一致：代码中使用'asset_inventory'但模型对应表应为'magazine_publications'。模型MagazinePublication与表asset_inventory的字段可能不匹配，特别是调用者查询的defense/material/rarity字段在模型中未定义",
            "sql": ""
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "OTHER"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "MagazinePublication",
        "code_value": "type MagazinePublication struct {\n\tID              int       `json:\"id\" gorm:\"column:id\"`\n\tTitle           string    `json:\"title\" gorm:\"column:title\"`\n\tTopic           string    `json:\"topic\" gorm:\"column:topic\"`\n\tPublicationDate time.Time `json:\"publication_date\" gorm:\"column:publication_date\"`\n\tMonthlyLimit    int       `json:\"monthly_limit\" gorm:\"column:monthly_limit\"`\n\tCreatedAt       time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt       time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "PublicationFilter",
        "code_value": "type PublicationFilter struct {\n\tTopic        *string \n\tMonthlyLimit *int    \n\tStatus       *string \n\tPublisherID  *int    \n}"
      },
      {
        "code_key": "PublicationResponse",
        "code_value": "type PublicationResponse struct {\n\tPublications []MagazinePublication `json:\"publications\"`\n\tTotalCount   int                   `json:\"total_count\"`\n\tPage         int                   `json:\"page\"`\n\tSize         int                   `json:\"size\"`\n}"
      },
      {
        "code_key": "TableNamePublications",
        "code_value": "const TableNamePublications = \"magazine_publications\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "MaxPageSize",
        "code_value": "const MaxPageSize = 100"
      },
      {
        "code_key": "PublicationStatus",
        "code_value": "var PublicationStatus = struct {\n\tDraft     string\n\tPublished string\n\tArchived  string\n}{\n\tDraft:     \"draft\",\n\tPublished: \"published\",\n\tArchived:  \"archived\",\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "FilterByAttribute",
    "orm_code": "func (m *Magazine) FilterByAttribute(filters map[string]interface{}, page, size int) ([]types.MagazinePublication, error) {\n\tvar publications []types.MagazinePublication\n\tvar err error\n\tquery := base.GetInstance().Db().Table(\"asset_inventory\").Order(\"publication_date\")\n\n\tif topic, ok := filters[\"topic\"]; ok {\n\t\tquery = query.Where(\"topic LIKE ?\", \"%\"+topic.(string)+\"%\")\n\t\tdelete(filters, \"topic\")\n\t}\n\n\tif limit, ok := filters[\"limit\"]; ok {\n\t\tquery = query.Where(\"monthly_limit > ?\", limit.(int))\n\t\tdelete(filters, \"limit\")\n\t}\n\n\terr = query.Scopes(PaginateDB(page, size)).Where(filters).Find(&publications).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn publications, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn publications, nil\n}",
    "caller": "func (h *EmployeeHandler) HandleEmployeeProfiles(req *types.EmployeeFilterRequest) ([]types.EmployeeProfile, error) {\n\tif req.Page <= 0 || req.Limit <= 0 {\n\t\treturn nil, fmt.Errorf(\"invalid pagination parameters\")\n\t}\n\n\tfilterCriteria := make(map[string]interface{})\n\tif req.CertificateID != \"\" {\n\t\tfilterCriteria[\"CertificateId\"] = req.CertificateID\n\t} else if req.District != \"\" {\n\t\tfilterCriteria[\"District\"] = req.District\n\t} else if req.Country != \"\" {\n\t\tfilterCriteria[\"Country\"] = req.Country\n\t}\n\n\temp := &Employee{}\n\tprofiles, err := emp.FilterByAttribute(filterCriteria, req.Page, req.Limit)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to filter employee profiles: %w\", err)\n\t}\n\n\tif len(profiles) == 0 {\n\t\treturn []types.EmployeeProfile{}, nil\n\t}\n\treturn profiles, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按CertificateId过滤",
            "sql": "SELECT id, certificate_id, district, country, status, created_at, updated_at FROM character_inventory WHERE certificate_id = ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "按District模糊匹配",
            "sql": "SELECT id, certificate_id, district, country, status, created_at, updated_at FROM character_inventory WHERE district LIKE ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "按Country精确匹配并附加状态过滤",
            "sql": "SELECT id, certificate_id, district, country, status, created_at, updated_at FROM character_inventory WHERE country = ? AND status = 'active' ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "MagazinePublication",
        "code_value": "type MagazinePublication struct {\n\tID              int       `json:\"id\" gorm:\"column:id\"`\n\tTitle           string    `json:\"title\" gorm:\"column:title\"`\n\tTopic           string    `json:\"topic\" gorm:\"column:topic\"`\n\tPublicationDate time.Time `json:\"publication_date\" gorm:\"column:publication_date\"`\n\tMonthlyLimit    int       `json:\"monthly_limit\" gorm:\"column:monthly_limit\"`\n\tCreatedAt       time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt       time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "PublicationFilter",
        "code_value": "type PublicationFilter struct {\n\tTopic        *string \n\tMonthlyLimit *int    \n\tStatus       *string \n\tPublisherID  *int    \n}"
      },
      {
        "code_key": "PublicationResponse",
        "code_value": "type PublicationResponse struct {\n\tPublications []MagazinePublication `json:\"publications\"`\n\tTotalCount   int                   `json:\"total_count\"`\n\tPage         int                   `json:\"page\"`\n\tSize         int                   `json:\"size\"`\n}"
      },
      {
        "code_key": "TableNamePublications",
        "code_value": "const TableNamePublications = \"magazine_publications\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "MaxPageSize",
        "code_value": "const MaxPageSize = 100"
      },
      {
        "code_key": "PublicationStatus",
        "code_value": "var PublicationStatus = struct {\n\tDraft     string\n\tPublished string\n\tArchived  string\n}{\n\tDraft:     \"draft\",\n\tPublished: \"published\",\n\tArchived:  \"archived\",\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "SyncWithExternal",
    "orm_code": "func (e *Equipment) SyncWithExternal(filterParams map[string]interface{}) ([]types.EquipmentRecord, error) {\n\trecords := make([]types.EquipmentRecord, 0)\n\tdb := base.GetInstance().MainDB().Table(\"tournament_brackets\")\n\n\tif edition, ok := filterParams[\"Edition\"]; ok {\n\t\tif method, ok := filterParams[\"MethodName\"]; ok {\n\t\tdb = db.Where(\"edition = ? AND method_name = ?\", edition.(string), method.(string))\n\t\t} else {\n\t\t\tdb = db.Where(\"edition LIKE ?\", \"%\"+edition.(string)+\"%\")\n\t\t}\n\t} else if content, ok := filterParams[\"Content\"]; ok {\n\t\tdb = db.Where(\"content LIKE ?\", \"%\"+content.(string)+\"%\")\n\t} else {\n\t\tdb = db.Where(filterParams)\n\t}\n\n\tif err := db.Order(\"created_at DESC\").Find(&records).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "包含Edition和MethodName参数",
            "sql": "SELECT * FROM tournament_brackets WHERE edition = ? AND method_name = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "仅包含Edition参数",
            "sql": "SELECT * FROM tournament_brackets WHERE edition LIKE ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "仅包含Content参数",
            "sql": "SELECT * FROM tournament_brackets WHERE content LIKE ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "其他参数组合",
            "sql": "SELECT * FROM tournament_brackets WHERE status = ? AND type = ? ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "EquipmentRecord",
        "code_value": "type EquipmentRecord struct {\n\tID        uint      `gorm:\"primaryKey\"`\n\tEdition   string    `gorm:\"column:edition\"`\n\tMethodName string   `gorm:\"column:method_name\"`\n\tContent   string    `gorm:\"column:content\"`\n\tCreatedAt time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "TournamentFilter",
        "code_value": "type TournamentFilter struct {\n\tEdition    string\n\tMethodName string\n\tContent    string\n}"
      },
      {
        "code_key": "EquipmentStatus",
        "code_value": "const (\n\tEquipmentActive = \"active\"\n\tEquipmentInactive = \"inactive\"\n\tEquipmentPending = \"pending\"\n)"
      },
      {
        "code_key": "MaxRetryAttempts",
        "code_value": "const MaxRetryAttempts = 3"
      },
      {
        "code_key": "DefaultPagination",
        "code_value": "var DefaultPagination = struct {\n\tPage    int\n\tPerPage int\n}{\n\tPage:    1,\n\tPerPage: 20,\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "SyncWithExternal",
    "orm_code": "func (e *Equipment) SyncWithExternal(filterParams map[string]interface{}) ([]types.EquipmentRecord, error) {\n\trecords := make([]types.EquipmentRecord, 0)\n\tdb := base.GetInstance().MainDB().Table(\"tournament_brackets\")\n\n\tif edition, ok := filterParams[\"Edition\"]; ok {\n\t\tif method, ok := filterParams[\"MethodName\"]; ok {\n\t\tdb = db.Where(\"edition = ? AND method_name = ?\", edition.(string), method.(string))\n\t\t} else {\n\t\t\tdb = db.Where(\"edition LIKE ?\", \"%\"+edition.(string)+\"%\")\n\t\t}\n\t} else if content, ok := filterParams[\"Content\"]; ok {\n\t\tdb = db.Where(\"content LIKE ?\", \"%\"+content.(string)+\"%\")\n\t} else {\n\t\tdb = db.Where(filterParams)\n\t}\n\n\tif err := db.Order(\"created_at DESC\").Find(&records).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "caller": "func (h *EquipmentHandler) HandleEquipmentSearch(req *types.EquipmentSearchRequest) ([]types.EquipmentRecord, error) {\n\tfilter := make(map[string]interface{})\n\n\tif req.SerialNumber != \"\" {\n\t\tif len(req.SerialNumber) < 5 {\n\t\t\treturn nil, errors.New(\"serial number too short\")\n\t\t}\n\t\tfilter[\"SerialNumber\"] = req.SerialNumber\n\t} else if req.Location != \"\" {\n\t\tif !validateLocation(req.Location) {\n\t\t\treturn nil, errors.New(\"invalid location format\")\n\t\t}\n\t\tfilter[\"Location\"] = req.Location\n\t} else if req.Status != 0 {\n\t\tif req.Status < 1 || req.Status > 4 {\n\t\t\treturn nil, errors.New(\"invalid status value\")\n\t\t}\n\t\tfilter[\"Status\"] = req.Status\n\t} else {\n\t\tfilter[\"LastMaintained\"] = time.Now().AddDate(0, -3, 0)\n\t}\n\n\tequipment := &Equipment{}\n\trecords, err := equipment.SyncWithExternal(filter)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to sync equipment: %v\", err)\n\t}\n\n\tif len(records) == 0 {\n\t\treturn nil, errors.New(\"no matching equipment found\")\n\t}\n\n\treturn records, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "filterParams contains SerialNumber",
            "sql": "SELECT id, edition, method_name, content, created_at, updated_at FROM tournament_brackets WHERE serial_number = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "filterParams contains Location",
            "sql": "SELECT id, edition, method_name, content, created_at, updated_at FROM tournament_brackets WHERE location = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "filterParams contains Status",
            "sql": "SELECT id, edition, method_name, content, created_at, updated_at FROM tournament_brackets WHERE status = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "filterParams contains LastMaintained (default case)",
            "sql": "SELECT id, edition, method_name, content, created_at, updated_at FROM tournament_brackets WHERE last_maintained = ? ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "EquipmentRecord",
        "code_value": "type EquipmentRecord struct {\n\tID        uint      `gorm:\"primaryKey\"`\n\tEdition   string    `gorm:\"column:edition\"`\n\tMethodName string   `gorm:\"column:method_name\"`\n\tContent   string    `gorm:\"column:content\"`\n\tCreatedAt time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "TournamentFilter",
        "code_value": "type TournamentFilter struct {\n\tEdition    string\n\tMethodName string\n\tContent    string\n}"
      },
      {
        "code_key": "EquipmentStatus",
        "code_value": "const (\n\tEquipmentActive = \"active\"\n\tEquipmentInactive = \"inactive\"\n\tEquipmentPending = \"pending\"\n)"
      },
      {
        "code_key": "MaxRetryAttempts",
        "code_value": "const MaxRetryAttempts = 3"
      },
      {
        "code_key": "DefaultPagination",
        "code_value": "var DefaultPagination = struct {\n\tPage    int\n\tPerPage int\n}{\n\tPage:    1,\n\tPerPage: 20,\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "PreventAttack",
    "orm_code": "func (s *Semester) PreventAttack(filters map[string]interface{}) ([]types.Currency, error) {\n\tvar currencies []types.Currency\n\tdb := base.GetInstance().GormDB().Table(\"grade_records\")\n\n\tif territory, exists := filters[\"Territory\"]; exists {\n\t\tif method, ok := filters[\"AttackMethod\"]; ok {\n\t\t\tdb = db.Where(\"territory = ? AND attack_method = ?\", territory, method)\n\t\t} else {\n\t\t\tdb = db.Where(\"territory LIKE ?\", \"%\" + territory.(string) + \"%\")\n\t\t}\n\t} else if amount, exists := filters[\"TotalAmount\"]; exists {\n\t\tdb = db.Where(\"total_amount > ?\", amount)\n\t}\n\n\terr := db.Find(&currencies).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn currencies, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "包含Territory和AttackMethod条件",
            "sql": "SELECT id, territory, total_amount AS amount, attack_method AS method, created_at, updated_at FROM grade_records WHERE territory = ? AND attack_method = ?;"
          },
          {
            "scenario": "仅包含Territory条件（模糊匹配）",
            "sql": "SELECT id, territory, total_amount AS amount, attack_method AS method, created_at, updated_at FROM grade_records WHERE territory LIKE ?;"
          },
          {
            "scenario": "仅包含TotalAmount条件",
            "sql": "SELECT id, territory, total_amount AS amount, attack_method AS method, created_at, updated_at FROM grade_records WHERE total_amount > ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Currency",
        "code_value": "type Currency struct {\n\tID          int     `json:\"id\" gorm:\"column:id\"`\n\tTerritory   string  `json:\"territory\" gorm:\"column:territory\"`\n\tAmount      float64 `json:\"amount\" gorm:\"column:total_amount\"`\n\tMethod      string  `json:\"method\" gorm:\"column:attack_method\"`\n\tCreatedAt   int64   `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt   int64   `json:\"updated_at\" gorm:\"column:updated_at\"`"
      },
      {
        "code_key": "AttackFilter",
        "code_value": "type AttackFilter struct {\n\tTerritory    string\n\tAttackMethod string\n\tTotalAmount  float64"
      },
      {
        "code_key": "TableGradeRecords",
        "code_value": "const TableGradeRecords = \"grade_records\""
      },
      {
        "code_key": "DefaultCurrencyLimit",
        "code_value": "const DefaultCurrencyLimit = 1000"
      },
      {
        "code_key": "DefenseStatus",
        "code_value": "type DefenseStatus struct {\n\tActive   bool\n\tLastScan int64"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "PreventAttack",
    "orm_code": "func (s *Semester) PreventAttack(filters map[string]interface{}) ([]types.Currency, error) {\n\tvar currencies []types.Currency\n\tdb := base.GetInstance().GormDB().Table(\"grade_records\")\n\n\tif territory, exists := filters[\"Territory\"]; exists {\n\t\tif method, ok := filters[\"AttackMethod\"]; ok {\n\t\t\tdb = db.Where(\"territory = ? AND attack_method = ?\", territory, method)\n\t\t} else {\n\t\t\tdb = db.Where(\"territory LIKE ?\", \"%\" + territory.(string) + \"%\")\n\t\t}\n\t} else if amount, exists := filters[\"TotalAmount\"]; exists {\n\t\tdb = db.Where(\"total_amount > ?\", amount)\n\t}\n\n\terr := db.Find(&currencies).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn currencies, nil\n}",
    "caller": "func (c *CurrencyController) HandleCurrencyReport(req *types.CurrencyReportRequest) ([]types.Currency, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.Threshold > 0 {\n\t\tfilter[\"TotalAmount\"] = req.Threshold\n\t} else if req.Region != \"\" {\n\t\tif req.Method != \"\" {\n\t\t\tfilter[\"Territory\"] = req.Region\n\t\t\tfilter[\"AttackMethod\"] = req.Method\n\t\t} else {\n\t\t\tfilter[\"Territory\"] = req.Region\n\t\t}\n\t} else if req.Status != \"\" {\n\t\tfilter[\"status\"] = req.Status\n\t} else {\n\t\treturn nil, errors.New(\"invalid query parameters\")\n\t}\n\n\tsemester := &Semester{}\n\tresults, err := semester.PreventAttack(filter)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to fetch currency data: %v\", err)\n\t}\n\n\tif len(results) == 0 {\n\t\treturn nil, errors.New(\"no matching records found\")\n\t}\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Threshold > 0 (按金额过滤)",
            "sql": "SELECT id, territory, total_amount AS amount, attack_method AS method, created_at, updated_at FROM grade_records WHERE total_amount > ?;"
          },
          {
            "scenario": "Region和Method都有值 (精确匹配)",
            "sql": "SELECT id, territory, total_amount AS amount, attack_method AS method, created_at, updated_at FROM grade_records WHERE territory = ? AND attack_method = ?;"
          },
          {
            "scenario": "只有Region有值 (模糊匹配)",
            "sql": "SELECT id, territory, total_amount AS amount, attack_method AS method, created_at, updated_at FROM grade_records WHERE territory LIKE ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Currency",
        "code_value": "type Currency struct {\n\tID          int     `json:\"id\" gorm:\"column:id\"`\n\tTerritory   string  `json:\"territory\" gorm:\"column:territory\"`\n\tAmount      float64 `json:\"amount\" gorm:\"column:total_amount\"`\n\tMethod      string  `json:\"method\" gorm:\"column:attack_method\"`\n\tCreatedAt   int64   `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt   int64   `json:\"updated_at\" gorm:\"column:updated_at\"`"
      },
      {
        "code_key": "AttackFilter",
        "code_value": "type AttackFilter struct {\n\tTerritory    string\n\tAttackMethod string\n\tTotalAmount  float64"
      },
      {
        "code_key": "TableGradeRecords",
        "code_value": "const TableGradeRecords = \"grade_records\""
      },
      {
        "code_key": "DefaultCurrencyLimit",
        "code_value": "const DefaultCurrencyLimit = 1000"
      },
      {
        "code_key": "DefenseStatus",
        "code_value": "type DefenseStatus struct {\n\tActive   bool\n\tLastScan int64"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "RebuildIndex",
    "orm_code": "func (f *Forecast) RebuildIndex(filterParams map[string]interface{}, limit int) ([]types.PlayerProfile, error) {\n\tvar profiles []types.PlayerProfile\n\tdb := base.GetInstance().GormDriver().Table(\"player_profiles\")\n\n\tif registrationTime, exists := filterParams[\"RegistrationTime\"]; exists {\n\t\tdb = db.Where(\"registration_time > ?\", registrationTime).Order(\"registration_time desc\")\n\t} else if floor, exists := filterParams[\"Floor\"]; exists {\n\t\tfilter := make(map[string]interface{})\n\t\tfor k, v := range filterParams {\n\t\t\tif k != \"Floor\" {\n\t\t\t\tfilter[k] = v\n\t\t\t}\n\t\t}\n\t\tdb = db.Where(filter).Where(\"floor >= ?\", floor.(int))\n\t}\n\n\tif limit > 0 {\n\t\tdb = db.Limit(limit)\n\t}\n\n\tif err := db.Find(&profiles).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn profiles, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "criteria contains Rating key",
            "sql": "SELECT id, rating, category, status, priority, author, created_at, updated_at FROM fraud_alerts WHERE rating >= ? AND status = 'pending' ORDER BY created_at DESC LIMIT ?;"
          },
          {
            "scenario": "criteria contains Category key",
            "sql": "SELECT id, rating, category, status, priority, author, created_at, updated_at FROM fraud_alerts WHERE category = ? AND status = 'active' ORDER BY priority ASC LIMIT ?;"
          },
          {
            "scenario": "criteria contains Author key",
            "sql": "SELECT id, rating, category, status, priority, author, created_at, updated_at FROM fraud_alerts WHERE author LIKE ? AND status = 'pending' ORDER BY updated_at DESC LIMIT ?;"
          },
          {
            "scenario": "criteria contains none of the keys",
            "sql": "SELECT id, rating, category, status, priority, author, created_at, updated_at FROM fraud_alerts WHERE status = 'pending' ORDER BY id ASC LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "PlayerScore",
        "code_value": "type PlayerScore struct {\n\tID        int       `json:\"id\" gorm:\"primaryKey\"`\n\tPlayerID  int       `json:\"player_id\" gorm:\"index\"`\n\tScore     float64   `json:\"score\"`\n\tCreatedAt time.Time `json:\"created_at\"`\n\tUpdatedAt time.Time `json:\"updated_at\"`\n}"
      },
      {
        "code_key": "ScoreFilter",
        "code_value": "type ScoreFilter struct {\n\tMinScore     float64 `json:\"min_score\"`\n\tMaxScore     float64 `json:\"max_score\"`\n\tPlayerIDs    []int   `json:\"player_ids\"`\n\tCreatedAfter string  `json:\"created_after\"`\n}"
      },
      {
        "code_key": "ScoreResult",
        "code_value": "type ScoreResult struct {\n\tScores []PlayerScore `json:\"scores\"`\n\tTotal  int           `json:\"total\"`\n}"
      },
      {
        "code_key": "TablePlayerScores",
        "code_value": "const TablePlayerScores = \"player_scores\""
      },
      {
        "code_key": "DefaultScoreLimit",
        "code_value": "const DefaultScoreLimit = 50"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "RebuildIndex",
    "orm_code": "func (f *Forecast) RebuildIndex(filterParams map[string]interface{}, limit int) ([]types.PlayerProfile, error) {\n\tvar profiles []types.PlayerProfile\n\tdb := base.GetInstance().GormDriver().Table(\"player_profiles\")\n\n\tif registrationTime, exists := filterParams[\"RegistrationTime\"]; exists {\n\t\tdb = db.Where(\"registration_time > ?\", registrationTime).Order(\"registration_time desc\")\n\t} else if floor, exists := filterParams[\"Floor\"]; exists {\n\t\tfilter := make(map[string]interface{})\n\t\tfor k, v := range filterParams {\n\t\t\tif k != \"Floor\" {\n\t\t\t\tfilter[k] = v\n\t\t\t}\n\t\t}\n\t\tdb = db.Where(filter).Where(\"floor >= ?\", floor.(int))\n\t}\n\n\tif limit > 0 {\n\t\tdb = db.Limit(limit)\n\t}\n\n\tif err := db.Find(&profiles).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn profiles, nil\n}",
    "caller": "func (s *ProfileService) HandlePlayerProfiles(req *types.ProfileRequest) ([]types.PlayerProfile, error) {\n\tfilter := make(map[string]interface{})\n\tvar limit int\n\n\tif req.PlayerID != \"\" {\n\t\tfilter[\"player_id\"] = req.PlayerID\n\t} else if req.TeamID > 0 {\n\t\tfilter[\"team_id\"] = req.TeamID\n\t\tif req.MinScore > 0 {\n\t\t\tfilter[\"score\"] = req.MinScore\n\t\t}\n\t} else if req.Region != \"\" {\n\t\tif err := validateRegion(req.Region); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"invalid region: %v\", err)\n\t\t}\n\t\tfilter[\"region\"] = req.Region\n\t\tlimit = 100\n\t} else {\n\t\treturn nil, errors.New(\"at least one filter parameter is required\")\n\t}\n\n\tif req.Limit > 0 {\n\t\tlimit = req.Limit\n\t}\n\n\tforecast := new(Forecast)\n\tprofiles, err := forecast.RebuildIndex(filter, limit)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to rebuild index: %v\", err)\n\t}\n\treturn profiles, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按player_id查询",
            "sql": "SELECT * FROM player_profiles WHERE player_id = ?;"
          },
          {
            "scenario": "按team_id和score查询",
            "sql": "SELECT * FROM player_profiles WHERE team_id = ? AND score = ?;"
          },
          {
            "scenario": "按region查询且有limit",
            "sql": "SELECT * FROM player_profiles WHERE region = ? LIMIT 100;"
          },
          {
            "scenario": "带RegistrationTime过滤",
            "sql": "SELECT * FROM player_profiles WHERE registration_time > ? ORDER BY registration_time DESC;"
          },
          {
            "scenario": "带Floor和其他条件过滤",
            "sql": "SELECT * FROM player_profiles WHERE status = ? AND floor >= ?;"
          },
          {
            "scenario": "带limit限制",
            "sql": "SELECT * FROM player_profiles WHERE player_id = ? LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PlayerScore",
        "code_value": "type PlayerScore struct {\n\tID        int       `json:\"id\" gorm:\"primaryKey\"`\n\tPlayerID  int       `json:\"player_id\" gorm:\"index\"`\n\tScore     float64   `json:\"score\"`\n\tCreatedAt time.Time `json:\"created_at\"`\n\tUpdatedAt time.Time `json:\"updated_at\"`\n}"
      },
      {
        "code_key": "ScoreFilter",
        "code_value": "type ScoreFilter struct {\n\tMinScore     float64 `json:\"min_score\"`\n\tMaxScore     float64 `json:\"max_score\"`\n\tPlayerIDs    []int   `json:\"player_ids\"`\n\tCreatedAfter string  `json:\"created_after\"`\n}"
      },
      {
        "code_key": "ScoreResult",
        "code_value": "type ScoreResult struct {\n\tScores []PlayerScore `json:\"scores\"`\n\tTotal  int           `json:\"total\"`\n}"
      },
      {
        "code_key": "TablePlayerScores",
        "code_value": "const TablePlayerScores = \"player_scores\""
      },
      {
        "code_key": "DefaultScoreLimit",
        "code_value": "const DefaultScoreLimit = 50"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "RebuildIndex",
    "orm_code": "func (f *Forecast) RebuildIndex(filterParams map[string]interface{}, limit int) ([]types.PlayerProfile, error) {\n\tvar profiles []types.PlayerProfile\n\tdb := base.GetInstance().GormDriver().Table(\"player_profiles\")\n\n\tif registrationTime, exists := filterParams[\"RegistrationTime\"]; exists {\n\t\tdb = db.Where(\"registration_time > ?\", registrationTime).Order(\"registration_time desc\")\n\t} else if floor, exists := filterParams[\"Floor\"]; exists {\n\t\tfilter := make(map[string]interface{})\n\t\tfor k, v := range filterParams {\n\t\t\tif k != \"Floor\" {\n\t\t\t\tfilter[k] = v\n\t\t\t}\n\t\t}\n\t\tdb = db.Where(filter).Where(\"floor >= ?\", floor.(int))\n\t}\n\n\tif limit > 0 {\n\t\tdb = db.Limit(limit)\n\t}\n\n\tif err := db.Find(&profiles).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn profiles, nil\n}",
    "caller": "func (s *FraudAlertService) HandleFraudAlerts(req *types.FraudAlertRequest) ([]types.FraudAlert, error) {\n\tif req == nil {\n\t\treturn nil, fmt.Errorf(\"invalid request: nil\")\n\t}\n\n\tfilterParams := make(map[string]interface{})\n\tvar resultLimit int\n\n\tswitch req.FilterType {\n\tcase \"rating\":\n\t\tif req.MinRating < 1 || req.MinRating > 5 {\n\t\t\treturn nil, fmt.Errorf(\"invalid rating value: must be between 1-5\")\n\t\t}\n\t\tfilterParams[\"Rating\"] = req.MinRating\n\tcase \"category\":\n\t\tif req.Category == \"\" {\n\t\t\treturn nil, fmt.Errorf(\"category cannot be empty\")\n\t\t}\n\t\tfilterParams[\"Category\"] = req.Category\n\tcase \"author\":\n\t\tif req.AuthorName == \"\" {\n\t\t\treturn nil, fmt.Errorf(\"author name cannot be empty\")\n\t\t}\n\t\tfilterParams[\"Author\"] = req.AuthorName\n\t}\n\n\tif req.MaxResults > 0 {\n\t\tresultLimit = req.MaxResults\n\t}\n\n\tpolicy := &Policy{}\n\talerts, err := policy.RebuildIndex(filterParams, resultLimit)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to fetch alerts: %w\", err)\n\t}\n\n\treturn alerts, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "通过Rating过滤",
            "sql": "SELECT * FROM fraud_alerts WHERE rating >= ? ORDER BY created_at DESC LIMIT ?;"
          },
          {
            "scenario": "通过Category过滤",
            "sql": "SELECT * FROM fraud_alerts WHERE category = ? AND status = 'active' ORDER BY priority ASC;"
          },
          {
            "scenario": "通过Author模糊匹配",
            "sql": "SELECT * FROM fraud_alerts WHERE author LIKE ? ORDER BY updated_at DESC LIMIT ?;"
          },
          {
            "scenario": "无特定过滤条件（默认情况）",
            "sql": "SELECT * FROM fraud_alerts WHERE status = 'pending' ORDER BY id ASC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "PlayerScore",
        "code_value": "type PlayerScore struct {\n\tID        int       `json:\"id\" gorm:\"primaryKey\"`\n\tPlayerID  int       `json:\"player_id\" gorm:\"index\"`\n\tScore     float64   `json:\"score\"`\n\tCreatedAt time.Time `json:\"created_at\"`\n\tUpdatedAt time.Time `json:\"updated_at\"`\n}"
      },
      {
        "code_key": "ScoreFilter",
        "code_value": "type ScoreFilter struct {\n\tMinScore     float64 `json:\"min_score\"`\n\tMaxScore     float64 `json:\"max_score\"`\n\tPlayerIDs    []int   `json:\"player_ids\"`\n\tCreatedAfter string  `json:\"created_after\"`\n}"
      },
      {
        "code_key": "ScoreResult",
        "code_value": "type ScoreResult struct {\n\tScores []PlayerScore `json:\"scores\"`\n\tTotal  int           `json:\"total\"`\n}"
      },
      {
        "code_key": "TablePlayerScores",
        "code_value": "const TablePlayerScores = \"player_scores\""
      },
      {
        "code_key": "DefaultScoreLimit",
        "code_value": "const DefaultScoreLimit = 50"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ListWithPaging",
    "orm_code": "func (p *Profile) ListWithPaging(filter map[string]interface{}, page, size int) ([]types.ProfileDetail, error) {\n\tprofiles := make([]types.ProfileDetail, 0)\n\tdb := base.GetInstance().MainDriver().Table(\"maintenance_logs\").Order(\"created_at DESC\")\n\n\tif category, ok := filter[\"Category\"]; ok {\n\t\tdelete(filter, \"Category\")\n\t\tdb = db.Where(\"category LIKE ?\", \"%\"+category.(string)+\"%\")\n\t\tif len(filter) > 0 {\n\t\t\tdb = db.Where(filter)\n\t\t}\n\t} else if taskID, ok := filter[\"TaskId\"]; ok {\n\t\tdelete(filter, \"TaskId\")\n\t\tdb = db.Where(\"task_id = ?\", taskID)\n\t\tif len(filter) > 0 {\n\t\t\tdb = db.Where(filter)\n\t\t}\n\t} else {\n\t\tdb = db.Where(filter)\n\t}\n\n\terr := db.Scopes(PaginateDB(page, size)).Find(&profiles).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn profiles, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn profiles, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "role filter with admin role",
            "sql": "SELECT id, name, role, mobile_number, longitude, latitude, join_date FROM skill_trees WHERE role = 'admin' ORDER BY join_date DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "role filter with member or moderator role",
            "sql": "SELECT id, name, role, mobile_number, longitude, latitude, join_date FROM skill_trees WHERE role IN ('member', 'moderator') LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "mobile number filter with LIKE condition",
            "sql": "SELECT id, name, role, mobile_number, longitude, latitude, join_date FROM skill_trees WHERE mobile_number LIKE ? LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "location filter with BETWEEN condition",
            "sql": "SELECT id, name, role, mobile_number, longitude, latitude, join_date FROM skill_trees WHERE longitude BETWEEN ? AND ? LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "generic filter with direct key-value conditions",
            "sql": "SELECT id, name, role, mobile_number, longitude, latitude, join_date FROM skill_trees WHERE name = ? AND latitude = ? LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "ProfileDetail",
        "code_value": "type ProfileDetail struct {\n\tID        uint      `json:\"id\" gorm:\"primaryKey\"`\n\tName      string    `json:\"name\" gorm:\"column:name\"`\n\tCategory  string    `json:\"category\" gorm:\"column:category\"`\n\tTaskID    string    `json:\"task_id\" gorm:\"column:task_id\"`\n\tCreatedAt time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "MaintenanceLogTable",
        "code_value": "const MaintenanceLogTable = \"maintenance_logs\""
      },
      {
        "code_key": "ProfileFilter",
        "code_value": "type ProfileFilter struct {\n\tCategory string `json:\"category\"`\n\tTaskID   string `json:\"task_id\"`\n\tStatus   int    `json:\"status\"`\n}"
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "MaxPageSize",
        "code_value": "const MaxPageSize = 100"
      },
      {
        "code_key": "ProfileStatus",
        "code_value": "const (\n\tProfileStatusActive = 1\n\tProfileStatusInactive = 2\n\tProfileStatusArchived = 3\n)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ListWithPaging",
    "orm_code": "func (p *Profile) ListWithPaging(filter map[string]interface{}, page, size int) ([]types.ProfileDetail, error) {\n\tprofiles := make([]types.ProfileDetail, 0)\n\tdb := base.GetInstance().MainDriver().Table(\"maintenance_logs\").Order(\"created_at DESC\")\n\n\tif category, ok := filter[\"Category\"]; ok {\n\t\tdelete(filter, \"Category\")\n\t\tdb = db.Where(\"category LIKE ?\", \"%\"+category.(string)+\"%\")\n\t\tif len(filter) > 0 {\n\t\t\tdb = db.Where(filter)\n\t\t}\n\t} else if taskID, ok := filter[\"TaskId\"]; ok {\n\t\tdelete(filter, \"TaskId\")\n\t\tdb = db.Where(\"task_id = ?\", taskID)\n\t\tif len(filter) > 0 {\n\t\t\tdb = db.Where(filter)\n\t\t}\n\t} else {\n\t\tdb = db.Where(filter)\n\t}\n\n\terr := db.Scopes(PaginateDB(page, size)).Find(&profiles).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn profiles, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn profiles, nil\n}",
    "caller": "func (s *SpellService) HandleSpellSearch(req *types.SpellSearchRequest, log *logger.MagicLog) ([]types.SpellDetail, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.SpellID != \"\" {\n\t\tfilter[\"spell_id\"] = req.SpellID\n\t} else if req.CasterLevel > 0 {\n\t\tfilter[\"min_level\"] = req.CasterLevel\n\t} else if req.ElementType != \"\" {\n\t\tif !utils.IsValidElement(req.ElementType) {\n\t\t\tlog.Error(\"Invalid element type\")\n\t\t\treturn nil, errors.New(\"invalid element type\")\n\t\t}\n\t\tfilter[\"element\"] = req.ElementType\n\t} else {\n\t\tif req.Name != \"\" {\n\t\t\tfilter[\"name\"] = req.Name\n\t\t}\n\t}\n\n\tspellRepo := &Spell{DB: s.DB}\n\tpage, size := utils.GetPagination(req.Page, req.Size)\n\tspells, err := spellRepo.ListWithPaging(filter, page, size)\n\tif err != nil {\n\t\tlog.ErrorV(fmt.Sprintf(\"Search spells failed: %v\", err))\n\t\treturn nil, err\n\t}\n\treturn spells, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "传入SpellID",
            "sql": "SELECT id, name, category, task_id, created_at, updated_at FROM maintenance_logs WHERE spell_id = 'some-id' ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "传入CasterLevel",
            "sql": "SELECT id, name, category, task_id, created_at, updated_at FROM maintenance_logs WHERE min_level = 5 ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "传入ElementType",
            "sql": "SELECT id, name, category, task_id, created_at, updated_at FROM maintenance_logs WHERE element = 'fire' ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "传入Name",
            "sql": "SELECT id, name, category, task_id, created_at, updated_at FROM maintenance_logs WHERE name = 'fireball' ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "无过滤条件",
            "sql": "SELECT id, name, category, task_id, created_at, updated_at FROM maintenance_logs ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ProfileDetail",
        "code_value": "type ProfileDetail struct {\n\tID        uint      `json:\"id\" gorm:\"primaryKey\"`\n\tName      string    `json:\"name\" gorm:\"column:name\"`\n\tCategory  string    `json:\"category\" gorm:\"column:category\"`\n\tTaskID    string    `json:\"task_id\" gorm:\"column:task_id\"`\n\tCreatedAt time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "MaintenanceLogTable",
        "code_value": "const MaintenanceLogTable = \"maintenance_logs\""
      },
      {
        "code_key": "ProfileFilter",
        "code_value": "type ProfileFilter struct {\n\tCategory string `json:\"category\"`\n\tTaskID   string `json:\"task_id\"`\n\tStatus   int    `json:\"status\"`\n}"
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "MaxPageSize",
        "code_value": "const MaxPageSize = 100"
      },
      {
        "code_key": "ProfileStatus",
        "code_value": "const (\n\tProfileStatusActive = 1\n\tProfileStatusInactive = 2\n\tProfileStatusArchived = 3\n)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ListWithPaging",
    "orm_code": "func (p *Profile) ListWithPaging(filter map[string]interface{}, page, size int) ([]types.ProfileDetail, error) {\n\tprofiles := make([]types.ProfileDetail, 0)\n\tdb := base.GetInstance().MainDriver().Table(\"maintenance_logs\").Order(\"created_at DESC\")\n\n\tif category, ok := filter[\"Category\"]; ok {\n\t\tdelete(filter, \"Category\")\n\t\tdb = db.Where(\"category LIKE ?\", \"%\"+category.(string)+\"%\")\n\t\tif len(filter) > 0 {\n\t\t\tdb = db.Where(filter)\n\t\t}\n\t} else if taskID, ok := filter[\"TaskId\"]; ok {\n\t\tdelete(filter, \"TaskId\")\n\t\tdb = db.Where(\"task_id = ?\", taskID)\n\t\tif len(filter) > 0 {\n\t\t\tdb = db.Where(filter)\n\t\t}\n\t} else {\n\t\tdb = db.Where(filter)\n\t}\n\n\terr := db.Scopes(PaginateDB(page, size)).Find(&profiles).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn profiles, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn profiles, nil\n}",
    "caller": "func (h *GuildHandler) HandleGuildMemberQuery(req *types.GuildMemberQueryRequest) ([]types.GuildMember, error) {\n\tif req.Page <= 0 || req.Size <= 0 {\n\t\treturn nil, fmt.Errorf(\"invalid pagination parameters\")\n\t}\n\n\tfilter := make(map[string]interface{})\n\tif req.Role != \"\" {\n\t\tfilter[\"role\"] = req.Role\n\t} else if req.MobileNumber != \"\" {\n\t\tfilter[\"mobile\"] = req.MobileNumber\n\t} else if req.LocationRange != nil {\n\t\tfilter[\"location\"] = map[string]float64{\n\t\t\t\"min\": req.LocationRange.MinLongitude,\n\t\t\t\"max\": req.LocationRange.MaxLongitude,\n\t\t}\n\t}\n\n\tguild := &Guild{}\n\tmembers, err := guild.ListWithPaging(filter, req.Page, req.Size)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to query guild members: %w\", err)\n\t}\n\treturn members, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "role parameter is 'admin'",
            "sql": "SELECT id, name, role, mobile_number, longitude, latitude, join_date FROM skill_trees WHERE role = 'admin' ORDER BY join_date DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "role parameter is not 'admin'",
            "sql": "SELECT id, name, role, mobile_number, longitude, latitude, join_date FROM skill_trees WHERE role IN ('member', 'moderator') LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "mobile parameter is provided",
            "sql": "SELECT id, name, role, mobile_number, longitude, latitude, join_date FROM skill_trees WHERE mobile_number LIKE ? LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "location parameter is provided",
            "sql": "SELECT id, name, role, mobile_number, longitude, latitude, join_date FROM skill_trees WHERE longitude BETWEEN ? AND ? LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "no filter conditions",
            "sql": "SELECT id, name, role, mobile_number, longitude, latitude, join_date FROM skill_trees LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "ProfileDetail",
        "code_value": "type ProfileDetail struct {\n\tID        uint      `json:\"id\" gorm:\"primaryKey\"`\n\tName      string    `json:\"name\" gorm:\"column:name\"`\n\tCategory  string    `json:\"category\" gorm:\"column:category\"`\n\tTaskID    string    `json:\"task_id\" gorm:\"column:task_id\"`\n\tCreatedAt time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "MaintenanceLogTable",
        "code_value": "const MaintenanceLogTable = \"maintenance_logs\""
      },
      {
        "code_key": "ProfileFilter",
        "code_value": "type ProfileFilter struct {\n\tCategory string `json:\"category\"`\n\tTaskID   string `json:\"task_id\"`\n\tStatus   int    `json:\"status\"`\n}"
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "MaxPageSize",
        "code_value": "const MaxPageSize = 100"
      },
      {
        "code_key": "ProfileStatus",
        "code_value": "const (\n\tProfileStatusActive = 1\n\tProfileStatusInactive = 2\n\tProfileStatusArchived = 3\n)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "AnalyzePerformance",
    "orm_code": "func (t *Tracking) AnalyzePerformance(filterParams map[string]interface{}, limit int) ([]types.PerformanceMetric, error) {\n\tvar metrics []types.PerformanceMetric\n\tdb := base.GetInstance().GormDriver().Table(\"trading_orders\")\n\n\tif campaignId, ok := filterParams[\"campaign_id\"]; ok {\n\t\tdb = db.Where(\"campaign_id = ? AND status = ?\", campaignId, \"active\")\n\t} else if dateRange, ok := filterParams[\"date_range\"]; ok {\n\t\trangeValues := dateRange.([]string)\n\t\tdb = db.Where(\"created_at BETWEEN ? AND ?\", rangeValues[0], rangeValues[1])\n\t}\n\n\tif className, ok := filterParams[\"class_name\"]; ok {\n\t\tdb = db.Where(\"class_name LIKE ?\", \"%\"+className.(string)+\"%\")\n\t}\n\n\terr := db.Order(\"transaction_id DESC\").Limit(limit).Find(&metrics).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn metrics, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按课程名称模糊查询",
            "sql": "SELECT id, student_id, course_title, score, semester_id, created_at, updated_at FROM grade_records WHERE course_title LIKE '%数学%' ORDER BY student_id LIMIT 10 OFFSET 0;"
          },
          {
            "scenario": "按分数范围查询（同时有最小和最大分数）",
            "sql": "SELECT id, student_id, course_title, score, semester_id, created_at, updated_at FROM grade_records WHERE score BETWEEN 60.0 AND 90.0 ORDER BY student_id LIMIT 15 OFFSET 15;"
          },
          {
            "scenario": "按分数范围查询（只有最小分数）",
            "sql": "SELECT id, student_id, course_title, score, semester_id, created_at, updated_at FROM grade_records WHERE score >= 80.0 ORDER BY student_id LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "按院系ID查询",
            "sql": "SELECT grade_records.id, grade_records.student_id, grade_records.course_title, grade_records.score, grade_records.semester_id, grade_records.created_at, grade_records.updated_at FROM grade_records JOIN department_structure ON grade_records.student_id = department_structure.student_id WHERE department_structure.department_id = 5 ORDER BY grade_records.student_id LIMIT 5 OFFSET 0;"
          },
          {
            "scenario": "按其他条件组合查询",
            "sql": "SELECT id, student_id, course_title, score, semester_id, created_at, updated_at FROM grade_records WHERE semester_id = 202301 AND student_id = 'S1001' ORDER BY student_id LIMIT 10 OFFSET 0;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "PerformanceMetric",
        "code_value": "type PerformanceMetric struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tCampaignID    string    `json:\"campaign_id\" gorm:\"column:campaign_id\"`\n\tClassName     string    `json:\"class_name\" gorm:\"column:class_name\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n\tTransactionID string    `json:\"transaction_id\" gorm:\"column:transaction_id\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tValue         float64   `json:\"value\" gorm:\"column:value\"`\n}"
      },
      {
        "code_key": "TrackingOrderStatus",
        "code_value": "const (\n\tOrderStatusActive   = \"active\"\n\tOrderStatusPending  = \"pending\"\n\tOrderStatusCanceled = \"canceled\"\n)"
      },
      {
        "code_key": "DefaultQueryLimit",
        "code_value": "const DefaultQueryLimit = 100"
      },
      {
        "code_key": "TrackingTableName",
        "code_value": "const TrackingTableName = \"trading_orders\""
      },
      {
        "code_key": "PerformanceFilter",
        "code_value": "type PerformanceFilter struct {\n\tCampaignID *string   `json:\"campaign_id\"`\n\tDateRange  []string  `json:\"date_range\"`\n\tClassName  *string   `json:\"class_name\"`\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "AnalyzePerformance",
    "orm_code": "func (t *Tracking) AnalyzePerformance(filterParams map[string]interface{}, limit int) ([]types.PerformanceMetric, error) {\n\tvar metrics []types.PerformanceMetric\n\tdb := base.GetInstance().GormDriver().Table(\"trading_orders\")\n\n\tif campaignId, ok := filterParams[\"campaign_id\"]; ok {\n\t\tdb = db.Where(\"campaign_id = ? AND status = ?\", campaignId, \"active\")\n\t} else if dateRange, ok := filterParams[\"date_range\"]; ok {\n\t\trangeValues := dateRange.([]string)\n\t\tdb = db.Where(\"created_at BETWEEN ? AND ?\", rangeValues[0], rangeValues[1])\n\t}\n\n\tif className, ok := filterParams[\"class_name\"]; ok {\n\t\tdb = db.Where(\"class_name LIKE ?\", \"%\"+className.(string)+\"%\")\n\t}\n\n\terr := db.Order(\"transaction_id DESC\").Limit(limit).Find(&metrics).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn metrics, nil\n}",
    "caller": "func (s *AnalyticsService) HandleCampaignMetrics(req *types.CampaignMetricsRequest, logger *log.Logger) ([]types.PerformanceMetric, error) {\n\tif req == nil {\n\t\tlogger.Println(\"[HandleCampaignMetrics] Invalid request\")\n\t\treturn nil, fmt.Errorf(\"invalid request\")\n\t}\n\n\tfilters := make(map[string]interface{})\n\tif req.CampaignID != \"\" {\n\t\tfilters[\"campaign_id\"] = req.CampaignID\n\t} else if req.StartDate != \"\" && req.EndDate != \"\" {\n\t\tfilters[\"date_range\"] = []string{req.StartDate, req.EndDate}\n\t} else if req.ClassName != \"\" {\n\t\tif len(req.ClassName) > 50 {\n\t\t\tlogger.Println(\"[HandleCampaignMetrics] Class name too long\")\n\t\t\treturn nil, fmt.Errorf(\"class name exceeds maximum length\")\n\t\t}\n\t\tfilters[\"class_name\"] = req.ClassName\n\t}\n\n\ttracker := &Tracking{}\n\tresult, err := tracker.AnalyzePerformance(filters, req.Limit)\n\tif err != nil {\n\t\tlogger.Printf(\"[HandleCampaignMetrics] Error analyzing performance: %v\", err)\n\t\treturn nil, err\n\t}\n\n\tif len(result) == 0 {\n\t\tlogger.Println(\"[HandleCampaignMetrics] No metrics found\")\n\t}\n\n\treturn result, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "传入campaign_id",
            "sql": "SELECT id, campaign_id, class_name, status, transaction_id, created_at, value FROM trading_orders WHERE campaign_id = ? AND status = ? ORDER BY transaction_id DESC LIMIT ?;"
          },
          {
            "scenario": "传入date_range（无campaign_id）",
            "sql": "SELECT id, campaign_id, class_name, status, transaction_id, created_at, value FROM trading_orders WHERE created_at BETWEEN ? AND ? ORDER BY transaction_id DESC LIMIT ?;"
          },
          {
            "scenario": "仅传入class_name（无campaign_id和date_range）",
            "sql": "SELECT id, campaign_id, class_name, status, transaction_id, created_at, value FROM trading_orders WHERE class_name LIKE ? ORDER BY transaction_id DESC LIMIT ?;"
          },
          {
            "scenario": "无任何过滤条件",
            "sql": "SELECT id, campaign_id, class_name, status, transaction_id, created_at, value FROM trading_orders ORDER BY transaction_id DESC LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PerformanceMetric",
        "code_value": "type PerformanceMetric struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tCampaignID    string    `json:\"campaign_id\" gorm:\"column:campaign_id\"`\n\tClassName     string    `json:\"class_name\" gorm:\"column:class_name\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n\tTransactionID string    `json:\"transaction_id\" gorm:\"column:transaction_id\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tValue         float64   `json:\"value\" gorm:\"column:value\"`\n}"
      },
      {
        "code_key": "TrackingOrderStatus",
        "code_value": "const (\n\tOrderStatusActive   = \"active\"\n\tOrderStatusPending  = \"pending\"\n\tOrderStatusCanceled = \"canceled\"\n)"
      },
      {
        "code_key": "DefaultQueryLimit",
        "code_value": "const DefaultQueryLimit = 100"
      },
      {
        "code_key": "TrackingTableName",
        "code_value": "const TrackingTableName = \"trading_orders\""
      },
      {
        "code_key": "PerformanceFilter",
        "code_value": "type PerformanceFilter struct {\n\tCampaignID *string   `json:\"campaign_id\"`\n\tDateRange  []string  `json:\"date_range\"`\n\tClassName  *string   `json:\"class_name\"`\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "AnalyzePerformance",
    "orm_code": "func (t *Tracking) AnalyzePerformance(filterParams map[string]interface{}, limit int) ([]types.PerformanceMetric, error) {\n\tvar metrics []types.PerformanceMetric\n\tdb := base.GetInstance().GormDriver().Table(\"trading_orders\")\n\n\tif campaignId, ok := filterParams[\"campaign_id\"]; ok {\n\t\tdb = db.Where(\"campaign_id = ? AND status = ?\", campaignId, \"active\")\n\t} else if dateRange, ok := filterParams[\"date_range\"]; ok {\n\t\trangeValues := dateRange.([]string)\n\t\tdb = db.Where(\"created_at BETWEEN ? AND ?\", rangeValues[0], rangeValues[1])\n\t}\n\n\tif className, ok := filterParams[\"class_name\"]; ok {\n\t\tdb = db.Where(\"class_name LIKE ?\", \"%\"+className.(string)+\"%\")\n\t}\n\n\terr := db.Order(\"transaction_id DESC\").Limit(limit).Find(&metrics).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn metrics, nil\n}",
    "caller": "func (h *StudentHandler) HandleStudentPerformance(req *types.PerformanceRequest, log *logger.AcademicLog) ([]types.GradeRecord, error) {\n\tif req.Page <= 0 || req.Size <= 0 {\n\t\treturn nil, utils.NewError(\"invalid pagination parameters\")\n\t}\n\n\tfilterCriteria := make(map[string]interface{})\n\tif req.CourseTitle != \"\" {\n\t\tfilterCriteria[\"course_title\"] = req.CourseTitle\n\t} else if req.MinScore > 0 {\n\t\tfilterCriteria[\"min_score\"] = req.MinScore\n\t\tif req.MaxScore > req.MinScore {\n\t\t\tfilterCriteria[\"max_score\"] = req.MaxScore\n\t\t}\n\t} else if req.DepartmentID != \"\" {\n\t\tif !utils.IsValidDepartment(req.DepartmentID) {\n\t\t\treturn nil, utils.NewError(\"invalid department ID\")\n\t\t}\n\t\tfilterCriteria[\"department_id\"] = req.DepartmentID\n\t} else {\n\t\tfilterCriteria[\"semester_id\"] = req.SemesterID\n\t}\n\n\tcurrentSemester := &models.Semester{ID: req.SemesterID}\n\tresults, err := currentSemester.AnalyzePerformance(filterCriteria, req.Page, req.Size)\n\tif err != nil {\n\t\tlog.Error(\"failed to analyze performance\", zap.Error(err))\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按课程名称查询",
            "sql": "SELECT id, student_id, course_title, score, semester_id, created_at, updated_at FROM grade_records WHERE course_title LIKE '%数学%' ORDER BY student_id LIMIT 10 OFFSET 0;"
          },
          {
            "scenario": "按分数范围查询",
            "sql": "SELECT id, student_id, course_title, score, semester_id, created_at, updated_at FROM grade_records WHERE score BETWEEN 60.0 AND 90.0 ORDER BY student_id LIMIT 20 OFFSET 20;"
          },
          {
            "scenario": "按分数下限查询",
            "sql": "SELECT id, student_id, course_title, score, semester_id, created_at, updated_at FROM grade_records WHERE score >= 80.0 ORDER BY student_id LIMIT 15 OFFSET 0;"
          },
          {
            "scenario": "按院系ID查询",
            "sql": "SELECT grade_records.id, grade_records.student_id, grade_records.course_title, grade_records.score, grade_records.semester_id, grade_records.created_at, grade_records.updated_at FROM grade_records JOIN department_structure ON grade_records.student_id = department_structure.student_id WHERE department_structure.department_id = 5 ORDER BY grade_records.student_id LIMIT 10 OFFSET 0;"
          },
          {
            "scenario": "默认查询（按学期ID）",
            "sql": "SELECT id, student_id, course_title, score, semester_id, created_at, updated_at FROM grade_records WHERE semester_id = 202301 ORDER BY student_id LIMIT 10 OFFSET 0;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "PerformanceMetric",
        "code_value": "type PerformanceMetric struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tCampaignID    string    `json:\"campaign_id\" gorm:\"column:campaign_id\"`\n\tClassName     string    `json:\"class_name\" gorm:\"column:class_name\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n\tTransactionID string    `json:\"transaction_id\" gorm:\"column:transaction_id\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tValue         float64   `json:\"value\" gorm:\"column:value\"`\n}"
      },
      {
        "code_key": "TrackingOrderStatus",
        "code_value": "const (\n\tOrderStatusActive   = \"active\"\n\tOrderStatusPending  = \"pending\"\n\tOrderStatusCanceled = \"canceled\"\n)"
      },
      {
        "code_key": "DefaultQueryLimit",
        "code_value": "const DefaultQueryLimit = 100"
      },
      {
        "code_key": "TrackingTableName",
        "code_value": "const TrackingTableName = \"trading_orders\""
      },
      {
        "code_key": "PerformanceFilter",
        "code_value": "type PerformanceFilter struct {\n\tCampaignID *string   `json:\"campaign_id\"`\n\tDateRange  []string  `json:\"date_range\"`\n\tClassName  *string   `json:\"class_name\"`\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "GenerateReport",
    "orm_code": "func (v *Video) GenerateReport(filterParams map[string]interface{}, pageSize, pageNum int) ([]types.Layout, error) {\n\tvar layouts []types.Layout\n\tdb := base.GetInstance().GormDriver().Table(\"market_data\")\n\n\tif region, ok := filterParams[\"region\"]; ok {\n\t\tdelete(filterParams, \"region\")\n\t\tdb = db.Where(\"region LIKE ?\", \"%\"+region.(string)+\"%\")\n\t}\n\n\tif len(filterParams) > 0 {\n\t\tdb = db.Where(filterParams)\n\t}\n\n\tif err := db.Scopes(Paginate(pageSize, pageNum)).Order(\"created_at DESC\").Find(&layouts).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.DataNotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn layouts, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "只有region条件",
            "sql": "SELECT id, region, market_value, created_at, updated_at FROM market_data WHERE region LIKE '%Asia%' ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "region和其他条件组合",
            "sql": "SELECT id, region, market_value, created_at, updated_at FROM market_data WHERE region LIKE '%Europe%' AND market_type = 'retail' ORDER BY created_at DESC LIMIT 10 OFFSET 10;"
          },
          {
            "scenario": "没有region但其他条件",
            "sql": "SELECT id, region, market_value, created_at, updated_at FROM market_data WHERE min_value = 1000 AND max_value = 5000 ORDER BY created_at DESC LIMIT 30 OFFSET 0;"
          },
          {
            "scenario": "没有任何过滤条件",
            "sql": "SELECT id, region, market_value, created_at, updated_at FROM market_data ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Layout",
        "code_value": "type Layout struct {\n\tID          uint      `gorm:\"primaryKey\"`\n\tRegion      string    `gorm:\"column:region\"`\n\tMarketValue float64   `gorm:\"column:market_value\"`\n\tCreatedAt   time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt   time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "ReportFilter",
        "code_value": "type ReportFilter struct {\n\tRegion       string `json:\"region\"`\n\tMarketType   string `json:\"market_type\"`\n\tMinValue     int    `json:\"min_value\"`\n\tMaxValue     int    `json:\"max_value\"`\n\tActiveStatus bool   `json:\"active_status\"`\n}"
      },
      {
        "code_key": "MarketTable",
        "code_value": "const MarketTable = \"market_data\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "VideoManager",
        "code_value": "type VideoManager struct {\n\tDB *gorm.DB\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "GenerateReport",
    "orm_code": "func (v *Video) GenerateReport(filterParams map[string]interface{}, pageSize, pageNum int) ([]types.Layout, error) {\n\tvar layouts []types.Layout\n\tdb := base.GetInstance().GormDriver().Table(\"market_data\")\n\n\tif region, ok := filterParams[\"region\"]; ok {\n\t\tdelete(filterParams, \"region\")\n\t\tdb = db.Where(\"region LIKE ?\", \"%\"+region.(string)+\"%\")\n\t}\n\n\tif len(filterParams) > 0 {\n\t\tdb = db.Where(filterParams)\n\t}\n\n\tif err := db.Scopes(Paginate(pageSize, pageNum)).Order(\"created_at DESC\").Find(&layouts).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.DataNotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn layouts, nil\n}",
    "caller": "func (v *VideoHandler) HandleVideoReport(req *types.VideoReportRequest, log *logger.AppLog) ([]types.Layout, error) {\n\tfilterParams := make(map[string]interface{})\n\tif req.VideoID != \"\" {\n\t\tfilterParams[\"video_id\"] = req.VideoID\n\t} else if req.CreatorName != \"\" {\n\t\tif len(req.CreatorName) > 50 {\n\t\t\tlog.Error(\"CreatorName too long\")\n\t\t\treturn nil, errors.New(\"invalid creator name\")\n\t\t}\n\t\tfilterParams[\"creator\"] = req.CreatorName\n\t} else if req.Status > 0 {\n\t\tif req.Status < 1 || req.Status > 5 {\n\t\t\tlog.Error(\"Invalid status value\")\n\t\t\treturn nil, errors.New(\"invalid status\")\n\t\t}\n\t\tfilterParams[\"status\"] = req.Status\n\t} else {\n\t\tfilterParams[\"is_active\"] = true\n\t}\n\n\tif req.Region != \"\" {\n\t\tfilterParams[\"region\"] = req.Region\n\t}\n\n\tvideo := &Video{}\n\tpageSize := 20\n\tif req.PageSize > 0 {\n\t\tpageSize = req.PageSize\n\t}\n\n\tlayouts, err := video.GenerateReport(filterParams, pageSize, req.PageNum)\n\tif err != nil {\n\t\tlog.Errorf(\"Generate report failed: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn layouts, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "使用video_id和region过滤",
            "sql": "SELECT * FROM market_data WHERE video_id = ? AND region LIKE ? ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "使用creator_name和region过滤",
            "sql": "SELECT * FROM market_data WHERE creator = ? AND region LIKE ? ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "使用status和region过滤",
            "sql": "SELECT * FROM market_data WHERE status = ? AND region LIKE ? ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "默认使用is_active过滤",
            "sql": "SELECT * FROM market_data WHERE is_active = true ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "仅使用video_id过滤",
            "sql": "SELECT * FROM market_data WHERE video_id = ? ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Layout",
        "code_value": "type Layout struct {\n\tID          uint      `gorm:\"primaryKey\"`\n\tRegion      string    `gorm:\"column:region\"`\n\tMarketValue float64   `gorm:\"column:market_value\"`\n\tCreatedAt   time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt   time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "ReportFilter",
        "code_value": "type ReportFilter struct {\n\tRegion       string `json:\"region\"`\n\tMarketType   string `json:\"market_type\"`\n\tMinValue     int    `json:\"min_value\"`\n\tMaxValue     int    `json:\"max_value\"`\n\tActiveStatus bool   `json:\"active_status\"`\n}"
      },
      {
        "code_key": "MarketTable",
        "code_value": "const MarketTable = \"market_data\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "VideoManager",
        "code_value": "type VideoManager struct {\n\tDB *gorm.DB\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "SearchByKeyword",
    "orm_code": "func (s *Story) SearchByKeyword(filterParams map[string]interface{}, page, size int) ([]types.StoryContent, error) {\n\tresults := make([]types.StoryContent, 0)\n\tvar err error\n\tdb := base.GetInstance().MainDB().Table(\"treatment_plans\")\n\n\tif keyword, ok := filterParams[\"keyword\"]; ok {\n\t\tfilter := make(map[string]interface{})\n\t\tfor k, v := range filterParams {\n\t\t\tif k == \"keyword\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfilter[k] = v\n\t\t}\n\t\terr = db.Where(filter).Where(\"title LIKE ? OR description LIKE ?\", \n\t\t\t\"%\"+keyword.(string)+\"%\", \"%\"+keyword.(string)+\"%\").\n\t\t\tOrder(\"created_at DESC\").Scopes(PaginateDB(page, size)).Find(&results).Error\n\t} else {\n\t\terr = db.Where(filterParams).Order(\"created_at DESC\").\n\t\t\tScopes(PaginateDB(page, size)).Find(&results).Error\n\t}\n\n\tif err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn results, utils.NotFoundError\n\t\t}\n\t\treturn results, err\n\t}\n\treturn results, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "filter contains keyword",
            "sql": "SELECT id, title, abstract, author_id, delivery_code, status, created_at, updated_at FROM publication WHERE (title LIKE '%research%' OR abstract LIKE '%research%') ORDER BY created_at DESC LIMIT 10 OFFSET 0;"
          },
          {
            "scenario": "filter contains author_id but no keyword",
            "sql": "SELECT id, title, abstract, author_id, delivery_code, status, created_at, updated_at FROM publication WHERE (author_id = 123 AND status = 1) ORDER BY created_at DESC LIMIT 5 OFFSET 5;"
          },
          {
            "scenario": "filter contains delivery_code but no keyword or author_id",
            "sql": "SELECT id, title, abstract, author_id, delivery_code, status, created_at, updated_at FROM publication WHERE (delivery_code = 'DL2023') ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "filter contains none of the special keys",
            "sql": "SELECT id, title, abstract, author_id, delivery_code, status, created_at, updated_at FROM publication WHERE (status = 0) ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "StoryContent",
        "code_value": "type StoryContent struct {\n\tID          int       `json:\"id\" gorm:\"column:id\"`\n\tTitle       string    `json:\"title\" gorm:\"column:title\"`\n\tDescription string    `json:\"description\" gorm:\"column:description\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt   time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "StoryResponse",
        "code_value": "type StoryResponse struct {\n\tData       []StoryContent `json:\"data\"`\n\tTotalCount int            `json:\"total_count\"`\n\tPage       int            `json:\"page\"`\n\tSize       int            `json:\"size\"`\n\tStatus     string         `json:\"status\"`\n}"
      },
      {
        "code_key": "StoryFilterParams",
        "code_value": "type StoryFilterParams struct {\n\tKeyword     string `json:\"keyword\"`\n\tCategory    string `json:\"category\"`\n\tAuthorID    int    `json:\"author_id\"`\n\tPublishDate string `json:\"publish_date\"`\n}"
      },
      {
        "code_key": "TreatmentPlansTable",
        "code_value": "const TreatmentPlansTable = \"treatment_plans\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "SearchByKeyword",
    "orm_code": "func (s *Story) SearchByKeyword(filterParams map[string]interface{}, page, size int) ([]types.StoryContent, error) {\n\tresults := make([]types.StoryContent, 0)\n\tvar err error\n\tdb := base.GetInstance().MainDB().Table(\"treatment_plans\")\n\n\tif keyword, ok := filterParams[\"keyword\"]; ok {\n\t\tfilter := make(map[string]interface{})\n\t\tfor k, v := range filterParams {\n\t\t\tif k == \"keyword\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfilter[k] = v\n\t\t}\n\t\terr = db.Where(filter).Where(\"title LIKE ? OR description LIKE ?\", \n\t\t\t\"%\"+keyword.(string)+\"%\", \"%\"+keyword.(string)+\"%\").\n\t\t\tOrder(\"created_at DESC\").Scopes(PaginateDB(page, size)).Find(&results).Error\n\t} else {\n\t\terr = db.Where(filterParams).Order(\"created_at DESC\").\n\t\t\tScopes(PaginateDB(page, size)).Find(&results).Error\n\t}\n\n\tif err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn results, utils.NotFoundError\n\t\t}\n\t\treturn results, err\n\t}\n\treturn results, nil\n}",
    "caller": "func (h *StoryHandler) HandleStoryQuery(req *types.StoryQueryRequest, log *logger.AppLog) ([]types.StoryContent, error) {\n\tpage, size := utils.GetPagination(req.Page, req.Size)\n\tfilter := make(map[string]interface{})\n\n\tif req.ID > 0 {\n\t\tfilter[\"id\"] = req.ID\n\t} else if req.Author != \"\" {\n\t\tif len(req.Author) > 100 {\n\t\t\tlog.Error(\"author name too long\")\n\t\t\treturn nil, utils.InvalidParamError\n\t\t}\n\t\tfilter[\"author\"] = req.Author\n\t} else if req.Status != \"\" {\n\t\tif !utils.IsValidStatus(req.Status) {\n\t\t\tlog.Error(\"invalid status value\")\n\t\t\treturn nil, utils.InvalidParamError\n\t\t}\n\t\tfilter[\"status\"] = req.Status\n\t} else {\n\t\tfilter[\"is_featured\"] = true\n\t}\n\n\tif req.Keyword != \"\" {\n\t\tfilter[\"keyword\"] = req.Keyword\n\t}\n\n\tstory := &model.Story{}\n\tcontents, err := story.SearchByKeyword(filter, page, size)\n\tif err != nil {\n\t\tlog.Error(fmt.Sprintf(\"SearchByKeyword failed: %v\", err))\n\t\treturn nil, err\n\t}\n\n\treturn contents, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "ID条件 + 无Keyword",
            "sql": "SELECT id, title, description, created_at, updated_at FROM treatment_plans WHERE id = 123 ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "ID条件 + 有Keyword",
            "sql": "SELECT id, title, description, created_at, updated_at FROM treatment_plans WHERE id = 123 AND (title LIKE '%test%' OR description LIKE '%test%') ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "Author条件 + 无Keyword",
            "sql": "SELECT id, title, description, created_at, updated_at FROM treatment_plans WHERE author = 'John' ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "Author条件 + 有Keyword",
            "sql": "SELECT id, title, description, created_at, updated_at FROM treatment_plans WHERE author = 'John' AND (title LIKE '%test%' OR description LIKE '%test%') ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "Status条件 + 无Keyword",
            "sql": "SELECT id, title, description, created_at, updated_at FROM treatment_plans WHERE status = 'published' ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "Status条件 + 有Keyword",
            "sql": "SELECT id, title, description, created_at, updated_at FROM treatment_plans WHERE status = 'published' AND (title LIKE '%test%' OR description LIKE '%test%') ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "默认is_featured + 无Keyword",
            "sql": "SELECT id, title, description, created_at, updated_at FROM treatment_plans WHERE is_featured = true ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "默认is_featured + 有Keyword",
            "sql": "SELECT id, title, description, created_at, updated_at FROM treatment_plans WHERE is_featured = true AND (title LIKE '%test%' OR description LIKE '%test%') ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "StoryContent",
        "code_value": "type StoryContent struct {\n\tID          int       `json:\"id\" gorm:\"column:id\"`\n\tTitle       string    `json:\"title\" gorm:\"column:title\"`\n\tDescription string    `json:\"description\" gorm:\"column:description\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt   time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "StoryResponse",
        "code_value": "type StoryResponse struct {\n\tData       []StoryContent `json:\"data\"`\n\tTotalCount int            `json:\"total_count\"`\n\tPage       int            `json:\"page\"`\n\tSize       int            `json:\"size\"`\n\tStatus     string         `json:\"status\"`\n}"
      },
      {
        "code_key": "StoryFilterParams",
        "code_value": "type StoryFilterParams struct {\n\tKeyword     string `json:\"keyword\"`\n\tCategory    string `json:\"category\"`\n\tAuthorID    int    `json:\"author_id\"`\n\tPublishDate string `json:\"publish_date\"`\n}"
      },
      {
        "code_key": "TreatmentPlansTable",
        "code_value": "const TreatmentPlansTable = \"treatment_plans\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "SearchByKeyword",
    "orm_code": "func (s *Story) SearchByKeyword(filterParams map[string]interface{}, page, size int) ([]types.StoryContent, error) {\n\tresults := make([]types.StoryContent, 0)\n\tvar err error\n\tdb := base.GetInstance().MainDB().Table(\"treatment_plans\")\n\n\tif keyword, ok := filterParams[\"keyword\"]; ok {\n\t\tfilter := make(map[string]interface{})\n\t\tfor k, v := range filterParams {\n\t\t\tif k == \"keyword\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfilter[k] = v\n\t\t}\n\t\terr = db.Where(filter).Where(\"title LIKE ? OR description LIKE ?\", \n\t\t\t\"%\"+keyword.(string)+\"%\", \"%\"+keyword.(string)+\"%\").\n\t\t\tOrder(\"created_at DESC\").Scopes(PaginateDB(page, size)).Find(&results).Error\n\t} else {\n\t\terr = db.Where(filterParams).Order(\"created_at DESC\").\n\t\t\tScopes(PaginateDB(page, size)).Find(&results).Error\n\t}\n\n\tif err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn results, utils.NotFoundError\n\t\t}\n\t\treturn results, err\n\t}\n\treturn results, nil\n}",
    "caller": "func (m *MediaHandler) HandleMediaSearch(req *types.MediaSearchRequest) ([]types.PublicationDetail, error) {\n\tif req.Page <= 0 || req.Size <= 0 {\n\t\treturn nil, errors.New(\"invalid pagination parameters\")\n\t}\n\t\n\tfilter := make(map[string]interface{})\n\tif req.Keyword != \"\" {\n\t\tfilter[\"keyword\"] = req.Keyword\n\t} else if req.AuthorID > 0 {\n\t\tfilter[\"author_id\"] = req.AuthorID\n\t} else if req.DeliveryCode != \"\" {\n\t\tfilter[\"delivery_code\"] = req.DeliveryCode\n\t} else {\n\t\tfilter[\"status\"] = types.Published\n\t}\n\t\n\tpub := &Publication{}\n\tresults, err := pub.SearchByKeyword(filter, req.Page, req.Size)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"search failed: %v\", err)\n\t}\n\t\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按关键词搜索（req.Keyword != \"\"）",
            "sql": "SELECT id, title, abstract, author_id, delivery_code, status, created_at, updated_at FROM publication WHERE (title LIKE '%test%' OR abstract LIKE '%test%') ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "按作者ID搜索（req.AuthorID > 0）",
            "sql": "SELECT id, title, abstract, author_id, delivery_code, status, created_at, updated_at FROM publication WHERE author_id = 123 AND status = 1 ORDER BY created_at DESC LIMIT 10 OFFSET 10;"
          },
          {
            "scenario": "按交付代码搜索（req.DeliveryCode != \"\"）",
            "sql": "SELECT id, title, abstract, author_id, delivery_code, status, created_at, updated_at FROM publication WHERE delivery_code = 'DC123' ORDER BY created_at DESC LIMIT 5 OFFSET 0;"
          },
          {
            "scenario": "默认搜索已发布内容（其他情况）",
            "sql": "SELECT id, title, abstract, author_id, delivery_code, status, created_at, updated_at FROM publication WHERE status = 1 ORDER BY created_at DESC LIMIT 15 OFFSET 30;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "StoryContent",
        "code_value": "type StoryContent struct {\n\tID          int       `json:\"id\" gorm:\"column:id\"`\n\tTitle       string    `json:\"title\" gorm:\"column:title\"`\n\tDescription string    `json:\"description\" gorm:\"column:description\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt   time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "StoryResponse",
        "code_value": "type StoryResponse struct {\n\tData       []StoryContent `json:\"data\"`\n\tTotalCount int            `json:\"total_count\"`\n\tPage       int            `json:\"page\"`\n\tSize       int            `json:\"size\"`\n\tStatus     string         `json:\"status\"`\n}"
      },
      {
        "code_key": "StoryFilterParams",
        "code_value": "type StoryFilterParams struct {\n\tKeyword     string `json:\"keyword\"`\n\tCategory    string `json:\"category\"`\n\tAuthorID    int    `json:\"author_id\"`\n\tPublishDate string `json:\"publish_date\"`\n}"
      },
      {
        "code_key": "TreatmentPlansTable",
        "code_value": "const TreatmentPlansTable = \"treatment_plans\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "EvaluateResults",
    "orm_code": "func (t *Tracking) EvaluateResults(filterParams map[string]interface{}, limit int) ([]types.LabTestRecord, error) {\n\tvar records []types.LabTestRecord\n\tdb := base.GetInstance().IvcDriver().Table(\"lab_test_results\")\n\n\tif reactivationDate, exists := filterParams[\"ReactivationDate\"]; exists {\n\t\tdb = db.Where(\"reactivation_date > ?\", reactivationDate)\n\t\tif room, exists := filterParams[\"Room\"]; exists {\n\t\t\tdb = db.Where(\"room = ?\", room)\n\t\t}\n\t} else if subCategory, exists := filterParams[\"SubCategory\"]; exists {\n\t\tdb = db.Where(\"sub_category LIKE ?\", \"%\"+subCategory.(string)+\"%\")\n\t}\n\n\terr := db.Order(\"created_at DESC\").Limit(limit).Find(&records).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "包含min_rating条件",
            "sql": "SELECT id, rating, floor, is_verified, last_name, created_at, updated_at FROM like_records WHERE rating >= ? ORDER BY created_at DESC LIMIT ?;"
          },
          {
            "scenario": "包含floor条件",
            "sql": "SELECT id, rating, floor, is_verified, last_name, created_at, updated_at FROM like_records WHERE floor = ? AND is_verified = ? ORDER BY rating DESC LIMIT ?;"
          },
          {
            "scenario": "包含last_name模糊匹配条件",
            "sql": "SELECT id, rating, floor, is_verified, last_name, created_at, updated_at FROM like_records WHERE last_name LIKE ? ORDER BY updated_at DESC LIMIT ?;"
          },
          {
            "scenario": "其他条件组合",
            "sql": "SELECT id, rating, floor, is_verified, last_name, created_at, updated_at FROM like_records WHERE is_verified = ? AND rating = ? ORDER BY id DESC LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "LabTestRecord",
        "code_value": "type LabTestRecord struct {\n\tID               int       `json:\"id\" gorm:\"column:id\"`\n\tTestName         string    `json:\"test_name\" gorm:\"column:test_name\"`\n\tSubCategory      string    `json:\"sub_category\" gorm:\"column:sub_category\"`\n\tRoom             string    `json:\"room\" gorm:\"column:room\"`\n\tReactivationDate time.Time `json:\"reactivation_date\" gorm:\"column:reactivation_date\"`\n\tCreatedAt        time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt        time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "FilterParams",
        "code_value": "type FilterParams struct {\n\tReactivationDate *time.Time\n\tRoom            *string\n\tSubCategory     *string\n}"
      },
      {
        "code_key": "LabTestTable",
        "code_value": "const LabTestTable = \"lab_test_results\""
      },
      {
        "code_key": "DefaultQueryLimit",
        "code_value": "const DefaultQueryLimit = 100"
      },
      {
        "code_key": "TestStatus",
        "code_value": "const (\n\tTestStatusPending = \"pending\"\n\tTestStatusCompleted = \"completed\"\n\tTestStatusFailed = \"failed\"\n)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "EvaluateResults",
    "orm_code": "func (t *Tracking) EvaluateResults(filterParams map[string]interface{}, limit int) ([]types.LabTestRecord, error) {\n\tvar records []types.LabTestRecord\n\tdb := base.GetInstance().IvcDriver().Table(\"lab_test_results\")\n\n\tif reactivationDate, exists := filterParams[\"ReactivationDate\"]; exists {\n\t\tdb = db.Where(\"reactivation_date > ?\", reactivationDate)\n\t\tif room, exists := filterParams[\"Room\"]; exists {\n\t\t\tdb = db.Where(\"room = ?\", room)\n\t\t}\n\t} else if subCategory, exists := filterParams[\"SubCategory\"]; exists {\n\t\tdb = db.Where(\"sub_category LIKE ?\", \"%\"+subCategory.(string)+\"%\")\n\t}\n\n\terr := db.Order(\"created_at DESC\").Limit(limit).Find(&records).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "caller": "func (s *CertService) HandleCertificateAnalysis(req *types.CertAnalysisRequest) ([]types.LabTestRecord, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.CertID != \"\" {\n\t\tfilter[\"ReactivationDate\"] = time.Now().AddDate(0, -6, 0) // 6 months ago\n\t\tfilter[\"Room\"] = \"certification\"\n\t} else if req.AnalysisType == \"full\" {\n\t\tif req.StartDate.IsZero() || req.EndDate.IsZero() {\n\t\t\treturn nil, fmt.Errorf(\"start and end dates are required for full analysis\")\n\t\t}\n\t\tfilter[\"ReactivationDate\"] = req.StartDate\n\t} else if req.Keyword != \"\" {\n\t\tif len(req.Keyword) < 3 {\n\t\t\treturn nil, fmt.Errorf(\"search keyword must be at least 3 characters\")\n\t\t}\n\t\tfilter[\"SubCategory\"] = req.Keyword\n\t} else {\n\t\treturn nil, fmt.Errorf(\"no valid filter parameters provided\")\n\t}\n\n\ttracker := &Tracking{}\n\tresults, err := tracker.EvaluateResults(filter, 100)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to evaluate results: %v\", err)\n\t}\n\t\n\tif len(results) == 0 {\n\t\treturn nil, fmt.Errorf(\"no records found matching criteria\")\n\t}\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "提供CertID，同时包含ReactivationDate和Room条件",
            "sql": "SELECT id, test_name, sub_category, room, reactivation_date, created_at, updated_at FROM lab_test_results WHERE reactivation_date > ? AND room = ? ORDER BY created_at DESC LIMIT 100;"
          },
          {
            "scenario": "AnalysisType为full且有起止日期，只包含ReactivationDate条件",
            "sql": "SELECT id, test_name, sub_category, room, reactivation_date, created_at, updated_at FROM lab_test_results WHERE reactivation_date > ? ORDER BY created_at DESC LIMIT 100;"
          },
          {
            "scenario": "提供Keyword，只包含SubCategory的LIKE模糊查询条件",
            "sql": "SELECT id, test_name, sub_category, room, reactivation_date, created_at, updated_at FROM lab_test_results WHERE sub_category LIKE ? ORDER BY created_at DESC LIMIT 100;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "LabTestRecord",
        "code_value": "type LabTestRecord struct {\n\tID               int       `json:\"id\" gorm:\"column:id\"`\n\tTestName         string    `json:\"test_name\" gorm:\"column:test_name\"`\n\tSubCategory      string    `json:\"sub_category\" gorm:\"column:sub_category\"`\n\tRoom             string    `json:\"room\" gorm:\"column:room\"`\n\tReactivationDate time.Time `json:\"reactivation_date\" gorm:\"column:reactivation_date\"`\n\tCreatedAt        time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt        time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "FilterParams",
        "code_value": "type FilterParams struct {\n\tReactivationDate *time.Time\n\tRoom            *string\n\tSubCategory     *string\n}"
      },
      {
        "code_key": "LabTestTable",
        "code_value": "const LabTestTable = \"lab_test_results\""
      },
      {
        "code_key": "DefaultQueryLimit",
        "code_value": "const DefaultQueryLimit = 100"
      },
      {
        "code_key": "TestStatus",
        "code_value": "const (\n\tTestStatusPending = \"pending\"\n\tTestStatusCompleted = \"completed\"\n\tTestStatusFailed = \"failed\"\n)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "EvaluateResults",
    "orm_code": "func (t *Tracking) EvaluateResults(filterParams map[string]interface{}, limit int) ([]types.LabTestRecord, error) {\n\tvar records []types.LabTestRecord\n\tdb := base.GetInstance().IvcDriver().Table(\"lab_test_results\")\n\n\tif reactivationDate, exists := filterParams[\"ReactivationDate\"]; exists {\n\t\tdb = db.Where(\"reactivation_date > ?\", reactivationDate)\n\t\tif room, exists := filterParams[\"Room\"]; exists {\n\t\t\tdb = db.Where(\"room = ?\", room)\n\t\t}\n\t} else if subCategory, exists := filterParams[\"SubCategory\"]; exists {\n\t\tdb = db.Where(\"sub_category LIKE ?\", \"%\"+subCategory.(string)+\"%\")\n\t}\n\n\terr := db.Order(\"created_at DESC\").Limit(limit).Find(&records).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "caller": "func (s *PurchaseService) HandlePurchaseEvaluation(req *types.EvaluationRequest) ([]types.PurchaseEvaluation, error) {\n\tif req.Limit <= 0 {\n\t\treturn nil, fmt.Errorf(\"limit must be positive\")\n\t}\n\n\tfilter := make(map[string]interface{})\n\tif req.MinRating > 0 {\n\t\tfilter[\"min_rating\"] = req.MinRating\n\t} else if req.Floor != \"\" {\n\t\tfilter[\"floor\"] = req.Floor\n\t} else if req.LastName != \"\" {\n\t\tfilter[\"last_name\"] = req.LastName\n\t} else {\n\t\tfilter[\"status\"] = \"completed\"\n\t}\n\n\tbuyer := &Buyer{}\n\treturn buyer.EvaluateResults(filter, req.Limit)\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "min_rating > 0",
            "sql": "SELECT id, rating, floor, is_verified, last_name, created_at, updated_at FROM like_records WHERE rating >= ? ORDER BY created_at DESC LIMIT ?;"
          },
          {
            "scenario": "floor non-empty",
            "sql": "SELECT id, rating, floor, is_verified, last_name, created_at, updated_at FROM like_records WHERE floor = ? AND is_verified = true ORDER BY rating DESC LIMIT ?;"
          },
          {
            "scenario": "last_name non-empty",
            "sql": "SELECT id, rating, floor, is_verified, last_name, created_at, updated_at FROM like_records WHERE last_name LIKE ? ORDER BY updated_at DESC LIMIT ?;"
          },
          {
            "scenario": "default case (status = 'completed')",
            "sql": "SELECT id, rating, floor, is_verified, last_name, created_at, updated_at FROM like_records WHERE status = ? ORDER BY id DESC LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "LabTestRecord",
        "code_value": "type LabTestRecord struct {\n\tID               int       `json:\"id\" gorm:\"column:id\"`\n\tTestName         string    `json:\"test_name\" gorm:\"column:test_name\"`\n\tSubCategory      string    `json:\"sub_category\" gorm:\"column:sub_category\"`\n\tRoom             string    `json:\"room\" gorm:\"column:room\"`\n\tReactivationDate time.Time `json:\"reactivation_date\" gorm:\"column:reactivation_date\"`\n\tCreatedAt        time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt        time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "FilterParams",
        "code_value": "type FilterParams struct {\n\tReactivationDate *time.Time\n\tRoom            *string\n\tSubCategory     *string\n}"
      },
      {
        "code_key": "LabTestTable",
        "code_value": "const LabTestTable = \"lab_test_results\""
      },
      {
        "code_key": "DefaultQueryLimit",
        "code_value": "const DefaultQueryLimit = 100"
      },
      {
        "code_key": "TestStatus",
        "code_value": "const (\n\tTestStatusPending = \"pending\"\n\tTestStatusCompleted = \"completed\"\n\tTestStatusFailed = \"failed\"\n)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "FindVaccinationRecords",
    "orm_code": "func (v *Vaccination) FindVaccinationRecords(filter map[string]interface{}, page, size int) ([]types.VaccinationRecord, error) {\n\tvar records []types.VaccinationRecord\n\tdb := base.GetInstance().HealthDB().Table(\"vaccination_records\")\n\t\n\tif batchNo, ok := filter[\"batch_no\"]; ok {\n\t\tdelete(filter, \"batch_no\")\n\t\tdb = db.Where(filter).Where(\"batch_no LIKE ?\", \"%\"+batchNo.(string)+\"%\")\n\t} else if facilityId, ok := filter[\"facility_id\"]; ok {\n\t\tdelete(filter, \"facility_id\")\n\t\tdb = db.Where(filter).Where(\"facility_id = ?\", facilityId.(int))\n\t} else {\n\t\tdb = db.Where(filter)\n\t}\n\t\n\terr := db.Scopes(PaginateDB(page, size)).Find(&records).Error\n\tif err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn nil, utils.RecordNotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "包含batch_no模糊搜索条件",
            "sql": "SELECT id, patient_id, vaccine_type, batch_no, facility_id, administered_at, dose_number, created_at, updated_at FROM vaccination_records WHERE vaccine_type = ? AND batch_no LIKE ? LIMIT 10 OFFSET 0;"
          },
          {
            "scenario": "包含facility_id精确匹配条件",
            "sql": "SELECT id, patient_id, vaccine_type, batch_no, facility_id, administered_at, dose_number, created_at, updated_at FROM vaccination_records WHERE patient_id = ? AND facility_id = ? LIMIT 10 OFFSET 0;"
          },
          {
            "scenario": "普通条件组合",
            "sql": "SELECT id, patient_id, vaccine_type, batch_no, facility_id, administered_at, dose_number, created_at, updated_at FROM vaccination_records WHERE patient_id = ? AND vaccine_type = ? LIMIT 10 OFFSET 0;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "VaccinationRecord",
        "code_value": "type VaccinationRecord struct {\n\tID          int       `json:\"id\" gorm:\"column:id\"`\n\tPatientID   string    `json:\"patient_id\" gorm:\"column:patient_id\"`\n\tVaccineType string    `json:\"vaccine_type\" gorm:\"column:vaccine_type\"`\n\tBatchNo     string    `json:\"batch_no\" gorm:\"column:batch_no\"`\n\tFacilityID  int       `json:\"facility_id\" gorm:\"column:facility_id\"`\n\tAdminDate   time.Time `json:\"admin_date\" gorm:\"column:administered_at\"`\n\tDoseNumber  int       `json:\"dose_number\" gorm:\"column:dose_number\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt   time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "VaccinationFilter",
        "code_value": "type VaccinationFilter struct {\n\tPatientID   *string    `json:\"patient_id\"`\n\tVaccineType *string    `json:\"vaccine_type\"`\n\tBatchNo     *string    `json:\"batch_no\"`\n\tFacilityID  *int       `json:\"facility_id\"`\n\tStartDate   *time.Time `json:\"start_date\"`\n\tEndDate     *time.Time `json:\"end_date\"`\n}"
      },
      {
        "code_key": "VaccinationTableName",
        "code_value": "const VaccinationTableName = \"vaccination_records\""
      },
      {
        "code_key": "VaccinationStatus",
        "code_value": "const (\n\tVaccinationPending = \"PENDING\"\n\tVaccinationCompleted = \"COMPLETED\"\n\tVaccinationCancelled = \"CANCELLED\"\n)"
      },
      {
        "code_key": "PaginateDB",
        "code_value": "func PaginateDB(page, size int) func(db *gorm.DB) *gorm.DB {\n\treturn func(db *gorm.DB) *gorm.DB {\n\t\toffset := (page - 1) * size\n\t\treturn db.Offset(offset).Limit(size)\n\t}\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "FindVaccinationRecords",
    "orm_code": "func (v *Vaccination) FindVaccinationRecords(filter map[string]interface{}, page, size int) ([]types.VaccinationRecord, error) {\n\tvar records []types.VaccinationRecord\n\tdb := base.GetInstance().HealthDB().Table(\"vaccination_records\")\n\t\n\tif batchNo, ok := filter[\"batch_no\"]; ok {\n\t\tdelete(filter, \"batch_no\")\n\t\tdb = db.Where(filter).Where(\"batch_no LIKE ?\", \"%\"+batchNo.(string)+\"%\")\n\t} else if facilityId, ok := filter[\"facility_id\"]; ok {\n\t\tdelete(filter, \"facility_id\")\n\t\tdb = db.Where(filter).Where(\"facility_id = ?\", facilityId.(int))\n\t} else {\n\t\tdb = db.Where(filter)\n\t}\n\t\n\terr := db.Scopes(PaginateDB(page, size)).Find(&records).Error\n\tif err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn nil, utils.RecordNotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "caller": "func (h *VaccinationHandler) HandleVaccinationQuery(req *types.VaccinationQueryRequest) ([]types.VaccinationRecord, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.PatientID != \"\" {\n\t\tfilter[\"patient_id\"] = req.PatientID\n\t} else if req.VaccineType != \"\" {\n\t\tif !utils.IsValidVaccineType(req.VaccineType) {\n\t\t\treturn nil, utils.InvalidParamError\n\t\t}\n\t\tfilter[\"vaccine_type\"] = req.VaccineType\n\t} else if req.Status != 0 {\n\t\tif req.Status < 1 || req.Status > 3 {\n\t\t\treturn nil, utils.InvalidParamError\n\t\t}\n\t\tfilter[\"status\"] = req.Status\n\t} else {\n\t\treturn nil, utils.MissingParamError\n\t}\n\t\n\tvaccination := &model.Vaccination{}\n\tpage, size := utils.ParsePagination(req.Page, req.Size)\n\t\n\trecords, err := vaccination.FindVaccinationRecords(filter, page, size)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按patient_id查询",
            "sql": "SELECT id, patient_id, vaccine_type, batch_no, facility_id, administered_at, dose_number, created_at, updated_at FROM vaccination_records WHERE patient_id = ? LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "按vaccine_type查询",
            "sql": "SELECT id, patient_id, vaccine_type, batch_no, facility_id, administered_at, dose_number, created_at, updated_at FROM vaccination_records WHERE vaccine_type = ? LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "按status查询",
            "sql": "SELECT id, patient_id, vaccine_type, batch_no, facility_id, administered_at, dose_number, created_at, updated_at FROM vaccination_records WHERE status = ? LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "按patient_id和batch_no模糊查询",
            "sql": "SELECT id, patient_id, vaccine_type, batch_no, facility_id, administered_at, dose_number, created_at, updated_at FROM vaccination_records WHERE patient_id = ? AND batch_no LIKE ? LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "按patient_id和facility_id精确查询",
            "sql": "SELECT id, patient_id, vaccine_type, batch_no, facility_id, administered_at, dose_number, created_at, updated_at FROM vaccination_records WHERE patient_id = ? AND facility_id = ? LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "VaccinationRecord",
        "code_value": "type VaccinationRecord struct {\n\tID          int       `json:\"id\" gorm:\"column:id\"`\n\tPatientID   string    `json:\"patient_id\" gorm:\"column:patient_id\"`\n\tVaccineType string    `json:\"vaccine_type\" gorm:\"column:vaccine_type\"`\n\tBatchNo     string    `json:\"batch_no\" gorm:\"column:batch_no\"`\n\tFacilityID  int       `json:\"facility_id\" gorm:\"column:facility_id\"`\n\tAdminDate   time.Time `json:\"admin_date\" gorm:\"column:administered_at\"`\n\tDoseNumber  int       `json:\"dose_number\" gorm:\"column:dose_number\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt   time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "VaccinationFilter",
        "code_value": "type VaccinationFilter struct {\n\tPatientID   *string    `json:\"patient_id\"`\n\tVaccineType *string    `json:\"vaccine_type\"`\n\tBatchNo     *string    `json:\"batch_no\"`\n\tFacilityID  *int       `json:\"facility_id\"`\n\tStartDate   *time.Time `json:\"start_date\"`\n\tEndDate     *time.Time `json:\"end_date\"`\n}"
      },
      {
        "code_key": "VaccinationTableName",
        "code_value": "const VaccinationTableName = \"vaccination_records\""
      },
      {
        "code_key": "VaccinationStatus",
        "code_value": "const (\n\tVaccinationPending = \"PENDING\"\n\tVaccinationCompleted = \"COMPLETED\"\n\tVaccinationCancelled = \"CANCELLED\"\n)"
      },
      {
        "code_key": "PaginateDB",
        "code_value": "func PaginateDB(page, size int) func(db *gorm.DB) *gorm.DB {\n\treturn func(db *gorm.DB) *gorm.DB {\n\t\toffset := (page - 1) * size\n\t\treturn db.Offset(offset).Limit(size)\n\t}\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "QueryDiagnosticResults",
    "orm_code": "func (d *Diagnostic) QueryDiagnosticResults(filters map[string]interface{}, page, size int) ([]types.DiagnosticRecord, error) {\n\tvar records []types.DiagnosticRecord\n\tdb := base.GetInstance().PrimaryDB().Table(\"diagnostic_results\").Order(\"RegistrationTime DESC\")\n\n\tif approval, ok := filters[\"ApprovalLevel\"]; ok {\n\t\t// Exact match for approval level\n\t\tdelete(filters, \"ApprovalLevel\")\n\t\tdb = db.Where(\"approval_level = ?\", approval).Where(filters)\n\t} else if address, ok := filters[\"WorkAddress\"]; ok {\n\t\t// Partial match for work address\n\t\tdelete(filters, \"WorkAddress\")\n\t\tdb = db.Where(\"work_address LIKE ?\", \"%\"+address.(string)+\"%\").Where(filters)\n\t} else {\n\t\tdb = db.Where(filters)\n\t}\n\n\terr := db.Scopes(PaginateDB(page, size)).Find(&records).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "包含ApprovalLevel过滤条件",
            "sql": "SELECT id, patient_name, registration_time, approval_level, work_address, diagnosis_code, status, created_at, updated_at FROM diagnostic_results WHERE approval_level = ? AND status = ? ORDER BY registration_time DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "包含WorkAddress过滤条件",
            "sql": "SELECT id, patient_name, registration_time, approval_level, work_address, diagnosis_code, status, created_at, updated_at FROM diagnostic_results WHERE work_address LIKE ? AND status = ? ORDER BY registration_time DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "不包含特殊过滤条件",
            "sql": "SELECT id, patient_name, registration_time, approval_level, work_address, diagnosis_code, status, created_at, updated_at FROM diagnostic_results WHERE patient_name = ? AND status = ? ORDER BY registration_time DESC LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "DiagnosticRecord",
        "code_value": "type DiagnosticRecord struct {\n\tID                int       `json:\"id\" gorm:\"column:id\"`\n\tPatientName       string    `json:\"patient_name\" gorm:\"column:patient_name\"`\n\tRegistrationTime  time.Time `json:\"registration_time\" gorm:\"column:registration_time\"`\n\tApprovalLevel     int       `json:\"approval_level\" gorm:\"column:approval_level\"`\n\tWorkAddress       string    `json:\"work_address\" gorm:\"column:work_address\"`\n\tDiagnosisCode     string    `json:\"diagnosis_code\" gorm:\"column:diagnosis_code\"`\n\tStatus            int       `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt         time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt         time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "DiagnosticFilterRequest",
        "code_value": "type DiagnosticFilterRequest struct {\n\tPatientName   string `json:\"patient_name\"`\n\tApprovalLevel int    `json:\"approval_level\"`\n\tWorkAddress   string `json:\"work_address\"`\n\tStatus        int    `json:\"status\"`\n\tPage          int    `json:\"page\"`\n\tPageSize      int    `json:\"page_size\"`\n}"
      },
      {
        "code_key": "DiagnosticResultResponse",
        "code_value": "type DiagnosticResultResponse struct {\n\tRecords       []DiagnosticRecord `json:\"records\"`\n\tTotalCount    int                `json:\"total_count\"`\n\tCurrentPage   int                `json:\"current_page\"`\n\tTotalPages    int                `json:\"total_pages\"`\n}"
      },
      {
        "code_key": "DiagnosticStatus",
        "code_value": "const (\n\tStatusPending  = 0\n\tStatusApproved = 1\n\tStatusRejected = 2\n)"
      },
      {
        "code_key": "TableDiagnosticResults",
        "code_value": "const TableDiagnosticResults = \"diagnostic_results\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "QueryDiagnosticResults",
    "orm_code": "func (d *Diagnostic) QueryDiagnosticResults(filters map[string]interface{}, page, size int) ([]types.DiagnosticRecord, error) {\n\tvar records []types.DiagnosticRecord\n\tdb := base.GetInstance().PrimaryDB().Table(\"diagnostic_results\").Order(\"RegistrationTime DESC\")\n\n\tif approval, ok := filters[\"ApprovalLevel\"]; ok {\n\t\t// Exact match for approval level\n\t\tdelete(filters, \"ApprovalLevel\")\n\t\tdb = db.Where(\"approval_level = ?\", approval).Where(filters)\n\t} else if address, ok := filters[\"WorkAddress\"]; ok {\n\t\t// Partial match for work address\n\t\tdelete(filters, \"WorkAddress\")\n\t\tdb = db.Where(\"work_address LIKE ?\", \"%\"+address.(string)+\"%\").Where(filters)\n\t} else {\n\t\tdb = db.Where(filters)\n\t}\n\n\terr := db.Scopes(PaginateDB(page, size)).Find(&records).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "caller": "func (h *ResourceHandler) HandleResourceAccessLogs(req *types.AccessLogRequest, logger *log.Logger) ([]types.DiagnosticRecord, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.ResourceID != \"\" {\n\t\tfilter[\"resource_id\"] = req.ResourceID\n\t} else if req.UserEmail != \"\" {\n\t\tif !strings.Contains(req.UserEmail, \"@\") {\n\t\t\tlogger.Printf(\"Invalid email format: %s\", req.UserEmail)\n\t\t\treturn nil, fmt.Errorf(\"invalid email format\")\n\t\t}\n\t\tfilter[\"user_email\"] = req.UserEmail\n\t} else if req.Status != 0 {\n\t\tif req.Status < 1 || req.Status > 3 {\n\t\t\tlogger.Printf(\"Invalid status value: %d\", req.Status)\n\t\t\treturn nil, fmt.Errorf(\"status must be 1-3\")\n\t\t}\n\t\tfilter[\"status\"] = req.Status\n\t} else {\n\t\tfilter[\"timestamp\"] = req.TimeRange\n\t}\n\n\td := &Diagnostic{}\n\tresult, err := d.QueryDiagnosticResults(filter, req.Page, req.PageSize)\n\tif err != nil {\n\t\tlogger.Printf(\"Query failed: %v\", err)\n\t\treturn nil, fmt.Errorf(\"query failed: %w\", err)\n\t}\n\treturn result, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "filter contains resource_id",
            "sql": "SELECT * FROM diagnostic_results WHERE resource_id = ? ORDER BY registration_time DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "filter contains user_email",
            "sql": "SELECT * FROM diagnostic_results WHERE user_email = ? ORDER BY registration_time DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "filter contains status (1-3)",
            "sql": "SELECT * FROM diagnostic_results WHERE status = ? ORDER BY registration_time DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "filter contains timestamp (TimeRange)",
            "sql": "SELECT * FROM diagnostic_results WHERE timestamp BETWEEN ? AND ? ORDER BY registration_time DESC LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "DiagnosticRecord",
        "code_value": "type DiagnosticRecord struct {\n\tID                int       `json:\"id\" gorm:\"column:id\"`\n\tPatientName       string    `json:\"patient_name\" gorm:\"column:patient_name\"`\n\tRegistrationTime  time.Time `json:\"registration_time\" gorm:\"column:registration_time\"`\n\tApprovalLevel     int       `json:\"approval_level\" gorm:\"column:approval_level\"`\n\tWorkAddress       string    `json:\"work_address\" gorm:\"column:work_address\"`\n\tDiagnosisCode     string    `json:\"diagnosis_code\" gorm:\"column:diagnosis_code\"`\n\tStatus            int       `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt         time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt         time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "DiagnosticFilterRequest",
        "code_value": "type DiagnosticFilterRequest struct {\n\tPatientName   string `json:\"patient_name\"`\n\tApprovalLevel int    `json:\"approval_level\"`\n\tWorkAddress   string `json:\"work_address\"`\n\tStatus        int    `json:\"status\"`\n\tPage          int    `json:\"page\"`\n\tPageSize      int    `json:\"page_size\"`\n}"
      },
      {
        "code_key": "DiagnosticResultResponse",
        "code_value": "type DiagnosticResultResponse struct {\n\tRecords       []DiagnosticRecord `json:\"records\"`\n\tTotalCount    int                `json:\"total_count\"`\n\tCurrentPage   int                `json:\"current_page\"`\n\tTotalPages    int                `json:\"total_pages\"`\n}"
      },
      {
        "code_key": "DiagnosticStatus",
        "code_value": "const (\n\tStatusPending  = 0\n\tStatusApproved = 1\n\tStatusRejected = 2\n)"
      },
      {
        "code_key": "TableDiagnosticResults",
        "code_value": "const TableDiagnosticResults = \"diagnostic_results\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "LoadBalance",
    "orm_code": "func (p *Publication) LoadBalance(filter map[string]interface{}) ([]types.ContentDistribution, error) {\n\tvar distributions []types.ContentDistribution\n\tdb := base.GetInstance().PrimaryDB().Table(\"content_reports\")\n\n\tif region, ok := filter[\"Region\"]; ok {\n\t\tdelete(filter, \"Region\")\n\t\tdb = db.Where(\"region LIKE ?\", \"%\"+region.(string)+\"%\")\n\t}\n\n\tif priority, ok := filter[\"Priority\"]; ok {\n\t\tdb = db.Where(\"priority_level = ?\", priority.(int))\n\t\tdelete(filter, \"Priority\")\n\t}\n\n\tif len(filter) > 0 {\n\t\tdb = db.Where(filter)\n\t}\n\n\tif err := db.Find(&distributions).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.NotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn distributions, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按MethodName筛选",
            "sql": "SELECT id, method_name, last_access_time, allocated_amount, end_date, vendor_id, contract_number FROM vendor_contracts WHERE method_name LIKE '%payment%' ORDER BY end_date DESC;"
          },
          {
            "scenario": "按LastAccessTime筛选",
            "sql": "SELECT id, method_name, last_access_time, allocated_amount, end_date, vendor_id, contract_number FROM vendor_contracts WHERE last_access_time > '2023-01-01T00:00:00Z' ORDER BY end_date DESC;"
          },
          {
            "scenario": "按ThresholdAmount筛选",
            "sql": "SELECT id, method_name, last_access_time, allocated_amount, end_date, vendor_id, contract_number FROM vendor_contracts WHERE allocated_amount >= 5000.0 ORDER BY end_date DESC;"
          },
          {
            "scenario": "无筛选条件",
            "sql": "SELECT id, method_name, last_access_time, allocated_amount, end_date, vendor_id, contract_number FROM vendor_contracts ORDER BY end_date DESC LIMIT 50;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "ContentDistribution",
        "code_value": "type ContentDistribution struct {\n\tID             int       `json:\"id\" gorm:\"column:id\"`\n\tContentID      string    `json:\"content_id\" gorm:\"column:content_id\"`\n\tRegion         string    `json:\"region\" gorm:\"column:region\"`\n\tPriorityLevel  int       `json:\"priority_level\" gorm:\"column:priority_level\"`\n\tDistributionAt time.Time `json:\"distribution_at\" gorm:\"column:distribution_at\"`\n\tStatus         int       `json:\"status\" gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "DistributionStatus",
        "code_value": "const (\n\tStatusPending = iota\n\tStatusProcessing\n\tStatusCompleted\n\tStatusFailed\n)"
      },
      {
        "code_key": "ContentTable",
        "code_value": "const ContentTable = \"content_reports\""
      },
      {
        "code_key": "DistributionFilter",
        "code_value": "type DistributionFilter struct {\n\tRegion   string\n\tPriority int\n\tStatus   int\n\tContentIDs []string\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "LoadBalance",
    "orm_code": "func (p *Publication) LoadBalance(filter map[string]interface{}) ([]types.ContentDistribution, error) {\n\tvar distributions []types.ContentDistribution\n\tdb := base.GetInstance().PrimaryDB().Table(\"content_reports\")\n\n\tif region, ok := filter[\"Region\"]; ok {\n\t\tdelete(filter, \"Region\")\n\t\tdb = db.Where(\"region LIKE ?\", \"%\"+region.(string)+\"%\")\n\t}\n\n\tif priority, ok := filter[\"Priority\"]; ok {\n\t\tdb = db.Where(\"priority_level = ?\", priority.(int))\n\t\tdelete(filter, \"Priority\")\n\t}\n\n\tif len(filter) > 0 {\n\t\tdb = db.Where(filter)\n\t}\n\n\tif err := db.Find(&distributions).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.NotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn distributions, nil\n}",
    "caller": "func (h *ContentHandler) HandleContentDistribution(req *types.ContentDistributionRequest) ([]types.ContentDistribution, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.ContentID != \"\" {\n\t\tfilter[\"content_id\"] = req.ContentID\n\t} else if req.Status != 0 {\n\t\tif req.Status < 1 || req.Status > 3 {\n\t\t\treturn nil, fmt.Errorf(\"invalid status value: %d\", req.Status)\n\t\t}\n\t\tfilter[\"status\"] = req.Status\n\t} else if req.CreatedAfter != \"\" {\n\t\tif _, err := time.Parse(time.RFC3339, req.CreatedAfter); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"invalid date format: %v\", err)\n\t\t}\n\t\tfilter[\"created_at > ?\"] = req.CreatedAfter\n\t} else {\n\t\treturn nil, fmt.Errorf(\"at least one filter parameter is required\")\n\t}\n\t\n\tif req.Region != \"\" {\n\t\tfilter[\"Region\"] = req.Region\n\t}\n\t\n\tif req.Priority != 0 {\n\t\tfilter[\"Priority\"] = req.Priority\n\t}\n\t\n\tpub := &Publication{}\n\treturn pub.LoadBalance(filter)\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "ContentID为主条件",
            "sql": "SELECT id, content_id, region, priority_level, distribution_at, status FROM content_reports WHERE content_id = ? AND region LIKE ? AND priority_level = ?;"
          },
          {
            "scenario": "Status为主条件",
            "sql": "SELECT id, content_id, region, priority_level, distribution_at, status FROM content_reports WHERE status = ? AND region LIKE ? AND priority_level = ?;"
          },
          {
            "scenario": "CreatedAfter为主条件",
            "sql": "SELECT id, content_id, region, priority_level, distribution_at, status FROM content_reports WHERE created_at > ? AND region LIKE ? AND priority_level = ?;"
          },
          {
            "scenario": "只有Region和Priority（调用者逻辑不会触发此场景）",
            "sql": "SELECT id, content_id, region, priority_level, distribution_at, status FROM content_reports WHERE region LIKE ? AND priority_level = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ContentDistribution",
        "code_value": "type ContentDistribution struct {\n\tID             int       `json:\"id\" gorm:\"column:id\"`\n\tContentID      string    `json:\"content_id\" gorm:\"column:content_id\"`\n\tRegion         string    `json:\"region\" gorm:\"column:region\"`\n\tPriorityLevel  int       `json:\"priority_level\" gorm:\"column:priority_level\"`\n\tDistributionAt time.Time `json:\"distribution_at\" gorm:\"column:distribution_at\"`\n\tStatus         int       `json:\"status\" gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "DistributionStatus",
        "code_value": "const (\n\tStatusPending = iota\n\tStatusProcessing\n\tStatusCompleted\n\tStatusFailed\n)"
      },
      {
        "code_key": "ContentTable",
        "code_value": "const ContentTable = \"content_reports\""
      },
      {
        "code_key": "DistributionFilter",
        "code_value": "type DistributionFilter struct {\n\tRegion   string\n\tPriority int\n\tStatus   int\n\tContentIDs []string\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "LoadBalance",
    "orm_code": "func (p *Publication) LoadBalance(filter map[string]interface{}) ([]types.ContentDistribution, error) {\n\tvar distributions []types.ContentDistribution\n\tdb := base.GetInstance().PrimaryDB().Table(\"content_reports\")\n\n\tif region, ok := filter[\"Region\"]; ok {\n\t\tdelete(filter, \"Region\")\n\t\tdb = db.Where(\"region LIKE ?\", \"%\"+region.(string)+\"%\")\n\t}\n\n\tif priority, ok := filter[\"Priority\"]; ok {\n\t\tdb = db.Where(\"priority_level = ?\", priority.(int))\n\t\tdelete(filter, \"Priority\")\n\t}\n\n\tif len(filter) > 0 {\n\t\tdb = db.Where(filter)\n\t}\n\n\tif err := db.Find(&distributions).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.NotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn distributions, nil\n}",
    "caller": "func (r *ResourceManager) HandleResourceAllocation(req *types.AllocationRequest) ([]types.CostAllocation, error) {\n\tif req == nil {\n\t\treturn nil, fmt.Errorf(\"invalid request\")\n\t}\n\n\tfilters := make(map[string]interface{})\n\tvar pageLimit int\n\n\tif req.MethodFilter != \"\" {\n\t\tfilters[\"MethodName\"] = req.MethodFilter\n\t} else if !req.LastAccessed.IsZero() {\n\t\tfilters[\"LastAccessTime\"] = req.LastAccessed\n\t} else if req.MinAmount > 0 {\n\t\tfilters[\"ThresholdAmount\"] = req.MinAmount\n\t} else {\n\t\tpageLimit = 50\n\t}\n\n\tbudget := &Budget{}\n\tallocations, err := budget.LoadBalance(filters, pageLimit)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to load allocations: %v\", err)\n\t}\n\n\treturn allocations, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "MethodFilter provided",
            "sql": "SELECT id, method_name, last_access_time, allocated_amount, end_date, vendor_id, contract_number FROM vendor_contracts WHERE method_name LIKE ? ORDER BY end_date DESC;"
          },
          {
            "scenario": "LastAccessTime provided",
            "sql": "SELECT id, method_name, last_access_time, allocated_amount, end_date, vendor_id, contract_number FROM vendor_contracts WHERE last_access_time > ? ORDER BY end_date DESC;"
          },
          {
            "scenario": "ThresholdAmount provided",
            "sql": "SELECT id, method_name, last_access_time, allocated_amount, end_date, vendor_id, contract_number FROM vendor_contracts WHERE allocated_amount >= ? ORDER BY end_date DESC;"
          },
          {
            "scenario": "No filter condition",
            "sql": "SELECT id, method_name, last_access_time, allocated_amount, end_date, vendor_id, contract_number FROM vendor_contracts ORDER BY end_date DESC LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "ContentDistribution",
        "code_value": "type ContentDistribution struct {\n\tID             int       `json:\"id\" gorm:\"column:id\"`\n\tContentID      string    `json:\"content_id\" gorm:\"column:content_id\"`\n\tRegion         string    `json:\"region\" gorm:\"column:region\"`\n\tPriorityLevel  int       `json:\"priority_level\" gorm:\"column:priority_level\"`\n\tDistributionAt time.Time `json:\"distribution_at\" gorm:\"column:distribution_at\"`\n\tStatus         int       `json:\"status\" gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "DistributionStatus",
        "code_value": "const (\n\tStatusPending = iota\n\tStatusProcessing\n\tStatusCompleted\n\tStatusFailed\n)"
      },
      {
        "code_key": "ContentTable",
        "code_value": "const ContentTable = \"content_reports\""
      },
      {
        "code_key": "DistributionFilter",
        "code_value": "type DistributionFilter struct {\n\tRegion   string\n\tPriority int\n\tStatus   int\n\tContentIDs []string\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "TrackLabResults",
    "orm_code": "func (l *Lab) TrackLabResults(filterParams map[string]interface{}, page, size int) ([]types.LabTestResult, error) {\n\tresults := make([]types.LabTestResult, 0)\n\tdb := base.GetInstance().LabDriver().Table(\"lab_test_results\")\n\n\tif area, exists := filterParams[\"Area\"]; exists {\n\t\t// Filter by area with exact match and sort by CreationTime\n\t\terr := db.Where(\"area = ?\", area).\n\t\t\tOrder(\"creation_time desc\").\n\t\t\tScopes(PaginateDB(page, size)).\n\t\t\tFind(&results).Error\n\t\treturn results, err\n\t} else if desc, exists := filterParams[\"Description\"]; exists {\n\t\t// Filter by description with partial match\n\t\terr := db.Where(\"description LIKE ?\", \"%\"+desc.(string)+\"%\").\n\t\t\tOrder(\"id\").\n\t\t\tScopes(PaginateDB(page, size)).\n\t\t\tFind(&results).Error\n\t\treturn results, err\n\t}\n\n\t// Default query without area or description filters\n\terr := db.Where(filterParams).\n\t\tOrder(\"id\").\n\t\tScopes(PaginateDB(page, size)).\n\t\tFind(&results).Error\n\treturn results, err\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按Area精确匹配",
            "sql": "SELECT id, area, description, result_value, creation_time, status FROM lab_test_results WHERE area = ? ORDER BY creation_time desc LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "按Description模糊匹配",
            "sql": "SELECT id, area, description, result_value, creation_time, status FROM lab_test_results WHERE description LIKE ? ORDER BY id LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "默认查询（使用所有filterParams）",
            "sql": "SELECT id, area, description, result_value, creation_time, status FROM lab_test_results WHERE status = ? AND result_value = ? ORDER BY id LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "LabTestResult",
        "code_value": "type LabTestResult struct {\n\tID           int       `json:\"id\" gorm:\"column:id\"`\n\tArea         string    `json:\"area\" gorm:\"column:area\"`\n\tDescription  string    `json:\"description\" gorm:\"column:description\"`\n\tResultValue  float64   `json:\"result_value\" gorm:\"column:result_value\"`\n\tCreationTime time.Time `json:\"creation_time\" gorm:\"column:creation_time\"`\n\tStatus       int       `json:\"status\" gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "LabFilterRequest",
        "code_value": "type LabFilterRequest struct {\n\tArea        *string `json:\"area,omitempty\"`\n\tDescription *string `json:\"description,omitempty\"`\n\tPage        int     `json:\"page\"`\n\tSize        int     `json:\"size\"`\n}"
      },
      {
        "code_key": "LabTestResponse",
        "code_value": "type LabTestResponse struct {\n\tResults     []LabTestResult `json:\"results\"`\n\tTotalCount  int             `json:\"total_count\"`\n\tCurrentPage int             `json:\"current_page\"`\n}"
      },
      {
        "code_key": "LabTestStatus",
        "code_value": "const (\n\tLabStatusPending   = 0\n\tLabStatusApproved = 1\n\tLabStatusRejected = 2\n)"
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "TrackLabResults",
    "orm_code": "func (l *Lab) TrackLabResults(filterParams map[string]interface{}, page, size int) ([]types.LabTestResult, error) {\n\tresults := make([]types.LabTestResult, 0)\n\tdb := base.GetInstance().LabDriver().Table(\"lab_test_results\")\n\n\tif area, exists := filterParams[\"Area\"]; exists {\n\t\t// Filter by area with exact match and sort by CreationTime\n\t\terr := db.Where(\"area = ?\", area).\n\t\t\tOrder(\"creation_time desc\").\n\t\t\tScopes(PaginateDB(page, size)).\n\t\t\tFind(&results).Error\n\t\treturn results, err\n\t} else if desc, exists := filterParams[\"Description\"]; exists {\n\t\t// Filter by description with partial match\n\t\terr := db.Where(\"description LIKE ?\", \"%\"+desc.(string)+\"%\").\n\t\t\tOrder(\"id\").\n\t\t\tScopes(PaginateDB(page, size)).\n\t\t\tFind(&results).Error\n\t\treturn results, err\n\t}\n\n\t// Default query without area or description filters\n\terr := db.Where(filterParams).\n\t\tOrder(\"id\").\n\t\tScopes(PaginateDB(page, size)).\n\t\tFind(&results).Error\n\treturn results, err\n}",
    "caller": "func (h *LabHandler) HandleTestResults(req *types.QueryLabResultsRequest) ([]types.LabTestResult, error) {\n\tfilterParams := make(map[string]interface{})\n\tif req.PatientID != \"\" {\n\t\tfilterParams[\"PatientID\"] = req.PatientID\n\t} else if req.TestCode != \"\" {\n\t\tfilterParams[\"TestCode\"] = req.TestCode\n\t} else if req.Status > 0 {\n\t\tif req.Status < 1 || req.Status > 3 {\n\t\t\treturn nil, fmt.Errorf(\"invalid status value\")\n\t\t}\n\t\tfilterParams[\"Status\"] = req.Status\n\t}\n\n\tlab := &Lab{}\n\tpage, size := utils.GetPaginationParams(req.Page, req.Size)\n\tresults, err := lab.TrackLabResults(filterParams, page, size)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to track lab results: %v\", err)\n\t}\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "传入PatientID参数",
            "sql": "SELECT id, area, description, result_value, creation_time, status FROM lab_test_results WHERE patient_id = ? ORDER BY id LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "传入TestCode参数",
            "sql": "SELECT id, area, description, result_value, creation_time, status FROM lab_test_results WHERE test_code = ? ORDER BY id LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "传入Status参数（有效值1-3）",
            "sql": "SELECT id, area, description, result_value, creation_time, status FROM lab_test_results WHERE status = ? ORDER BY id LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "传入Area参数",
            "sql": "SELECT id, area, description, result_value, creation_time, status FROM lab_test_results WHERE area = ? ORDER BY creation_time desc LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "传入Description参数",
            "sql": "SELECT id, area, description, result_value, creation_time, status FROM lab_test_results WHERE description LIKE ? ORDER BY id LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "LabTestResult",
        "code_value": "type LabTestResult struct {\n\tID           int       `json:\"id\" gorm:\"column:id\"`\n\tArea         string    `json:\"area\" gorm:\"column:area\"`\n\tDescription  string    `json:\"description\" gorm:\"column:description\"`\n\tResultValue  float64   `json:\"result_value\" gorm:\"column:result_value\"`\n\tCreationTime time.Time `json:\"creation_time\" gorm:\"column:creation_time\"`\n\tStatus       int       `json:\"status\" gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "LabFilterRequest",
        "code_value": "type LabFilterRequest struct {\n\tArea        *string `json:\"area,omitempty\"`\n\tDescription *string `json:\"description,omitempty\"`\n\tPage        int     `json:\"page\"`\n\tSize        int     `json:\"size\"`\n}"
      },
      {
        "code_key": "LabTestResponse",
        "code_value": "type LabTestResponse struct {\n\tResults     []LabTestResult `json:\"results\"`\n\tTotalCount  int             `json:\"total_count\"`\n\tCurrentPage int             `json:\"current_page\"`\n}"
      },
      {
        "code_key": "LabTestStatus",
        "code_value": "const (\n\tLabStatusPending   = 0\n\tLabStatusApproved = 1\n\tLabStatusRejected = 2\n)"
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "MergeRecords",
    "orm_code": "func (p *Paragraph) MergeRecords(filterParams map[string]interface{}, page, size int) ([]types.ResourceAllocation, error) {\n\tvar allocations []types.ResourceAllocation\n\tdb := base.GetInstance().GormDB().Table(\"resource_allocation\")\n\t\n\tif region, exists := filterParams[\"Region\"]; exists {\n\t\tif activationDate, ok := filterParams[\"ActivationDate\"]; ok {\n\t\t\tdb = db.Where(\"region = ? AND activation_date >= ?\", region, activationDate)\n\t\t} else {\n\t\t\tdb = db.Where(\"region LIKE ?\", \"%\"+region.(string)+\"%\")\n\t\t}\n\t} else if scheduledTime, exists := filterParams[\"ScheduledTime\"]; exists {\n\t\tdb = db.Where(\"scheduled_time BETWEEN ? AND ?\", \n\t\t\tscheduledTime.([]interface{})[0], \n\t\t\tscheduledTime.([]interface{})[1])\n\t}\n\t\n\terr := db.Scopes(PaginateDB(page, size)).Find(&allocations).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.RecordNotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn allocations, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "包含Region和ActivationDate参数",
            "sql": "SELECT id, region, activation_date, scheduled_time, resource_id, status, created_at, updated_at FROM resource_allocation WHERE region = ? AND activation_date >= ? LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "仅包含Region参数",
            "sql": "SELECT id, region, activation_date, scheduled_time, resource_id, status, created_at, updated_at FROM resource_allocation WHERE region LIKE ? LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "包含ScheduledTime参数",
            "sql": "SELECT id, region, activation_date, scheduled_time, resource_id, status, created_at, updated_at FROM resource_allocation WHERE scheduled_time BETWEEN ? AND ? LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "无过滤条件",
            "sql": "SELECT id, region, activation_date, scheduled_time, resource_id, status, created_at, updated_at FROM resource_allocation LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ResourceAllocation",
        "code_value": "type ResourceAllocation struct {\n\tID             int       `json:\"id\" gorm:\"column:id\"`\n\tRegion         string    `json:\"region\" gorm:\"column:region\"`\n\tActivationDate time.Time `json:\"activation_date\" gorm:\"column:activation_date\"`\n\tScheduledTime  time.Time `json:\"scheduled_time\" gorm:\"column:scheduled_time\"`\n\tResourceID     int       `json:\"resource_id\" gorm:\"column:resource_id\"`\n\tStatus         int       `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt      time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt      time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "AllocationFilter",
        "code_value": "type AllocationFilter struct {\n\tRegion         *string    `json:\"region\"`\n\tActivationDate *time.Time `json:\"activation_date\"`\n\tScheduledTime  [2]time.Time `json:\"scheduled_time\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "const TableName = \"resource_allocation\""
      },
      {
        "code_key": "AllocationStatus",
        "code_value": "const (\n\tAllocationPending = iota\n\tAllocationActive\n\tAllocationCompleted\n\tAllocationCancelled\n)"
      },
      {
        "code_key": "defaultPageSize",
        "code_value": "var defaultPageSize = 20"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "MergeRecords",
    "orm_code": "func (p *Paragraph) MergeRecords(filterParams map[string]interface{}, page, size int) ([]types.ResourceAllocation, error) {\n\tvar allocations []types.ResourceAllocation\n\tdb := base.GetInstance().GormDB().Table(\"resource_allocation\")\n\t\n\tif region, exists := filterParams[\"Region\"]; exists {\n\t\tif activationDate, ok := filterParams[\"ActivationDate\"]; ok {\n\t\t\tdb = db.Where(\"region = ? AND activation_date >= ?\", region, activationDate)\n\t\t} else {\n\t\t\tdb = db.Where(\"region LIKE ?\", \"%\"+region.(string)+\"%\")\n\t\t}\n\t} else if scheduledTime, exists := filterParams[\"ScheduledTime\"]; exists {\n\t\tdb = db.Where(\"scheduled_time BETWEEN ? AND ?\", \n\t\t\tscheduledTime.([]interface{})[0], \n\t\t\tscheduledTime.([]interface{})[1])\n\t}\n\t\n\terr := db.Scopes(PaginateDB(page, size)).Find(&allocations).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.RecordNotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn allocations, nil\n}",
    "caller": "func (p *ProjectHandler) HandleProjectAllocation(req *types.ProjectAllocationRequest, log *logger.ProjectLog) ([]types.ResourceAllocation, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.ProjectID != \"\" {\n\t\tfilter[\"Region\"] = \"region_\" + req.ProjectID[:3]\n\t} else if req.TimeRange != nil {\n\t\tif len(req.TimeRange) == 2 {\n\t\t\tfilter[\"ScheduledTime\"] = []interface{}{req.TimeRange[0], req.TimeRange[1]}\n\t\t} else {\n\t\t\treturn nil, utils.InvalidParamError\n\t\t}\n\t} else if req.Status != \"\" {\n\t\tfilter[\"ActivationDate\"] = time.Now().AddDate(0, 0, -7)\n\t} else {\n\t\treturn nil, utils.MissingParamError\n\t}\n\t\n\tpara := &Paragraph{}\n\tallocations, err := para.MergeRecords(filter, req.Page, req.Size)\n\tif err != nil {\n\t\tlog.ErrorV(fmt.Sprintf(\"[HandleProjectAllocation] MergeRecords failed: %v\", err), utils.OperationErr)\n\t\treturn nil, err\n\t}\n\t\n\treturn allocations, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "ProjectID不为空时，生成带region LIKE条件的SQL",
            "sql": "SELECT id, region, activation_date, scheduled_time, resource_id, status, created_at, updated_at FROM resource_allocation WHERE region LIKE '%region_XXX%' LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "TimeRange不为空且长度正确时，生成带scheduled_time BETWEEN条件的SQL",
            "sql": "SELECT id, region, activation_date, scheduled_time, resource_id, status, created_at, updated_at FROM resource_allocation WHERE scheduled_time BETWEEN '2023-01-01 00:00:00' AND '2023-01-31 23:59:59' LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "Status不为空时，生成带region等于和activation_date比较条件的SQL",
            "sql": "SELECT id, region, activation_date, scheduled_time, resource_id, status, created_at, updated_at FROM resource_allocation WHERE region = 'region_XXX' AND activation_date >= '2023-06-23 00:00:00' LIMIT 20 OFFSET 0;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ResourceAllocation",
        "code_value": "type ResourceAllocation struct {\n\tID             int       `json:\"id\" gorm:\"column:id\"`\n\tRegion         string    `json:\"region\" gorm:\"column:region\"`\n\tActivationDate time.Time `json:\"activation_date\" gorm:\"column:activation_date\"`\n\tScheduledTime  time.Time `json:\"scheduled_time\" gorm:\"column:scheduled_time\"`\n\tResourceID     int       `json:\"resource_id\" gorm:\"column:resource_id\"`\n\tStatus         int       `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt      time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt      time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "AllocationFilter",
        "code_value": "type AllocationFilter struct {\n\tRegion         *string    `json:\"region\"`\n\tActivationDate *time.Time `json:\"activation_date\"`\n\tScheduledTime  [2]time.Time `json:\"scheduled_time\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "const TableName = \"resource_allocation\""
      },
      {
        "code_key": "AllocationStatus",
        "code_value": "const (\n\tAllocationPending = iota\n\tAllocationActive\n\tAllocationCompleted\n\tAllocationCancelled\n)"
      },
      {
        "code_key": "defaultPageSize",
        "code_value": "var defaultPageSize = 20"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CleanupOldData",
    "orm_code": "func (p *Patient) CleanupOldData(filter map[string]interface{}) (int64, error) {\n    var count int64\n    db := base.GetInstance().MainDB().Table(\"surgery_schedules\")\n    \n    if lastAccess, exists := filter[\"LastAccessTime\"]; exists {\n        // Cleanup strategy 1: Delete records older than specified timestamp\n        result := db.Where(\"last_access_time < ?\", lastAccess).Delete(&Layout{})\n        if result.Error != nil {\n            return 0, result.Error\n        }\n        count = result.RowsAffected\n    } else if taskId, exists := filter[\"TaskId\"]; exists {\n        // Cleanup strategy 2: Delete records matching specific task ID pattern\n        result := db.Where(\"task_id LIKE ?\", \"%\"+taskId.(string)+\"%\").Delete(&Layout{})\n        if result.Error != nil {\n            return 0, result.Error\n        }\n        count = result.RowsAffected\n    } else {\n        // Default cleanup strategy\n        result := db.Where(filter).Delete(&Layout{})\n        if result.Error != nil {\n            return 0, result.Error\n        }\n        count = result.RowsAffected\n    }\n    \n    return count, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按LastAccessTime清理",
            "sql": "DELETE FROM surgery_schedules WHERE last_access_time < ?;"
          },
          {
            "scenario": "按TaskId模式清理",
            "sql": "DELETE FROM surgery_schedules WHERE task_id LIKE ?;"
          },
          {
            "scenario": "默认清理策略(使用filter中的条件)",
            "sql": "DELETE FROM surgery_schedules WHERE status = ?;"
          },
          {
            "scenario": "默认清理策略(使用filter中的多个条件)",
            "sql": "DELETE FROM surgery_schedules WHERE status = ? AND created_at < ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "SurgerySchedule",
        "code_value": "type SurgerySchedule struct {\n\tID             int64     `json:\"id\" gorm:\"column:id;primary_key\"`\n\tTaskID         string    `json:\"task_id\" gorm:\"column:task_id\"`\n\tLastAccessTime time.Time `json:\"last_access_time\" gorm:\"column:last_access_time\"`\n\tStatus         int       `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt      time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt      time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "CleanupRequest",
        "code_value": "type CleanupRequest struct {\n\tLastAccessTime *time.Time `json:\"last_access_time,omitempty\"`\n\tTaskID         *string    `json:\"task_id,omitempty\"`\n\tFilters        map[string]interface{} `json:\"filters,omitempty\"`\n}"
      },
      {
        "code_key": "CleanupResponse",
        "code_value": "type CleanupResponse struct {\n\tDeletedCount int64  `json:\"deleted_count\"`\n\tError        string `json:\"error,omitempty\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "const TableName = \"surgery_schedules\""
      },
      {
        "code_key": "CleanupStatus",
        "code_value": "const (\n\tCleanupPending = iota\n\tCleanupInProgress\n\tCleanupCompleted\n\tCleanupFailed\n)"
      },
      {
        "code_key": "DefaultCleanupWindow",
        "code_value": "var DefaultCleanupWindow = 30 * 24 * time.Hour"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CleanupOldData",
    "orm_code": "func (p *Patient) CleanupOldData(filter map[string]interface{}) (int64, error) {\n    var count int64\n    db := base.GetInstance().MainDB().Table(\"surgery_schedules\")\n    \n    if lastAccess, exists := filter[\"LastAccessTime\"]; exists {\n        // Cleanup strategy 1: Delete records older than specified timestamp\n        result := db.Where(\"last_access_time < ?\", lastAccess).Delete(&Layout{})\n        if result.Error != nil {\n            return 0, result.Error\n        }\n        count = result.RowsAffected\n    } else if taskId, exists := filter[\"TaskId\"]; exists {\n        // Cleanup strategy 2: Delete records matching specific task ID pattern\n        result := db.Where(\"task_id LIKE ?\", \"%\"+taskId.(string)+\"%\").Delete(&Layout{})\n        if result.Error != nil {\n            return 0, result.Error\n        }\n        count = result.RowsAffected\n    } else {\n        // Default cleanup strategy\n        result := db.Where(filter).Delete(&Layout{})\n        if result.Error != nil {\n            return 0, result.Error\n        }\n        count = result.RowsAffected\n    }\n    \n    return count, nil\n}",
    "caller": "func (h *PatientHandler) HandlePatientRecords(req *types.PatientRecordsRequest) (int64, error) {\n    if req == nil {\n        return 0, errors.New(\"request cannot be nil\")\n    }\n    \n    patient := &Patient{}\n    criteria := make(map[string]interface{})\n    \n    if req.ExpiredBefore > 0 {\n        criteria[\"LastAccessTime\"] = req.ExpiredBefore\n    } else if len(req.TreatmentCode) > 0 {\n        if !utils.IsValidTreatmentCode(req.TreatmentCode) {\n            return 0, errors.New(\"invalid treatment code format\")\n        }\n        criteria[\"TaskId\"] = req.TreatmentCode\n    } else if req.Status != \"\" {\n        if req.Status != \"active\" && req.Status != \"archived\" {\n            return 0, errors.New(\"invalid status value\")\n        }\n        criteria[\"status\"] = req.Status\n    } else {\n        criteria[\"department\"] = req.Department\n    }\n    \n    affected, err := patient.CleanupOldData(criteria)\n    if err != nil {\n        return 0, fmt.Errorf(\"failed to cleanup records: %v\", err)\n    }\n    \n    return affected, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "清理过期记录（LastAccessTime条件）",
            "sql": "DELETE FROM surgery_schedules WHERE last_access_time < ?;"
          },
          {
            "scenario": "清理特定治疗代码记录（TaskId条件）",
            "sql": "DELETE FROM surgery_schedules WHERE task_id LIKE ?;"
          },
          {
            "scenario": "清理特定状态记录（status条件）",
            "sql": "DELETE FROM surgery_schedules WHERE status = ?;"
          },
          {
            "scenario": "清理部门记录（department条件）",
            "sql": "DELETE FROM surgery_schedules WHERE department = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "SurgerySchedule",
        "code_value": "type SurgerySchedule struct {\n\tID             int64     `json:\"id\" gorm:\"column:id;primary_key\"`\n\tTaskID         string    `json:\"task_id\" gorm:\"column:task_id\"`\n\tLastAccessTime time.Time `json:\"last_access_time\" gorm:\"column:last_access_time\"`\n\tStatus         int       `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt      time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt      time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "CleanupRequest",
        "code_value": "type CleanupRequest struct {\n\tLastAccessTime *time.Time `json:\"last_access_time,omitempty\"`\n\tTaskID         *string    `json:\"task_id,omitempty\"`\n\tFilters        map[string]interface{} `json:\"filters,omitempty\"`\n}"
      },
      {
        "code_key": "CleanupResponse",
        "code_value": "type CleanupResponse struct {\n\tDeletedCount int64  `json:\"deleted_count\"`\n\tError        string `json:\"error,omitempty\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "const TableName = \"surgery_schedules\""
      },
      {
        "code_key": "CleanupStatus",
        "code_value": "const (\n\tCleanupPending = iota\n\tCleanupInProgress\n\tCleanupCompleted\n\tCleanupFailed\n)"
      },
      {
        "code_key": "DefaultCleanupWindow",
        "code_value": "var DefaultCleanupWindow = 30 * 24 * time.Hour"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "OptimizeRoutes",
    "orm_code": "func (e *Exchange) OptimizeRoutes(filterParams map[string]interface{}) ([]types.Tournament, error) {\n\tvar tournaments []types.Tournament\n\tdb := base.GetInstance().MainDB().Table(\"health_metrics\")\n\n\tif routeId, exists := filterParams[\"RouteId\"]; exists {\n\t\tdb = db.Where(\"route_id = ?\", routeId)\n\t\tif priority, hasPriority := filterParams[\"Priority\"]; hasPriority {\n\t\t\tdb = db.Where(\"priority > ?\", priority)\n\t\t}\n\t} else if location, hasLocation := filterParams[\"Location\"]; hasLocation {\n\t\tdb = db.Where(\"location LIKE ?\", \"%\"+location.(string)+\"%\")\n\t}\n\n\terr := db.Order(\"scheduled_time desc\").Find(&tournaments).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn tournaments, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Building parameter exists",
            "sql": "SELECT logistics_hubs.id, logistics_hubs.building, logistics_hubs.locale, logistics_hubs.distance, logistics_hubs.capacity, logistics_hubs.status, logistics_hubs.created_at, logistics_hubs.updated_at FROM logistics_hubs WHERE building = ? ORDER BY distance ASC;"
          },
          {
            "scenario": "Locale parameter exists (no Building)",
            "sql": "SELECT logistics_hubs.id, logistics_hubs.building, logistics_hubs.locale, logistics_hubs.distance, logistics_hubs.capacity, logistics_hubs.status, logistics_hubs.created_at, logistics_hubs.updated_at FROM logistics_hubs WHERE locale LIKE ? ORDER BY capacity DESC;"
          },
          {
            "scenario": "RequestId parameter exists (no Building or Locale)",
            "sql": "SELECT logistics_hubs.id, logistics_hubs.building, logistics_hubs.locale, logistics_hubs.distance, logistics_hubs.capacity, logistics_hubs.status, logistics_hubs.created_at, logistics_hubs.updated_at FROM logistics_hubs JOIN return_requests ON logistics_hubs.id = return_requests.hub_id WHERE return_requests.request_id = ? ORDER BY return_requests.created_at DESC;"
          },
          {
            "scenario": "No specific parameters",
            "sql": "SELECT logistics_hubs.id, logistics_hubs.building, logistics_hubs.locale, logistics_hubs.distance, logistics_hubs.capacity, logistics_hubs.status, logistics_hubs.created_at, logistics_hubs.updated_at FROM logistics_hubs WHERE status = 'active' ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "Tournament",
        "code_value": "type Tournament struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tRouteID       string    `json:\"route_id\" gorm:\"column:route_id\"`\n\tPriority      int       `json:\"priority\" gorm:\"column:priority\"`\n\tLocation      string    `json:\"location\" gorm:\"column:location\"`\n\tScheduledTime time.Time `json:\"scheduled_time\" gorm:\"column:scheduled_time\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "RouteFilterParams",
        "code_value": "type RouteFilterParams struct {\n\tRouteId  string\n\tPriority int\n\tLocation string\n}"
      },
      {
        "code_key": "TableNameTournament",
        "code_value": "const TableNameTournament = \"health_metrics\""
      },
      {
        "code_key": "TournamentStatus",
        "code_value": "const (\n\tTournamentPending   = \"pending\"\n\tTournamentActive    = \"active\"\n\tTournamentCompleted = \"completed\"\n)"
      },
      {
        "code_key": "DefaultPriority",
        "code_value": "const DefaultPriority = 5"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "OptimizeRoutes",
    "orm_code": "func (e *Exchange) OptimizeRoutes(filterParams map[string]interface{}) ([]types.Tournament, error) {\n\tvar tournaments []types.Tournament\n\tdb := base.GetInstance().MainDB().Table(\"health_metrics\")\n\n\tif routeId, exists := filterParams[\"RouteId\"]; exists {\n\t\tdb = db.Where(\"route_id = ?\", routeId)\n\t\tif priority, hasPriority := filterParams[\"Priority\"]; hasPriority {\n\t\t\tdb = db.Where(\"priority > ?\", priority)\n\t\t}\n\t} else if location, hasLocation := filterParams[\"Location\"]; hasLocation {\n\t\tdb = db.Where(\"location LIKE ?\", \"%\"+location.(string)+\"%\")\n\t}\n\n\terr := db.Order(\"scheduled_time desc\").Find(&tournaments).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn tournaments, nil\n}",
    "caller": "func (h *TournamentHandler) HandleTournamentSearch(req *types.TournamentSearchRequest) ([]types.Tournament, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.RouteID != \"\" {\n\t\tfilter[\"RouteId\"] = req.RouteID\n\t\tif req.MinPriority > 0 {\n\t\t\tfilter[\"Priority\"] = req.MinPriority\n\t\t}\n\t} else if req.Location != \"\" {\n\t\tif len(req.Location) < 3 {\n\t\t\treturn nil, errors.New(\"location query too short\")\n\t\t}\n\t\tfilter[\"Location\"] = req.Location\n\t} else if req.Status != 0 {\n\t\tfilter[\"Status\"] = req.Status\n\t} else {\n\t\treturn nil, errors.New(\"no valid search criteria provided\")\n\t}\n\n\texchange := &Exchange{}\n\tresults, err := exchange.OptimizeRoutes(filter)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to optimize routes: %v\", err)\n\t}\n\t\n\tif len(results) == 0 {\n\t\treturn nil, errors.New(\"no tournaments found matching criteria\")\n\t}\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "提供RouteID和MinPriority",
            "sql": "SELECT id, route_id, priority, location, scheduled_time, status FROM health_metrics WHERE route_id = ? AND priority > ? ORDER BY scheduled_time DESC;"
          },
          {
            "scenario": "仅提供RouteID",
            "sql": "SELECT id, route_id, priority, location, scheduled_time, status FROM health_metrics WHERE route_id = ? ORDER BY scheduled_time DESC;"
          },
          {
            "scenario": "提供Location且长度≥3",
            "sql": "SELECT id, route_id, priority, location, scheduled_time, status FROM health_metrics WHERE location LIKE ? ORDER BY scheduled_time DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Tournament",
        "code_value": "type Tournament struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tRouteID       string    `json:\"route_id\" gorm:\"column:route_id\"`\n\tPriority      int       `json:\"priority\" gorm:\"column:priority\"`\n\tLocation      string    `json:\"location\" gorm:\"column:location\"`\n\tScheduledTime time.Time `json:\"scheduled_time\" gorm:\"column:scheduled_time\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "RouteFilterParams",
        "code_value": "type RouteFilterParams struct {\n\tRouteId  string\n\tPriority int\n\tLocation string\n}"
      },
      {
        "code_key": "TableNameTournament",
        "code_value": "const TableNameTournament = \"health_metrics\""
      },
      {
        "code_key": "TournamentStatus",
        "code_value": "const (\n\tTournamentPending   = \"pending\"\n\tTournamentActive    = \"active\"\n\tTournamentCompleted = \"completed\"\n)"
      },
      {
        "code_key": "DefaultPriority",
        "code_value": "const DefaultPriority = 5"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "OptimizeRoutes",
    "orm_code": "func (e *Exchange) OptimizeRoutes(filterParams map[string]interface{}) ([]types.Tournament, error) {\n\tvar tournaments []types.Tournament\n\tdb := base.GetInstance().MainDB().Table(\"health_metrics\")\n\n\tif routeId, exists := filterParams[\"RouteId\"]; exists {\n\t\tdb = db.Where(\"route_id = ?\", routeId)\n\t\tif priority, hasPriority := filterParams[\"Priority\"]; hasPriority {\n\t\t\tdb = db.Where(\"priority > ?\", priority)\n\t\t}\n\t} else if location, hasLocation := filterParams[\"Location\"]; hasLocation {\n\t\tdb = db.Where(\"location LIKE ?\", \"%\"+location.(string)+\"%\")\n\t}\n\n\terr := db.Order(\"scheduled_time desc\").Find(&tournaments).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn tournaments, nil\n}",
    "caller": "func (s *RouteService) HandleRouteOptimization(req *types.RouteRequest) ([]types.RouteOptimization, error) {\n\tif req == nil {\n\t\treturn nil, fmt.Errorf(\"invalid request parameters\")\n\t}\n\n\tfilterCriteria := make(map[string]interface{})\n\n\tswitch {\n\tcase req.BuildingID != \"\":\n\t\tfilterCriteria[\"Building\"] = req.BuildingID\n\tcase req.LocaleQuery != \"\":\n\t\tfilterCriteria[\"Locale\"] = req.LocaleQuery\n\tcase req.ReturnRequestID != \"\":\n\t\tfilterCriteria[\"RequestId\"] = req.ReturnRequestID\n\t}\n\n\troutePlanner := &Teacher{}\n\toptimizedRoutes, err := routePlanner.OptimizeRoutes(filterCriteria)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to optimize routes: %v\", err)\n\t}\n\n\tif len(optimizedRoutes) == 0 {\n\t\treturn nil, fmt.Errorf(\"no routes available for given criteria\")\n\t}\n\n\treturn optimizedRoutes, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "BuildingID filter is provided",
            "sql": "SELECT logistics_hubs.id, logistics_hubs.building, logistics_hubs.locale, logistics_hubs.distance, logistics_hubs.capacity, logistics_hubs.status, logistics_hubs.created_at, logistics_hubs.updated_at FROM logistics_hubs WHERE building = ? ORDER BY distance ASC;"
          },
          {
            "scenario": "LocaleQuery filter is provided",
            "sql": "SELECT logistics_hubs.id, logistics_hubs.building, logistics_hubs.locale, logistics_hubs.distance, logistics_hubs.capacity, logistics_hubs.status, logistics_hubs.created_at, logistics_hubs.updated_at FROM logistics_hubs WHERE locale LIKE ? ORDER BY capacity DESC;"
          },
          {
            "scenario": "ReturnRequestID filter is provided",
            "sql": "SELECT logistics_hubs.id, logistics_hubs.building, logistics_hubs.locale, logistics_hubs.distance, logistics_hubs.capacity, logistics_hubs.status, logistics_hubs.created_at, logistics_hubs.updated_at FROM logistics_hubs JOIN return_requests ON logistics_hubs.id = return_requests.hub_id WHERE return_requests.request_id = ? ORDER BY return_requests.created_at DESC;"
          },
          {
            "scenario": "No filter is provided (default case)",
            "sql": "SELECT logistics_hubs.id, logistics_hubs.building, logistics_hubs.locale, logistics_hubs.distance, logistics_hubs.capacity, logistics_hubs.status, logistics_hubs.created_at, logistics_hubs.updated_at FROM logistics_hubs WHERE status = ? ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "Tournament",
        "code_value": "type Tournament struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tRouteID       string    `json:\"route_id\" gorm:\"column:route_id\"`\n\tPriority      int       `json:\"priority\" gorm:\"column:priority\"`\n\tLocation      string    `json:\"location\" gorm:\"column:location\"`\n\tScheduledTime time.Time `json:\"scheduled_time\" gorm:\"column:scheduled_time\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "RouteFilterParams",
        "code_value": "type RouteFilterParams struct {\n\tRouteId  string\n\tPriority int\n\tLocation string\n}"
      },
      {
        "code_key": "TableNameTournament",
        "code_value": "const TableNameTournament = \"health_metrics\""
      },
      {
        "code_key": "TournamentStatus",
        "code_value": "const (\n\tTournamentPending   = \"pending\"\n\tTournamentActive    = \"active\"\n\tTournamentCompleted = \"completed\"\n)"
      },
      {
        "code_key": "DefaultPriority",
        "code_value": "const DefaultPriority = 5"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "FetchWithFilter",
    "orm_code": "func (a *Author) FetchWithFilter(filter map[string]interface{}, page, limit int) ([]types.AuthorProfile, error) {\n\tvar profiles []types.AuthorProfile\n\tdb := base.GetInstance().GormDB().Table(\"trending_topics\")\n\n\tif activationDate, ok := filter[\"ActivationDate\"]; ok {\n\t\tdb = db.Where(\"activation_date > ?\", activationDate)\n\t\tdelete(filter, \"ActivationDate\")\n\t}\n\n\tif subCategory, ok := filter[\"SubCategory\"]; ok {\n\t\tdb = db.Where(\"sub_category LIKE ?\", \"%\"+subCategory.(string)+\"%\")\n\t\tdelete(filter, \"SubCategory\")\n\t} else {\n\t\tdb = db.Where(filter)\n\t}\n\n\terr := db.Scopes(PaginateDB(page, limit)).Order(\"created_at DESC\").Find(&profiles).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.RecordNotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn profiles, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Locale and Balance parameters present",
            "sql": "SELECT id, locale, balance, timezone, score, created_at, updated_at FROM training_modules WHERE locale = ? AND balance > ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "Locale parameter present without Balance",
            "sql": "SELECT id, locale, balance, timezone, score, created_at, updated_at FROM training_modules WHERE locale = ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "Timezone parameter present",
            "sql": "SELECT id, locale, balance, timezone, score, created_at, updated_at FROM training_modules WHERE timezone LIKE ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "MinScore parameter present",
            "sql": "SELECT id, locale, balance, timezone, score, created_at, updated_at FROM training_modules WHERE score >= ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "Direct filterParams map conditions",
            "sql": "SELECT id, locale, balance, timezone, score, created_at, updated_at FROM training_modules WHERE score = ? AND timezone = ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "No filter conditions",
            "sql": "SELECT id, locale, balance, timezone, score, created_at, updated_at FROM training_modules ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "AuthorProfile",
        "code_value": "type AuthorProfile struct {\n\tID             int       `json:\"id\" gorm:\"column:id\"`\n\tName           string    `json:\"name\" gorm:\"column:name\"`\n\tActivationDate time.Time `json:\"activation_date\" gorm:\"column:activation_date\"`\n\tSubCategory    string    `json:\"sub_category\" gorm:\"column:sub_category\"`\n\tCreatedAt      time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt      time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "FilterConstants",
        "code_value": "const (\n\tDefaultPageSize = 20\n\tMaxPageSize     = 100\n)"
      },
      {
        "code_key": "TableNames",
        "code_value": "var TableNames = struct {\n\tTrendingTopics string\n}{\n\tTrendingTopics: \"trending_topics\",\n}"
      },
      {
        "code_key": "QueryResult",
        "code_value": "type QueryResult struct {\n\tTotal   int              `json:\"total\"`\n\tPage    int              `json:\"page\"`\n\tLimit   int              `json:\"limit\"`\n\tResults []AuthorProfile `json:\"results\"`\n}"
      },
      {
        "code_key": "ErrorMessages",
        "code_value": "var ErrorMessages = struct {\n\tRecordNotFound string\n}{\n\tRecordNotFound: \"record not found\",\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "FetchWithFilter",
    "orm_code": "func (a *Author) FetchWithFilter(filter map[string]interface{}, page, limit int) ([]types.AuthorProfile, error) {\n\tvar profiles []types.AuthorProfile\n\tdb := base.GetInstance().GormDB().Table(\"trending_topics\")\n\n\tif activationDate, ok := filter[\"ActivationDate\"]; ok {\n\t\tdb = db.Where(\"activation_date > ?\", activationDate)\n\t\tdelete(filter, \"ActivationDate\")\n\t}\n\n\tif subCategory, ok := filter[\"SubCategory\"]; ok {\n\t\tdb = db.Where(\"sub_category LIKE ?\", \"%\"+subCategory.(string)+\"%\")\n\t\tdelete(filter, \"SubCategory\")\n\t} else {\n\t\tdb = db.Where(filter)\n\t}\n\n\terr := db.Scopes(PaginateDB(page, limit)).Order(\"created_at DESC\").Find(&profiles).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.RecordNotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn profiles, nil\n}",
    "caller": "func HandleTrendingAuthors(req *types.TrendingAuthorsRequest, log *logger.AppLog) ([]types.AuthorProfile, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.MinFollowers > 0 {\n\t\tfilter[\"follower_count\"] = fmt.Sprintf(\">%d\", req.MinFollowers)\n\t} else if len(req.Category) > 0 {\n\t\tif err := validateCategory(req.Category); err != nil {\n\t\t\tlog.Error(\"Invalid category\", \"error\", err)\n\t\t\treturn nil, err\n\t\t}\n\t\tfilter[\"SubCategory\"] = req.Category\n\t} else if !req.LastActive.IsZero() {\n\t\tfilter[\"ActivationDate\"] = req.LastActive\n\t} else {\n\t\tfilter[\"is_verified\"] = true\n\t}\n\n\tauthor := &Author{}\n\tprofiles, err := author.FetchWithFilter(filter, req.Page, req.PageSize)\n\tif err != nil {\n\t\tlog.Error(\"Failed to fetch authors\", \"error\", err)\n\t\treturn nil, err\n\t}\n\n\tif len(profiles) == 0 {\n\t\tlog.Warn(\"No matching authors found\", \"filter\", filter)\n\t}\n\treturn profiles, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "有MinFollowers条件",
            "sql": "SELECT id, name, activation_date, sub_category, created_at, updated_at FROM trending_topics WHERE follower_count > ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "有Category条件",
            "sql": "SELECT id, name, activation_date, sub_category, created_at, updated_at FROM trending_topics WHERE sub_category LIKE ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "有LastActive条件",
            "sql": "SELECT id, name, activation_date, sub_category, created_at, updated_at FROM trending_topics WHERE activation_date > ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "默认条件(is_verified=true)",
            "sql": "SELECT id, name, activation_date, sub_category, created_at, updated_at FROM trending_topics WHERE is_verified = ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "AuthorProfile",
        "code_value": "type AuthorProfile struct {\n\tID             int       `json:\"id\" gorm:\"column:id\"`\n\tName           string    `json:\"name\" gorm:\"column:name\"`\n\tActivationDate time.Time `json:\"activation_date\" gorm:\"column:activation_date\"`\n\tSubCategory    string    `json:\"sub_category\" gorm:\"column:sub_category\"`\n\tCreatedAt      time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt      time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "FilterConstants",
        "code_value": "const (\n\tDefaultPageSize = 20\n\tMaxPageSize     = 100\n)"
      },
      {
        "code_key": "TableNames",
        "code_value": "var TableNames = struct {\n\tTrendingTopics string\n}{\n\tTrendingTopics: \"trending_topics\",\n}"
      },
      {
        "code_key": "QueryResult",
        "code_value": "type QueryResult struct {\n\tTotal   int              `json:\"total\"`\n\tPage    int              `json:\"page\"`\n\tLimit   int              `json:\"limit\"`\n\tResults []AuthorProfile `json:\"results\"`\n}"
      },
      {
        "code_key": "ErrorMessages",
        "code_value": "var ErrorMessages = struct {\n\tRecordNotFound string\n}{\n\tRecordNotFound: \"record not found\",\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "FetchWithFilter",
    "orm_code": "func (a *Author) FetchWithFilter(filter map[string]interface{}, page, limit int) ([]types.AuthorProfile, error) {\n\tvar profiles []types.AuthorProfile\n\tdb := base.GetInstance().GormDB().Table(\"trending_topics\")\n\n\tif activationDate, ok := filter[\"ActivationDate\"]; ok {\n\t\tdb = db.Where(\"activation_date > ?\", activationDate)\n\t\tdelete(filter, \"ActivationDate\")\n\t}\n\n\tif subCategory, ok := filter[\"SubCategory\"]; ok {\n\t\tdb = db.Where(\"sub_category LIKE ?\", \"%\"+subCategory.(string)+\"%\")\n\t\tdelete(filter, \"SubCategory\")\n\t} else {\n\t\tdb = db.Where(filter)\n\t}\n\n\terr := db.Scopes(PaginateDB(page, limit)).Order(\"created_at DESC\").Find(&profiles).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.RecordNotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn profiles, nil\n}",
    "caller": "func (h *GameHandler) HandleGameRecords(req *types.GameRecordsRequest) ([]types.GameRecord, error) {\n\tif req.Page <= 0 || req.Limit <= 0 {\n\t\treturn nil, errors.New(\"invalid pagination parameters\")\n\t}\n\n\tfilters := make(map[string]interface{})\n\tif req.Locale != \"\" {\n\t\tfilters[\"Locale\"] = req.Locale\n\t\tif req.Balance > 0 {\n\t\t\tfilters[\"Balance\"] = req.Balance\n\t\t}\n\t} else if req.Timezone != \"\" {\n\t\tfilters[\"Timezone\"] = req.Timezone\n\t} else if req.MinScore > 0 {\n\t\tfilters[\"MinScore\"] = req.MinScore\n\t} else {\n\t\tfilters[\"status\"] = \"active\"\n\t}\n\n\tgameService := &Game{}\n\trecords, err := gameService.FetchWithFilter(filters, req.Page, req.Limit)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to fetch game records: %v\", err)\n\t}\n\n\treturn records, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Locale and Balance filters are provided",
            "sql": "SELECT id, locale, balance, timezone, score, created_at, updated_at FROM training_modules WHERE locale = ? AND balance > ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "Only Locale filter is provided",
            "sql": "SELECT id, locale, balance, timezone, score, created_at, updated_at FROM training_modules WHERE locale = ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "Timezone filter is provided",
            "sql": "SELECT id, locale, balance, timezone, score, created_at, updated_at FROM training_modules WHERE timezone LIKE ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "MinScore filter is provided",
            "sql": "SELECT id, locale, balance, timezone, score, created_at, updated_at FROM training_modules WHERE score >= ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "Default case with status filter",
            "sql": "SELECT id, locale, balance, timezone, score, created_at, updated_at FROM training_modules WHERE status = ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "AuthorProfile",
        "code_value": "type AuthorProfile struct {\n\tID             int       `json:\"id\" gorm:\"column:id\"`\n\tName           string    `json:\"name\" gorm:\"column:name\"`\n\tActivationDate time.Time `json:\"activation_date\" gorm:\"column:activation_date\"`\n\tSubCategory    string    `json:\"sub_category\" gorm:\"column:sub_category\"`\n\tCreatedAt      time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt      time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "FilterConstants",
        "code_value": "const (\n\tDefaultPageSize = 20\n\tMaxPageSize     = 100\n)"
      },
      {
        "code_key": "TableNames",
        "code_value": "var TableNames = struct {\n\tTrendingTopics string\n}{\n\tTrendingTopics: \"trending_topics\",\n}"
      },
      {
        "code_key": "QueryResult",
        "code_value": "type QueryResult struct {\n\tTotal   int              `json:\"total\"`\n\tPage    int              `json:\"page\"`\n\tLimit   int              `json:\"limit\"`\n\tResults []AuthorProfile `json:\"results\"`\n}"
      },
      {
        "code_key": "ErrorMessages",
        "code_value": "var ErrorMessages = struct {\n\tRecordNotFound string\n}{\n\tRecordNotFound: \"record not found\",\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "GroupByCategory",
    "orm_code": "func (m *Marketplace) GroupByCategory(filterParams map[string]interface{}, limit int) ([]types.BudgetPlan, error) {\n\tvar plans []types.BudgetPlan\n\tdb := base.GetInstance().MarketplaceDriver().Table(\"budget_planning\")\n\n\tif territory, ok := filterParams[\"Territory\"]; ok {\n\t\tdb = db.Where(\"Territory = ?\", territory).Order(\"created_at DESC\")\n\t} else if refCode, ok := filterParams[\"ReferenceCode\"]; ok {\n\t\tdb = db.Where(\"reference_code LIKE ?\", \"%\"+refCode.(string)+\"%\").Order(\"amount ASC\")\n\t}\n\n\terr := db.Limit(limit).Find(&plans).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn plans, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "filterParams包含category参数",
            "sql": "SELECT id, category, priority_rank, area, floor, created_at, updated_at FROM media_library WHERE category = ? ORDER BY floor DESC LIMIT ?;"
          },
          {
            "scenario": "filterParams包含priority参数",
            "sql": "SELECT id, category, priority_rank, area, floor, created_at, updated_at FROM media_library WHERE priority_rank > ? ORDER BY floor DESC LIMIT ?;"
          },
          {
            "scenario": "filterParams包含area参数",
            "sql": "SELECT id, category, priority_rank, area, floor, created_at, updated_at FROM media_library WHERE area LIKE ? ORDER BY floor DESC LIMIT ?;"
          },
          {
            "scenario": "filterParams包含其他参数或不包含上述特定参数",
            "sql": "SELECT id, category, priority_rank, area, floor, created_at, updated_at FROM media_library WHERE floor = ? ORDER BY floor DESC LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "BudgetPlan",
        "code_value": "type BudgetPlan struct {\n\tID            int       `gorm:\"column:id;primaryKey\"`\n\tTerritory     string    `gorm:\"column:territory\"`\n\tReferenceCode string    `gorm:\"column:reference_code\"`\n\tAmount        float64   `gorm:\"column:amount\"`\n\tCreatedAt     time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "FilterParams",
        "code_value": "type FilterParams struct {\n\tTerritory     string\n\tReferenceCode string\n}"
      },
      {
        "code_key": "BudgetTable",
        "code_value": "const BudgetTable = \"budget_planning\""
      },
      {
        "code_key": "DefaultLimit",
        "code_value": "const DefaultLimit = 100"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "GroupByCategory",
    "orm_code": "func (m *Marketplace) GroupByCategory(filterParams map[string]interface{}, limit int) ([]types.BudgetPlan, error) {\n\tvar plans []types.BudgetPlan\n\tdb := base.GetInstance().MarketplaceDriver().Table(\"budget_planning\")\n\n\tif territory, ok := filterParams[\"Territory\"]; ok {\n\t\tdb = db.Where(\"Territory = ?\", territory).Order(\"created_at DESC\")\n\t} else if refCode, ok := filterParams[\"ReferenceCode\"]; ok {\n\t\tdb = db.Where(\"reference_code LIKE ?\", \"%\"+refCode.(string)+\"%\").Order(\"amount ASC\")\n\t}\n\n\terr := db.Limit(limit).Find(&plans).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn plans, nil\n}",
    "caller": "func (p *ProductManager) HandleProductCatalog(req *types.ProductCatalogRequest) ([]types.BudgetPlan, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.CategoryID > 0 {\n\t\tfilter[\"Territory\"] = req.CategoryID\n\t} else if len(req.ProductCode) > 0 {\n\t\tif len(req.ProductCode) < 4 {\n\t\t\treturn nil, fmt.Errorf(\"product code must be at least 4 characters\")\n\t\t}\n\t\tfilter[\"ReferenceCode\"] = req.ProductCode\n\t} else if req.PriceRange != nil {\n\t\tif req.PriceRange.Min >= req.PriceRange.Max {\n\t\t\treturn nil, fmt.Errorf(\"invalid price range\")\n\t\t}\n\t\tfilter[\"Status\"] = \"active\"\n\t}\n\n\tmarketplace := &Marketplace{}\n\treturn marketplace.GroupByCategory(filter, req.PageSize)\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "CategoryID > 0",
            "sql": "SELECT id, territory, reference_code, amount, created_at, updated_at FROM budget_planning WHERE territory = ? ORDER BY created_at DESC LIMIT ?;"
          },
          {
            "scenario": "ProductCode provided (length ≥ 4)",
            "sql": "SELECT id, territory, reference_code, amount, created_at, updated_at FROM budget_planning WHERE reference_code LIKE ? ORDER BY amount ASC LIMIT ?;"
          },
          {
            "scenario": "PriceRange provided (with status condition not handled)",
            "sql": "SELECT id, territory, reference_code, amount, created_at, updated_at FROM budget_planning LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "BudgetPlan",
        "code_value": "type BudgetPlan struct {\n\tID            int       `gorm:\"column:id;primaryKey\"`\n\tTerritory     string    `gorm:\"column:territory\"`\n\tReferenceCode string    `gorm:\"column:reference_code\"`\n\tAmount        float64   `gorm:\"column:amount\"`\n\tCreatedAt     time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "FilterParams",
        "code_value": "type FilterParams struct {\n\tTerritory     string\n\tReferenceCode string\n}"
      },
      {
        "code_key": "BudgetTable",
        "code_value": "const BudgetTable = \"budget_planning\""
      },
      {
        "code_key": "DefaultLimit",
        "code_value": "const DefaultLimit = 100"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "GroupByCategory",
    "orm_code": "func (m *Marketplace) GroupByCategory(filterParams map[string]interface{}, limit int) ([]types.BudgetPlan, error) {\n\tvar plans []types.BudgetPlan\n\tdb := base.GetInstance().MarketplaceDriver().Table(\"budget_planning\")\n\n\tif territory, ok := filterParams[\"Territory\"]; ok {\n\t\tdb = db.Where(\"Territory = ?\", territory).Order(\"created_at DESC\")\n\t} else if refCode, ok := filterParams[\"ReferenceCode\"]; ok {\n\t\tdb = db.Where(\"reference_code LIKE ?\", \"%\"+refCode.(string)+\"%\").Order(\"amount ASC\")\n\t}\n\n\terr := db.Limit(limit).Find(&plans).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn plans, nil\n}",
    "caller": "func (s *MediaService) HandleMediaLibrary(req *types.QueryMediaRequest) ([]types.MediaGroup, error) {\n\tif req.PageSize <= 0 {\n\t\treturn nil, fmt.Errorf(\"invalid page size\")\n\t}\n\n\tfilter := make(map[string]interface{})\n\tif req.Category != \"\" {\n\t\tfilter[\"category\"] = req.Category\n\t} else if req.Priority > 0 {\n\t\tfilter[\"priority\"] = req.Priority\n\t} else if req.Area != \"\" {\n\t\tfilter[\"area\"] = req.Area\n\t} else {\n\t\tfilter[\"status\"] = \"active\"\n\t}\n\n\tmediaModule := &Module{}\n\tresults, err := mediaModule.GroupByCategory(filter, req.PageSize)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"query failed: %v\", err)\n\t}\n\n\tif len(results) == 0 {\n\t\treturn nil, fmt.Errorf(\"no matching records\")\n\t}\n\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "有category参数",
            "sql": "SELECT id, category, priority_rank, area, floor, created_at, updated_at FROM media_library WHERE category = ? ORDER BY floor DESC LIMIT ?;"
          },
          {
            "scenario": "无category但有priority参数",
            "sql": "SELECT id, category, priority_rank, area, floor, created_at, updated_at FROM media_library WHERE priority_rank > ? ORDER BY floor DESC LIMIT ?;"
          },
          {
            "scenario": "无category和priority但有area参数",
            "sql": "SELECT id, category, priority_rank, area, floor, created_at, updated_at FROM media_library WHERE area LIKE ? ORDER BY floor DESC LIMIT ?;"
          },
          {
            "scenario": "所有参数都为空（使用默认条件）",
            "sql": "SELECT id, category, priority_rank, area, floor, created_at, updated_at FROM media_library WHERE status = ? ORDER BY floor DESC LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "BudgetPlan",
        "code_value": "type BudgetPlan struct {\n\tID            int       `gorm:\"column:id;primaryKey\"`\n\tTerritory     string    `gorm:\"column:territory\"`\n\tReferenceCode string    `gorm:\"column:reference_code\"`\n\tAmount        float64   `gorm:\"column:amount\"`\n\tCreatedAt     time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "FilterParams",
        "code_value": "type FilterParams struct {\n\tTerritory     string\n\tReferenceCode string\n}"
      },
      {
        "code_key": "BudgetTable",
        "code_value": "const BudgetTable = \"budget_planning\""
      },
      {
        "code_key": "DefaultLimit",
        "code_value": "const DefaultLimit = 100"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "MonitorHealth",
    "orm_code": "func (c *Coupon) MonitorHealth(filterParams map[string]interface{}) ([]types.DoctorProfile, error) {\n\tvar profiles []types.DoctorProfile\n\tdb := base.GetInstance().HealthDriver().Table(\"doctor_profiles\")\n\n\tif status, exists := filterParams[\"Status\"]; exists {\n\t\tif lastAccess, hasAccess := filterParams[\"LastAccessTime\"]; hasAccess {\n\t\t\tdb = db.Where(\"status = ? AND last_access_time > ?\", status, lastAccess)\n\t\t} else {\n\t\t\tdb = db.Where(\"status = ?\", status)\n\t\t}\n\t} else if category, hasCategory := filterParams[\"SubCategory\"]; hasCategory {\n\t\tdb = db.Where(\"sub_category LIKE ?\", \"%\"+category.(string)+\"%\")\n\t} else {\n\t\treturn nil, errors.New(\"invalid filter parameters\")\n\t}\n\n\tif err := db.Find(&profiles).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn profiles, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按patient_id查询",
            "sql": "SELECT id, patient_id, vaccine_type, injection_date, dose_number, clinic_name, created_at, updated_at FROM vaccination_records WHERE patient_id = ? LIMIT ?;"
          },
          {
            "scenario": "按vaccine_type模糊查询",
            "sql": "SELECT id, patient_id, vaccine_type, injection_date, dose_number, clinic_name, created_at, updated_at FROM vaccination_records WHERE vaccine_type LIKE ? ORDER BY injection_date DESC LIMIT ?;"
          },
          {
            "scenario": "按date_range范围查询",
            "sql": "SELECT id, patient_id, vaccine_type, injection_date, dose_number, clinic_name, created_at, updated_at FROM vaccination_records WHERE injection_date BETWEEN ? AND ? LIMIT ?;"
          },
          {
            "scenario": "无过滤条件查询所有记录",
            "sql": "SELECT id, patient_id, vaccine_type, injection_date, dose_number, clinic_name, created_at, updated_at FROM vaccination_records LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "DoctorProfile",
        "code_value": "type DoctorProfile struct {\n\tID              int       `json:\"id\" gorm:\"column:id\"`\n\tName            string    `json:\"name\" gorm:\"column:name\"`\n\tSpecialization  string    `json:\"specialization\" gorm:\"column:specialization\"`\n\tStatus          string    `json:\"status\" gorm:\"column:status\"`\n\tLastAccessTime  time.Time `json:\"last_access_time\" gorm:\"column:last_access_time\"`\n\tSubCategory     string    `json:\"sub_category\" gorm:\"column:sub_category\"`\n\tCreatedAt       time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt       time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "HealthStatus",
        "code_value": "const (\n\tActiveStatus   = \"active\"\n\tInactiveStatus = \"inactive\"\n\tPendingStatus  = \"pending\"\n)"
      },
      {
        "code_key": "DoctorFilter",
        "code_value": "type DoctorFilter struct {\n\tStatus         *string\n\tLastAccessTime *time.Time\n\tSubCategory    *string\n}"
      },
      {
        "code_key": "TableNameDoctor",
        "code_value": "const TableNameDoctor = \"doctor_profiles\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "MonitorHealth",
    "orm_code": "func (c *Coupon) MonitorHealth(filterParams map[string]interface{}) ([]types.DoctorProfile, error) {\n\tvar profiles []types.DoctorProfile\n\tdb := base.GetInstance().HealthDriver().Table(\"doctor_profiles\")\n\n\tif status, exists := filterParams[\"Status\"]; exists {\n\t\tif lastAccess, hasAccess := filterParams[\"LastAccessTime\"]; hasAccess {\n\t\t\tdb = db.Where(\"status = ? AND last_access_time > ?\", status, lastAccess)\n\t\t} else {\n\t\t\tdb = db.Where(\"status = ?\", status)\n\t\t}\n\t} else if category, hasCategory := filterParams[\"SubCategory\"]; hasCategory {\n\t\tdb = db.Where(\"sub_category LIKE ?\", \"%\"+category.(string)+\"%\")\n\t} else {\n\t\treturn nil, errors.New(\"invalid filter parameters\")\n\t}\n\n\tif err := db.Find(&profiles).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn profiles, nil\n}",
    "caller": "func (s *SearchService) HandleDoctorProfileSearch(searchReq *types.DoctorSearchRequest, logger *log.Logger) ([]types.DoctorProfile, error) {\n\tfilterCriteria := make(map[string]interface{})\n\t\n\tif searchReq.Status != \"\" {\n\t\tfilterCriteria[\"Status\"] = searchReq.Status\n\t\tif searchReq.LastActiveDate != \"\" {\n\t\t\tt, err := time.Parse(time.RFC3339, searchReq.LastActiveDate)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Printf(\"Invalid date format: %v\", err)\n\t\t\t\treturn nil, fmt.Errorf(\"invalid date format\")\n\t\t\t}\n\t\t\tfilterCriteria[\"LastAccessTime\"] = t\n\t\t}\n\t} else if searchReq.Specialization != \"\" {\n\t\tfilterCriteria[\"SubCategory\"] = searchReq.Specialization\n\t} else if searchReq.MinRating > 0 {\n\t\tfilterCriteria[\"Rating\"] = searchReq.MinRating\n\t} else {\n\t\treturn nil, fmt.Errorf(\"at least one search criteria must be provided\")\n\t}\n\n\tcouponSvc := &Coupon{}\n\tresults, err := couponSvc.MonitorHealth(filterCriteria)\n\tif err != nil {\n\t\tlogger.Printf(\"Health monitoring failed: %v\", err)\n\t\treturn nil, fmt.Errorf(\"search failed\")\n\t}\n\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "提供Status和LastAccessTime",
            "sql": "SELECT id, name, specialization, status, last_access_time, sub_category, created_at, updated_at FROM doctor_profiles WHERE status = ? AND last_access_time > ?;"
          },
          {
            "scenario": "只提供Status",
            "sql": "SELECT id, name, specialization, status, last_access_time, sub_category, created_at, updated_at FROM doctor_profiles WHERE status = ?;"
          },
          {
            "scenario": "只提供SubCategory（Specialization）",
            "sql": "SELECT id, name, specialization, status, last_access_time, sub_category, created_at, updated_at FROM doctor_profiles WHERE sub_category LIKE ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "DoctorProfile",
        "code_value": "type DoctorProfile struct {\n\tID              int       `json:\"id\" gorm:\"column:id\"`\n\tName            string    `json:\"name\" gorm:\"column:name\"`\n\tSpecialization  string    `json:\"specialization\" gorm:\"column:specialization\"`\n\tStatus          string    `json:\"status\" gorm:\"column:status\"`\n\tLastAccessTime  time.Time `json:\"last_access_time\" gorm:\"column:last_access_time\"`\n\tSubCategory     string    `json:\"sub_category\" gorm:\"column:sub_category\"`\n\tCreatedAt       time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt       time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "HealthStatus",
        "code_value": "const (\n\tActiveStatus   = \"active\"\n\tInactiveStatus = \"inactive\"\n\tPendingStatus  = \"pending\"\n)"
      },
      {
        "code_key": "DoctorFilter",
        "code_value": "type DoctorFilter struct {\n\tStatus         *string\n\tLastAccessTime *time.Time\n\tSubCategory    *string\n}"
      },
      {
        "code_key": "TableNameDoctor",
        "code_value": "const TableNameDoctor = \"doctor_profiles\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "MonitorHealth",
    "orm_code": "func (c *Coupon) MonitorHealth(filterParams map[string]interface{}) ([]types.DoctorProfile, error) {\n\tvar profiles []types.DoctorProfile\n\tdb := base.GetInstance().HealthDriver().Table(\"doctor_profiles\")\n\n\tif status, exists := filterParams[\"Status\"]; exists {\n\t\tif lastAccess, hasAccess := filterParams[\"LastAccessTime\"]; hasAccess {\n\t\t\tdb = db.Where(\"status = ? AND last_access_time > ?\", status, lastAccess)\n\t\t} else {\n\t\t\tdb = db.Where(\"status = ?\", status)\n\t\t}\n\t} else if category, hasCategory := filterParams[\"SubCategory\"]; hasCategory {\n\t\tdb = db.Where(\"sub_category LIKE ?\", \"%\"+category.(string)+\"%\")\n\t} else {\n\t\treturn nil, errors.New(\"invalid filter parameters\")\n\t}\n\n\tif err := db.Find(&profiles).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn profiles, nil\n}",
    "caller": "func (h *HealthHandler) HandleVaccineRecords(req *types.VaccineQueryRequest) ([]types.VaccinationRecord, error) {\n\tif req.Limit <= 0 {\n\t\treturn nil, errors.New(\"limit must be positive\")\n\t}\n\n\tqueryFilters := make(map[string]interface{})\n\n\tswitch {\n\tcase req.PatientID != \"\":\n\t\tqueryFilters[\"patient_id\"] = req.PatientID\n\tcase req.VaccineType != \"\":\n\t\tqueryFilters[\"vaccine_type\"] = req.VaccineType\n\tcase req.StartDate != \"\" && req.EndDate != \"\":\n\t\tqueryFilters[\"date_range\"] = []string{req.StartDate, req.EndDate}\n\t}\n\n\tsvc := &Surgery{}\n\trecords, err := svc.MonitorHealth(queryFilters, req.Limit)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to query vaccine records: %v\", err)\n\t}\n\n\tif len(records) == 0 {\n\t\treturn nil, errors.New(\"no matching records found\")\n\t}\n\n\treturn records, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按patient_id精确查询",
            "sql": "SELECT id, patient_id, vaccine_type, injection_date, dose_number, clinic_name, created_at, updated_at FROM vaccination_records WHERE patient_id = ? LIMIT ?;"
          },
          {
            "scenario": "按vaccine_type模糊查询",
            "sql": "SELECT id, patient_id, vaccine_type, injection_date, dose_number, clinic_name, created_at, updated_at FROM vaccination_records WHERE vaccine_type LIKE ? ORDER BY injection_date DESC LIMIT ?;"
          },
          {
            "scenario": "按date_range范围查询",
            "sql": "SELECT id, patient_id, vaccine_type, injection_date, dose_number, clinic_name, created_at, updated_at FROM vaccination_records WHERE injection_date BETWEEN ? AND ? LIMIT ?;"
          },
          {
            "scenario": "无条件查询所有记录",
            "sql": "SELECT id, patient_id, vaccine_type, injection_date, dose_number, clinic_name, created_at, updated_at FROM vaccination_records LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "DoctorProfile",
        "code_value": "type DoctorProfile struct {\n\tID              int       `json:\"id\" gorm:\"column:id\"`\n\tName            string    `json:\"name\" gorm:\"column:name\"`\n\tSpecialization  string    `json:\"specialization\" gorm:\"column:specialization\"`\n\tStatus          string    `json:\"status\" gorm:\"column:status\"`\n\tLastAccessTime  time.Time `json:\"last_access_time\" gorm:\"column:last_access_time\"`\n\tSubCategory     string    `json:\"sub_category\" gorm:\"column:sub_category\"`\n\tCreatedAt       time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt       time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "HealthStatus",
        "code_value": "const (\n\tActiveStatus   = \"active\"\n\tInactiveStatus = \"inactive\"\n\tPendingStatus  = \"pending\"\n)"
      },
      {
        "code_key": "DoctorFilter",
        "code_value": "type DoctorFilter struct {\n\tStatus         *string\n\tLastAccessTime *time.Time\n\tSubCategory    *string\n}"
      },
      {
        "code_key": "TableNameDoctor",
        "code_value": "const TableNameDoctor = \"doctor_profiles\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ApproveRequest",
    "orm_code": "func (v *Video) ApproveRequest(filters map[string]interface{}) ([]types.VideoApproval, error) {\n\tvar approvals []types.VideoApproval\n\tdb := base.GetInstance().GormDriver().Table(\"dispatch_orders\")\n\n\tif edition, ok := filters[\"Edition\"]; ok {\n\t\tif region, ok := filters[\"Region\"]; ok {\n\t\t\tdb = db.Where(\"edition = ? AND region = ?\", edition, region)\n\t\t} else {\n\t\t\tdb = db.Where(\"edition LIKE ?\", \"%\"+edition.(string)+\"%\")\n\t\t}\n\t} else if code, ok := filters[\"LocationCode\"]; ok {\n\t\tdb = db.Where(\"location_code = ?\", code)\n\t}\n\n\tif err := db.Find(&approvals).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn approvals, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "包含Edition和Region参数",
            "sql": "SELECT id, edition, region, location_code, status, created_at, updated_at FROM dispatch_orders WHERE edition = ? AND region = ?;"
          },
          {
            "scenario": "仅包含Edition参数",
            "sql": "SELECT id, edition, region, location_code, status, created_at, updated_at FROM dispatch_orders WHERE edition LIKE ?;"
          },
          {
            "scenario": "仅包含LocationCode参数",
            "sql": "SELECT id, edition, region, location_code, status, created_at, updated_at FROM dispatch_orders WHERE location_code = ?;"
          },
          {
            "scenario": "无任何参数",
            "sql": "SELECT id, edition, region, location_code, status, created_at, updated_at FROM dispatch_orders;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "VideoApproval",
        "code_value": "type VideoApproval struct {\n\tID           int       `json:\"id\" gorm:\"column:id\"`\n\tEdition      string    `json:\"edition\" gorm:\"column:edition\"`\n\tRegion       string    `json:\"region\" gorm:\"column:region\"`\n\tLocationCode string    `json:\"location_code\" gorm:\"column:location_code\"`\n\tStatus       int       `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt    time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt    time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "ApprovalStatus",
        "code_value": "const (\n\tPending  ApprovalStatus = iota\n\tApproved\n\tRejected\n)"
      },
      {
        "code_key": "VideoFilter",
        "code_value": "type VideoFilter struct {\n\tEdition      string\n\tRegion       string\n\tLocationCode string\n}"
      },
      {
        "code_key": "DispatchOrderTable",
        "code_value": "const DispatchOrderTable = \"dispatch_orders\""
      },
      {
        "code_key": "DefaultRegion",
        "code_value": "var DefaultRegion = \"US\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ApproveRequest",
    "orm_code": "func (v *Video) ApproveRequest(filters map[string]interface{}) ([]types.VideoApproval, error) {\n\tvar approvals []types.VideoApproval\n\tdb := base.GetInstance().GormDriver().Table(\"dispatch_orders\")\n\n\tif edition, ok := filters[\"Edition\"]; ok {\n\t\tif region, ok := filters[\"Region\"]; ok {\n\t\t\tdb = db.Where(\"edition = ? AND region = ?\", edition, region)\n\t\t} else {\n\t\t\tdb = db.Where(\"edition LIKE ?\", \"%\"+edition.(string)+\"%\")\n\t\t}\n\t} else if code, ok := filters[\"LocationCode\"]; ok {\n\t\tdb = db.Where(\"location_code = ?\", code)\n\t}\n\n\tif err := db.Find(&approvals).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn approvals, nil\n}",
    "caller": "func (h *DriverHandler) HandleDriverApprovals(req *types.DriverApprovalRequest) ([]types.VideoApproval, error) {\n\tfilters := make(map[string]interface{})\n\n\tif req.DriverID != \"\" {\n\t\tfilters[\"LocationCode\"] = req.DriverID\n\t} else if req.Edition != \"\" {\n\t\tfilters[\"Edition\"] = req.Edition\n\t\tif req.Region != \"\" {\n\t\t\tfilters[\"Region\"] = req.Region\n\t\t}\n\t} else if req.Status != \"\" {\n\t\tif !utils.IsValidStatus(req.Status) {\n\t\t\treturn nil, fmt.Errorf(\"invalid status: %s\", req.Status)\n\t\t}\n\t\tfilters[\"Status\"] = req.Status\n\t}\n\n\tdriver := &Video{}\n\tapprovals, err := driver.ApproveRequest(filters)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get driver approvals: %v\", err)\n\t}\n\n\tif len(approvals) == 0 && req.RequireNonEmpty {\n\t\treturn nil, fmt.Errorf(\"no approvals found but require non-empty result\")\n\t}\n\n\treturn approvals, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "DriverID参数提供",
            "sql": "SELECT id, edition, region, location_code, status, created_at, updated_at FROM dispatch_orders WHERE location_code = 'DRV123';"
          },
          {
            "scenario": "Edition和Region参数都提供",
            "sql": "SELECT id, edition, region, location_code, status, created_at, updated_at FROM dispatch_orders WHERE edition = '2023' AND region = 'US';"
          },
          {
            "scenario": "只有Edition参数提供",
            "sql": "SELECT id, edition, region, location_code, status, created_at, updated_at FROM dispatch_orders WHERE edition LIKE '%2023%';"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "VideoApproval",
        "code_value": "type VideoApproval struct {\n\tID           int       `json:\"id\" gorm:\"column:id\"`\n\tEdition      string    `json:\"edition\" gorm:\"column:edition\"`\n\tRegion       string    `json:\"region\" gorm:\"column:region\"`\n\tLocationCode string    `json:\"location_code\" gorm:\"column:location_code\"`\n\tStatus       int       `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt    time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt    time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "ApprovalStatus",
        "code_value": "const (\n\tPending  ApprovalStatus = iota\n\tApproved\n\tRejected\n)"
      },
      {
        "code_key": "VideoFilter",
        "code_value": "type VideoFilter struct {\n\tEdition      string\n\tRegion       string\n\tLocationCode string\n}"
      },
      {
        "code_key": "DispatchOrderTable",
        "code_value": "const DispatchOrderTable = \"dispatch_orders\""
      },
      {
        "code_key": "DefaultRegion",
        "code_value": "var DefaultRegion = \"US\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "SortByField",
    "orm_code": "func (p *Project) SortByField(filterParams map[string]interface{}, orderField string) ([]types.SocialPost, error) {\n\tvar posts []types.SocialPost\n\tdb := base.GetInstance().MainDB().Table(\"social_posts\")\n\n\tif summary, exists := filterParams[\"Summary\"]; exists {\n\t\tdb = db.Where(\"summary LIKE ?\", \"%\"+summary.(string)+\"%\")\n\t\tif creationTime, hasTime := filterParams[\"CreationTime\"]; hasTime {\n\t\t\tdb = db.Where(\"created_at > ?\", creationTime)\n\t\t}\n\t} else {\n\t\tdb = db.Where(filterParams)\n\t}\n\n\terr := db.Order(orderField).Find(&posts).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn posts, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "filterParams contains UnitPrice",
            "sql": "SELECT id, unit_price, activation_date, sequence_number, created_at, updated_at FROM health_metrics WHERE unit_price = ? ORDER BY sequence_number DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "filterParams contains ActivationDate",
            "sql": "SELECT id, unit_price, activation_date, sequence_number, created_at, updated_at FROM health_metrics WHERE activation_date > ? ORDER BY unit_price ASC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "filterParams contains SequenceNumber",
            "sql": "SELECT id, unit_price, activation_date, sequence_number, created_at, updated_at FROM health_metrics WHERE sequence_number LIKE ? ORDER BY activation_date DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "filterParams is empty or doesn't contain the above fields",
            "sql": "SELECT id, unit_price, activation_date, sequence_number, created_at, updated_at FROM health_metrics ORDER BY id ASC LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "SocialPost",
        "code_value": "type SocialPost struct {\n\tID          uint      json:\"id\" gorm:\"primaryKey\"\n\tSummary     string    json:\"summary\" gorm:\"column:summary\"\n\tContent     string    json:\"content\" gorm:\"column:content\"\n\tCreatedAt   time.Time json:\"created_at\" gorm:\"column:created_at\"\n\tUpdatedAt   time.Time json:\"updated_at\" gorm:\"column:updated_at\"\n\tAuthorID    uint      json:\"author_id\" gorm:\"column:author_id\"\n\tLikeCount   int       json:\"like_count\" gorm:\"column:like_count\"\n\tCommentCount int      json:\"comment_count\" gorm:\"column:comment_count\"\n}"
      },
      {
        "code_key": "PostFilter",
        "code_value": "type PostFilter struct {\n\tSummary      *string\n\tCreationTime *time.Time\n\tAuthorID     *uint\n\tMinLikes     *int\n}"
      },
      {
        "code_key": "SortDirection",
        "code_value": "type SortDirection string\n\nconst (\n\tSortAsc  SortDirection = \"ASC\"\n\tSortDesc SortDirection = \"DESC\"\n)"
      },
      {
        "code_key": "TableSocialPosts",
        "code_value": "const TableSocialPosts = \"social_posts\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "MaxPostSummaryLength",
        "code_value": "const MaxPostSummaryLength = 140"
      },
      {
        "code_key": "PostCache",
        "code_value": "var PostCache = make(map[uint]types.SocialPost)"
      },
      {
        "code_key": "PopularPostThreshold",
        "code_value": "const PopularPostThreshold = 1000"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "SortByField",
    "orm_code": "func (p *Project) SortByField(filterParams map[string]interface{}, orderField string) ([]types.SocialPost, error) {\n\tvar posts []types.SocialPost\n\tdb := base.GetInstance().MainDB().Table(\"social_posts\")\n\n\tif summary, exists := filterParams[\"Summary\"]; exists {\n\t\tdb = db.Where(\"summary LIKE ?\", \"%\"+summary.(string)+\"%\")\n\t\tif creationTime, hasTime := filterParams[\"CreationTime\"]; hasTime {\n\t\t\tdb = db.Where(\"created_at > ?\", creationTime)\n\t\t}\n\t} else {\n\t\tdb = db.Where(filterParams)\n\t}\n\n\terr := db.Order(orderField).Find(&posts).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn posts, nil\n}",
    "caller": "func (v *VideoHandler) HandleVideoCollection(req *types.VideoCollectionRequest, log *logger.AppLog) ([]types.SocialPost, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.CategoryID > 0 {\n\t\tfilter[\"category_id\"] = req.CategoryID\n\t\tif req.IsPremium {\n\t\t\tfilter[\"is_premium\"] = true\n\t\t}\n\t} else if len(req.AuthorName) > 0 {\n\t\tif err := validateAuthorName(req.AuthorName); err != nil {\n\t\t\tlog.Error(\"Invalid author name\", err)\n\t\t\treturn nil, err\n\t\t}\n\t\tfilter[\"author\"] = req.AuthorName\n\t} else if req.MinDuration > 0 {\n\t\tfilter[\"duration\"] = gorm.Expr(\"duration >= ?\", req.MinDuration)\n\t} else {\n\t\tfilter[\"is_featured\"] = true\n\t}\n\n\tvideoProject := &Project{}\n\tresults, err := videoProject.SortByField(filter, req.SortBy)\n\tif err != nil {\n\t\tlog.Error(\"Failed to fetch videos\", err)\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}\n\nfunc validateAuthorName(name string) error {\n\tif len(name) < 2 || len(name) > 50 {\n\t\treturn errors.New(\"author name must be 2-50 characters\")\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "带有 category_id 和 is_premium 的查询",
            "sql": "SELECT id, summary, content, created_at, updated_at, author_id, like_count, comment_count FROM social_posts WHERE category_id = ? AND is_premium = ? ORDER BY ?;"
          },
          {
            "scenario": "带有 author 的查询",
            "sql": "SELECT id, summary, content, created_at, updated_at, author_id, like_count, comment_count FROM social_posts WHERE author = ? ORDER BY ?;"
          },
          {
            "scenario": "带有 duration 条件的查询",
            "sql": "SELECT id, summary, content, created_at, updated_at, author_id, like_count, comment_count FROM social_posts WHERE duration >= ? ORDER BY ?;"
          },
          {
            "scenario": "默认查询 is_featured",
            "sql": "SELECT id, summary, content, created_at, updated_at, author_id, like_count, comment_count FROM social_posts WHERE is_featured = true ORDER BY ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "SocialPost",
        "code_value": "type SocialPost struct {\n\tID          uint      json:\"id\" gorm:\"primaryKey\"\n\tSummary     string    json:\"summary\" gorm:\"column:summary\"\n\tContent     string    json:\"content\" gorm:\"column:content\"\n\tCreatedAt   time.Time json:\"created_at\" gorm:\"column:created_at\"\n\tUpdatedAt   time.Time json:\"updated_at\" gorm:\"column:updated_at\"\n\tAuthorID    uint      json:\"author_id\" gorm:\"column:author_id\"\n\tLikeCount   int       json:\"like_count\" gorm:\"column:like_count\"\n\tCommentCount int      json:\"comment_count\" gorm:\"column:comment_count\"\n}"
      },
      {
        "code_key": "PostFilter",
        "code_value": "type PostFilter struct {\n\tSummary      *string\n\tCreationTime *time.Time\n\tAuthorID     *uint\n\tMinLikes     *int\n}"
      },
      {
        "code_key": "SortDirection",
        "code_value": "type SortDirection string\n\nconst (\n\tSortAsc  SortDirection = \"ASC\"\n\tSortDesc SortDirection = \"DESC\"\n)"
      },
      {
        "code_key": "TableSocialPosts",
        "code_value": "const TableSocialPosts = \"social_posts\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "MaxPostSummaryLength",
        "code_value": "const MaxPostSummaryLength = 140"
      },
      {
        "code_key": "PostCache",
        "code_value": "var PostCache = make(map[uint]types.SocialPost)"
      },
      {
        "code_key": "PopularPostThreshold",
        "code_value": "const PopularPostThreshold = 1000"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "SortByField",
    "orm_code": "func (p *Project) SortByField(filterParams map[string]interface{}, orderField string) ([]types.SocialPost, error) {\n\tvar posts []types.SocialPost\n\tdb := base.GetInstance().MainDB().Table(\"social_posts\")\n\n\tif summary, exists := filterParams[\"Summary\"]; exists {\n\t\tdb = db.Where(\"summary LIKE ?\", \"%\"+summary.(string)+\"%\")\n\t\tif creationTime, hasTime := filterParams[\"CreationTime\"]; hasTime {\n\t\t\tdb = db.Where(\"created_at > ?\", creationTime)\n\t\t}\n\t} else {\n\t\tdb = db.Where(filterParams)\n\t}\n\n\terr := db.Order(orderField).Find(&posts).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn posts, nil\n}",
    "caller": "func (h *HealthHandler) HandleHealthMetrics(req *types.HealthMetricsRequest) ([]types.HealthMetrics, error) {\n\tif req.Page <= 0 || req.Size <= 0 {\n\t\treturn nil, fmt.Errorf(\"invalid pagination parameters\")\n\t}\n\t\n\tfilterCriteria := make(map[string]interface{})\n\tif req.UnitPrice > 0 {\n\t\tfilterCriteria[\"UnitPrice\"] = req.UnitPrice\n\t} else if !req.ActivationDate.IsZero() {\n\t\tfilterCriteria[\"ActivationDate\"] = req.ActivationDate\n\t} else if req.SequenceNumber != \"\" {\n\t\tfilterCriteria[\"SequenceNumber\"] = req.SequenceNumber\n\t}\n\t\n\tappt := &Appointment{}\n\tresults, err := appt.SortByField(filterCriteria, req.Page, req.Size)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to query health metrics: %v\", err)\n\t}\n\t\n\tif len(results) == 0 {\n\t\treturn nil, fmt.Errorf(\"no matching records found\")\n\t}\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "UnitPrice条件",
            "sql": "SELECT id, unit_price, activation_date, sequence_number, created_at, updated_at FROM health_metrics WHERE unit_price = ? ORDER BY sequence_number DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "ActivationDate条件",
            "sql": "SELECT id, unit_price, activation_date, sequence_number, created_at, updated_at FROM health_metrics WHERE activation_date > ? ORDER BY unit_price ASC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "SequenceNumber条件",
            "sql": "SELECT id, unit_price, activation_date, sequence_number, created_at, updated_at FROM health_metrics WHERE sequence_number LIKE ? ORDER BY activation_date DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "无条件查询",
            "sql": "SELECT id, unit_price, activation_date, sequence_number, created_at, updated_at FROM health_metrics ORDER BY id ASC LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "SocialPost",
        "code_value": "type SocialPost struct {\n\tID          uint      json:\"id\" gorm:\"primaryKey\"\n\tSummary     string    json:\"summary\" gorm:\"column:summary\"\n\tContent     string    json:\"content\" gorm:\"column:content\"\n\tCreatedAt   time.Time json:\"created_at\" gorm:\"column:created_at\"\n\tUpdatedAt   time.Time json:\"updated_at\" gorm:\"column:updated_at\"\n\tAuthorID    uint      json:\"author_id\" gorm:\"column:author_id\"\n\tLikeCount   int       json:\"like_count\" gorm:\"column:like_count\"\n\tCommentCount int      json:\"comment_count\" gorm:\"column:comment_count\"\n}"
      },
      {
        "code_key": "PostFilter",
        "code_value": "type PostFilter struct {\n\tSummary      *string\n\tCreationTime *time.Time\n\tAuthorID     *uint\n\tMinLikes     *int\n}"
      },
      {
        "code_key": "SortDirection",
        "code_value": "type SortDirection string\n\nconst (\n\tSortAsc  SortDirection = \"ASC\"\n\tSortDesc SortDirection = \"DESC\"\n)"
      },
      {
        "code_key": "TableSocialPosts",
        "code_value": "const TableSocialPosts = \"social_posts\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "MaxPostSummaryLength",
        "code_value": "const MaxPostSummaryLength = 140"
      },
      {
        "code_key": "PostCache",
        "code_value": "var PostCache = make(map[uint]types.SocialPost)"
      },
      {
        "code_key": "PopularPostThreshold",
        "code_value": "const PopularPostThreshold = 1000"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CalculateByFormula",
    "orm_code": "func (m *Media) CalculateByFormula(filterParams map[string]interface{}, page, limit int) ([]types.MediaContent, error) {\n\tcontents := make([]types.MediaContent, 0)\n\tdb := base.GetInstance().MediaDriver().Table(\"content_archive\")\n\n\tif category, ok := filterParams[\"CategoryType\"]; ok {\n\t\tif title, exists := filterParams[\"Title\"]; exists {\n\t\t\tdb = db.Where(\"category_type = ? AND title LIKE ?\", category, \"%\"+title.(string)+\"%\")\n\t\t} else {\n\t\t\tdb = db.Where(\"category_type = ?\", category)\n\t\t}\n\t} else if expiration, ok := filterParams[\"ExpirationTime\"]; ok {\n\t\tdb = db.Where(\"expiration_time > ?\", expiration)\n\t}\n\n\terr := db.Scopes(PaginateDB(page, limit)).Order(\"created_at DESC\").Find(&contents).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn contents, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn contents, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "同时提供CategoryType和Title",
            "sql": "SELECT id, title, category_type, expiration_time, created_at, content_data FROM content_archive WHERE category_type = ? AND title LIKE ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "只提供CategoryType",
            "sql": "SELECT id, title, category_type, expiration_time, created_at, content_data FROM content_archive WHERE category_type = ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "提供ExpirationTime",
            "sql": "SELECT id, title, category_type, expiration_time, created_at, content_data FROM content_archive WHERE expiration_time > ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "无过滤条件",
            "sql": "SELECT id, title, category_type, expiration_time, created_at, content_data FROM content_archive ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "MediaContent",
        "code_value": "type MediaContent struct {\n\tID            uint      `gorm:\"column:id;primaryKey\"`\n\tTitle         string    `gorm:\"column:title\"`\n\tCategoryType  string    `gorm:\"column:category_type\"`\n\tExpirationTime time.Time `gorm:\"column:expiration_time\"`\n\tCreatedAt     time.Time `gorm:\"column:created_at\"`\n\tContentData   []byte    `gorm:\"column:content_data;type:jsonb\"`\n}"
      },
      {
        "code_key": "ContentArchiveTable",
        "code_value": "const ContentArchiveTable = \"content_archive\""
      },
      {
        "code_key": "FilterParams",
        "code_value": "type FilterParams struct {\n\tCategoryType   string \n\tTitle          string \n\tExpirationTime time.Time\n}"
      },
      {
        "code_key": "PaginationConfig",
        "code_value": "var PaginationConfig = struct {\n\tDefaultPage  int\n\tDefaultLimit int\n}{\n\tDefaultPage:  1,\n\tDefaultLimit: 20,\n}"
      },
      {
        "code_key": "MediaResponse",
        "code_value": "type MediaResponse struct {\n\tContents     []MediaContent\n\tCurrentPage  int\n\tTotalPages   int\n\tTotalRecords int64\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CalculateByFormula",
    "orm_code": "func (m *Media) CalculateByFormula(filterParams map[string]interface{}, page, limit int) ([]types.MediaContent, error) {\n\tcontents := make([]types.MediaContent, 0)\n\tdb := base.GetInstance().MediaDriver().Table(\"content_archive\")\n\n\tif category, ok := filterParams[\"CategoryType\"]; ok {\n\t\tif title, exists := filterParams[\"Title\"]; exists {\n\t\t\tdb = db.Where(\"category_type = ? AND title LIKE ?\", category, \"%\"+title.(string)+\"%\")\n\t\t} else {\n\t\t\tdb = db.Where(\"category_type = ?\", category)\n\t\t}\n\t} else if expiration, ok := filterParams[\"ExpirationTime\"]; ok {\n\t\tdb = db.Where(\"expiration_time > ?\", expiration)\n\t}\n\n\terr := db.Scopes(PaginateDB(page, limit)).Order(\"created_at DESC\").Find(&contents).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn contents, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn contents, nil\n}",
    "caller": "func (h *MediaHandler) HandleMediaContent(req *types.MediaContentRequest, log *logger.AppLog) ([]types.MediaContent, error) {\n\tfilter := make(map[string]interface{})\n\tif req.ContentID != \"\" {\n\t\tfilter[\"ContentID\"] = req.ContentID\n\t} else if req.Author != \"\" {\n\t\tif len(req.Author) > 50 {\n\t\t\tlog.Error(\"Author name too long\")\n\t\t\treturn nil, errors.New(\"invalid author name\")\n\t\t}\n\t\tfilter[\"Author\"] = req.Author\n\t} else if req.Status != 0 {\n\t\tif req.Status < 1 || req.Status > 3 {\n\t\t\tlog.Error(\"Invalid status value\")\n\t\t\treturn nil, errors.New(\"invalid status\")\n\t\t}\n\t\tfilter[\"Status\"] = req.Status\n\t} else {\n\t\tfilter[\"IsFeatured\"] = true\n\t}\n\n\tmedia := &Media{}\n\tpage, size := utils.NormalizePagination(req.Page, req.PageSize)\n\tcontents, err := media.CalculateByFormula(filter, page, size)\n\tif err != nil {\n\t\tlog.Error(\"Failed to query media content\", err)\n\t\treturn nil, err\n\t}\n\treturn contents, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "filterParams contains both CategoryType and Title",
            "sql": "SELECT id, title, category_type, expiration_time, created_at, content_data FROM content_archive WHERE category_type = ? AND title LIKE ? ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "filterParams contains only CategoryType",
            "sql": "SELECT id, title, category_type, expiration_time, created_at, content_data FROM content_archive WHERE category_type = ? ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "filterParams contains only ExpirationTime",
            "sql": "SELECT id, title, category_type, expiration_time, created_at, content_data FROM content_archive WHERE expiration_time > ? ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "filterParams contains none of the specified keys",
            "sql": "SELECT id, title, category_type, expiration_time, created_at, content_data FROM content_archive ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "MediaContent",
        "code_value": "type MediaContent struct {\n\tID            uint      `gorm:\"column:id;primaryKey\"`\n\tTitle         string    `gorm:\"column:title\"`\n\tCategoryType  string    `gorm:\"column:category_type\"`\n\tExpirationTime time.Time `gorm:\"column:expiration_time\"`\n\tCreatedAt     time.Time `gorm:\"column:created_at\"`\n\tContentData   []byte    `gorm:\"column:content_data;type:jsonb\"`\n}"
      },
      {
        "code_key": "ContentArchiveTable",
        "code_value": "const ContentArchiveTable = \"content_archive\""
      },
      {
        "code_key": "FilterParams",
        "code_value": "type FilterParams struct {\n\tCategoryType   string \n\tTitle          string \n\tExpirationTime time.Time\n}"
      },
      {
        "code_key": "PaginationConfig",
        "code_value": "var PaginationConfig = struct {\n\tDefaultPage  int\n\tDefaultLimit int\n}{\n\tDefaultPage:  1,\n\tDefaultLimit: 20,\n}"
      },
      {
        "code_key": "MediaResponse",
        "code_value": "type MediaResponse struct {\n\tContents     []MediaContent\n\tCurrentPage  int\n\tTotalPages   int\n\tTotalRecords int64\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CountByStatus",
    "orm_code": "func (m *Medicine) CountByStatus(filter map[string]interface{}) (int64, error) {\n\tvar count int64\n\tdb := base.GetInstance().GormDB().Table(\"project_assignments\")\n\n\tif status, ok := filter[\"Status\"]; ok {\n\t\tif trackingId, ok := filter[\"TrackingId\"]; ok {\n\t\t\tdb = db.Where(\"status = ? AND tracking_id = ?\", status, trackingId)\n\t\t} else {\n\t\t\tdb = db.Where(\"status = ?\", status)\n\t\t}\n\t} else if apiKey, ok := filter[\"ApiKey\"]; ok {\n\t\tdb = db.Where(\"api_key LIKE ?\", \"%\"+apiKey.(string)+\"%\")\n\t} else {\n\t\tdb = db.Where(filter)\n\t}\n\n\terr := db.Count(&count).Error\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn count, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "包含status参数的查询",
            "sql": "SELECT COUNT(*) FROM subscription_tiers WHERE status = ? AND end_date > ?;"
          },
          {
            "scenario": "包含module参数的查询",
            "sql": "SELECT COUNT(*) FROM subscription_tiers WHERE module_name LIKE ? AND floor > ?;"
          },
          {
            "scenario": "包含end_date参数的查询",
            "sql": "SELECT COUNT(*) FROM subscription_tiers WHERE end_date BETWEEN ? AND ?;"
          },
          {
            "scenario": "不包含上述特定参数的查询",
            "sql": "SELECT COUNT(*) FROM subscription_tiers WHERE name = ? AND floor = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "ProjectAssignment",
        "code_value": "type ProjectAssignment struct {\n\tID        uint      `gorm:\"primaryKey\"`\n\tStatus    string    `gorm:\"column:status\"`\n\tTrackingID string   `gorm:\"column:tracking_id\"`\n\tApiKey    string    `gorm:\"column:api_key\"`\n\tCreatedAt time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "AssignmentStatus",
        "code_value": "const (\n\tAssignmentPending = \"pending\"\n\tAssignmentActive = \"active\"\n\tAssignmentCompleted = \"completed\"\n)"
      },
      {
        "code_key": "TableProjectAssignments",
        "code_value": "const TableProjectAssignments = \"project_assignments\""
      },
      {
        "code_key": "AssignmentFilter",
        "code_value": "type AssignmentFilter struct {\n\tStatus    string\n\tTrackingID string\n\tApiKey    string\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CountByStatus",
    "orm_code": "func (m *Medicine) CountByStatus(filter map[string]interface{}) (int64, error) {\n\tvar count int64\n\tdb := base.GetInstance().GormDB().Table(\"project_assignments\")\n\n\tif status, ok := filter[\"Status\"]; ok {\n\t\tif trackingId, ok := filter[\"TrackingId\"]; ok {\n\t\t\tdb = db.Where(\"status = ? AND tracking_id = ?\", status, trackingId)\n\t\t} else {\n\t\t\tdb = db.Where(\"status = ?\", status)\n\t\t}\n\t} else if apiKey, ok := filter[\"ApiKey\"]; ok {\n\t\tdb = db.Where(\"api_key LIKE ?\", \"%\"+apiKey.(string)+\"%\")\n\t} else {\n\t\tdb = db.Where(filter)\n\t}\n\n\terr := db.Count(&count).Error\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn count, nil\n}",
    "caller": "func (s *MedicineService) HandleMedicineCount(req *types.MedicineCountRequest) (int64, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.Status != \"\" {\n\t\tfilter[\"Status\"] = req.Status\n\t\tif req.TrackingID != \"\" {\n\t\t\tfilter[\"TrackingId\"] = req.TrackingID\n\t\t}\n\t} else if req.APIKey != \"\" {\n\t\tif len(req.APIKey) < 5 {\n\t\t\treturn 0, errors.New(\"API key too short\")\n\t\t}\n\t\tfilter[\"ApiKey\"] = req.APIKey\n\t} else if req.Category != \"\" {\n\t\tfilter[\"category\"] = req.Category\n\t} else {\n\t\treturn 0, errors.New(\"at least one filter parameter required\")\n\t}\n\n\tmed := &Medicine{}\n\tcount, err := med.CountByStatus(filter)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to count medicines: %v\", err)\n\t}\n\t\n\treturn count, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Status and TrackingID both provided",
            "sql": "SELECT COUNT(*) FROM project_assignments WHERE status = ? AND tracking_id = ?;"
          },
          {
            "scenario": "Only Status provided",
            "sql": "SELECT COUNT(*) FROM project_assignments WHERE status = ?;"
          },
          {
            "scenario": "APIKey provided (length ≥ 5)",
            "sql": "SELECT COUNT(*) FROM project_assignments WHERE api_key LIKE ?;"
          },
          {
            "scenario": "Only Category provided (not defined in struct)",
            "sql": "SELECT COUNT(*) FROM project_assignments WHERE category = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ProjectAssignment",
        "code_value": "type ProjectAssignment struct {\n\tID        uint      `gorm:\"primaryKey\"`\n\tStatus    string    `gorm:\"column:status\"`\n\tTrackingID string   `gorm:\"column:tracking_id\"`\n\tApiKey    string    `gorm:\"column:api_key\"`\n\tCreatedAt time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "AssignmentStatus",
        "code_value": "const (\n\tAssignmentPending = \"pending\"\n\tAssignmentActive = \"active\"\n\tAssignmentCompleted = \"completed\"\n)"
      },
      {
        "code_key": "TableProjectAssignments",
        "code_value": "const TableProjectAssignments = \"project_assignments\""
      },
      {
        "code_key": "AssignmentFilter",
        "code_value": "type AssignmentFilter struct {\n\tStatus    string\n\tTrackingID string\n\tApiKey    string\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CountByStatus",
    "orm_code": "func (m *Medicine) CountByStatus(filter map[string]interface{}) (int64, error) {\n\tvar count int64\n\tdb := base.GetInstance().GormDB().Table(\"project_assignments\")\n\n\tif status, ok := filter[\"Status\"]; ok {\n\t\tif trackingId, ok := filter[\"TrackingId\"]; ok {\n\t\t\tdb = db.Where(\"status = ? AND tracking_id = ?\", status, trackingId)\n\t\t} else {\n\t\t\tdb = db.Where(\"status = ?\", status)\n\t\t}\n\t} else if apiKey, ok := filter[\"ApiKey\"]; ok {\n\t\tdb = db.Where(\"api_key LIKE ?\", \"%\"+apiKey.(string)+\"%\")\n\t} else {\n\t\tdb = db.Where(filter)\n\t}\n\n\terr := db.Count(&count).Error\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn count, nil\n}",
    "caller": "func (s *SubscriptionService) HandleSubscriptionStats(req *types.SubscriptionStatsRequest) (*types.SubscriptionStatsResponse, error) {\n\tfilters := make(map[string]interface{})\n\t\n\tif req.Status != \"\" {\n\t\tfilters[\"status\"] = req.Status\n\t} else if req.SearchModule != \"\" {\n\t\tfilters[\"module\"] = req.SearchModule\n\t\tfilters[\"floor\"] = req.MinFloor\n\t} else if req.TargetDate > 0 {\n\t\tfilters[\"end_date\"] = req.TargetDate\n\t} else {\n\t\tfilters[\"active\"] = true\n\t}\n\t\n\tauction := &models.Auction{}\n\ttotal, err := auction.CountByStatus(filters)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get subscription stats: %v\", err)\n\t}\n\t\n\treturn &types.SubscriptionStatsResponse{\n\t\tTotalCount: total,\n\t\tFilterType: determineFilterType(filters),\n\t}, nil\n}\n\nfunc determineFilterType(filters map[string]interface{}) string {\n\tif _, ok := filters[\"status\"]; ok {\n\t\treturn \"status\"\n\t} else if _, ok := filters[\"module\"]; ok {\n\t\treturn \"module\"\n\t} else if _, ok := filters[\"end_date\"]; ok {\n\t\treturn \"date_range\"\n\t}\n\treturn \"default\"\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "根据status过滤",
            "sql": "SELECT COUNT(*) FROM subscription_tiers WHERE status = ? AND end_date > ?;"
          },
          {
            "scenario": "根据module模糊搜索和floor过滤",
            "sql": "SELECT COUNT(*) FROM subscription_tiers WHERE module_name LIKE ? AND floor > ?;"
          },
          {
            "scenario": "根据end_date范围过滤",
            "sql": "SELECT COUNT(*) FROM subscription_tiers WHERE end_date BETWEEN ? AND ?;"
          },
          {
            "scenario": "默认过滤（active=true）",
            "sql": "SELECT COUNT(*) FROM subscription_tiers WHERE active = true;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "ProjectAssignment",
        "code_value": "type ProjectAssignment struct {\n\tID        uint      `gorm:\"primaryKey\"`\n\tStatus    string    `gorm:\"column:status\"`\n\tTrackingID string   `gorm:\"column:tracking_id\"`\n\tApiKey    string    `gorm:\"column:api_key\"`\n\tCreatedAt time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "AssignmentStatus",
        "code_value": "const (\n\tAssignmentPending = \"pending\"\n\tAssignmentActive = \"active\"\n\tAssignmentCompleted = \"completed\"\n)"
      },
      {
        "code_key": "TableProjectAssignments",
        "code_value": "const TableProjectAssignments = \"project_assignments\""
      },
      {
        "code_key": "AssignmentFilter",
        "code_value": "type AssignmentFilter struct {\n\tStatus    string\n\tTrackingID string\n\tApiKey    string\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CalculateDiscount",
    "orm_code": "func (p *Prescription) CalculateDiscount(filterParams map[string]interface{}) ([]types.MedicineDiscount, error) {\n\tvar discounts []types.MedicineDiscount\n\tdb := base.GetInstance().PharmacyDB().Table(\"prescription_discounts\")\n\n\tif medicineType, ok := filterParams[\"MedicineType\"]; ok {\n\t\t// Exact match for MedicineType combined with date range\n\t\tstartDate := filterParams[\"StartDate\"].(string)\n\t\tendDate := filterParams[\"EndDate\"].(string)\n\t\treturn discounts, db.Where(\"medicine_type = ? AND valid_from <= ? AND valid_to >= ?\", \n\t\t\tmedicineType, startDate, endDate).Find(&discounts).Error\n\t} else {\n\t\t// Range query based on discount percentage\n\t\tminDiscount := filterParams[\"MinDiscount\"].(float64)\n\t\tmaxDiscount := filterParams[\"MaxDiscount\"].(float64)\n\t\treturn discounts, db.Where(\"discount_percentage BETWEEN ? AND ?\", \n\t\t\tminDiscount, maxDiscount).Order(\"medicine_name\").Find(&discounts).Error\n\t}\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "filter中包含min_balance参数",
            "sql": "SELECT id, case_number, balance, duration_days, access_level, status, notes, rate_value, created_at, updated_at FROM expense_reports WHERE balance >= ? AND access_level IN ? ORDER BY case_number DESC;"
          },
          {
            "scenario": "filter中包含max_duration参数",
            "sql": "SELECT id, case_number, balance, duration_days, access_level, status, notes, rate_value, created_at, updated_at FROM expense_reports WHERE duration_days <= ? AND status = ? ORDER BY balance ASC;"
          },
          {
            "scenario": "filter中包含search_term参数",
            "sql": "SELECT id, case_number, balance, duration_days, access_level, status, notes, rate_value, created_at, updated_at FROM expense_reports WHERE notes LIKE ? LIMIT 50;"
          },
          {
            "scenario": "filter不包含特殊参数",
            "sql": "SELECT id, case_number, balance, duration_days, access_level, status, notes, rate_value, created_at, updated_at FROM expense_reports WHERE status = ? AND access_level = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "MedicineDiscount",
        "code_value": "type MedicineDiscount struct {\n\tID                int     `json:\"id\" gorm:\"column:id\"`\n\tMedicineType      string  `json:\"medicine_type\" gorm:\"column:medicine_type\"`\n\tMedicineName      string  `json:\"medicine_name\" gorm:\"column:medicine_name\"`\n\tDiscountPercentage float64 `json:\"discount_percentage\" gorm:\"column:discount_percentage\"`\n\tValidFrom         string  `json:\"valid_from\" gorm:\"column:valid_from\"`\n\tValidTo           string  `json:\"valid_to\" gorm:\"column:valid_to\"`\n\tCreatedAt         int64   `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt         int64   `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "Prescription",
        "code_value": "type Prescription struct {\n\tID         int       `json:\"id\" gorm:\"column:id\"`\n\tPatientID  string    `json:\"patient_id\" gorm:\"column:patient_id\"`\n\tDoctorID   string    `json:\"doctor_id\" gorm:\"column:doctor_id\"`\n\tIssueDate  time.Time `json:\"issue_date\" gorm:\"column:issue_date\"`\n\tExpiryDate time.Time `json:\"expiry_date\" gorm:\"column:expiry_date\"`\n\tStatus     string    `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt  time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt  time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "TableNamePrescriptionDiscounts",
        "code_value": "const TableNamePrescriptionDiscounts = \"prescription_discounts\""
      },
      {
        "code_key": "DiscountStatus",
        "code_value": "const (\n\tDiscountStatusActive   = \"ACTIVE\"\n\tDiscountStatusExpired  = \"EXPIRED\"\n\tDiscountStatusPending  = \"PENDING\"\n\tDiscountStatusArchived = \"ARCHIVED\"\n)"
      },
      {
        "code_key": "PharmacyDBInstance",
        "code_value": "var PharmacyDBInstance *gorm.DB"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CalculateDiscount",
    "orm_code": "func (p *Prescription) CalculateDiscount(filterParams map[string]interface{}) ([]types.MedicineDiscount, error) {\n\tvar discounts []types.MedicineDiscount\n\tdb := base.GetInstance().PharmacyDB().Table(\"prescription_discounts\")\n\n\tif medicineType, ok := filterParams[\"MedicineType\"]; ok {\n\t\t// Exact match for MedicineType combined with date range\n\t\tstartDate := filterParams[\"StartDate\"].(string)\n\t\tendDate := filterParams[\"EndDate\"].(string)\n\t\treturn discounts, db.Where(\"medicine_type = ? AND valid_from <= ? AND valid_to >= ?\", \n\t\t\tmedicineType, startDate, endDate).Find(&discounts).Error\n\t} else {\n\t\t// Range query based on discount percentage\n\t\tminDiscount := filterParams[\"MinDiscount\"].(float64)\n\t\tmaxDiscount := filterParams[\"MaxDiscount\"].(float64)\n\t\treturn discounts, db.Where(\"discount_percentage BETWEEN ? AND ?\", \n\t\t\tminDiscount, maxDiscount).Order(\"medicine_name\").Find(&discounts).Error\n\t}\n}",
    "caller": "func (s *DiscountService) HandleMedicineDiscount(req *types.DiscountRequest) ([]types.MedicineDiscount, error) {\n\tfilterParams := make(map[string]interface{})\n\t\n\tif req.MedicineType != \"\" {\n\t\tif req.StartDate == \"\" || req.EndDate == \"\" {\n\t\t\treturn nil, errors.New(\"date range required for medicine type query\")\n\t\t}\n\t\tfilterParams[\"MedicineType\"] = req.MedicineType\n\t\tfilterParams[\"StartDate\"] = req.StartDate\n\t\tfilterParams[\"EndDate\"] = req.EndDate\n\t} else if req.MinDiscount > 0 || req.MaxDiscount > 0 {\n\t\tif req.MinDiscount < 0 || req.MaxDiscount > 100 {\n\t\t\treturn nil, errors.New(\"invalid discount range\")\n\t\t}\n\t\tfilterParams[\"MinDiscount\"] = req.MinDiscount\n\t\tfilterParams[\"MaxDiscount\"] = req.MaxDiscount\n\t} else if req.MedicineName != \"\" {\n\t\tfilterParams[\"MedicineType\"] = req.MedicineName\n\t\tfilterParams[\"StartDate\"] = \"1970-01-01\"\n\t\tfilterParams[\"EndDate\"] = \"2100-01-01\"\n\t} else {\n\t\treturn nil, errors.New(\"no valid filter parameters provided\")\n\t}\n\t\n\tprescription := &Prescription{}\n\treturn prescription.CalculateDiscount(filterParams)\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按药品类型和时间范围查询",
            "sql": "SELECT id, medicine_type, medicine_name, discount_percentage, valid_from, valid_to, created_at, updated_at FROM prescription_discounts WHERE medicine_type = ? AND valid_from <= ? AND valid_to >= ?;"
          },
          {
            "scenario": "按折扣百分比范围查询（带排序）",
            "sql": "SELECT id, medicine_type, medicine_name, discount_percentage, valid_from, valid_to, created_at, updated_at FROM prescription_discounts WHERE discount_percentage BETWEEN ? AND ? ORDER BY medicine_name;"
          },
          {
            "scenario": "按药品名称查询（特殊处理，使用medicine_type字段和极宽时间范围）",
            "sql": "SELECT id, medicine_type, medicine_name, discount_percentage, valid_from, valid_to, created_at, updated_at FROM prescription_discounts WHERE medicine_type = ? AND valid_from <= ? AND valid_to >= ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "MedicineDiscount",
        "code_value": "type MedicineDiscount struct {\n\tID                int     `json:\"id\" gorm:\"column:id\"`\n\tMedicineType      string  `json:\"medicine_type\" gorm:\"column:medicine_type\"`\n\tMedicineName      string  `json:\"medicine_name\" gorm:\"column:medicine_name\"`\n\tDiscountPercentage float64 `json:\"discount_percentage\" gorm:\"column:discount_percentage\"`\n\tValidFrom         string  `json:\"valid_from\" gorm:\"column:valid_from\"`\n\tValidTo           string  `json:\"valid_to\" gorm:\"column:valid_to\"`\n\tCreatedAt         int64   `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt         int64   `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "Prescription",
        "code_value": "type Prescription struct {\n\tID         int       `json:\"id\" gorm:\"column:id\"`\n\tPatientID  string    `json:\"patient_id\" gorm:\"column:patient_id\"`\n\tDoctorID   string    `json:\"doctor_id\" gorm:\"column:doctor_id\"`\n\tIssueDate  time.Time `json:\"issue_date\" gorm:\"column:issue_date\"`\n\tExpiryDate time.Time `json:\"expiry_date\" gorm:\"column:expiry_date\"`\n\tStatus     string    `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt  time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt  time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "TableNamePrescriptionDiscounts",
        "code_value": "const TableNamePrescriptionDiscounts = \"prescription_discounts\""
      },
      {
        "code_key": "DiscountStatus",
        "code_value": "const (\n\tDiscountStatusActive   = \"ACTIVE\"\n\tDiscountStatusExpired  = \"EXPIRED\"\n\tDiscountStatusPending  = \"PENDING\"\n\tDiscountStatusArchived = \"ARCHIVED\"\n)"
      },
      {
        "code_key": "PharmacyDBInstance",
        "code_value": "var PharmacyDBInstance *gorm.DB"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CalculateDiscount",
    "orm_code": "func (p *Prescription) CalculateDiscount(filterParams map[string]interface{}) ([]types.MedicineDiscount, error) {\n\tvar discounts []types.MedicineDiscount\n\tdb := base.GetInstance().PharmacyDB().Table(\"prescription_discounts\")\n\n\tif medicineType, ok := filterParams[\"MedicineType\"]; ok {\n\t\t// Exact match for MedicineType combined with date range\n\t\tstartDate := filterParams[\"StartDate\"].(string)\n\t\tendDate := filterParams[\"EndDate\"].(string)\n\t\treturn discounts, db.Where(\"medicine_type = ? AND valid_from <= ? AND valid_to >= ?\", \n\t\t\tmedicineType, startDate, endDate).Find(&discounts).Error\n\t} else {\n\t\t// Range query based on discount percentage\n\t\tminDiscount := filterParams[\"MinDiscount\"].(float64)\n\t\tmaxDiscount := filterParams[\"MaxDiscount\"].(float64)\n\t\treturn discounts, db.Where(\"discount_percentage BETWEEN ? AND ?\", \n\t\t\tminDiscount, maxDiscount).Order(\"medicine_name\").Find(&discounts).Error\n\t}\n}",
    "caller": "func (s *DiscountService) HandleDiscountCalculation(request *types.DiscountRequest, log *logger.AppLog) ([]types.DiscountRate, error) {\n\tif request == nil {\n\t\tlog.Error(\"nil request parameter\")\n\t\treturn nil, errors.New(\"invalid request\")\n\t}\n\n\tfilterParams := make(map[string]interface{})\n\tif request.MinBalanceThreshold > 0 {\n\t\tfilterParams[\"min_balance\"] = request.MinBalanceThreshold\n\t} else if request.MaxDurationDays > 0 {\n\t\tfilterParams[\"max_duration\"] = request.MaxDurationDays\n\t} else if len(request.SearchKeyword) > 0 {\n\t\tfilterParams[\"search_term\"] = request.SearchKeyword\n\t} else {\n\t\tfilterParams[\"status\"] = \"pending\"\n\t}\n\n\tproposal := &Proposal{ClientID: request.ClientID}\n\tdiscountRates, err := proposal.CalculateDiscount(filterParams)\n\tif err != nil {\n\t\tlog.Errorf(\"failed to calculate discounts: %v\", err)\n\t\treturn nil, fmt.Errorf(\"calculation error: %w\", err)\n\t}\n\n\tif len(discountRates) == 0 {\n\t\tlog.Warn(\"no discount rates found for given criteria\")\n\t}\n\treturn discountRates, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "min_balance条件",
            "sql": "SELECT id, case_number, balance, duration_days, access_level, status, notes, rate_value, created_at, updated_at FROM expense_reports WHERE balance >= ? AND access_level IN ? ORDER BY case_number DESC;"
          },
          {
            "scenario": "max_duration条件",
            "sql": "SELECT id, case_number, balance, duration_days, access_level, status, notes, rate_value, created_at, updated_at FROM expense_reports WHERE duration_days <= ? AND status = ? ORDER BY balance ASC;"
          },
          {
            "scenario": "search_term条件",
            "sql": "SELECT id, case_number, balance, duration_days, access_level, status, notes, rate_value, created_at, updated_at FROM expense_reports WHERE notes LIKE ? LIMIT 50;"
          },
          {
            "scenario": "默认条件（status=pending）",
            "sql": "SELECT id, case_number, balance, duration_days, access_level, status, notes, rate_value, created_at, updated_at FROM expense_reports WHERE status = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "MedicineDiscount",
        "code_value": "type MedicineDiscount struct {\n\tID                int     `json:\"id\" gorm:\"column:id\"`\n\tMedicineType      string  `json:\"medicine_type\" gorm:\"column:medicine_type\"`\n\tMedicineName      string  `json:\"medicine_name\" gorm:\"column:medicine_name\"`\n\tDiscountPercentage float64 `json:\"discount_percentage\" gorm:\"column:discount_percentage\"`\n\tValidFrom         string  `json:\"valid_from\" gorm:\"column:valid_from\"`\n\tValidTo           string  `json:\"valid_to\" gorm:\"column:valid_to\"`\n\tCreatedAt         int64   `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt         int64   `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "Prescription",
        "code_value": "type Prescription struct {\n\tID         int       `json:\"id\" gorm:\"column:id\"`\n\tPatientID  string    `json:\"patient_id\" gorm:\"column:patient_id\"`\n\tDoctorID   string    `json:\"doctor_id\" gorm:\"column:doctor_id\"`\n\tIssueDate  time.Time `json:\"issue_date\" gorm:\"column:issue_date\"`\n\tExpiryDate time.Time `json:\"expiry_date\" gorm:\"column:expiry_date\"`\n\tStatus     string    `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt  time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt  time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "TableNamePrescriptionDiscounts",
        "code_value": "const TableNamePrescriptionDiscounts = \"prescription_discounts\""
      },
      {
        "code_key": "DiscountStatus",
        "code_value": "const (\n\tDiscountStatusActive   = \"ACTIVE\"\n\tDiscountStatusExpired  = \"EXPIRED\"\n\tDiscountStatusPending  = \"PENDING\"\n\tDiscountStatusArchived = \"ARCHIVED\"\n)"
      },
      {
        "code_key": "PharmacyDBInstance",
        "code_value": "var PharmacyDBInstance *gorm.DB"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "GetByStatus",
    "orm_code": "func (i *Image) GetByStatus(filterParams map[string]interface{}, page, size int) ([]types.ImageRecord, error) {\n\tvar results []types.ImageRecord\n\tdb := base.GetInstance().MainDB().Table(\"progress_tracking\")\n\n\tif dimension, ok := filterParams[\"Dimension\"]; ok {\n\t\t// Range query for dimension\n\t\tdb = db.Where(\"dimension BETWEEN ? AND ?\", dimension.(float64)-0.5, dimension.(float64)+0.5)\n\t\tdelete(filterParams, \"Dimension\")\n\t}\n\n\tif len(filterParams) > 0 {\n\t\tdb = db.Where(filterParams)\n\t}\n\n\terr := db.Scopes(PaginateDB(page, size)).Order(\"created_at DESC\").Find(&results).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.RecordNotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "只有Dimension条件",
            "sql": "SELECT * FROM progress_tracking WHERE dimension BETWEEN 9.5 AND 10.5 ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "只有其他字段条件(如status)",
            "sql": "SELECT * FROM progress_tracking WHERE status = 'PENDING' ORDER BY created_at DESC LIMIT 10 OFFSET 10;"
          },
          {
            "scenario": "Dimension和其他字段条件组合",
            "sql": "SELECT * FROM progress_tracking WHERE dimension BETWEEN 14.5 AND 15.5 AND status = 'APPROVED' AND app_id = 123 ORDER BY created_at DESC LIMIT 15 OFFSET 30;"
          },
          {
            "scenario": "无条件查询",
            "sql": "SELECT * FROM progress_tracking ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ImageRecord",
        "code_value": "type ImageRecord struct {\n\tID          uint      json:\"id\" gorm:\"column:id;primaryKey\"\n\tDimension   float64   json:\"dimension\" gorm:\"column:dimension\"\n\tStatus      string    json:\"status\" gorm:\"column:status\"\n\tCreatedAt   time.Time json:\"created_at\" gorm:\"column:created_at\"\n\tUpdatedAt   time.Time json:\"updated_at\" gorm:\"column:updated_at\"\n}"
      },
      {
        "code_key": "FilterParams",
        "code_value": "type FilterParams struct {\n\tDimension *float64 \n\tStatus    string   \n\tAppID     int      \n}"
      },
      {
        "code_key": "TableProgressTracking",
        "code_value": "const TableProgressTracking = \"progress_tracking\""
      },
      {
        "code_key": "ImageStatus",
        "code_value": "const (\n\tImageStatusPending   = \"PENDING\"\n\tImageStatusApproved = \"APPROVED\"\n\tImageStatusRejected = \"REJECTED\"\n)"
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "GetByStatus",
    "orm_code": "func (i *Image) GetByStatus(filterParams map[string]interface{}, page, size int) ([]types.ImageRecord, error) {\n\tvar results []types.ImageRecord\n\tdb := base.GetInstance().MainDB().Table(\"progress_tracking\")\n\n\tif dimension, ok := filterParams[\"Dimension\"]; ok {\n\t\t// Range query for dimension\n\t\tdb = db.Where(\"dimension BETWEEN ? AND ?\", dimension.(float64)-0.5, dimension.(float64)+0.5)\n\t\tdelete(filterParams, \"Dimension\")\n\t}\n\n\tif len(filterParams) > 0 {\n\t\tdb = db.Where(filterParams)\n\t}\n\n\terr := db.Scopes(PaginateDB(page, size)).Order(\"created_at DESC\").Find(&results).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.RecordNotFoundError\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}",
    "caller": "func (h *ImageHandler) HandleImageSearch(req *types.ImageSearchRequest, log *logger.AppLog) ([]types.ImageRecord, error) {\n\tfilterParams := make(map[string]interface{})\n\n\tif req.Status != \"\" {\n\t\tif !utils.IsValidStatus(req.Status) {\n\t\t\tlog.Error(\"Invalid status parameter\")\n\t\t\treturn nil, utils.InvalidParamError\n\t\t}\n\t\tfilterParams[\"status\"] = req.Status\n\t} else if req.UserID > 0 {\n\t\tfilterParams[\"user_id\"] = req.UserID\n\t} else if req.Category != \"\" {\n\t\tif len(req.Category) > 50 {\n\t\t\tlog.Error(\"Category name too long\")\n\t\t\treturn nil, utils.InvalidParamError\n\t\t}\n\t\tfilterParams[\"category\"] = req.Category\n\t} else {\n\t\treturn nil, utils.MissingParamError\n\t}\n\n\tif req.Dimension > 0 {\n\t\tfilterParams[\"Dimension\"] = req.Dimension\n\t}\n\n\timg := &Image{}\n\tpage, size := utils.GetPagination(req.Page, req.Size)\n\tresults, err := img.GetByStatus(filterParams, page, size)\n\tif err != nil {\n\t\tlog.Errorf(\"Failed to get images: %v\", err)\n\t\treturn nil, err\n\t}\n\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "仅Status参数",
            "sql": "SELECT id, dimension, status, created_at, updated_at FROM progress_tracking WHERE status = 'PENDING' ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "仅UserID参数",
            "sql": "SELECT id, dimension, status, created_at, updated_at FROM progress_tracking WHERE user_id = 123 ORDER BY created_at DESC LIMIT 10 OFFSET 10;"
          },
          {
            "scenario": "仅Category参数",
            "sql": "SELECT id, dimension, status, created_at, updated_at FROM progress_tracking WHERE category = 'nature' ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "仅Dimension参数（范围查询）",
            "sql": "SELECT id, dimension, status, created_at, updated_at FROM progress_tracking WHERE dimension BETWEEN 10.0 AND 11.0 ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "Status和Dimension组合",
            "sql": "SELECT id, dimension, status, created_at, updated_at FROM progress_tracking WHERE dimension BETWEEN 5.0 AND 6.0 AND status = 'APPROVED' ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "UserID和Dimension组合",
            "sql": "SELECT id, dimension, status, created_at, updated_at FROM progress_tracking WHERE dimension BETWEEN 6.7 AND 7.7 AND user_id = 456 ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ImageRecord",
        "code_value": "type ImageRecord struct {\n\tID          uint      json:\"id\" gorm:\"column:id;primaryKey\"\n\tDimension   float64   json:\"dimension\" gorm:\"column:dimension\"\n\tStatus      string    json:\"status\" gorm:\"column:status\"\n\tCreatedAt   time.Time json:\"created_at\" gorm:\"column:created_at\"\n\tUpdatedAt   time.Time json:\"updated_at\" gorm:\"column:updated_at\"\n}"
      },
      {
        "code_key": "FilterParams",
        "code_value": "type FilterParams struct {\n\tDimension *float64 \n\tStatus    string   \n\tAppID     int      \n}"
      },
      {
        "code_key": "TableProgressTracking",
        "code_value": "const TableProgressTracking = \"progress_tracking\""
      },
      {
        "code_key": "ImageStatus",
        "code_value": "const (\n\tImageStatusPending   = \"PENDING\"\n\tImageStatusApproved = \"APPROVED\"\n\tImageStatusRejected = \"REJECTED\"\n)"
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ProcessPayment",
    "orm_code": "func (i *Insurance) ProcessPayment(filterParams map[string]interface{}) ([]types.InsurancePolicy, error) {\n\tvar policies []types.InsurancePolicy\n\tquery := base.GetInstance().DB().Table(\"insurance_policies\")\n\n\tif policyNum, ok := filterParams[\"policy_number\"]; ok {\n\t\t// Exact match for policy number\n\t\tquery = query.Where(\"policy_number = ?\", policyNum)\n\t} else if clientID, ok := filterParams[\"client_id\"]; ok {\n\t\t// Range query for payment date when clientID is provided\n\t\tif startDate, dateOk := filterParams[\"start_date\"]; dateOk {\n\t\t\tquery = query.Where(\"client_id = ? AND payment_date >= ?\", clientID, startDate)\n\t\t} else {\n\t\t\tquery = query.Where(\"client_id = ?\", clientID)\n\t\t}\n\t} else {\n\t\t// Default query for unpaid policies\n\t\tquery = query.Where(\"payment_status = ?\", \"unpaid\")\n\t}\n\n\tif err := query.Find(&policies).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn policies, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "filterParams contains District key",
            "sql": "SELECT id, transaction_id, amount, district, api_key, activation_date, created_at, updated_at FROM player_profiles WHERE district = ? LIMIT ?;"
          },
          {
            "scenario": "filterParams contains ApiKey key",
            "sql": "SELECT id, transaction_id, amount, district, api_key, activation_date, created_at, updated_at FROM player_profiles WHERE api_key LIKE ? LIMIT ?;"
          },
          {
            "scenario": "filterParams contains ActivationDate key",
            "sql": "SELECT id, transaction_id, amount, district, api_key, activation_date, created_at, updated_at FROM player_profiles WHERE activation_date > ? LIMIT ?;"
          },
          {
            "scenario": "filterParams contains other keys",
            "sql": "SELECT id, transaction_id, amount, district, api_key, activation_date, created_at, updated_at FROM player_profiles WHERE /* condition depends on filterParams content */ LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "InsurancePolicy",
        "code_value": "type InsurancePolicy struct {\n\tID            uint      `gorm:\"column:id;primaryKey\"`\n\tPolicyNumber  string    `gorm:\"column:policy_number;uniqueIndex\"`\n\tClientID      uint      `gorm:\"column:client_id;index\"`\n\tPaymentDate   time.Time `gorm:\"column:payment_date\"`\n\tPaymentStatus string    `gorm:\"column:payment_status;default:'unpaid'\"`\n\tPremiumAmount float64   `gorm:\"column:premium_amount\"`\n\tCreatedAt     time.Time `gorm:\"column:created_at;autoCreateTime\"`\n\tUpdatedAt     time.Time `gorm:\"column:updated_at;autoUpdateTime\"`\n}"
      },
      {
        "code_key": "PaymentStatus",
        "code_value": "const (\n\tPaymentStatusUnpaid  = \"unpaid\"\n\tPaymentStatusPending = \"pending\"\n\tPaymentStatusPaid    = \"paid\"\n)"
      },
      {
        "code_key": "InsuranceFilterParams",
        "code_value": "type InsuranceFilterParams struct {\n\tPolicyNumber *string    `json:\"policy_number\"`\n\tClientID     *uint      `json:\"client_id\"`\n\tStartDate    *time.Time `json:\"start_date\"`\n}"
      },
      {
        "code_key": "Client",
        "code_value": "type Client struct {\n\tID        uint      `gorm:\"column:id;primaryKey\"`\n\tName      string    `gorm:\"column:name\"`\n\tEmail     string    `gorm:\"column:email;uniqueIndex\"`\n\tCreatedAt time.Time `gorm:\"column:created_at;autoCreateTime\"`\n\tUpdatedAt time.Time `gorm:\"column:updated_at;autoUpdateTime\"`\n}"
      },
      {
        "code_key": "TableNameInsurancePolicies",
        "code_value": "const TableNameInsurancePolicies = \"insurance_policies\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ProcessPayment",
    "orm_code": "func (i *Insurance) ProcessPayment(filterParams map[string]interface{}) ([]types.InsurancePolicy, error) {\n\tvar policies []types.InsurancePolicy\n\tquery := base.GetInstance().DB().Table(\"insurance_policies\")\n\n\tif policyNum, ok := filterParams[\"policy_number\"]; ok {\n\t\t// Exact match for policy number\n\t\tquery = query.Where(\"policy_number = ?\", policyNum)\n\t} else if clientID, ok := filterParams[\"client_id\"]; ok {\n\t\t// Range query for payment date when clientID is provided\n\t\tif startDate, dateOk := filterParams[\"start_date\"]; dateOk {\n\t\t\tquery = query.Where(\"client_id = ? AND payment_date >= ?\", clientID, startDate)\n\t\t} else {\n\t\t\tquery = query.Where(\"client_id = ?\", clientID)\n\t\t}\n\t} else {\n\t\t// Default query for unpaid policies\n\t\tquery = query.Where(\"payment_status = ?\", \"unpaid\")\n\t}\n\n\tif err := query.Find(&policies).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn policies, nil\n}",
    "caller": "func (s *BonusService) HandleEmployeeBonus(req *types.BonusRequest) ([]types.BonusRecord, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.EmployeeID != \"\" {\n\t\tfilter[\"employee_id\"] = req.EmployeeID\n\t} else if req.Department != \"\" {\n\t\tif req.Quarter > 0 {\n\t\t\tfilter[\"department\"] = req.Department\n\t\t\tfilter[\"quarter\"] = req.Quarter\n\t\t} else {\n\t\t\tfilter[\"department\"] = req.Department\n\t\t}\n\t} else if req.Status != \"\" {\n\t\tif !utils.IsValidBonusStatus(req.Status) {\n\t\t\treturn nil, fmt.Errorf(\"invalid bonus status: %s\", req.Status)\n\t\t}\n\t\tfilter[\"status\"] = req.Status\n\t} else {\n\t\tfilter[\"year\"] = time.Now().Year()\n\t}\n\n\tbonus := &models.Bonus{}\n\trecords, err := bonus.ProcessPayment(filter)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to process bonus: %v\", err)\n\t}\n\treturn records, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Default query when no matching parameters are provided",
            "sql": "SELECT id, policy_number, client_id, payment_date, payment_status, premium_amount, created_at, updated_at FROM insurance_policies WHERE payment_status = 'unpaid';"
          },
          {
            "scenario": "Query with policy_number parameter",
            "sql": "SELECT id, policy_number, client_id, payment_date, payment_status, premium_amount, created_at, updated_at FROM insurance_policies WHERE policy_number = ?;"
          },
          {
            "scenario": "Query with client_id and start_date parameters",
            "sql": "SELECT id, policy_number, client_id, payment_date, payment_status, premium_amount, created_at, updated_at FROM insurance_policies WHERE client_id = ? AND payment_date >= ?;"
          },
          {
            "scenario": "Query with client_id parameter only",
            "sql": "SELECT id, policy_number, client_id, payment_date, payment_status, premium_amount, created_at, updated_at FROM insurance_policies WHERE client_id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "InsurancePolicy",
        "code_value": "type InsurancePolicy struct {\n\tID            uint      `gorm:\"column:id;primaryKey\"`\n\tPolicyNumber  string    `gorm:\"column:policy_number;uniqueIndex\"`\n\tClientID      uint      `gorm:\"column:client_id;index\"`\n\tPaymentDate   time.Time `gorm:\"column:payment_date\"`\n\tPaymentStatus string    `gorm:\"column:payment_status;default:'unpaid'\"`\n\tPremiumAmount float64   `gorm:\"column:premium_amount\"`\n\tCreatedAt     time.Time `gorm:\"column:created_at;autoCreateTime\"`\n\tUpdatedAt     time.Time `gorm:\"column:updated_at;autoUpdateTime\"`\n}"
      },
      {
        "code_key": "PaymentStatus",
        "code_value": "const (\n\tPaymentStatusUnpaid  = \"unpaid\"\n\tPaymentStatusPending = \"pending\"\n\tPaymentStatusPaid    = \"paid\"\n)"
      },
      {
        "code_key": "InsuranceFilterParams",
        "code_value": "type InsuranceFilterParams struct {\n\tPolicyNumber *string    `json:\"policy_number\"`\n\tClientID     *uint      `json:\"client_id\"`\n\tStartDate    *time.Time `json:\"start_date\"`\n}"
      },
      {
        "code_key": "Client",
        "code_value": "type Client struct {\n\tID        uint      `gorm:\"column:id;primaryKey\"`\n\tName      string    `gorm:\"column:name\"`\n\tEmail     string    `gorm:\"column:email;uniqueIndex\"`\n\tCreatedAt time.Time `gorm:\"column:created_at;autoCreateTime\"`\n\tUpdatedAt time.Time `gorm:\"column:updated_at;autoUpdateTime\"`\n}"
      },
      {
        "code_key": "TableNameInsurancePolicies",
        "code_value": "const TableNameInsurancePolicies = \"insurance_policies\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ProcessPayment",
    "orm_code": "func (i *Insurance) ProcessPayment(filterParams map[string]interface{}) ([]types.InsurancePolicy, error) {\n\tvar policies []types.InsurancePolicy\n\tquery := base.GetInstance().DB().Table(\"insurance_policies\")\n\n\tif policyNum, ok := filterParams[\"policy_number\"]; ok {\n\t\t// Exact match for policy number\n\t\tquery = query.Where(\"policy_number = ?\", policyNum)\n\t} else if clientID, ok := filterParams[\"client_id\"]; ok {\n\t\t// Range query for payment date when clientID is provided\n\t\tif startDate, dateOk := filterParams[\"start_date\"]; dateOk {\n\t\t\tquery = query.Where(\"client_id = ? AND payment_date >= ?\", clientID, startDate)\n\t\t} else {\n\t\t\tquery = query.Where(\"client_id = ?\", clientID)\n\t\t}\n\t} else {\n\t\t// Default query for unpaid policies\n\t\tquery = query.Where(\"payment_status = ?\", \"unpaid\")\n\t}\n\n\tif err := query.Find(&policies).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn policies, nil\n}",
    "caller": "func (s *PaymentService) HandlePaymentRecords(req *types.PaymentRequest, logger *log.Logger) ([]types.PaymentRecord, error) {\n\tif req.PageSize <= 0 {\n\t\treturn nil, fmt.Errorf(\"invalid page size: %d\", req.PageSize)\n\t}\n\n\tfilters := make(map[string]interface{})\n\tif req.District != \"\" {\n\t\tfilters[\"District\"] = req.District\n\t} else if req.ApiKey != \"\" {\n\t\tfilters[\"ApiKey\"] = req.ApiKey\n\t} else if !req.SinceDate.IsZero() {\n\t\tfilters[\"ActivationDate\"] = req.SinceDate\n\t} else {\n\t\tfilters[\"status\"] = \"active\"\n\t}\n\n\tinvoice := &Invoice{}\n\trecords, err := invoice.ProcessPayment(filters, req.PageSize)\n\tif err != nil {\n\t\tlogger.Printf(\"Failed to process payments: %v\", err)\n\t\treturn nil, fmt.Errorf(\"payment processing failed: %w\", err)\n\t}\n\n\tif len(records) == 0 {\n\t\tlogger.Println(\"No payment records found\")\n\t}\n\treturn records, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "District condition (e.g. 'NY')",
            "sql": "SELECT id, transaction_id, amount, district, api_key, activation_date, created_at, updated_at FROM player_profiles WHERE district = 'NY' LIMIT ?;"
          },
          {
            "scenario": "ApiKey condition (e.g. 'ABC123')",
            "sql": "SELECT id, transaction_id, amount, district, api_key, activation_date, created_at, updated_at FROM player_profiles WHERE api_key LIKE '%ABC123%' LIMIT ?;"
          },
          {
            "scenario": "ActivationDate condition (e.g. '2023-01-01 00:00:00')",
            "sql": "SELECT id, transaction_id, amount, district, api_key, activation_date, created_at, updated_at FROM player_profiles WHERE activation_date > '2023-01-01 00:00:00' LIMIT ?;"
          },
          {
            "scenario": "Default condition (status = 'active')",
            "sql": "SELECT id, transaction_id, amount, district, api_key, activation_date, created_at, updated_at FROM player_profiles WHERE status = 'active' LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "InsurancePolicy",
        "code_value": "type InsurancePolicy struct {\n\tID            uint      `gorm:\"column:id;primaryKey\"`\n\tPolicyNumber  string    `gorm:\"column:policy_number;uniqueIndex\"`\n\tClientID      uint      `gorm:\"column:client_id;index\"`\n\tPaymentDate   time.Time `gorm:\"column:payment_date\"`\n\tPaymentStatus string    `gorm:\"column:payment_status;default:'unpaid'\"`\n\tPremiumAmount float64   `gorm:\"column:premium_amount\"`\n\tCreatedAt     time.Time `gorm:\"column:created_at;autoCreateTime\"`\n\tUpdatedAt     time.Time `gorm:\"column:updated_at;autoUpdateTime\"`\n}"
      },
      {
        "code_key": "PaymentStatus",
        "code_value": "const (\n\tPaymentStatusUnpaid  = \"unpaid\"\n\tPaymentStatusPending = \"pending\"\n\tPaymentStatusPaid    = \"paid\"\n)"
      },
      {
        "code_key": "InsuranceFilterParams",
        "code_value": "type InsuranceFilterParams struct {\n\tPolicyNumber *string    `json:\"policy_number\"`\n\tClientID     *uint      `json:\"client_id\"`\n\tStartDate    *time.Time `json:\"start_date\"`\n}"
      },
      {
        "code_key": "Client",
        "code_value": "type Client struct {\n\tID        uint      `gorm:\"column:id;primaryKey\"`\n\tName      string    `gorm:\"column:name\"`\n\tEmail     string    `gorm:\"column:email;uniqueIndex\"`\n\tCreatedAt time.Time `gorm:\"column:created_at;autoCreateTime\"`\n\tUpdatedAt time.Time `gorm:\"column:updated_at;autoUpdateTime\"`\n}"
      },
      {
        "code_key": "TableNameInsurancePolicies",
        "code_value": "const TableNameInsurancePolicies = \"insurance_policies\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ScheduleDelivery",
    "orm_code": "func (t *Textbook) ScheduleDelivery(filterParams map[string]interface{}) ([]types.Chapter, error) {\n\tvar chapters []types.Chapter\n\tdb := base.GetInstance().GormDriver().Table(\"subscription_tiers\")\n\n\tif language, ok := filterParams[\"Language\"]; ok {\n\t\tif region, ok := filterParams[\"RegionCode\"]; ok {\n\t\t\tdb = db.Where(\"language = ? AND region_code = ?\", language.(string), region.(string))\n\t\t} else {\n\t\t\tdb = db.Where(\"language like ?\", \"%\"+language.(string)+\"%\")\n\t\t}\n\t} else if street, ok := filterParams[\"Street\"]; ok {\n\t\tdb = db.Where(\"delivery_address like ?\", \"%\"+street.(string)+\"%\")\n\t}\n\n\tif err := db.Order(\"created_at desc\").Find(&chapters).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn chapters, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "zone_id condition",
            "sql": "SELECT id, zone_id, priority, contact_info, delivery_date, created_at, updated_at FROM delivery_zones WHERE zone_id = ? LIMIT ?;"
          },
          {
            "scenario": "priority_level condition",
            "sql": "SELECT id, zone_id, priority, contact_info, delivery_date, created_at, updated_at FROM delivery_zones WHERE priority >= ? ORDER BY priority DESC LIMIT ?;"
          },
          {
            "scenario": "contact_info condition",
            "sql": "SELECT id, zone_id, priority, contact_info, delivery_date, created_at, updated_at FROM delivery_zones WHERE contact_info LIKE ? LIMIT ?;"
          },
          {
            "scenario": "other filter conditions",
            "sql": "SELECT id, zone_id, priority, contact_info, delivery_date, created_at, updated_at FROM delivery_zones WHERE priority = ? AND delivery_date = ? LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "Chapter",
        "code_value": "type Chapter struct {\n\tID          int       `json:\"id\" gorm:\"column:id\"`\n\tTitle       string    `json:\"title\" gorm:\"column:title\"`\n\tContent     string    `json:\"content\" gorm:\"column:content\"`\n\tLanguage    string    `json:\"language\" gorm:\"column:language\"`\n\tRegionCode  string    `json:\"region_code\" gorm:\"column:region_code\"`\n\tDeliveryAddress string `json:\"delivery_address\" gorm:\"column:delivery_address\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "Textbook",
        "code_value": "type Textbook struct {\n\tID        int       `json:\"id\" gorm:\"column:id\"`\n\tISBN      string    `json:\"isbn\" gorm:\"column:isbn\"`\n\tTitle     string    `json:\"title\" gorm:\"column:title\"`\n\tAuthor    string    `json:\"author\" gorm:\"column:author\"`\n\tPublished time.Time `json:\"published\" gorm:\"column:published\"`\n}"
      },
      {
        "code_key": "SubscriptionTier",
        "code_value": "type SubscriptionTier struct {\n\tID          int    `json:\"id\" gorm:\"column:id\"`\n\tName        string `json:\"name\" gorm:\"column:name\"`\n\tDescription string `json:\"description\" gorm:\"column:description\"`\n\tPriority    int    `json:\"priority\" gorm:\"column:priority\"`\n}"
      },
      {
        "code_key": "DeliveryStatus",
        "code_value": "const (\n\tPendingStatus   = \"pending\"\n\tShippedStatus   = \"shipped\"\n\tDeliveredStatus = \"delivered\"\n\tCancelledStatus = \"cancelled\"\n)"
      },
      {
        "code_key": "MaxDeliveryAttempts",
        "code_value": "const MaxDeliveryAttempts = 3"
      },
      {
        "code_key": "SupportedLanguages",
        "code_value": "var SupportedLanguages = []string{\"en\", \"es\", \"fr\", \"de\", \"ja\"}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ScheduleDelivery",
    "orm_code": "func (t *Textbook) ScheduleDelivery(filterParams map[string]interface{}) ([]types.Chapter, error) {\n\tvar chapters []types.Chapter\n\tdb := base.GetInstance().GormDriver().Table(\"subscription_tiers\")\n\n\tif language, ok := filterParams[\"Language\"]; ok {\n\t\tif region, ok := filterParams[\"RegionCode\"]; ok {\n\t\t\tdb = db.Where(\"language = ? AND region_code = ?\", language.(string), region.(string))\n\t\t} else {\n\t\t\tdb = db.Where(\"language like ?\", \"%\"+language.(string)+\"%\")\n\t\t}\n\t} else if street, ok := filterParams[\"Street\"]; ok {\n\t\tdb = db.Where(\"delivery_address like ?\", \"%\"+street.(string)+\"%\")\n\t}\n\n\tif err := db.Order(\"created_at desc\").Find(&chapters).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn chapters, nil\n}",
    "caller": "func (m *MaterialHandler) HandleCourseDelivery(req *types.CourseDeliveryRequest) ([]types.Chapter, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.CourseID != \"\" {\n\t\tfilter[\"Language\"] = req.Language\n\t\tfilter[\"RegionCode\"] = req.Region\n\t} else if req.Address != \"\" {\n\t\tfilter[\"Street\"] = req.Address\n\t} else if req.Status != 0 {\n\t\tif req.Status == types.ExpressDelivery {\n\t\t\tfilter[\"Language\"] = \"en\"\n\t\t} else {\n\t\t\tfilter[\"Language\"] = req.Language\n\t\t}\n\t} else {\n\t\treturn nil, errors.New(\"invalid delivery parameters\")\n\t}\n\n\ttextbook := &Textbook{}\n\tchapters, err := textbook.ScheduleDelivery(filter)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to schedule delivery: %v\", err)\n\t}\n\t\n\tif len(chapters) == 0 {\n\t\treturn nil, errors.New(\"no chapters found\")\n\t}\n\t\n\treturn chapters, nil\n}",
    "sql_statement_list": [
      {
        "type": "LACK_INFORMATION",
        "variants": [
          {
            "scenario": "查询表(subscription_tiers)与结果映射(Chapter)不匹配",
            "sql": "SELECT * FROM subscription_tiers WHERE language = ? AND region_code = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "查询表(subscription_tiers)与结果映射(Chapter)不匹配",
            "sql": "SELECT * FROM subscription_tiers WHERE delivery_address LIKE ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "查询表(subscription_tiers)与结果映射(Chapter)不匹配",
            "sql": "SELECT * FROM subscription_tiers WHERE language = 'en' ORDER BY created_at DESC;"
          },
          {
            "scenario": "查询表(subscription_tiers)与结果映射(Chapter)不匹配",
            "sql": "SELECT * FROM subscription_tiers WHERE language LIKE ? ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Chapter",
        "code_value": "type Chapter struct {\n\tID          int       `json:\"id\" gorm:\"column:id\"`\n\tTitle       string    `json:\"title\" gorm:\"column:title\"`\n\tContent     string    `json:\"content\" gorm:\"column:content\"`\n\tLanguage    string    `json:\"language\" gorm:\"column:language\"`\n\tRegionCode  string    `json:\"region_code\" gorm:\"column:region_code\"`\n\tDeliveryAddress string `json:\"delivery_address\" gorm:\"column:delivery_address\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "Textbook",
        "code_value": "type Textbook struct {\n\tID        int       `json:\"id\" gorm:\"column:id\"`\n\tISBN      string    `json:\"isbn\" gorm:\"column:isbn\"`\n\tTitle     string    `json:\"title\" gorm:\"column:title\"`\n\tAuthor    string    `json:\"author\" gorm:\"column:author\"`\n\tPublished time.Time `json:\"published\" gorm:\"column:published\"`\n}"
      },
      {
        "code_key": "SubscriptionTier",
        "code_value": "type SubscriptionTier struct {\n\tID          int    `json:\"id\" gorm:\"column:id\"`\n\tName        string `json:\"name\" gorm:\"column:name\"`\n\tDescription string `json:\"description\" gorm:\"column:description\"`\n\tPriority    int    `json:\"priority\" gorm:\"column:priority\"`\n}"
      },
      {
        "code_key": "DeliveryStatus",
        "code_value": "const (\n\tPendingStatus   = \"pending\"\n\tShippedStatus   = \"shipped\"\n\tDeliveredStatus = \"delivered\"\n\tCancelledStatus = \"cancelled\"\n)"
      },
      {
        "code_key": "MaxDeliveryAttempts",
        "code_value": "const MaxDeliveryAttempts = 3"
      },
      {
        "code_key": "SupportedLanguages",
        "code_value": "var SupportedLanguages = []string{\"en\", \"es\", \"fr\", \"de\", \"ja\"}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ScheduleDelivery",
    "orm_code": "func (t *Textbook) ScheduleDelivery(filterParams map[string]interface{}) ([]types.Chapter, error) {\n\tvar chapters []types.Chapter\n\tdb := base.GetInstance().GormDriver().Table(\"subscription_tiers\")\n\n\tif language, ok := filterParams[\"Language\"]; ok {\n\t\tif region, ok := filterParams[\"RegionCode\"]; ok {\n\t\t\tdb = db.Where(\"language = ? AND region_code = ?\", language.(string), region.(string))\n\t\t} else {\n\t\t\tdb = db.Where(\"language like ?\", \"%\"+language.(string)+\"%\")\n\t\t}\n\t} else if street, ok := filterParams[\"Street\"]; ok {\n\t\tdb = db.Where(\"delivery_address like ?\", \"%\"+street.(string)+\"%\")\n\t}\n\n\tif err := db.Order(\"created_at desc\").Find(&chapters).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn chapters, nil\n}",
    "caller": "func (s *DeliveryService) HandleDeliveryScheduling(req *types.DeliveryScheduleRequest, log *logger.SvcLogger) ([]types.DeliverySchedule, error) {\n\tfilterCriteria := make(map[string]interface{})\n\n\tif req.ZoneID != \"\" {\n\t\tfilterCriteria[\"zone_id\"] = req.ZoneID\n\t} else if req.PriorityThreshold > 0 {\n\t\tfilterCriteria[\"priority_level\"] = req.PriorityThreshold\n\t} else if req.ContactQuery != \"\" {\n\t\tif len(req.ContactQuery) > 100 {\n\t\t\tlog.Warn(\"contact info query too long, truncating\")\n\t\t\treq.ContactQuery = req.ContactQuery[:100]\n\t\t}\n\t\tfilterCriteria[\"contact_info\"] = req.ContactQuery\n\t} else {\n\t\tfilterCriteria[\"status\"] = \"pending\"\n\t}\n\n\tdept := &Department{Code: req.DeptCode}\n\tmaxResults := utils.Min(req.MaxResults, 1000)\n\n\tschedules, err := dept.ScheduleDelivery(filterCriteria, maxResults)\n\tif err != nil {\n\t\tlog.Error(fmt.Sprintf(\"Delivery scheduling failed: %v\", err))\n\t\treturn nil, fmt.Errorf(\"failed to schedule deliveries: %w\", err)\n\t}\n\n\tif len(schedules) == 0 {\n\t\tlog.Info(\"No delivery schedules found matching criteria\")\n\t}\n\n\treturn schedules, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "ZoneID 参数存在",
            "sql": "SELECT id, zone_id, priority, contact_info, delivery_date, created_at, updated_at FROM delivery_zones WHERE zone_id = ? LIMIT ?;"
          },
          {
            "scenario": "PriorityThreshold 参数存在",
            "sql": "SELECT id, zone_id, priority, contact_info, delivery_date, created_at, updated_at FROM delivery_zones WHERE priority >= ? ORDER BY priority DESC LIMIT ?;"
          },
          {
            "scenario": "ContactQuery 参数存在",
            "sql": "SELECT id, zone_id, priority, contact_info, delivery_date, created_at, updated_at FROM delivery_zones WHERE contact_info LIKE ? LIMIT ?;"
          },
          {
            "scenario": "默认参数（status = pending）",
            "sql": "SELECT id, zone_id, priority, contact_info, delivery_date, created_at, updated_at FROM delivery_zones WHERE status = ? LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "Chapter",
        "code_value": "type Chapter struct {\n\tID          int       `json:\"id\" gorm:\"column:id\"`\n\tTitle       string    `json:\"title\" gorm:\"column:title\"`\n\tContent     string    `json:\"content\" gorm:\"column:content\"`\n\tLanguage    string    `json:\"language\" gorm:\"column:language\"`\n\tRegionCode  string    `json:\"region_code\" gorm:\"column:region_code\"`\n\tDeliveryAddress string `json:\"delivery_address\" gorm:\"column:delivery_address\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "Textbook",
        "code_value": "type Textbook struct {\n\tID        int       `json:\"id\" gorm:\"column:id\"`\n\tISBN      string    `json:\"isbn\" gorm:\"column:isbn\"`\n\tTitle     string    `json:\"title\" gorm:\"column:title\"`\n\tAuthor    string    `json:\"author\" gorm:\"column:author\"`\n\tPublished time.Time `json:\"published\" gorm:\"column:published\"`\n}"
      },
      {
        "code_key": "SubscriptionTier",
        "code_value": "type SubscriptionTier struct {\n\tID          int    `json:\"id\" gorm:\"column:id\"`\n\tName        string `json:\"name\" gorm:\"column:name\"`\n\tDescription string `json:\"description\" gorm:\"column:description\"`\n\tPriority    int    `json:\"priority\" gorm:\"column:priority\"`\n}"
      },
      {
        "code_key": "DeliveryStatus",
        "code_value": "const (\n\tPendingStatus   = \"pending\"\n\tShippedStatus   = \"shipped\"\n\tDeliveredStatus = \"delivered\"\n\tCancelledStatus = \"cancelled\"\n)"
      },
      {
        "code_key": "MaxDeliveryAttempts",
        "code_value": "const MaxDeliveryAttempts = 3"
      },
      {
        "code_key": "SupportedLanguages",
        "code_value": "var SupportedLanguages = []string{\"en\", \"es\", \"fr\", \"de\", \"ja\"}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "TrackBehavior",
    "orm_code": "func (t *Tracking) TrackBehavior(filterParams map[string]interface{}, limit int) ([]types.BehaviorLog, error) {\n\tvar logs []types.BehaviorLog\n\tdb := base.GetInstance().GormClient().Table(\"tournament_brackets\")\n\t\n\tif score, exists := filterParams[\"Score\"]; exists {\n\t\tif score.(int) > 80 {\n\t\t\tdb = db.Where(\"Score > ? AND CurrentStatus = ?\", score, \"active\")\n\t\t} else {\n\t\t\tdb = db.Where(\"Score <= ?\", score)\n\t\t}\n\t} else if discountRate, exists := filterParams[\"DiscountRate\"]; exists {\n\t\tdb = db.Where(\"DiscountRate BETWEEN ? AND ?\", discountRate.(float64)-0.1, discountRate.(float64)+0.1)\n\t}\n\t\n\terr := db.Order(\"created_at DESC\").Limit(limit).Find(&logs).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn logs, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "包含session_id参数",
            "sql": "SELECT id, session_id, variable_name, volume, work_address, created_at, updated_at FROM quest_progress WHERE session_id = ? AND volume > ? ORDER BY created_at DESC LIMIT ?;"
          },
          {
            "scenario": "包含variable_name参数",
            "sql": "SELECT id, session_id, variable_name, volume, work_address, created_at, updated_at FROM quest_progress WHERE variable_name LIKE ? AND work_address IS NOT NULL ORDER BY updated_at DESC LIMIT ?;"
          },
          {
            "scenario": "包含start_time和end_time参数",
            "sql": "SELECT session_id, variable_name, COUNT(*) as volume FROM quest_progress WHERE created_at BETWEEN ? AND ? GROUP BY session_id, variable_name LIMIT ?;"
          },
          {
            "scenario": "其他参数组合",
            "sql": "SELECT id, session_id, variable_name, volume, work_address, created_at, updated_at FROM quest_progress WHERE session_id = ? AND variable_name = ? ORDER BY id DESC LIMIT ?;"
          },
          {
            "scenario": "其他参数组合",
            "sql": "SELECT id, session_id, variable_name, volume, work_address, created_at, updated_at FROM quest_progress WHERE volume = ? ORDER BY id DESC LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "BehaviorLog",
        "code_value": "type BehaviorLog struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tUserID        string    `json:\"user_id\" gorm:\"column:user_id\"`\n\tActionType    string    `json:\"action_type\" gorm:\"column:action_type\"`\n\tScore         int       `json:\"score\" gorm:\"column:score\"`\n\tDiscountRate  float64   `json:\"discount_rate\" gorm:\"column:discount_rate\"`\n\tCurrentStatus string    `json:\"current_status\" gorm:\"column:current_status\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "BehaviorFilter",
        "code_value": "type BehaviorFilter struct {\n\tScore        *int     `json:\"score\"`\n\tDiscountRate *float64 `json:\"discount_rate\"`\n\tLimit        int      `json:\"limit\"`\n}"
      },
      {
        "code_key": "BehaviorResponse",
        "code_value": "type BehaviorResponse struct {\n\tLogs  []BehaviorLog `json:\"logs\"`\n\tCount int           `json:\"count\"`\n\tError string        `json:\"error,omitempty\"`\n}"
      },
      {
        "code_key": "BehaviorStatus",
        "code_value": "const (\n\tBehaviorStatusActive  = \"active\"\n\tBehaviorStatusPending = \"pending\"\n\tBehaviorStatusExpired = \"expired\"\n)"
      },
      {
        "code_key": "DefaultBehaviorLimit",
        "code_value": "const DefaultBehaviorLimit = 100"
      },
      {
        "code_key": "BehaviorTableName",
        "code_value": "const BehaviorTableName = \"user_behaviors\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "TrackBehavior",
    "orm_code": "func (t *Tracking) TrackBehavior(filterParams map[string]interface{}, limit int) ([]types.BehaviorLog, error) {\n\tvar logs []types.BehaviorLog\n\tdb := base.GetInstance().GormClient().Table(\"tournament_brackets\")\n\t\n\tif score, exists := filterParams[\"Score\"]; exists {\n\t\tif score.(int) > 80 {\n\t\t\tdb = db.Where(\"Score > ? AND CurrentStatus = ?\", score, \"active\")\n\t\t} else {\n\t\t\tdb = db.Where(\"Score <= ?\", score)\n\t\t}\n\t} else if discountRate, exists := filterParams[\"DiscountRate\"]; exists {\n\t\tdb = db.Where(\"DiscountRate BETWEEN ? AND ?\", discountRate.(float64)-0.1, discountRate.(float64)+0.1)\n\t}\n\t\n\terr := db.Order(\"created_at DESC\").Limit(limit).Find(&logs).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn logs, nil\n}",
    "caller": "func (h *Handler) HandleProgressTracking(req *types.ProgressRequest) ([]types.BehaviorLog, error) {\n\tfilter := make(map[string]interface{})\n\t\n\tif req.UserID != \"\" {\n\t\tfilter[\"Score\"] = 85 // Will trigger the first branch in ORM\n\t} else if req.CampaignID > 0 {\n\t\tfilter[\"DiscountRate\"] = 0.5 // Will trigger the second branch in ORM\n\t} else if req.StartTime != \"\" && req.EndTime != \"\" {\n\t\tfilter[\"TimeRange\"] = true\n\t\thandleTimeRangeFilter(filter, req.StartTime, req.EndTime)\n\t} else {\n\t\treturn nil, errors.New(\"invalid filter parameters\")\n\t}\n\n\ttracker := &Tracking{}\n\tlogs, err := tracker.TrackBehavior(filter, req.Limit)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"track behavior failed: %v\", err)\n\t}\n\t\n\tif len(logs) == 0 {\n\t\treturn nil, errors.New(\"no matching records found\")\n\t}\n\treturn logs, nil\n}\n\nfunc handleTimeRangeFilter(filter map[string]interface{}, start, end string) {\n\tfilter[\"StartTime\"] = start\n\tfilter[\"EndTime\"] = end\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "When UserID is provided (Score > 85)",
            "sql": "SELECT id, user_id, action_type, score, discount_rate, current_status, created_at, updated_at FROM tournament_brackets WHERE Score > 85 AND CurrentStatus = 'active' ORDER BY created_at DESC LIMIT ?;"
          },
          {
            "scenario": "When CampaignID is provided (DiscountRate between 0.4 and 0.6)",
            "sql": "SELECT id, user_id, action_type, score, discount_rate, current_status, created_at, updated_at FROM tournament_brackets WHERE DiscountRate BETWEEN 0.4 AND 0.6 ORDER BY created_at DESC LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "BehaviorLog",
        "code_value": "type BehaviorLog struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tUserID        string    `json:\"user_id\" gorm:\"column:user_id\"`\n\tActionType    string    `json:\"action_type\" gorm:\"column:action_type\"`\n\tScore         int       `json:\"score\" gorm:\"column:score\"`\n\tDiscountRate  float64   `json:\"discount_rate\" gorm:\"column:discount_rate\"`\n\tCurrentStatus string    `json:\"current_status\" gorm:\"column:current_status\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "BehaviorFilter",
        "code_value": "type BehaviorFilter struct {\n\tScore        *int     `json:\"score\"`\n\tDiscountRate *float64 `json:\"discount_rate\"`\n\tLimit        int      `json:\"limit\"`\n}"
      },
      {
        "code_key": "BehaviorResponse",
        "code_value": "type BehaviorResponse struct {\n\tLogs  []BehaviorLog `json:\"logs\"`\n\tCount int           `json:\"count\"`\n\tError string        `json:\"error,omitempty\"`\n}"
      },
      {
        "code_key": "BehaviorStatus",
        "code_value": "const (\n\tBehaviorStatusActive  = \"active\"\n\tBehaviorStatusPending = \"pending\"\n\tBehaviorStatusExpired = \"expired\"\n)"
      },
      {
        "code_key": "DefaultBehaviorLimit",
        "code_value": "const DefaultBehaviorLimit = 100"
      },
      {
        "code_key": "BehaviorTableName",
        "code_value": "const BehaviorTableName = \"user_behaviors\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "TrackBehavior",
    "orm_code": "func (t *Tracking) TrackBehavior(filterParams map[string]interface{}, limit int) ([]types.BehaviorLog, error) {\n\tvar logs []types.BehaviorLog\n\tdb := base.GetInstance().GormClient().Table(\"tournament_brackets\")\n\t\n\tif score, exists := filterParams[\"Score\"]; exists {\n\t\tif score.(int) > 80 {\n\t\t\tdb = db.Where(\"Score > ? AND CurrentStatus = ?\", score, \"active\")\n\t\t} else {\n\t\t\tdb = db.Where(\"Score <= ?\", score)\n\t\t}\n\t} else if discountRate, exists := filterParams[\"DiscountRate\"]; exists {\n\t\tdb = db.Where(\"DiscountRate BETWEEN ? AND ?\", discountRate.(float64)-0.1, discountRate.(float64)+0.1)\n\t}\n\t\n\terr := db.Order(\"created_at DESC\").Limit(limit).Find(&logs).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn logs, nil\n}",
    "caller": "func (s *BehaviorService) HandleBehaviorTracking(req *types.BehaviorTrackingRequest) ([]types.BehaviorRecord, error) {\n\tif req.Limit <= 0 {\n\t\treturn nil, fmt.Errorf(\"invalid limit parameter\")\n\t}\n\n\tfilterCriteria := make(map[string]interface{})\n\tif req.SessionID != \"\" {\n\t\tfilterCriteria[\"session_id\"] = req.SessionID\n\t} else if req.VariableName != \"\" {\n\t\tfilterCriteria[\"variable_name\"] = req.VariableName\n\t} else if !req.StartTime.IsZero() {\n\t\tfilterCriteria[\"start_time\"] = req.StartTime\n\t\tfilterCriteria[\"end_time\"] = req.EndTime\n\t} else {\n\t\tfilterCriteria[\"patient_id\"] = req.PatientID\n\t}\n\n\tpatientObj := &Patient{ID: req.PatientID}\n\tbehaviorRecords, err := patientObj.TrackBehavior(filterCriteria, req.Limit)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to track behavior: %v\", err)\n\t}\n\n\treturn behaviorRecords, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "提供SessionID",
            "sql": "SELECT id, session_id, variable_name, volume, work_address, created_at, updated_at FROM quest_progress WHERE session_id = ? AND volume > 0 ORDER BY created_at DESC LIMIT ?;"
          },
          {
            "scenario": "提供VariableName",
            "sql": "SELECT id, session_id, variable_name, volume, work_address, created_at, updated_at FROM quest_progress WHERE variable_name LIKE ? AND work_address IS NOT NULL ORDER BY updated_at DESC LIMIT ?;"
          },
          {
            "scenario": "提供StartTime和EndTime",
            "sql": "SELECT session_id, variable_name, COUNT(*) as volume FROM quest_progress WHERE created_at BETWEEN ? AND ? GROUP BY session_id, variable_name LIMIT ?;"
          },
          {
            "scenario": "仅提供PatientID",
            "sql": "SELECT id, session_id, variable_name, volume, work_address, created_at, updated_at FROM quest_progress WHERE patient_id = ? ORDER BY id DESC LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "BehaviorLog",
        "code_value": "type BehaviorLog struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tUserID        string    `json:\"user_id\" gorm:\"column:user_id\"`\n\tActionType    string    `json:\"action_type\" gorm:\"column:action_type\"`\n\tScore         int       `json:\"score\" gorm:\"column:score\"`\n\tDiscountRate  float64   `json:\"discount_rate\" gorm:\"column:discount_rate\"`\n\tCurrentStatus string    `json:\"current_status\" gorm:\"column:current_status\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "BehaviorFilter",
        "code_value": "type BehaviorFilter struct {\n\tScore        *int     `json:\"score\"`\n\tDiscountRate *float64 `json:\"discount_rate\"`\n\tLimit        int      `json:\"limit\"`\n}"
      },
      {
        "code_key": "BehaviorResponse",
        "code_value": "type BehaviorResponse struct {\n\tLogs  []BehaviorLog `json:\"logs\"`\n\tCount int           `json:\"count\"`\n\tError string        `json:\"error,omitempty\"`\n}"
      },
      {
        "code_key": "BehaviorStatus",
        "code_value": "const (\n\tBehaviorStatusActive  = \"active\"\n\tBehaviorStatusPending = \"pending\"\n\tBehaviorStatusExpired = \"expired\"\n)"
      },
      {
        "code_key": "DefaultBehaviorLimit",
        "code_value": "const DefaultBehaviorLimit = 100"
      },
      {
        "code_key": "BehaviorTableName",
        "code_value": "const BehaviorTableName = \"user_behaviors\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "LoadByType",
    "orm_code": "func (c *Certificate) LoadByType(filterParams map[string]interface{}, page, size int) ([]types.CertificateRecord, error) {\n\tvar records []types.CertificateRecord\n\tdb := base.GetDB().Table(\"comment_moderation\")\n\t\n\tif certType, ok := filterParams[\"CertificateType\"]; ok {\n\t\tquery := make(map[string]interface{})\n\t\tfor k, v := range filterParams {\n\t\t\tif k != \"CertificateType\" {\n\t\t\t\tquery[k] = v\n\t\t\t}\n\t\t}\n\t\tdb = db.Where(query).Where(\"cert_type = ?\", certType)\n\t} else if nickName, ok := filterParams[\"NickName\"]; ok {\n\t\tdb = db.Where(\"nick_name LIKE ?\", \"%\"+nickName.(string)+\"%\")\n\t} else {\n\t\tdb = db.Where(filterParams)\n\t}\n\t\n\terr := db.Scopes(PaginateDB(page, size)).Order(\"created_at DESC\").Find(&records).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "filter中包含content_type",
            "sql": "SELECT id, content_type, title, status, created_at, updated_at FROM content_reports WHERE content_type = ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "filter中包含title（不含content_type）",
            "sql": "SELECT id, content_type, title, status, created_at, updated_at FROM content_reports WHERE title LIKE ? ORDER BY title ASC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "filter中包含active_only=true（不含content_type和title）",
            "sql": "SELECT id, content_type, title, status, created_at, updated_at FROM content_reports WHERE status = 'active' ORDER BY updated_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "filter中包含其他条件（不含上述三种情况）",
            "sql": "SELECT id, content_type, title, status, created_at, updated_at FROM content_reports WHERE status = ? ORDER BY id LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "CertificateRecord",
        "code_value": "type CertificateRecord struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tCertificateType string    `json:\"certificate_type\" gorm:\"column:cert_type\"`\n\tNickName      string    `json:\"nick_name\" gorm:\"column:nick_name\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "Certificate",
        "code_value": "type Certificate struct {\n\tbase.Model\n\tRecords []CertificateRecord `json:\"records\" gorm:\"-\"`"
      },
      {
        "code_key": "CertificateFilter",
        "code_value": "type CertificateFilter struct {\n\tCertificateType string `json:\"certificate_type\"`\n\tNickName       string `json:\"nick_name\"`\n\tPage           int    `json:\"page\"`\n\tSize           int    `json:\"size\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "const TableName = \"certificate_records\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "MaxPageSize",
        "code_value": "const MaxPageSize = 100"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "LoadByType",
    "orm_code": "func (c *Certificate) LoadByType(filterParams map[string]interface{}, page, size int) ([]types.CertificateRecord, error) {\n\tvar records []types.CertificateRecord\n\tdb := base.GetDB().Table(\"comment_moderation\")\n\t\n\tif certType, ok := filterParams[\"CertificateType\"]; ok {\n\t\tquery := make(map[string]interface{})\n\t\tfor k, v := range filterParams {\n\t\t\tif k != \"CertificateType\" {\n\t\t\t\tquery[k] = v\n\t\t\t}\n\t\t}\n\t\tdb = db.Where(query).Where(\"cert_type = ?\", certType)\n\t} else if nickName, ok := filterParams[\"NickName\"]; ok {\n\t\tdb = db.Where(\"nick_name LIKE ?\", \"%\"+nickName.(string)+\"%\")\n\t} else {\n\t\tdb = db.Where(filterParams)\n\t}\n\t\n\terr := db.Scopes(PaginateDB(page, size)).Order(\"created_at DESC\").Find(&records).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "caller": "func (s *SellerService) HandleSellerCertificates(req *types.SellerCertRequest, log *logger.BizLog) ([]types.CertificateRecord, error) {\n\tfilter := make(map[string]interface{})\n\tpage, size := utils.NormalizePagination(req.Page, req.Size)\n\t\n\tif req.SellerID != \"\" {\n\t\tfilter[\"seller_id\"] = req.SellerID\n\t} else if req.CompanyName != \"\" {\n\t\tif len(req.CompanyName) > 100 {\n\t\t\tlog.Error(\"CompanyName too long\")\n\t\t\treturn nil, errors.New(\"invalid company name\")\n\t\t}\n\t\tfilter[\"company_name\"] = req.CompanyName\n\t} else if req.CertStatus != 0 {\n\t\tif req.CertStatus < 1 || req.CertStatus > 5 {\n\t\t\tlog.Error(\"Invalid cert status\")\n\t\t\treturn nil, errors.New(\"invalid certificate status\")\n\t\t}\n\t\tfilter[\"status\"] = req.CertStatus\n\t} else {\n\t\tfilter[\"is_active\"] = true\n\t}\n\t\n\tcert := &Certificate{}\n\trecords, err := cert.LoadByType(filter, page, size)\n\tif err != nil {\n\t\tlog.Errorf(\"Failed to load certificates: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "filter contains seller_id",
            "sql": "SELECT id, cert_type, nick_name, created_at, updated_at FROM comment_moderation WHERE seller_id = ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "filter contains company_name",
            "sql": "SELECT id, cert_type, nick_name, created_at, updated_at FROM comment_moderation WHERE company_name = ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "filter contains status",
            "sql": "SELECT id, cert_type, nick_name, created_at, updated_at FROM comment_moderation WHERE status = ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "default filter with is_active",
            "sql": "SELECT id, cert_type, nick_name, created_at, updated_at FROM comment_moderation WHERE is_active = ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "CertificateRecord",
        "code_value": "type CertificateRecord struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tCertificateType string    `json:\"certificate_type\" gorm:\"column:cert_type\"`\n\tNickName      string    `json:\"nick_name\" gorm:\"column:nick_name\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "Certificate",
        "code_value": "type Certificate struct {\n\tbase.Model\n\tRecords []CertificateRecord `json:\"records\" gorm:\"-\"`"
      },
      {
        "code_key": "CertificateFilter",
        "code_value": "type CertificateFilter struct {\n\tCertificateType string `json:\"certificate_type\"`\n\tNickName       string `json:\"nick_name\"`\n\tPage           int    `json:\"page\"`\n\tSize           int    `json:\"size\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "const TableName = \"certificate_records\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "MaxPageSize",
        "code_value": "const MaxPageSize = 100"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "LoadByType",
    "orm_code": "func (c *Certificate) LoadByType(filterParams map[string]interface{}, page, size int) ([]types.CertificateRecord, error) {\n\tvar records []types.CertificateRecord\n\tdb := base.GetDB().Table(\"comment_moderation\")\n\t\n\tif certType, ok := filterParams[\"CertificateType\"]; ok {\n\t\tquery := make(map[string]interface{})\n\t\tfor k, v := range filterParams {\n\t\t\tif k != \"CertificateType\" {\n\t\t\t\tquery[k] = v\n\t\t\t}\n\t\t}\n\t\tdb = db.Where(query).Where(\"cert_type = ?\", certType)\n\t} else if nickName, ok := filterParams[\"NickName\"]; ok {\n\t\tdb = db.Where(\"nick_name LIKE ?\", \"%\"+nickName.(string)+\"%\")\n\t} else {\n\t\tdb = db.Where(filterParams)\n\t}\n\t\n\terr := db.Scopes(PaginateDB(page, size)).Order(\"created_at DESC\").Find(&records).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "caller": "func (a *Armor) HandleArmor(req *types.ArmorRequest, log *logger.BattleLog) ([]types.ContentLabel, error) {\n\tpageReq := req.Pagination\n\tpage, size := model.GetPagination(&pageReq)\n\tcriteria := make(map[string]interface{})\n\n\tif len(req.ArmorType) > 0 {\n\t\tcriteria[\"content_type\"] = req.ArmorType\n\t} else if len(req.Description) > 0 {\n\t\tcriteria[\"title\"] = req.Description\n\t} else if req.ActiveOnly {\n\t\tcriteria[\"active_only\"] = true\n\t}\n\n\tarmorObj := &Label{Code: model.NewCode(req.RequestID, model.HandleArmorFlow)}\n\tresults, err := armorObj.LoadByType(criteria, page, size)\n\tif err != nil {\n\t\tlog.Error(fmt.Sprintf(\"[HandleArmor] LoadByType failed: %v\", err), utils.DatabaseError)\n\t\treturn nil, err\n\t}\n\n\tif len(results) == 0 {\n\t\tlog.Info(\"[HandleArmor] No armor records found\")\n\t\treturn nil, nil\n\t}\n\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "传入content_type参数",
            "sql": "SELECT id, content_type, title, status, created_at, updated_at FROM content_reports WHERE content_type = 'video' ORDER BY created_at DESC LIMIT 10 OFFSET 0;"
          },
          {
            "scenario": "传入title参数",
            "sql": "SELECT id, content_type, title, status, created_at, updated_at FROM content_reports WHERE title LIKE '%armor%' ORDER BY title ASC LIMIT 20 OFFSET 20;"
          },
          {
            "scenario": "传入active_only参数",
            "sql": "SELECT id, content_type, title, status, created_at, updated_at FROM content_reports WHERE status = 'active' ORDER BY updated_at DESC LIMIT 5 OFFSET 0;"
          },
          {
            "scenario": "无特殊条件参数",
            "sql": "SELECT id, content_type, title, status, created_at, updated_at FROM content_reports ORDER BY id LIMIT 10 OFFSET 0;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "CertificateRecord",
        "code_value": "type CertificateRecord struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tCertificateType string    `json:\"certificate_type\" gorm:\"column:cert_type\"`\n\tNickName      string    `json:\"nick_name\" gorm:\"column:nick_name\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "Certificate",
        "code_value": "type Certificate struct {\n\tbase.Model\n\tRecords []CertificateRecord `json:\"records\" gorm:\"-\"`"
      },
      {
        "code_key": "CertificateFilter",
        "code_value": "type CertificateFilter struct {\n\tCertificateType string `json:\"certificate_type\"`\n\tNickName       string `json:\"nick_name\"`\n\tPage           int    `json:\"page\"`\n\tSize           int    `json:\"size\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "const TableName = \"certificate_records\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "MaxPageSize",
        "code_value": "const MaxPageSize = 100"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "FilterMarketEvents",
    "orm_code": "func (v *Vendor) FilterMarketEvents(criteria map[string]interface{}, page, size int) ([]types.MarketEvent, error) {\n\tvar events []types.MarketEvent\n\tdb := base.GetInstance().GormDB().Table(\"market_data\")\n\t\n\tif theme, ok := criteria[\"Theme\"]; ok {\n\t\tdb = db.Where(\"theme LIKE ?\", \"%\"+theme.(string)+\"%\")\n\t} else if trackingID, ok := criteria[\"TrackingId\"]; ok {\n\t\tdb = db.Where(\"tracking_id = ?\", trackingID.(string))\n\t} else if deliveryCode, ok := criteria[\"DeliveryCode\"]; ok {\n\t\tdb = db.Where(\"delivery_code IN ?\", strings.Split(deliveryCode.(string), \",\"))\n\t}\n\t\n\terr := db.Scopes(PaginateDB(page, size)).\n\t\tOrder(\"created_at DESC\").\n\t\tFind(&events).Error\n\t\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.ErrNotFound\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to query market events: %w\", err)\n\t}\n\treturn events, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按Theme筛选",
            "sql": "SELECT * FROM market_data WHERE theme LIKE '%festival%' ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "按TrackingId筛选",
            "sql": "SELECT * FROM market_data WHERE tracking_id = 'TRK123' ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "按DeliveryCode筛选",
            "sql": "SELECT * FROM market_data WHERE delivery_code IN ('DC1', 'DC2', 'DC3') ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "无筛选条件",
            "sql": "SELECT * FROM market_data ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "MarketEvent",
        "code_value": "type MarketEvent struct {\n\tID           uint      `json:\"id\" gorm:\"primaryKey\"`\n\tTheme        string    `json:\"theme\" gorm:\"column:theme\"`\n\tTrackingId   string    `json:\"tracking_id\" gorm:\"column:tracking_id\"`\n\tDeliveryCode string    `json:\"delivery_code\" gorm:\"column:delivery_code\"`\n\tCreatedAt    time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt    time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "EventFilterCriteria",
        "code_value": "type EventFilterCriteria struct {\n\tTheme        *string\n\tTrackingId   *string\n\tDeliveryCode *string\n}"
      },
      {
        "code_key": "MarketEventResponse",
        "code_value": "type MarketEventResponse struct {\n\tEvents      []MarketEvent `json:\"events\"`\n\tTotalCount  int          `json:\"total_count\"`\n\tCurrentPage int          `json:\"current_page\"`\n\tPageSize    int          `json:\"page_size\"`\n}"
      },
      {
        "code_key": "TableNameMarketData",
        "code_value": "const TableNameMarketData = \"market_data\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "MaxPageSize",
        "code_value": "const MaxPageSize = 100"
      },
      {
        "code_key": "EventStatus",
        "code_value": "const (\n\tEventStatusPending   = \"pending\"\n\tEventStatusActive    = \"active\"\n\tEventStatusCompleted = \"completed\"\n\tEventStatusCancelled = \"cancelled\"\n)"
      },
      {
        "code_key": "eventStatusMap",
        "code_value": "var eventStatusMap = map[string]int{\n\t\"pending\":   0,\n\t\"active\":    1,\n\t\"completed\": 2,\n\t\"cancelled\": 3,\n}"
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "FilterMarketEvents",
    "orm_code": "func (v *Vendor) FilterMarketEvents(criteria map[string]interface{}, page, size int) ([]types.MarketEvent, error) {\n\tvar events []types.MarketEvent\n\tdb := base.GetInstance().GormDB().Table(\"market_data\")\n\t\n\tif theme, ok := criteria[\"Theme\"]; ok {\n\t\tdb = db.Where(\"theme LIKE ?\", \"%\"+theme.(string)+\"%\")\n\t} else if trackingID, ok := criteria[\"TrackingId\"]; ok {\n\t\tdb = db.Where(\"tracking_id = ?\", trackingID.(string))\n\t} else if deliveryCode, ok := criteria[\"DeliveryCode\"]; ok {\n\t\tdb = db.Where(\"delivery_code IN ?\", strings.Split(deliveryCode.(string), \",\"))\n\t}\n\t\n\terr := db.Scopes(PaginateDB(page, size)).\n\t\tOrder(\"created_at DESC\").\n\t\tFind(&events).Error\n\t\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, utils.ErrNotFound\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to query market events: %w\", err)\n\t}\n\treturn events, nil\n}",
    "caller": "func (s *MarketService) HandleMarketEventSearch(req *types.SearchMarketEventsRequest) ([]types.MarketEvent, error) {\n\tsearchCriteria := make(map[string]interface{})\n\tif req.Theme != \"\" {\n\t\tsearchCriteria[\"Theme\"] = req.Theme\n\t} else if req.TrackingID != \"\" {\n\t\tsearchCriteria[\"TrackingId\"] = req.TrackingID\n\t} else if req.DeliveryCodes != \"\" {\n\t\tsearchCriteria[\"DeliveryCode\"] = req.DeliveryCodes\n\t} else {\n\t\treturn nil, fmt.Errorf(\"at least one search parameter must be provided\")\n\t}\n\n\tvendor := &Vendor{DB: s.DB}\n\tevents, err := vendor.FilterMarketEvents(searchCriteria, req.Page, req.Size)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"market event search failed: %w\", err)\n\t}\n\n\tif len(events) == 0 {\n\t\treturn nil, fmt.Errorf(\"no market events found matching criteria\")\n\t}\n\treturn events, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按Theme搜索",
            "sql": "SELECT * FROM market_data WHERE theme LIKE '%tech%' ORDER BY created_at DESC LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "按TrackingId精确匹配",
            "sql": "SELECT * FROM market_data WHERE tracking_id = 'TRK12345' ORDER BY created_at DESC LIMIT 10 OFFSET 10;"
          },
          {
            "scenario": "按DeliveryCode列表搜索",
            "sql": "SELECT * FROM market_data WHERE delivery_code IN ('DC001','DC002','DC003') ORDER BY created_at DESC LIMIT 5 OFFSET 0;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "MarketEvent",
        "code_value": "type MarketEvent struct {\n\tID           uint      `json:\"id\" gorm:\"primaryKey\"`\n\tTheme        string    `json:\"theme\" gorm:\"column:theme\"`\n\tTrackingId   string    `json:\"tracking_id\" gorm:\"column:tracking_id\"`\n\tDeliveryCode string    `json:\"delivery_code\" gorm:\"column:delivery_code\"`\n\tCreatedAt    time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt    time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "EventFilterCriteria",
        "code_value": "type EventFilterCriteria struct {\n\tTheme        *string\n\tTrackingId   *string\n\tDeliveryCode *string\n}"
      },
      {
        "code_key": "MarketEventResponse",
        "code_value": "type MarketEventResponse struct {\n\tEvents      []MarketEvent `json:\"events\"`\n\tTotalCount  int          `json:\"total_count\"`\n\tCurrentPage int          `json:\"current_page\"`\n\tPageSize    int          `json:\"page_size\"`\n}"
      },
      {
        "code_key": "TableNameMarketData",
        "code_value": "const TableNameMarketData = \"market_data\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "MaxPageSize",
        "code_value": "const MaxPageSize = 100"
      },
      {
        "code_key": "EventStatus",
        "code_value": "const (\n\tEventStatusPending   = \"pending\"\n\tEventStatusActive    = \"active\"\n\tEventStatusCompleted = \"completed\"\n\tEventStatusCancelled = \"cancelled\"\n)"
      },
      {
        "code_key": "eventStatusMap",
        "code_value": "var eventStatusMap = map[string]int{\n\t\"pending\":   0,\n\t\"active\":    1,\n\t\"completed\": 2,\n\t\"cancelled\": 3,\n}"
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "PredictTrends",
    "orm_code": "func (s *Semester) PredictTrends(filterParams map[string]interface{}) ([]types.ExamTrend, error) {\n\ttrends := make([]types.ExamTrend, 0)\n\tvar err error\n\n\tquery := base.GetInstance().IvcDriver().Table(\"exam_results\").Order(\"created_at DESC\")\n\n\tif subject, ok := filterParams[\"subject\"]; ok {\n\t\tquery = query.Where(\"subject = ?\", subject.(string))\n\t} else if scoreRange, ok := filterParams[\"score_range\"]; ok {\n\t\trangeValues := scoreRange.([]int)\n\t\tif len(rangeValues) == 2 {\n\t\t\tquery = query.Where(\"score BETWEEN ? AND ?\", rangeValues[0], rangeValues[1])\n\t\t}\n\t} else if studentId, ok := filterParams[\"student_id\"]; ok {\n\t\tquery = query.Where(\"student_id LIKE ?\", \"%\"+studentId.(string)+\"%\")\n\t} else {\n\t\tquery = query.Limit(100)\n\t}\n\n\terr = query.Find(&trends).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn trends, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\n\treturn trends, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "传入'subject'参数",
            "sql": "SELECT id, student_id, subject, score, created_at, updated_at FROM exam_results WHERE subject = 'math' ORDER BY created_at DESC;"
          },
          {
            "scenario": "传入'score_range'参数（且数组长度为2）",
            "sql": "SELECT id, student_id, subject, score, created_at, updated_at FROM exam_results WHERE score BETWEEN 60 AND 90 ORDER BY created_at DESC;"
          },
          {
            "scenario": "传入'student_id'参数",
            "sql": "SELECT id, student_id, subject, score, created_at, updated_at FROM exam_results WHERE student_id LIKE '%2021%' ORDER BY created_at DESC;"
          },
          {
            "scenario": "不传入任何过滤参数",
            "sql": "SELECT id, student_id, subject, score, created_at, updated_at FROM exam_results ORDER BY created_at DESC LIMIT 100;"
          },
          {
            "scenario": "传入'score_range'参数但数组长度不为2",
            "sql": "SELECT id, student_id, subject, score, created_at, updated_at FROM exam_results ORDER BY created_at DESC LIMIT 100;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "ExamTrend",
        "code_value": "type ExamTrend struct {\n\tID        int       `json:\"id\" gorm:\"column:id\"`\n\tStudentID string    `json:\"student_id\" gorm:\"column:student_id\"`\n\tSubject   string    `json:\"subject\" gorm:\"column:subject\"`\n\tScore     int       `json:\"score\" gorm:\"column:score\"`\n\tCreatedAt time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "TrendFilter",
        "code_value": "type TrendFilter struct {\n\tSubject    string `json:\"subject\"`\n\tScoreRange []int  `json:\"score_range\"`\n\tStudentID  string `json:\"student_id\"`\n}"
      },
      {
        "code_key": "ExamResultTable",
        "code_value": "const ExamResultTable = \"exam_results\""
      },
      {
        "code_key": "DefaultLimit",
        "code_value": "const DefaultLimit = 100"
      },
      {
        "code_key": "TrendResponse",
        "code_value": "type TrendResponse struct {\n\tData  []ExamTrend `json:\"data\"`\n\tTotal int         `json:\"total\"`\n\tError string      `json:\"error,omitempty\"`\n}"
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "PredictTrends",
    "orm_code": "func (s *Semester) PredictTrends(filterParams map[string]interface{}) ([]types.ExamTrend, error) {\n\ttrends := make([]types.ExamTrend, 0)\n\tvar err error\n\n\tquery := base.GetInstance().IvcDriver().Table(\"exam_results\").Order(\"created_at DESC\")\n\n\tif subject, ok := filterParams[\"subject\"]; ok {\n\t\tquery = query.Where(\"subject = ?\", subject.(string))\n\t} else if scoreRange, ok := filterParams[\"score_range\"]; ok {\n\t\trangeValues := scoreRange.([]int)\n\t\tif len(rangeValues) == 2 {\n\t\t\tquery = query.Where(\"score BETWEEN ? AND ?\", rangeValues[0], rangeValues[1])\n\t\t}\n\t} else if studentId, ok := filterParams[\"student_id\"]; ok {\n\t\tquery = query.Where(\"student_id LIKE ?\", \"%\"+studentId.(string)+\"%\")\n\t} else {\n\t\tquery = query.Limit(100)\n\t}\n\n\terr = query.Find(&trends).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn trends, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\n\treturn trends, nil\n}",
    "caller": "func (h *ExamHandler) HandleExamTrends(req *types.ExamTrendRequest) ([]types.ExamTrend, error) {\n\tif req == nil {\n\t\treturn nil, fmt.Errorf(\"request cannot be nil\")\n\t}\n\n\tfilterCriteria := make(map[string]interface{})\n\n\tsemester := &models.Semester{ID: req.SemesterID}\n\n\tswitch req.FilterType {\n\tcase \"subject\":\n\t\tif req.Subject == \"\" {\n\t\t\treturn nil, fmt.Errorf(\"subject cannot be empty\")\n\t\t}\n\t\tfilterCriteria[\"subject\"] = req.Subject\n\tcase \"score_range\":\n\t\tif len(req.ScoreRange) != 2 {\n\t\t\treturn nil, fmt.Errorf(\"score range must have 2 values\")\n\t\t}\n\t\tfilterCriteria[\"score_range\"] = req.ScoreRange\n\tcase \"student\":\n\t\tif req.StudentID == \"\" {\n\t\t\treturn nil, fmt.Errorf(\"student ID cannot be empty\")\n\t\t}\n\t\tfilterCriteria[\"student_id\"] = req.StudentID\n\tdefault:\n\t\t// No filter applied, will use default limit\n\t}\n\n\ttrendResults, err := semester.PredictTrends(filterCriteria)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to predict trends: %v\", err)\n\t}\n\n\treturn trendResults, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按subject精确匹配",
            "sql": "SELECT id, student_id, subject, score, created_at, updated_at FROM exam_results WHERE subject = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "按score_range范围匹配",
            "sql": "SELECT id, student_id, subject, score, created_at, updated_at FROM exam_results WHERE score BETWEEN ? AND ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "按student_id模糊匹配",
            "sql": "SELECT id, student_id, subject, score, created_at, updated_at FROM exam_results WHERE student_id LIKE ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "默认无过滤限制100条",
            "sql": "SELECT id, student_id, subject, score, created_at, updated_at FROM exam_results ORDER BY created_at DESC LIMIT 100;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "ExamTrend",
        "code_value": "type ExamTrend struct {\n\tID        int       `json:\"id\" gorm:\"column:id\"`\n\tStudentID string    `json:\"student_id\" gorm:\"column:student_id\"`\n\tSubject   string    `json:\"subject\" gorm:\"column:subject\"`\n\tScore     int       `json:\"score\" gorm:\"column:score\"`\n\tCreatedAt time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "TrendFilter",
        "code_value": "type TrendFilter struct {\n\tSubject    string `json:\"subject\"`\n\tScoreRange []int  `json:\"score_range\"`\n\tStudentID  string `json:\"student_id\"`\n}"
      },
      {
        "code_key": "ExamResultTable",
        "code_value": "const ExamResultTable = \"exam_results\""
      },
      {
        "code_key": "DefaultLimit",
        "code_value": "const DefaultLimit = 100"
      },
      {
        "code_key": "TrendResponse",
        "code_value": "type TrendResponse struct {\n\tData  []ExamTrend `json:\"data\"`\n\tTotal int         `json:\"total\"`\n\tError string      `json:\"error,omitempty\"`\n}"
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "AuditChanges",
    "orm_code": "func (p *Project) AuditChanges(filterParams map[string]interface{}, limit int) ([]types.AuditRecord, error) {\n\tvar records []types.AuditRecord\n\tdb := base.GetInstance().MainDB().Table(\"share_activities\")\n\n\tif region, ok := filterParams[\"RegionCode\"]; ok {\n\t\tdb = db.Where(\"region_code = ? AND status = ?\", region.(string), \"pending\")\n\t} else if email, ok := filterParams[\"EmailAddress\"]; ok {\n\t\tdb = db.Where(\"initiator_email LIKE ?\", \"%\"+email.(string)+\"%\")\n\t} else if postalCode, ok := filterParams[\"PostalCode\"]; ok {\n\t\tdb = db.Where(\"postal_code IN (?) AND action_type = ?\", []string{postalCode.(string), \"backup\"}, \"modification\")\n\t} else {\n\t\tdb = db.Where(filterParams)\n\t}\n\n\terr := db.Order(\"created_at DESC\").Limit(limit).Find(&records).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to audit changes: %w\", err)\n\t}\n\n\treturn records, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按RegionCode过滤",
            "sql": "SELECT id, region_code, initiator_email, postal_code, action_type, status, created_at, updated_at FROM share_activities WHERE region_code = 'US' AND status = 'pending' ORDER BY created_at DESC LIMIT 10;"
          },
          {
            "scenario": "按EmailAddress过滤",
            "sql": "SELECT id, region_code, initiator_email, postal_code, action_type, status, created_at, updated_at FROM share_activities WHERE initiator_email LIKE '%example@company.com%' ORDER BY created_at DESC LIMIT 10;"
          },
          {
            "scenario": "按PostalCode过滤",
            "sql": "SELECT id, region_code, initiator_email, postal_code, action_type, status, created_at, updated_at FROM share_activities WHERE postal_code IN ('10001', 'backup') AND action_type = 'modification' ORDER BY created_at DESC LIMIT 10;"
          },
          {
            "scenario": "其他过滤条件",
            "sql": "SELECT id, region_code, initiator_email, postal_code, action_type, status, created_at, updated_at FROM share_activities WHERE action_type = 'update' AND status = 'approved' ORDER BY created_at DESC LIMIT 10;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "AuditRecord",
        "code_value": "type AuditRecord struct {\n\tID           int       `json:\"id\" gorm:\"column:id\"`\n\tRegionCode   string    `json:\"region_code\" gorm:\"column:region_code\"`\n\tEmailAddress string    `json:\"email_address\" gorm:\"column:initiator_email\"`\n\tPostalCode   string    `json:\"postal_code\" gorm:\"column:postal_code\"`\n\tActionType   string    `json:\"action_type\" gorm:\"column:action_type\"`\n\tStatus       string    `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt    time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt    time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "AuditStatus",
        "code_value": "const (\n\tAuditPending    = \"pending\"\n\tAuditApproved   = \"approved\"\n\tAuditRejected   = \"rejected\"\n\tAuditModification = \"modification\"\n)"
      },
      {
        "code_key": "AuditAction",
        "code_value": "const (\n\tActionCreate   = \"create\"\n\tActionUpdate   = \"update\"\n\tActionDelete   = \"delete\"\n\tActionBackup   = \"backup\"\n)"
      },
      {
        "code_key": "AuditFilter",
        "code_value": "type AuditFilter struct {\n\tRegionCode   string\n\tEmailAddress string\n\tPostalCode   string\n\tActionType   string\n\tStatus       string\n}"
      },
      {
        "code_key": "auditTableName",
        "code_value": "const auditTableName = \"share_activities\""
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "AuditChanges",
    "orm_code": "func (p *Project) AuditChanges(filterParams map[string]interface{}, limit int) ([]types.AuditRecord, error) {\n\tvar records []types.AuditRecord\n\tdb := base.GetInstance().MainDB().Table(\"share_activities\")\n\n\tif region, ok := filterParams[\"RegionCode\"]; ok {\n\t\tdb = db.Where(\"region_code = ? AND status = ?\", region.(string), \"pending\")\n\t} else if email, ok := filterParams[\"EmailAddress\"]; ok {\n\t\tdb = db.Where(\"initiator_email LIKE ?\", \"%\"+email.(string)+\"%\")\n\t} else if postalCode, ok := filterParams[\"PostalCode\"]; ok {\n\t\tdb = db.Where(\"postal_code IN (?) AND action_type = ?\", []string{postalCode.(string), \"backup\"}, \"modification\")\n\t} else {\n\t\tdb = db.Where(filterParams)\n\t}\n\n\terr := db.Order(\"created_at DESC\").Limit(limit).Find(&records).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to audit changes: %w\", err)\n\t}\n\n\treturn records, nil\n}",
    "caller": "func (s *AuditService) HandleAuditRecords(req *types.AuditRequest) ([]types.AuditRecord, error) {\n\tif req.Limit <= 0 || req.Limit > 100 {\n\t\treturn nil, fmt.Errorf(\"invalid limit value: %d\", req.Limit)\n\t}\n\n\tfilterCriteria := make(map[string]interface{})\n\tif req.SearchByRegion {\n\t\tif len(req.RegionCode) == 0 {\n\t\t\treturn nil, fmt.Errorf(\"region code required\")\n\t\t}\n\t\tfilterCriteria[\"RegionCode\"] = req.RegionCode\n\t} else if req.SearchByEmail {\n\t\tif len(req.Email) == 0 {\n\t\t\treturn nil, fmt.Errorf(\"email required\")\n\t\t}\n\t\tfilterCriteria[\"EmailAddress\"] = req.Email\n\t} else if req.SearchByPostalCode {\n\t\tif len(req.PostalCode) == 0 {\n\t\t\treturn nil, fmt.Errorf(\"postal code required\")\n\t\t}\n\t\tfilterCriteria[\"PostalCode\"] = req.PostalCode\n\t} else {\n\t\tfilterCriteria[\"status\"] = \"active\"\n\t}\n\n\tproject := &Project{}\n\tauditLogs, err := project.AuditChanges(filterCriteria, req.Limit)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to fetch audit records: %w\", err)\n\t}\n\n\treturn auditLogs, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按区域代码搜索 (SearchByRegion = true)",
            "sql": "SELECT id, region_code, initiator_email, postal_code, action_type, status, created_at, updated_at FROM share_activities WHERE region_code = ? AND status = 'pending' ORDER BY created_at DESC LIMIT ?;"
          },
          {
            "scenario": "按邮箱搜索 (SearchByEmail = true)",
            "sql": "SELECT id, region_code, initiator_email, postal_code, action_type, status, created_at, updated_at FROM share_activities WHERE initiator_email LIKE ? ORDER BY created_at DESC LIMIT ?;"
          },
          {
            "scenario": "按邮政编码搜索 (SearchByPostalCode = true)",
            "sql": "SELECT id, region_code, initiator_email, postal_code, action_type, status, created_at, updated_at FROM share_activities WHERE postal_code IN (?, 'backup') AND action_type = 'modification' ORDER BY created_at DESC LIMIT ?;"
          },
          {
            "scenario": "默认搜索（无特定搜索条件）",
            "sql": "SELECT id, region_code, initiator_email, postal_code, action_type, status, created_at, updated_at FROM share_activities WHERE status = ? ORDER BY created_at DESC LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "AuditRecord",
        "code_value": "type AuditRecord struct {\n\tID           int       `json:\"id\" gorm:\"column:id\"`\n\tRegionCode   string    `json:\"region_code\" gorm:\"column:region_code\"`\n\tEmailAddress string    `json:\"email_address\" gorm:\"column:initiator_email\"`\n\tPostalCode   string    `json:\"postal_code\" gorm:\"column:postal_code\"`\n\tActionType   string    `json:\"action_type\" gorm:\"column:action_type\"`\n\tStatus       string    `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt    time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt    time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "AuditStatus",
        "code_value": "const (\n\tAuditPending    = \"pending\"\n\tAuditApproved   = \"approved\"\n\tAuditRejected   = \"rejected\"\n\tAuditModification = \"modification\"\n)"
      },
      {
        "code_key": "AuditAction",
        "code_value": "const (\n\tActionCreate   = \"create\"\n\tActionUpdate   = \"update\"\n\tActionDelete   = \"delete\"\n\tActionBackup   = \"backup\"\n)"
      },
      {
        "code_key": "AuditFilter",
        "code_value": "type AuditFilter struct {\n\tRegionCode   string\n\tEmailAddress string\n\tPostalCode   string\n\tActionType   string\n\tStatus       string\n}"
      },
      {
        "code_key": "auditTableName",
        "code_value": "const auditTableName = \"share_activities\""
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "SearchInventoryRecords",
    "orm_code": "func (i *Inventory) SearchInventoryRecords(criteria map[string]interface{}, limit int) ([]types.InventoryRecord, error) {\n\tvar records []types.InventoryRecord\n\tdb := base.GetInstance().GormDB().Table(\"inventory_claims\")\n\n\tif itemCode, ok := criteria[\"item_code\"]; ok {\n\t\tdb = db.Where(\"item_code LIKE ?\", \"%\"+itemCode.(string)+\"%\")\n\t} else if location, ok := criteria[\"location\"]; ok {\n\t\tdb = db.Where(\"location = ? AND status = ?\", location.(string), \"active\")\n\t} else if minBalance, ok := criteria[\"min_balance\"]; ok {\n\t\tdb = db.Where(\"current_balance >= ?\", minBalance.(int))\n\t\tif maxBalance, ok := criteria[\"max_balance\"]; ok {\n\t\t\tdb = db.Where(\"current_balance <= ?\", maxBalance.(int))\n\t\t}\n\t} else {\n\t\tdb = db.Where(criteria)\n\t}\n\n\terr := db.Order(\"last_updated DESC\").Limit(limit).Find(&records).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to search inventory: %w\", err)\n\t}\n\treturn records, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "criteria contains item_code",
            "sql": "SELECT id, item_code, location, current_balance, status, last_updated FROM inventory_claims WHERE item_code LIKE '%ABC123%' ORDER BY last_updated DESC LIMIT 10;"
          },
          {
            "scenario": "criteria contains location but not item_code",
            "sql": "SELECT id, item_code, location, current_balance, status, last_updated FROM inventory_claims WHERE location = 'Warehouse1' AND status = 'active' ORDER BY last_updated DESC LIMIT 10;"
          },
          {
            "scenario": "criteria contains min_balance only",
            "sql": "SELECT id, item_code, location, current_balance, status, last_updated FROM inventory_claims WHERE current_balance >= 100 ORDER BY last_updated DESC LIMIT 10;"
          },
          {
            "scenario": "criteria contains both min_balance and max_balance",
            "sql": "SELECT id, item_code, location, current_balance, status, last_updated FROM inventory_claims WHERE current_balance >= 100 AND current_balance <= 1000 ORDER BY last_updated DESC LIMIT 10;"
          },
          {
            "scenario": "criteria contains other fields or is empty",
            "sql": "SELECT id, item_code, location, current_balance, status, last_updated FROM inventory_claims WHERE status = 'inactive' ORDER BY last_updated DESC LIMIT 10;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "InventoryRecord",
        "code_value": "type InventoryRecord struct {\n\tID            int       `json:\"id\" gorm:\"column:id;primaryKey\"`\n\tItemCode      string    `json:\"item_code\" gorm:\"column:item_code\"`\n\tLocation      string    `json:\"location\" gorm:\"column:location\"`\n\tCurrentBalance int       `json:\"current_balance\" gorm:\"column:current_balance\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n\tLastUpdated   time.Time `json:\"last_updated\" gorm:\"column:last_updated\"`\n}"
      },
      {
        "code_key": "InventoryQueryParams",
        "code_value": "type InventoryQueryParams struct {\n\tItemCode   *string `json:\"item_code\"`\n\tLocation   *string `json:\"location\"`\n\tMinBalance *int    `json:\"min_balance\"`\n\tMaxBalance *int    `json:\"max_balance\"`\n\tLimit      int     `json:\"limit\"`\n}"
      },
      {
        "code_key": "InventoryStatus",
        "code_value": "const (\n\tInventoryStatusActive   = \"active\"\n\tInventoryStatusInactive = \"inactive\"\n\tInventoryStatusArchived = \"archived\"\n)"
      },
      {
        "code_key": "DefaultInventoryLimit",
        "code_value": "const DefaultInventoryLimit = 100"
      },
      {
        "code_key": "InventoryTableName",
        "code_value": "const InventoryTableName = \"inventory_claims\""
      },
      {
        "code_key": "InventoryReport",
        "code_value": "type InventoryReport struct {\n\tInventoryRecord\n\tAdditionalNotes string `json:\"additional_notes\"`\n}"
      }
    ],
    "sql_pattern_cnt": 4
  },
  {
    "function_name": "SearchInventoryRecords",
    "orm_code": "func (i *Inventory) SearchInventoryRecords(criteria map[string]interface{}, limit int) ([]types.InventoryRecord, error) {\n\tvar records []types.InventoryRecord\n\tdb := base.GetInstance().GormDB().Table(\"inventory_claims\")\n\n\tif itemCode, ok := criteria[\"item_code\"]; ok {\n\t\tdb = db.Where(\"item_code LIKE ?\", \"%\"+itemCode.(string)+\"%\")\n\t} else if location, ok := criteria[\"location\"]; ok {\n\t\tdb = db.Where(\"location = ? AND status = ?\", location.(string), \"active\")\n\t} else if minBalance, ok := criteria[\"min_balance\"]; ok {\n\t\tdb = db.Where(\"current_balance >= ?\", minBalance.(int))\n\t\tif maxBalance, ok := criteria[\"max_balance\"]; ok {\n\t\t\tdb = db.Where(\"current_balance <= ?\", maxBalance.(int))\n\t\t}\n\t} else {\n\t\tdb = db.Where(criteria)\n\t}\n\n\terr := db.Order(\"last_updated DESC\").Limit(limit).Find(&records).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to search inventory: %w\", err)\n\t}\n\treturn records, nil\n}",
    "caller": "func (s *InventoryService) HandleInventorySearch(filter *types.InventoryFilter) ([]types.InventoryRecord, error) {\n\tif filter == nil {\n\t\treturn nil, fmt.Errorf(\"filter parameters cannot be empty\")\n\t}\n\n\tsearchCriteria := make(map[string]interface{})\n\n\tif filter.ItemCode != \"\" {\n\t\tsearchCriteria[\"item_code\"] = filter.ItemCode\n\t} else if filter.Location != \"\" {\n\t\tsearchCriteria[\"location\"] = filter.Location\n\t} else if filter.MinBalance > 0 {\n\t\tsearchCriteria[\"min_balance\"] = filter.MinBalance\n\t\tif filter.MaxBalance > 0 {\n\t\t\tsearchCriteria[\"max_balance\"] = filter.MaxBalance\n\t\t}\n\t} else {\n\t\tsearchCriteria[\"status\"] = \"active\"\n\t}\n\n\tinventory := &Inventory{}\n\trecords, err := inventory.SearchInventoryRecords(searchCriteria, filter.Limit)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"inventory search failed: %w\", err)\n\t}\n\treturn records, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按商品代码(item_code)模糊查询",
            "sql": "SELECT id, item_code, location, current_balance, status, last_updated FROM inventory_claims WHERE item_code LIKE '%ABC123%' ORDER BY last_updated DESC LIMIT 50;"
          },
          {
            "scenario": "按位置(location)精确查询且状态为active",
            "sql": "SELECT id, item_code, location, current_balance, status, last_updated FROM inventory_claims WHERE location = 'WH-01' AND status = 'active' ORDER BY last_updated DESC LIMIT 50;"
          },
          {
            "scenario": "按最小库存(min_balance)查询",
            "sql": "SELECT id, item_code, location, current_balance, status, last_updated FROM inventory_claims WHERE current_balance >= 100 ORDER BY last_updated DESC LIMIT 50;"
          },
          {
            "scenario": "按库存范围(min_balance和max_balance)查询",
            "sql": "SELECT id, item_code, location, current_balance, status, last_updated FROM inventory_claims WHERE current_balance >= 100 AND current_balance <= 1000 ORDER BY last_updated DESC LIMIT 50;"
          },
          {
            "scenario": "默认查询（无特定条件）",
            "sql": "SELECT id, item_code, location, current_balance, status, last_updated FROM inventory_claims WHERE status = 'active' ORDER BY last_updated DESC LIMIT 50;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "InventoryRecord",
        "code_value": "type InventoryRecord struct {\n\tID            int       `json:\"id\" gorm:\"column:id;primaryKey\"`\n\tItemCode      string    `json:\"item_code\" gorm:\"column:item_code\"`\n\tLocation      string    `json:\"location\" gorm:\"column:location\"`\n\tCurrentBalance int       `json:\"current_balance\" gorm:\"column:current_balance\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n\tLastUpdated   time.Time `json:\"last_updated\" gorm:\"column:last_updated\"`\n}"
      },
      {
        "code_key": "InventoryQueryParams",
        "code_value": "type InventoryQueryParams struct {\n\tItemCode   *string `json:\"item_code\"`\n\tLocation   *string `json:\"location\"`\n\tMinBalance *int    `json:\"min_balance\"`\n\tMaxBalance *int    `json:\"max_balance\"`\n\tLimit      int     `json:\"limit\"`\n}"
      },
      {
        "code_key": "InventoryStatus",
        "code_value": "const (\n\tInventoryStatusActive   = \"active\"\n\tInventoryStatusInactive = \"inactive\"\n\tInventoryStatusArchived = \"archived\"\n)"
      },
      {
        "code_key": "DefaultInventoryLimit",
        "code_value": "const DefaultInventoryLimit = 100"
      },
      {
        "code_key": "InventoryTableName",
        "code_value": "const InventoryTableName = \"inventory_claims\""
      },
      {
        "code_key": "InventoryReport",
        "code_value": "type InventoryReport struct {\n\tInventoryRecord\n\tAdditionalNotes string `json:\"additional_notes\"`\n}"
      }
    ],
    "sql_pattern_cnt": 4
  },
  {
    "function_name": "CheckIntegrity",
    "orm_code": "func (m *Media) CheckIntegrity(filters map[string]interface{}) ([]types.SymptomRecord, error) {\n\trecords := make([]types.SymptomRecord, 0)\n\tdb := base.GetInstance().GormDB().Table(\"content_categories\")\n\t\n\tif format, ok := filters[\"Format\"]; ok {\n\t\t// Exact match for format with additional status filter\n\t\tif status, ok := filters[\"status\"]; ok {\n\t\t\tdb = db.Where(\"format = ? AND status = ?\", format, status)\n\t\t} else {\n\t\t\tdb = db.Where(\"format = ?\", format)\n\t\t}\n\t} else if connStr, ok := filters[\"ConnectionString\"]; ok {\n\t\t// Partial match for connection string\n\t\tdb = db.Where(\"connection_string LIKE ?\", \"%\"+connStr.(string)+\"%\")\n\t} else if displayName, ok := filters[\"DisplayName\"]; ok {\n\t\t// Combined condition with created_at range\n\t\tif startDate, ok := filters[\"start_date\"]; ok {\n\t\t\tdb = db.Where(\"display_name = ? AND created_at >= ?\", displayName, startDate)\n\t\t} else {\n\t\t\tdb = db.Where(\"display_name = ?\", displayName)\n\t\t}\n\t} else {\n\t\t// Default case with basic filtering\n\t\tdb = db.Where(filters)\n\t}\n\n\tif err := db.Order(\"created_at DESC\").Find(&records).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"database error: %w\", err)\n\t}\n\treturn records, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "包含Format和status参数",
            "sql": "SELECT id, format, status, display_name, connection_string, created_at FROM content_categories WHERE format = ? AND status = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "仅包含Format参数",
            "sql": "SELECT id, format, status, display_name, connection_string, created_at FROM content_categories WHERE format = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "包含ConnectionString参数",
            "sql": "SELECT id, format, status, display_name, connection_string, created_at FROM content_categories WHERE connection_string LIKE ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "包含DisplayName和start_date参数",
            "sql": "SELECT id, format, status, display_name, connection_string, created_at FROM content_categories WHERE display_name = ? AND created_at >= ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "仅包含DisplayName参数",
            "sql": "SELECT id, format, status, display_name, connection_string, created_at FROM content_categories WHERE display_name = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "默认filter组合",
            "sql": "SELECT id, format, status, display_name, connection_string, created_at FROM content_categories WHERE status = ? AND content_type = ? ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "SymptomRecord",
        "code_value": "type SymptomRecord struct {\n\tID          int       `json:\"id\" gorm:\"primaryKey\"`\n\tFormat      string    `json:\"format\" gorm:\"column:format\"`\n\tStatus      string    `json:\"status\" gorm:\"column:status\"`\n\tDisplayName string    `json:\"display_name\" gorm:\"column:display_name\"`\n\tConnString  string    `json:\"connection_string\" gorm:\"column:connection_string\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "Media",
        "code_value": "type Media struct {\n\tID          uint   `gorm:\"primaryKey\"`\n\tContentType string `gorm:\"column:content_type\"`\n\tContentID   string `gorm:\"column:content_id\"`\n\tStoragePath string `gorm:\"column:storage_path\"`\n}"
      },
      {
        "code_key": "ContentCategoryTable",
        "code_value": "const ContentCategoryTable = \"content_categories\""
      },
      {
        "code_key": "MediaStatus",
        "code_value": "const (\n\tMediaStatusActive = \"active\"\n\tMediaStatusDraft = \"draft\"\n\tMediaStatusArchived = \"archived\"\n)"
      }
    ],
    "sql_pattern_cnt": 4
  },
  {
    "function_name": "CheckIntegrity",
    "orm_code": "func (m *Media) CheckIntegrity(filters map[string]interface{}) ([]types.SymptomRecord, error) {\n\trecords := make([]types.SymptomRecord, 0)\n\tdb := base.GetInstance().GormDB().Table(\"content_categories\")\n\t\n\tif format, ok := filters[\"Format\"]; ok {\n\t\t// Exact match for format with additional status filter\n\t\tif status, ok := filters[\"status\"]; ok {\n\t\t\tdb = db.Where(\"format = ? AND status = ?\", format, status)\n\t\t} else {\n\t\t\tdb = db.Where(\"format = ?\", format)\n\t\t}\n\t} else if connStr, ok := filters[\"ConnectionString\"]; ok {\n\t\t// Partial match for connection string\n\t\tdb = db.Where(\"connection_string LIKE ?\", \"%\"+connStr.(string)+\"%\")\n\t} else if displayName, ok := filters[\"DisplayName\"]; ok {\n\t\t// Combined condition with created_at range\n\t\tif startDate, ok := filters[\"start_date\"]; ok {\n\t\t\tdb = db.Where(\"display_name = ? AND created_at >= ?\", displayName, startDate)\n\t\t} else {\n\t\t\tdb = db.Where(\"display_name = ?\", displayName)\n\t\t}\n\t} else {\n\t\t// Default case with basic filtering\n\t\tdb = db.Where(filters)\n\t}\n\n\tif err := db.Order(\"created_at DESC\").Find(&records).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"database error: %w\", err)\n\t}\n\treturn records, nil\n}",
    "caller": "func (s *MediaService) HandleMediaRecords(req *types.MediaQueryRequest) ([]types.SymptomRecord, error) {\n\tif req == nil {\n\t\treturn nil, fmt.Errorf(\"invalid request: nil parameter\")\n\t}\n\n\tmediaObj := &Media{}\n\tqueryFilters := make(map[string]interface{})\n\n\tswitch req.QueryType {\n\tcase \"format\":\n\t\tqueryFilters[\"Format\"] = req.Format\n\t\tif req.Status != \"\" {\n\t\t\tqueryFilters[\"status\"] = req.Status\n\t\t}\n\tcase \"connection\":\n\t\tqueryFilters[\"ConnectionString\"] = req.ConnectionStr\n\tcase \"display\":\n\t\tqueryFilters[\"DisplayName\"] = req.DisplayName\n\t\tif !req.StartDate.IsZero() {\n\t\t\tqueryFilters[\"start_date\"] = req.StartDate\n\t\t}\n\tdefault:\n\t\tif len(req.BasicFilters) > 0 {\n\t\t\tqueryFilters = req.BasicFilters\n\t\t}\n\t}\n\n\trecords, err := mediaObj.CheckIntegrity(queryFilters)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to check media integrity: %w\", err)\n\t}\n\treturn records, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Format query with status filter",
            "sql": "SELECT id, format, status, display_name, connection_string, created_at FROM content_categories WHERE format = ? AND status = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "Format query without status filter",
            "sql": "SELECT id, format, status, display_name, connection_string, created_at FROM content_categories WHERE format = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "ConnectionString query with LIKE pattern",
            "sql": "SELECT id, format, status, display_name, connection_string, created_at FROM content_categories WHERE connection_string LIKE ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "DisplayName query with date range",
            "sql": "SELECT id, format, status, display_name, connection_string, created_at FROM content_categories WHERE display_name = ? AND created_at >= ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "DisplayName query without date range",
            "sql": "SELECT id, format, status, display_name, connection_string, created_at FROM content_categories WHERE display_name = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "Basic filters query",
            "sql": "SELECT id, format, status, display_name, connection_string, created_at FROM content_categories WHERE status = ? ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "SymptomRecord",
        "code_value": "type SymptomRecord struct {\n\tID          int       `json:\"id\" gorm:\"primaryKey\"`\n\tFormat      string    `json:\"format\" gorm:\"column:format\"`\n\tStatus      string    `json:\"status\" gorm:\"column:status\"`\n\tDisplayName string    `json:\"display_name\" gorm:\"column:display_name\"`\n\tConnString  string    `json:\"connection_string\" gorm:\"column:connection_string\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "Media",
        "code_value": "type Media struct {\n\tID          uint   `gorm:\"primaryKey\"`\n\tContentType string `gorm:\"column:content_type\"`\n\tContentID   string `gorm:\"column:content_id\"`\n\tStoragePath string `gorm:\"column:storage_path\"`\n}"
      },
      {
        "code_key": "ContentCategoryTable",
        "code_value": "const ContentCategoryTable = \"content_categories\""
      },
      {
        "code_key": "MediaStatus",
        "code_value": "const (\n\tMediaStatusActive = \"active\"\n\tMediaStatusDraft = \"draft\"\n\tMediaStatusArchived = \"archived\"\n)"
      }
    ],
    "sql_pattern_cnt": 4
  },
  {
    "function_name": "UpdateEntity",
    "orm_code": "func (p *Patient) UpdateEntity(filterParams map[string]interface{}, updateData map[string]interface{}) (int64, error) {\n\tvar affectedRows int64\n\tvar err error\n\n\tdb := base.GetInstance().HealthDriver().Table(\"inventory_items\")\n\n\tif netValue, ok := filterParams[\"NetValue\"]; ok {\n\t\t// Fuzzy match on NetValue and exact match on Status\n\t\terr = db.Where(\"net_value LIKE ?\", \"%\"+netValue.(string)+\"%\").\n\t\t\tWhere(\"status = ?\", filterParams[\"Status\"]).\n\t\t\tUpdates(updateData).\n\t\t\tError\n\t} else if approvalLevel, ok := filterParams[\"ApprovalLevel\"]; ok {\n\t\t// Range query on ApprovalLevel with Credits check\n\t\terr = db.Where(\"approval_level BETWEEN ? AND ?\", \n\t\t\tapprovalLevel.(int)-1, approvalLevel.(int)+1).\n\t\t\tWhere(\"credits > ?\", filterParams[\"MinCredits\"]).\n\t\t\tUpdates(updateData).\n\t\t\tError\n\t} else if department, ok := filterParams[\"Department\"]; ok {\n\t\t// Exact match on Department with date range\n\t\terr = db.Where(\"department = ?\", department).\n\t\t\tWhere(\"created_at BETWEEN ? AND ?\", \n\t\t\tfilterParams[\"StartDate\"], filterParams[\"EndDate\"]).\n\t\t\tUpdates(updateData).\n\t\t\tError\n\t} else {\n\t\t// Default update without specific filters\n\t\terr = db.Updates(updateData).Error\n\t}\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn 0, nil\n\t\t}\n\t\treturn 0, fmt.Errorf(\"failed to update entity: %v\", err)\n\t}\n\n\taffectedRows = db.RowsAffected\n\treturn affectedRows, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "NetValue模糊匹配 + Status精确匹配",
            "sql": "UPDATE inventory_items SET status = 'approved', updated_at = '2023-11-15 12:00:00' WHERE net_value LIKE '%100%' AND status = 'pending';"
          },
          {
            "scenario": "ApprovalLevel范围查询 + Credits最小值",
            "sql": "UPDATE inventory_items SET approval_level = 4, credits = 600.0 WHERE approval_level BETWEEN 2 AND 4 AND credits > 500.0;"
          },
          {
            "scenario": "Department精确匹配 + 创建日期范围",
            "sql": "UPDATE inventory_items SET department = 'Operations' WHERE department = 'IT' AND created_at BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';"
          },
          {
            "scenario": "无特定条件的默认更新",
            "sql": "UPDATE inventory_items SET status = 'approved';"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "InventoryItem",
        "code_value": "type InventoryItem struct {\n\tID            int       `json:\"id\" gorm:\"column:id;primaryKey\"`\n\tNetValue      string    `json:\"net_value\" gorm:\"column:net_value\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n\tApprovalLevel int       `json:\"approval_level\" gorm:\"column:approval_level\"`\n\tCredits       float64   `json:\"credits\" gorm:\"column:credits\"`\n\tDepartment    string    `json:\"department\" gorm:\"column:department\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`"
      },
      {
        "code_key": "InventoryStatus",
        "code_value": "const (\n\tInventoryStatusPending  = \"pending\"\n\tInventoryStatusApproved = \"approved\"\n\tInventoryStatusRejected = \"rejected\"\n)"
      },
      {
        "code_key": "UpdateRequest",
        "code_value": "type UpdateRequest struct {\n\tFilterParams map[string]interface{} `json:\"filter_params\"`\n\tUpdateData   map[string]interface{} `json:\"update_data\"`"
      },
      {
        "code_key": "DefaultApprovalRange",
        "code_value": "const DefaultApprovalRange = 2"
      },
      {
        "code_key": "DepartmentList",
        "code_value": "var DepartmentList = []string{\"HR\", \"Finance\", \"IT\", \"Operations\"}"
      }
    ],
    "sql_pattern_cnt": 4
  },
  {
    "function_name": "UpdateEntity",
    "orm_code": "func (p *Patient) UpdateEntity(filterParams map[string]interface{}, updateData map[string]interface{}) (int64, error) {\n\tvar affectedRows int64\n\tvar err error\n\n\tdb := base.GetInstance().HealthDriver().Table(\"inventory_items\")\n\n\tif netValue, ok := filterParams[\"NetValue\"]; ok {\n\t\t// Fuzzy match on NetValue and exact match on Status\n\t\terr = db.Where(\"net_value LIKE ?\", \"%\"+netValue.(string)+\"%\").\n\t\t\tWhere(\"status = ?\", filterParams[\"Status\"]).\n\t\t\tUpdates(updateData).\n\t\t\tError\n\t} else if approvalLevel, ok := filterParams[\"ApprovalLevel\"]; ok {\n\t\t// Range query on ApprovalLevel with Credits check\n\t\terr = db.Where(\"approval_level BETWEEN ? AND ?\", \n\t\t\tapprovalLevel.(int)-1, approvalLevel.(int)+1).\n\t\t\tWhere(\"credits > ?\", filterParams[\"MinCredits\"]).\n\t\t\tUpdates(updateData).\n\t\t\tError\n\t} else if department, ok := filterParams[\"Department\"]; ok {\n\t\t// Exact match on Department with date range\n\t\terr = db.Where(\"department = ?\", department).\n\t\t\tWhere(\"created_at BETWEEN ? AND ?\", \n\t\t\tfilterParams[\"StartDate\"], filterParams[\"EndDate\"]).\n\t\t\tUpdates(updateData).\n\t\t\tError\n\t} else {\n\t\t// Default update without specific filters\n\t\terr = db.Updates(updateData).Error\n\t}\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn 0, nil\n\t\t}\n\t\treturn 0, fmt.Errorf(\"failed to update entity: %v\", err)\n\t}\n\n\taffectedRows = db.RowsAffected\n\treturn affectedRows, nil\n}",
    "caller": "func (s *PatientService) HandlePatientUpdate(updateReq *PatientUpdateRequest) (int64, error) {\n\tif updateReq == nil {\n\t\treturn 0, fmt.Errorf(\"update request cannot be nil\")\n\t}\n\n\tfilterParams := make(map[string]interface{})\n\tupdateFields := make(map[string]interface{})\n\n\t// Build different query strategies based on input\n\tif updateReq.NetValue != \"\" {\n\t\tfilterParams[\"NetValue\"] = updateReq.NetValue\n\t\tfilterParams[\"Status\"] = updateReq.Status\n\t} else if updateReq.ApprovalLevel > 0 {\n\t\tfilterParams[\"ApprovalLevel\"] = updateReq.ApprovalLevel\n\t\tfilterParams[\"MinCredits\"] = updateReq.MinCredits\n\t} else if updateReq.Department != \"\" {\n\t\tfilterParams[\"Department\"] = updateReq.Department\n\t\tfilterParams[\"StartDate\"] = updateReq.StartDate\n\t\tfilterParams[\"EndDate\"] = updateReq.EndDate\n\t}\n\n\t// Set update fields\n\tif updateReq.Name != \"\" {\n\t\tupdateFields[\"name\"] = updateReq.Name\n\t}\n\tif updateReq.Age > 0 {\n\t\tupdateFields[\"age\"] = updateReq.Age\n\t}\n\n\tpatient := &Patient{}\n\taffected, err := patient.UpdateEntity(filterParams, updateFields)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to update patient: %v\", err)\n\t}\n\n\treturn affected, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "NetValue和Status条件",
            "sql": "UPDATE inventory_items SET name = 'John', age = 30, updated_at = CURRENT_TIMESTAMP WHERE net_value LIKE '%100%' AND status = 'pending';"
          },
          {
            "scenario": "ApprovalLevel和MinCredits条件",
            "sql": "UPDATE inventory_items SET name = 'John', age = 30, updated_at = CURRENT_TIMESTAMP WHERE approval_level BETWEEN 2 AND 4 AND credits > 1000.0;"
          },
          {
            "scenario": "Department和日期范围条件",
            "sql": "UPDATE inventory_items SET name = 'John', age = 30, updated_at = CURRENT_TIMESTAMP WHERE department = 'IT' AND created_at BETWEEN '2023-01-01' AND '2023-12-31';"
          },
          {
            "scenario": "无条件更新",
            "sql": "UPDATE inventory_items SET name = 'John', age = 30, updated_at = CURRENT_TIMESTAMP;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "InventoryItem",
        "code_value": "type InventoryItem struct {\n\tID            int       `json:\"id\" gorm:\"column:id;primaryKey\"`\n\tNetValue      string    `json:\"net_value\" gorm:\"column:net_value\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n\tApprovalLevel int       `json:\"approval_level\" gorm:\"column:approval_level\"`\n\tCredits       float64   `json:\"credits\" gorm:\"column:credits\"`\n\tDepartment    string    `json:\"department\" gorm:\"column:department\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`"
      },
      {
        "code_key": "InventoryStatus",
        "code_value": "const (\n\tInventoryStatusPending  = \"pending\"\n\tInventoryStatusApproved = \"approved\"\n\tInventoryStatusRejected = \"rejected\"\n)"
      },
      {
        "code_key": "UpdateRequest",
        "code_value": "type UpdateRequest struct {\n\tFilterParams map[string]interface{} `json:\"filter_params\"`\n\tUpdateData   map[string]interface{} `json:\"update_data\"`"
      },
      {
        "code_key": "DefaultApprovalRange",
        "code_value": "const DefaultApprovalRange = 2"
      },
      {
        "code_key": "DepartmentList",
        "code_value": "var DepartmentList = []string{\"HR\", \"Finance\", \"IT\", \"Operations\"}"
      }
    ],
    "sql_pattern_cnt": 4
  },
  {
    "function_name": "SearchDoctorByConditions",
    "orm_code": "func (d *Doctor) SearchDoctorByConditions(params map[string]interface{}, limit int) ([]types.DoctorProfile, error) {\n\tvar profiles []types.DoctorProfile\n\tquery := base.GetInstance().ClinicDB().Table(\"player_rankings\").Select(\"*\")\n\n\tif specialization, ok := params[\"specialization\"]; ok {\n\t\tquery = query.Where(\"specialization = ?\", specialization)\n\t} else if phone, ok := params[\"phone_number\"]; ok {\n\t\tquery = query.Where(\"phone_number LIKE ?\", \"%\"+phone.(string)+\"%\")\n\t} else if zone, ok := params[\"zone\"]; ok {\n\t\tquery = query.Where(\"zone = ? AND is_active = true\", zone)\n\t} else {\n\t\tquery = query.Where(\"rating > 4.5\").Order(\"creation_time DESC\")\n\t}\n\n\tif limit > 0 {\n\t\tquery = query.Limit(limit)\n\t}\n\n\tif err := query.Find(&profiles).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, fmt.Errorf(\"no doctors found matching criteria\")\n\t\t}\n\t\treturn nil, fmt.Errorf(\"database error: %w\", err)\n\t}\n\n\treturn profiles, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "传入specialization参数",
            "sql": "SELECT * FROM player_rankings WHERE specialization = ? LIMIT ?;"
          },
          {
            "scenario": "传入phone_number参数",
            "sql": "SELECT * FROM player_rankings WHERE phone_number LIKE ? LIMIT ?;"
          },
          {
            "scenario": "传入zone参数",
            "sql": "SELECT * FROM player_rankings WHERE zone = ? AND is_active = true LIMIT ?;"
          },
          {
            "scenario": "不传入任何条件参数",
            "sql": "SELECT * FROM player_rankings WHERE rating > 4.5 ORDER BY creation_time DESC LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "DoctorProfile",
        "code_value": "type DoctorProfile struct {\n\tID              int       `json:\"id\" gorm:\"column:id\"`\n\tName            string    `json:\"name\" gorm:\"column:name\"`\n\tSpecialization  string    `json:\"specialization\" gorm:\"column:specialization\"`\n\tPhoneNumber     string    `json:\"phone_number\" gorm:\"column:phone_number\"`\n\tZone            string    `json:\"zone\" gorm:\"column:zone\"`\n\tRating          float64   `json:\"rating\" gorm:\"column:rating\"`\n\tIsActive        bool      `json:\"is_active\" gorm:\"column:is_active\"`\n\tCreationTime    time.Time `json:\"creation_time\" gorm:\"column:creation_time\"`\n}"
      },
      {
        "code_key": "DoctorSearchRequest",
        "code_value": "type DoctorSearchRequest struct {\n\tSpecialization string `json:\"specialization\"`\n\tPhoneNumber    string `json:\"phone_number\"`\n\tZone           string `json:\"zone\"`\n\tLimit          int    `json:\"limit\"`\n}"
      },
      {
        "code_key": "DoctorTableName",
        "code_value": "const DoctorTableName = \"player_rankings\""
      },
      {
        "code_key": "MinHighRating",
        "code_value": "const MinHighRating = 4.5"
      },
      {
        "code_key": "DefaultQueryLimit",
        "code_value": "const DefaultQueryLimit = 20"
      },
      {
        "code_key": "DoctorStatus",
        "code_value": "type DoctorStatus struct {\n\tActive   bool `json:\"active\"`\n\tVerified bool `json:\"verified\"`\n}"
      }
    ],
    "sql_pattern_cnt": 4
  },
  {
    "function_name": "SearchDoctorByConditions",
    "orm_code": "func (d *Doctor) SearchDoctorByConditions(params map[string]interface{}, limit int) ([]types.DoctorProfile, error) {\n\tvar profiles []types.DoctorProfile\n\tquery := base.GetInstance().ClinicDB().Table(\"player_rankings\").Select(\"*\")\n\n\tif specialization, ok := params[\"specialization\"]; ok {\n\t\tquery = query.Where(\"specialization = ?\", specialization)\n\t} else if phone, ok := params[\"phone_number\"]; ok {\n\t\tquery = query.Where(\"phone_number LIKE ?\", \"%\"+phone.(string)+\"%\")\n\t} else if zone, ok := params[\"zone\"]; ok {\n\t\tquery = query.Where(\"zone = ? AND is_active = true\", zone)\n\t} else {\n\t\tquery = query.Where(\"rating > 4.5\").Order(\"creation_time DESC\")\n\t}\n\n\tif limit > 0 {\n\t\tquery = query.Limit(limit)\n\t}\n\n\tif err := query.Find(&profiles).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, fmt.Errorf(\"no doctors found matching criteria\")\n\t\t}\n\t\treturn nil, fmt.Errorf(\"database error: %w\", err)\n\t}\n\n\treturn profiles, nil\n}",
    "caller": "func HandleDoctorSearch(criteria *types.DoctorSearchCriteria) ([]types.DoctorProfile, error) {\n\tif criteria == nil {\n\t\treturn nil, fmt.Errorf(\"search criteria cannot be nil\")\n\t}\n\n\tsearchParams := make(map[string]interface{})\n\tif criteria.Specialization != \"\" {\n\t\tsearchParams[\"specialization\"] = criteria.Specialization\n\t} else if criteria.PhoneNumber != \"\" {\n\t\tsearchParams[\"phone_number\"] = criteria.PhoneNumber\n\t} else if criteria.ZoneID > 0 {\n\t\tsearchParams[\"zone\"] = criteria.ZoneID\n\t}\n\n\tdoctorDB := &Doctor{}\n\tprofiles, err := doctorDB.SearchDoctorByConditions(searchParams, criteria.Limit)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to search doctors: %w\", err)\n\t}\n\n\tif len(profiles) == 0 {\n\t\treturn nil, fmt.Errorf(\"no matching doctors found\")\n\t}\n\n\treturn profiles, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按specialization搜索",
            "sql": "SELECT * FROM player_rankings WHERE specialization = ? LIMIT ?;"
          },
          {
            "scenario": "按phone_number模糊搜索",
            "sql": "SELECT * FROM player_rankings WHERE phone_number LIKE ? LIMIT ?;"
          },
          {
            "scenario": "按zone搜索且is_active=true",
            "sql": "SELECT * FROM player_rankings WHERE zone = ? AND is_active = true LIMIT ?;"
          },
          {
            "scenario": "默认查询（rating>4.5）",
            "sql": "SELECT * FROM player_rankings WHERE rating > 4.5 ORDER BY creation_time DESC LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "DoctorProfile",
        "code_value": "type DoctorProfile struct {\n\tID              int       `json:\"id\" gorm:\"column:id\"`\n\tName            string    `json:\"name\" gorm:\"column:name\"`\n\tSpecialization  string    `json:\"specialization\" gorm:\"column:specialization\"`\n\tPhoneNumber     string    `json:\"phone_number\" gorm:\"column:phone_number\"`\n\tZone            string    `json:\"zone\" gorm:\"column:zone\"`\n\tRating          float64   `json:\"rating\" gorm:\"column:rating\"`\n\tIsActive        bool      `json:\"is_active\" gorm:\"column:is_active\"`\n\tCreationTime    time.Time `json:\"creation_time\" gorm:\"column:creation_time\"`\n}"
      },
      {
        "code_key": "DoctorSearchRequest",
        "code_value": "type DoctorSearchRequest struct {\n\tSpecialization string `json:\"specialization\"`\n\tPhoneNumber    string `json:\"phone_number\"`\n\tZone           string `json:\"zone\"`\n\tLimit          int    `json:\"limit\"`\n}"
      },
      {
        "code_key": "DoctorTableName",
        "code_value": "const DoctorTableName = \"player_rankings\""
      },
      {
        "code_key": "MinHighRating",
        "code_value": "const MinHighRating = 4.5"
      },
      {
        "code_key": "DefaultQueryLimit",
        "code_value": "const DefaultQueryLimit = 20"
      },
      {
        "code_key": "DoctorStatus",
        "code_value": "type DoctorStatus struct {\n\tActive   bool `json:\"active\"`\n\tVerified bool `json:\"verified\"`\n}"
      }
    ],
    "sql_pattern_cnt": 4
  },
  {
    "function_name": "FindMagazineByCriteria",
    "orm_code": "func (m *Magazine) FindMagazineByCriteria(filter map[string]interface{}, page, size int) ([]types.MagazineRecord, error) {\n\tvar records []types.MagazineRecord\n\tdb := base.GetInstance().GormDB().Table(\"magazines\")\n\n\tif percentage, ok := filter[\"Percentage\"]; ok {\n\t\tdb = db.Where(\"percentage > ?\", percentage.(float64))\n\t} else if publication, ok := filter[\"Publication\"]; ok {\n\t\tdb = db.Where(\"publication_date BETWEEN ? AND ?\", \n\t\t\tpublication.(map[string]interface{})[\"start\"], \n\t\t\tpublication.(map[string]interface{})[\"end\"])\n\t} else if area, ok := filter[\"Area\"]; ok {\n\t\tdb = db.Where(\"area LIKE ?\", \"%\"+area.(string)+\"%\")\n\t} else {\n\t\tdb = db.Where(filter)\n\t}\n\n\terr := db.Scopes(PaginateDB(page, size)).\n\t\tOrder(\"created_at DESC\").\n\t\tFind(&records).Error\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Percentage条件过滤",
            "sql": "SELECT id, title, percentage, area, publication_date, created_at FROM magazines WHERE percentage > ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "Publication日期范围过滤",
            "sql": "SELECT id, title, percentage, area, publication_date, created_at FROM magazines WHERE publication_date BETWEEN ? AND ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "Area模糊匹配",
            "sql": "SELECT id, title, percentage, area, publication_date, created_at FROM magazines WHERE area LIKE ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "通用filter条件",
            "sql": "SELECT id, title, percentage, area, publication_date, created_at FROM magazines WHERE title = ? AND percentage = ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "无filter条件",
            "sql": "SELECT id, title, percentage, area, publication_date, created_at FROM magazines ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "MagazineRecord",
        "code_value": "type MagazineRecord struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tTitle         string    `json:\"title\" gorm:\"column:title\"`\n\tPercentage    float64   `json:\"percentage\" gorm:\"column:percentage\"`\n\tArea          string    `json:\"area\" gorm:\"column:area\"`\n\tPublicationDate time.Time `json:\"publication_date\" gorm:\"column:publication_date\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "MagazineFilter",
        "code_value": "type MagazineFilter struct {\n\tPercentage *float64             `json:\"percentage\"`\n\tPublication *PublicationRange   `json:\"publication\"`\n\tArea      *string              `json:\"area\"`\n}"
      },
      {
        "code_key": "PublicationRange",
        "code_value": "type PublicationRange struct {\n\tStart time.Time `json:\"start\"`\n\tEnd   time.Time `json:\"end\"`\n}"
      },
      {
        "code_key": "MagazineTable",
        "code_value": "const MagazineTable = \"magazines\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "MagazineStatus",
        "code_value": "const (\n\tMagazineActive   = \"active\"\n\tMagazineArchived = \"archived\"\n\tMagazineDraft    = \"draft\"\n)"
      }
    ],
    "sql_pattern_cnt": 4
  },
  {
    "function_name": "FindMagazineByCriteria",
    "orm_code": "func (m *Magazine) FindMagazineByCriteria(filter map[string]interface{}, page, size int) ([]types.MagazineRecord, error) {\n\tvar records []types.MagazineRecord\n\tdb := base.GetInstance().GormDB().Table(\"magazines\")\n\n\tif percentage, ok := filter[\"Percentage\"]; ok {\n\t\tdb = db.Where(\"percentage > ?\", percentage.(float64))\n\t} else if publication, ok := filter[\"Publication\"]; ok {\n\t\tdb = db.Where(\"publication_date BETWEEN ? AND ?\", \n\t\t\tpublication.(map[string]interface{})[\"start\"], \n\t\t\tpublication.(map[string]interface{})[\"end\"])\n\t} else if area, ok := filter[\"Area\"]; ok {\n\t\tdb = db.Where(\"area LIKE ?\", \"%\"+area.(string)+\"%\")\n\t} else {\n\t\tdb = db.Where(filter)\n\t}\n\n\terr := db.Scopes(PaginateDB(page, size)).\n\t\tOrder(\"created_at DESC\").\n\t\tFind(&records).Error\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "caller": "func (s *MagazineService) HandleMagazineSearch(req *types.SearchMagazineRequest) ([]types.MagazineRecord, error) {\n\tcriteria := make(map[string]interface{})\n\t\n\tif req.PercentageThreshold > 0 {\n\t\tcriteria[\"Percentage\"] = req.PercentageThreshold\n\t} else if !req.PublicationRange.Start.IsZero() && !req.PublicationRange.End.IsZero() {\n\t\tcriteria[\"Publication\"] = map[string]interface{}{\n\t\t\t\"start\": req.PublicationRange.Start,\n\t\t\t\"end\": req.PublicationRange.End,\n\t\t}\n\t} else if req.Region != \"\" {\n\t\tcriteria[\"Area\"] = req.Region\n\t} else {\n\t\tcriteria[\"status\"] = \"active\"\n\t}\n\n\tmagazineModel := &Magazine{}\n\tresults, err := magazineModel.FindMagazineByCriteria(criteria, req.Page, req.Size)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to search magazines: %w\", err)\n\t}\n\t\n\tif len(results) == 0 {\n\t\treturn nil, nil\n\t}\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "PercentageThreshold > 0",
            "sql": "SELECT id, title, percentage, area, publication_date, created_at FROM magazines WHERE percentage > ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "PublicationRange with valid Start and End dates",
            "sql": "SELECT id, title, percentage, area, publication_date, created_at FROM magazines WHERE publication_date BETWEEN ? AND ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "Region is not empty",
            "sql": "SELECT id, title, percentage, area, publication_date, created_at FROM magazines WHERE area LIKE ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "Default status condition",
            "sql": "SELECT id, title, percentage, area, publication_date, created_at FROM magazines WHERE status = ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "MagazineRecord",
        "code_value": "type MagazineRecord struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tTitle         string    `json:\"title\" gorm:\"column:title\"`\n\tPercentage    float64   `json:\"percentage\" gorm:\"column:percentage\"`\n\tArea          string    `json:\"area\" gorm:\"column:area\"`\n\tPublicationDate time.Time `json:\"publication_date\" gorm:\"column:publication_date\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "MagazineFilter",
        "code_value": "type MagazineFilter struct {\n\tPercentage *float64             `json:\"percentage\"`\n\tPublication *PublicationRange   `json:\"publication\"`\n\tArea      *string              `json:\"area\"`\n}"
      },
      {
        "code_key": "PublicationRange",
        "code_value": "type PublicationRange struct {\n\tStart time.Time `json:\"start\"`\n\tEnd   time.Time `json:\"end\"`\n}"
      },
      {
        "code_key": "MagazineTable",
        "code_value": "const MagazineTable = \"magazines\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "MagazineStatus",
        "code_value": "const (\n\tMagazineActive   = \"active\"\n\tMagazineArchived = \"archived\"\n\tMagazineDraft    = \"draft\"\n)"
      }
    ],
    "sql_pattern_cnt": 4
  },
  {
    "function_name": "FindVendorContracts",
    "orm_code": "func (r *Report) FindVendorContracts(filter map[string]interface{}, page, size int) ([]types.VendorContract, error) {\n\tvar contracts []types.VendorContract\n\tdb := base.GetInstance().GormDB().Table(\"vendor_management\")\n\n\tif region, ok := filter[\"Continent\"]; ok {\n\t\tdb = db.Where(\"continent = ?\", region).Order(\"EntityId desc\")\n\t} else if code, ok := filter[\"Room\"]; ok {\n\t\tdb = db.Where(\"room LIKE ?\", \"%\"+code.(string)+\"%\").Order(\"created_at asc\")\n\t} else if status, ok := filter[\"Active\"]; ok {\n\t\tdb = db.Where(\"is_active = ? AND expiration_date > NOW()\", status).Order(\"expiration_date desc\")\n\t} else {\n\t\tdb = db.Where(filter).Order(\"EntityId\")\n\t}\n\n\terr := db.Scopes(PaginateDB(page, size)).Find(&contracts).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, fmt.Errorf(\"no contracts found\")\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn contracts, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Continent参数存在",
            "sql": "SELECT entity_id, vendor_name, continent, room, is_active, expiration_date, created_at, updated_at FROM vendor_management WHERE continent = 'Asia' ORDER BY entity_id DESC LIMIT 10 OFFSET 0;"
          },
          {
            "scenario": "Room参数存在",
            "sql": "SELECT entity_id, vendor_name, continent, room, is_active, expiration_date, created_at, updated_at FROM vendor_management WHERE room LIKE '%101%' ORDER BY created_at ASC LIMIT 10 OFFSET 0;"
          },
          {
            "scenario": "Active参数存在",
            "sql": "SELECT entity_id, vendor_name, continent, room, is_active, expiration_date, created_at, updated_at FROM vendor_management WHERE is_active = TRUE AND expiration_date > NOW() ORDER BY expiration_date DESC LIMIT 10 OFFSET 0;"
          },
          {
            "scenario": "其他参数组合",
            "sql": "SELECT entity_id, vendor_name, continent, room, is_active, expiration_date, created_at, updated_at FROM vendor_management WHERE vendor_name = 'Acme' ORDER BY entity_id LIMIT 10 OFFSET 0;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "VendorContract",
        "code_value": "type VendorContract struct {\n\tEntityId        int       `json:\"entityId\" gorm:\"column:entity_id\"`\n\tVendorName      string    `json:\"vendorName\" gorm:\"column:vendor_name\"`\n\tContinent       string    `json:\"continent\" gorm:\"column:continent\"`\n\tRoom            string    `json:\"room\" gorm:\"column:room\"`\n\tIsActive        bool      `json:\"isActive\" gorm:\"column:is_active\"`\n\tExpirationDate  time.Time `json:\"expirationDate\" gorm:\"column:expiration_date\"`\n\tCreatedAt       time.Time `json:\"createdAt\" gorm:\"column:created_at\"`\n\tUpdatedAt       time.Time `json:\"updatedAt\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "ContractStatus",
        "code_value": "type ContractStatus struct {\n\tActive    string `json:\"active\"`\n\tExpired   string `json:\"expired\"`\n\tPending   string `json:\"pending\"`\n\tCancelled string `json:\"cancelled\"`\n}"
      },
      {
        "code_key": "TableNameVendorManagement",
        "code_value": "const TableNameVendorManagement = \"vendor_management\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "ContractFilter",
        "code_value": "type ContractFilter struct {\n\tContinent *string\n\tRoom      *string\n\tActive    *bool\n}"
      },
      {
        "code_key": "VendorResponse",
        "code_value": "type VendorResponse struct {\n\tSuccess   bool              `json:\"success\"`\n\tContracts []VendorContract `json:\"contracts\"`\n\tPage      int              `json:\"page\"`\n\tTotal     int64            `json:\"total\"`\n}"
      }
    ],
    "sql_pattern_cnt": 4
  },
  {
    "function_name": "FindVendorContracts",
    "orm_code": "func (r *Report) FindVendorContracts(filter map[string]interface{}, page, size int) ([]types.VendorContract, error) {\n\tvar contracts []types.VendorContract\n\tdb := base.GetInstance().GormDB().Table(\"vendor_management\")\n\n\tif region, ok := filter[\"Continent\"]; ok {\n\t\tdb = db.Where(\"continent = ?\", region).Order(\"EntityId desc\")\n\t} else if code, ok := filter[\"Room\"]; ok {\n\t\tdb = db.Where(\"room LIKE ?\", \"%\"+code.(string)+\"%\").Order(\"created_at asc\")\n\t} else if status, ok := filter[\"Active\"]; ok {\n\t\tdb = db.Where(\"is_active = ? AND expiration_date > NOW()\", status).Order(\"expiration_date desc\")\n\t} else {\n\t\tdb = db.Where(filter).Order(\"EntityId\")\n\t}\n\n\terr := db.Scopes(PaginateDB(page, size)).Find(&contracts).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, fmt.Errorf(\"no contracts found\")\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn contracts, nil\n}",
    "caller": "func (m *MediaHandler) HandleMediaContracts(req *types.MediaContractRequest, log *logger.MediaLog) ([]types.VendorContract, error) {\n\tpageReq := req.Pagination\n\tpage, size := model.CalcPagination(&pageReq)\n\tfilter := make(map[string]interface{})\n\n\tif req.Region != \"\" {\n\t\tfilter[\"Continent\"] = req.Region\n\t} else if req.RoomCode != \"\" {\n\t\tif len(req.RoomCode) > 20 {\n\t\t\tlog.Error(\"RoomCode too long\")\n\t\t\treturn nil, errors.New(\"invalid room code\")\n\t\t}\n\t\tfilter[\"Room\"] = req.RoomCode\n\t} else if req.OnlyActive {\n\t\tfilter[\"Active\"] = true\n\t} else {\n\t\tfilter[\"EntityId\"] = req.EntityID\n\t}\n\n\treport := &Report{Context: m.Context}\n\tcontracts, err := report.FindVendorContracts(filter, page, size)\n\tif err != nil {\n\t\tlog.Errorf(\"Failed to find contracts: %v\", err)\n\t\treturn nil, fmt.Errorf(\"contract query failed\")\n\t}\n\treturn contracts, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "req.Region不为空",
            "sql": "SELECT entity_id, vendor_name, continent, room, is_active, expiration_date, created_at, updated_at FROM vendor_management WHERE continent = ? ORDER BY entity_id DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "req.RoomCode不为空",
            "sql": "SELECT entity_id, vendor_name, continent, room, is_active, expiration_date, created_at, updated_at FROM vendor_management WHERE room LIKE ? ORDER BY created_at ASC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "req.OnlyActive为true",
            "sql": "SELECT entity_id, vendor_name, continent, room, is_active, expiration_date, created_at, updated_at FROM vendor_management WHERE is_active = ? AND expiration_date > NOW() ORDER BY expiration_date DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "以上条件都不满足，使用EntityId过滤",
            "sql": "SELECT entity_id, vendor_name, continent, room, is_active, expiration_date, created_at, updated_at FROM vendor_management WHERE entity_id = ? ORDER BY entity_id LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "VendorContract",
        "code_value": "type VendorContract struct {\n\tEntityId        int       `json:\"entityId\" gorm:\"column:entity_id\"`\n\tVendorName      string    `json:\"vendorName\" gorm:\"column:vendor_name\"`\n\tContinent       string    `json:\"continent\" gorm:\"column:continent\"`\n\tRoom            string    `json:\"room\" gorm:\"column:room\"`\n\tIsActive        bool      `json:\"isActive\" gorm:\"column:is_active\"`\n\tExpirationDate  time.Time `json:\"expirationDate\" gorm:\"column:expiration_date\"`\n\tCreatedAt       time.Time `json:\"createdAt\" gorm:\"column:created_at\"`\n\tUpdatedAt       time.Time `json:\"updatedAt\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "ContractStatus",
        "code_value": "type ContractStatus struct {\n\tActive    string `json:\"active\"`\n\tExpired   string `json:\"expired\"`\n\tPending   string `json:\"pending\"`\n\tCancelled string `json:\"cancelled\"`\n}"
      },
      {
        "code_key": "TableNameVendorManagement",
        "code_value": "const TableNameVendorManagement = \"vendor_management\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "ContractFilter",
        "code_value": "type ContractFilter struct {\n\tContinent *string\n\tRoom      *string\n\tActive    *bool\n}"
      },
      {
        "code_key": "VendorResponse",
        "code_value": "type VendorResponse struct {\n\tSuccess   bool              `json:\"success\"`\n\tContracts []VendorContract `json:\"contracts\"`\n\tPage      int              `json:\"page\"`\n\tTotal     int64            `json:\"total\"`\n}"
      }
    ],
    "sql_pattern_cnt": 4
  },
  {
    "function_name": "FindByExamZone",
    "orm_code": "func (d *Doctor) FindByExamZone(filter map[string]interface{}, page, size int) ([]types.ExamResult, error) {\n\tresults := make([]types.ExamResult, 0)\n\tdb := base.GetInstance().ClinicDB().Table(\"exam_results\")\n\n\tif zone, ok := filter[\"Zone\"]; ok {\n\t\tif status, ok := filter[\"Status\"]; ok {\n\t\t\tdb = db.Where(\"zone = ? AND status = ?\", zone.(string), status.(string))\n\t\t} else {\n\t\t\tdb = db.Where(\"zone LIKE ?\", \"%\"+zone.(string)+\"%\")\n\t\t}\n\t} else if room, ok := filter[\"Room\"]; ok {\n\t\tdb = db.Where(\"room = ?\", room.(string)).Order(\"created_at DESC\")\n\t} else if middleName, ok := filter[\"MiddleName\"]; ok {\n\t\tdb = db.Where(\"middle_name LIKE ?\", \"%\"+middleName.(string)+\"%\").Limit(50)\n\t} else {\n\t\tdb = db.Where(filter)\n\t}\n\n\terr := db.Scopes(PaginateDB(page, size)).Find(&results).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn results, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Zone和Status都提供",
            "sql": "SELECT id, zone, room, middle_name, status, created_at, updated_at FROM exam_results WHERE zone = ? AND status = ? LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "只提供Zone",
            "sql": "SELECT id, zone, room, middle_name, status, created_at, updated_at FROM exam_results WHERE zone LIKE ? LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "只提供Room",
            "sql": "SELECT id, zone, room, middle_name, status, created_at, updated_at FROM exam_results WHERE room = ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "只提供MiddleName",
            "sql": "SELECT id, zone, room, middle_name, status, created_at, updated_at FROM exam_results WHERE middle_name LIKE ? LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "ExamResult",
        "code_value": "type ExamResult struct {\n\tID          uint      `gorm:\"column:id;primaryKey\"`\n\tZone        string    `gorm:\"column:zone\"`\n\tRoom        string    `gorm:\"column:room\"`\n\tMiddleName  string    `gorm:\"column:middle_name\"`\n\tStatus      string    `gorm:\"column:status\"`\n\tCreatedAt   time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt   time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "ExamResponse",
        "code_value": "type ExamResponse struct {\n\tResults     []ExamResult `json:\"results\"`\n\tTotalCount  int          `json:\"total_count\"`\n\tCurrentPage int          `json:\"current_page\"`\n\tPageSize    int          `json:\"page_size\"`\n}"
      },
      {
        "code_key": "ExamFilter",
        "code_value": "type ExamFilter struct {\n\tZone       string \n\tRoom       string \n\tMiddleName string \n\tStatus     string \n}"
      },
      {
        "code_key": "ExamStatus",
        "code_value": "const (\n\tExamStatusPending   = \"pending\"\n\tExamStatusInProgress = \"in_progress\"\n\tExamStatusCompleted = \"completed\"\n)"
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "ResultTable",
        "code_value": "const ResultTable = \"exam_results\""
      }
    ],
    "sql_pattern_cnt": 4
  },
  {
    "function_name": "FindByExamZone",
    "orm_code": "func (d *Doctor) FindByExamZone(filter map[string]interface{}, page, size int) ([]types.ExamResult, error) {\n\tresults := make([]types.ExamResult, 0)\n\tdb := base.GetInstance().ClinicDB().Table(\"exam_results\")\n\n\tif zone, ok := filter[\"Zone\"]; ok {\n\t\tif status, ok := filter[\"Status\"]; ok {\n\t\t\tdb = db.Where(\"zone = ? AND status = ?\", zone.(string), status.(string))\n\t\t} else {\n\t\t\tdb = db.Where(\"zone LIKE ?\", \"%\"+zone.(string)+\"%\")\n\t\t}\n\t} else if room, ok := filter[\"Room\"]; ok {\n\t\tdb = db.Where(\"room = ?\", room.(string)).Order(\"created_at DESC\")\n\t} else if middleName, ok := filter[\"MiddleName\"]; ok {\n\t\tdb = db.Where(\"middle_name LIKE ?\", \"%\"+middleName.(string)+\"%\").Limit(50)\n\t} else {\n\t\tdb = db.Where(filter)\n\t}\n\n\terr := db.Scopes(PaginateDB(page, size)).Find(&results).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn results, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}",
    "caller": "func (h *ExamHandler) HandleExamResults(req *types.ExamQueryRequest) ([]types.ExamResult, error) {\n\tif req.Page <= 0 || req.Size <= 0 {\n\t\treturn nil, fmt.Errorf(\"invalid pagination parameters\")\n\t}\n\n\tcriteria := make(map[string]interface{})\n\tdoc := &Doctor{}\n\n\tif req.ZoneCode != \"\" {\n\t\tcriteria[\"Zone\"] = req.ZoneCode\n\t\tif req.StatusFilter != \"\" {\n\t\t\tcriteria[\"Status\"] = req.StatusFilter\n\t\t}\n\t} else if req.RoomNumber != \"\" {\n\t\tcriteria[\"Room\"] = req.RoomNumber\n\t} else if req.SearchName != \"\" {\n\t\tif len(req.SearchName) > 50 {\n\t\t\treturn nil, fmt.Errorf(\"name too long\")\n\t\t}\n\t\tcriteria[\"MiddleName\"] = req.SearchName\n\t}\n\n\texamData, err := doc.FindByExamZone(criteria, req.Page, req.Size)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"query failed: %v\", err)\n\t}\n\treturn examData, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "ZoneCode和StatusFilter都有值",
            "sql": "SELECT * FROM exam_results WHERE zone = ? AND status = ? LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "只有ZoneCode有值",
            "sql": "SELECT * FROM exam_results WHERE zone LIKE ? LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "只有RoomNumber有值",
            "sql": "SELECT * FROM exam_results WHERE room = ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "只有SearchName有值",
            "sql": "SELECT * FROM exam_results WHERE middle_name LIKE ? LIMIT 50 LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "ExamResult",
        "code_value": "type ExamResult struct {\n\tID          uint      `gorm:\"column:id;primaryKey\"`\n\tZone        string    `gorm:\"column:zone\"`\n\tRoom        string    `gorm:\"column:room\"`\n\tMiddleName  string    `gorm:\"column:middle_name\"`\n\tStatus      string    `gorm:\"column:status\"`\n\tCreatedAt   time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt   time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "ExamResponse",
        "code_value": "type ExamResponse struct {\n\tResults     []ExamResult `json:\"results\"`\n\tTotalCount  int          `json:\"total_count\"`\n\tCurrentPage int          `json:\"current_page\"`\n\tPageSize    int          `json:\"page_size\"`\n}"
      },
      {
        "code_key": "ExamFilter",
        "code_value": "type ExamFilter struct {\n\tZone       string \n\tRoom       string \n\tMiddleName string \n\tStatus     string \n}"
      },
      {
        "code_key": "ExamStatus",
        "code_value": "const (\n\tExamStatusPending   = \"pending\"\n\tExamStatusInProgress = \"in_progress\"\n\tExamStatusCompleted = \"completed\"\n)"
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "ResultTable",
        "code_value": "const ResultTable = \"exam_results\""
      }
    ],
    "sql_pattern_cnt": 4
  },
  {
    "function_name": "MigrateData",
    "orm_code": "func (s *Stock) MigrateData(filter map[string]interface{}, page, size int) ([]types.PriceHistory, error) {\n\tph := make([]types.PriceHistory, 0)\n\tvar err error\n\tdb := base.GetInstance().GormDB().Table(\"price_history\")\n\n\tif symbol, ok := filter[\"symbol\"]; ok {\n\t\terr = db.Where(\"symbol LIKE ?\", \"%\"+symbol.(string)+\"%\")\n\t\t\t.Scopes(PaginateDB(page, size))\n\t\t\t.Order(\"record_date DESC\")\n\t\t\t.Find(&ph).Error\n\t} else if status, ok := filter[\"CurrentStatus\"]; ok {\n\t\terr = db.Where(\"CurrentStatus = ? AND record_date > ?\", \n\t\t\tstatus.(string), time.Now().AddDate(0, -1, 0))\n\t\t\t.Scopes(PaginateDB(page, size))\n\t\t\t.Find(&ph).Error\n\t} else if rangeFilter, ok := filter[\"price_range\"]; ok {\n\t\trangeVal := rangeFilter.([]float64)\n\t\terr = db.Where(\"price BETWEEN ? AND ?\", \n\t\t\trangeVal[0], rangeVal[1])\n\t\t\t.Scopes(PaginateDB(page, size))\n\t\t\t.Find(&ph).Error\n\t} else {\n\t\terr = db.Scopes(PaginateDB(page, size))\n\t\t\t.Order(\"record_date DESC\")\n\t\t\t.Find(&ph).Error\n\t}\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn ph, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "当 filter 包含 'symbol' 参数时",
            "sql": "SELECT id, symbol, price, record_date, current_status FROM price_history WHERE symbol LIKE '%AAPL%' ORDER BY record_date DESC LIMIT 10 OFFSET 0;"
          },
          {
            "scenario": "当 filter 包含 'CurrentStatus' 参数时",
            "sql": "SELECT id, symbol, price, record_date, current_status FROM price_history WHERE current_status = 'ACTIVE' AND record_date > '2023-05-16' LIMIT 5 OFFSET 5;"
          },
          {
            "scenario": "当 filter 包含 'price_range' 参数时",
            "sql": "SELECT id, symbol, price, record_date, current_status FROM price_history WHERE price BETWEEN 100.0 AND 200.0 LIMIT 20 OFFSET 0;"
          },
          {
            "scenario": "当 filter 不包含任何条件时",
            "sql": "SELECT id, symbol, price, record_date, current_status FROM price_history ORDER BY record_date DESC LIMIT 10 OFFSET 0;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "PriceHistory",
        "code_value": "type PriceHistory struct {\n\tID          int       `json:\"id\" gorm:\"column:id\"`\n\tSymbol      string    `json:\"symbol\" gorm:\"column:symbol\"`\n\tPrice       float64   `json:\"price\" gorm:\"column:price\"`\n\tRecordDate  time.Time `json:\"record_date\" gorm:\"column:record_date\"`\n\tCurrentStatus string  `json:\"current_status\" gorm:\"column:current_status\"`\n}"
      },
      {
        "code_key": "StockFilter",
        "code_value": "type StockFilter struct {\n\tSymbol       *string    `json:\"symbol\"`\n\tCurrentStatus *string   `json:\"current_status\"`\n\tPriceRange   []float64  `json:\"price_range\"`\n}"
      },
      {
        "code_key": "PaginatedResponse",
        "code_value": "type PaginatedResponse struct {\n\tData         []PriceHistory `json:\"data\"`\n\tPage         int            `json:\"page\"`\n\tSize         int            `json:\"size\"`\n\tTotalRecords int64          `json:\"total_records\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "const TableName = \"price_history\""
      },
      {
        "code_key": "PriceStatus",
        "code_value": "const (\n\tPriceActive   = \"ACTIVE\"\n\tPriceInactive = \"INACTIVE\"\n\tPricePending  = \"PENDING\"\n)"
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      }
    ],
    "sql_pattern_cnt": 4
  },
  {
    "function_name": "MigrateData",
    "orm_code": "func (s *Stock) MigrateData(filter map[string]interface{}, page, size int) ([]types.PriceHistory, error) {\n\tph := make([]types.PriceHistory, 0)\n\tvar err error\n\tdb := base.GetInstance().GormDB().Table(\"price_history\")\n\n\tif symbol, ok := filter[\"symbol\"]; ok {\n\t\terr = db.Where(\"symbol LIKE ?\", \"%\"+symbol.(string)+\"%\")\n\t\t\t.Scopes(PaginateDB(page, size))\n\t\t\t.Order(\"record_date DESC\")\n\t\t\t.Find(&ph).Error\n\t} else if status, ok := filter[\"CurrentStatus\"]; ok {\n\t\terr = db.Where(\"CurrentStatus = ? AND record_date > ?\", \n\t\t\tstatus.(string), time.Now().AddDate(0, -1, 0))\n\t\t\t.Scopes(PaginateDB(page, size))\n\t\t\t.Find(&ph).Error\n\t} else if rangeFilter, ok := filter[\"price_range\"]; ok {\n\t\trangeVal := rangeFilter.([]float64)\n\t\terr = db.Where(\"price BETWEEN ? AND ?\", \n\t\t\trangeVal[0], rangeVal[1])\n\t\t\t.Scopes(PaginateDB(page, size))\n\t\t\t.Find(&ph).Error\n\t} else {\n\t\terr = db.Scopes(PaginateDB(page, size))\n\t\t\t.Order(\"record_date DESC\")\n\t\t\t.Find(&ph).Error\n\t}\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn ph, nil\n}",
    "caller": "func (h *StockHandler) HandleStockData(req *types.StockQueryRequest) ([]types.PriceHistory, error) {\n\tif req.Page <= 0 || req.Size <= 0 {\n\t\treturn nil, fmt.Errorf(\"invalid pagination parameters\")\n\t}\n\n\tqueryFilters := make(map[string]interface{})\n\tif req.Symbol != \"\" {\n\t\tqueryFilters[\"symbol\"] = req.Symbol\n\t} else if req.Status != \"\" {\n\t\tqueryFilters[\"CurrentStatus\"] = req.Status\n\t} else if req.MinPrice > 0 && req.MaxPrice > req.MinPrice {\n\t\tqueryFilters[\"price_range\"] = []float64{req.MinPrice, req.MaxPrice}\n\t}\n\n\tstockModel := &Stock{}\n\tresult, err := stockModel.MigrateData(queryFilters, req.Page, req.Size)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to migrate stock data: %v\", err)\n\t}\n\n\tif len(result) == 0 {\n\t\treturn nil, nil\n\t}\n\treturn result, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Symbol condition with LIKE and date ordering",
            "sql": "SELECT id, symbol, price, record_date, current_status FROM price_history WHERE symbol LIKE '%?%' ORDER BY record_date DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "Status condition with date filter",
            "sql": "SELECT id, symbol, price, record_date, current_status FROM price_history WHERE current_status = ? AND record_date > ? LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "Price range condition",
            "sql": "SELECT id, symbol, price, record_date, current_status FROM price_history WHERE price BETWEEN ? AND ? LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "No conditions with date ordering",
            "sql": "SELECT id, symbol, price, record_date, current_status FROM price_history ORDER BY record_date DESC LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "PriceHistory",
        "code_value": "type PriceHistory struct {\n\tID          int       `json:\"id\" gorm:\"column:id\"`\n\tSymbol      string    `json:\"symbol\" gorm:\"column:symbol\"`\n\tPrice       float64   `json:\"price\" gorm:\"column:price\"`\n\tRecordDate  time.Time `json:\"record_date\" gorm:\"column:record_date\"`\n\tCurrentStatus string  `json:\"current_status\" gorm:\"column:current_status\"`\n}"
      },
      {
        "code_key": "StockFilter",
        "code_value": "type StockFilter struct {\n\tSymbol       *string    `json:\"symbol\"`\n\tCurrentStatus *string   `json:\"current_status\"`\n\tPriceRange   []float64  `json:\"price_range\"`\n}"
      },
      {
        "code_key": "PaginatedResponse",
        "code_value": "type PaginatedResponse struct {\n\tData         []PriceHistory `json:\"data\"`\n\tPage         int            `json:\"page\"`\n\tSize         int            `json:\"size\"`\n\tTotalRecords int64          `json:\"total_records\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "const TableName = \"price_history\""
      },
      {
        "code_key": "PriceStatus",
        "code_value": "const (\n\tPriceActive   = \"ACTIVE\"\n\tPriceInactive = \"INACTIVE\"\n\tPricePending  = \"PENDING\"\n)"
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      }
    ],
    "sql_pattern_cnt": 4
  },
  {
    "function_name": "ValidateOrder",
    "orm_code": "func (r *Review) ValidateOrder(filterParams map[string]interface{}) (*types.ReviewResult, error) {\n\tvar result types.ReviewResult\n\tdb := base.GetInstance().MainDB().Table(\"maintenance_logs\")\n\t\n\tif editor, ok := filterParams[\"Editor\"]; ok {\n\t\terr := db.Where(\"editor = ? AND status = ?\", editor.(string), \"pending\").First(&result).Error\n\t\tif err != nil {\n\t\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\t\treturn nil, fmt.Errorf(\"no pending reviews for editor: %v\", editor)\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t} else if level, ok := filterParams[\"ApprovalLevel\"]; ok {\n\t\terr := db.Where(\"approval_level > ?\", level.(int)).Order(\"created_at desc\").First(&result).Error\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to find high priority review: %v\", err)\n\t\t}\n\t} else if subject, ok := filterParams[\"Subject\"]; ok {\n\t\terr := db.Where(\"subject LIKE ?\", \"%\"+subject.(string)+\"%\").First(&result).Error\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"subject search failed: %v\", err)\n\t\t}\n\t} else {\n\t\treturn nil, errors.New(\"invalid filter parameters\")\n\t}\n\t\n\treturn &result, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "提供Editor参数",
            "sql": "SELECT id, editor, subject, status, approval_level, content, created_at, updated_at FROM maintenance_logs WHERE editor = ? AND status = 'pending' ORDER BY id ASC LIMIT 1;"
          },
          {
            "scenario": "提供ApprovalLevel参数",
            "sql": "SELECT id, editor, subject, status, approval_level, content, created_at, updated_at FROM maintenance_logs WHERE approval_level > ? ORDER BY created_at DESC LIMIT 1;"
          },
          {
            "scenario": "提供Subject参数",
            "sql": "SELECT id, editor, subject, status, approval_level, content, created_at, updated_at FROM maintenance_logs WHERE subject LIKE ? ORDER BY id ASC LIMIT 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "ReviewResult",
        "code_value": "type ReviewResult struct {\n\tID            uint      `gorm:\"column:id\"`\n\tEditor        string    `gorm:\"column:editor\"`\n\tSubject       string    `gorm:\"column:subject\"`\n\tStatus        string    `gorm:\"column:status\"`\n\tApprovalLevel int       `gorm:\"column:approval_level\"`\n\tContent       string    `gorm:\"column:content\"`\n\tCreatedAt     time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "ReviewStatus",
        "code_value": "const (\n\tReviewStatusPending   = \"pending\"\n\tReviewStatusApproved = \"approved\"\n\tReviewStatusRejected = \"rejected\"\n)"
      },
      {
        "code_key": "ReviewTable",
        "code_value": "const ReviewTable = \"maintenance_logs\""
      },
      {
        "code_key": "ApprovalThreshold",
        "code_value": "var ApprovalThreshold = map[string]int{\n\t\"low\":    1,\n\t\"medium\": 3,\n\t\"high\":   5\n}"
      },
      {
        "code_key": "ReviewFilter",
        "code_value": "type ReviewFilter struct {\n\tEditor        *string\n\tSubject       *string\n\tApprovalLevel *int\n\tStatus        *string\n}"
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "ValidateOrder",
    "orm_code": "func (r *Review) ValidateOrder(filterParams map[string]interface{}) (*types.ReviewResult, error) {\n\tvar result types.ReviewResult\n\tdb := base.GetInstance().MainDB().Table(\"maintenance_logs\")\n\t\n\tif editor, ok := filterParams[\"Editor\"]; ok {\n\t\terr := db.Where(\"editor = ? AND status = ?\", editor.(string), \"pending\").First(&result).Error\n\t\tif err != nil {\n\t\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\t\treturn nil, fmt.Errorf(\"no pending reviews for editor: %v\", editor)\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t} else if level, ok := filterParams[\"ApprovalLevel\"]; ok {\n\t\terr := db.Where(\"approval_level > ?\", level.(int)).Order(\"created_at desc\").First(&result).Error\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to find high priority review: %v\", err)\n\t\t}\n\t} else if subject, ok := filterParams[\"Subject\"]; ok {\n\t\terr := db.Where(\"subject LIKE ?\", \"%\"+subject.(string)+\"%\").First(&result).Error\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"subject search failed: %v\", err)\n\t\t}\n\t} else {\n\t\treturn nil, errors.New(\"invalid filter parameters\")\n\t}\n\t\n\treturn &result, nil\n}",
    "caller": "func (s *MaintenanceService) HandleMaintenanceReview(req *types.ReviewRequest) (*types.ReviewResult, error) {\n\tif req == nil {\n\t\treturn nil, errors.New(\"empty request\")\n\t}\n\n\treviewObj := &Review{}\n\tfilterCriteria := make(map[string]interface{})\n\n\t// Trigger different ORM branches based on request\n\tswitch {\n\tcase req.EditorID != \"\":\n\t\tfilterCriteria[\"Editor\"] = req.EditorID\n\tcase req.MinApprovalLevel > 0:\n\t\tfilterCriteria[\"ApprovalLevel\"] = req.MinApprovalLevel\n\tcase req.SearchTerm != \"\":\n\t\tfilterCriteria[\"Subject\"] = req.SearchTerm\n\tdefault:\n\t\treturn nil, errors.New(\"invalid review criteria\")\n\t}\n\n\tresult, err := reviewObj.ValidateOrder(filterCriteria)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"review validation failed: %v\", err)\n\t}\n\n\treturn result, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Editor ID provided",
            "sql": "SELECT id, editor, subject, status, approval_level, content, created_at, updated_at FROM maintenance_logs WHERE editor = ? AND status = 'pending' ORDER BY maintenance_logs.id LIMIT 1;"
          },
          {
            "scenario": "Approval Level provided",
            "sql": "SELECT id, editor, subject, status, approval_level, content, created_at, updated_at FROM maintenance_logs WHERE approval_level > ? ORDER BY created_at DESC LIMIT 1;"
          },
          {
            "scenario": "Search Term provided",
            "sql": "SELECT id, editor, subject, status, approval_level, content, created_at, updated_at FROM maintenance_logs WHERE subject LIKE ? ORDER BY maintenance_logs.id LIMIT 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "ReviewResult",
        "code_value": "type ReviewResult struct {\n\tID            uint      `gorm:\"column:id\"`\n\tEditor        string    `gorm:\"column:editor\"`\n\tSubject       string    `gorm:\"column:subject\"`\n\tStatus        string    `gorm:\"column:status\"`\n\tApprovalLevel int       `gorm:\"column:approval_level\"`\n\tContent       string    `gorm:\"column:content\"`\n\tCreatedAt     time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "ReviewStatus",
        "code_value": "const (\n\tReviewStatusPending   = \"pending\"\n\tReviewStatusApproved = \"approved\"\n\tReviewStatusRejected = \"rejected\"\n)"
      },
      {
        "code_key": "ReviewTable",
        "code_value": "const ReviewTable = \"maintenance_logs\""
      },
      {
        "code_key": "ApprovalThreshold",
        "code_value": "var ApprovalThreshold = map[string]int{\n\t\"low\":    1,\n\t\"medium\": 3,\n\t\"high\":   5\n}"
      },
      {
        "code_key": "ReviewFilter",
        "code_value": "type ReviewFilter struct {\n\tEditor        *string\n\tSubject       *string\n\tApprovalLevel *int\n\tStatus        *string\n}"
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "FilterMediaUploads",
    "orm_code": "func (d *Diploma) FilterMediaUploads(filterParams map[string]interface{}) ([]types.MediaUpload, error) {\n\tvar uploads []types.MediaUpload\n\tdb := base.GetInstance().GormDB().Table(\"media_uploads\")\n\n\tif topic, ok := filterParams[\"Topic\"]; ok {\n\t\tdb = db.Where(\"topic LIKE ?\", \"%\"+topic.(string)+\"%\")\n\t} else if postalCode, ok := filterParams[\"PostalCode\"]; ok {\n\t\tdb = db.Where(\"postal_code = ?\", postalCode.(string))\n\t} else if modDate, ok := filterParams[\"ModificationDate\"]; ok {\n\t\tdb = db.Where(\"modification_date > ?\", modDate.(string)).Order(\"modification_date DESC\")\n\t} else {\n\t\tdb = db.Limit(100).Order(\"id DESC\")\n\t}\n\n\tif err := db.Find(&uploads).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to query media uploads: %w\", err)\n\t}\n\n\treturn uploads, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "传入Topic参数",
            "sql": "SELECT * FROM media_uploads WHERE topic LIKE '%?%';"
          },
          {
            "scenario": "传入PostalCode参数",
            "sql": "SELECT * FROM media_uploads WHERE postal_code = ?;"
          },
          {
            "scenario": "传入ModificationDate参数",
            "sql": "SELECT * FROM media_uploads WHERE modification_date > ? ORDER BY modification_date DESC;"
          },
          {
            "scenario": "无匹配参数（默认情况）",
            "sql": "SELECT * FROM media_uploads ORDER BY id DESC LIMIT 100;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "MediaUploadRequest",
        "code_value": "type MediaUploadRequest struct {\n\tTopic            string `json:\"topic\"`\n\tPostalCode       string `json:\"postal_code\"`\n\tModificationDate string `json:\"modification_date\"`\n}"
      },
      {
        "code_key": "MediaUploadResponse",
        "code_value": "type MediaUploadResponse struct {\n\tUploads []MediaUpload `json:\"uploads\"`\n\tError   string       `json:\"error,omitempty\"`\n}"
      },
      {
        "code_key": "Theme",
        "code_value": "type Theme struct {\n\tID          int    `gorm:\"column:id\"`\n\tName        string `gorm:\"column:name\"`\n\tDescription string `gorm:\"column:description\"`\n\tCreatedAt   string `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "Forecast",
        "code_value": "type Forecast struct {\n\ttypes.Theme\n\n\tLocation string `gorm:\"column:location\"`\n\tDate     string `gorm:\"column:date\"`\n}"
      },
      {
        "code_key": "const",
        "code_value": "const (\n\tMediaUploadTable = \"media_uploads\"\n\tDefaultLimit     = 100\n)"
      },
      {
        "code_key": "var",
        "code_value": "var (\n\tDefaultFilterParams = map[string]interface{}{\"Limit\": DefaultLimit}\n)"
      }
    ],
    "sql_pattern_cnt": 4
  },
  {
    "function_name": "FilterMediaUploads",
    "orm_code": "func (d *Diploma) FilterMediaUploads(filterParams map[string]interface{}) ([]types.MediaUpload, error) {\n\tvar uploads []types.MediaUpload\n\tdb := base.GetInstance().GormDB().Table(\"media_uploads\")\n\n\tif topic, ok := filterParams[\"Topic\"]; ok {\n\t\tdb = db.Where(\"topic LIKE ?\", \"%\"+topic.(string)+\"%\")\n\t} else if postalCode, ok := filterParams[\"PostalCode\"]; ok {\n\t\tdb = db.Where(\"postal_code = ?\", postalCode.(string))\n\t} else if modDate, ok := filterParams[\"ModificationDate\"]; ok {\n\t\tdb = db.Where(\"modification_date > ?\", modDate.(string)).Order(\"modification_date DESC\")\n\t} else {\n\t\tdb = db.Limit(100).Order(\"id DESC\")\n\t}\n\n\tif err := db.Find(&uploads).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to query media uploads: %w\", err)\n\t}\n\n\treturn uploads, nil\n}",
    "caller": "func (m *MediaManager) HandleMediaSearch(searchReq *types.MediaSearchRequest) ([]types.MediaUpload, error) {\n\tif searchReq == nil {\n\t\treturn nil, fmt.Errorf(\"search request cannot be nil\")\n\t}\n\n\tfilters := make(map[string]interface{})\n\tif searchReq.TopicKeyword != \"\" {\n\t\tfilters[\"Topic\"] = searchReq.TopicKeyword\n\t} else if searchReq.LocationCode != \"\" {\n\t\tif len(searchReq.LocationCode) != 6 {\n\t\t\treturn nil, fmt.Errorf(\"invalid postal code format\")\n\t\t}\n\t\tfilters[\"PostalCode\"] = searchReq.LocationCode\n\t} else if searchReq.LastUpdated != \"\" {\n\t\tif _, err := time.Parse(\"2006-01-02\", searchReq.LastUpdated); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"invalid date format\")\n\t\t}\n\t\tfilters[\"ModificationDate\"] = searchReq.LastUpdated\n\t}\n\n\tdiploma := &Diploma{}\n\tresults, err := diploma.FilterMediaUploads(filters)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to filter media: %v\", err)\n\t}\n\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按Topic模糊搜索",
            "sql": "SELECT * FROM media_uploads WHERE topic LIKE '%weather%';"
          },
          {
            "scenario": "按PostalCode精确匹配",
            "sql": "SELECT * FROM media_uploads WHERE postal_code = '123456';"
          },
          {
            "scenario": "按ModificationDate筛选并排序",
            "sql": "SELECT * FROM media_uploads WHERE modification_date > '2023-01-01' ORDER BY modification_date DESC;"
          },
          {
            "scenario": "无筛选条件",
            "sql": "SELECT * FROM media_uploads ORDER BY id DESC LIMIT 100;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "MediaUploadRequest",
        "code_value": "type MediaUploadRequest struct {\n\tTopic            string `json:\"topic\"`\n\tPostalCode       string `json:\"postal_code\"`\n\tModificationDate string `json:\"modification_date\"`\n}"
      },
      {
        "code_key": "MediaUploadResponse",
        "code_value": "type MediaUploadResponse struct {\n\tUploads []MediaUpload `json:\"uploads\"`\n\tError   string       `json:\"error,omitempty\"`\n}"
      },
      {
        "code_key": "Theme",
        "code_value": "type Theme struct {\n\tID          int    `gorm:\"column:id\"`\n\tName        string `gorm:\"column:name\"`\n\tDescription string `gorm:\"column:description\"`\n\tCreatedAt   string `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "Forecast",
        "code_value": "type Forecast struct {\n\ttypes.Theme\n\n\tLocation string `gorm:\"column:location\"`\n\tDate     string `gorm:\"column:date\"`\n}"
      },
      {
        "code_key": "const",
        "code_value": "const (\n\tMediaUploadTable = \"media_uploads\"\n\tDefaultLimit     = 100\n)"
      },
      {
        "code_key": "var",
        "code_value": "var (\n\tDefaultFilterParams = map[string]interface{}{\"Limit\": DefaultLimit}\n)"
      }
    ],
    "sql_pattern_cnt": 4
  },
  {
    "function_name": "QueryWidgetAccessRecords",
    "orm_code": "func (w *Widget) QueryWidgetAccessRecords(filter map[string]interface{}, page int, size int) ([]types.AccessRecord, error) {\n\tvar records []types.AccessRecord\n\tvar err error\n\tquery := base.GetInstance().GormDB().Table(\"widget_access_records\")\n\n\tif method, ok := filter[\"MethodName\"]; ok {\n\t\tquery = query.Where(\"method_name LIKE ?\", \"%\"+method.(string)+\"%\")\n\t} else if level, ok := filter[\"AccessLevel\"]; ok {\n\t\tquery = query.Where(\"access_level = ?\", level.(int))\n\t} else if key, ok := filter[\"PublicKey\"]; ok {\n\t\tquery = query.Where(\"public_key = ? AND is_verified = ?\", key.(string), true)\n\t} else {\n\t\tquery = query.Where(filter)\n\t}\n\n\terr = query.Order(\"created_at DESC\").Scopes(PaginateDB(page, size)).Find(&records).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to query access records: %w\", err)\n\t}\n\treturn records, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "MethodName condition with LIKE",
            "sql": "SELECT id, method_name, access_level, public_key, is_verified, created_at FROM widget_access_records WHERE method_name LIKE '%?%' ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "AccessLevel condition with exact match",
            "sql": "SELECT id, method_name, access_level, public_key, is_verified, created_at FROM widget_access_records WHERE access_level = ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "PublicKey condition with additional is_verified check",
            "sql": "SELECT id, method_name, access_level, public_key, is_verified, created_at FROM widget_access_records WHERE public_key = ? AND is_verified = true ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "Direct filter map condition",
            "sql": "SELECT id, method_name, access_level, public_key, is_verified, created_at FROM widget_access_records WHERE ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "No filter condition",
            "sql": "SELECT id, method_name, access_level, public_key, is_verified, created_at FROM widget_access_records ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "AccessRecord",
        "code_value": "type AccessRecord struct {\n\tID          uint      `gorm:\"column:id;primaryKey\"`\n\tMethodName  string    `gorm:\"column:method_name\"`\n\tAccessLevel int       `gorm:\"column:access_level\"`\n\tPublicKey   string    `gorm:\"column:public_key\"`\n\tIsVerified  bool      `gorm:\"column:is_verified\"`\n\tCreatedAt   time.Time `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "WidgetQueryParams",
        "code_value": "type WidgetQueryParams struct {\n\tMethodName  string\n\tAccessLevel int\n\tPublicKey   string\n}"
      },
      {
        "code_key": "TableNameWidgetAccessRecords",
        "code_value": "const TableNameWidgetAccessRecords = \"widget_access_records\""
      },
      {
        "code_key": "AccessLevels",
        "code_value": "const (\n\tAccessLevelBasic = 1\n\tAccessLevelAdmin = 2\n\tAccessLevelSuper = 3\n)"
      },
      {
        "code_key": "PaginateDB",
        "code_value": "func PaginateDB(page, size int) func(db *gorm.DB) *gorm.DB {\n\treturn func(db *gorm.DB) *gorm.DB {\n\t\toffset := (page - 1) * size\n\t\treturn db.Offset(offset).Limit(size)\n\t}\n}"
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "QueryWidgetAccessRecords",
    "orm_code": "func (w *Widget) QueryWidgetAccessRecords(filter map[string]interface{}, page int, size int) ([]types.AccessRecord, error) {\n\tvar records []types.AccessRecord\n\tvar err error\n\tquery := base.GetInstance().GormDB().Table(\"widget_access_records\")\n\n\tif method, ok := filter[\"MethodName\"]; ok {\n\t\tquery = query.Where(\"method_name LIKE ?\", \"%\"+method.(string)+\"%\")\n\t} else if level, ok := filter[\"AccessLevel\"]; ok {\n\t\tquery = query.Where(\"access_level = ?\", level.(int))\n\t} else if key, ok := filter[\"PublicKey\"]; ok {\n\t\tquery = query.Where(\"public_key = ? AND is_verified = ?\", key.(string), true)\n\t} else {\n\t\tquery = query.Where(filter)\n\t}\n\n\terr = query.Order(\"created_at DESC\").Scopes(PaginateDB(page, size)).Find(&records).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to query access records: %w\", err)\n\t}\n\treturn records, nil\n}",
    "caller": "func (h *WidgetHandler) HandleWidgetAccessRecords(req *types.QueryWidgetAccessRequest) ([]types.AccessRecord, error) {\n\tif req.Page <= 0 || req.Size <= 0 {\n\t\treturn nil, fmt.Errorf(\"invalid pagination parameters\")\n\t}\n\n\tqueryParams := make(map[string]interface{})\n\n\tswitch {\n\tcase req.MethodName != \"\":\n\t\tqueryParams[\"MethodName\"] = req.MethodName\n\tcase req.AccessLevel > 0:\n\t\tqueryParams[\"AccessLevel\"] = req.AccessLevel\n\tcase req.PublicKey != \"\":\n\t\tqueryParams[\"PublicKey\"] = req.PublicKey\n\tdefault:\n\t\tqueryParams[\"created_at\"] = req.StartTime\n\t}\n\n\twidgetDAO := &Widget{}\n\taccessLogs, err := widgetDAO.QueryWidgetAccessRecords(queryParams, req.Page, req.Size)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to query access records: %w\", err)\n\t}\n\n\treturn accessLogs, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按MethodName模糊查询",
            "sql": "SELECT id, method_name, access_level, public_key, is_verified, created_at FROM widget_access_records WHERE method_name LIKE '%getWidget%' ORDER BY created_at DESC LIMIT 10 OFFSET 0;"
          },
          {
            "scenario": "按AccessLevel精确查询",
            "sql": "SELECT id, method_name, access_level, public_key, is_verified, created_at FROM widget_access_records WHERE access_level = 2 ORDER BY created_at DESC LIMIT 20 OFFSET 20;"
          },
          {
            "scenario": "按PublicKey和IsVerified组合查询",
            "sql": "SELECT id, method_name, access_level, public_key, is_verified, created_at FROM widget_access_records WHERE public_key = 'abc123' AND is_verified = true ORDER BY created_at DESC LIMIT 5 OFFSET 0;"
          },
          {
            "scenario": "默认查询(按created_at时间范围)",
            "sql": "SELECT id, method_name, access_level, public_key, is_verified, created_at FROM widget_access_records WHERE created_at = '2023-01-01 00:00:00' ORDER BY created_at DESC LIMIT 10 OFFSET 0;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "AccessRecord",
        "code_value": "type AccessRecord struct {\n\tID          uint      `gorm:\"column:id;primaryKey\"`\n\tMethodName  string    `gorm:\"column:method_name\"`\n\tAccessLevel int       `gorm:\"column:access_level\"`\n\tPublicKey   string    `gorm:\"column:public_key\"`\n\tIsVerified  bool      `gorm:\"column:is_verified\"`\n\tCreatedAt   time.Time `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "WidgetQueryParams",
        "code_value": "type WidgetQueryParams struct {\n\tMethodName  string\n\tAccessLevel int\n\tPublicKey   string\n}"
      },
      {
        "code_key": "TableNameWidgetAccessRecords",
        "code_value": "const TableNameWidgetAccessRecords = \"widget_access_records\""
      },
      {
        "code_key": "AccessLevels",
        "code_value": "const (\n\tAccessLevelBasic = 1\n\tAccessLevelAdmin = 2\n\tAccessLevelSuper = 3\n)"
      },
      {
        "code_key": "PaginateDB",
        "code_value": "func PaginateDB(page, size int) func(db *gorm.DB) *gorm.DB {\n\treturn func(db *gorm.DB) *gorm.DB {\n\t\toffset := (page - 1) * size\n\t\treturn db.Offset(offset).Limit(size)\n\t}\n}"
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "RefreshIndex",
    "orm_code": "func (p *Pallet) RefreshIndex(filter map[string]interface{}) ([]types.Score, error) {\n\tscores := make([]types.Score, 0)\n\tdb := base.GetInstance().DbDriver().Table(\"leaderboards\")\n\n\tif projectCode, ok := filter[\"ProjectCode\"]; ok {\n\t\tif err := db.Where(\"project_code = ? AND is_active = ?\", projectCode, true).\n\t\t\tOrder(\"created_at DESC\").Find(&scores).Error; err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else if startDate, ok := filter[\"StartDate\"]; ok {\n\t\tif err := db.Where(\"start_date > ?\", startDate).\n\t\t\tGroup(\"transaction_id\").Having(\"COUNT(*) > 1\").Find(&scores).Error; err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else if region, ok := filter[\"Region\"]; ok {\n\t\tif err := db.Where(\"region LIKE ?\", \"%\"+region.(string)+\"%\").\n\t\t\tLimit(100).Find(&scores).Error; err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\tif err := db.Where(filter).Find(&scores).Error; err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif len(scores) == 0 {\n\t\treturn nil, db.ErrRecordNotFound\n\t}\n\treturn scores, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "filter包含ProjectCode",
            "sql": "SELECT id, project_code, is_active, created_at, start_date, region, transaction_id FROM leaderboards WHERE project_code = ? AND is_active = true ORDER BY created_at DESC;"
          },
          {
            "scenario": "filter包含StartDate",
            "sql": "SELECT id, project_code, is_active, created_at, start_date, region, transaction_id FROM leaderboards WHERE start_date > ? GROUP BY transaction_id HAVING COUNT(*) > 1;"
          },
          {
            "scenario": "filter包含Region",
            "sql": "SELECT id, project_code, is_active, created_at, start_date, region, transaction_id FROM leaderboards WHERE region LIKE ? LIMIT 100;"
          },
          {
            "scenario": "filter包含其他条件",
            "sql": "SELECT id, project_code, is_active, created_at, start_date, region, transaction_id FROM leaderboards WHERE is_active = ? AND transaction_id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "Score",
        "code_value": "type Score struct {\n\tID          int       `json:\"id\" gorm:\"column:id\"`\n\tProjectCode string    `json:\"project_code\" gorm:\"column:project_code\"`\n\tIsActive    bool      `json:\"is_active\" gorm:\"column:is_active\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tStartDate   time.Time `json:\"start_date\" gorm:\"column:start_date\"`\n\tRegion      string    `json:\"region\" gorm:\"column:region\"`\n\tTransactionID string  `json:\"transaction_id\" gorm:\"column:transaction_id\"`\n}"
      },
      {
        "code_key": "LeaderboardFilter",
        "code_value": "type LeaderboardFilter struct {\n\tProjectCode string\n\tStartDate   time.Time\n\tRegion      string\n}"
      },
      {
        "code_key": "TableLeaderboard",
        "code_value": "const TableLeaderboard = \"leaderboards\""
      },
      {
        "code_key": "DefaultScoreLimit",
        "code_value": "const DefaultScoreLimit = 100"
      },
      {
        "code_key": "ScoreBatchSize",
        "code_value": "var ScoreBatchSize = 50"
      }
    ],
    "sql_pattern_cnt": 4
  },
  {
    "function_name": "RefreshIndex",
    "orm_code": "func (p *Pallet) RefreshIndex(filter map[string]interface{}) ([]types.Score, error) {\n\tscores := make([]types.Score, 0)\n\tdb := base.GetInstance().DbDriver().Table(\"leaderboards\")\n\n\tif projectCode, ok := filter[\"ProjectCode\"]; ok {\n\t\tif err := db.Where(\"project_code = ? AND is_active = ?\", projectCode, true).\n\t\t\tOrder(\"created_at DESC\").Find(&scores).Error; err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else if startDate, ok := filter[\"StartDate\"]; ok {\n\t\tif err := db.Where(\"start_date > ?\", startDate).\n\t\t\tGroup(\"transaction_id\").Having(\"COUNT(*) > 1\").Find(&scores).Error; err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else if region, ok := filter[\"Region\"]; ok {\n\t\tif err := db.Where(\"region LIKE ?\", \"%\"+region.(string)+\"%\").\n\t\t\tLimit(100).Find(&scores).Error; err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\tif err := db.Where(filter).Find(&scores).Error; err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif len(scores) == 0 {\n\t\treturn nil, db.ErrRecordNotFound\n\t}\n\treturn scores, nil\n}",
    "caller": "func HandleScoreRefresh(req *types.ScoreRefreshRequest) ([]types.Score, error) {\n\tif req == nil {\n\t\treturn nil, fmt.Errorf(\"request cannot be nil\")\n\t}\n\n\tpallet := &Pallet{}\n\tqueryConditions := make(map[string]interface{})\n\n\tswitch req.QueryType {\n\tcase \"by_project\":\n\t\tif req.ProjectCode == \"\" {\n\t\t\treturn nil, fmt.Errorf(\"project code required for this query type\")\n\t\t}\n\t\tqueryConditions[\"ProjectCode\"] = req.ProjectCode\n\tcase \"by_date\":\n\t\tif req.StartDate.IsZero() {\n\t\t\treturn nil, fmt.Errorf(\"start date required for this query type\")\n\t\t}\n\t\tqueryConditions[\"StartDate\"] = req.StartDate\n\tcase \"by_region\":\n\t\tif req.Region == \"\" {\n\t\t\treturn nil, fmt.Errorf(\"region required for this query type\")\n\t\t}\n\t\tqueryConditions[\"Region\"] = req.Region\n\tdefault:\n\t\tqueryConditions[\"is_active\"] = true\n\t}\n\n\tresults, err := pallet.RefreshIndex(queryConditions)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to refresh scores: %w\", err)\n\t}\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "by_project query with ProjectCode and is_active filter",
            "sql": "SELECT id, project_code, is_active, created_at, start_date, region, transaction_id FROM leaderboards WHERE project_code = ? AND is_active = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "by_date query with StartDate filter and grouping",
            "sql": "SELECT id, project_code, is_active, created_at, start_date, region, transaction_id FROM leaderboards WHERE start_date > ? GROUP BY transaction_id HAVING COUNT(*) > 1;"
          },
          {
            "scenario": "by_region query with Region LIKE filter and limit",
            "sql": "SELECT id, project_code, is_active, created_at, start_date, region, transaction_id FROM leaderboards WHERE region LIKE ? LIMIT 100;"
          },
          {
            "scenario": "default query with is_active filter",
            "sql": "SELECT id, project_code, is_active, created_at, start_date, region, transaction_id FROM leaderboards WHERE is_active = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "Score",
        "code_value": "type Score struct {\n\tID          int       `json:\"id\" gorm:\"column:id\"`\n\tProjectCode string    `json:\"project_code\" gorm:\"column:project_code\"`\n\tIsActive    bool      `json:\"is_active\" gorm:\"column:is_active\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tStartDate   time.Time `json:\"start_date\" gorm:\"column:start_date\"`\n\tRegion      string    `json:\"region\" gorm:\"column:region\"`\n\tTransactionID string  `json:\"transaction_id\" gorm:\"column:transaction_id\"`\n}"
      },
      {
        "code_key": "LeaderboardFilter",
        "code_value": "type LeaderboardFilter struct {\n\tProjectCode string\n\tStartDate   time.Time\n\tRegion      string\n}"
      },
      {
        "code_key": "TableLeaderboard",
        "code_value": "const TableLeaderboard = \"leaderboards\""
      },
      {
        "code_key": "DefaultScoreLimit",
        "code_value": "const DefaultScoreLimit = 100"
      },
      {
        "code_key": "ScoreBatchSize",
        "code_value": "var ScoreBatchSize = 50"
      }
    ],
    "sql_pattern_cnt": 4
  },
  {
    "function_name": "UpdateMediaLibraryStatus",
    "orm_code": "func (m *MediaLibrary) UpdateMediaLibraryStatus(filter map[string]interface{}, status string) ([]types.MediaItem, error) {\n\titems := make([]types.MediaItem, 0)\n\tdb := base.GetInstance().GormDB().Table(\"media_library\")\n\n\tif category, ok := filter[\"category\"]; ok {\n\t\tdb = db.Where(\"category = ? AND current_status != ?\", category, status)\n\t} else if code, ok := filter[\"delivery_code\"]; ok {\n\t\tdb = db.Where(\"delivery_code LIKE ?\", \"%\"+code.(string)+\"%\")\n\t} else if idRange, ok := filter[\"id_range\"]; ok {\n\t\trangeVal := idRange.([]int)\n\t\tif len(rangeVal) == 2 {\n\t\t\tdb = db.Where(\"id BETWEEN ? AND ?\", rangeVal[0], rangeVal[1])\n\t\t}\n\t} else {\n\t\tdb = db.Where(filter)\n\t}\n\n\terr := db.Model(&types.MediaItem{}).\n\t\tUpdate(\"current_status\", status).\n\t\tFind(&items).Error\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, fmt.Errorf(\"no matching records found\")\n\t\t}\n\t\treturn nil, err\n\t}\n\n\treturn items, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "filter contains category",
            "sql": "UPDATE media_library SET current_status = ?, updated_at = CURRENT_TIMESTAMP WHERE category = ? AND current_status != ?;"
          },
          {
            "scenario": "filter contains delivery_code",
            "sql": "UPDATE media_library SET current_status = ?, updated_at = CURRENT_TIMESTAMP WHERE delivery_code LIKE ?;"
          },
          {
            "scenario": "filter contains id_range",
            "sql": "UPDATE media_library SET current_status = ?, updated_at = CURRENT_TIMESTAMP WHERE id BETWEEN ? AND ?;"
          },
          {
            "scenario": "filter is empty or contains other keys",
            "sql": "UPDATE media_library SET current_status = ?, updated_at = CURRENT_TIMESTAMP WHERE ?;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "filter contains category",
            "sql": "SELECT id, category, delivery_code, current_status, created_at, updated_at FROM media_library WHERE category = ? AND current_status != ?;"
          },
          {
            "scenario": "filter contains delivery_code",
            "sql": "SELECT id, category, delivery_code, current_status, created_at, updated_at FROM media_library WHERE delivery_code LIKE ?;"
          },
          {
            "scenario": "filter contains id_range",
            "sql": "SELECT id, category, delivery_code, current_status, created_at, updated_at FROM media_library WHERE id BETWEEN ? AND ?;"
          },
          {
            "scenario": "filter is empty or contains other keys",
            "sql": "SELECT id, category, delivery_code, current_status, created_at, updated_at FROM media_library WHERE ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "MediaItem",
        "code_value": "type MediaItem struct {\n\tID            int       `json:\"id\" gorm:\"column:id;primaryKey\"`\n\tCategory      string    `json:\"category\" gorm:\"column:category\"`\n\tDeliveryCode  string    `json:\"delivery_code\" gorm:\"column:delivery_code\"`\n\tCurrentStatus string    `json:\"current_status\" gorm:\"column:current_status\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "MediaStatus",
        "code_value": "const (\n\tMediaStatusPending   = \"pending\"\n\tMediaStatusApproved  = \"approved\"\n\tMediaStatusRejected  = \"rejected\"\n\tMediaStatusArchived  = \"archived\"\n)"
      },
      {
        "code_key": "MediaLibraryTable",
        "code_value": "const MediaLibraryTable = \"media_library\""
      },
      {
        "code_key": "DefaultMediaCategory",
        "code_value": "var DefaultMediaCategory = map[string]bool{\n\t\"video\":    true,\n\t\"audio\":    true,\n\t\"image\":    true,\n\t\"document\": true,\n}"
      },
      {
        "code_key": "MediaFilter",
        "code_value": "type MediaFilter struct {\n\tCategory     string `json:\"category\"`\n\tDeliveryCode string `json:\"delivery_code\"`\n\tIDRange      []int  `json:\"id_range\"`\n}"
      }
    ],
    "sql_pattern_cnt": 4
  },
  {
    "function_name": "UpdateMediaLibraryStatus",
    "orm_code": "func (m *MediaLibrary) UpdateMediaLibraryStatus(filter map[string]interface{}, status string) ([]types.MediaItem, error) {\n\titems := make([]types.MediaItem, 0)\n\tdb := base.GetInstance().GormDB().Table(\"media_library\")\n\n\tif category, ok := filter[\"category\"]; ok {\n\t\tdb = db.Where(\"category = ? AND current_status != ?\", category, status)\n\t} else if code, ok := filter[\"delivery_code\"]; ok {\n\t\tdb = db.Where(\"delivery_code LIKE ?\", \"%\"+code.(string)+\"%\")\n\t} else if idRange, ok := filter[\"id_range\"]; ok {\n\t\trangeVal := idRange.([]int)\n\t\tif len(rangeVal) == 2 {\n\t\t\tdb = db.Where(\"id BETWEEN ? AND ?\", rangeVal[0], rangeVal[1])\n\t\t}\n\t} else {\n\t\tdb = db.Where(filter)\n\t}\n\n\terr := db.Model(&types.MediaItem{}).\n\t\tUpdate(\"current_status\", status).\n\t\tFind(&items).Error\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, fmt.Errorf(\"no matching records found\")\n\t\t}\n\t\treturn nil, err\n\t}\n\n\treturn items, nil\n}",
    "caller": "func (s *MediaService) HandleMediaStatusUpdate(req *types.MediaStatusUpdateRequest) ([]types.MediaItem, error) {\n\tif req.Status == \"\" {\n\t\treturn nil, fmt.Errorf(\"status cannot be empty\")\n\t}\n\n\tfilterParams := make(map[string]interface{})\n\tif req.Category != \"\" {\n\t\tfilterParams[\"category\"] = req.Category\n\t} else if req.DeliveryCode != \"\" {\n\t\tfilterParams[\"delivery_code\"] = req.DeliveryCode\n\t} else if len(req.IDRange) == 2 {\n\t\tfilterParams[\"id_range\"] = req.IDRange\n\t} else {\n\t\tfilterParams[\"upload_date\"] = req.UploadDate\n\t}\n\n\tmediaLib := &MediaLibrary{}\n\tupdatedItems, err := mediaLib.UpdateMediaLibraryStatus(filterParams, req.Status)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to update media status: %v\", err)\n\t}\n\n\tif len(updatedItems) == 0 {\n\t\treturn nil, fmt.Errorf(\"no items matched the criteria\")\n\t}\n\n\treturn updatedItems, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按category过滤",
            "sql": "UPDATE media_library SET current_status = ?, updated_at = CURRENT_TIMESTAMP WHERE category = ? AND current_status != ?;"
          },
          {
            "scenario": "按category过滤后查询",
            "sql": "SELECT id, category, delivery_code, current_status, created_at, updated_at FROM media_library WHERE category = ? AND current_status != ?;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按delivery_code模糊匹配",
            "sql": "UPDATE media_library SET current_status = ?, updated_at = CURRENT_TIMESTAMP WHERE delivery_code LIKE ?;"
          },
          {
            "scenario": "按delivery_code模糊匹配后查询",
            "sql": "SELECT id, category, delivery_code, current_status, created_at, updated_at FROM media_library WHERE delivery_code LIKE ?;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按id范围过滤",
            "sql": "UPDATE media_library SET current_status = ?, updated_at = CURRENT_TIMESTAMP WHERE id BETWEEN ? AND ?;"
          },
          {
            "scenario": "按id范围过滤后查询",
            "sql": "SELECT id, category, delivery_code, current_status, created_at, updated_at FROM media_library WHERE id BETWEEN ? AND ?;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按upload_date过滤",
            "sql": "UPDATE media_library SET current_status = ?, updated_at = CURRENT_TIMESTAMP WHERE upload_date = ?;"
          },
          {
            "scenario": "按upload_date过滤后查询",
            "sql": "SELECT id, category, delivery_code, current_status, created_at, updated_at FROM media_library WHERE upload_date = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "MediaItem",
        "code_value": "type MediaItem struct {\n\tID            int       `json:\"id\" gorm:\"column:id;primaryKey\"`\n\tCategory      string    `json:\"category\" gorm:\"column:category\"`\n\tDeliveryCode  string    `json:\"delivery_code\" gorm:\"column:delivery_code\"`\n\tCurrentStatus string    `json:\"current_status\" gorm:\"column:current_status\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "MediaStatus",
        "code_value": "const (\n\tMediaStatusPending   = \"pending\"\n\tMediaStatusApproved  = \"approved\"\n\tMediaStatusRejected  = \"rejected\"\n\tMediaStatusArchived  = \"archived\"\n)"
      },
      {
        "code_key": "MediaLibraryTable",
        "code_value": "const MediaLibraryTable = \"media_library\""
      },
      {
        "code_key": "DefaultMediaCategory",
        "code_value": "var DefaultMediaCategory = map[string]bool{\n\t\"video\":    true,\n\t\"audio\":    true,\n\t\"image\":    true,\n\t\"document\": true,\n}"
      },
      {
        "code_key": "MediaFilter",
        "code_value": "type MediaFilter struct {\n\tCategory     string `json:\"category\"`\n\tDeliveryCode string `json:\"delivery_code\"`\n\tIDRange      []int  `json:\"id_range\"`\n}"
      }
    ],
    "sql_pattern_cnt": 4
  },
  {
    "function_name": "OptimizePerformance",
    "orm_code": "func (d *Document) OptimizePerformance(filterParams map[string]interface{}, limit int) ([]types.PerformanceMetric, error) {\n\tmetrics := make([]types.PerformanceMetric, 0)\n\tvar err error\n\n\tquery := base.GetInstance().GormDB().Table(\"quest_progress\")\n\n\tif region, ok := filterParams[\"Region\"]; ok {\n\t\tquery = query.Where(\"region = ?\", region.(string))\n\t} else if session, ok := filterParams[\"SessionToken\"]; ok {\n\t\tquery = query.Where(\"session_token = ? AND status = 'active'\", session.(string))\n\t} else if duration, ok := filterParams[\"Duration\"]; ok {\n\t\tdurationInt := duration.(int)\n\t\tquery = query.Where(\"duration > ? AND completed_at IS NOT NULL\", durationInt)\n\t} else {\n\t\tquery = query.Where(\"is_benchmark = true\")\n\t}\n\n\terr = query.Order(\"score DESC\").Limit(limit).Find(&metrics).Error\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn metrics, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to fetch performance metrics: %w\", err)\n\t}\n\n\treturn metrics, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Region parameter provided",
            "sql": "SELECT id, region, session_token, score, duration, completed_at, is_benchmark, status, created_at, updated_at FROM quest_progress WHERE region = ? ORDER BY score DESC LIMIT ?;"
          },
          {
            "scenario": "SessionToken parameter provided",
            "sql": "SELECT id, region, session_token, score, duration, completed_at, is_benchmark, status, created_at, updated_at FROM quest_progress WHERE session_token = ? AND status = 'active' ORDER BY score DESC LIMIT ?;"
          },
          {
            "scenario": "Duration parameter provided",
            "sql": "SELECT id, region, session_token, score, duration, completed_at, is_benchmark, status, created_at, updated_at FROM quest_progress WHERE duration > ? AND completed_at IS NOT NULL ORDER BY score DESC LIMIT ?;"
          },
          {
            "scenario": "No specific filter parameters provided",
            "sql": "SELECT id, region, session_token, score, duration, completed_at, is_benchmark, status, created_at, updated_at FROM quest_progress WHERE is_benchmark = true ORDER BY score DESC LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "PerformanceMetric",
        "code_value": "type PerformanceMetric struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tRegion        string    `json:\"region\" gorm:\"column:region\"`\n\tSessionToken  string    `json:\"session_token\" gorm:\"column:session_token\"`\n\tScore         float64   `json:\"score\" gorm:\"column:score\"`\n\tDuration      int       `json:\"duration\" gorm:\"column:duration\"`\n\tCompletedAt   time.Time `json:\"completed_at\" gorm:\"column:completed_at\"`\n\tIsBenchmark   bool      `json:\"is_benchmark\" gorm:\"column:is_benchmark\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "Document",
        "code_value": "type Document struct {\n\tID        string `json:\"id\" gorm:\"primaryKey\"`\n\tContent   string `json:\"content\" gorm:\"type:text\"`\n\tVersion   int    `json:\"version\" gorm:\"default:1\"`\n\tIsActive  bool   `json:\"is_active\" gorm:\"default:true\"`\n\tCreatedBy string `json:\"created_by\" gorm:\"size:255\"`\n}"
      },
      {
        "code_key": "TableNamePerformance",
        "code_value": "const TableNamePerformance = \"quest_progress\""
      },
      {
        "code_key": "StatusActive",
        "code_value": "const StatusActive = \"active\""
      },
      {
        "code_key": "DefaultLimit",
        "code_value": "const DefaultLimit = 100"
      },
      {
        "code_key": "FilterParams",
        "code_value": "type FilterParams struct {\n\tRegion       string\n\tSessionToken string\n\tDuration     int\n}"
      }
    ],
    "sql_pattern_cnt": 4
  },
  {
    "function_name": "OptimizePerformance",
    "orm_code": "func (d *Document) OptimizePerformance(filterParams map[string]interface{}, limit int) ([]types.PerformanceMetric, error) {\n\tmetrics := make([]types.PerformanceMetric, 0)\n\tvar err error\n\n\tquery := base.GetInstance().GormDB().Table(\"quest_progress\")\n\n\tif region, ok := filterParams[\"Region\"]; ok {\n\t\tquery = query.Where(\"region = ?\", region.(string))\n\t} else if session, ok := filterParams[\"SessionToken\"]; ok {\n\t\tquery = query.Where(\"session_token = ? AND status = 'active'\", session.(string))\n\t} else if duration, ok := filterParams[\"Duration\"]; ok {\n\t\tdurationInt := duration.(int)\n\t\tquery = query.Where(\"duration > ? AND completed_at IS NOT NULL\", durationInt)\n\t} else {\n\t\tquery = query.Where(\"is_benchmark = true\")\n\t}\n\n\terr = query.Order(\"score DESC\").Limit(limit).Find(&metrics).Error\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn metrics, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to fetch performance metrics: %w\", err)\n\t}\n\n\treturn metrics, nil\n}",
    "caller": "func (h *PerformanceHandler) HandlePerformanceMetrics(criteria *types.PerformanceCriteria) ([]types.PerformanceMetric, error) {\n\tif criteria == nil {\n\t\treturn nil, fmt.Errorf(\"performance criteria cannot be nil\")\n\t}\n\n\tdoc := &Document{}\n\tfilters := make(map[string]interface{})\n\t\n\tif criteria.Region != \"\" {\n\t\tfilters[\"Region\"] = criteria.Region\n\t} else if criteria.SessionToken != \"\" {\n\t\tfilters[\"SessionToken\"] = criteria.SessionToken\n\t} else if criteria.MinDuration > 0 {\n\t\tfilters[\"Duration\"] = criteria.MinDuration\n\t}\n\n\tresult, err := doc.OptimizePerformance(filters, criteria.MaxResults)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to optimize performance: %w\", err)\n\t}\n\n\tif len(result) == 0 {\n\t\treturn nil, fmt.Errorf(\"no performance metrics found\")\n\t}\n\n\treturn result, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Region参数有效",
            "sql": "SELECT id, region, session_token, score, duration, completed_at, is_benchmark, status, created_at, updated_at FROM quest_progress WHERE region = 'some_region' ORDER BY score DESC LIMIT 100;"
          },
          {
            "scenario": "SessionToken参数有效（Region无效）",
            "sql": "SELECT id, region, session_token, score, duration, completed_at, is_benchmark, status, created_at, updated_at FROM quest_progress WHERE session_token = 'some_session_token' AND status = 'active' ORDER BY score DESC LIMIT 100;"
          },
          {
            "scenario": "MinDuration参数有效（Region和SessionToken无效）",
            "sql": "SELECT id, region, session_token, score, duration, completed_at, is_benchmark, status, created_at, updated_at FROM quest_progress WHERE duration > 100 AND completed_at IS NOT NULL ORDER BY score DESC LIMIT 100;"
          },
          {
            "scenario": "无有效参数",
            "sql": "SELECT id, region, session_token, score, duration, completed_at, is_benchmark, status, created_at, updated_at FROM quest_progress WHERE is_benchmark = true ORDER BY score DESC LIMIT 100;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "PerformanceMetric",
        "code_value": "type PerformanceMetric struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tRegion        string    `json:\"region\" gorm:\"column:region\"`\n\tSessionToken  string    `json:\"session_token\" gorm:\"column:session_token\"`\n\tScore         float64   `json:\"score\" gorm:\"column:score\"`\n\tDuration      int       `json:\"duration\" gorm:\"column:duration\"`\n\tCompletedAt   time.Time `json:\"completed_at\" gorm:\"column:completed_at\"`\n\tIsBenchmark   bool      `json:\"is_benchmark\" gorm:\"column:is_benchmark\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "Document",
        "code_value": "type Document struct {\n\tID        string `json:\"id\" gorm:\"primaryKey\"`\n\tContent   string `json:\"content\" gorm:\"type:text\"`\n\tVersion   int    `json:\"version\" gorm:\"default:1\"`\n\tIsActive  bool   `json:\"is_active\" gorm:\"default:true\"`\n\tCreatedBy string `json:\"created_by\" gorm:\"size:255\"`\n}"
      },
      {
        "code_key": "TableNamePerformance",
        "code_value": "const TableNamePerformance = \"quest_progress\""
      },
      {
        "code_key": "StatusActive",
        "code_value": "const StatusActive = \"active\""
      },
      {
        "code_key": "DefaultLimit",
        "code_value": "const DefaultLimit = 100"
      },
      {
        "code_key": "FilterParams",
        "code_value": "type FilterParams struct {\n\tRegion       string\n\tSessionToken string\n\tDuration     int\n}"
      }
    ],
    "sql_pattern_cnt": 4
  },
  {
    "function_name": "QueryProgressByConditions",
    "orm_code": "func (p *Progress) QueryProgressByConditions(criteria map[string]interface{}, page, limit int) ([]types.ProgressDetail, error) {\n    var records []types.ProgressDetail\n    db := base.GetInstance().MainDB().Table(\"progress_tracking\")\n    \n    if locale, ok := criteria[\"Locale\"]; ok {\n        db = db.Where(\"locale = ?\", locale.(string))\n    } else if summary, ok := criteria[\"Summary\"]; ok {\n        db = db.Where(\"summary LIKE ?\", \"%\"+summary.(string)+\"%\")\n    } else if threshold, ok := criteria[\"Threshold\"]; ok {\n        db = db.Where(\"completion_rate >= ?\", threshold.(float64))\n    } else {\n        db = db.Where(criteria)\n    }\n    \n    err := db.Order(\"updated_at DESC\").\n        Scopes(PaginateDB(page, limit)).\n        Find(&records).Error\n    \n    if err != nil {\n        if errors.Is(err, gorm.ErrRecordNotFound) {\n            return nil, nil\n        }\n        return nil, fmt.Errorf(\"query progress failed: %w\", err)\n    }\n    return records, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "criteria中包含Locale参数",
            "sql": "SELECT id, locale, summary, completion_rate, created_at, updated_at FROM progress_tracking WHERE locale = ? ORDER BY updated_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "criteria中包含Summary参数但不含Locale",
            "sql": "SELECT id, locale, summary, completion_rate, created_at, updated_at FROM progress_tracking WHERE summary LIKE ? ORDER BY updated_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "criteria中包含Threshold参数但不含Locale和Summary",
            "sql": "SELECT id, locale, summary, completion_rate, created_at, updated_at FROM progress_tracking WHERE completion_rate >= ? ORDER BY updated_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "criteria包含其他字段或前面条件都不满足",
            "sql": "SELECT id, locale, summary, completion_rate, created_at, updated_at FROM progress_tracking WHERE completion_rate = ? AND locale = ? ORDER BY updated_at DESC LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "ProgressTracking",
        "code_value": "type ProgressTracking struct {\n\tID             int       `json:\"id\" gorm:\"column:id;primaryKey\"`\n\tLocale         string    `json:\"locale\" gorm:\"column:locale\"`\n\tSummary        string    `json:\"summary\" gorm:\"column:summary\"`\n\tCompletionRate float64   `json:\"completion_rate\" gorm:\"column:completion_rate\"`\n\tCreatedAt      time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt      time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "ProgressDetail",
        "code_value": "type ProgressDetail struct {\n\tID             int       `json:\"id\"`\n\tLocale         string    `json:\"locale\"`\n\tSummary        string    `json:\"summary\"`\n\tCompletionRate float64   `json:\"completion_rate\"`\n\tLastUpdated    time.Time `json:\"last_updated\"`\n}"
      },
      {
        "code_key": "ProgressQueryRequest",
        "code_value": "type ProgressQueryRequest struct {\n\tLocale   string  `json:\"locale\"`\n\tSummary  string  `json:\"summary\"`\n\tThreshold float64 `json:\"threshold\"`\n\tPage     int     `json:\"page\"`\n\tLimit    int     `json:\"limit\"`\n}"
      },
      {
        "code_key": "ProgressTable",
        "code_value": "const ProgressTable = \"progress_tracking\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "MaxQueryLimit",
        "code_value": "const MaxQueryLimit = 100"
      },
      {
        "code_key": "ProgressStatus",
        "code_value": "type ProgressStatus struct {\n\tPending   string `json:\"pending\"`\n\tCompleted string `json:\"completed\"`\n\tFailed    string `json:\"failed\"`\n}"
      },
      {
        "code_key": "StatusValues",
        "code_value": "var StatusValues = ProgressStatus{\n\tPending:   \"pending\",\n\tCompleted: \"completed\",\n\tFailed:    \"failed\",\n}"
      }
    ],
    "sql_pattern_cnt": 4
  },
  {
    "function_name": "QueryProgressByConditions",
    "orm_code": "func (p *Progress) QueryProgressByConditions(criteria map[string]interface{}, page, limit int) ([]types.ProgressDetail, error) {\n    var records []types.ProgressDetail\n    db := base.GetInstance().MainDB().Table(\"progress_tracking\")\n    \n    if locale, ok := criteria[\"Locale\"]; ok {\n        db = db.Where(\"locale = ?\", locale.(string))\n    } else if summary, ok := criteria[\"Summary\"]; ok {\n        db = db.Where(\"summary LIKE ?\", \"%\"+summary.(string)+\"%\")\n    } else if threshold, ok := criteria[\"Threshold\"]; ok {\n        db = db.Where(\"completion_rate >= ?\", threshold.(float64))\n    } else {\n        db = db.Where(criteria)\n    }\n    \n    err := db.Order(\"updated_at DESC\").\n        Scopes(PaginateDB(page, limit)).\n        Find(&records).Error\n    \n    if err != nil {\n        if errors.Is(err, gorm.ErrRecordNotFound) {\n            return nil, nil\n        }\n        return nil, fmt.Errorf(\"query progress failed: %w\", err)\n    }\n    return records, nil\n}",
    "caller": "func (h *ContainerHandler) HandleContainerProgress(req *types.ContainerProgressRequest) ([]types.ProgressDetail, error) {\n    if req.Page <= 0 || req.Limit <= 0 {\n        return nil, fmt.Errorf(\"invalid pagination parameters\")\n    }\n    \n    searchParams := make(map[string]interface{})\n    \n    if req.Locale != \"\" {\n        searchParams[\"Locale\"] = req.Locale\n    } else if req.SummaryKeyword != \"\" {\n        searchParams[\"Summary\"] = req.SummaryKeyword\n    } else if req.MinCompletionRate > 0 {\n        searchParams[\"Threshold\"] = req.MinCompletionRate\n    } else {\n        searchParams[\"container_id\"] = req.ContainerID\n    }\n    \n    progressTracker := &Progress{}\n    results, err := progressTracker.QueryProgressByConditions(searchParams, req.Page, req.Limit)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to query container progress: %w\", err)\n    }\n    \n    return results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "提供Locale参数",
            "sql": "SELECT id, locale, summary, completion_rate, created_at, updated_at FROM progress_tracking WHERE locale = 'en-US' ORDER BY updated_at DESC LIMIT 10 OFFSET 0;"
          },
          {
            "scenario": "提供SummaryKeyword参数",
            "sql": "SELECT id, locale, summary, completion_rate, created_at, updated_at FROM progress_tracking WHERE summary LIKE '%update%' ORDER BY updated_at DESC LIMIT 20 OFFSET 20;"
          },
          {
            "scenario": "提供MinCompletionRate参数",
            "sql": "SELECT id, locale, summary, completion_rate, created_at, updated_at FROM progress_tracking WHERE completion_rate >= 0.5 ORDER BY updated_at DESC LIMIT 15 OFFSET 30;"
          },
          {
            "scenario": "提供ContainerID参数",
            "sql": "SELECT id, locale, summary, completion_rate, created_at, updated_at FROM progress_tracking WHERE container_id = 'container123' ORDER BY updated_at DESC LIMIT 5 OFFSET 0;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "ProgressTracking",
        "code_value": "type ProgressTracking struct {\n\tID             int       `json:\"id\" gorm:\"column:id;primaryKey\"`\n\tLocale         string    `json:\"locale\" gorm:\"column:locale\"`\n\tSummary        string    `json:\"summary\" gorm:\"column:summary\"`\n\tCompletionRate float64   `json:\"completion_rate\" gorm:\"column:completion_rate\"`\n\tCreatedAt      time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt      time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "ProgressDetail",
        "code_value": "type ProgressDetail struct {\n\tID             int       `json:\"id\"`\n\tLocale         string    `json:\"locale\"`\n\tSummary        string    `json:\"summary\"`\n\tCompletionRate float64   `json:\"completion_rate\"`\n\tLastUpdated    time.Time `json:\"last_updated\"`\n}"
      },
      {
        "code_key": "ProgressQueryRequest",
        "code_value": "type ProgressQueryRequest struct {\n\tLocale   string  `json:\"locale\"`\n\tSummary  string  `json:\"summary\"`\n\tThreshold float64 `json:\"threshold\"`\n\tPage     int     `json:\"page\"`\n\tLimit    int     `json:\"limit\"`\n}"
      },
      {
        "code_key": "ProgressTable",
        "code_value": "const ProgressTable = \"progress_tracking\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "MaxQueryLimit",
        "code_value": "const MaxQueryLimit = 100"
      },
      {
        "code_key": "ProgressStatus",
        "code_value": "type ProgressStatus struct {\n\tPending   string `json:\"pending\"`\n\tCompleted string `json:\"completed\"`\n\tFailed    string `json:\"failed\"`\n}"
      },
      {
        "code_key": "StatusValues",
        "code_value": "var StatusValues = ProgressStatus{\n\tPending:   \"pending\",\n\tCompleted: \"completed\",\n\tFailed:    \"failed\",\n}"
      }
    ],
    "sql_pattern_cnt": 4
  },
  {
    "function_name": "AssignTask",
    "orm_code": "func (m *Magazine) AssignTask(filterParams map[string]interface{}, page, limit int) ([]types.TaskAssignment, error) {\n\tassignments := make([]types.TaskAssignment, 0)\n\tvar err error\n\n\tif ticketNumber, ok := filterParams[\"TicketNumber\"]; ok {\n\t\tquery := base.GetDB().Table(\"share_activities\").Where(\"ticket_number = ?\", ticketNumber)\n\t\tif language, ok := filterParams[\"Language\"]; ok {\n\t\t\tquery = query.Where(\"language = ?\", language)\n\t\t}\n\t\terr = query.Scopes(PaginateDB(page, limit)).Find(&assignments).Error\n\t} else if firstLoginDate, ok := filterParams[\"FirstLoginDate\"]; ok {\n\t\tstartDate := firstLoginDate.(string) + \" 00:00:00\"\n\t\tendDate := firstLoginDate.(string) + \" 23:59:59\"\n\t\terr = base.GetDB().Table(\"transit_times\")\n\t\t\t.Where(\"created_at BETWEEN ? AND ?\", startDate, endDate)\n\t\t\t.Scopes(PaginateDB(page, limit))\n\t\t\t.Find(&assignments).Error\n\t} else {\n\t\terr = base.GetDB().Table(\"prescription_data\")\n\t\t\t.Where(filterParams)\n\t\t\t.Scopes(PaginateDB(page, limit))\n\t\t\t.Find(&assignments).Error\n\t}\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn assignments, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "提供TicketNumber参数",
            "sql": "SELECT id, ticket_number, language, created_at, updated_at, assignee_id, status FROM share_activities WHERE ticket_number = ? AND language = ? LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "提供FirstLoginDate参数",
            "sql": "SELECT id, ticket_number, language, created_at, updated_at, assignee_id, status FROM transit_times WHERE created_at BETWEEN ? AND ? LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "不提供TicketNumber或FirstLoginDate",
            "sql": "SELECT id, ticket_number, language, created_at, updated_at, assignee_id, status FROM prescription_data WHERE assignee_id = ? AND status = ? LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "TaskAssignment",
        "code_value": "type TaskAssignment struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tTicketNumber  string    `json:\"ticket_number\" gorm:\"column:ticket_number\"`\n\tLanguage      string    `json:\"language\" gorm:\"column:language\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n\tAssigneeID    int       `json:\"assignee_id\" gorm:\"column:assignee_id\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "TaskFilterParams",
        "code_value": "type TaskFilterParams struct {\n\tTicketNumber   *string `json:\"ticket_number\"`\n\tLanguage       *string `json:\"language\"`\n\tFirstLoginDate *string `json:\"first_login_date\"`\n\tAssigneeID     *int    `json:\"assignee_id\"`\n}"
      },
      {
        "code_key": "TaskStatus",
        "code_value": "const (\n\tTaskStatusPending   = \"pending\"\n\tTaskStatusAssigned = \"assigned\"\n\tTaskStatusCompleted = \"completed\"\n\tTaskStatusRejected = \"rejected\"\n)"
      },
      {
        "code_key": "TaskTables",
        "code_value": "var TaskTables = struct {\n\tShareActivities  string\n\tTransitTimes     string\n\tPrescriptionData string\n}{\n\tShareActivities:  \"share_activities\",\n\tTransitTimes:     \"transit_times\",\n\tPrescriptionData: \"prescription_data\",\n}"
      },
      {
        "code_key": "AssignmentResponse",
        "code_value": "type AssignmentResponse struct {\n\tSuccess   bool               `json:\"success\"`\n\tMessage   string             `json:\"message\"`\n\tData      []TaskAssignment   `json:\"data\"`\n\tPage      int                `json:\"page\"`\n\tPageSize  int                `json:\"page_size\"`\n\tTotal     int64              `json:\"total\"`\n}"
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "AssignTask",
    "orm_code": "func (m *Magazine) AssignTask(filterParams map[string]interface{}, page, limit int) ([]types.TaskAssignment, error) {\n\tassignments := make([]types.TaskAssignment, 0)\n\tvar err error\n\n\tif ticketNumber, ok := filterParams[\"TicketNumber\"]; ok {\n\t\tquery := base.GetDB().Table(\"share_activities\").Where(\"ticket_number = ?\", ticketNumber)\n\t\tif language, ok := filterParams[\"Language\"]; ok {\n\t\t\tquery = query.Where(\"language = ?\", language)\n\t\t}\n\t\terr = query.Scopes(PaginateDB(page, limit)).Find(&assignments).Error\n\t} else if firstLoginDate, ok := filterParams[\"FirstLoginDate\"]; ok {\n\t\tstartDate := firstLoginDate.(string) + \" 00:00:00\"\n\t\tendDate := firstLoginDate.(string) + \" 23:59:59\"\n\t\terr = base.GetDB().Table(\"transit_times\")\n\t\t\t.Where(\"created_at BETWEEN ? AND ?\", startDate, endDate)\n\t\t\t.Scopes(PaginateDB(page, limit))\n\t\t\t.Find(&assignments).Error\n\t} else {\n\t\terr = base.GetDB().Table(\"prescription_data\")\n\t\t\t.Where(filterParams)\n\t\t\t.Scopes(PaginateDB(page, limit))\n\t\t\t.Find(&assignments).Error\n\t}\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn assignments, nil\n}",
    "caller": "func (s *TaskService) HandleTaskAssignment(req *types.TaskAssignmentRequest) ([]types.TaskAssignment, error) {\n\tmag := &Magazine{}\n\tfilters := make(map[string]interface{})\n\n\tswitch req.SearchType {\n\tcase \"byTicket\":\n\t\tif req.TicketNumber == \"\" {\n\t\t\treturn nil, errors.New(\"ticket number required\")\n\t\t}\n\t\tfilters[\"TicketNumber\"] = req.TicketNumber\n\t\tif req.Language != \"\" {\n\t\t\tfilters[\"Language\"] = req.Language\n\t\t}\n\tcase \"byDate\":\n\t\tif req.FirstLoginDate == \"\" {\n\t\t\treturn nil, errors.New(\"date required\")\n\t\t}\n\t\tfilters[\"FirstLoginDate\"] = req.FirstLoginDate\n\tdefault:\n\t\tif req.Status != \"\" {\n\t\t\tfilters[\"status\"] = req.Status\n\t\t}\n\t}\n\n\tpage := 1\n\tif req.Page > 0 {\n\t\tpage = req.Page\n\t}\n\tlimit := 10\n\tif req.Limit > 0 && req.Limit < 100 {\n\t\tlimit = req.Limit\n\t}\n\n\treturn mag.AssignTask(filters, page, limit)\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按票号搜索(仅ticket_number)",
            "sql": "SELECT id, ticket_number, language, created_at, updated_at, assignee_id, status FROM share_activities WHERE ticket_number = ? LIMIT 10 OFFSET 0;"
          },
          {
            "scenario": "按票号搜索(ticket_number和language)",
            "sql": "SELECT id, ticket_number, language, created_at, updated_at, assignee_id, status FROM share_activities WHERE ticket_number = ? AND language = ? LIMIT 10 OFFSET 0;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按日期搜索",
            "sql": "SELECT id, ticket_number, language, created_at, updated_at, assignee_id, status FROM transit_times WHERE created_at BETWEEN ? AND ? LIMIT 10 OFFSET 0;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "默认搜索(status条件)",
            "sql": "SELECT id, ticket_number, language, created_at, updated_at, assignee_id, status FROM prescription_data WHERE status = ? LIMIT 10 OFFSET 0;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "TaskAssignment",
        "code_value": "type TaskAssignment struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tTicketNumber  string    `json:\"ticket_number\" gorm:\"column:ticket_number\"`\n\tLanguage      string    `json:\"language\" gorm:\"column:language\"`\n\tCreatedAt     time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n\tAssigneeID    int       `json:\"assignee_id\" gorm:\"column:assignee_id\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "TaskFilterParams",
        "code_value": "type TaskFilterParams struct {\n\tTicketNumber   *string `json:\"ticket_number\"`\n\tLanguage       *string `json:\"language\"`\n\tFirstLoginDate *string `json:\"first_login_date\"`\n\tAssigneeID     *int    `json:\"assignee_id\"`\n}"
      },
      {
        "code_key": "TaskStatus",
        "code_value": "const (\n\tTaskStatusPending   = \"pending\"\n\tTaskStatusAssigned = \"assigned\"\n\tTaskStatusCompleted = \"completed\"\n\tTaskStatusRejected = \"rejected\"\n)"
      },
      {
        "code_key": "TaskTables",
        "code_value": "var TaskTables = struct {\n\tShareActivities  string\n\tTransitTimes     string\n\tPrescriptionData string\n}{\n\tShareActivities:  \"share_activities\",\n\tTransitTimes:     \"transit_times\",\n\tPrescriptionData: \"prescription_data\",\n}"
      },
      {
        "code_key": "AssignmentResponse",
        "code_value": "type AssignmentResponse struct {\n\tSuccess   bool               `json:\"success\"`\n\tMessage   string             `json:\"message\"`\n\tData      []TaskAssignment   `json:\"data\"`\n\tPage      int                `json:\"page\"`\n\tPageSize  int                `json:\"page_size\"`\n\tTotal     int64              `json:\"total\"`\n}"
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "ValidatePolicy",
    "orm_code": "func (p *Policy) ValidatePolicy(filter map[string]interface{}) ([]types.PolicyRecord, error) {\n\tvar records []types.PolicyRecord\n\tdb := base.GetInstance().Db().Table(\"content_archive\")\n\n\tif zone, ok := filter[\"Zone\"]; ok {\n\t\tdb = db.Where(\"zone = ?\", zone).Order(\"created_at DESC\")\n\t} else if privateKey, ok := filter[\"PrivateKey\"]; ok {\n\t\tdb = db.Where(\"private_key LIKE ?\", \"%\"+privateKey.(string)+\"%\").Order(\"updated_at\")\n\t} else if totalAmount, ok := filter[\"TotalAmount\"]; ok {\n\t\tamount := totalAmount.(float64)\n\t\tdb = db.Where(\"total_amount > ? AND total_amount < ?\", amount*0.9, amount*1.1)\n\t} else {\n\t\treturn nil, errors.New(\"invalid filter parameters\")\n\t}\n\n\tif err := db.Find(&records).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"database error: %w\", err)\n\t}\n\n\treturn records, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "filter contains Zone parameter",
            "sql": "SELECT id, zone, private_key, total_amount, created_at, updated_at FROM content_archive WHERE zone = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "filter contains PrivateKey parameter",
            "sql": "SELECT id, zone, private_key, total_amount, created_at, updated_at FROM content_archive WHERE private_key LIKE ? ORDER BY updated_at;"
          },
          {
            "scenario": "filter contains TotalAmount parameter",
            "sql": "SELECT id, zone, private_key, total_amount, created_at, updated_at FROM content_archive WHERE total_amount > ? AND total_amount < ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "PolicyRecord",
        "code_value": "type PolicyRecord struct {\n\tID          uint      `json:\"id\" gorm:\"column:id\"`\n\tZone        string    `json:\"zone\" gorm:\"column:zone\"`\n\tPrivateKey  string    `json:\"private_key\" gorm:\"column:private_key\"`\n\tTotalAmount float64   `json:\"total_amount\" gorm:\"column:total_amount\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt   time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "PolicyFilter",
        "code_value": "type PolicyFilter struct {\n\tZone       string  `json:\"zone\"`\n\tPrivateKey string  `json:\"private_key\"`\n\tTotalAmount float64 `json:\"total_amount\"`\n}"
      },
      {
        "code_key": "ContentArchiveTable",
        "code_value": "const ContentArchiveTable = \"content_archive\""
      },
      {
        "code_key": "ErrorMessages",
        "code_value": "var ErrorMessages = map[string]string{\n\t\"InvalidFilter\": \"invalid filter parameters\",\n\t\"DatabaseError\": \"database error\",\n\t\"NotFound\": \"record not found\"\n}"
      },
      {
        "code_key": "PolicyValidationThreshold",
        "code_value": "const PolicyValidationThreshold = 0.1"
      },
      {
        "code_key": "PolicyResponse",
        "code_value": "type PolicyResponse struct {\n\tRecords []PolicyRecord `json:\"records\"`\n\tError   string        `json:\"error,omitempty\"`\n}"
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "ValidatePolicy",
    "orm_code": "func (p *Policy) ValidatePolicy(filter map[string]interface{}) ([]types.PolicyRecord, error) {\n\tvar records []types.PolicyRecord\n\tdb := base.GetInstance().Db().Table(\"content_archive\")\n\n\tif zone, ok := filter[\"Zone\"]; ok {\n\t\tdb = db.Where(\"zone = ?\", zone).Order(\"created_at DESC\")\n\t} else if privateKey, ok := filter[\"PrivateKey\"]; ok {\n\t\tdb = db.Where(\"private_key LIKE ?\", \"%\"+privateKey.(string)+\"%\").Order(\"updated_at\")\n\t} else if totalAmount, ok := filter[\"TotalAmount\"]; ok {\n\t\tamount := totalAmount.(float64)\n\t\tdb = db.Where(\"total_amount > ? AND total_amount < ?\", amount*0.9, amount*1.1)\n\t} else {\n\t\treturn nil, errors.New(\"invalid filter parameters\")\n\t}\n\n\tif err := db.Find(&records).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"database error: %w\", err)\n\t}\n\n\treturn records, nil\n}",
    "caller": "func (s *PolicyService) HandlePolicySearch(searchReq *types.PolicySearchRequest) ([]types.PolicyRecord, error) {\n\tif searchReq == nil {\n\t\treturn nil, errors.New(\"invalid request\")\n\t}\n\n\tqueryFilters := make(map[string]interface{})\n\n\tswitch {\n\tcase searchReq.ZoneID != \"\":\n\t\tqueryFilters[\"Zone\"] = searchReq.ZoneID\n\tcase searchReq.KeyFragment != \"\":\n\t\tif len(searchReq.KeyFragment) < 4 {\n\t\t\treturn nil, errors.New(\"key fragment too short\")\n\t\t}\n\t\tqueryFilters[\"PrivateKey\"] = searchReq.KeyFragment\n\tcase searchReq.ApproxAmount > 0:\n\t\tqueryFilters[\"TotalAmount\"] = searchReq.ApproxAmount\n\tdefault:\n\t\treturn nil, errors.New(\"no valid search criteria provided\")\n\t}\n\n\tpolicy := &Policy{}\n\trecords, err := policy.ValidatePolicy(queryFilters)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"policy validation failed: %w\", err)\n\t}\n\n\treturn records, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按ZoneID查询",
            "sql": "SELECT `id`, `zone`, `private_key`, `total_amount`, `created_at`, `updated_at` FROM `content_archive` WHERE `zone` = ? ORDER BY `created_at` DESC;"
          },
          {
            "scenario": "按PrivateKey模糊查询",
            "sql": "SELECT `id`, `zone`, `private_key`, `total_amount`, `created_at`, `updated_at` FROM `content_archive` WHERE `private_key` LIKE ? ORDER BY `updated_at`;"
          },
          {
            "scenario": "按ApproxAmount范围查询",
            "sql": "SELECT `id`, `zone`, `private_key`, `total_amount`, `created_at`, `updated_at` FROM `content_archive` WHERE `total_amount` > ? AND `total_amount` < ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "PolicyRecord",
        "code_value": "type PolicyRecord struct {\n\tID          uint      `json:\"id\" gorm:\"column:id\"`\n\tZone        string    `json:\"zone\" gorm:\"column:zone\"`\n\tPrivateKey  string    `json:\"private_key\" gorm:\"column:private_key\"`\n\tTotalAmount float64   `json:\"total_amount\" gorm:\"column:total_amount\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt   time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "PolicyFilter",
        "code_value": "type PolicyFilter struct {\n\tZone       string  `json:\"zone\"`\n\tPrivateKey string  `json:\"private_key\"`\n\tTotalAmount float64 `json:\"total_amount\"`\n}"
      },
      {
        "code_key": "ContentArchiveTable",
        "code_value": "const ContentArchiveTable = \"content_archive\""
      },
      {
        "code_key": "ErrorMessages",
        "code_value": "var ErrorMessages = map[string]string{\n\t\"InvalidFilter\": \"invalid filter parameters\",\n\t\"DatabaseError\": \"database error\",\n\t\"NotFound\": \"record not found\"\n}"
      },
      {
        "code_key": "PolicyValidationThreshold",
        "code_value": "const PolicyValidationThreshold = 0.1"
      },
      {
        "code_key": "PolicyResponse",
        "code_value": "type PolicyResponse struct {\n\tRecords []PolicyRecord `json:\"records\"`\n\tError   string        `json:\"error,omitempty\"`\n}"
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "QueryGameSessions",
    "orm_code": "func (s *Student) QueryGameSessions(filter map[string]interface{}, page, size int) ([]types.GameSession, error) {\n\tvar sessions []types.GameSession\n\tdb := base.GetInstance().GormDB().Table(\"game_sessions\")\n\n\tif version, ok := filter[\"Version\"]; ok {\n\t\tdb = db.Where(\"version = ?\", version).Order(\"created_at desc\")\n\t} else if rank, ok := filter[\"PriorityRank\"]; ok {\n\t\tdb = db.Where(\"priority_rank > ?\", rank).Order(\"priority_rank asc\")\n\t} else if building, ok := filter[\"Building\"]; ok {\n\t\tdb = db.Where(\"building LIKE ?\", \"%\"+building.(string)+\"%\").Order(\"building asc\")\n\t} else {\n\t\tdb = db.Order(\"id desc\")\n\t}\n\n\terr := db.Scopes(Paginate(page, size)).Find(&sessions).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn sessions, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "filter中包含Version参数",
            "sql": "SELECT id, version, priority_rank, building, created_at, updated_at FROM game_sessions WHERE version = ? ORDER BY created_at DESC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "filter中包含PriorityRank参数",
            "sql": "SELECT id, version, priority_rank, building, created_at, updated_at FROM game_sessions WHERE priority_rank > ? ORDER BY priority_rank ASC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "filter中包含Building参数",
            "sql": "SELECT id, version, priority_rank, building, created_at, updated_at FROM game_sessions WHERE building LIKE ? ORDER BY building ASC LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "filter为空",
            "sql": "SELECT id, version, priority_rank, building, created_at, updated_at FROM game_sessions ORDER BY id DESC LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "GameSession",
        "code_value": "type GameSession struct {\n\tID           uint      `gorm:\"column:id;primaryKey\"`\n\tVersion      string    `gorm:\"column:version\"`\n\tPriorityRank int       `gorm:\"column:priority_rank\"`\n\tBuilding     string    `gorm:\"column:building\"`\n\tCreatedAt    time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt    time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "SessionFilter",
        "code_value": "type SessionFilter struct {\n\tVersion      *string\n\tPriorityRank *int\n\tBuilding     *string\n}"
      },
      {
        "code_key": "GameSessionResponse",
        "code_value": "type GameSessionResponse struct {\n\tSessions []GameSession `json:\"sessions\"`\n\tPage     int           `json:\"page\"`\n\tPageSize int           `json:\"page_size\"`\n\tTotal    int64         `json:\"total\"`\n}"
      },
      {
        "code_key": "TableNameGameSessions",
        "code_value": "const TableNameGameSessions = \"game_sessions\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "MaxPageSize",
        "code_value": "const MaxPageSize = 100"
      },
      {
        "code_key": "SessionStatusActive",
        "code_value": "const SessionStatusActive = \"active\""
      },
      {
        "code_key": "SessionStatusInactive",
        "code_value": "const SessionStatusInactive = \"inactive\""
      }
    ],
    "sql_pattern_cnt": 4
  },
  {
    "function_name": "QueryGameSessions",
    "orm_code": "func (s *Student) QueryGameSessions(filter map[string]interface{}, page, size int) ([]types.GameSession, error) {\n\tvar sessions []types.GameSession\n\tdb := base.GetInstance().GormDB().Table(\"game_sessions\")\n\n\tif version, ok := filter[\"Version\"]; ok {\n\t\tdb = db.Where(\"version = ?\", version).Order(\"created_at desc\")\n\t} else if rank, ok := filter[\"PriorityRank\"]; ok {\n\t\tdb = db.Where(\"priority_rank > ?\", rank).Order(\"priority_rank asc\")\n\t} else if building, ok := filter[\"Building\"]; ok {\n\t\tdb = db.Where(\"building LIKE ?\", \"%\"+building.(string)+\"%\").Order(\"building asc\")\n\t} else {\n\t\tdb = db.Order(\"id desc\")\n\t}\n\n\terr := db.Scopes(Paginate(page, size)).Find(&sessions).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn sessions, nil\n}",
    "caller": "func (h *GameSessionHandler) HandleGameSessionQuery(req *types.GameSessionQueryRequest) ([]types.GameSession, error) {\n\tif req.Page <= 0 || req.Size <= 0 {\n\t\treturn nil, fmt.Errorf(\"invalid pagination parameters\")\n\t}\n\n\tcriteria := make(map[string]interface{})\n\tif req.Version != \"\" {\n\t\tcriteria[\"Version\"] = req.Version\n\t} else if req.PriorityRank > 0 {\n\t\tcriteria[\"PriorityRank\"] = req.PriorityRank\n\t} else if req.Building != \"\" {\n\t\tcriteria[\"Building\"] = req.Building\n\t}\n\n\tstudent := &Student{}\n\tresults, err := student.QueryGameSessions(criteria, req.Page, req.Size)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"query failed: %v\", err)\n\t}\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "查询特定版本",
            "sql": "SELECT id, version, priority_rank, building, created_at, updated_at FROM game_sessions WHERE version = ? ORDER BY created_at desc LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "查询优先级高于指定值",
            "sql": "SELECT id, version, priority_rank, building, created_at, updated_at FROM game_sessions WHERE priority_rank > ? ORDER BY priority_rank asc LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "模糊查询建筑名称",
            "sql": "SELECT id, version, priority_rank, building, created_at, updated_at FROM game_sessions WHERE building LIKE ? ORDER BY building asc LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "默认查询",
            "sql": "SELECT id, version, priority_rank, building, created_at, updated_at FROM game_sessions ORDER BY id desc LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "GameSession",
        "code_value": "type GameSession struct {\n\tID           uint      `gorm:\"column:id;primaryKey\"`\n\tVersion      string    `gorm:\"column:version\"`\n\tPriorityRank int       `gorm:\"column:priority_rank\"`\n\tBuilding     string    `gorm:\"column:building\"`\n\tCreatedAt    time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt    time.Time `gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "SessionFilter",
        "code_value": "type SessionFilter struct {\n\tVersion      *string\n\tPriorityRank *int\n\tBuilding     *string\n}"
      },
      {
        "code_key": "GameSessionResponse",
        "code_value": "type GameSessionResponse struct {\n\tSessions []GameSession `json:\"sessions\"`\n\tPage     int           `json:\"page\"`\n\tPageSize int           `json:\"page_size\"`\n\tTotal    int64         `json:\"total\"`\n}"
      },
      {
        "code_key": "TableNameGameSessions",
        "code_value": "const TableNameGameSessions = \"game_sessions\""
      },
      {
        "code_key": "DefaultPageSize",
        "code_value": "const DefaultPageSize = 20"
      },
      {
        "code_key": "MaxPageSize",
        "code_value": "const MaxPageSize = 100"
      },
      {
        "code_key": "SessionStatusActive",
        "code_value": "const SessionStatusActive = \"active\""
      },
      {
        "code_key": "SessionStatusInactive",
        "code_value": "const SessionStatusInactive = \"inactive\""
      }
    ],
    "sql_pattern_cnt": 4
  },
  {
    "function_name": "FetchCurrencyRates",
    "orm_code": "func (c *Currency) FetchCurrencyRates(filter map[string]interface{}) ([]types.ExchangeRate, error) {\n\trates := make([]types.ExchangeRate, 0)\n\tvar err error\n\n\tif code, ok := filter[\"LocationCode\"]; ok {\n\t\terr = base.GetDB().Table(\"investment_portfolios\").\n\t\t\tWhere(\"location_code = ? AND status = ?\", code.(string), \"active\").\n\t\t\tOrder(\"effective_date DESC\").\n\t\t\tFind(&rates).Error\n\t} else if dateRange, ok := filter[\"DateRange\"]; ok {\n\t\trangeVal := dateRange.([]string)\n\t\terr = base.GetDB().Table(\"investment_portfolios\").\n\t\t\tWhere(\"effective_date BETWEEN ? AND ?\", rangeVal[0], rangeVal[1]).\n\t\t\tGroup(\"currency_type\").\n\t\t\tFind(&rates).Error\n\t} else if threshold, ok := filter[\"RateThreshold\"]; ok {\n\t\terr = base.GetDB().Table(\"investment_portfolios\").\n\t\t\tWhere(\"conversion_rate > ?\", threshold.(float64)).\n\t\t\tLimit(100).\n\t\t\tFind(&rates).Error\n\t} else {\n\t\terr = base.GetDB().Table(\"investment_portfolios\").\n\t\t\tWhere(filter).\n\t\t\tFind(&rates).Error\n\t}\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, fmt.Errorf(\"no matching currency rates found\")\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn rates, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按LocationCode和Status查询",
            "sql": "SELECT id, currency_type, location_code, conversion_rate, effective_date, status FROM investment_portfolios WHERE location_code = ? AND status = ? ORDER BY effective_date DESC;"
          },
          {
            "scenario": "按DateRange查询并分组",
            "sql": "SELECT id, currency_type, location_code, conversion_rate, effective_date, status FROM investment_portfolios WHERE effective_date BETWEEN ? AND ? GROUP BY currency_type;"
          },
          {
            "scenario": "按RateThreshold查询",
            "sql": "SELECT id, currency_type, location_code, conversion_rate, effective_date, status FROM investment_portfolios WHERE conversion_rate > ? LIMIT 100;"
          },
          {
            "scenario": "通用过滤查询",
            "sql": "SELECT id, currency_type, location_code, conversion_rate, effective_date, status FROM investment_portfolios WHERE currency_type = ? AND status = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "ExchangeRate",
        "code_value": "type ExchangeRate struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tCurrencyType  string    `json:\"currency_type\" gorm:\"column:currency_type\"`\n\tLocationCode  string    `json:\"location_code\" gorm:\"column:location_code\"`\n\tConversionRate float64   `json:\"conversion_rate\" gorm:\"column:conversion_rate\"`\n\tEffectiveDate time.Time `json:\"effective_date\" gorm:\"column:effective_date\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "CurrencyFilter",
        "code_value": "type CurrencyFilter struct {\n\tLocationCode  interface{} `json:\"LocationCode\"`\n\tDateRange     interface{} `json:\"DateRange\"`\n\tRateThreshold interface{} `json:\"RateThreshold\"`\n}"
      },
      {
        "code_key": "TableInvestmentPortfolios",
        "code_value": "const TableInvestmentPortfolios = \"investment_portfolios\""
      },
      {
        "code_key": "StatusActive",
        "code_value": "const StatusActive = \"active\""
      },
      {
        "code_key": "DefaultRateLimit",
        "code_value": "const DefaultRateLimit = 100"
      },
      {
        "code_key": "CurrencyErrorMessages",
        "code_value": "var CurrencyErrorMessages = map[string]string{\n\t\"NotFound\": \"no matching currency rates found\",\n\t\"InvalidFilter\": \"invalid filter parameters provided\"\n}"
      }
    ],
    "sql_pattern_cnt": 4
  },
  {
    "function_name": "FetchCurrencyRates",
    "orm_code": "func (c *Currency) FetchCurrencyRates(filter map[string]interface{}) ([]types.ExchangeRate, error) {\n\trates := make([]types.ExchangeRate, 0)\n\tvar err error\n\n\tif code, ok := filter[\"LocationCode\"]; ok {\n\t\terr = base.GetDB().Table(\"investment_portfolios\").\n\t\t\tWhere(\"location_code = ? AND status = ?\", code.(string), \"active\").\n\t\t\tOrder(\"effective_date DESC\").\n\t\t\tFind(&rates).Error\n\t} else if dateRange, ok := filter[\"DateRange\"]; ok {\n\t\trangeVal := dateRange.([]string)\n\t\terr = base.GetDB().Table(\"investment_portfolios\").\n\t\t\tWhere(\"effective_date BETWEEN ? AND ?\", rangeVal[0], rangeVal[1]).\n\t\t\tGroup(\"currency_type\").\n\t\t\tFind(&rates).Error\n\t} else if threshold, ok := filter[\"RateThreshold\"]; ok {\n\t\terr = base.GetDB().Table(\"investment_portfolios\").\n\t\t\tWhere(\"conversion_rate > ?\", threshold.(float64)).\n\t\t\tLimit(100).\n\t\t\tFind(&rates).Error\n\t} else {\n\t\terr = base.GetDB().Table(\"investment_portfolios\").\n\t\t\tWhere(filter).\n\t\t\tFind(&rates).Error\n\t}\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, fmt.Errorf(\"no matching currency rates found\")\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn rates, nil\n}",
    "caller": "func HandleCurrencyRateRequest(criteria *types.CurrencyRateCriteria) ([]types.ExchangeRate, error) {\n\tif criteria == nil {\n\t\treturn nil, fmt.Errorf(\"criteria cannot be nil\")\n\t}\n\n\tcurrencyDB := &Currency{}\n\tqueryParams := make(map[string]interface{})\n\n\tif criteria.Location != \"\" {\n\t\tqueryParams[\"LocationCode\"] = criteria.Location\n\t} else if !criteria.StartDate.IsZero() && !criteria.EndDate.IsZero() {\n\t\tqueryParams[\"DateRange\"] = []string{criteria.StartDate.Format(\"2006-01-02\"), criteria.EndDate.Format(\"2006-01-02\")}\n\t} else if criteria.MinRate > 0 {\n\t\tqueryParams[\"RateThreshold\"] = criteria.MinRate\n\t} else {\n\t\treturn nil, fmt.Errorf(\"no valid query criteria provided\")\n\t}\n\n\texchangeRates, err := currencyDB.FetchCurrencyRates(queryParams)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to fetch currency rates: %v\", err)\n\t}\n\n\tif len(exchangeRates) == 0 {\n\t\treturn nil, fmt.Errorf(\"no rates found for given criteria\")\n\t}\n\n\treturn exchangeRates, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "查询指定LocationCode的记录",
            "sql": "SELECT id, currency_type, location_code, conversion_rate, effective_date, status FROM investment_portfolios WHERE location_code = ? AND status = ? ORDER BY effective_date DESC;"
          },
          {
            "scenario": "查询指定DateRange的记录",
            "sql": "SELECT id, currency_type, location_code, conversion_rate, effective_date, status FROM investment_portfolios WHERE effective_date BETWEEN ? AND ? GROUP BY currency_type;"
          },
          {
            "scenario": "查询超过RateThreshold的记录",
            "sql": "SELECT id, currency_type, location_code, conversion_rate, effective_date, status FROM investment_portfolios WHERE conversion_rate > ? LIMIT 100;"
          },
          {
            "scenario": "使用通用filter查询记录",
            "sql": "SELECT id, currency_type, location_code, conversion_rate, effective_date, status FROM investment_portfolios WHERE location_code = ? AND status = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "ExchangeRate",
        "code_value": "type ExchangeRate struct {\n\tID            int       `json:\"id\" gorm:\"column:id\"`\n\tCurrencyType  string    `json:\"currency_type\" gorm:\"column:currency_type\"`\n\tLocationCode  string    `json:\"location_code\" gorm:\"column:location_code\"`\n\tConversionRate float64   `json:\"conversion_rate\" gorm:\"column:conversion_rate\"`\n\tEffectiveDate time.Time `json:\"effective_date\" gorm:\"column:effective_date\"`\n\tStatus        string    `json:\"status\" gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "CurrencyFilter",
        "code_value": "type CurrencyFilter struct {\n\tLocationCode  interface{} `json:\"LocationCode\"`\n\tDateRange     interface{} `json:\"DateRange\"`\n\tRateThreshold interface{} `json:\"RateThreshold\"`\n}"
      },
      {
        "code_key": "TableInvestmentPortfolios",
        "code_value": "const TableInvestmentPortfolios = \"investment_portfolios\""
      },
      {
        "code_key": "StatusActive",
        "code_value": "const StatusActive = \"active\""
      },
      {
        "code_key": "DefaultRateLimit",
        "code_value": "const DefaultRateLimit = 100"
      },
      {
        "code_key": "CurrencyErrorMessages",
        "code_value": "var CurrencyErrorMessages = map[string]string{\n\t\"NotFound\": \"no matching currency rates found\",\n\t\"InvalidFilter\": \"invalid filter parameters provided\"\n}"
      }
    ],
    "sql_pattern_cnt": 4
  },
  {
    "function_name": "ScaleCapacity",
    "orm_code": "func (v *Vehicle) ScaleCapacity(filters map[string]interface{}) ([]types.VehicleCapacity, error) {\n\tcapacities := make([]types.VehicleCapacity, 0)\n\tdb := base.GetInstance().GormDriver().Table(\"package_tracking\")\n\n\tif floor, ok := filters[\"Floor\"]; ok {\n\t\tdb = db.Where(\"floor = ? AND available = ?\", floor.(int), true)\n\t} else if shipmentId, ok := filters[\"ShipmentId\"]; ok {\n\t\tdb = db.Where(\"shipment_id LIKE ?\", \"%\"+shipmentId.(string)+\"%\").Order(\"created_at DESC\")\n\t} else if deliveryCode, ok := filters[\"DeliveryCode\"]; ok {\n\t\tfilter := map[string]interface{}{\n\t\t\t\"delivery_code\": deliveryCode,\n\t\t\t\"status\":         \"active\",\n\t\t}\n\t\tdb = db.Where(filter).Limit(100)\n\t} else {\n\t\tdb = db.Where(filters).Order(\"id ASC\")\n\t}\n\n\terr := db.Find(&capacities).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn capacities, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "filters contains Floor key",
            "sql": "SELECT id, shipment_id, delivery_code, floor, available, status, created_at, updated_at FROM package_tracking WHERE floor = ? AND available = ?;"
          },
          {
            "scenario": "filters contains ShipmentId key",
            "sql": "SELECT id, shipment_id, delivery_code, floor, available, status, created_at, updated_at FROM package_tracking WHERE shipment_id LIKE ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "filters contains DeliveryCode key",
            "sql": "SELECT id, shipment_id, delivery_code, floor, available, status, created_at, updated_at FROM package_tracking WHERE delivery_code = ? AND status = ? LIMIT 100;"
          },
          {
            "scenario": "filters without special keys",
            "sql": "SELECT id, shipment_id, delivery_code, floor, available, status, created_at, updated_at FROM package_tracking WHERE status = ? ORDER BY id ASC;"
          },
          {
            "scenario": "filters without special keys with multiple conditions",
            "sql": "SELECT id, shipment_id, delivery_code, floor, available, status, created_at, updated_at FROM package_tracking WHERE available = ? AND status = ? ORDER BY id ASC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "VehicleCapacity",
        "code_value": "type VehicleCapacity struct {\n\tID           int       `json:\"id\" gorm:\"column:id\"`\n\tShipmentId   string    `json:\"shipment_id\" gorm:\"column:shipment_id\"`\n\tDeliveryCode string    `json:\"delivery_code\" gorm:\"column:delivery_code\"`\n\tFloor        int       `json:\"floor\" gorm:\"column:floor\"`\n\tAvailable    bool      `json:\"available\" gorm:\"column:available\"`\n\tStatus       string    `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt    time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt    time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "CapacityStatus",
        "code_value": "const (\n\tCapacityStatusActive   = \"active\"\n\tCapacityStatusInactive = \"inactive\"\n\tCapacityStatusPending  = \"pending\"\n)"
      },
      {
        "code_key": "VehicleFilter",
        "code_value": "type VehicleFilter struct {\n\tFloor        *int\n\tShipmentId   *string\n\tDeliveryCode *string\n\tStatus       *string\n}"
      },
      {
        "code_key": "PackageTrackingTable",
        "code_value": "const PackageTrackingTable = \"package_tracking\""
      },
      {
        "code_key": "DefaultCapacityLimit",
        "code_value": "var DefaultCapacityLimit = 100"
      }
    ],
    "sql_pattern_cnt": 4
  },
  {
    "function_name": "ScaleCapacity",
    "orm_code": "func (v *Vehicle) ScaleCapacity(filters map[string]interface{}) ([]types.VehicleCapacity, error) {\n\tcapacities := make([]types.VehicleCapacity, 0)\n\tdb := base.GetInstance().GormDriver().Table(\"package_tracking\")\n\n\tif floor, ok := filters[\"Floor\"]; ok {\n\t\tdb = db.Where(\"floor = ? AND available = ?\", floor.(int), true)\n\t} else if shipmentId, ok := filters[\"ShipmentId\"]; ok {\n\t\tdb = db.Where(\"shipment_id LIKE ?\", \"%\"+shipmentId.(string)+\"%\").Order(\"created_at DESC\")\n\t} else if deliveryCode, ok := filters[\"DeliveryCode\"]; ok {\n\t\tfilter := map[string]interface{}{\n\t\t\t\"delivery_code\": deliveryCode,\n\t\t\t\"status\":         \"active\",\n\t\t}\n\t\tdb = db.Where(filter).Limit(100)\n\t} else {\n\t\tdb = db.Where(filters).Order(\"id ASC\")\n\t}\n\n\terr := db.Find(&capacities).Error\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn capacities, nil\n}",
    "caller": "func (h *CapacityHandler) HandleCapacity(req *types.CapacityRequest) ([]types.VehicleCapacity, error) {\n\tif req == nil {\n\t\treturn nil, errors.New(\"invalid request\")\n\t}\n\n\tvehicle := &Vehicle{}\n\tfilters := make(map[string]interface{})\n\n\tswitch {\n\tcase req.Floor > 0:\n\t\tfilters[\"Floor\"] = req.Floor\n\tcase req.ShipmentID != \"\":\n\t\tfilters[\"ShipmentId\"] = req.ShipmentID\n\tcase req.DeliveryCode != \"\":\n\t\tfilters[\"DeliveryCode\"] = req.DeliveryCode\n\tdefault:\n\t\tfilters[\"region\"] = req.Region\n\t\tfilters[\"vehicle_type\"] = req.VehicleType\n\t}\n\n\tcapacities, err := vehicle.ScaleCapacity(filters)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get capacities: %v\", err)\n\t}\n\treturn capacities, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Floor参数有效 (req.Floor > 0)",
            "sql": "SELECT id, shipment_id, delivery_code, floor, available, status, created_at, updated_at FROM package_tracking WHERE floor = ? AND available = true;"
          },
          {
            "scenario": "ShipmentID参数有效 (req.ShipmentID != \"\")",
            "sql": "SELECT id, shipment_id, delivery_code, floor, available, status, created_at, updated_at FROM package_tracking WHERE shipment_id LIKE ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "DeliveryCode参数有效 (req.DeliveryCode != \"\")",
            "sql": "SELECT id, shipment_id, delivery_code, floor, available, status, created_at, updated_at FROM package_tracking WHERE delivery_code = ? AND status = 'active' LIMIT 100;"
          },
          {
            "scenario": "默认情况 (region和vehicle_type参数)",
            "sql": "SELECT id, shipment_id, delivery_code, floor, available, status, created_at, updated_at FROM package_tracking WHERE region = ? AND vehicle_type = ? ORDER BY id ASC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "VehicleCapacity",
        "code_value": "type VehicleCapacity struct {\n\tID           int       `json:\"id\" gorm:\"column:id\"`\n\tShipmentId   string    `json:\"shipment_id\" gorm:\"column:shipment_id\"`\n\tDeliveryCode string    `json:\"delivery_code\" gorm:\"column:delivery_code\"`\n\tFloor        int       `json:\"floor\" gorm:\"column:floor\"`\n\tAvailable    bool      `json:\"available\" gorm:\"column:available\"`\n\tStatus       string    `json:\"status\" gorm:\"column:status\"`\n\tCreatedAt    time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n\tUpdatedAt    time.Time `json:\"updated_at\" gorm:\"column:updated_at\"`\n}"
      },
      {
        "code_key": "CapacityStatus",
        "code_value": "const (\n\tCapacityStatusActive   = \"active\"\n\tCapacityStatusInactive = \"inactive\"\n\tCapacityStatusPending  = \"pending\"\n)"
      },
      {
        "code_key": "VehicleFilter",
        "code_value": "type VehicleFilter struct {\n\tFloor        *int\n\tShipmentId   *string\n\tDeliveryCode *string\n\tStatus       *string\n}"
      },
      {
        "code_key": "PackageTrackingTable",
        "code_value": "const PackageTrackingTable = \"package_tracking\""
      },
      {
        "code_key": "DefaultCapacityLimit",
        "code_value": "var DefaultCapacityLimit = 100"
      }
    ],
    "sql_pattern_cnt": 4
  }
]