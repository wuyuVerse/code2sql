{
  "synthetic_对象const_chunk_ApproveRequest": {
    "scenario": "对象const+chunk",
    "code_key": "ApproveRequest",
    "code_value": "func (repo *RouteRepo) ApproveRequest(ctx context.Context, claim *model.Claim) error {\n\tcheckClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\texisting := &model.Claim{}\n\n\tif err := repo.db.Clauses(checkClause).Table(model.ClaimTableName).\n\t\tWhere(\"work_address = ? AND zip_code = ?\", claim.WorkAddress, claim.ZipCode).\n\t\tFirst(existing).Error; err != nil {\n\t\t\treturn err\n\t}\n\n\tif existing.State != claim.State {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.ClaimTableName).\n\t\t\tWhere(\"id = ?\", existing.Id).\n\t\t\tUpdate(\"state\", claim.State).Error; err != nil {\n\t\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "sql_pattern_cnt": 2,
    "callers": [
      {
        "code_key": "HandleMaintenanceApproval",
        "code_value": "func HandleMaintenanceApproval(db *gorm.DB, address string, zip string) error {\n\tctx := context.Background()\n\trepo := &RouteRepo{db: db}\n\tclaim := &model.Claim{\n\t\tWorkAddress: address,\n\t\tZipCode:     zip,\n\t\tState:       2, // approved state\n\t}\n\n\tif err := repo.ApproveRequest(ctx, claim); err != nil {\n\t\treturn fmt.Errorf(\"approval failed: %v\", err)\n\t}\n\treturn nil\n}"
      },
      {
        "code_key": "ProcessFacilityClaims",
        "code_value": "func ProcessFacilityClaims(db *gorm.DB) error {\n\tctx := context.Background()\n\trepo := &RouteRepo{db: db}\n\n\t// Sample claim data for processing\n\tfacilityClaim := &model.Claim{\n\t\tWorkAddress: \"123 Industrial Park\",\n\t\tZipCode:     \"90210\",\n\t\tState:       3, // processed state\n\t}\n\n\tif err := repo.ApproveRequest(ctx, facilityClaim); err != nil {\n\t\treturn fmt.Errorf(\"could not process facility claim: %v\", err)\n\t}\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "RouteRepo",
        "code_value": "type RouteRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Claim",
        "code_value": "type Claim struct {\n\tId          int64  `gorm:\"column:id\"`\n\tWorkAddress string `gorm:\"column:work_address\"`\n\tZipCode     string `gorm:\"column:zip_code\"`\n\tState       int    `gorm:\"column:state\"`\n}"
      },
      {
        "code_key": "ClaimTableName",
        "code_value": "const ClaimTableName = \"maintenance_logs\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-event-alarm/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) hints.Hints {\n\tcommentInfo := icontext.GetSQLCommentFromContext(ctx)\n\tif len(commentInfo.ReqId) < 16 {\n\t\tcommentInfo.ReqId = uuid.NewString()\n\t}\n\n\tcomment := fmt.Sprintf(\"p=%v,a=%v,o=%v,s=%v,f=%v,i=%v\", ProductName,\n\t\tcommentInfo.AppId, commentInfo.OwnerUin, commentInfo.SubUin, commentInfo.Action, commentInfo.ReqId)\n\treturn hints.CommentBefore(clause, comment)\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"select\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"update\""
      }
    ]
  },
  "synthetic_对象const_chunk_ValidatePermissions": {
    "scenario": "对象const+chunk",
    "code_key": "ValidatePermissions",
    "code_value": "func (repo *PhotoRepo) ValidatePermissions(ctx context.Context, photo *model.Photo) (bool, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\ttarget := &model.Photo{}\n\n\terr := repo.db.Clauses(queryClause).Table(model.PhotoTableName).\n\t\tWhere(\"territory = ? AND gross_value > ?\", photo.Territory, photo.GrossValue).\n\t\tFirst(target).Error\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif target.Limit < photo.Limit {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandlePhotoUpload",
        "code_value": "func HandlePhotoUpload(ctx context.Context, dbConn *gorm.DB, region string, valueThreshold int) error {\n\tphotoStorage := &PhotoRepo{db: dbConn}\n\tphotoData := &model.Photo{\n\t\tTerritory:  region,\n\t\tGrossValue: valueThreshold,\n\t\tLimit:      1000,\n\t}\n\n\tisValid, err := photoStorage.ValidatePermissions(ctx, photoData)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"permission validation failed: %v\", err)\n\t}\n\tif !isValid {\n\t\treturn errors.New(\"photo doesn't meet requirements\")\n\t}\n\treturn nil\n}"
      },
      {
        "code_key": "CheckMediaEligibility",
        "code_value": "func CheckMediaEligibility(ctx context.Context, gormDB *gorm.DB, countryCode string, minValue int) (bool, error) {\n\tmediaRepo := PhotoRepo{db: gormDB}\n\tmediaItem := model.Photo{\n\t\tTerritory:  countryCode,\n\t\tGrossValue: minValue,\n\t\tLimit:      500,\n\t}\n\n\tapproved, checkErr := mediaRepo.ValidatePermissions(ctx, &mediaItem)\n\tif checkErr != nil {\n\t\treturn false, fmt.Errorf(\"eligibility check error: %w\", checkErr)\n\t}\n\treturn approved, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "PortfolioRepo",
        "code_value": "type PortfolioRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "PortfolioTableName",
        "code_value": "const PortfolioTableName = \"user_portfolios\""
      },
      {
        "code_key": "Portfolio",
        "code_value": "type Portfolio struct {\n\tID          int64   `gorm:\"column:id\" json:\"id\"`\n\tUserID      int64   `gorm:\"column:user_id\" json:\"user_id\"`\n\tAssetType   string  `gorm:\"column:asset_type\" json:\"asset_type\"`\n\tAmount      float64 `gorm:\"column:amount\" json:\"amount\"`\n\tRiskLevel   int     `gorm:\"column:risk_level\" json:\"risk_level\"`\n\tCreatedTime int64   `gorm:\"column:created_time\" json:\"created_time\"`\n}"
      },
      {
        "code_key": "AppointmentRepo",
        "code_value": "type AppointmentRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "AppointmentTableName",
        "code_value": "const AppointmentTableName = \"client_appointments\""
      },
      {
        "code_key": "Appointment",
        "code_value": "type Appointment struct {\n\tID         int64  `gorm:\"column:id\" json:\"id\"`\n\tClientID   int64  `gorm:\"column:client_id\" json:\"client_id\"`\n\tAdvisorID  int64  `gorm:\"column:advisor_id\" json:\"advisor_id\"`\n\tStartTime  int64  `gorm:\"column:start_time\" json:\"start_time\"`\n\tEndTime    int64  `gorm:\"column:end_time\" json:\"end_time\"`\n\tStatus     string `gorm:\"column:status\" json:\"status\"`\n\tNotes      string `gorm:\"column:notes\" json:\"notes\"`\n}"
      },
      {
        "code_key": "MaxRiskLevel",
        "code_value": "const MaxRiskLevel = 5"
      },
      {
        "code_key": "DefaultAppointmentStatus",
        "code_value": "const DefaultAppointmentStatus = \"scheduled\""
      },
      {
        "code_key": "PortfolioQueryClause",
        "code_value": "utils.SetSQLComment(ctx, utils.QueryKey)"
      },
      {
        "code_key": "AppointmentQueryClause",
        "code_value": "utils.SetSQLComment(ctx, utils.QueryKey)"
      }
    ]
  },
  "synthetic_对象const_chunk_MergeRecords": {
    "scenario": "对象const+chunk",
    "code_key": "MergeRecords",
    "code_value": "func (repo *CurriculumRepo) MergeRecords(ctx context.Context, record *model.ContentArchive) error {\n    selectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n    updateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n    existing := &model.ContentArchive{}\n\n    if err := repo.db.Clauses(selectClause).Table(model.ContentArchiveTableName).\n        Where(\"location_code = ? AND classification_level = ?\", record.LocationCode, record.ClassificationLevel).\n        First(existing).Error; err != nil {\n        if errors.Is(err, gorm.ErrRecordNotFound) {\n            return repo.db.Table(model.ContentArchiveTableName).Create(record).Error\n        }\n        return err\n    }\n\n    if existing.UnitPrice != record.UnitPrice {\n        return repo.db.Clauses(updateClause).Table(model.ContentArchiveTableName).\n            Where(\"id = ?\", existing.Id).\n            Update(\"unit_price\", record.UnitPrice).Error\n    }\n    return nil\n}",
    "sql_pattern_cnt": 3,
    "callers": [
      {
        "code_key": "HandlePriceUpdate",
        "code_value": "func HandlePriceUpdate(ctx context.Context, location string, level int, newPrice float64) error {\n\tcurriculumRepo := &CurriculumRepo{db: globalDB}\n\tarchiveEntry := &model.ContentArchive{\n\t\tLocationCode:          location,\n\t\tClassificationLevel:   level,\n\t\tUnitPrice:            newPrice\n\t}\n\tif err := curriculumRepo.MergeRecords(ctx, archiveEntry); err != nil {\n\t\tlog.Printf(\"Failed to update price for %s level %d: %v\", location, level, err)\n\t\treturn err\n\t}\n\treturn nil\n}"
      },
      {
        "code_key": "SyncCurriculumPrices",
        "code_value": "func SyncCurriculumPrices(ctx context.Context, priceUpdates []model.PriceChange) error {\n\trepo := NewCurriculumRepo(GetDB())\n\tfor _, update := range priceUpdates {\n\t\tarchive := &model.ContentArchive{\n\t\t\tLocationCode:         update.RegionCode,\n\t\t\tClassificationLevel:  update.Grade,\n\t\t\tUnitPrice:           update.NewAmount\n\t\t}\n\t\tif err := repo.MergeRecords(ctx, archive); err != nil {\n\t\t\treturn fmt.Errorf(\"price sync failed for %s: %w\", update.RegionCode, err)\n\t\t}\n\t}\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "ContentArchive",
        "code_value": "type ContentArchive struct {\n\tId                   int64   `gorm:\"column:id\" json:\"id\"`\n\tLocationCode         string  `gorm:\"column:location_code\" json:\"location_code\"`\n\tClassificationLevel  int     `gorm:\"column:classification_level\" json:\"classification_level\"`\n\tUnitPrice            float64 `gorm:\"column:unit_price\" json:\"unit_price\"`\n}"
      },
      {
        "code_key": "ContentArchiveTableName",
        "code_value": "const ContentArchiveTableName = \"content_archive\""
      },
      {
        "code_key": "CurriculumRepo",
        "code_value": "type CurriculumRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "selectClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SelectKey)"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-content-management/pkg/utils"
      },
      {
        "code_key": "PriceHistory",
        "code_value": "type PriceHistory struct {\n\tId          int64   `gorm:\"column:id\" json:\"id\"`\n\tArchiveId   int64   `gorm:\"column:archive_id\" json:\"archive_id\"`\n\tOldPrice    float64 `gorm:\"column:old_price\" json:\"old_price\"`\n\tNewPrice    float64 `gorm:\"column:new_price\" json:\"new_price\"`\n\tUpdatedAt   int64   `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "PriceHistoryTableName",
        "code_value": "const PriceHistoryTableName = \"price_history\""
      }
    ]
  },
  "synthetic_对象const_chunk_MonitorHealth": {
    "scenario": "对象const+chunk",
    "code_key": "MonitorHealth",
    "code_value": "func (repo *HealthRepo) MonitorHealth(ctx context.Context, check *model.HealthCheck) error {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tinsertClause := utils.SetSQLComment(ctx, utils.InsertKey)\n\tlastCheck := &model.HealthCheck{}\n\n\tif err := repo.db.Clauses(selectClause).Table(model.HealthCheckTableName).\n\t\tWhere(\"node_id = ?\", check.NodeId).\n\t\tLast(lastCheck).\n\t\tError; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\tif err = repo.db.Clauses(insertClause).Table(model.HealthCheckTableName).\n\t\t\t\tCreate(check).Error; err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif lastCheck.Dimension != check.Dimension {\n\t\tif err := repo.db.Clauses(insertClause).Table(model.HealthCheckTableName).\n\t\t\tCreate(check).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "sql_pattern_cnt": 2,
    "callers": [
      {
        "code_key": "HandleClusterHealthCheck",
        "code_value": "func HandleClusterHealthCheck(ctx context.Context, nodeID string, dimension string, logger *zap.Logger) error {\n\thealthRepo := &HealthRepo{db: globalDB}\n\tcheck := &model.HealthCheck{\n\t\tNodeId:    nodeID,\n\t\tDimension: dimension,\n\t\tTimestamp: time.Now().Unix(),\n\t}\n\n\tif err := healthRepo.MonitorHealth(ctx, check); err != nil {\n\t\tlogger.Error(\"Failed to monitor cluster health\", zap.String(\"nodeID\", nodeID), zap.Error(err))\n\t\treturn fmt.Errorf(\"health check failed for node %s: %v\", nodeID, err)\n\t}\n\treturn nil\n}"
      },
      {
        "code_key": "ProcessNodeHealthStatus",
        "code_value": "func ProcessNodeHealthStatus(ctx context.Context, nodes []*model.ClusterNode) error {\n\thealthRepo := &HealthRepo{db: database.GetInstance()}\n\tfor _, node := range nodes {\n\t\tif node == nil {\n\t\t\tcontinue\n\t\t}\n\t\tcheck := &model.HealthCheck{\n\t\t\tNodeId:    node.ID,\n\t\t\tDimension: node.HealthDimension,\n\t\t\tTimestamp: time.Now().Unix(),\n\t\t}\n\t\tif err := healthRepo.MonitorHealth(ctx, check); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to process health status for node %s: %v\", node.ID, err)\n\t\t}\n\t}\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "HealthRepo",
        "code_value": "type HealthRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "HealthCheck",
        "code_value": "type HealthCheck struct {\n\tID        int64  `gorm:\"column:id\" json:\"id\"`\n\tNodeId    string `gorm:\"column:node_id\" json:\"node_id\"`\n\tDimension int    `gorm:\"column:dimension\" json:\"dimension\"`\n\tStatus    string `gorm:\"column:status\" json:\"status\"`\n\tTimestamp int64  `gorm:\"column:timestamp\" json:\"timestamp\"`\n}"
      },
      {
        "code_key": "HealthCheckTableName",
        "code_value": "const HealthCheckTableName = \"system_health_checks\""
      },
      {
        "code_key": "HealthStatus",
        "code_value": "type HealthStatus string\n\nconst (\n\tStatusHealthy   HealthStatus = \"HEALTHY\"\n\tStatusDegraded  HealthStatus = \"DEGRADED\"\n\tStatusCritical  HealthStatus = \"CRITICAL\"\n\tStatusUnknown   HealthStatus = \"UNKNOWN\"\n)"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "NodeRole",
        "code_value": "type NodeRole string\n\nconst (\n\tRoleMaster NodeRole = \"MASTER\"\n\tRoleWorker NodeRole = \"WORKER\"\n\tRoleProxy  NodeRole = \"PROXY\"\n)"
      },
      {
        "code_key": "HealthDimension",
        "code_value": "type HealthDimension int\n\nconst (\n\tDimensionCPU     HealthDimension = 1\n\tDimensionMemory  HealthDimension = 2\n\tDimensionDisk    HealthDimension = 3\n\tDimensionNetwork HealthDimension = 4\n)"
      },
      {
        "code_key": "HealthThreshold",
        "code_value": "var HealthThreshold = map[HealthDimension]float64{\n\tDimensionCPU:     0.8,\n\tDimensionMemory:  0.85,\n\tDimensionDisk:    0.9,\n\tDimensionNetwork: 0.7,\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (hc *HealthCheck) TableName() string {\n\treturn HealthCheckTableName\n}"
      }
    ]
  },
  "synthetic_对象const_chunk_AggregateByType": {
    "scenario": "对象const+chunk",
    "code_key": "AggregateByType",
    "code_value": "func (repo *RecommendationRepo) AggregateByType(ctx context.Context, categoryType int) ([]model.Recommendation, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tvar results []model.Recommendation\n\n\tif err := repo.db.Clauses(queryClause).Table(model.RecommendationTableName).\n\t\tWhere(\"category_type = ?\", categoryType).\n\t\tGroup(\"language\").\n\t\tSelect(\"language, sum(points) as points\").\n\t\tFind(&results).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn results, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleLanguagePoints",
        "code_value": "func HandleLanguagePoints(ctx context.Context, typeID int, logger *zap.Logger) (map[string]int, error) {\n\trepo := &RecommendationRepo{db: globalDB}\n\trecs, err := repo.AggregateByType(ctx, typeID)\n\tif err != nil {\n\t\tlogger.Error(\"failed to aggregate language points\", zap.Error(err))\n\t\treturn nil, err\n\t}\n\n\tpointMap := make(map[string]int)\n\tfor _, r := range recs {\n\t\tpointMap[r.Language] = r.Points\n\t}\n\treturn pointMap, nil\n}"
      },
      {
        "code_key": "ProcessContentRecommendations",
        "code_value": "func ProcessContentRecommendations(ctx context.Context, contentType int) ([]model.Recommendation, error) {\n\trecommendationDB := initializeDB()\n\trepo := &RecommendationRepo{db: recommendationDB}\n\n\tresults, err := repo.AggregateByType(ctx, contentType)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"content processing failed: %w\", err)\n\t}\n\n\tif len(results) == 0 {\n\t\treturn nil, errors.New(\"no recommendations found\")\n\t}\n\treturn results, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "RecommendationRepo",
        "code_value": "type RecommendationRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "RecommendationTableName",
        "code_value": "const RecommendationTableName = \"ivc_recommendation\""
      },
      {
        "code_key": "Recommendation",
        "code_value": "type Recommendation struct {\n\tId          int64  `gorm:\"column:id\" json:\"id\"`\n\tCategoryType int    `gorm:\"column:category_type\" json:\"category_type\"`\n\tLanguage    string `gorm:\"column:language\" json:\"language\"`\n\tPoints      int64  `gorm:\"column:points\" json:\"points\"`\n\tCreatedAt   int64  `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (r *Recommendation) TableName() string {\n\treturn RecommendationTableName\n}"
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"query\""
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"select\""
      },
      {
        "code_key": "hints",
        "code_value": "git.woa.com/IVC/ivc-event-alarm/pkg/hints"
      },
      {
        "code_key": "icontext",
        "code_value": "git.woa.com/IVC/ivc-event-alarm/pkg/icontext"
      },
      {
        "code_key": "ProductName",
        "code_value": "const ProductName = \"recommendation_service\""
      }
    ]
  },
  "synthetic_对象const_chunk_RestoreFromBackup": {
    "scenario": "对象const+chunk",
    "code_key": "RestoreFromBackup",
    "code_value": "func (repo *WeaponRepo) RestoreFromBackup(ctx context.Context, item *model.Weapon) error {\n\tsaveClause := utils.SetSQLComment(ctx, utils.SaveKey)\n\tbackup := &model.Weapon{}\n\n\tif err := repo.db.Table(model.WeaponBackupTableName).\n\t\tWhere(\"security_level = ? AND genre = ?\", item.SecurityLevel, item.Genre).\n\t\tFirst(backup).Error; err != nil {\n\t\treturn fmt.Errorf(\"backup not found: %v\", err)\n\t}\n\n\tif err := repo.db.Clauses(saveClause).Table(model.WeaponTableName).\n\t\tWhere(\"id = ?\", item.Id).\n\t\tUpdates(map[string]interface{}{\n\t\t\t\"building\":       backup.Building,\n\t\t\t\"security_level\": backup.SecurityLevel,\n\t\t\t\"genre\":          backup.Genre,\n\t\t}).Error; err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
    "sql_pattern_cnt": 2,
    "callers": [
      {
        "code_key": "HandleWeaponRecovery",
        "code_value": "func HandleWeaponRecovery(ctx context.Context, weaponID string, securityLevel int, genre string, log *zap.Logger) error {\n\tweaponRepo := &WeaponRepo{db: GetDB()}\n\tweapon := &model.Weapon{\n\t\tId:            weaponID,\n\t\tSecurityLevel: securityLevel,\n\t\tGenre:         genre,\n\t}\n\n\tif err := weaponRepo.RestoreFromBackup(ctx, weapon); err != nil {\n\t\tlog.Error(\"failed to restore weapon from backup\", zap.Error(err))\n\t\treturn fmt.Errorf(\"weapon recovery failed: %v\", err)\n\t}\n\tlog.Info(\"weapon restored successfully\", zap.String(\"weaponID\", weaponID))\n\treturn nil\n}"
      },
      {
        "code_key": "ProcessWeaponRestoration",
        "code_value": "func ProcessWeaponRestoration(ctx context.Context, weaponData *model.Weapon, dbConn *gorm.DB) (bool, error) {\n\trepo := WeaponRepo{db: dbConn}\n\n\terr := repo.RestoreFromBackup(ctx, weaponData)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"restoration process failed: %v\", err)\n\t}\n\n\treturn true, nil\n}"
      },
      {
        "code_key": "RecoverWeaponByCriteria",
        "code_value": "func RecoverWeaponByCriteria(ctx context.Context, criteria map[string]interface{}) error {\n\tweapon := &model.Weapon{\n\t\tSecurityLevel: criteria[\"security_level\"].(int),\n\t\tGenre:        criteria[\"genre\"].(string),\n\t}\n\n\trepo := NewWeaponRepository()\n\tif err := repo.RestoreFromBackup(ctx, weapon); err != nil {\n\t\treturn fmt.Errorf(\"could not recover weapon: %v\", err)\n\t}\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "WeaponRepo",
        "code_value": "type WeaponRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Weapon",
        "code_value": "type Weapon struct {\n\tId            int64  `gorm:\"column:id\" json:\"id\"`\n\tBuilding      string `gorm:\"column:building\" json:\"building\"`\n\tSecurityLevel int    `gorm:\"column:security_level\" json:\"security_level\"`\n\tGenre         string `gorm:\"column:genre\" json:\"genre\"`\n}"
      },
      {
        "code_key": "WeaponTableName",
        "code_value": "const WeaponTableName = \"armory_weapons\""
      },
      {
        "code_key": "WeaponBackupTableName",
        "code_value": "const WeaponBackupTableName = \"armory_weapons_backup\""
      },
      {
        "code_key": "saveClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SaveKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/armory/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Interface {\n\tcomment := icontext.GetCommentFromContext(ctx)\n\tif comment == \"\" {\n\t\tcomment = \"default_operation\"\n\t}\n\treturn clause.Comment(comment)\n}"
      },
      {
        "code_key": "backupWeapon",
        "code_value": "&model.Weapon{}"
      }
    ]
  },
  "synthetic_对象const_chunk_FetchWithFilter": {
    "scenario": "对象const+chunk",
    "code_key": "FetchWithFilter",
    "code_value": "func (repo *ClientRepo) FetchWithFilter(ctx context.Context, projectCode string) ([]*model.Client, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tvar clients []*model.Client\n\n\tif err := repo.db.Clauses(queryClause).Table(model.ClientTableName).\n\t\tWhere(\"project_code = ?\", projectCode).\n\t\tWhere(\"status = ?\", model.ClientStatusActive).\n\t\tFind(&clients).Error; err != nil {\n\t\t\treturn nil, err\n\t}\n\n\treturn clients, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleActiveClients",
        "code_value": "func HandleActiveClients(ctx context.Context, projectIdentifier string, logger *zap.Logger) ([]*model.Client, error) {\n\tclientStorage := &ClientRepo{db: database.GetDB()}\n\tactiveClients, err := clientStorage.FetchWithFilter(ctx, projectIdentifier)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to fetch active clients\", zap.String(\"project\", projectIdentifier), zap.Error(err))\n\t\treturn nil, fmt.Errorf(\"failed to fetch active clients: %w\", err)\n\t}\n\treturn activeClients, nil\n}"
      },
      {
        "code_key": "ProcessProjectClients",
        "code_value": "func ProcessProjectClients(ctx context.Context, projectList []string) (map[string][]*model.Client, error) {\n\tresult := make(map[string][]*model.Client)\n\trepository := &ClientRepo{db: config.GetDatabaseConnection()}\n\n\tfor _, projCode := range projectList {\n\t\tclients, err := repository.FetchWithFilter(ctx, projCode)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to process project %s: %w\", projCode, err)\n\t\t}\n\t\tresult[projCode] = clients\n\t}\n\n\treturn result, nil\n}"
      },
      {
        "code_key": "SyncClientData",
        "code_value": "func SyncClientData(ctx context.Context, targetProject string, cacheClient cache.Provider) error {\n\tdbHandler := &ClientRepo{db: global.DBInstance}\n\tfilteredClients, err := dbHandler.FetchWithFilter(ctx, targetProject)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"database fetch failed: %w\", err)\n\t}\n\n\tcacheKey := fmt.Sprintf(\"active_clients:%s\", targetProject)\n\tif err := cacheClient.Set(ctx, cacheKey, filteredClients, 24*time.Hour); err != nil {\n\t\treturn fmt.Errorf(\"cache update failed: %w\", err)\n\t}\n\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "ProjectLevelRepo",
        "code_value": "type ProjectLevelRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ProjectManifestTableName",
        "code_value": "const ProjectManifestTableName = \"project_manifests\""
      },
      {
        "code_key": "ProjectStatusActive",
        "code_value": "const ProjectStatusActive = 2"
      },
      {
        "code_key": "ProjectManifest",
        "code_value": "type ProjectManifest struct {\n\tID          int64  `gorm:\"column:id\" json:\"id\"`\n\tProjectCode string `gorm:\"column:project_code\" json:\"project_code\"`\n\tStatus      int    `gorm:\"column:status\" json:\"status\"`\n\tCategory    string `gorm:\"column:category\" json:\"category\"`\n\tCreatedAt   int64  `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "QueryBuilder",
        "code_value": "type QueryBuilder struct {\n\tClause string\n\tParams []interface{}\n}"
      },
      {
        "code_key": "DefaultQueryLimit",
        "code_value": "const DefaultQueryLimit = 100"
      },
      {
        "code_key": "ProjectCategoryTech",
        "code_value": "const ProjectCategoryTech = \"technology\""
      },
      {
        "code_key": "ProjectCategoryBusiness",
        "code_value": "const ProjectCategoryBusiness = \"business\""
      },
      {
        "code_key": "ManifestVersion",
        "code_value": "type ManifestVersion struct {\n\tMajor int `json:\"major\"`\n\tMinor int `json:\"minor\"`\n\tPatch int `json:\"patch\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (pm *ProjectManifest) TableName() string {\n\treturn ProjectManifestTableName\n}"
      }
    ]
  },
  "synthetic_对象const_chunk_RetrieveByDate": {
    "scenario": "对象const+chunk",
    "code_key": "RetrieveByDate",
    "code_value": "func (repo *TaskRepo) RetrieveByDate(ctx context.Context, startDate, endDate int64) ([]*model.Task, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\ttasks := make([]*model.Task, 0)\n\n\tif err := repo.db.Clauses(queryClause).Table(model.TaskTableName).\n\t\tWhere(\"created_at BETWEEN ? AND ?\", startDate, endDate).\n\t\tOrder(\"created_at DESC\").\n\t\tFind(&tasks).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn tasks, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleTaskReport",
        "code_value": "func HandleTaskReport(ctx context.Context, log *zap.Logger) error {\n\trepo := &TaskRepo{db: conf.GetDBEngine()}\n\tnow := time.Now().Unix()\n\tstartTime := now - 86400 // last 24 hours\n\n\ttasks, err := repo.RetrieveByDate(ctx, startTime, now)\n\tif err != nil {\n\t\tlog.Error(\"failed to retrieve tasks\", zap.Error(err))\n\t\treturn err\n\t}\n\n\tif len(tasks) == 0 {\n\t\tlog.Info(\"no tasks found in the given period\")\n\t\treturn nil\n\t}\n\n\t// Process tasks...\n\treturn nil\n}"
      },
      {
        "code_key": "HandleArchiveExpiredTasks",
        "code_value": "func HandleArchiveExpiredTasks(ctx context.Context, retentionDays int) (int, error) {\n\trepo := &TaskRepo{db: conf.GetDBEngine()}\n\tendTime := time.Now().AddDate(0, 0, -retentionDays).Unix()\n\n\texpiredTasks, err := repo.RetrieveByDate(ctx, 0, endTime)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to get expired tasks: %w\", err)\n\t}\n\n\t// Archive tasks...\n\treturn len(expiredTasks), nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "TaskRepo",
        "code_value": "type TaskRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Task",
        "code_value": "type Task struct {\n\tID        int64  `gorm:\"column:id\" json:\"id\"`\n\tName      string `gorm:\"column:name\" json:\"name\"`\n\tStatus    int    `gorm:\"column:status\" json:\"status\"`\n\tCreatedAt int64  `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt int64  `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "TaskTableName",
        "code_value": "const TaskTableName = \"user_tasks\""
      },
      {
        "code_key": "TaskStatusPending",
        "code_value": "const TaskStatusPending = 1"
      },
      {
        "code_key": "TaskStatusCompleted",
        "code_value": "const TaskStatusCompleted = 2"
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"SELECT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (t *Task) TableName() string {\n\treturn TaskTableName\n}"
      },
      {
        "code_key": "defaultTask",
        "code_value": "var defaultTask = &Task{Status: TaskStatusPending}"
      }
    ]
  },
  "synthetic_对象const_chunk_GroupByCategory": {
    "scenario": "对象const+chunk",
    "code_key": "GroupByCategory",
    "code_value": "func (repo *ScannerRepo) GroupByCategory(ctx context.Context, pattern string) (map[string][]*model.Publication, error) {\n\tcategoryClause := utils.SetSQLComment(ctx, utils.GroupKey)\n\tresults := make([]*model.Publication, 0)\n\tcategoryMap := make(map[string][]*model.Publication)\n\n\tif err := repo.db.Clauses(categoryClause).Table(model.PublicationTableName).\n\t\tWhere(\"unique_key LIKE ?\", pattern).\n\t\tFind(&results).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, pub := range results {\n\t\tcategoryMap[pub.RoleCode] = append(categoryMap[pub.RoleCode], pub)\n\t}\n\n\treturn categoryMap, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandlePublicationGrouping",
        "code_value": "func HandlePublicationGrouping(db *gorm.DB, ctx context.Context) (map[string][]*model.Publication, error) {\n\tscannerRepo := &ScannerRepo{db: db}\n\tpattern := \"user-%\"\n\t\n\tgroupedPubs, err := scannerRepo.GroupByCategory(ctx, pattern)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to group publications: %v\", err)\n\t}\n\t\n\treturn groupedPubs, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "PatientRepo",
        "code_value": "type PatientRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "MedicalRecordTableName",
        "code_value": "const MedicalRecordTableName = \"hospital_medical_records\""
      },
      {
        "code_key": "MedicalRecord",
        "code_value": "type MedicalRecord struct {\n\tRecordID    int64  `gorm:\"column:record_id\" json:\"record_id\"`\n\tPatientID   string `gorm:\"column:patient_id\" json:\"patient_id\"`\n\tDiagnosis   string `gorm:\"column:diagnosis\" json:\"diagnosis\"`\n\tDoctorID    string `gorm:\"column:doctor_id\" json:\"doctor_id\"`\n\tRecordDate  int64  `gorm:\"column:record_date\" json:\"record_date\"`\n\tIsCritical  bool   `gorm:\"column:is_critical\" json:\"is_critical\"`\n}"
      },
      {
        "code_key": "searchClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SearchKey)"
      },
      {
        "code_key": "medUtils",
        "code_value": "git.woa.com/Medical/health-record/pkg/medUtils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, operation string) hints.Hints {\n\tctxInfo := medcontext.GetMedContextFromContext(ctx)\n\tif len(ctxInfo.SessionID) < 10 {\n\t\tctxInfo.SessionID = uuid.New().String()[:8]\n\t}\n\n\tcomment := fmt.Sprintf(\"h=%v,d=%v,p=%v,s=%v\", HospitalID,\n\t\tctxInfo.Department, ctxInfo.PhysicianID, ctxInfo.SessionID)\n\treturn hints.CommentBefore(operation, comment)\n}"
      },
      {
        "code_key": "HospitalID",
        "code_value": "const HospitalID = \"GH12345\""
      },
      {
        "code_key": "PatientRecord",
        "code_value": "&model.MedicalRecord{}"
      },
      {
        "code_key": "CriticalStatus",
        "code_value": "const CriticalStatus = true"
      },
      {
        "code_key": "DepartmentCodes",
        "code_value": "var DepartmentCodes = map[string]int{\n\t\"Cardiology\":    1,\n\t\"Neurology\":     2,\n\t\"Orthopedics\":   3,\n\t\"Pediatrics\":    4,\n\t\"Dermatology\":   5\n}"
      }
    ]
  },
  "synthetic_对象const_chunk_HardDelete": {
    "scenario": "对象const+chunk",
    "code_key": "HardDelete",
    "code_value": "func (repo *TagRepo) HardDelete(ctx context.Context, tagID string) error {\n\tdeleteClause := utils.SetSQLComment(ctx, utils.DeleteKey)\n\n\tif err := repo.db.Clauses(deleteClause).Table(model.TagTableName).\n\t\tWhere(\"tag_id = ?\", tagID).\n\t\tDelete(&model.Tag{}).Error; err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleExpiredTags",
        "code_value": "func HandleExpiredTags(ctx context.Context, expiredTagIDs []string, logger *zap.Logger) error {\n\ttagRepo := NewTagRepo()\n\tfor _, id := range expiredTagIDs {\n\t\terr := tagRepo.HardDelete(ctx, id)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"failed to delete expired tag\", zap.String(\"tagID\", id), zap.Error(err))\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}"
      },
      {
        "code_key": "CleanupOrphanedTags",
        "code_value": "func CleanupOrphanedTags(ctx context.Context, dbClient *gorm.DB) error {\n\ttagRepo := &TagRepo{db: dbClient}\n\terr := tagRepo.HardDelete(ctx, \"orphaned_tag_123\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to cleanup orphaned tag: %v\", err)\n\t}\n\treturn nil\n}"
      },
      {
        "code_key": "ProcessTagRemovalRequest",
        "code_value": "func ProcessTagRemovalRequest(ctx context.Context, requestID string, tagService TagService) error {\n\ttagID := \"req_\" + requestID\n\tif err := tagService.GetRepo().HardDelete(ctx, tagID); err != nil {\n\t\treturn fmt.Errorf(\"tag removal failed for request %s: %v\", requestID, err)\n\t}\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "TagRepo",
        "code_value": "type TagRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "TagTableName",
        "code_value": "const TagTableName = \"inventory_tags\""
      },
      {
        "code_key": "Tag",
        "code_value": "type Tag struct {\n\tTagID      string `gorm:\"column:tag_id\" json:\"tag_id\"`\n\tLabel      string `gorm:\"column:label\" json:\"label\"`\n\tCategory   string `gorm:\"column:category\" json:\"category\"`\n\tStatus     int    `gorm:\"column:status\" json:\"status\"`\n\tCreatedAt  int64  `gorm:\"column:created_at\" json:\"created_at\"`\n\tModifiedAt int64  `gorm:\"column:modified_at\" json:\"modified_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (t *Tag) TableName() string {\n\treturn TagTableName\n}"
      },
      {
        "code_key": "DeleteKey",
        "code_value": "const DeleteKey = \"hard_delete\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/inventory-service/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) hints.Hints {\n\tcommentInfo := icontext.GetSQLCommentFromContext(ctx)\n\tif len(commentInfo.OperationID) < 12 {\n\t\tcommentInfo.OperationID = generateOpID()\n\t}\n\n\tcomment := fmt.Sprintf(\"svc=%v,op=%v,req=%v\", ServiceIdentifier,\n\t\tcommentInfo.OperationType, commentInfo.OperationID)\n\treturn hints.CommentBefore(clause, comment)\n}"
      }
    ]
  },
  "synthetic_对象const_chunk_CalculateByFormula": {
    "scenario": "对象const+chunk",
    "code_key": "CalculateByFormula",
    "code_value": "func (repo *DiplomaRepo) CalculateByFormula(ctx context.Context, scoreThreshold float64) ([]*model.Diploma, error) {\n    selectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n    var diplomas []*model.Diploma\n\n    if err := repo.db.Clauses(selectClause).Table(model.DiplomaTableName).\n        Where(\"final_score >= ?\", scoreThreshold).\n        Find(&diplomas).Error; err != nil {\n        return nil, err\n    }\n\n    return diplomas, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleGraduationEligibility",
        "code_value": "func HandleGraduationEligibility(ctx context.Context, logger *zap.Logger) error {\n    diplomaRepo, err := data.NewDiplomaRepo()\n    if err != nil {\n        logger.Error(\"failed to initialize diploma repo\", zap.Error(err))\n        return err\n    }\n\n    passingStudents, err := diplomaRepo.CalculateByFormula(ctx, 70.0)\n    if err != nil {\n        logger.Error(\"failed to calculate graduation eligibility\", zap.Error(err))\n        return err\n    }\n\n    logger.Info(\"successfully retrieved eligible graduates\", zap.Int(\"count\", len(passingStudents)))\n    return nil\n}"
      },
      {
        "code_key": "ProcessScholarshipCandidates",
        "code_value": "func ProcessScholarshipCandidates(ctx context.Context, threshold float64) ([]*model.Diploma, error) {\n    repo := data.DiplomaRepo{db: globalDB}\n    \n    candidates, err := repo.CalculateByFormula(ctx, threshold)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to fetch scholarship candidates: %v\", err)\n    }\n\n    if len(candidates) == 0 {\n        return nil, errors.New(\"no eligible candidates found\")\n    }\n\n    return candidates, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "DiplomaRepo",
        "code_value": "type DiplomaRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Diploma",
        "code_value": "type Diploma struct {\n\tID          int64   `gorm:\"column:id\" json:\"id\"`\n\tStudentName string  `gorm:\"column:student_name\" json:\"student_name\"`\n\tMajor       string  `gorm:\"column:major\" json:\"major\"`\n\tFinalScore  float64 `gorm:\"column:final_score\" json:\"final_score\"`\n\tIsGraduated bool    `gorm:\"column:is_graduated\" json:\"is_graduated\"`\n}"
      },
      {
        "code_key": "DiplomaTableName",
        "code_value": "const DiplomaTableName = \"academic_diploma\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (d *Diploma) TableName() string {\n\treturn DiplomaTableName\n}"
      },
      {
        "code_key": "ScoreThreshold",
        "code_value": "const ScoreThreshold = 60.0"
      },
      {
        "code_key": "GraduateStatus",
        "code_value": "type GraduateStatus int\n\nconst (\n\tPending GraduateStatus = iota\n\tApproved\n\tRejected\n)"
      },
      {
        "code_key": "AcademicUtils",
        "code_value": "package academic\n\nimport \"context\"\n\ntype Hints struct{}\n\nfunc SetSQLComment(ctx context.Context, clause string) Hints {\n\treturn Hints{}\n}"
      },
      {
        "code_key": "QueryOptions",
        "code_value": "type QueryOptions struct {\n\tLimit  int\n\tOffset int\n\tSortBy string\n}"
      }
    ]
  },
  "synthetic_对象const_chunk_AnalyzePerformance": {
    "scenario": "对象const+chunk",
    "code_key": "AnalyzePerformance",
    "code_value": "func (repo *SpellRepo) AnalyzePerformance(ctx context.Context, spellID string) (*model.SpellPerformance, error) {\n\tconst performanceTable = \"spell_performance_data\"\n\tselectClause := analytics.SetTrackingComment(ctx, analytics.SelectKey)\n\tperformance := &model.SpellPerformance{}\n\n\tif err := repo.db.Clauses(selectClause).Table(performanceTable).\n\t\tWhere(\"spell_id = ?\", spellID).\n\t\tFirst(performance).Error; err != nil {\n\t\t\tif err == gorm.ErrRecordNotFound {\n\t\t\t\treturn nil, nil\n\t\t\t}\n\t\t\treturn nil, err\n\t}\n\n\tif performance.LastAccessTime < time.Now().Unix()-86400 {\n\t\treturn nil, errors.New(\"performance data outdated\")\n\t}\n\n\treturn performance, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleSpellPerformance",
        "code_value": "func HandleSpellPerformance(ctx context.Context, spellIdentifier string, logger *zap.Logger) (*model.SpellPerformance, error) {\n\tspellRepo, err := data.NewSpellRepo()\n\tif err != nil {\n\t\tlogger.Error(\"failed to initialize spell repository\", zap.Error(err))\n\t\treturn nil, err\n\t}\n\n\tperfData, err := spellRepo.AnalyzePerformance(ctx, spellIdentifier)\n\tif err != nil {\n\t\tlogger.Error(\"failed to analyze spell performance\", \n\t\t\tzap.String(\"spellID\", spellIdentifier), \n\t\t\tzap.Error(err))\n\t\treturn nil, err\n\t}\n\n\tif perfData == nil {\n\t\tlogger.Warn(\"no performance data found\", zap.String(\"spellID\", spellIdentifier))\n\t\treturn nil, nil\n\t}\n\n\treturn perfData, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "SpellRepo",
        "code_value": "type SpellRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "SpellPerformance",
        "code_value": "type SpellPerformance struct {\n\tSpellID        string `gorm:\"column:spell_id\" json:\"spell_id\"`\n\tSuccessRate    float64 `gorm:\"column:success_rate\" json:\"success_rate\"`\n\tAvgCastTime    float64 `gorm:\"column:avg_cast_time\" json:\"avg_cast_time\"`\n\tLastAccessTime int64  `gorm:\"column:last_access_time\" json:\"last_access_time\"`\n}"
      },
      {
        "code_key": "spell_performance_data",
        "code_value": "const spell_performance_data = \"spell_performance_data\""
      },
      {
        "code_key": "analytics",
        "code_value": "import \"git.woa.com/magic/magic-analytics/pkg/analytics\""
      },
      {
        "code_key": "SetTrackingComment",
        "code_value": "func SetTrackingComment(ctx context.Context, operation string) clause.Expression {\n\ttraceID := ctx.Value(\"trace_id\")\n\tif traceID == nil {\n\t\ttraceID = \"not_provided\"\n\t}\n\treturn gorm.Expr(\"/* operation=%s,trace_id=%s */\", operation, traceID)\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"select\""
      },
      {
        "code_key": "time",
        "code_value": "import \"time\""
      },
      {
        "code_key": "gorm",
        "code_value": "import \"gorm.io/gorm\""
      },
      {
        "code_key": "errors",
        "code_value": "import \"errors\""
      },
      {
        "code_key": "context",
        "code_value": "import \"context\""
      }
    ]
  },
  "synthetic_对象const_chunk_MonitorActivity": {
    "scenario": "对象const+chunk",
    "code_key": "MonitorActivity",
    "code_value": "func (repo *ActivityRepo) MonitorActivity(ctx context.Context, achievement *model.Achievement) error {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\toldAchievement := &model.Achievement{}\n\n\tif err := repo.db.Clauses(selectClause).Table(model.AchievementTableName).\n\t\tWhere(\"reference_code = ?\", achievement.ReferenceCode).\n\t\tFirst(oldAchievement).Error; err != nil {\n\t\tif !errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn err\n\t\t}\n\t\t// 不存在则创建\n\t\tif err := repo.db.Clauses(updateClause).Table(model.AchievementTableName).\n\t\t\tCreate(achievement).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\t// 存在则更新\n\t\tif err := repo.db.Clauses(updateClause).Table(model.AchievementTableName).\n\t\t\tWhere(\"reference_code = ?\", achievement.ReferenceCode).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"role_code\": achievement.RoleCode,\n\t\t\t\t\"service_name\": achievement.ServiceName,\n\t\t\t}).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "sql_pattern_cnt": 2,
    "callers": [
      {
        "code_key": "HandleUserAchievement",
        "code_value": "func HandleUserAchievement(ctx context.Context, refCode string, roleCode string, serviceName string, logger *zap.Logger) error {\n\tactivityRepo, err := data.NewActivityRepo()\n\tif err != nil {\n\t\tlogger.Error(\"Failed to create activity repo\", zap.Error(err))\n\t\treturn err\n\t}\n\n\tachievement := &model.Achievement{\n\t\tReferenceCode: refCode,\n\t\tRoleCode:      roleCode,\n\t\tServiceName:   serviceName,\n\t}\n\n\tif err := activityRepo.MonitorActivity(ctx, achievement); err != nil {\n\t\tlogger.Error(\"Failed to monitor activity\", zap.Error(err))\n\t\treturn err\n\t}\n\treturn nil\n}"
      },
      {
        "code_key": "ProcessGameProgress",
        "code_value": "func ProcessGameProgress(ctx context.Context, playerID string, gameLevel string) error {\n\trepo := &ActivityRepo{db: database.GetDefaultDB()}\n\tprogress := &model.Achievement{\n\t\tReferenceCode: playerID,\n\t\tRoleCode:      \"player\",\n\t\tServiceName:   gameLevel,\n\t}\n\n\tif err := repo.MonitorActivity(ctx, progress); err != nil {\n\t\tmetrics.Increment(\"game_progress_error\")\n\t\treturn fmt.Errorf(\"failed to update game progress: %w\", err)\n\t}\n\tmetrics.Increment(\"game_progress_success\")\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "ActivityRepo",
        "code_value": "type ActivityRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "AchievementTableName",
        "code_value": "const AchievementTableName = \"ivc_activity_achievement\""
      },
      {
        "code_key": "Achievement",
        "code_value": "type Achievement struct {\n\tID           int64  `gorm:\"column:id\" json:\"id\"`\n\tReferenceCode string `gorm:\"column:reference_code\" json:\"reference_code\"`\n\tRoleCode      string `gorm:\"column:role_code\" json:\"role_code\"`\n\tServiceName   string `gorm:\"column:service_name\" json:\"service_name\"`\n\tCreatedAt    int64  `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt    int64  `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (a *Achievement) TableName() string {\n\treturn AchievementTableName\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "hints",
        "code_value": "git.woa.com/IVC/ivc-event-alarm/pkg/hints"
      },
      {
        "code_key": "icontext",
        "code_value": "git.woa.com/IVC/ivc-event-alarm/pkg/icontext"
      },
      {
        "code_key": "uuid",
        "code_value": "github.com/google/uuid"
      }
    ]
  },
  "synthetic_对象const_chunk_CountByStatus": {
    "scenario": "对象const+chunk",
    "code_key": "CountByStatus",
    "code_value": "func (repo *BudgetRepo) CountByStatus(ctx context.Context, status int) (int64, error) {\n\tcountClause := utils.SetSQLComment(ctx, utils.CountKey)\n\tvar count int64\n\n\tif err := repo.db.Clauses(countClause).Table(model.BudgetTableName).\n\t\tWhere(\"status = ?\", status).\n\t\tCount(&count).Error; err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn count, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleBudgetAnalysis",
        "code_value": "func HandleBudgetAnalysis(ctx context.Context, db *gorm.DB) (int64, error) {\n\trepo := &BudgetRepo{db: db}\n\tactiveCount, err := repo.CountByStatus(ctx, 1)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to count active budgets: %v\", err)\n\t}\n\treturn activeCount, nil\n}"
      },
      {
        "code_key": "ProcessBudgetReport",
        "code_value": "func ProcessBudgetReport(ctx context.Context, dbConn *gorm.DB, targetStatus int) error {\n\tbudgetRepo := &BudgetRepo{db: dbConn}\n\ttotal, err := budgetRepo.CountByStatus(ctx, targetStatus)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"budget status count failed: %w\", err)\n\t}\n\tlog.Printf(\"Found %d budgets with status %d\", total, targetStatus)\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "FuelConsumptionRepo",
        "code_value": "type FuelConsumptionRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "FuelConsumptionTableName",
        "code_value": "const FuelConsumptionTableName = \"vehicle_fuel_records\""
      },
      {
        "code_key": "FuelConsumption",
        "code_value": "type FuelConsumption struct {\n\tID          int64   `gorm:\"column:id\" json:\"id\"`\n\tVehicleID   string  `gorm:\"column:vehicle_id\" json:\"vehicle_id\"`\n\tFuelAmount  float64 `gorm:\"column:fuel_amount\" json:\"fuel_amount\"`\n\tCost        float64 `gorm:\"column:cost\" json:\"cost\"`\n\tStatus      int     `gorm:\"column:status\" json:\"status\"`\n\tRecordedAt  int64   `gorm:\"column:recorded_at\" json:\"recorded_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (fc *FuelConsumption) TableName() string {\n\treturn FuelConsumptionTableName\n}"
      },
      {
        "code_key": "FuelStatusActive",
        "code_value": "const FuelStatusActive = 1"
      },
      {
        "code_key": "FuelStatusInactive",
        "code_value": "const FuelStatusInactive = 0"
      },
      {
        "code_key": "FuelStatusArchived",
        "code_value": "const FuelStatusArchived = 2"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/vehicle-service/pkg/utils"
      },
      {
        "code_key": "CountKey",
        "code_value": "const CountKey = \"count\""
      },
      {
        "code_key": "VehicleRecord",
        "code_value": "type VehicleRecord struct {\n\tID          int64   `gorm:\"column:id\" json:\"id\"`\n\tPlateNumber string  `gorm:\"column:plate_number\" json:\"plate_number\"`\n\tModel       string  `gorm:\"column:model\" json:\"model\"`\n\tStatus      int     `gorm:\"column:status\" json:\"status\"`\n}"
      }
    ]
  },
  "synthetic_对象const_chunk_MeasureEfficiency": {
    "scenario": "对象const+chunk",
    "code_key": "MeasureEfficiency",
    "code_value": "func (repo *ContainerRepo) MeasureEfficiency(ctx context.Context, containerID string) (float64, error) {\n\tconst EfficiencyThreshold = 0.7\n\tvar container model.Container\n\t\n\tif err := repo.db.Table(model.ContainerTableName).\n\t\tWhere(\"container_id = ?\", containerID).\n\t\tFirst(&container).Error; err != nil {\n\t\treturn 0, err\n\t}\n\t\n\tefficiency := float64(container.ProcessedUnits) / float64(container.TotalCapacity)\n\tif efficiency < EfficiencyThreshold {\n\t\tif err := repo.db.Table(model.ContainerTableName).\n\t\t\tWhere(\"container_id = ?\", containerID).\n\t\t\tUpdate(\"status\", model.StatusNeedsMaintenance).Error; err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\t\n\treturn efficiency, nil\n}",
    "sql_pattern_cnt": 2,
    "callers": [
      {
        "code_key": "HandleContainerEfficiency",
        "code_value": "func HandleContainerEfficiency(containerRepo *ContainerRepo, containerID string) {\n\tctx := context.Background()\n\teff, err := containerRepo.MeasureEfficiency(ctx, containerID)\n\tif err != nil {\n\t\tlog.Printf(\"Error measuring container efficiency: %v\", err)\n\t\treturn\n\t}\n\tlog.Printf(\"Container %s efficiency: %.2f\", containerID, eff)\n}"
      },
      {
        "code_key": "MonitorFleetEfficiency",
        "code_value": "func MonitorFleetEfficiency(db *gorm.DB, containerIDs []string) map[string]float64 {\n\tresults := make(map[string]float64)\n\trepo := &ContainerRepo{db: db}\n\tctx := context.Background()\n\n\tfor _, id := range containerIDs {\n\t\teff, err := repo.MeasureEfficiency(ctx, id)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Skipping container %s due to error: %v\", id, err)\n\t\t\tcontinue\n\t\t}\n\t\tresults[id] = eff\n\t}\n\n\treturn results\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Container",
        "code_value": "type Container struct {\n\tContainerID     string `gorm:\"column:container_id\" json:\"container_id\"`\n\tProcessedUnits  int    `gorm:\"column:processed_units\" json:\"processed_units\"`\n\tTotalCapacity   int    `gorm:\"column:total_capacity\" json:\"total_capacity\"`\n\tStatus          string `gorm:\"column:status\" json:\"status\"`\n}"
      },
      {
        "code_key": "ContainerTableName",
        "code_value": "const ContainerTableName = \"container_metrics\""
      },
      {
        "code_key": "StatusNeedsMaintenance",
        "code_value": "const StatusNeedsMaintenance = \"NEEDS_MAINTENANCE\""
      },
      {
        "code_key": "ContainerRepo",
        "code_value": "type ContainerRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "EfficiencyThreshold",
        "code_value": "const EfficiencyThreshold = 0.7"
      },
      {
        "code_key": "EfficiencyReport",
        "code_value": "type EfficiencyReport struct {\n\tContainerID string  `json:\"container_id\"`\n\tEfficiency  float64 `json:\"efficiency\"`\n\tStatus      string  `json:\"status\"`\n}"
      },
      {
        "code_key": "ContainerStatus",
        "code_value": "type ContainerStatus string"
      },
      {
        "code_key": "TableName",
        "code_value": "func (c *Container) TableName() string {\n\treturn ContainerTableName\n}"
      }
    ]
  },
  "synthetic_对象const_chunk_ValidatePublication": {
    "scenario": "对象const+chunk",
    "code_key": "ValidatePublication",
    "code_value": "func (repo *PublicationRepo) ValidatePublication(ctx context.Context, pub *model.Publication) (bool, error) {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\texistingPub := &model.Publication{}\n\n\tif err := repo.db.Clauses(selectClause).Table(model.PublicationTableName).\n\t\tWhere(\"isbn = ? AND edition = ?\", pub.ISBN, pub.Edition).\n\t\tFirst(existingPub).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn true, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif existingPub.Description != pub.Description || existingPub.FullName != pub.FullName {\n\t\treturn false, fmt.Errorf(\"publication validation failed: description or fullName mismatch\")\n\t}\n\n\treturn true, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "ProcessPublicationUpload",
        "code_value": "func ProcessPublicationUpload(ctx context.Context, uploadData *model.Publication, logger *zap.Logger) error {\n\tpubRepo, err := data.NewPublicationRepo()\n\tif err != nil {\n\t\tlogger.Error(\"failed to create publication repo\", zap.Error(err))\n\t\treturn err\n\t}\n\n\tisValid, err := pubRepo.ValidatePublication(ctx, uploadData)\n\tif err != nil {\n\t\tlogger.Error(\"publication validation failed\", zap.Error(err))\n\t\treturn err\n\t}\n\n\tif !isValid {\n\t\treturn fmt.Errorf(\"invalid publication data\")\n\t}\n\n\t// Continue with upload processing\n\treturn nil\n}"
      },
      {
        "code_key": "SyncPublicationCatalog",
        "code_value": "func SyncPublicationCatalog(ctx context.Context, catalogItem *model.Publication, syncID string) (bool, error) {\n\trepo := &data.PublicationRepo{DB: global.DB}\n\n\tvalid, err := repo.ValidatePublication(ctx, catalogItem)\n\tif err != nil {\n\t\tglobal.Metrics.Increment(\"publication_validation_failure\")\n\t\treturn false, fmt.Errorf(\"sync failed for %s: %v\", syncID, err)\n\t}\n\n\tif !valid {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "PublicationRepo",
        "code_value": "type PublicationRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Publication",
        "code_value": "type Publication struct {\n\tISBN        string `gorm:\"column:isbn\" json:\"isbn\"`\n\tEdition     string `gorm:\"column:edition\" json:\"edition\"`\n\tDescription string `gorm:\"column:description\" json:\"description\"`\n\tFullName    string `gorm:\"column:full_name\" json:\"full_name\"`\n}"
      },
      {
        "code_key": "PublicationTableName",
        "code_value": "const PublicationTableName = \"publication\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (p *Publication) TableName() string {\n\treturn PublicationTableName\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "DeleteKey",
        "code_value": "const DeleteKey = \"DELETE\""
      },
      {
        "code_key": "existingPub",
        "code_value": "&model.Publication{}"
      },
      {
        "code_key": "selectClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SelectKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-publication/pkg/utils"
      }
    ]
  },
  "synthetic_对象const_chunk_GenerateReport": {
    "scenario": "对象const+chunk",
    "code_key": "GenerateReport",
    "code_value": "func (repo *ReportRepo) GenerateReport(ctx context.Context, params *model.ReportParams) (*model.ReportResult, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tresult := &model.ReportResult{}\n\n\terr := repo.db.Clauses(queryClause).Table(model.ReportTableName).\n\t\tSelect(\"sum(Credits) as total_credits, count(TrackingId) as record_count\").\n\t\tWhere(\"Language = ?\", params.Language).\n\t\tWhere(\"created_at BETWEEN ? AND ?\", params.StartTime, params.EndTime).\n\t\tGroup(\"Language\").\n\t\tScan(result).Error\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn result, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleDailyLanguageReport",
        "code_value": "func HandleDailyLanguageReport(ctx context.Context, lang string, logger *zap.Logger) (*model.ReportResult, error) {\n\treportRepo, err := data.NewReportRepo()\n\tif err != nil {\n\t\tlogger.Error(\"failed to create report repo\", zap.Error(err))\n\t\treturn nil, err\n\t}\n\n\tparams := &model.ReportParams{\n\t\tLanguage:  lang,\n\t\tStartTime: time.Now().AddDate(0, 0, -1),\n\t\tEndTime:   time.Now(),\n\t}\n\n\tstats, err := reportRepo.GenerateReport(ctx, params)\n\tif err != nil {\n\t\tlogger.Error(\"failed to generate report\", zap.Error(err))\n\t\treturn nil, err\n\t}\n\n\treturn stats, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "ReportRepo",
        "code_value": "type ReportRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ReportTableName",
        "code_value": "const ReportTableName = \"monthly_financial_report\""
      },
      {
        "code_key": "ReportParams",
        "code_value": "type ReportParams struct {\n\tLanguage  string\n\tStartTime time.Time\n\tEndTime   time.Time\n}"
      },
      {
        "code_key": "ReportResult",
        "code_value": "type ReportResult struct {\n\tTotalCredits float64 `json:\"total_credits\"`\n\tRecordCount  int64   `json:\"record_count\"`\n}"
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"QUERY\""
      },
      {
        "code_key": "TrackingRecord",
        "code_value": "type TrackingRecord struct {\n\tTrackingId string `gorm:\"column:tracking_id\"`\n\tCredits    float64 `gorm:\"column:credits\"`\n\tLanguage   string `gorm:\"column:language\"`\n\tCreatedAt  time.Time `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (tr *TrackingRecord) TableName() string {\n\treturn ReportTableName\n}"
      },
      {
        "code_key": "CreditStatus",
        "code_value": "const (\n\tCreditStatusPending = iota\n\tCreditProcessed\n\tCreditRejected\n)"
      },
      {
        "code_key": "DefaultLanguage",
        "code_value": "var DefaultLanguage = \"en-US\""
      }
    ]
  },
  "synthetic_对象const_chunk_GenerateMetrics": {
    "scenario": "对象const+chunk",
    "code_key": "GenerateMetrics",
    "code_value": "func (repo *SectionRepo) GenerateMetrics(ctx context.Context, forecast *model.Forecast) ([]*model.Marketplace, error) {\n\tmetrics := make([]*model.Marketplace, 0)\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\n\tif err := repo.db.Clauses(queryClause).Table(model.AchievementRecordsTableName).\n\t\tWhere(\"product_code = ?\", forecast.ProductCode).\n\t\tWhere(\"nick_name = ?\", forecast.NickName).\n\t\tFind(&metrics).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(metrics) == 0 {\n\t\tdefaultMetric := &model.Marketplace{\n\t\t\tProductCode: forecast.ProductCode,\n\t\t\tNickName:    forecast.NickName,\n\t\t\tStreet:      \"default\",\n\t\t}\n\t\tif err := repo.db.Clauses(queryClause).Table(model.AchievementRecordsTableName).\n\t\t\tCreate(defaultMetric).Error; err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tmetrics = append(metrics, defaultMetric)\n\t}\n\n\treturn metrics, nil\n}",
    "sql_pattern_cnt": 2,
    "callers": [
      {
        "code_key": "HandleMarketplaceMetrics",
        "code_value": "func HandleMarketplaceMetrics(ctx context.Context, productID string, sellerAlias string, logger *zap.Logger) (*model.Marketplace, error) {\n\trepo, err := data.NewSectionRepo()\n\tif err != nil {\n\t\tlogger.Error(\"failed to initialize section repo\", zap.Error(err))\n\t\treturn nil, err\n\t}\n\n\tforecastData := &model.Forecast{\n\t\tProductCode: productID,\n\t\tNickName:    sellerAlias,\n\t}\n\n\tmarketStats, err := repo.GenerateMetrics(ctx, forecastData)\n\tif err != nil || len(marketStats) == 0 {\n\t\tlogger.Error(\"failed to generate marketplace metrics\", zap.Error(err))\n\t\treturn nil, err\n\t}\n\n\treturn marketStats[0], nil\n}"
      },
      {
        "code_key": "ProcessVendorPerformance",
        "code_value": "func ProcessVendorPerformance(appCtx context.Context, vendor *model.VendorProfile) ([]*model.Marketplace, error) {\n\tdbRepo := &SectionRepo{db: global.GetDB()}\n\n\tperformanceForecast := &model.Forecast{\n\t\tProductCode: vendor.PrimarySKU,\n\t\tNickName:    vendor.StoreName,\n\t}\n\n\tvendorMetrics, err := dbRepo.GenerateMetrics(appCtx, performanceForecast)\n\tif err != nil {\n\t\tglobal.Logger.Errorf(\"vendor %s metrics error: %v\", vendor.ID, err)\n\t\treturn nil, fmt.Errorf(\"metrics generation failed: %w\", err)\n\t}\n\n\treturn vendorMetrics, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "SectionRepo",
        "code_value": "type SectionRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Forecast",
        "code_value": "type Forecast struct {\n\tProductCode string `json:\"product_code\"`\n\tNickName    string `json:\"nick_name\"`\n}"
      },
      {
        "code_key": "Marketplace",
        "code_value": "type Marketplace struct {\n\tProductCode string `gorm:\"column:product_code\" json:\"product_code\"`\n\tNickName    string `gorm:\"column:nick_name\" json:\"nick_name\"`\n\tStreet      string `gorm:\"column:street\" json:\"street\"`\n}"
      },
      {
        "code_key": "AchievementRecordsTableName",
        "code_value": "const AchievementRecordsTableName = \"marketplace_achievements\""
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"QUERY\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-marketplace/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Interface {\n\tcomment := icontext.GetSQLCommentFromContext(ctx)\n\tif comment == nil {\n\t\tcomment = &SQLComment{ReqId: uuid.NewString()}\n\t}\n\treturn clause.Comment(fmt.Sprintf(\"/* %s */\", comment.ReqId))\n}"
      },
      {
        "code_key": "SQLComment",
        "code_value": "type SQLComment struct {\n\tReqId string `json:\"req_id\"`\n}"
      }
    ]
  },
  "synthetic_对象const_chunk_ForecastDemand": {
    "scenario": "对象const+chunk",
    "code_key": "ForecastDemand",
    "code_value": "func (repo *ThemeRepo) ForecastDemand(ctx context.Context, audio *model.Audio) (int, error) {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tvar existingTheme model.Theme\n\n\tif err := repo.db.Clauses(selectClause).Table(model.ThemeTableName).\n\t\tWhere(\"product_code = ?\", audio.ProductCode).\n\t\tFirst(&existingTheme).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn 0, nil\n\t\t}\n\t\treturn 0, err\n\t}\n\n\tbalance := existingTheme.Balance * audio.PlaybackFactor\n\treturn int(balance), nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleAudioDemand",
        "code_value": "func HandleAudioDemand(ctx context.Context, track *model.Audio, logger *zap.Logger) {\n\trepo, err := data.NewThemeRepo()\n\tif err != nil {\n\t\tlogger.Error(\"Failed to create theme repo\", zap.Error(err))\n\t\treturn\n\t}\n\n\tdemand, err := repo.ForecastDemand(ctx, track)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to forecast demand\", zap.Error(err))\n\t\treturn\n\t}\n\n\tlogger.Info(\"Forecast demand result\", \n\t\tzap.String(\"productCode\", track.ProductCode),\n\t\tzap.Int(\"demand\", demand))\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "ThemeRepo",
        "code_value": "type ThemeRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ThemeTableName",
        "code_value": "const ThemeTableName = \"theme_metadata\""
      },
      {
        "code_key": "Theme",
        "code_value": "type Theme struct {\n\tID          int64   `gorm:\"column:id\" json:\"id\"`\n\tProductCode string  `gorm:\"column:product_code\" json:\"product_code\"`\n\tBalance     float64 `gorm:\"column:balance\" json:\"balance\"`\n\tCreatedAt   int64   `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt   int64   `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "Audio",
        "code_value": "type Audio struct {\n\tProductCode    string  `json:\"product_code\"`\n\tPlaybackFactor float64 `json:\"playback_factor\"`\n\tDuration       int     `json:\"duration\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (t *Theme) TableName() string {\n\treturn ThemeTableName\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "PlaybackThreshold",
        "code_value": "const PlaybackThreshold = 0.8"
      },
      {
        "code_key": "DefaultBalance",
        "code_value": "const DefaultBalance = 100.0"
      }
    ]
  },
  "synthetic_对象const_chunk_LoadByType": {
    "scenario": "对象const+chunk",
    "code_key": "LoadByType",
    "code_value": "func (repo *CertificateRepo) LoadByType(ctx context.Context, sector string) ([]*model.Certificate, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tvar certificates []*model.Certificate\n\n\tif err := repo.db.Clauses(queryClause).Table(model.CertificateTableName).\n\t\tWhere(\"sector = ?\", sector).\n\t\tFind(&certificates).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(certificates) == 0 {\n\t\treturn nil, gorm.ErrRecordNotFound\n\t}\n\n\treturn certificates, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleTrainingCertificates",
        "code_value": "func HandleTrainingCertificates(ctx context.Context, db *gorm.DB, industry string) ([]*model.Certificate, error) {\n\trepo := &CertificateRepo{db: db}\n\tcerts, err := repo.LoadByType(ctx, industry)\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, fmt.Errorf(\"no certificates found for sector: %s\", industry)\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to load certificates: %v\", err)\n\t}\n\treturn certs, nil\n}"
      },
      {
        "code_key": "ProcessSectorCompliance",
        "code_value": "func ProcessSectorCompliance(ctx context.Context, dbConn *gorm.DB, targetSector string) error {\n\tcertRepo := &CertificateRepo{db: dbConn}\n\tvalidCerts, err := certRepo.LoadByType(ctx, targetSector)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"compliance check failed: %v\", err)\n\t}\n\n\tif len(validCerts) < 5 {\n\t\treturn fmt.Errorf(\"insufficient certificates for %s compliance\", targetSector)\n\t}\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "PatientRepo",
        "code_value": "type PatientRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "queryClause",
        "code_value": "utils.SetSQLComment(ctx, utils.QueryKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/healthcare/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) hints.Hints {\n\tcommentInfo := icontext.GetSQLCommentFromContext(ctx)\n\tif len(commentInfo.SessionId) < 10 {\n\t\tcommentInfo.SessionId = uuid.New().String()\n\t}\n\n\tcomment := fmt.Sprintf(\"app=%v,user=%v,session=%v,action=%v\", AppName,\n\t\tcommentInfo.UserId, commentInfo.SessionId, commentInfo.Action)\n\treturn hints.CommentBefore(clause, comment)\n}"
      },
      {
        "code_key": "PatientTableName",
        "code_value": "const PatientTableName = \"medical_patients\""
      },
      {
        "code_key": "Patient",
        "code_value": "type Patient struct {\n\tID             int64  `gorm:\"column:id\" json:\"id\"`\n\tMedicalRecord  string `gorm:\"column:medical_record\" json:\"medical_record\"`\n\tName           string `gorm:\"column:name\" json:\"name\"`\n\tAge            int    `gorm:\"column:age\" json:\"age\"`\n\tGender         string `gorm:\"column:gender\" json:\"gender\"`\n\tAdmissionDate  int64  `gorm:\"column:admission_date\" json:\"admission_date\"`\n\tDischargeDate  int64  `gorm:\"column:discharge_date\" json:\"discharge_date\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (p *Patient) TableName() string {\n\treturn PatientTableName\n}"
      },
      {
        "code_key": "insertClause",
        "code_value": "utils.SetSQLComment(ctx, utils.InsertKey)"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      },
      {
        "code_key": "NewsletterRepo",
        "code_value": "type NewsletterRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "NewsletterTableName",
        "code_value": "const NewsletterTableName = \"marketing_newsletters\""
      },
      {
        "code_key": "Newsletter",
        "code_value": "type Newsletter struct {\n\tID          int64  `gorm:\"column:id\" json:\"id\"`\n\tTitle       string `gorm:\"column:title\" json:\"title\"`\n\tContent     string `gorm:\"column:content\" json:\"content\"`\n\tStatus      int    `gorm:\"column:status\" json:\"status\"`\n\tPublishedAt int64  `gorm:\"column:published_at\" json:\"published_at\"`\n\tAuthorId    int64  `gorm:\"column:author_id\" json:\"author_id\"`\n}"
      },
      {
        "code_key": "NewsletterStatus",
        "code_value": "const (\n\tDraft = iota\n\tPendingReview\n\tPublished\n\tArchived\n)"
      }
    ]
  },
  "synthetic_对象const_chunk_SelectByRange": {
    "scenario": "对象const+chunk",
    "code_key": "SelectByRange",
    "code_value": "func (repo *ProposalRepo) SelectByRange(ctx context.Context, startTime int64, endTime int64) ([]*model.Progress, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tresults := make([]*model.Progress, 0)\n\n\tif err := repo.db.Clauses(queryClause).Table(model.ProgressTableName).\n\t\tWhere(\"create_time BETWEEN ? AND ?\", startTime, endTime).\n\t\tWhere(\"processing_state = ?\", model.StateActive).\n\t\tFind(&results).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn results, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleProgressReport",
        "code_value": "func HandleProgressReport(ctx context.Context, logger *zap.Logger) ([]*model.Progress, error) {\n\trepo, err := NewProposalRepo()\n\tif err != nil {\n\t\tlogger.Error(\"failed to initialize proposal repo\", zap.Error(err))\n\t\treturn nil, err\n\t}\n\n\tnow := time.Now().Unix()\n\tlastWeek := now - 7*24*60*60\n\t\n\tactiveProgresses, err := repo.SelectByRange(ctx, lastWeek, now)\n\tif err != nil {\n\t\tlogger.Error(\"failed to fetch active progresses\", \n\t\t\tzap.Int64(\"start_time\", lastWeek),\n\t\t\tzap.Int64(\"end_time\", now),\n\t\t\tzap.Error(err))\n\t\treturn nil, err\n\t}\n\n\treturn activeProgresses, nil\n}"
      },
      {
        "code_key": "ProcessQuarterlyReview",
        "code_value": "func ProcessQuarterlyReview(ctx context.Context) error {\n\trepo := &ProposalRepo{db: globalDB}\n\t\n\tcurrentYear := time.Now().Year()\n\tq1Start := time.Date(currentYear, 1, 1, 0, 0, 0, 0, time.UTC).Unix()\n\tq1End := time.Date(currentYear, 3, 31, 23, 59, 59, 0, time.UTC).Unix()\n\t\n\tresults, err := repo.SelectByRange(ctx, q1Start, q1End)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get Q1 progress: %w\", err)\n\t}\n\t\n\tif len(results) == 0 {\n\t\treturn errors.New(\"no active progress in Q1\")\n\t}\n\t\n\t// Process results...\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "ProposalRepo",
        "code_value": "type ProposalRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Progress",
        "code_value": "type Progress struct {\n\tID             int64  `gorm:\"column:id\" json:\"id\"`\n\tProposalID     string `gorm:\"column:proposal_id\" json:\"proposal_id\"`\n\tCreateTime     int64  `gorm:\"column:create_time\" json:\"create_time\"`\n\tProcessingState int    `gorm:\"column:processing_state\" json:\"processing_state\"`\n\tCurrentStage   string `gorm:\"column:current_stage\" json:\"current_stage\"`\n}"
      },
      {
        "code_key": "ProgressTableName",
        "code_value": "const ProgressTableName = \"proposal_progress\""
      },
      {
        "code_key": "StateActive",
        "code_value": "const StateActive = 1"
      },
      {
        "code_key": "StateCompleted",
        "code_value": "const StateCompleted = 2"
      },
      {
        "code_key": "StateCancelled",
        "code_value": "const StateCancelled = 3"
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"SELECT\""
      },
      {
        "code_key": "TableNameMethod",
        "code_value": "func (p *Progress) TableName() string {\n\treturn ProgressTableName\n}"
      },
      {
        "code_key": "ProposalContract",
        "code_value": "type ProposalContract struct {\n\tContractID   string `gorm:\"column:contract_id\" json:\"contract_id\"`\n\tContractName string `gorm:\"column:contract_name\" json:\"contract_name\"`\n\tSignDate     int64  `gorm:\"column:sign_date\" json:\"sign_date\"`\n}"
      },
      {
        "code_key": "ContractTableName",
        "code_value": "const ContractTableName = \"proposal_contracts\""
      }
    ]
  },
  "synthetic_对象const_chunk_ConfigureSettings": {
    "scenario": "对象const+chunk",
    "code_key": "ConfigureSettings",
    "code_value": "func (repo *ProjectRepo) ConfigureSettings(ctx context.Context, config *model.ProjectConfig) error {\n\tinsertClause := utils.SetSQLComment(ctx, utils.InsertKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\n\texisting := &model.ProjectConfig{}\n\tif err := repo.db.Table(model.ProjectConfigTableName).\n\t\tWhere(\"application_id = ?\", config.ApplicationId).\n\t\tFirst(existing).Error; err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\tif err := repo.db.Clauses(insertClause).Table(model.ProjectConfigTableName).\n\t\t\t\tCreate(config).Error; err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.ProjectConfigTableName).\n\t\t\tWhere(\"id = ?\", existing.Id).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"points\": config.Points,\n\t\t\t\t\"subject\": config.Subject,\n\t\t\t}).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
    "sql_pattern_cnt": 2,
    "callers": [
      {
        "code_key": "HandleProjectConfigUpdate",
        "code_value": "func HandleProjectConfigUpdate(ctx context.Context, appID string, points int, subject string) error {\n\trepo := &ProjectRepo{db: GetDBInstance()}\n\tcfg := &model.ProjectConfig{\n\t\tApplicationId: appID,\n\t\tPoints:       points,\n\t\tSubject:      subject,\n\t}\n\tif err := repo.ConfigureSettings(ctx, cfg); err != nil {\n\t\tlog.Printf(\"Failed to update project config: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}"
      },
      {
        "code_key": "InitDefaultProjectSettings",
        "code_value": "func InitDefaultProjectSettings(ctx context.Context) error {\n\trepo := &ProjectRepo{db: globalDB}\n\tdefaultCfg := &model.ProjectConfig{\n\t\tApplicationId: \"default-app\",\n\t\tPoints:       100,\n\t\tSubject:      \"General\",\n\t}\n\treturn repo.ConfigureSettings(ctx, defaultCfg)"
      },
      {
        "code_key": "SyncProjectConfiguration",
        "code_value": "func SyncProjectConfiguration(ctx context.Context, sourceCfg *ExternalConfig) error {\n\trepo := NewProjectRepository()\n\ttargetCfg := &model.ProjectConfig{\n\t\tApplicationId: sourceCfg.AppID,\n\t\tPoints:       sourceCfg.Score,\n\t\tSubject:      sourceCfg.Category,\n\t}\n\treturn repo.ConfigureSettings(ctx, targetCfg)"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "ProjectRepo",
        "code_value": "type ProjectRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ProjectConfigTableName",
        "code_value": "const ProjectConfigTableName = \"project_config\""
      },
      {
        "code_key": "ProjectConfig",
        "code_value": "type ProjectConfig struct {\n\tId            int64   `gorm:\"column:id\" json:\"id\"`\n\tApplicationId string  `gorm:\"column:application_id\" json:\"application_id\"`\n\tPoints        float64 `gorm:\"column:points\" json:\"points\"`\n\tSubject       string  `gorm:\"column:subject\" json:\"subject\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (pc *ProjectConfig) TableName() string {\n\treturn ProjectConfigTableName\n}"
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "SQLCommentInfo",
        "code_value": "type SQLCommentInfo struct {\n\tAppId    string\n\tOwnerUin string\n\tSubUin   string\n\tAction   string\n\tReqId    string\n}"
      },
      {
        "code_key": "GetSQLCommentFromContext",
        "code_value": "func GetSQLCommentFromContext(ctx context.Context) SQLCommentInfo {\n\t// implementation details\n\treturn SQLCommentInfo{}\n}"
      },
      {
        "code_key": "hints",
        "code_value": "import \"git.woa.com/IVC/ivc-event-alarm/pkg/hints\""
      }
    ]
  },
  "synthetic_对象const_chunk_MatchByPattern": {
    "scenario": "对象const+chunk",
    "code_key": "MatchByPattern",
    "code_value": "func (repo *BookRepo) MatchByPattern(ctx context.Context, pattern string) ([]*model.Book, error) {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tvar books []*model.Book\n\n\tif err := repo.db.Clauses(selectClause).\n\t\tTable(model.BookTableName).\n\t\tWhere(\"title LIKE ?\", \"%\"+pattern+\"%\").\n\t\tOr(\"MiddleName LIKE ?\", \"%\"+pattern+\"%\").\n\t\tFind(&books).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(books) == 0 {\n\t\tif err := repo.db.Clauses(selectClause).\n\t\t\tTable(model.BookTableName).\n\t\t\tWhere(\"DiscountRate > ?\", 0.5).\n\t\t\tFind(&books).Error; err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn books, nil\n}",
    "sql_pattern_cnt": 2,
    "callers": [
      {
        "code_key": "HandleSearchBooks",
        "code_value": "func HandleSearchBooks(ctx context.Context, searchQuery string) ([]*model.Book, error) {\n\tbookStore := &BookRepo{db: GetDBConnection()}\n\tmatchedBooks, err := bookStore.MatchByPattern(ctx, searchQuery)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to search books: %v\", err)\n\t}\n\treturn matchedBooks, nil\n}"
      },
      {
        "code_key": "ProcessDiscountRecommendations",
        "code_value": "func ProcessDiscountRecommendations(ctx context.Context) error {\n\tbookHandler := &BookRepo{db: InitDatabase()}\n\tdiscountedBooks, err := bookHandler.MatchByPattern(ctx, \"\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get discounted books: %v\", err)\n\t}\n\tif len(discountedBooks) > 0 {\n\t\tSendRecommendations(discountedBooks)\n\t}\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "VideoRepo",
        "code_value": "type VideoRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "VideoTableName",
        "code_value": "const VideoTableName = \"media_videos\""
      },
      {
        "code_key": "Video",
        "code_value": "type Video struct {\n\tID          int64   `gorm:\"column:id\"`\n\tTitle       string  `gorm:\"column:title\"`\n\tDuration    float64 `gorm:\"column:duration\"`\n\tViews       int64   `gorm:\"column:views\"`\n\tIsPublished bool    `gorm:\"column:is_published\"`\n}"
      },
      {
        "code_key": "TestRepo",
        "code_value": "type TestRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "TestTableName",
        "code_value": "const TestTableName = \"user_tests\""
      },
      {
        "code_key": "Test",
        "code_value": "type Test struct {\n\tID         int64   `gorm:\"column:id\"`\n\tUserId     int64   `gorm:\"column:user_id\"`\n\tScore      float64 `gorm:\"column:score\"`\n\tIsComplete bool    `gorm:\"column:is_complete\"`\n}"
      },
      {
        "code_key": "SQLUtils",
        "code_value": "git.woa.com/media-platform/sql-utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Expression {\n\tcommentInfo := GetCommentFromContext(ctx)\n\tif commentInfo == nil {\n\t\treturn clause.Expr{}\n\t}\n\tcomment := fmt.Sprintf(\"app=%s,user=%s\", commentInfo.AppName, commentInfo.UserID)\n\treturn clause.Expr{SQL: \"/* \" + comment + \" */\", Vars: nil}\n}"
      },
      {
        "code_key": "MediaStatus",
        "code_value": "const (\n\tMediaStatusDraft = \"draft\"\n\tMediaStatusPublished = \"published\"\n\tMediaStatusArchived = \"archived\"\n)"
      }
    ]
  },
  "synthetic_对象const_chunk_VerifyIdentity": {
    "scenario": "对象const+chunk",
    "code_key": "VerifyIdentity",
    "code_value": "func (repo *SecurityRepo) VerifyIdentity(ctx context.Context, template *model.IdentityTemplate) (bool, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tverification := &model.IdentityVerification{}\n\n\tif err := repo.db.Clauses(queryClause).Table(model.SecurityClearancesTableName).\n\t\tWhere(\"function_name = ? AND private_key = ?\", template.FunctionName, template.PrivateKey).\n\t\tFirst(verification).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif verification.RefreshKey != template.RefreshKey {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleSecurityVerification",
        "code_value": "func HandleSecurityVerification(ctx context.Context, funcName string, privKey string, refreshToken string) (bool, error) {\n\trepo := &SecurityRepo{db: GetDBInstance()}\n\ttemplate := &model.IdentityTemplate{\n\t\tFunctionName: funcName,\n\t\tPrivateKey:   privKey,\n\t\tRefreshKey:   refreshToken,\n\t}\n\n\tverified, err := repo.VerifyIdentity(ctx, template)\n\tif err != nil {\n\t\tlog.Printf(\"Security verification failed: %v\", err)\n\t\treturn false, err\n\t}\n\n\treturn verified, nil\n}"
      },
      {
        "code_key": "ProcessApiAuthentication",
        "code_value": "func ProcessApiAuthentication(ctx context.Context, apiCreds *ApiCredentials) error {\n\tsecRepo := NewSecurityRepository()\n\tidentTemplate := &model.IdentityTemplate{\n\t\tFunctionName: apiCreds.Endpoint,\n\t\tPrivateKey:   apiCreds.SecretKey,\n\t\tRefreshKey:   apiCreds.SessionToken,\n\t}\n\n\tisValid, verifyErr := secRepo.VerifyIdentity(ctx, identTemplate)\n\tif verifyErr != nil || !isValid {\n\t\treturn errors.New(\"API authentication failed\")\n\t}\n\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "SecurityRepo",
        "code_value": "type SecurityRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "IdentityTemplate",
        "code_value": "type IdentityTemplate struct {\n\tFunctionName string `json:\"function_name\"`\n\tPrivateKey   string `json:\"private_key\"`\n\tRefreshKey   string `json:\"refresh_key\"`\n}"
      },
      {
        "code_key": "IdentityVerification",
        "code_value": "type IdentityVerification struct {\n\tFunctionName string `gorm:\"column:function_name\" json:\"function_name\"`\n\tPrivateKey   string `gorm:\"column:private_key\" json:\"private_key\"`\n\tRefreshKey   string `gorm:\"column:refresh_key\" json:\"refresh_key\"`\n\tCreatedAt    int64  `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "SecurityClearancesTableName",
        "code_value": "const SecurityClearancesTableName = \"security_clearances\""
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"QUERY\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-security/pkg/utils"
      },
      {
        "code_key": "TableName",
        "code_value": "func (iv *IdentityVerification) TableName() string {\n\treturn SecurityClearancesTableName\n}"
      },
      {
        "code_key": "hints",
        "code_value": "git.woa.com/IVC/gorm-hints"
      },
      {
        "code_key": "icontext",
        "code_value": "git.woa.com/IVC/ivc-context"
      }
    ]
  },
  "synthetic_对象const_chunk_RefreshIndex": {
    "scenario": "对象const+chunk",
    "code_key": "RefreshIndex",
    "code_value": "func (repo *CarrierRepo) RefreshIndex(ctx context.Context, carrier *model.Carrier) error {\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\toldCarrier := &model.Carrier{}\n\n\tif err := repo.db.Table(model.CarrierTableName).\n\t\tWhere(\"publication = ?\", carrier.Publication).\n\t\tFirst(oldCarrier).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif oldCarrier.ReactivationDate != carrier.ReactivationDate {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.CarrierTableName).\n\t\t\tWhere(\"id = ?\", oldCarrier.Id).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"reactivation_date\": carrier.ReactivationDate,\n\t\t\t\t\"auth_token\":       carrier.AuthToken,\n\t\t\t}).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleCarrierReactivation",
        "code_value": "func HandleCarrierReactivation(ctx context.Context, publication string, newDate time.Time, token string) error {\n\trepo := &CarrierRepo{db: GetDBInstance()}\n\tcarrier := &model.Carrier{\n\t\tPublication:      publication,\n\t\tReactivationDate: newDate,\n\t\tAuthToken:        token,\n\t}\n\tif err := repo.RefreshIndex(ctx, carrier); err != nil {\n\t\treturn fmt.Errorf(\"failed to refresh carrier index: %v\", err)\n\t}\n\treturn nil\n}"
      },
      {
        "code_key": "UpdateDistributorTokens",
        "code_value": "func UpdateDistributorTokens(ctx context.Context, distributorID string, authToken string) error {\n\trepo := NewCarrierRepository()\n\tcarrierData := &model.Carrier{\n\t\tPublication:      distributorID,\n\t\tReactivationDate: time.Now(),\n\t\tAuthToken:        authToken,\n\t}\n\terr := repo.RefreshIndex(ctx, carrierData)\n\tif err != nil {\n\t\tlog.Printf(\"Error updating distributor tokens: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "CarrierRepo",
        "code_value": "type CarrierRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "CarrierTableName",
        "code_value": "const CarrierTableName = \"ivc_carrier_info\""
      },
      {
        "code_key": "Carrier",
        "code_value": "type Carrier struct {\n\tId               int64   `gorm:\"column:id\" json:\"id\"`\n\tPublication      string  `gorm:\"column:publication\" json:\"publication\"`\n\tReactivationDate int64   `gorm:\"column:reactivation_date\" json:\"reactivation_date\"`\n\tAuthToken        string  `gorm:\"column:auth_token\" json:\"auth_token\"`\n\tStatus           int     `gorm:\"column:status\" json:\"status\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (c *Carrier) TableName() string {\n\treturn CarrierTableName\n}"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-core/pkg/utils"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      },
      {
        "code_key": "CarrierStatusActive",
        "code_value": "const CarrierStatusActive = 1"
      },
      {
        "code_key": "CarrierStatusInactive",
        "code_value": "const CarrierStatusInactive = 0"
      },
      {
        "code_key": "oldCarrier",
        "code_value": "&model.Carrier{}"
      }
    ]
  },
  "synthetic_对象const_chunk_BulkUpdate": {
    "scenario": "对象const+chunk",
    "code_key": "BulkUpdate",
    "code_value": "func (repo *ResourceRepo) BulkUpdate(ctx context.Context, updates []*model.ResourceUpdate) error {\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\tdb := repo.db.Clauses(updateClause).Table(model.ResourceTableName)\n\n\tfor _, update := range updates {\n\t\tif update == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tresult := db.Where(\"OrderNumber = ?\", update.OrderNumber).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"Credits\":         update.Credits,\n\t\t\t\t\"MailingAddress\":  update.MailingAddress,\n\t\t\t})\n\n\t\tif result.Error != nil {\n\t\t\treturn result.Error\n\t\t}\n\t}\n\n\treturn nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleResourceCreditsUpdate",
        "code_value": "func HandleResourceCreditsUpdate(ctx context.Context, resourceUpdates []*model.ResourceUpdate, logger *zap.Logger) error {\n\trepo, err := data.NewResourceRepo()\n\tif err != nil {\n\t\tlogger.Error(\"failed to initialize resource repository\", zap.Error(err))\n\t\treturn err\n\t}\n\n\tif len(resourceUpdates) == 0 {\n\t\tlogger.Warn(\"no resource updates provided\")\n\t\treturn nil\n\t}\n\n\tif err := repo.BulkUpdate(ctx, resourceUpdates); err != nil {\n\t\tlogger.Error(\"failed to bulk update resources\", zap.Error(err))\n\t\treturn fmt.Errorf(\"resource update failed: %w\", err)\n\t}\n\n\tlogger.Info(\"successfully updated resources\", zap.Int(\"count\", len(resourceUpdates)))\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "ResourceRepo",
        "code_value": "type ResourceRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ResourceUpdate",
        "code_value": "type ResourceUpdate struct {\n\tOrderNumber     string  `json:\"order_number\"`\n\tCredits         float64 `json:\"credits\"`\n\tMailingAddress  string  `json:\"mailing_address\"`\n}"
      },
      {
        "code_key": "ResourceTableName",
        "code_value": "const ResourceTableName = \"inventory_resources\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "Resource",
        "code_value": "type Resource struct {\n\tOrderNumber    string  `gorm:\"column:order_number\" json:\"order_number\"`\n\tCredits        float64 `gorm:\"column:credits\" json:\"credits\"`\n\tMailingAddress string  `gorm:\"column:mailing_address\" json:\"mailing_address\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (r *Resource) TableName() string {\n\treturn ResourceTableName\n}"
      },
      {
        "code_key": "hints",
        "code_value": "import \"gorm.io/hints\""
      },
      {
        "code_key": "icontext",
        "code_value": "import \"git.woa.com/common/pkg/icontext\""
      },
      {
        "code_key": "uuid",
        "code_value": "import \"github.com/google/uuid\""
      }
    ]
  },
  "synthetic_对象const_chunk_CalculateStatistics": {
    "scenario": "对象const+chunk",
    "code_key": "CalculateStatistics",
    "code_value": "func (repo *ArmorRepo) CalculateStatistics(ctx context.Context, territory string) (map[string]interface{}, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tresult := make(map[string]interface{})\n\tdbQuery := repo.db.Clauses(queryClause).Table(model.ArmorTableName)\n\n\tif territory != \"\" {\n\t\tdbQuery = dbQuery.Where(\"territory = ?\", territory)\n\t}\n\n\tif err := dbQuery.Select(\n\t\t\"SUM(tax_amount) as total_tax\",\n\t\t\"AVG(suspension_time) as avg_suspension\",\n\t\t\"COUNT(*) as record_count\",\n\t).Scan(&result).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn result, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleArmorStats",
        "code_value": "func HandleArmorStats(db *gorm.DB, region string) (map[string]interface{}, error) {\n\trepo := &ArmorRepo{db: db}\n\tstats, err := repo.CalculateStatistics(context.Background(), region)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to calculate armor stats: %v\", err)\n\t}\n\treturn stats, nil\n}"
      },
      {
        "code_key": "ProcessTerritoryReport",
        "code_value": "func ProcessTerritoryReport(conn *gorm.DB) error {\n\treportRepo := &ArmorRepo{db: conn}\n\tmetrics, err := reportRepo.CalculateStatistics(context.TODO(), \"europe\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"territory report generation failed: %w\", err)\n\t}\n\tlog.Printf(\"Territory metrics: %+v\", metrics)\n\treturn nil\n}"
      },
      {
        "code_key": "GenerateGlobalArmorSummary",
        "code_value": "func GenerateGlobalArmorSummary(dbClient *gorm.DB) (float64, error) {\n\tarmorRepo := ArmorRepo{db: dbClient}\n\tresults, err := armorRepo.CalculateStatistics(context.Background(), \"\")\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"global summary error: %w\", err)\n\t}\n\treturn results[\"total_tax\"].(float64), nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "AchievementRepo",
        "code_value": "type AchievementRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "AchievementTableName",
        "code_value": "const AchievementTableName = \"user_achievements\""
      },
      {
        "code_key": "Achievement",
        "code_value": "type Achievement struct {\n\tID          uint    `gorm:\"column:id\"`\n\tUserID      string  `gorm:\"column:user_id\"`\n\tLevel       int     `gorm:\"column:level\"`\n\tPoints      float64 `gorm:\"column:points\"`\n\tCompletedAt int64   `gorm:\"column:completed_at\"`\n}"
      },
      {
        "code_key": "TaskRepo",
        "code_value": "type TaskRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "TaskTableName",
        "code_value": "const TaskTableName = \"user_tasks\""
      },
      {
        "code_key": "Task",
        "code_value": "type Task struct {\n\tID        uint   `gorm:\"column:id\"`\n\tName      string `gorm:\"column:name\"`\n\tStatus    int    `gorm:\"column:status\"`\n\tCreatedBy string `gorm:\"column:created_by\"`\n\tDueDate   int64  `gorm:\"column:due_date\"`\n}"
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"QUERY\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "TaskStatusPending",
        "code_value": "const TaskStatusPending = 0"
      },
      {
        "code_key": "TaskStatusCompleted",
        "code_value": "const TaskStatusCompleted = 1"
      }
    ]
  },
  "synthetic_对象const_chunk_RejectApplication": {
    "scenario": "对象const+chunk",
    "code_key": "RejectApplication",
    "code_value": "func (repo *TestRepo) RejectApplication(ctx context.Context, app *model.Application) error {\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\tconst RejectedStatus = 3\n\n\texisting := &model.Application{}\n\tif err := repo.db.Table(model.ApplicationTableName).\n\t\tWhere(\"application_id = ?\", app.ApplicationID).\n\t\tFirst(existing).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif existing.Status != RejectedStatus {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.ApplicationTableName).\n\t\t\tWhere(\"id = ?\", existing.ID).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"status\": RejectedStatus,\n\t\t\t\t\"end_date\": time.Now().Unix(),\n\t\t\t}).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
    "sql_pattern_cnt": 2,
    "callers": [
      {
        "code_key": "ProcessApplicationRejection",
        "code_value": "func ProcessApplicationRejection(ctx context.Context, appID string) error {\n\trepo := &TestRepo{db: initializeDB()}\n\tapplication := &model.Application{ApplicationID: appID}\n\tif err := repo.RejectApplication(ctx, application); err != nil {\n\t\tlog.Printf(\"Failed to reject application %s: %v\", appID, err)\n\t\treturn err\n\t}\n\tlog.Printf(\"Successfully rejected application %s\", appID)\n\treturn nil\n}"
      },
      {
        "code_key": "HandleExpiredApplications",
        "code_value": "func HandleExpiredApplications(ctx context.Context, expiredApps []string) error {\n\trepo := &TestRepo{db: getDatabaseConnection()}\n\tfor _, appID := range expiredApps {\n\t\tapp := &model.Application{ApplicationID: appID}\n\t\tif err := repo.RejectApplication(ctx, app); err != nil {\n\t\t\treturn fmt.Errorf(\"error rejecting app %s: %w\", appID, err)\n\t\t}\n\t}\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Application",
        "code_value": "type Application struct {\n\tID            int64  `gorm:\"column:id\" json:\"id\"`\n\tApplicationID string `gorm:\"column:application_id\" json:\"application_id\"`\n\tStatus        int    `gorm:\"column:status\" json:\"status\"`\n\tEndDate       int64  `gorm:\"column:end_date\" json:\"end_date\"`\n}"
      },
      {
        "code_key": "ApplicationTableName",
        "code_value": "const ApplicationTableName = \"applications\""
      },
      {
        "code_key": "RejectedStatus",
        "code_value": "const RejectedStatus = 3"
      },
      {
        "code_key": "TestRepo",
        "code_value": "type TestRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/company/project/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) hints.Hints {\n\tcommentInfo := icontext.GetSQLCommentFromContext(ctx)\n\tif len(commentInfo.ReqId) == 0 {\n\t\tcommentInfo.ReqId = uuid.New().String()\n\t}\n\n\tcomment := fmt.Sprintf(\"p=%s,a=%s,o=%s\", \n\t\tcommentInfo.Product, commentInfo.AppName, commentInfo.Owner)\n\treturn hints.CommentBefore(clause, comment)\n}"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      },
      {
        "code_key": "ApplicationRequest",
        "code_value": "type ApplicationRequest struct {\n\tApplicationID string `json:\"application_id\"`\n\tStatus       int    `json:\"status\"`\n}"
      },
      {
        "code_key": "PendingStatus",
        "code_value": "const PendingStatus = 1"
      },
      {
        "code_key": "ApprovedStatus",
        "code_value": "const ApprovedStatus = 2"
      }
    ]
  },
  "synthetic_对象const_chunk_ValidateEdition": {
    "scenario": "对象const+chunk",
    "code_key": "ValidateEdition",
    "code_value": "func (repo *BlogRepo) ValidateEdition(ctx context.Context, blog *model.BlogContent) error {\n\tconst ContentReportsTable = \"content_reports\"\n\tselectClause := utils.SetSQLComment(ctx, \"select_edition\")\n\texisting := &model.BlogContent{}\n\n\tif err := repo.db.Clauses(selectClause).Table(ContentReportsTable).\n\t\tWhere(\"edition = ? AND latitude > ?\", blog.Edition, 0).\n\t\tFirst(existing).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif existing.DiscountRate != blog.DiscountRate {\n\t\treturn fmt.Errorf(\"discount rate mismatch for edition %d\", blog.Edition)\n\t}\n\n\treturn nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleBlogUpdate",
        "code_value": "func HandleBlogUpdate(ctx context.Context, editionID int, discount float64) error {\n\trepo := &BlogRepo{db: GetDB()}\n\tblog := &model.BlogContent{\n\t\tEdition:      editionID,\n\t\tDiscountRate: discount,\n\t}\n\n\tif err := repo.ValidateEdition(ctx, blog); err != nil {\n\t\treturn fmt.Errorf(\"validation failed: %v\", err)\n\t}\n\treturn nil\n}"
      },
      {
        "code_key": "ProcessEditionCheck",
        "code_value": "func ProcessEditionCheck(ctx context.Context, contentData *model.BlogContent) (bool, error) {\n\trepository := NewBlogRepository(globalDB)\n\terr := repository.ValidateEdition(ctx, contentData)\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn true, nil\n\t\t}\n\t\treturn false, fmt.Errorf(\"edition validation error: %w\", err)\n\t}\n\treturn true, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "BlogContent",
        "code_value": "type BlogContent struct {\n\tEdition      int     `gorm:\"column:edition\" json:\"edition\"`\n\tDiscountRate float64 `gorm:\"column:discount_rate\" json:\"discount_rate\"`\n\tLatitude     float64 `gorm:\"column:latitude\" json:\"latitude\"`\n}"
      },
      {
        "code_key": "BlogRepo",
        "code_value": "type BlogRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ContentReportsTable",
        "code_value": "const ContentReportsTable = \"content_reports\""
      },
      {
        "code_key": "select_edition",
        "code_value": "utils.SetSQLComment(ctx, \"select_edition\")"
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/org/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Expression {\n\tcomment := \"/* \" + clause + \" */\"\n\treturn gorm.Expr(comment)\n}"
      },
      {
        "code_key": "DiscountReport",
        "code_value": "type DiscountReport struct {\n\tID           int64   `gorm:\"column:id\" json:\"id\"`\n\tEdition      int     `gorm:\"column:edition\" json:\"edition\"`\n\tDiscountRate float64 `gorm:\"column:discount_rate\" json:\"discount_rate\"`\n\tLatitude     float64 `gorm:\"column:latitude\" json:\"latitude\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (d *DiscountReport) TableName() string {\n\treturn ContentReportsTable\n}"
      }
    ]
  },
  "synthetic_对象const_chunk_PurgeExpiredRecords": {
    "scenario": "对象const+chunk",
    "code_key": "PurgeExpiredRecords",
    "code_value": "func (repo *TimelineRepo) PurgeExpiredRecords(ctx context.Context, threshold int64) error {\n\tdeleteClause := utils.SetSQLComment(ctx, utils.DeleteKey)\n\t\n\tif err := repo.db.Clauses(deleteClause).Table(model.TimelineTableName).\n\t\tWhere(\"last_updated < ?\", threshold).\n\t\tDelete(&model.Timeline{}).Error; err != nil {\n\t\treturn err\n\t}\n\t\n\treturn nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandlePostCleanup",
        "code_value": "func HandlePostCleanup(ctx context.Context, dbConn *gorm.DB, retentionDays int) error {\n\trepo := &TimelineRepo{db: dbConn}\n\tthreshold := time.Now().AddDate(0, 0, -retentionDays).Unix()\n\tif err := repo.PurgeExpiredRecords(ctx, threshold); err != nil {\n\t\treturn fmt.Errorf(\"failed to purge old posts: %w\", err)\n\t}\n\treturn nil\n}"
      },
      {
        "code_key": "ProcessRegionDataMaintenance",
        "code_value": "func ProcessRegionDataMaintenance(ctx context.Context, storage *gorm.DB, regionCode string) error {\n\trepo := &TimelineRepo{db: storage}\n\t// Purge records older than 90 days for specific region\n\texpiryCutoff := time.Now().AddDate(0, -3, 0).Unix()\n\terr := repo.PurgeExpiredRecords(ctx, expiryCutoff)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"region %s cleanup failed: %v\", regionCode, err)\n\t}\n\treturn nil\n}"
      },
      {
        "code_key": "ExecuteScheduledPurge",
        "code_value": "func ExecuteScheduledPurge(dbInstance *gorm.DB) error {\n\trepository := &TimelineRepo{db: dbInstance}\n\t// Keep only last 30 days of data\n\tcutoffTime := time.Now().Add(-720 * time.Hour).Unix()\n\tif err := repository.PurgeExpiredRecords(context.Background(), cutoffTime); err != nil {\n\t\tlog.Printf(\"Database maintenance error: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "PatientRepo",
        "code_value": "type PatientRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "queryClause",
        "code_value": "utils.SetSQLComment(ctx, utils.QueryKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/medical/patient-management/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) hints.Hints {\n\tcommentInfo := icontext.GetSQLCommentFromContext(ctx)\n\tif len(commentInfo.SessionId) < 16 {\n\t\tcommentInfo.SessionId = uuid.NewString()\n\t}\n\n\tcomment := fmt.Sprintf(\"m=%v,d=%v,p=%v,t=%v,s=%v\", MedicalCenter,\n\t\tcommentInfo.DoctorId, commentInfo.PatientId, commentInfo.Timestamp, commentInfo.SessionId)\n\treturn hints.CommentBefore(clause, comment)\n}"
      },
      {
        "code_key": "PatientRecordTableName",
        "code_value": "const PatientRecordTableName = \"hospital_patient_records\""
      },
      {
        "code_key": "patientRecord",
        "code_value": "&model.PatientRecord{}"
      },
      {
        "code_key": "PatientRecord",
        "code_value": "type PatientRecord struct {\n\tId            int64   `gorm:\"column:id\" json:\"id\"`\n\tPatientName   string  `gorm:\"column:patient_name\" json:\"patient_name\"`\n\tAge           int     `gorm:\"column:age\" json:\"age\"`\n\tGender        string  `gorm:\"column:gender\" json:\"gender\"`\n\tMedicalStatus int     `gorm:\"column:medical_status\" json:\"medical_status\"`\n\tLastCheckup   int64   `gorm:\"column:last_checkup\" json:\"last_checkup\"`\n\tBloodType     string  `gorm:\"column:blood_type\" json:\"blood_type\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (pr *PatientRecord) TableName() string {\n\treturn PatientRecordTableName\n}"
      },
      {
        "code_key": "MedicalCenter",
        "code_value": "const MedicalCenter = \"Central_Hospital\""
      },
      {
        "code_key": "createClause",
        "code_value": "utils.SetSQLComment(ctx, utils.CreateKey)"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      }
    ]
  },
  "synthetic_对象const_chunk_ListWithPaging": {
    "scenario": "对象const+chunk",
    "code_key": "ListWithPaging",
    "code_value": "func (repo *QuizRepo) ListWithPaging(ctx context.Context, filter *QuizFilter, page, size int) ([]*Quiz, error) {\n\tconst QuizTableName = \"performance_reviews\"\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tvar quizzes []*Quiz\n\n\tquery := repo.db.Clauses(selectClause).Table(QuizTableName)\n\tif filter.FunctionName != \"\" {\n\t\tquery = query.Where(\"function_name = ?\", filter.FunctionName)\n\t}\n\tif filter.DepartmentCode != 0 {\n\t\tquery = query.Where(\"department_code = ?\", filter.DepartmentCode)\n\t}\n\n\tif err := query.Offset((page - 1) * size).\n\t\tLimit(size).\n\t\tFind(&quizzes).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn quizzes, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandlePerformanceReview",
        "code_value": "func HandlePerformanceReview(ctx context.Context, role string) ([]*Quiz, error) {\n\treviewRepo, err := InitializeQuizRepo()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to init repo: %v\", err)\n\t}\n\n\tcriteria := &QuizFilter{\n\t\tFunctionName:   role,\n\t\tDepartmentCode: 0,\n\t}\n\n\tresults, err := reviewRepo.ListWithPaging(ctx, criteria, 1, 10)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"query failed: %v\", err)\n\t}\n\n\treturn results, nil\n}"
      },
      {
        "code_key": "FetchDepartmentReviews",
        "code_value": "func FetchDepartmentReviews(ctx context.Context, deptID int, pageSize int) ([]*Quiz, error) {\n\tdbRepo := NewQuizRepository()\n\tif dbRepo == nil {\n\t\treturn nil, errors.New(\"repository initialization failed\")\n\t}\n\n\tfilters := &QuizFilter{\n\t\tDepartmentCode: deptID,\n\t}\n\n\treviews, err := dbRepo.ListWithPaging(ctx, filters, 1, pageSize)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"paging query error: %w\", err)\n\t}\n\n\tif len(reviews) == 0 {\n\t\treturn nil, nil\n\t}\n\n\treturn reviews, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "QuizRepo",
        "code_value": "type QuizRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Quiz",
        "code_value": "type Quiz struct {\n\tID            int64  `gorm:\"column:id\" json:\"id\"`\n\tFunctionName  string `gorm:\"column:function_name\" json:\"function_name\"`\n\tDepartmentCode int    `gorm:\"column:department_code\" json:\"department_code\"`\n\tReviewScore   int    `gorm:\"column:review_score\" json:\"review_score\"`\n\tCreatedAt    time.Time `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "QuizFilter",
        "code_value": "type QuizFilter struct {\n\tFunctionName  string\n\tDepartmentCode int\n}"
      },
      {
        "code_key": "QuizTableName",
        "code_value": "const QuizTableName = \"performance_reviews\""
      },
      {
        "code_key": "PageSizeDefault",
        "code_value": "const PageSizeDefault = 20"
      },
      {
        "code_key": "MaxPageSize",
        "code_value": "const MaxPageSize = 100"
      },
      {
        "code_key": "ReviewStatusPending",
        "code_value": "const ReviewStatusPending = 1"
      },
      {
        "code_key": "ReviewStatusCompleted",
        "code_value": "const ReviewStatusCompleted = 2"
      },
      {
        "code_key": "selectClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SelectKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/org/pkg/utils"
      }
    ]
  },
  "synthetic_对象const_chunk_MigrateData": {
    "scenario": "对象const+chunk",
    "code_key": "MigrateData",
    "code_value": "func (repo *ScannerRepo) MigrateData(ctx context.Context, pattern string) error {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tinsertClause := utils.SetSQLComment(ctx, utils.InsertKey)\n\tvar scanners []*model.Scanner\n\n\tif err := repo.db.Clauses(selectClause).Table(model.ScannerTableName).\n\t\tWhere(\"summary LIKE ?\", \"%\"+pattern+\"%\").\n\t\tFind(&scanners).\n\t\tError; err != nil {\n\t\treturn err\n\t}\n\n\tfor _, s := range scanners {\n\t\tif err := repo.db.Clauses(insertClause).Table(model.ScannerArchiveTableName).\n\t\t\tCreate(s).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "sql_pattern_cnt": 2,
    "callers": [
      {
        "code_key": "HandleScannerMigration",
        "code_value": "func HandleScannerMigration(ctx context.Context, searchPattern string, logger *zap.Logger) error {\n\tdbConn, err := config.GetDatabaseConnection()\n\tif err != nil {\n\t\tlogger.Error(\"Failed to get DB connection\", zap.Error(err))\n\t\treturn err\n\t}\n\n\tscannerRepo := &repository.ScannerRepo{db: dbConn}\n\terr = scannerRepo.MigrateData(ctx, searchPattern)\n\tif err != nil {\n\t\tlogger.Error(\"Data migration failed\", \n\t\t\tzap.String(\"pattern\", searchPattern), \n\t\t\tzap.Error(err))\n\t\treturn fmt.Errorf(\"migration error: %w\", err)\n\t}\n\tlogger.Info(\"Scanner data migrated successfully\")\n\treturn nil\n}"
      },
      {
        "code_key": "ProcessSecurityScanArchive",
        "code_value": "func ProcessSecurityScanArchive(ctx context.Context) error {\n\tdbEngine := infrastructure.GetDB()\n\tif dbEngine == nil {\n\t\treturn errors.New(\"database engine not initialized\")\n\t}\n\n\trepo := &scanner.ScannerRepo{db: dbEngine}\n\terr := repo.MigrateData(ctx, \"CVE-\")\n\tif err != nil {\n\t\tmetrics.Increment(\"scanner_migration_failure\")\n\t\treturn err\n\t}\n\tmetrics.Increment(\"scanner_migration_success\")\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "ScannerRepo",
        "code_value": "type ScannerRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Scanner",
        "code_value": "type Scanner struct {\n\tID      int64  `gorm:\"column:id\" json:\"id\"`\n\tName    string `gorm:\"column:name\" json:\"name\"`\n\tSummary string `gorm:\"column:summary\" json:\"summary\"`\n\tStatus  int    `gorm:\"column:status\" json:\"status\"`\n}"
      },
      {
        "code_key": "ScannerArchive",
        "code_value": "type ScannerArchive struct {\n\tID      int64  `gorm:\"column:id\" json:\"id\"`\n\tName    string `gorm:\"column:name\" json:\"name\"`\n\tSummary string `gorm:\"column:summary\" json:\"summary\"`\n\tArchivedAt int64 `gorm:\"column:archived_at\" json:\"archived_at\"`\n}"
      },
      {
        "code_key": "ScannerTableName",
        "code_value": "const ScannerTableName = \"scanners\""
      },
      {
        "code_key": "ScannerArchiveTableName",
        "code_value": "const ScannerArchiveTableName = \"scanner_archives\""
      },
      {
        "code_key": "ActiveStatus",
        "code_value": "const ActiveStatus = 1"
      },
      {
        "code_key": "InactiveStatus",
        "code_value": "const InactiveStatus = 0"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "DefaultPattern",
        "code_value": "const DefaultPattern = \"test\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (s *Scanner) TableName() string {\n\treturn ScannerTableName\n}"
      },
      {
        "code_key": "ArchiveTableName",
        "code_value": "func (sa *ScannerArchive) TableName() string {\n\treturn ScannerArchiveTableName\n}"
      }
    ]
  },
  "synthetic_对象const_chunk_PreventAttack": {
    "scenario": "对象const+chunk",
    "code_key": "PreventAttack",
    "code_value": "func (repo *SecurityRepo) PreventAttack(ctx context.Context, log *AuditLog) error {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tinsertClause := utils.SetSQLComment(ctx, utils.InsertKey)\n\texistingLog := &AuditLog{}\n\n\tif err := repo.db.Clauses(queryClause).Table(model.AuditLogTableName).\n\t\tWhere(\"room = ? AND database_name = ?\", log.Room, log.DatabaseName).\n\t\tFirst(existingLog).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\tif err := repo.db.Clauses(insertClause).Table(model.AuditLogTableName).\n\t\t\t\tCreate(log).Error; err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif existingLog.DeliveryCode != log.DeliveryCode {\n\t\tif err := repo.db.Table(model.AuditLogTableName).\n\t\t\tWhere(\"id = ?\", existingLog.ID).\n\t\t\tUpdate(\"delivery_code\", log.DeliveryCode).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "sql_pattern_cnt": 3,
    "callers": [
      {
        "code_key": "HandleAuditLogUpdate",
        "code_value": "func HandleAuditLogUpdate(ctx context.Context, dbConn *gorm.DB) error {\n\tsecRepo := &SecurityRepo{db: dbConn}\n\tauditEntry := &AuditLog{\n\t\tRoom:         \"conference_room\",\n\t\tDatabaseName: \"medical_records\",\n\t\tDeliveryCode: \"SECURE123\",\n\t}\n\n\tif err := secRepo.PreventAttack(ctx, auditEntry); err != nil {\n\t\treturn fmt.Errorf(\"failed to process audit log: %v\", err)\n\t}\n\treturn nil\n}"
      },
      {
        "code_key": "ProcessSecurityCheck",
        "code_value": "func ProcessSecurityCheck(ctx context.Context, dbEngine *gorm.DB, facility string) error {\n\tsecurityRepo := &SecurityRepo{db: dbEngine}\n\tlogData := &AuditLog{\n\t\tRoom:         facility,\n\t\tDatabaseName: \"patient_data\",\n\t\tDeliveryCode: \"HEALTH456\",\n\t}\n\n\terr := securityRepo.PreventAttack(ctx, logData)\n\tif err != nil {\n\t\tlog.Printf(\"security check failed for %s: %v\", facility, err)\n\t\treturn err\n\t}\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "SecurityRepo",
        "code_value": "type SecurityRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "AuditLogTableName",
        "code_value": "const AuditLogTableName = \"security_audit_log\""
      },
      {
        "code_key": "AuditLog",
        "code_value": "type AuditLog struct {\n\tID           uint   `gorm:\"column:id\" json:\"id\"`\n\tRoom         string `gorm:\"column:room\" json:\"room\"`\n\tDatabaseName string `gorm:\"column:database_name\" json:\"database_name\"`\n\tDeliveryCode string `gorm:\"column:delivery_code\" json:\"delivery_code\"`\n\tCreatedAt    int64  `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"QUERY\""
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "SecurityEvent",
        "code_value": "type SecurityEvent struct {\n\tEventType   string `json:\"event_type\"`\n\tDescription string `json:\"description\"`\n\tSeverity    int    `json:\"severity\"`\n}"
      },
      {
        "code_key": "AuditLogResponse",
        "code_value": "type AuditLogResponse struct {\n\tSuccess bool   `json:\"success\"`\n\tMessage string `json:\"message\"`\n\tLogID   uint   `json:\"log_id\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (al *AuditLog) TableName() string {\n\treturn AuditLogTableName\n}"
      }
    ]
  },
  "synthetic_对象const_chunk_SyncWithExternal": {
    "scenario": "对象const+chunk",
    "code_key": "SyncWithExternal",
    "code_value": "func (repo *RiskRepo) SyncWithExternal(ctx context.Context, externalData *model.Express) error {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\texisting := &model.Express{}\n\n\tif err := repo.db.Clauses(selectClause).Table(model.ExpressTableName).\n\t\tWhere(\"transaction_id = ?\", externalData.TransactionId).\n\t\tFirst(existing).Error; err != nil {\n\t\tif !errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn err\n\t\t}\n\t\t// 不存在则创建\n\t\treturn repo.db.Table(model.ExpressTableName).Create(externalData).Error\n\t}\n\n\t// 存在则更新时区字段\n\tif existing.Timezone != externalData.Timezone {\n\t\treturn repo.db.Clauses(updateClause).Table(model.ExpressTableName).\n\t\t\tWhere(\"transaction_id = ?\", externalData.TransactionId).\n\t\t\tUpdate(\"timezone\", externalData.Timezone).Error\n\t}\n\n\treturn nil\n}",
    "sql_pattern_cnt": 3,
    "callers": [
      {
        "code_key": "HandleExpressSync",
        "code_value": "func HandleExpressSync(ctx context.Context, transID string, zone string, log *zap.Logger) error {\n\trepo := &RiskRepo{db: conf.GetDBEngine()}\n\texpressData := &model.Express{\n\t\tTransactionId: transID,\n\t\tTimezone:      zone,\n\t}\n\n\tif err := repo.SyncWithExternal(ctx, expressData); err != nil {\n\t\tlog.Error(\"failed to sync express data\", zap.Error(err))\n\t\treturn err\n\t}\n\treturn nil\n}"
      },
      {
        "code_key": "ProcessShippingUpdate",
        "code_value": "func ProcessShippingUpdate(ctx context.Context, shippingInfo *model.Express) error {\n\trepo := &RiskRepo{db: conf.GetDBEngine()}\n\tif shippingInfo == nil {\n\t\treturn errors.New(\"invalid shipping info\")\n\t}\n\n\treturn repo.SyncWithExternal(ctx, shippingInfo)\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "RiskRepo",
        "code_value": "type RiskRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ExpressTableName",
        "code_value": "const ExpressTableName = \"risk_express_record\""
      },
      {
        "code_key": "Express",
        "code_value": "type Express struct {\n\tTransactionId string `gorm:\"column:transaction_id\" json:\"transaction_id\"`\n\tTimezone      string `gorm:\"column:timezone\" json:\"timezone\"`\n\tStatus        int    `gorm:\"column:status\" json:\"status\"`\n\tCreatedAt     int64  `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (e *Express) TableName() string {\n\treturn ExpressTableName\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "hints",
        "code_value": "import \"gorm.io/hints\""
      },
      {
        "code_key": "gorm",
        "code_value": "import \"gorm.io/gorm\""
      },
      {
        "code_key": "errors",
        "code_value": "import \"errors\""
      },
      {
        "code_key": "icontext",
        "code_value": "import \"git.woa.com/IVC/ivc-risk/pkg/icontext\""
      }
    ]
  },
  "synthetic_对象const_chunk_SearchByKeyword": {
    "scenario": "对象const+chunk",
    "code_key": "SearchByKeyword",
    "code_value": "func (repo *DiseaseRepo) SearchByKeyword(ctx context.Context, keyword string) ([]*model.Disease, error) {\n\tsearchClause := utils.SetSQLComment(ctx, utils.SearchKey)\n\tresult := make([]*model.Disease, 0)\n\n\tquery := repo.db.Clauses(searchClause).Table(model.DiseaseTableName)\n\tif keyword != \"\" {\n\t\tquery = query.Where(\n\t\t\t\"disease_name LIKE ? OR disease_code LIKE ?\", \n\t\t\t\"%\"+keyword+\"%\", \n\t\t\t\"%\"+keyword+\"%\")\n\t}\n\n\tif err := query.Find(&result).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn result, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleDiseaseSearch",
        "code_value": "func HandleDiseaseSearch(ctx context.Context, searchTerm string, logger *zap.Logger) ([]*model.Disease, error) {\n\tdbEngine := conf.GetDBEngine()\n\tif dbEngine == nil {\n\t\treturn nil, fmt.Errorf(\"database engine not initialized\")\n\t}\n\n\tdiseaseRepo := &DiseaseRepo{db: dbEngine}\n\tmatchedDiseases, err := diseaseRepo.SearchByKeyword(ctx, searchTerm)\n\tif err != nil {\n\t\tlogger.Error(\"Disease search failed\", zap.Error(err))\n\t\treturn nil, fmt.Errorf(\"search failed: %v\", err)\n\t}\n\n\tif len(matchedDiseases) == 0 {\n\t\tlogger.Info(\"No diseases found matching criteria\", zap.String(\"term\", searchTerm))\n\t}\n\n\treturn matchedDiseases, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "DiseaseRepo",
        "code_value": "type DiseaseRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Disease",
        "code_value": "type Disease struct {\n\tID          int64  `gorm:\"column:id\" json:\"id\"`\n\tDiseaseCode string `gorm:\"column:disease_code\" json:\"disease_code\"`\n\tDiseaseName string `gorm:\"column:disease_name\" json:\"disease_name\"`\n\tDescription string `gorm:\"column:description\" json:\"description\"`\n\tCreatedAt   int64  `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt   int64  `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "DiseaseTableName",
        "code_value": "const DiseaseTableName = \"medical_diseases\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (d *Disease) TableName() string {\n\treturn DiseaseTableName\n}"
      },
      {
        "code_key": "SearchKey",
        "code_value": "const SearchKey = \"SEARCH\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/medical/pkg/utils"
      },
      {
        "code_key": "icontext",
        "code_value": "git.woa.com/common/pkg/icontext"
      },
      {
        "code_key": "hints",
        "code_value": "gorm.io/hints"
      }
    ]
  },
  "synthetic_对象const_chunk_UpdateQuestStatus": {
    "scenario": "对象const+chunk",
    "code_key": "UpdateQuestStatus",
    "code_value": "func (repo *QuestRepo) UpdateQuestStatus(ctx context.Context, quest *model.Quest) error {\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\tcurrentQuest := &model.Quest{}\n\n\tif err := repo.db.Table(model.QuestTableName).\n\t\tWhere(\"unique_key = ?\", quest.UniqueKey).\n\t\tFirst(currentQuest).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif currentQuest.SuspensionTime != quest.SuspensionTime {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.QuestTableName).\n\t\t\tWhere(\"id = ?\", currentQuest.Id).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"suspension_time\": quest.SuspensionTime,\n\t\t\t\t\"nick_name\":      quest.NickName,\n\t\t\t}).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "sql_pattern_cnt": 2,
    "callers": [
      {
        "code_key": "HandleQuestSuspension",
        "code_value": "func HandleQuestSuspension(ctx context.Context, questID string, suspendUntil time.Time, logger *zap.Logger) error {\n\trepo, err := data.NewQuestRepo()\n\tif err != nil {\n\t\tlogger.Error(\"failed to create quest repo\", zap.Error(err))\n\t\treturn err\n\t}\n\n\ttargetQuest := &model.Quest{\n\t\tUniqueKey:      questID,\n\t\tSuspensionTime: suspendUntil,\n\t\tNickName:       \"system_admin\",\n\t}\n\n\tif err := repo.UpdateQuestStatus(ctx, targetQuest); err != nil {\n\t\tlogger.Error(\"failed to update quest status\", \n\t\t\tzap.String(\"questID\", questID),\n\t\t\tzap.Error(err))\n\t\treturn err\n\t}\n\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "QuestRepo",
        "code_value": "type QuestRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Quest",
        "code_value": "type Quest struct {\n\tId            int64  `gorm:\"column:id\" json:\"id\"`\n\tUniqueKey     string `gorm:\"column:unique_key\" json:\"unique_key\"`\n\tSuspensionTime int64  `gorm:\"column:suspension_time\" json:\"suspension_time\"`\n\tNickName      string `gorm:\"column:nick_name\" json:\"nick_name\"`\n}"
      },
      {
        "code_key": "QuestTableName",
        "code_value": "const QuestTableName = \"user_quests\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "hints",
        "code_value": "import \"gorm.io/hints\""
      },
      {
        "code_key": "icontext",
        "code_value": "import \"git.woa.com/common/icontext\""
      },
      {
        "code_key": "uuid",
        "code_value": "import \"github.com/google/uuid\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (q *Quest) TableName() string {\n\treturn QuestTableName\n}"
      }
    ]
  },
  "synthetic_对象const_chunk_CalculateDiscount": {
    "scenario": "对象const+chunk",
    "code_key": "CalculateDiscount",
    "code_value": "func (repo *VendorRepo) CalculateDiscount(ctx context.Context, contract *model.VendorContract) (float64, error) {\n\tbaseClause := utils.SetSQLComment(ctx, utils.BaseKey)\n\tvar existingContract model.VendorContract\n\n\terr := repo.db.Clauses(baseClause).Table(model.VendorContractsTableName).\n\t\tWhere(\"vendor_id = ? AND product_type = ?\", contract.VendorId, contract.ProductType).\n\t\tFirst(&existingContract).Error\n\n\tif err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn 0.0, nil\n\t\t}\n\t\treturn 0.0, err\n\t}\n\n\tdiscount := existingContract.BaseRate * (1 - existingContract.NegotiatedRate)\n\treturn discount, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "ProcessVendorDiscount",
        "code_value": "func ProcessVendorDiscount(ctx context.Context, db *gorm.DB, vendorID string, productType int) (float64, error) {\n\trepo := &VendorRepo{db: db}\n\tcontract := &model.VendorContract{\n\t\tVendorId:    vendorID,\n\t\tProductType: productType,\n\t}\n\n\tdiscount, err := repo.CalculateDiscount(ctx, contract)\n\tif err != nil {\n\t\treturn 0.0, fmt.Errorf(\"failed to calculate discount: %v\", err)\n\t}\n\t\n\tif discount > 0 {\n\t\tlog.Printf(\"Discount calculated: %.2f for vendor %s\", discount, vendorID)\n\t}\n\treturn discount, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "DiscountCalculatorRepo",
        "code_value": "type DiscountCalculatorRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ProductDiscountTableName",
        "code_value": "const ProductDiscountTableName = \"product_discounts\""
      },
      {
        "code_key": "ProductDiscount",
        "code_value": "type ProductDiscount struct {\n\tID             int64   `gorm:\"column:id\"`\n\tMerchantId     string  `gorm:\"column:merchant_id\"`\n\tCategoryId     int     `gorm:\"column:category_id\"`\n\tStandardPrice  float64 `gorm:\"column:standard_price\"`\n\tDiscountRate   float64 `gorm:\"column:discount_rate\"`\n\tEffectiveDate  int64   `gorm:\"column:effective_date\"`\n\tExpirationDate int64   `gorm:\"column:expiration_date\"`\n}"
      },
      {
        "code_key": "DiscountPolicy",
        "code_value": "type DiscountPolicy struct {\n\tMinAmount    float64\n\tMaxAmount    float64\n\tTieredRates  map[float64]float64\n\tSpecialRules []SpecialRule\n}"
      },
      {
        "code_key": "SpecialRule",
        "code_value": "type SpecialRule struct {\n\tCondition  string\n\tAdjustment float64\n}"
      },
      {
        "code_key": "GlobalDiscountSettings",
        "code_value": "var GlobalDiscountSettings = struct {\n\tDefaultRate    float64\n\tMaxDiscount    float64\n\tBlacklist      []string\n\tWhitelist      []string\n\tActiveCampaign bool\n}{\n\tDefaultRate:    0.1,\n\tMaxDiscount:    0.5,\n\tActiveCampaign: true,\n}"
      },
      {
        "code_key": "PriceTier",
        "code_value": "const (\n\tTierBasic    = 1\n\tTierStandard = 2\n\tTierPremium  = 3\n)"
      },
      {
        "code_key": "DiscountCache",
        "code_value": "var DiscountCache = sync.Map{}"
      },
      {
        "code_key": "CategoryDiscount",
        "code_value": "type CategoryDiscount struct {\n\tCategoryId      int\n\tBaseMultiplier  float64\n\tSeasonalAdjust  float64\n\tInventoryFactor float64\n}"
      }
    ]
  },
  "synthetic_对象const_chunk_CompareData": {
    "scenario": "对象const+chunk",
    "code_key": "CompareData",
    "code_value": "func (repo *AssetRepo) CompareData(ctx context.Context, scanner *model.Scanner) (bool, error) {\n\tdbClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tstoredAsset := &model.Asset{}\n\n\tif err := repo.db.Clauses(dbClause).Table(model.AssetTableName).\n\t\tWhere(\"scanner_id = ?\", scanner.ID).\n\t\tFirst(&storedAsset).Error; err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif storedAsset.Percentage != scanner.Percentage || \n\t   storedAsset.CurrentStatus != scanner.CurrentStatus {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleScanValidation",
        "code_value": "func HandleScanValidation(ctx context.Context, scanTool *model.Scanner, dbConn *gorm.DB) (bool, error) {\n\trepo := &AssetRepo{db: dbConn}\n\tisIdentical, err := repo.CompareData(ctx, scanTool)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"scan validation failed: %w\", err)\n\t}\n\tif !isIdentical {\n\t\treturn false, nil\n\t}\n\treturn true, nil\n}"
      },
      {
        "code_key": "ProcessContentReport",
        "code_value": "func ProcessContentReport(ctx context.Context, contentScanner *model.Scanner, storage *gorm.DB) error {\n\tassetRep := AssetRepo{db: storage}\n\tmatched, compareErr := assetRep.CompareData(ctx, contentScanner)\n\tif compareErr != nil {\n\t\treturn compareErr\n\t}\n\tif !matched {\n\t\treturn fmt.Errorf(\"content report data mismatch\")\n\t}\n\treturn nil\n}"
      },
      {
        "code_key": "VerifyAssetConsistency",
        "code_value": "func VerifyAssetConsistency(ctx context.Context, detector *model.Scanner, database *gorm.DB) bool {\n\tassetChecker := &AssetRepo{db: database}\n\tisConsistent, _ := assetChecker.CompareData(ctx, detector)\n\treturn isConsistent\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Scanner",
        "code_value": "type Scanner struct {\n\tID            string  `gorm:\"column:scanner_id\" json:\"scanner_id\"`\n\tPercentage    float64 `gorm:\"column:percentage\" json:\"percentage\"`\n\tCurrentStatus int     `gorm:\"column:current_status\" json:\"current_status\"`\n}"
      },
      {
        "code_key": "ReportContentTableName",
        "code_value": "const ReportContentTableName = \"scan_reports\""
      },
      {
        "code_key": "ContentReport",
        "code_value": "type ContentReport struct {\n\tID            int64   `gorm:\"column:id\" json:\"id\"`\n\tScannerID     string  `gorm:\"column:scanner_id\" json:\"scanner_id\"`\n\tPercentage    float64 `gorm:\"column:percentage\" json:\"percentage\"`\n\tCurrentStatus int     `gorm:\"column:current_status\" json:\"current_status\"`\n\tCreatedAt     int64   `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt     int64   `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "ScanResult",
        "code_value": "type ScanResult struct {\n\tIsMatch      bool   `json:\"is_match\"`\n\tErrorMessage string `json:\"error_message,omitempty\"`\n}"
      },
      {
        "code_key": "ReportRepo",
        "code_value": "type ReportRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ScanThreshold",
        "code_value": "const ScanThreshold = 0.95"
      },
      {
        "code_key": "StatusCompleted",
        "code_value": "const StatusCompleted = 1"
      },
      {
        "code_key": "StatusPending",
        "code_value": "const StatusPending = 0"
      },
      {
        "code_key": "TableName",
        "code_value": "func (cr *ContentReport) TableName() string {\n\treturn ReportContentTableName\n}"
      }
    ]
  },
  "synthetic_对象const_chunk_TrackBehavior": {
    "scenario": "对象const+chunk",
    "code_key": "TrackBehavior",
    "code_value": "func (repo *GameBehaviorRepo) TrackBehavior(ctx context.Context, session *model.PlayerSession) error {\n\tactionClause := utils.SetSQLComment(ctx, utils.ActionKey)\n\tbehavior := &model.PlayerBehavior{SessionID: session.ID, AuthToken: session.Token}\n\n\tif err := repo.db.Clauses(actionClause).Table(model.BehaviorTableName).\n\t\tWhere(\"session_id = ? AND auth_token = ?\", session.ID, session.Token).\n\t\tFirstOrCreate(behavior).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif behavior.GrossValue < session.Score {\n\t\tif err := repo.db.Clauses(actionClause).Table(model.BehaviorTableName).\n\t\t\tWhere(\"id = ?\", behavior.ID).\n\t\t\tUpdate(\"gross_value\", session.Score).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "sql_pattern_cnt": 2,
    "callers": [
      {
        "code_key": "HandleGameSessionUpdate",
        "code_value": "func HandleGameSessionUpdate(ctx context.Context, gameSession *model.PlayerSession, logger *zap.Logger) error {\n\tgameRepo, err := data.NewGameBehaviorRepo()\n\tif err != nil {\n\t\tlogger.Error(\"Failed to initialize game behavior repository\", zap.Error(err))\n\t\treturn err\n\t}\n\n\tif err := gameRepo.TrackBehavior(ctx, gameSession); err != nil {\n\t\tlogger.Error(\"Failed to track player behavior\", \n\t\t\tzap.String(\"sessionID\", gameSession.ID),\n\t\t\tzap.Error(err))\n\t\treturn fmt.Errorf(\"track behavior failed: %w\", err)\n\t}\n\n\tlogger.Info(\"Successfully tracked player behavior\",\n\t\tzap.String(\"sessionID\", gameSession.ID),\n\t\tzap.Int(\"score\", gameSession.Score))\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "PlayerSession",
        "code_value": "type PlayerSession struct {\n\tID    string `gorm:\"column:id\" json:\"id\"`\n\tToken string `gorm:\"column:auth_token\" json:\"auth_token\"`\n\tScore int    `gorm:\"column:score\" json:\"score\"`\n}"
      },
      {
        "code_key": "PlayerBehavior",
        "code_value": "type PlayerBehavior struct {\n\tID         int    `gorm:\"column:id\" json:\"id\"`\n\tSessionID  string `gorm:\"column:session_id\" json:\"session_id\"`\n\tAuthToken  string `gorm:\"column:auth_token\" json:\"auth_token\"`\n\tGrossValue int    `gorm:\"column:gross_value\" json:\"gross_value\"`\n}"
      },
      {
        "code_key": "GameBehaviorRepo",
        "code_value": "type GameBehaviorRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "BehaviorTableName",
        "code_value": "const BehaviorTableName = \"player_behavior\""
      },
      {
        "code_key": "ActionKey",
        "code_value": "const ActionKey = \"action\""
      },
      {
        "code_key": "ScoreThreshold",
        "code_value": "const ScoreThreshold = 1000"
      },
      {
        "code_key": "hints",
        "code_value": "import \"gorm.io/hints\""
      }
    ]
  },
  "synthetic_对象const_chunk_SortByField": {
    "scenario": "对象const+chunk",
    "code_key": "SortByField",
    "code_value": "func (repo *StreamRepo) SortByField(ctx context.Context, fieldName string, ascending bool) ([]*model.Stream, error) {\n\torderClause := utils.SetSQLComment(ctx, utils.OrderKey)\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\t\n\tvar streams []*model.Stream\n\tdbQuery := repo.db.Clauses(queryClause).Table(model.StreamTableName)\n\t\n\tif ascending {\n\t\tdbQuery = dbQuery.Clauses(orderClause).Order(fieldName + \" ASC\")\n\t} else {\n\t\tdbQuery = dbQuery.Clauses(orderClause).Order(fieldName + \" DESC\")\n\t}\n\t\n\tif err := dbQuery.Find(&streams).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn streams, nil\n}",
    "sql_pattern_cnt": 2,
    "callers": [
      {
        "code_key": "HandleLiveStreamSorting",
        "code_value": "func HandleLiveStreamSorting(ctx context.Context, log *zap.Logger) ([]*model.Stream, error) {\n\tdb := conf.GetDBEngine()\n\tif db == nil {\n\t\treturn nil, fmt.Errorf(\"database engine not initialized\")\n\t}\n\n\trepo := &StreamRepo{db: db}\n\tsortedStreams, err := repo.SortByField(ctx, \"viewers_count\", false)\n\tif err != nil {\n\t\tlog.Error(\"Failed to sort streams by viewers\", zap.Error(err))\n\t\treturn nil, err\n\t}\n\treturn sortedStreams, nil\n}"
      },
      {
        "code_key": "HandleNewestStreams",
        "code_value": "func HandleNewestStreams(ctx context.Context) ([]*model.Stream, error) {\n\tdbConn, err := data.NewDBConnection()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create db connection: %v\", err)\n\t}\n\n\trepo := &StreamRepo{db: dbConn}\n\tresult, err := repo.SortByField(ctx, \"created_at\", false)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"sorting failed: %v\", err)\n\t}\n\treturn result, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "StreamRepo",
        "code_value": "type StreamRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "StreamTableName",
        "code_value": "const StreamTableName = \"media_streams\""
      },
      {
        "code_key": "Stream",
        "code_value": "type Stream struct {\n\tID          uint      `gorm:\"column:id;primaryKey\" json:\"id\"`\n\tName        string    `gorm:\"column:name\" json:\"name\"`\n\tStatus      int       `gorm:\"column:status\" json:\"status\"`\n\tCreatedAt   time.Time `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt   time.Time `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "StreamStatusActive",
        "code_value": "const StreamStatusActive = 1"
      },
      {
        "code_key": "StreamStatusInactive",
        "code_value": "const StreamStatusInactive = 0"
      },
      {
        "code_key": "OrderKey",
        "code_value": "const OrderKey = \"ORDER\""
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"QUERY\""
      },
      {
        "code_key": "StreamSortFields",
        "code_value": "var StreamSortFields = []string{\"name\", \"created_at\", \"updated_at\"}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (s *Stream) TableName() string {\n\treturn StreamTableName\n}"
      },
      {
        "code_key": "StreamFilter",
        "code_value": "type StreamFilter struct {\n\tStatus *int\n\tName   *string\n}"
      }
    ]
  },
  "synthetic_对象const_chunk_FilterByAttribute": {
    "scenario": "对象const+chunk",
    "code_key": "FilterByAttribute",
    "code_value": "func (repo *MagazineRepo) FilterByAttribute(ctx context.Context, regionCode string, categoryType int) ([]*model.Magazine, error) {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tvar results []*model.Magazine\n\n\tif err := repo.db.Clauses(selectClause).Table(model.MagazineTableName).\n\t\tWhere(\"region_code = ? AND category_type = ?\", regionCode, categoryType).\n\t\tFind(&results).Error; err != nil {\n\t\t\treturn nil, err\n\t}\n\n\tif len(results) == 0 {\n\t\treturn nil, gorm.ErrRecordNotFound\n\t}\n\n\treturn results, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleRegionalMagazines",
        "code_value": "func HandleRegionalMagazines(ctx context.Context, region string, category int) ([]*model.Magazine, error) {\n\trepo := &MagazineRepo{db: conf.GetDBEngine()}\n\tmagazines, err := repo.FilterByAttribute(ctx, region, category)\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to get regional magazines: %w\", err)\n\t}\n\treturn magazines, nil\n}"
      },
      {
        "code_key": "ProcessMagazineFeed",
        "code_value": "func ProcessMagazineFeed(ctx context.Context, locationCode string) error {\n\trepo := &MagazineRepo{db: conf.GetDefaultDB()}\n\titems, err := repo.FilterByAttribute(ctx, locationCode, model.CategoryMonthly)\n\tif err != nil {\n\t\tlog.Printf(\"Error fetching monthly magazines: %v\", err)\n\t\treturn err\n\t}\n\tfor _, item := range items {\n\t\tsendToFeedService(item)\n\t}\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "MagazineRepo",
        "code_value": "type MagazineRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Magazine",
        "code_value": "type Magazine struct {\n\tID           int64  `gorm:\"column:id\" json:\"id\"`\n\tRegionCode   string `gorm:\"column:region_code\" json:\"region_code\"`\n\tCategoryType int    `gorm:\"column:category_type\" json:\"category_type\"`\n\tTitle        string `gorm:\"column:title\" json:\"title\"`\n\tPublishDate  int64  `gorm:\"column:publish_date\" json:\"publish_date\"`\n}"
      },
      {
        "code_key": "MagazineTableName",
        "code_value": "const MagazineTableName = \"game_magazines\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (m *Magazine) TableName() string {\n\treturn MagazineTableName\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "hints",
        "code_value": "git.woa.com/gorm/hints"
      },
      {
        "code_key": "icontext",
        "code_value": "git.woa.com/context/icontext"
      },
      {
        "code_key": "defaultRegion",
        "code_value": "var defaultRegion = \"CN\""
      }
    ]
  },
  "synthetic_对象const_chunk_UpdateAchievementStatus": {
    "scenario": "对象const+chunk",
    "code_key": "UpdateAchievementStatus",
    "code_value": "func (repo *AchievementRepo) UpdateAchievementStatus(ctx context.Context, achievement *model.Achievement) error {\n\tconst AchievementTableName = \"comment_moderation\"\n\tstatusClause := utils.SetSQLComment(ctx, utils.StatusKey)\n\tcurrentAchievement := &model.Achievement{}\n\n\tif err := repo.db.Clauses(statusClause).Table(AchievementTableName).\n\t\tWhere(\"subject = ?\", achievement.Subject).\n\t\tFirst(currentAchievement).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif currentAchievement.Status != achievement.Status {\n\t\tif err := repo.db.Clauses(statusClause).Table(AchievementTableName).\n\t\t\tWhere(\"id = ?\", currentAchievement.ID).\n\t\t\tUpdate(\"status\", achievement.Status).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleTournamentCompletion",
        "code_value": "func HandleTournamentCompletion(ctx context.Context, tournamentID string) error {\n\tachievementRepo := &AchievementRepo{db: globalDB}\n\tachievement := &model.Achievement{\n\t\tSubject: tournamentID,\n\t\tStatus:  model.StatusCompleted,\n\t}\n\n\tif err := achievementRepo.UpdateAchievementStatus(ctx, achievement); err != nil {\n\t\tlog.Printf(\"failed to update tournament status: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}"
      },
      {
        "code_key": "HandleLevelProgress",
        "code_value": "func HandleLevelProgress(ctx context.Context, userID string, newStatus int) error {\n\tlevelRepo := &AchievementRepo{db: globalDB}\n\tprogress := &model.Achievement{\n\t\tSubject: userID,\n\t\tStatus:  newStatus,\n\t}\n\n\tif err := levelRepo.UpdateAchievementStatus(ctx, progress); err != nil {\n\t\tlog.Printf(\"failed to update level status: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "AchievementRepo",
        "code_value": "type AchievementRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Achievement",
        "code_value": "type Achievement struct {\n\tID      int64  `gorm:\"column:id\" json:\"id\"`\n\tSubject string `gorm:\"column:subject\" json:\"subject\"`\n\tStatus  int    `gorm:\"column:status\" json:\"status\"`\n}"
      },
      {
        "code_key": "StatusKey",
        "code_value": "const StatusKey = \"status\""
      },
      {
        "code_key": "CommentModerationTable",
        "code_value": "const CommentModerationTable = \"comment_moderation\""
      },
      {
        "code_key": "ModelPackage",
        "code_value": "git.woa.com/IVC/ivc-achievement/pkg/model"
      },
      {
        "code_key": "AchievementStatusPending",
        "code_value": "const AchievementStatusPending = 0"
      },
      {
        "code_key": "AchievementStatusCompleted",
        "code_value": "const AchievementStatusCompleted = 1"
      },
      {
        "code_key": "AchievementStatusFailed",
        "code_value": "const AchievementStatusFailed = 2"
      },
      {
        "code_key": "DBContextKey",
        "code_value": "const DBContextKey = \"db_context\""
      },
      {
        "code_key": "TableNameMethod",
        "code_value": "func (a *Achievement) TableName() string {\n\treturn CommentModerationTable\n}"
      }
    ]
  },
  "synthetic_对象const_chunk_QueryByCondition": {
    "scenario": "对象const+chunk",
    "code_key": "QueryByCondition",
    "code_value": "func (repo *NurseRepo) QueryByCondition(ctx context.Context, condition *model.NurseQueryCondition) ([]*model.Nurse, error) {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tvar nurses []*model.Nurse\n\n\tquery := repo.db.Clauses(selectClause).Table(model.NurseTableName)\n\tif condition.WardId > 0 {\n\t\tquery = query.Where(\"ward_id = ?\", condition.WardId)\n\t}\n\tif condition.ShiftType != \"\" {\n\t\tquery = query.Where(\"shift_type = ?\", condition.ShiftType)\n\t}\n\tif condition.IsCertified {\n\t\tquery = query.Where(\"certification_status = ?\", model.CertificationStatusActive)\n\t}\n\n\tif err := query.Find(&nurses).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn nurses, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleNurseShiftAssignment",
        "code_value": "func HandleNurseShiftAssignment(ctx context.Context, db *gorm.DB, wardID int, shiftType string) ([]*model.Nurse, error) {\n\tnurseRepo := &NurseRepo{db: db}\n\tcondition := &model.NurseQueryCondition{\n\t\tWardId:    wardID,\n\t\tShiftType: shiftType,\n\t\tIsCertified: true,\n\t}\n\n\tnurses, err := nurseRepo.QueryByCondition(ctx, condition)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to query nurses: %v\", err)\n\t}\n\n\tif len(nurses) == 0 {\n\t\treturn nil, errors.New(\"no certified nurses available for this shift\")\n\t}\n\n\treturn nurses, nil\n}"
      },
      {
        "code_key": "HandleWardStaffingReport",
        "code_value": "func HandleWardStaffingReport(ctx context.Context, db *gorm.DB) (map[int][]*model.Nurse, error) {\n\tnurseRepo := &NurseRepo{db: db}\n\tresult := make(map[int][]*model.Nurse)\n\n\tfor wardID := 1; wardID <= 5; wardID++ {\n\t\tcondition := &model.NurseQueryCondition{WardId: wardID}\n\t\tnurses, err := nurseRepo.QueryByCondition(ctx, condition)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to get nurses for ward %d: %v\", wardID, err)\n\t\t}\n\t\tresult[wardID] = nurses\n\t}\n\n\treturn result, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "PatientRepo",
        "code_value": "type PatientRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "PatientTableName",
        "code_value": "const PatientTableName = \"medical_patients\""
      },
      {
        "code_key": "PatientQueryCondition",
        "code_value": "type PatientQueryCondition struct {\n\tDepartmentId int\n\tBedNumber    string\n\tIsCritical   bool\n}"
      },
      {
        "code_key": "CriticalStatus",
        "code_value": "const CriticalStatus = 2"
      },
      {
        "code_key": "Patient",
        "code_value": "type Patient struct {\n\tId           int64  `gorm:\"column:id\" json:\"id\"`\n\tName         string `gorm:\"column:name\" json:\"name\"`\n\tAge          int    `gorm:\"column:age\" json:\"age\"`\n\tDepartmentId int    `gorm:\"column:department_id\" json:\"department_id\"`\n\tBedNumber    string `gorm:\"column:bed_number\" json:\"bed_number\"`\n\tStatus       int    `gorm:\"column:status\" json:\"status\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (p *Patient) TableName() string {\n\treturn PatientTableName\n}"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Expression {\n\tcommentInfo := GetCommentFromContext(ctx)\n\tcomment := fmt.Sprintf(\"app=%s,req_id=%s\", commentInfo.AppName, commentInfo.RequestID)\n\treturn clause.Comment(comment)"
      },
      {
        "code_key": "CommentInfo",
        "code_value": "type CommentInfo struct {\n\tAppName   string\n\tRequestID string\n}"
      },
      {
        "code_key": "GetCommentFromContext",
        "code_value": "func GetCommentFromContext(ctx context.Context) *CommentInfo {\n\tif v, ok := ctx.Value(commentCtxKey).(*CommentInfo); ok {\n\t\treturn v\n\t}\n\treturn &CommentInfo{}\n}"
      },
      {
        "code_key": "commentCtxKey",
        "code_value": "type contextKey string\n\nvar commentCtxKey = contextKey(\"sql_comment\")"
      }
    ]
  },
  "synthetic_对象const_chunk_RestoreDeletedClinic": {
    "scenario": "对象const+chunk",
    "code_key": "RestoreDeletedClinic",
    "code_value": "func (repo *ClinicRepo) RestoreDeletedClinic(ctx context.Context, licenseKey string) error {\n\trestoreClause := utils.SetSQLComment(ctx, utils.RestoreKey)\n\tclinic := &model.Clinic{}\n\n\tif err := repo.db.Clauses(restoreClause).Table(model.ClinicTableName).\n\t\tWhere(\"license_key = ? AND is_deleted = true\", licenseKey).\n\t\tFirst(&clinic).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif clinic.ID == 0 {\n\t\treturn errors.New(\"no deletable clinic found\")\n\t}\n\n\tif err := repo.db.Clauses(restoreClause).Table(model.ClinicTableName).\n\t\tWhere(\"license_key = ?\", licenseKey).\n\t\tUpdate(\"is_deleted\", false).Error; err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
    "sql_pattern_cnt": 2,
    "callers": [
      {
        "code_key": "HandleClinicRecovery",
        "code_value": "func HandleClinicRecovery(ctx context.Context, medicalLicense string, logger *zap.Logger) error {\n\tclinicStore := &ClinicRepo{db: globalDatabase}\n\tif err := clinicStore.RestoreDeletedClinic(ctx, medicalLicense); err != nil {\n\t\tlogger.Error(\"Failed to restore clinic\", zap.String(\"license\", medicalLicense), zap.Error(err))\n\t\treturn fmt.Errorf(\"clinic recovery failed: %w\", err)\n\t}\n\tlogger.Info(\"Successfully restored clinic\", zap.String(\"license\", medicalLicense))\n\treturn nil\n}"
      },
      {
        "code_key": "ProcessHospitalReactivation",
        "code_value": "func ProcessHospitalReactivation(credential string) error {\n\tctx := context.WithValue(context.Background(), utils.RestoreKey, \"system-auto-recovery\")\n\trepository := ClinicRepo{db: initializeDBConnection()}\n\tif err := repository.RestoreDeletedClinic(ctx, credential); err != nil {\n\t\tmetrics.Increment(\"clinic_restore_failure\")\n\t\treturn fmt.Errorf(\"reactivation failed for %s: %v\", credential, err)\n\t}\n\tmetrics.Increment(\"clinic_restore_success\")\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "ClinicRepo",
        "code_value": "type ClinicRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "RestoreKey",
        "code_value": "const RestoreKey = \"restore\""
      },
      {
        "code_key": "SecurityClearanceTableName",
        "code_value": "const SecurityClearanceTableName = \"security_clearances\""
      },
      {
        "code_key": "Clearance",
        "code_value": "type Clearance struct {\n\tID        uint   `gorm:\"primaryKey\"`\n\tClearanceLevel string `gorm:\"uniqueIndex\"`\n\tIsActive bool\n\tCreatedAt time.Time\n\tUpdatedAt time.Time\n}"
      },
      {
        "code_key": "hints",
        "code_value": "git.woa.com/common/gorm/hints"
      },
      {
        "code_key": "icontext",
        "code_value": "git.woa.com/common/context"
      },
      {
        "code_key": "uuid",
        "code_value": "github.com/google/uuid"
      },
      {
        "code_key": "ProductName",
        "code_value": "const ProductName = \"SecurityService\""
      },
      {
        "code_key": "SQLCommentInfo",
        "code_value": "type SQLCommentInfo struct {\n\tReqId   string\n\tAppId   string\n\tOwnerUin string\n\tSubUin  string\n\tAction  string\n}"
      },
      {
        "code_key": "GetSQLCommentFromContext",
        "code_value": "func GetSQLCommentFromContext(ctx context.Context) *SQLCommentInfo {\n\tif v := ctx.Value(commentCtxKey); v != nil {\n\t\treturn v.(*SQLCommentInfo)\n\t}\n\treturn &SQLCommentInfo{}\n}"
      }
    ]
  },
  "synthetic_对象const_chunk_VerifySignature": {
    "scenario": "对象const+chunk",
    "code_key": "VerifySignature",
    "code_value": "func (repo *CertificateRepo) VerifySignature(ctx context.Context, doc *model.TaxDocument) (bool, error) {\n\tsignClause := utils.SetSQLComment(ctx, \"verify_sign\")\n\tconst TaxDocTable = \"tax_documents\"\n\n\tvar existingDoc model.TaxDocument\n\terr := repo.db.Clauses(signClause).Table(TaxDocTable).\n\t\tWhere(\"document_id = ? AND location_code = ?\", doc.DocumentId, doc.LocationCode).\n\t\tFirst(&existingDoc).Error\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif existingDoc.SignatureHash != doc.SignatureHash {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleTaxDocVerification",
        "code_value": "func HandleTaxDocVerification(ctx context.Context, docID string, locCode string, sigHash string, logger *zap.Logger) (bool, error) {\n\trepo, err := data.NewCertificateRepo()\n\tif err != nil {\n\t\tlogger.Error(\"failed to initialize certificate repo\", zap.Error(err))\n\t\treturn false, err\n\t}\n\n\ttaxDoc := &model.TaxDocument{\n\t\tDocumentId:     docID,\n\t\tLocationCode:   locCode,\n\t\tSignatureHash:  sigHash,\n\t}\n\n\tisValid, err := repo.VerifySignature(ctx, taxDoc)\n\tif err != nil {\n\t\tlogger.Error(\"signature verification failed\", zap.Error(err))\n\t\treturn false, err\n\t}\n\n\treturn isValid, nil\n}"
      },
      {
        "code_key": "ProcessInvoiceSignature",
        "code_value": "func ProcessInvoiceSignature(ctx context.Context, invoice *model.Invoice, dbConfig *config.DB) (bool, error) {\n\trepo := &data.CertificateRepo{db: dbConfig.GetDB()}\n\n\tdoc := &model.TaxDocument{\n\t\tDocumentId:     invoice.DocRef,\n\t\tLocationCode:   invoice.RegionCode,\n\t\tSignatureHash:  invoice.DigitalSig,\n\t}\n\n\tverified, err := repo.VerifySignature(ctx, doc)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"signature verification error: %w\", err)\n\t}\n\n\tif !verified {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "CertificateRepo",
        "code_value": "type CertificateRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "TaxDocument",
        "code_value": "type TaxDocument struct {\n\tDocumentId     string `gorm:\"column:document_id\" json:\"document_id\"`\n\tLocationCode   string `gorm:\"column:location_code\" json:\"location_code\"`\n\tSignatureHash  string `gorm:\"column:signature_hash\" json:\"signature_hash\"`\n\tIssuerId       int64  `gorm:\"column:issuer_id\" json:\"issuer_id\"`\n\tExpirationDate int64  `gorm:\"column:expiration_date\" json:\"expiration_date\"`\n}"
      },
      {
        "code_key": "TaxDocTable",
        "code_value": "const TaxDocTable = \"tax_documents\""
      },
      {
        "code_key": "SignatureStatus",
        "code_value": "type SignatureStatus struct {\n\tIsValid      bool   `json:\"is_valid\"`\n\tErrorMessage string `json:\"error_message,omitempty\"`\n}"
      },
      {
        "code_key": "TaxDocumentFilter",
        "code_value": "type TaxDocumentFilter struct {\n\tDocumentId   string `json:\"document_id\"`\n\tLocationCode string `json:\"location_code\"`\n}"
      },
      {
        "code_key": "DocumentVerificationResult",
        "code_value": "type DocumentVerificationResult struct {\n\tIsSignatureValid bool `json:\"is_signature_valid\"`\n\tIsDocumentActive bool `json:\"is_document_active\"`\n}"
      },
      {
        "code_key": "MaxRetryCount",
        "code_value": "const MaxRetryCount = 3"
      },
      {
        "code_key": "DefaultTimeout",
        "code_value": "const DefaultTimeout = 30 * time.Second"
      },
      {
        "code_key": "VerificationCache",
        "code_value": "var VerificationCache = sync.Map{}"
      }
    ]
  },
  "synthetic_对象const_chunk_CheckIntegrity": {
    "scenario": "对象const+chunk",
    "code_key": "CheckIntegrity",
    "code_value": "func (repo *DeliveryRepo) CheckIntegrity(ctx context.Context, deliveryID string) (bool, error) {\n\tverifyClause := utils.SetSQLComment(ctx, utils.VerifyKey)\n\tdelivery := &Delivery{}\n\n\tif err := repo.db.Clauses(verifyClause).Table(model.DeliveryTableName).\n\t\tWhere(\"delivery_id = ?\", deliveryID).\n\t\tFirst(delivery).Error; err != nil {\n\t\treturn false, err\n\t}\n\n\tif delivery.Quantity <= 0 || delivery.City == \"\" {\n\t\treturn false, nil\n\t}\n\n\tif delivery.RefreshKey != model.DefaultRefreshKey {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "VerifyDeliveryStatus",
        "code_value": "func VerifyDeliveryStatus(deliveryIdentifier string) error {\n\tdeliveryRepo := &DeliveryRepo{db: GetDatabaseConnection()}\n\tisValid, err := deliveryRepo.CheckIntegrity(context.Background(), deliveryIdentifier)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to verify delivery: %v\", err)\n\t}\n\tif !isValid {\n\t\treturn errors.New(\"delivery integrity check failed\")\n\t}\n\treturn nil\n}"
      },
      {
        "code_key": "ProcessDeliveryBatch",
        "code_value": "func ProcessDeliveryBatch(deliveryIDs []string) ([]bool, error) {\n\trepo := NewDeliveryRepository()\n\tresults := make([]bool, len(deliveryIDs))\n\tfor idx, id := range deliveryIDs {\n\t\tstatus, err := repo.CheckIntegrity(context.TODO(), id)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"error checking delivery %s: %v\", id, err)\n\t\t}\n\t\tresults[idx] = status\n\t}\n\treturn results, nil\n}"
      },
      {
        "code_key": "ValidateShipmentRequest",
        "code_value": "func ValidateShipmentRequest(req *ShipmentRequest) (bool, error) {\n\tdbHandler := InitializeDeliveryRepo()\n\tvalid, err := dbHandler.CheckIntegrity(req.Ctx, req.DeliveryID)\n\tif err != nil {\n\t\tlog.Printf(\"Validation error for delivery %s: %v\", req.DeliveryID, err)\n\t\treturn false, err\n\t}\n\treturn valid, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "DeliveryRepo",
        "code_value": "type DeliveryRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Delivery",
        "code_value": "type Delivery struct {\n\tDeliveryID   string `gorm:\"column:delivery_id\" json:\"delivery_id\"`\n\tQuantity     int    `gorm:\"column:quantity\" json:\"quantity\"`\n\tCity         string `gorm:\"column:city\" json:\"city\"`\n\tRefreshKey   string `gorm:\"column:refresh_key\" json:\"refresh_key\"`\n\tCreatedAt    int64  `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt    int64  `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "DeliveryTableName",
        "code_value": "const DeliveryTableName = \"delivery_orders\""
      },
      {
        "code_key": "DefaultRefreshKey",
        "code_value": "const DefaultRefreshKey = \"DEFAULT_KEY_123\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (d *Delivery) TableName() string {\n\treturn DeliveryTableName\n}"
      },
      {
        "code_key": "VerifyKey",
        "code_value": "const VerifyKey = \"VERIFY\""
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/pkg/utils"
      },
      {
        "code_key": "hints",
        "code_value": "gorm.io/hints"
      }
    ]
  },
  "synthetic_对象const_chunk_UpdateQuizStatistics": {
    "scenario": "对象const+chunk",
    "code_key": "UpdateQuizStatistics",
    "code_value": "func (repo *QuizRepo) UpdateQuizStatistics(ctx context.Context, quiz *model.QuizStat) error {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\toldStat := &model.QuizStat{}\n\n\tif err := repo.db.Clauses(selectClause).Table(model.QuizStatTableName).\n\t\tWhere(\"quiz_id = ?\", quiz.QuizId).\n\t\tFirst(oldStat).Error; err != nil {\n\t\t\treturn err\n\t}\n\n\tif oldStat.RegistrationTime != quiz.RegistrationTime || oldStat.Volume != quiz.Volume {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.QuizStatTableName).\n\t\t\tWhere(\"id = ?\", oldStat.Id).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"registration_time\": quiz.RegistrationTime,\n\t\t\t\t\"volume\":           quiz.Volume,\n\t\t\t}).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "sql_pattern_cnt": 2,
    "callers": [
      {
        "code_key": "HandleQuizStatusUpdate",
        "code_value": "func HandleQuizStatusUpdate(ctx context.Context, quizID string, newRegTime int64, newVolume int) error {\n\tquizRepo, err := NewQuizRepo()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to initialize quiz repo: %v\", err)\n\t}\n\n\tquizStat := &model.QuizStat{\n\t\tQuizId:           quizID,\n\t\tRegistrationTime: newRegTime,\n\t\tVolume:           newVolume,\n\t}\n\n\tif err := quizRepo.UpdateQuizStatistics(ctx, quizStat); err != nil {\n\t\treturn fmt.Errorf(\"failed to update quiz statistics: %v\", err)\n\t}\n\treturn nil\n}"
      },
      {
        "code_key": "ProcessTrainingResult",
        "code_value": "func ProcessTrainingResult(ctx context.Context, trainingData *model.TrainingSession) error {\n\trepo, err := data.NewQuizRepository()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tquizStat := &model.QuizStat{\n\t\tQuizId:           trainingData.QuizID,\n\t\tRegistrationTime: trainingData.CompletionTime,\n\t\tVolume:           trainingData.QuestionsAttempted,\n\t}\n\n\tif err := repo.UpdateQuizStatistics(ctx, quizStat); err != nil {\n\t\tlog.Printf(\"Failed to process training result: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "QuizStat",
        "code_value": "type QuizStat struct {\n\tId               int64  `gorm:\"column:id\" json:\"id\"`\n\tQuizId           string `gorm:\"column:quiz_id\" json:\"quiz_id\"`\n\tRegistrationTime int64  `gorm:\"column:registration_time\" json:\"registration_time\"`\n\tVolume           int    `gorm:\"column:volume\" json:\"volume\"`\n}"
      },
      {
        "code_key": "QuizStatTableName",
        "code_value": "const QuizStatTableName = \"t_quiz_statistics\""
      },
      {
        "code_key": "QuizRepo",
        "code_value": "type QuizRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "selectClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SelectKey)"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/quiz-platform/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clauser.Clause {\n\tcommentInfo := contextx.GetCommentInfo(ctx)\n\tif commentInfo == nil {\n\t\tcommentInfo = &contextx.CommentInfo{RequestID: uuid.NewString()}\n\t}\n\tcomment := fmt.Sprintf(\"app=%s,req=%s\", commentInfo.AppName, commentInfo.RequestID)\n\treturn clauser.Comment(clause, comment)\n}"
      },
      {
        "code_key": "contextx",
        "code_value": "git.woa.com/IVC/common/contextx"
      },
      {
        "code_key": "clauser",
        "code_value": "git.woa.com/IVC/gorm/clauser"
      }
    ]
  },
  "synthetic_对象const_chunk_TrackInventoryMovement": {
    "scenario": "对象const+chunk",
    "code_key": "TrackInventoryMovement",
    "code_value": "func (repo *InventoryRepo) TrackInventoryMovement(ctx context.Context, widget *model.Widget) error {\n    selectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n    updateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n    \n    existing := &model.Widget{}\n    if err := repo.db.Clauses(selectClause).Table(model.InventoryItemsTableName).\n        Where(\"tracking_id = ?\", widget.TrackingId).\n        First(existing).Error; err != nil {\n        if errors.Is(err, gorm.ErrRecordNotFound) {\n            return repo.db.Table(model.InventoryItemsTableName).Create(widget).Error\n        }\n        return err\n    }\n\n    if existing.Points != widget.Points || existing.Weight != widget.Weight {\n        return repo.db.Clauses(updateClause).Table(model.InventoryItemsTableName).\n            Where(\"id = ?\", existing.Id).\n            Updates(map[string]interface{}{\n                \"points\": widget.Points,\n                \"weight\": widget.Weight,\n            }).Error\n    }\n    return nil\n}",
    "sql_pattern_cnt": 3,
    "callers": [
      {
        "code_key": "HandleInventoryUpdates",
        "code_value": "func HandleInventoryUpdates(ctx context.Context, db *gorm.DB, items []*model.Widget) error {\n    repo := &InventoryRepo{db: db}\n    for _, item := range items {\n        if err := repo.TrackInventoryMovement(ctx, item); err != nil {\n            return fmt.Errorf(\"failed to track inventory for item %s: %v\", item.TrackingId, err)\n        }\n    }\n    return nil\n}"
      },
      {
        "code_key": "ProcessWarehouseTransfer",
        "code_value": "func ProcessWarehouseTransfer(ctx context.Context, db *gorm.DB, sourceItem, destItem *model.Widget) error {\n    repo := &InventoryRepo{db: db}\n    \n    if err := repo.TrackInventoryMovement(ctx, sourceItem); err != nil {\n        return fmt.Errorf(\"source item update failed: %v\", err)\n    }\n    \n    if err := repo.TrackInventoryMovement(ctx, destItem); err != nil {\n        return fmt.Errorf(\"destination item update failed: %v\", err)\n    }\n    \n    return nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "InventoryRepo",
        "code_value": "type InventoryRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Widget",
        "code_value": "type Widget struct {\n\tId        int64   `gorm:\"column:id\" json:\"id\"`\n\tTrackingId string  `gorm:\"column:tracking_id\" json:\"tracking_id\"`\n\tPoints    float64 `gorm:\"column:points\" json:\"points\"`\n\tWeight    float64 `gorm:\"column:weight\" json:\"weight\"`\n}"
      },
      {
        "code_key": "InventoryItemsTableName",
        "code_value": "const InventoryItemsTableName = \"inventory_items\""
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "SQLCommentInfo",
        "code_value": "type SQLCommentInfo struct {\n\tReqId   string\n\tAppId   string\n\tOwnerUin string\n\tSubUin  string\n\tAction  string\n}"
      },
      {
        "code_key": "hints",
        "code_value": "import \"gorm.io/hints\""
      },
      {
        "code_key": "GetSQLCommentFromContext",
        "code_value": "func GetSQLCommentFromContext(ctx context.Context) SQLCommentInfo {\n\t// implementation details\n\treturn SQLCommentInfo{}\n}"
      },
      {
        "code_key": "icontext",
        "code_value": "import \"git.woa.com/IVC/ivc-event-alarm/pkg/icontext\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (w *Widget) TableName() string {\n\treturn InventoryItemsTableName\n}"
      }
    ]
  },
  "synthetic_对象const_chunk_UpdateEntity": {
    "scenario": "对象const+chunk",
    "code_key": "UpdateEntity",
    "code_value": "func (r *VendorRepo) UpdateEntity(ctx context.Context, entity *model.Layout) error {\n    selectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n    updateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n    oldEntity := &model.Layout{}\n\n    if err := r.db.Clauses(selectClause).Table(model.LayoutTableName).\n        Where(\"namespace_name = ?\", entity.NamespaceName).\n        First(oldEntity).Error; err != nil {\n        return err\n    }\n\n    if oldEntity.Genre != entity.Genre {\n        if err := r.db.Clauses(updateClause).Table(model.LayoutTableName).\n            Where(\"id = ?\", oldEntity.ID).\n            Update(\"genre\", entity.Genre).Error; err != nil {\n            return err\n        }\n    }\n\n    return nil\n}",
    "sql_pattern_cnt": 2,
    "callers": [
      {
        "code_key": "HandleEventLayoutUpdate",
        "code_value": "func HandleEventLayoutUpdate(ctx context.Context, db *gorm.DB, namespace string, genre int) error {\n    repo := &VendorRepo{db: db}\n    layout := &model.Layout{\n        NamespaceName: namespace,\n        Genre:        genre,\n    }\n    \n    if err := repo.UpdateEntity(ctx, layout); err != nil {\n        log.Printf(\"Failed to update layout: %v\", err)\n        return fmt.Errorf(\"update layout failed: %w\", err)\n    }\n    \n    return nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "PublicationRepo",
        "code_value": "type PublicationRepo struct {\n    db *gorm.DB\n}"
      },
      {
        "code_key": "QuestTableName",
        "code_value": "const QuestTableName = \"quest_publications\""
      },
      {
        "code_key": "Quest",
        "code_value": "type Quest struct {\n    ID           int64  `gorm:\"column:id\"`\n    Title        string `gorm:\"column:title\"`\n    Status       int    `gorm:\"column:status\"`\n    PublisherID  int64  `gorm:\"column:publisher_id\"`\n}"
      },
      {
        "code_key": "selectClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SelectKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/core/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) hints.Hints {\n    commentInfo := icontext.GetSQLCommentFromContext(ctx)\n    if commentInfo.RequestID == \"\" {\n        commentInfo.RequestID = uuid.New().String()\n    }\n    comment := fmt.Sprintf(\"app=%s,req=%s\", commentInfo.AppName, commentInfo.RequestID)\n    return hints.CommentBefore(clause, comment)\n}"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      },
      {
        "code_key": "PublicationStatus",
        "code_value": "const (\n    Draft = iota\n    Published\n    Archived\n)"
      },
      {
        "code_key": "oldQuest",
        "code_value": "&model.Quest{}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (q *Quest) TableName() string {\n    return QuestTableName\n}"
      }
    ]
  },
  "synthetic_对象const_chunk_AuthorizeAccess": {
    "scenario": "对象const+chunk",
    "code_key": "AuthorizeAccess",
    "code_value": "func (repo *CreditRepo) AuthorizeAccess(ctx context.Context, credit *model.CreditDimension) error {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\texistingCredit := &model.CreditDimension{}\n\n\tif err := repo.db.Clauses(queryClause).Table(model.CreditDimensionTableName).\n\t\tWhere(\"end_date > ? AND dimension = ?\", time.Now().Unix(), credit.Dimension).\n\t\tFirst(existingCredit).Error; err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn errors.New(\"credit authorization failed: no valid record found\")\n\t\t}\n\t\treturn err\n\t}\n\n\tif existingCredit.FullName != credit.FullName {\n\t\treturn errors.New(\"credit authorization failed: name mismatch\")\n\t}\n\n\treturn nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleCreditValidation",
        "code_value": "func HandleCreditValidation(ctx context.Context, userCred *model.CreditDimension, dbConn *gorm.DB) error {\n\tcreditRepo := &CreditRepo{db: dbConn}\n\tif err := creditRepo.AuthorizeAccess(ctx, userCred); err != nil {\n\t\tlog.Printf(\"credit validation failed: %v\", err)\n\t\treturn fmt.Errorf(\"cannot validate credit: %w\", err)\n\t}\n\tlog.Println(\"credit validation successful\")\n\treturn nil\n}"
      },
      {
        "code_key": "ProcessUserAccess",
        "code_value": "func ProcessUserAccess(ctx context.Context, accessDetails *model.CreditDimension) (bool, error) {\n\tdbInstance := config.GetDatabase()\n\tif dbInstance == nil {\n\t\treturn false, errors.New(\"database connection not available\")\n\t}\n\n\tvalidator := CreditRepo{db: dbInstance}\n\terr := validator.AuthorizeAccess(ctx, accessDetails)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"access denied: %w\", err)\n\t}\n\treturn true, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "CreditRepo",
        "code_value": "type CreditRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "CreditDimensionTableName",
        "code_value": "const CreditDimensionTableName = \"credit_dimension\""
      },
      {
        "code_key": "CreditDimension",
        "code_value": "type CreditDimension struct {\n\tID        int64  `gorm:\"column:id\" json:\"id\"`\n\tFullName  string `gorm:\"column:full_name\" json:\"full_name\"`\n\tDimension string `gorm:\"column:dimension\" json:\"dimension\"`\n\tEndDate   int64  `gorm:\"column:end_date\" json:\"end_date\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (cd *CreditDimension) TableName() string {\n\treturn CreditDimensionTableName\n}"
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"query\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-credit/pkg/utils"
      },
      {
        "code_key": "existingCredit",
        "code_value": "&model.CreditDimension{}"
      },
      {
        "code_key": "TimeNow",
        "code_value": "time.Now().Unix()"
      },
      {
        "code_key": "ErrRecordNotFound",
        "code_value": "gorm.ErrRecordNotFound"
      },
      {
        "code_key": "AuthErrorMsg",
        "code_value": "const AuthErrorMsg = \"credit authorization failed\""
      }
    ]
  },
  "synthetic_对象const_chunk_MoveToArchive": {
    "scenario": "对象const+chunk",
    "code_key": "MoveToArchive",
    "code_value": "func (repo *TextbookRepo) MoveToArchive(ctx context.Context, textbook *model.Textbook) error {\n\tarchiveClause := utils.SetSQLComment(ctx, utils.ArchiveKey)\n\tactiveClause := utils.SetSQLComment(ctx, utils.ActiveKey)\n\n\t// Check if textbook exists in active table\n\tvar existingTextbook model.Textbook\n\tif err := repo.db.Clauses(activeClause).Table(model.TextbookActiveTableName).\n\t\tWhere(\"tracking_id = ?\", textbook.TrackingId).\n\t\tFirst(&existingTextbook).Error; err != nil {\n\t\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\t\treturn fmt.Errorf(\"textbook not found\")\n\t\t\t}\n\t\t\treturn err\n\t}\n\n\t// Move to archive\n\tif err := repo.db.Clauses(archiveClause).Table(model.TextbookArchiveTableName).\n\t\tCreate(textbook).Error; err != nil {\n\t\t\treturn err\n\t}\n\n\t// Delete from active\n\tif err := repo.db.Clauses(activeClause).Table(model.TextbookActiveTableName).\n\t\tWhere(\"tracking_id = ?\", textbook.TrackingId).\n\t\tDelete(&model.Textbook{}).Error; err != nil {\n\t\t\treturn err\n\t}\n\n\treturn nil\n}",
    "sql_pattern_cnt": 3,
    "callers": [
      {
        "code_key": "HandleTextbookRetirement",
        "code_value": "func HandleTextbookRetirement(ctx context.Context, trackingID string) error {\n\trepo := &TextbookRepo{db: GetDBInstance()}\n\tbook := &model.Textbook{TrackingId: trackingID}\n\tif err := repo.MoveToArchive(ctx, book); err != nil {\n\t\tlog.Printf(\"Failed to retire textbook %s: %v\", trackingID, err)\n\t\treturn err\n\t}\n\tlog.Printf(\"Successfully retired textbook %s\", trackingID)\n\treturn nil\n}"
      },
      {
        "code_key": "ProcessExpiredTextbooks",
        "code_value": "func ProcessExpiredTextbooks(ctx context.Context, bookList []*model.Textbook) error {\n\trepo := &TextbookRepo{db: InitDatabaseConnection()}\n\tfor _, item := range bookList {\n\t\tif item == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif err := repo.MoveToArchive(ctx, item); err != nil {\n\t\t\tlog.Printf(\"Failed to archive textbook %s: %v\", item.TrackingId, err)\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "TextbookRepo",
        "code_value": "type TextbookRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Textbook",
        "code_value": "type Textbook struct {\n\tTrackingId    string `gorm:\"column:tracking_id\" json:\"tracking_id\"`\n\tTitle         string `gorm:\"column:title\" json:\"title\"`\n\tAuthor        string `gorm:\"column:author\" json:\"author\"`\n\tPublisher     string `gorm:\"column:publisher\" json:\"publisher\"`\n\tPublishedYear int    `gorm:\"column:published_year\" json:\"published_year\"`\n}"
      },
      {
        "code_key": "TextbookActiveTableName",
        "code_value": "const TextbookActiveTableName = \"textbook_active\""
      },
      {
        "code_key": "TextbookArchiveTableName",
        "code_value": "const TextbookArchiveTableName = \"textbook_archive\""
      },
      {
        "code_key": "ArchiveKey",
        "code_value": "const ArchiveKey = \"archive\""
      },
      {
        "code_key": "ActiveKey",
        "code_value": "const ActiveKey = \"active\""
      },
      {
        "code_key": "hints",
        "code_value": "import \"gorm.io/hints\""
      },
      {
        "code_key": "icontext",
        "code_value": "import \"git.woa.com/common/icontext\""
      },
      {
        "code_key": "model",
        "code_value": "import \"git.woa.com/edu/model\""
      },
      {
        "code_key": "utils",
        "code_value": "import \"git.woa.com/common/utils\""
      }
    ]
  },
  "synthetic_对象const_chunk_UpdateThemeWeights": {
    "scenario": "对象const+chunk",
    "code_key": "UpdateThemeWeights",
    "code_value": "func (repo *ThemeRepo) UpdateThemeWeights(ctx context.Context, theme *model.PortfolioTheme) error {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\texisting := &model.PortfolioTheme{}\n\n\tif err := repo.db.Clauses(selectClause).Table(model.ThemeTableName).\n\t\tWhere(\"theme_id = ? AND city = ?\", theme.ThemeId, theme.City).\n\t\tFirst(existing).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif existing.Weight != theme.Weight {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.ThemeTableName).\n\t\t\tWhere(\"id = ?\", existing.Id).\n\t\t\tUpdate(\"weight\", theme.Weight).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "sql_pattern_cnt": 2,
    "callers": [
      {
        "code_key": "HandlePortfolioThemeUpdate",
        "code_value": "func HandlePortfolioThemeUpdate(ctx context.Context, themeID string, city string, newWeight float64) error {\n\trepo, err := NewThemeRepo()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create theme repo: %v\", err)\n\t}\n\n\ttheme := &model.PortfolioTheme{\n\t\tThemeId: themeID,\n\t\tCity:    city,\n\t\tWeight:  newWeight,\n\t}\n\n\tif err := repo.UpdateThemeWeights(ctx, theme); err != nil {\n\t\treturn fmt.Errorf(\"failed to update theme weights: %v\", err)\n\t}\n\n\treturn nil\n}"
      },
      {
        "code_key": "ProcessThemeAdjustment",
        "code_value": "func ProcessThemeAdjustment(ctx context.Context, adjustment *model.ThemeAdjustment) error {\n\tdb := conf.GetDBEngine()\n\tif db == nil {\n\t\treturn fmt.Errorf(\"database engine not available\")\n\t}\n\n\trepo := &ThemeRepo{db: db}\n\ttheme := &model.PortfolioTheme{\n\t\tThemeId: adjustment.ID,\n\t\tCity:    adjustment.Location,\n\t\tWeight:  adjustment.TargetWeight,\n\t}\n\n\tif err := repo.UpdateThemeWeights(ctx, theme); err != nil {\n\t\treturn fmt.Errorf(\"theme adjustment failed: %v\", err)\n\t}\n\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "ThemeRepo",
        "code_value": "type ThemeRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "PortfolioTheme",
        "code_value": "type PortfolioTheme struct {\n\tId      int64   `gorm:\"column:id\" json:\"id\"`\n\tThemeId string  `gorm:\"column:theme_id\" json:\"theme_id\"`\n\tCity    string  `gorm:\"column:city\" json:\"city\"`\n\tWeight  float64 `gorm:\"column:weight\" json:\"weight\"`\n}"
      },
      {
        "code_key": "ThemeTableName",
        "code_value": "const ThemeTableName = \"portfolio_theme\""
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (pt *PortfolioTheme) TableName() string {\n\treturn ThemeTableName\n}"
      },
      {
        "code_key": "existingTheme",
        "code_value": "&model.PortfolioTheme{}"
      },
      {
        "code_key": "WeightThreshold",
        "code_value": "const WeightThreshold = 0.01"
      },
      {
        "code_key": "DefaultCity",
        "code_value": "const DefaultCity = \"Shanghai\""
      }
    ]
  },
  "synthetic_对象const_chunk_LogActivity": {
    "scenario": "对象const+chunk",
    "code_key": "LogActivity",
    "code_value": "func (repo *ActivityRepo) LogActivity(ctx context.Context, activity *model.Exam) error {\n    selectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n    insertClause := utils.SetSQLComment(ctx, utils.InsertKey)\n    \n    existing := &model.Exam{}\n    if err := repo.db.Clauses(selectClause).Table(model.ExamTableName).\n        Where(\"topic = ? AND function_name = ?\", activity.Topic, activity.FunctionName).\n        First(existing).Error; err != nil {\n        \n        if errors.Is(err, gorm.ErrRecordNotFound) {\n            return repo.db.Clauses(insertClause).Table(model.ExamTableName).\n                Create(activity).Error\n        }\n        return err\n    }\n    \n    if existing.DiscountRate != activity.DiscountRate {\n        return repo.db.Table(model.ExamTableName).\n            Where(\"id = ?\", existing.Id).\n            Update(\"discount_rate\", activity.DiscountRate).Error\n    }\n    return nil\n}",
    "sql_pattern_cnt": 3,
    "callers": [
      {
        "code_key": "HandleExamDiscount",
        "code_value": "func HandleExamDiscount(ctx context.Context, topic string, fnName string, rate float64) error {\n    repo := &ActivityRepo{db: GetDB()}\n    exam := &model.Exam{\n        Topic:        topic,\n        FunctionName: fnName,\n        DiscountRate: rate,\n    }\n    return repo.LogActivity(ctx, exam)\n}"
      },
      {
        "code_key": "ProcessLearningActivity",
        "code_value": "func ProcessLearningActivity(ctx context.Context, learningData *model.LearningData) error {\n    activityRepo := NewActivityRepo(GetDB())\n    exam := &model.Exam{\n        Topic:        learningData.CourseID,\n        FunctionName: \"course_completion\",\n        DiscountRate: learningData.Discount,\n    }\n    if err := activityRepo.LogActivity(ctx, exam); err != nil {\n        log.Printf(\"Failed to log activity: %v\", err)\n        return err\n    }\n    return nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "ActivityRepo",
        "code_value": "type ActivityRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Exam",
        "code_value": "type Exam struct {\n\tId           int64   `gorm:\"column:id\" json:\"id\"`\n\tTopic        string  `gorm:\"column:topic\" json:\"topic\"`\n\tFunctionName string  `gorm:\"column:function_name\" json:\"function_name\"`\n\tDiscountRate float64 `gorm:\"column:discount_rate\" json:\"discount_rate\"`\n}"
      },
      {
        "code_key": "ExamTableName",
        "code_value": "const ExamTableName = \"ivc_exam_records\""
      },
      {
        "code_key": "selectClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SelectKey)"
      },
      {
        "code_key": "insertClause",
        "code_value": "utils.SetSQLComment(ctx, utils.InsertKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-exam-system/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) hints.Hints {\n\tcommentInfo := icontext.GetSQLCommentFromContext(ctx)\n\tif len(commentInfo.ReqId) < 16 {\n\t\tcommentInfo.ReqId = uuid.NewString()\n\t}\n\n\tcomment := fmt.Sprintf(\"system=exam,app=%v,uin=%v,action=%v,reqid=%v\", \n\t\tcommentInfo.AppId, commentInfo.OwnerUin, commentInfo.Action, commentInfo.ReqId)\n\treturn hints.CommentBefore(clause, comment)\n}"
      },
      {
        "code_key": "existingExam",
        "code_value": "&model.Exam{}"
      }
    ]
  },
  "synthetic_对象const_chunk_DetectFraud": {
    "scenario": "对象const+chunk",
    "code_key": "DetectFraud",
    "code_value": "func (repo *FraudDetectionRepo) DetectFraud(ctx context.Context, invoice *model.Invoice) (bool, error) {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tthreshold := model.FraudDetectionThreshold\n\t\n\texistingInvoice := &model.Invoice{}\n\tif err := repo.db.Clauses(selectClause).Table(model.InvoiceTableName).\n\t\tWhere(\"reference_code = ?\", invoice.ReferenceCode).\n\t\tFirst(existingInvoice).Error; err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\t\n\tif existingInvoice.Amount > threshold && existingInvoice.Amount != invoice.Amount {\n\t\treturn true, nil\n\t}\n\t\n\treturn false, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "ProcessInvoicePayment",
        "code_value": "func ProcessInvoicePayment(ctx context.Context, paymentReq *model.PaymentRequest, logger *zap.Logger) (bool, error) {\n\tfraudRepo, err := data.NewFraudDetectionRepo()\n\tif err != nil {\n\t\tlogger.Error(\"failed to initialize fraud detection repo\", zap.Error(err))\n\t\treturn false, err\n\t}\n\n\tinvoice := &model.Invoice{\n\t\tReferenceCode: paymentReq.InvoiceID,\n\t\tAmount:       paymentReq.Amount,\n\t}\n\n\tisFraud, err := fraudRepo.DetectFraud(ctx, invoice)\n\tif err != nil {\n\t\tlogger.Error(\"fraud detection failed\", zap.Error(err))\n\t\treturn false, err\n\t}\n\treturn isFraud, nil\n}"
      },
      {
        "code_key": "VerifyInvoiceForRefund",
        "code_value": "func VerifyInvoiceForRefund(ctx context.Context, refundDetail *model.RefundDetail) (bool, error) {\n\tdbEngine := conf.GetDBEngine()\n\tif dbEngine == nil {\n\t\treturn false, errors.New(\"database engine not initialized\")\n\t}\n\n\tfraudRepo := &data.FraudDetectionRepo{db: dbEngine}\n\tinvoice := &model.Invoice{\n\t\tReferenceCode: refundDetail.OriginalInvoiceID,\n\t\tAmount:       refundDetail.RefundAmount,\n\t}\n\n\treturn fraudRepo.DetectFraud(ctx, invoice)"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "FraudDetectionRepo",
        "code_value": "type FraudDetectionRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "InvoiceTableName",
        "code_value": "const InvoiceTableName = \"finance_invoice\""
      },
      {
        "code_key": "FraudDetectionThreshold",
        "code_value": "const FraudDetectionThreshold = 10000.00"
      },
      {
        "code_key": "Invoice",
        "code_value": "type Invoice struct {\n\tID           int64   `gorm:\"column:id\" json:\"id\"`\n\tReferenceCode string  `gorm:\"column:reference_code\" json:\"reference_code\"`\n\tAmount       float64 `gorm:\"column:amount\" json:\"amount\"`\n\tStatus       int     `gorm:\"column:status\" json:\"status\"`\n\tCreatedAt    int64   `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (i *Invoice) TableName() string {\n\treturn InvoiceTableName\n}"
      },
      {
        "code_key": "InvoiceStatus",
        "code_value": "const (\n\tInvoiceStatusPending = 1\n\tInvoiceStatusPaid = 2\n\tInvoiceStatusCancelled = 3\n)"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/Finance/fraud-detection/pkg/utils"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"select\""
      },
      {
        "code_key": "FraudDetectionConfig",
        "code_value": "type FraudDetectionConfig struct {\n\tThreshold float64 `json:\"threshold\"`\n\tEnabled   bool    `json:\"enabled\"`\n}"
      }
    ]
  },
  "synthetic_对象const_chunk_ValidateByRules": {
    "scenario": "对象const+chunk",
    "code_key": "ValidateByRules",
    "code_value": "func (repo *CertificationRepo) ValidateByRules(ctx context.Context, cert *model.CertificationRecord) (bool, error) {\n\tvalidationClause := utils.SetSQLComment(ctx, utils.ValidationKey)\n\tvar existingCert model.CertificationRecord\n\n\tif err := repo.db.Clauses(validationClause).Table(model.CertificationTableName).\n\t\tWhere(\"license_key = ?\", cert.LicenseKey).\n\t\tFirst(&existingCert).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif existingCert.ExpiryDate < time.Now().Unix() {\n\t\treturn false, nil\n\t}\n\n\tif existingCert.LocationCode != cert.LocationCode {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleLicenseVerification",
        "code_value": "func HandleLicenseVerification(ctx context.Context, licenseKey string, locCode string) (bool, error) {\n\trepo, err := NewCertificationRepo()\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"failed to init repo: %v\", err)\n\t}\n\n\tcertRecord := &model.CertificationRecord{\n\t\tLicenseKey:   licenseKey,\n\t\tLocationCode: locCode,\n\t}\n\n\tisValid, err := repo.ValidateByRules(ctx, certRecord)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"validation failed: %v\", err)\n\t}\n\n\treturn isValid, nil\n}"
      },
      {
        "code_key": "BatchCheckCertifications",
        "code_value": "func BatchCheckCertifications(ctx context.Context, certs []*model.CertificationRecord) ([]bool, error) {\n\trepo, err := NewCertificationRepo()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresults := make([]bool, len(certs))\n\tfor i, cert := range certs {\n\t\tvalid, err := repo.ValidateByRules(ctx, cert)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresults[i] = valid\n\t}\n\n\treturn results, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "CertificationRepo",
        "code_value": "type CertificationRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "CertificationRecord",
        "code_value": "type CertificationRecord struct {\n\tID           int64  `gorm:\"column:id\" json:\"id\"`\n\tLicenseKey   string `gorm:\"column:license_key\" json:\"license_key\"`\n\tExpiryDate   int64  `gorm:\"column:expiry_date\" json:\"expiry_date\"`\n\tLocationCode string `gorm:\"column:location_code\" json:\"location_code\"`\n}"
      },
      {
        "code_key": "CertificationTableName",
        "code_value": "const CertificationTableName = \"certification_records\""
      },
      {
        "code_key": "ValidationKey",
        "code_value": "const ValidationKey = \"VALIDATION\""
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/common/pkg/utils"
      },
      {
        "code_key": "ValidationResult",
        "code_value": "type ValidationResult struct {\n\tIsValid bool\n\tError   error\n}"
      },
      {
        "code_key": "TimeUtils",
        "code_value": "var TimeUtils = struct {\n\tNow func() time.Time\n}{\n\tNow: time.Now,\n}"
      },
      {
        "code_key": "ErrorMessages",
        "code_value": "var ErrorMessages = map[string]string{\n\t\"INVALID_LICENSE\": \"License key is invalid\",\n\t\"EXPIRED\":        \"License has expired\",\n\t\"LOCATION_MISMATCH\": \"Location code does not match\"\n}"
      }
    ]
  },
  "synthetic_对象const_chunk_SoftDelete": {
    "scenario": "对象const+chunk",
    "code_key": "SoftDelete",
    "code_value": "func (repo *SurgeryRepo) SoftDelete(ctx context.Context, scheduleID string) error {\n    selectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n    updateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n    const SurgeryScheduleTableName = \"surgery_schedules\"\n\n    existing := &model.Layout{}\n    if err := repo.db.Clauses(selectClause).Table(SurgeryScheduleTableName).\n        Where(\"unique_key = ?\", scheduleID).\n        First(existing).Error; err != nil {\n        return err\n    }\n\n    if existing.DiscountRate > 0 {\n        return errors.New(\"discounted schedules cannot be deleted\")\n    }\n\n    return repo.db.Clauses(updateClause).Table(SurgeryScheduleTableName).\n        Where(\"unique_key = ?\", scheduleID).\n        Update(\"is_deleted\", true).Error\n}",
    "sql_pattern_cnt": 2,
    "callers": [
      {
        "code_key": "HandleScheduleCleanup",
        "code_value": "func HandleScheduleCleanup(ctx context.Context, scheduleIDs []string, logger *zap.Logger) error {\n\trepo := &SurgeryRepo{db: GetDBInstance()}\n\tfor _, id := range scheduleIDs {\n\t\tif err := repo.SoftDelete(ctx, id); err != nil {\n\t\t\tlogger.Error(\"failed to soft delete schedule\", zap.String(\"id\", id), zap.Error(err))\n\t\t\tif err.Error() == \"discounted schedules cannot be deleted\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}"
      },
      {
        "code_key": "RemoveExpiredSchedules",
        "code_value": "func RemoveExpiredSchedules(ctx context.Context) (int, error) {\n\trepo := &SurgeryRepo{db: global.DB}\n\texpiredIDs := fetchExpiredScheduleIDs(ctx)\n\tcount := 0\n\tfor _, id := range expiredIDs {\n\t\tif err := repo.SoftDelete(ctx, id); err == nil {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "SurgeryRepo",
        "code_value": "type SurgeryRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Layout",
        "code_value": "type Layout struct {\n\tUniqueKey     string  `gorm:\"column:unique_key\"`\n\tDiscountRate  float64 `gorm:\"column:discount_rate\"`\n\tIsDeleted     bool    `gorm:\"column:is_deleted\"`\n}"
      },
      {
        "code_key": "SurgeryScheduleTableName",
        "code_value": "const SurgeryScheduleTableName = \"surgery_schedules\""
      },
      {
        "code_key": "selectClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SelectKey)"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/medical/surgery/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Expression {\n\tcommentInfo := ctx.Value(\"sql_comment\").(utils.SQLComment)\n\tcomment := fmt.Sprintf(\"/* app=%s,req=%s */\", commentInfo.AppID, commentInfo.RequestID)\n\treturn clause.Expr{SQL: comment + \" \" + clause}\n}"
      },
      {
        "code_key": "SQLComment",
        "code_value": "type SQLComment struct {\n\tAppID     string\n\tRequestID string\n}"
      }
    ]
  },
  "synthetic_对象const_chunk_UpdateInventory": {
    "scenario": "对象const+chunk",
    "code_key": "UpdateInventory",
    "code_value": "func (repo *MedicationRepo) UpdateInventory(ctx context.Context, profile *model.MedicationProfile) error {\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\tcurrent := &model.MedicationProfile{}\n\n\tif err := repo.db.Table(model.MedicationInventoryTableName).\n\t\tWhere(\"region_code = ? AND room = ?\", profile.RegionCode, profile.Room).\n\t\tFirst(current).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif current.CurrentStatus != profile.CurrentStatus {\n\t\treturn repo.db.Clauses(updateClause).Table(model.MedicationInventoryTableName).\n\t\t\tWhere(\"id = ?\", current.Id).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"current_status\": profile.CurrentStatus,\n\t\t\t\t\"last_update\":   time.Now().Unix(),\n\t\t\t}).Error\n\t}\n\n\treturn nil\n}",
    "sql_pattern_cnt": 2,
    "callers": [
      {
        "code_key": "HandleMedicationStatusUpdate",
        "code_value": "func HandleMedicationStatusUpdate(ctx context.Context, region string, room string, newStatus int) error {\n\trepo := &MedicationRepo{db: GetDBInstance()}\n\tprofile := &model.MedicationProfile{\n\t\tRegionCode:    region,\n\t\tRoom:          room,\n\t\tCurrentStatus: newStatus,\n\t}\n\n\tif err := repo.UpdateInventory(ctx, profile); err != nil {\n\t\tlog.Printf(\"Failed to update medication status: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}"
      },
      {
        "code_key": "ProcessInventoryChange",
        "code_value": "func ProcessInventoryChange(ctx context.Context, facilityID string, location string) error {\n\tmedRepo := NewMedicationRepository()\n\tcurrentProfile := &model.MedicationProfile{\n\t\tRegionCode:    facilityID,\n\t\tRoom:          location,\n\t\tCurrentStatus: model.StatusInStock,\n\t}\n\n\terr := medRepo.UpdateInventory(ctx, currentProfile)\n\tif err != nil {\n\t\tmetrics.RecordInventoryError(facilityID)\n\t\treturn fmt.Errorf(\"inventory update failed: %w\", err)\n\t}\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "MedicationRepo",
        "code_value": "type MedicationRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "MedicationInventoryTableName",
        "code_value": "const MedicationInventoryTableName = \"medication_inventory\""
      },
      {
        "code_key": "MedicationProfile",
        "code_value": "type MedicationProfile struct {\n\tId           int64  `gorm:\"column:id\" json:\"id\"`\n\tRegionCode   string `gorm:\"column:region_code\" json:\"region_code\"`\n\tRoom         string `gorm:\"column:room\" json:\"room\"`\n\tCurrentStatus int    `gorm:\"column:current_status\" json:\"current_status\"`\n\tLastUpdate   int64  `gorm:\"column:last_update\" json:\"last_update\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (mp *MedicationProfile) TableName() string {\n\treturn MedicationInventoryTableName\n}"
      },
      {
        "code_key": "InventoryStatus",
        "code_value": "const (\n\tStatusInStock = iota + 1\n\tStatusOutOfStock\n\tStatusExpired\n)"
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/MedicalSystem/medication/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Expression {\n\tcommentInfo := context.GetCommentInfo(ctx)\n\tif commentInfo == nil {\n\t\tcommentInfo = &CommentInfo{RequestID: uuid.NewString()}\n\t}\n\treturn clause.Expr{SQL: fmt.Sprintf(\"%s /* %s */\", clause, commentInfo.String())}\n}"
      },
      {
        "code_key": "time",
        "code_value": "import \"time\""
      }
    ]
  },
  "synthetic_switch_GroupByCategory": {
    "scenario": "switch",
    "code_key": "GroupByCategory",
    "code_value": "func (m *Medicine) GroupByCategory() ([]Deal, error) {\n\tdeals := make([]Deal, 0)\n\tquery := base.GetInstance().MedicalDriver().Table(\"payment_records\")\n\t\n\tswitch m.ApprovalLevel {\n\tcase 1:\n\t\tquery = query.Where(\"zone = ? AND category = ?\", m.Zone, \"Prescription\")\n\tcase 2:\n\t\tquery = query.Where(\"zone = ? AND category = ?\", m.Zone, \"OTC\")\n\tcase 3:\n\t\tquery = query.Where(\"zone IN (?) AND category = ?\", []string{m.Zone, \"Special\"}, \"Restricted\")\n\tdefault:\n\t\treturn nil, errors.New(\"invalid approval level\")\n\t}\n\t\n\terr := query.Group(\"category\").Select(\"category, count(*) as total\").Scan(&deals).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn deals, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandlePrescriptionReports",
        "code_value": "func HandlePrescriptionReports(region string) ([]Deal, error) {\n\tmedData := Medicine{Zone: region, ApprovalLevel: 1}\n\tresults, err := medData.GroupByCategory()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to group prescription data: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}"
      },
      {
        "code_key": "ProcessOTCSales",
        "code_value": "func ProcessOTCSales(district string) {\n\tdrug := Medicine{Zone: district, ApprovalLevel: 2}\n\tstats, err := drug.GroupByCategory()\n\tif err != nil {\n\t\tlog.Printf(\"OTC processing error: %v\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"OTC Sales Report: %+v\\n\", stats)\n}"
      },
      {
        "code_key": "GenerateRestrictedAnalytics",
        "code_value": "func GenerateRestrictedAnalytics() error {\n\tpharma := Medicine{Zone: \"North\", ApprovalLevel: 3}\n\trestrictedData, err := pharma.GroupByCategory()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"restricted drugs analysis failed: %w\", err)\n\t}\n\tfmt.Println(\"Restricted Categories:\", restrictedData)\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Medicine",
        "code_value": "type Medicine struct {\n\tZone           string\n\tApprovalLevel  int\n}"
      },
      {
        "code_key": "Deal",
        "code_value": "type Deal struct {\n\tCategory string `gorm:\"column:category\"`\n\tTotal    int    `gorm:\"column:total\"`\n}"
      },
      {
        "code_key": "payment_records",
        "code_value": "const payment_records = \"payment_records\""
      },
      {
        "code_key": "ApprovalLevelConstants",
        "code_value": "const (\n\tApprovalLevelBasic = 1\n\tApprovalLevelOTC = 2\n\tApprovalLevelRestricted = 3\n)"
      },
      {
        "code_key": "CategoryType",
        "code_value": "const (\n\tCategoryPrescription = \"Prescription\"\n\tCategoryOTC = \"OTC\"\n\tCategoryRestricted = \"Restricted\"\n)"
      }
    ]
  },
  "synthetic_switch_ValidateByRules": {
    "scenario": "switch",
    "code_key": "ValidateByRules",
    "code_value": "func (s *Scanner) ValidateByRules() (bool, error) {\n\tvar records []compliance_records\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tswitch s.RuleType {\n\tcase \"privacy\":\n\t\tfilter[\"is_private\"] = 1\n\tcase \"security\":\n\t\tfilter[\"is_secure\"] = 1\n\tcase \"legal\":\n\t\tfilter[\"is_legal\"] = 1\n\tdefault:\n\t\treturn false, errors.New(\"unsupported rule type\")\n\t}\n\n\terr := base.GetInstance().ComplianceDriver().Table(\"compliance_records\").\n\t\tWhere(filter).Where(\"deadline_date >= ?\", time.Now()).Find(&records).Error\n\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn len(records) > 0, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandlePrivacyCompliance",
        "code_value": "func HandlePrivacyCompliance() (bool, error) {\n\tchecker := &Scanner{RuleType: \"privacy\"}\n\tisValid, err := checker.ValidateByRules()\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"privacy validation failed: %v\", err)\n\t}\n\treturn isValid, nil\n}"
      },
      {
        "code_key": "HandleSecurityAudit",
        "code_value": "func HandleSecurityAudit() {\n\tauditor := &Scanner{RuleType: \"security\"}\n\tpassed, err := auditor.ValidateByRules()\n\tif err != nil {\n\t\tlog.Printf(\"Security audit error: %v\\n\", err)\n\t\treturn\n\t}\n\tif passed {\n\t\tfmt.Println(\"Security requirements met\")\n\t} else {\n\t\tfmt.Println(\"Security requirements not satisfied\")\n\t}\n}"
      },
      {
        "code_key": "CheckLegalDocuments",
        "code_value": "func CheckLegalDocuments() bool {\n\tvalidator := &Scanner{RuleType: \"legal\"}\n\tvalid, err := validator.ValidateByRules()\n\tif err != nil {\n\t\tlog.Println(\"Legal document check failed:\", err)\n\t\treturn false\n\t}\n\treturn valid\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Scanner",
        "code_value": "type Scanner struct {\n\tRuleType string\n}"
      },
      {
        "code_key": "compliance_records",
        "code_value": "type compliance_records struct {\n\tID           int       `gorm:\"column:id\"`\n\tStatus       int       `gorm:\"column:status\"`\n\tIsPrivate    int       `gorm:\"column:is_private\"`\n\tIsSecure     int       `gorm:\"column:is_secure\"`\n\tIsLegal      int       `gorm:\"column:is_legal\"`\n\tDeadlineDate time.Time `gorm:\"column:deadline_date\"`\n}"
      },
      {
        "code_key": "ComplianceStatus",
        "code_value": "const (\n\tComplianceActive = 1\n\tComplianceInactive = 0\n)"
      },
      {
        "code_key": "RuleType",
        "code_value": "const (\n\tPrivacyRule = \"privacy\"\n\tSecurityRule = \"security\"\n\tLegalRule = \"legal\"\n)"
      },
      {
        "code_key": "ComplianceTable",
        "code_value": "const ComplianceTable = \"compliance_records\""
      }
    ]
  },
  "synthetic_switch_RefreshIndex": {
    "scenario": "switch",
    "code_key": "RefreshIndex",
    "code_value": "func (p *Project) RefreshIndex() ([]HealthMetrics, error) {\n\tmetrics := make([]HealthMetrics, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tswitch p.EnvType {\n\tcase \"production\":\n\t\tfilter[\"cluster_type\"] = \"primary\"\n\tcase \"staging\":\n\t\tfilter[\"cluster_type\"] = \"secondary\"\n\tcase \"development\":\n\t\tfilter[\"cluster_type\"] = \"local\"\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported environment type\")\n\t}\n\n\terr := base.GetInstance().MonitorDriver().Table(\"health_metrics\").\n\t\tWhere(filter).Order(\"created_at DESC\").Find(&metrics).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn metrics, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleSystemHealth",
        "code_value": "func HandleSystemHealth() error {\n\tproj := Project{EnvType: \"production\"}\n\tstats, err := proj.RefreshIndex()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to refresh health metrics: %v\", err)\n\t\treturn err\n\t}\n\tfmt.Printf(\"Retrieved %d health metrics\\n\", len(stats))\n\treturn nil\n}"
      },
      {
        "code_key": "HandleDevClusterMonitoring",
        "code_value": "func HandleDevClusterMonitoring() ([]HealthMetrics, error) {\n\tdevProject := &Project{EnvType: \"development\"}\n\tresults, err := devProject.RefreshIndex()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"development cluster monitoring failed: %w\", err)\n\t}\n\tif len(results) == 0 {\n\t\treturn nil, errors.New(\"no health data available\")\n\t}\n\treturn results, nil\n}"
      },
      {
        "code_key": "HandleStagingMetricsReport",
        "code_value": "func HandleStagingMetricsReport() {\n\tstagingProj := Project{EnvType: \"staging\"}\n\tmetrics, err := stagingProj.RefreshIndex()\n\tif err != nil {\n\t\tlog.Fatal(\"Staging metrics report generation failed: \", err)\n\t}\n\tfor _, m := range metrics {\n\t\tfmt.Printf(\"Metric ID: %s, Status: %d\\n\", m.ID, m.Status)\n\t}\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "HealthMetrics",
        "code_value": "type HealthMetrics struct {\n\tID        int       `gorm:\"column:id;primaryKey\"`\n\tStatus    int       `gorm:\"column:status\"`\n\tClusterType string   `gorm:\"column:cluster_type\"`\n\tCreatedAt time.Time `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "Project",
        "code_value": "type Project struct {\n\tEnvType string `json:\"env_type\"`\n}"
      },
      {
        "code_key": "HealthStatusActive",
        "code_value": "const HealthStatusActive = 1"
      },
      {
        "code_key": "HealthMetricsTable",
        "code_value": "const HealthMetricsTable = \"health_metrics\""
      },
      {
        "code_key": "ClusterTypePrimary",
        "code_value": "const ClusterTypePrimary = \"primary\""
      },
      {
        "code_key": "ClusterTypeSecondary",
        "code_value": "const ClusterTypeSecondary = \"secondary\""
      },
      {
        "code_key": "ClusterTypeLocal",
        "code_value": "const ClusterTypeLocal = \"local\""
      }
    ]
  },
  "synthetic_switch_TrackBehavior": {
    "scenario": "switch",
    "code_key": "TrackBehavior",
    "code_value": "func (p *Portfolio) TrackBehavior() ([]Policy, error) {\n\tpolicies := make([]Policy, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tswitch p.BehaviorType {\n\tcase 1:\n\t\tfilter[\"namespace_name\"] = p.NamespaceName\n\tcase 2:\n\t\tfilter[\"email_address\"] = p.EmailAddress\n\tcase 3:\n\t\tfilter[\"modification_date\"] = p.ModificationDate\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported behavior type\")\n\t}\n\n\terr := base.GetInstance().PolicyDriver().Table(\"performance_reviews\").\n\t\tWhere(filter).Order(\"created_at desc\").Limit(p.PageSize).Find(&policies).Error\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn policies, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleUserPolicies",
        "code_value": "func HandleUserPolicies() ([]Policy, error) {\n\tuserProfile := &Portfolio{\n\t\tBehaviorType:     2,\n\t\tEmailAddress:     \"user@example.com\",\n\t\tPageSize:         10,\n\t}\n\treturn userProfile.TrackBehavior()\n}"
      },
      {
        "code_key": "HandleNamespaceReviews",
        "code_value": "func HandleNamespaceReviews() ([]Policy, error) {\n\tnsReview := &Portfolio{\n\t\tBehaviorType:     1,\n\t\tNamespaceName:    \"prod-cluster\",\n\t\tPageSize:         5,\n\t}\n\treturn nsReview.TrackBehavior()\n}"
      },
      {
        "code_key": "HandleDateFilteredAudits",
        "code_value": "func HandleDateFilteredAudits() ([]Policy, error) {\n\tauditCheck := &Portfolio{\n\t\tBehaviorType:     3,\n\t\tModificationDate: \"2023-11-15\",\n\t\tPageSize:         20,\n\t}\n\treturn auditCheck.TrackBehavior()\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Policy",
        "code_value": "type Policy struct {\n\tID               int       `gorm:\"column:id;primaryKey\"`\n\tNamespaceName    string    `gorm:\"column:namespace_name\"`\n\tEmailAddress     string    `gorm:\"column:email_address\"`\n\tModificationDate time.Time `gorm:\"column:modification_date\"`\n\tStatus           int       `gorm:\"column:status\"`\n\tCreatedAt        time.Time `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "Portfolio",
        "code_value": "type Portfolio struct {\n\tBehaviorType     int\n\tNamespaceName    string\n\tEmailAddress     string\n\tModificationDate time.Time\n\tPageSize         int"
      },
      {
        "code_key": "BehaviorTypeConstants",
        "code_value": "const (\n\tNamespaceBehavior = 1\n\tEmailBehavior = 2\n\tDateBehavior = 3\n)"
      },
      {
        "code_key": "TableNames",
        "code_value": "const PerformanceReviewTable = \"performance_reviews\""
      },
      {
        "code_key": "StatusValues",
        "code_value": "const (\n\tActiveStatus = 1\n\tInactiveStatus = 0\n)"
      }
    ]
  },
  "synthetic_switch_ScaleCapacity": {
    "scenario": "switch",
    "code_key": "ScaleCapacity",
    "code_value": "func (b *Budget) ScaleCapacity(threshold int) ([]types.ResourceInfo, error) {\n\tresources := make([]types.ResourceInfo, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tswitch {\n\tcase b.Edition == \"premium\":\n\t\tfilter[\"tier\"] = 3\n\tcase b.Edition == \"standard\" && threshold > 1000:\n\t\tfilter[\"tier\"] = 2\n\tcase b.Edition == \"basic\" || threshold <= 500:\n\t\tfilter[\"tier\"] = 1\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported edition or threshold\")\n\t}\n\n\tif b.ProductCode != \"\" {\n\t\tfilter[\"product_code\"] = b.ProductCode\n\t}\n\n\terr := base.GetInstance().ResourceDriver().Table(\"resource_allocation\").\n\t\tWhere(filter).Find(&resources).Error\n\n\treturn resources, err\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandlePremiumResources",
        "code_value": "func HandlePremiumResources() ([]types.ResourceInfo, error) {\n\tpremiumBudget := &Budget{\n\t\tEdition:    \"premium\",\n\t\tProductCode: \"PRM123\",\n\t}\n\treturn premiumBudget.ScaleCapacity(2000)\n}"
      },
      {
        "code_key": "HandleBasicScaling",
        "code_value": "func HandleBasicScaling() error {\n\tbasicConfig := &Budget{\n\t\tEdition: \"basic\",\n\t}\n\tresources, err := basicConfig.ScaleCapacity(300)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"scaling failed: %v\", err)\n\t}\n\tlog.Printf(\"Allocated %d basic resources\", len(resources))\n\treturn nil\n}"
      },
      {
        "code_key": "HandleStandardUpgrade",
        "code_value": "func HandleStandardUpgrade() ([]types.ResourceInfo, error) {\n\tserviceBudget := &Budget{\n\t\tEdition:    \"standard\",\n\t\tProductCode: \"STD456\",\n\t}\n\treturn serviceBudget.ScaleCapacity(1500)\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "ResourceInfo",
        "code_value": "type ResourceInfo struct {\n\tID          int    `gorm:\"column:id\"`\n\tName        string `gorm:\"column:name\"`\n\tTier        int    `gorm:\"column:tier\"`\n\tProductCode string `gorm:\"column:product_code\"`\n\tStatus      int    `gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "Budget",
        "code_value": "type Budget struct {\n\tEdition     string\n\tProductCode string\n}"
      },
      {
        "code_key": "ResourceStatus",
        "code_value": "const (\n\tResourceActive = 1\n\tResourceInactive = 0\n)"
      },
      {
        "code_key": "ResourceTable",
        "code_value": "const ResourceTable = \"resource_allocation\""
      },
      {
        "code_key": "TierLevels",
        "code_value": "const (\n\tTierBasic = 1\n\tTierStandard = 2\n\tTierPremium = 3\n)"
      }
    ]
  },
  "synthetic_switch_ValidatePackageStatus": {
    "scenario": "switch",
    "code_key": "ValidatePackageStatus",
    "code_value": "func (m *Manager) ValidatePackageStatus() ([]Package, error) {\n\tpackages := make([]Package, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"active\"] = true\n\n\tswitch m.ModuleName {\n\tcase \"delivery\":\n\t\tfilter[\"route_type\"] = \"express\"\n\tcase \"storage\":\n\t\tfilter[\"storage_required\"] = true\n\tcase \"premium\":\n\t\tfilter[\"credits\"] = m.Credits\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported module\")\n\t}\n\n\terr := base.GetInstance().PackageDriver().Table(\"medication_inventory\").\n\t\tWhere(filter).Find(&packages).Error\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn packages, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleExpressDeliveries",
        "code_value": "func HandleExpressDeliveries() ([]Package, error) {\n\tmanager := &Manager{\n\t\tModuleName: \"delivery\",\n\t}\n\tdeliveries, err := manager.ValidatePackageStatus()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to fetch express deliveries: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn deliveries, nil\n}"
      },
      {
        "code_key": "ProcessStorageRequests",
        "code_value": "func ProcessStorageRequests() error {\n\tstorageManager := &Manager{\n\t\tModuleName: \"storage\",\n\t}\n\titems, err := storageManager.ValidatePackageStatus()\n\tif err != nil {\n\t\tlog.Printf(\"Storage validation failed: %v\", err)\n\t\treturn err\n\t}\n\t// Process storage items...\n\treturn nil\n}"
      },
      {
        "code_key": "CheckPremiumSubscriptions",
        "code_value": "func CheckPremiumSubscriptions(userCredits int) ([]Package, error) {\n\tpremiumManager := &Manager{\n\t\tModuleName: \"premium\",\n\t\tCredits:   userCredits,\n\t}\n\tsubscriptions, err := premiumManager.ValidatePackageStatus()\n\tif err != nil {\n\t\tlog.Printf(\"Premium package check failed: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn subscriptions, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Package",
        "code_value": "type Package struct {\n\tID              int    `gorm:\"column:id;primaryKey\"`\n\tName            string `gorm:\"column:name\"`\n\tActive          bool   `gorm:\"column:active\"`\n\tRouteType       string `gorm:\"column:route_type\"`\n\tStorageRequired bool   `gorm:\"column:storage_required\"`\n\tCredits         int    `gorm:\"column:credits\"`\n}"
      },
      {
        "code_key": "Manager",
        "code_value": "type Manager struct {\n\tModuleName string\n\tCredits    int\n}"
      },
      {
        "code_key": "MedicationInventoryTable",
        "code_value": "const MedicationInventoryTable = \"medication_inventory\""
      },
      {
        "code_key": "ModuleDelimiter",
        "code_value": "const (\n\tModuleDelivery = \"delivery\"\n\tModuleStorage  = \"storage\"\n\tModulePremium  = \"premium\"\n)"
      },
      {
        "code_key": "RouteTypeExpress",
        "code_value": "const RouteTypeExpress = \"express\""
      }
    ]
  },
  "synthetic_switch_BulkUpdate": {
    "scenario": "switch",
    "code_key": "BulkUpdate",
    "code_value": "func (p *Player) BulkUpdateSkillLevels() (int64, error) {\n\tupdates := make(map[string]interface{})\n\tswitch p.ClassName {\n\tcase \"Warrior\":\n\t\tupdates[\"attack_power\"] = p.Version * 10\n\tcase \"Mage\":\n\t\tupdates[\"spell_power\"] = p.Version * 8\n\tcase \"Rogue\":\n\t\tupdates[\"critical_chance\"] = p.Version * 0.5\n\tdefault:\n\t\treturn 0, fmt.Errorf(\"unsupported class: %s\", p.ClassName)\n\t}\n\n\tresult := base.GetInstance().GameDriver().Table(\"skill_assessments\").\n\t\tWhere(\"player_id = ? AND assessment_date >= ?\", p.ID, p.StartTime).\n\t\tUpdates(updates)\n\t\n\treturn result.RowsAffected, result.Error\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleWarriorSkillUpdate",
        "code_value": "func HandleWarriorSkillUpdate() error {\n\twarrior := &Player{\n\t\tClassName: \"Warrior\",\n\t\tID:       1001,\n\t\tVersion:  5,\n\t\tStartTime: time.Now().AddDate(0, -1, 0),\n\t}\n\n\tupdatedRows, err := warrior.BulkUpdateSkillLevels()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to update warrior skills: %v\", err)\n\t}\n\tlog.Printf(\"Successfully updated %d warrior skill records\\n\", updatedRows)\n\treturn nil\n}"
      },
      {
        "code_key": "ProcessMageSkillAssessment",
        "code_value": "func ProcessMageSkillAssessment(mageID int) (int64, error) {\n\tmage := &Player{\n\t\tClassName: \"Mage\",\n\t\tID:       mageID,\n\t\tVersion:  3,\n\t\tStartTime: time.Date(2023, 1, 1, 0, 0, 0, 0, time.UTC),\n\t}\n\n\taffectedRows, err := mage.BulkUpdateSkillLevels()\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"mage skill update failed: %w\", err)\n\t}\n\treturn affectedRows, nil\n}"
      },
      {
        "code_key": "RefreshRogueSkills",
        "code_value": "func RefreshRogueSkills(rogue *Player) error {\n\tif rogue == nil {\n\t\treturn fmt.Errorf(\"nil player provided\")\n\t}\n\trogue.ClassName = \"Rogue\"\n\trogue.Version = 7\n\trogue.StartTime = time.Now().Add(-240 * time.Hour)\n\n\tcount, err := rogue.BulkUpdateSkillLevels()\n\tif err != nil || count == 0 {\n\t\treturn fmt.Errorf(\"no rogue skills updated: %v\", err)\n\t}\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Player",
        "code_value": "type Player struct {\n\tID         int\n\tClassName  string\n\tVersion    int\n\tStartTime  int64\n}"
      },
      {
        "code_key": "SkillAssessment",
        "code_value": "type SkillAssessment struct {\n\tPlayerID       int    `gorm:\"column:player_id\"`\n\tAssessmentDate int64  `gorm:\"column:assessment_date\"`\n\tAttackPower    int    `gorm:\"column:attack_power\"`\n\tSpellPower     int    `gorm:\"column:spell_power\"`\n\tCriticalChance float64 `gorm:\"column:critical_chance\"`\n}"
      },
      {
        "code_key": "GameClass",
        "code_value": "const (\n\tWarrior = \"Warrior\"\n\tMage    = \"Mage\"\n\tRogue   = \"Rogue\"\n)"
      },
      {
        "code_key": "SkillTable",
        "code_value": "const SkillTable = \"skill_assessments\""
      },
      {
        "code_key": "GameDriver",
        "code_value": "var GameDriver = base.GetInstance().GameDriver()"
      }
    ]
  },
  "synthetic_switch_CalculateDiscount": {
    "scenario": "switch",
    "code_key": "CalculateDiscount",
    "code_value": "func (n *Nurse) CalculateDiscount() (float64, error) {\n\tdiscount := 0.0\n\tcomment := n.CommentFunc(SELECT_COMMENT)\n\tvar query *gorm.DB\n\n\tswitch n.AuthLevel {\n\tcase 1:\n\t\tdiscount = 0.1\n\tcase 2:\n\t\tdiscount = 0.2\n\tcase 3:\n\t\tdiscount = 0.3\n\tdefault:\n\t\treturn 0.0, errors.New(\"invalid auth level\")\n\t}\n\n\tif n.NetValue > 1000 {\n\t\tdiscount += 0.05\n\t}\n\n\terr := base.GetInstance().UserDriver().Clauses(comment).Table(\"user_profiles\").\n\t\tWhere(\"nurse_id = ?\", n.ID).Update(\"discount\", discount).Error\n\n\treturn discount, err\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandlePrescriptionDiscount",
        "code_value": "func HandlePrescriptionDiscount() error {\n\tnurse := &Nurse{\n\t\tID:        123,\n\t\tAuthLevel: 2,\n\t\tNetValue:  1500,\n\t}\n\n\tdiscount, err := nurse.CalculateDiscount()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to calculate discount: %v\", err)\n\t}\n\n\tlog.Printf(\"Applied discount: %.2f\", discount)\n\treturn nil\n}"
      },
      {
        "code_key": "ProcessNurseDiscount",
        "code_value": "func ProcessNurseDiscount(nurseID uint, authLevel int, netValue float64) (float64, error) {\n\tnurse := &Nurse{\n\t\tID:        nurseID,\n\t\tAuthLevel: authLevel,\n\t\tNetValue:  netValue,\n\t}\n\n\tdiscount, err := nurse.CalculateDiscount()\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"discount calculation failed: %v\", err)\n\t}\n\n\treturn discount, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Nurse",
        "code_value": "type Nurse struct {\n\tID        int\n\tAuthLevel int\n\tNetValue  float64\n\tCommentFunc func(string) hints.Hints\n}"
      },
      {
        "code_key": "DiscountUpdateResult",
        "code_value": "type DiscountUpdateResult struct {\n\tDiscount float64\n\tError    error\n}"
      },
      {
        "code_key": "SELECT_COMMENT",
        "code_value": "const SELECT_COMMENT = \"SELECT\""
      },
      {
        "code_key": "UserProfileTable",
        "code_value": "const UserProfileTable = \"user_profiles\""
      },
      {
        "code_key": "AuthLevels",
        "code_value": "const (\n\tJuniorAuth = 1\n\tMidAuth    = 2\n\tSeniorAuth = 3\n)"
      }
    ]
  },
  "synthetic_switch_CalculateStatistics": {
    "scenario": "switch",
    "code_key": "CalculateStatistics",
    "code_value": "func (e *Employee) CalculateStatistics(threshold int) ([]Zone, error) {\n\tzones := make([]Zone, 0)\n\tquery := base.GetInstance().ResourceDriver().Table(\"resource_allocation\")\n\n\tswitch {\n\tcase e.Points > threshold:\n\t\tquery = query.Where(\"points > ? AND department_code = ?\", threshold, e.DepartmentCode)\n\tcase e.Points == threshold:\n\t\tquery = query.Where(\"points = ? AND deadline_date IS NOT NULL\", threshold)\n\tdefault:\n\t\tquery = query.Where(\"points < ?\", threshold)\n\t}\n\n\terr := query.Order(\"deadline_date DESC\").Find(&zones).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn zones, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleResourceAnalysis",
        "code_value": "func HandleResourceAnalysis() error {\n\temp := &Employee{\n\t\tPoints:         85,\n\t\tDepartmentCode: \"DEV\",\n\t}\n\n\tzones, err := emp.CalculateStatistics(80)\n\tif err != nil {\n\t\tlog.Printf(\"Failed to calculate statistics: %v\", err)\n\t\treturn err\n\t}\n\n\tlog.Printf(\"Retrieved %d matching zones\", len(zones))\n\treturn nil\n}"
      },
      {
        "code_key": "ProcessDepartmentMetrics",
        "code_value": "func ProcessDepartmentMetrics(deptCode string, score int) ([]Zone, error) {\n\tstaffMember := &Employee{\n\t\tPoints:         score,\n\t\tDepartmentCode: deptCode,\n\t}\n\n\tresults, err := staffMember.CalculateStatistics(75)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"metrics calculation failed: %w\", err)\n\t}\n\n\treturn results, nil\n}"
      },
      {
        "code_key": "GenerateQuarterlyReport",
        "code_value": "func GenerateQuarterlyReport() {\n\treportEmployee := Employee{\n\t\tPoints:         90,\n\t\tDepartmentCode: \"FIN\",\n\t}\n\n\tfinancialZones, err := reportEmployee.CalculateStatistics(100)\n\tif err != nil {\n\t\tlog.Fatal(\"Critical report generation error: \", err)\n\t}\n\n\tfmt.Println(\"Quarterly financial zones:\", financialZones)\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Employee",
        "code_value": "type Employee struct {\n\tPoints         int\n\tDepartmentCode string\n}"
      },
      {
        "code_key": "Zone",
        "code_value": "type Zone struct {\n\tID           int    `gorm:\"column:id\"`\n\tPoints       int    `gorm:\"column:points\"`\n\tDepartment   string `gorm:\"column:department_code\"`\n\tDeadlineDate string `gorm:\"column:deadline_date\"`\n}"
      },
      {
        "code_key": "ResourceAllocationTable",
        "code_value": "const ResourceAllocationTable = \"resource_allocation\""
      },
      {
        "code_key": "BaseInstance",
        "code_value": "var BaseInstance = base.GetInstance()"
      },
      {
        "code_key": "QueryBuilder",
        "code_value": "type QueryBuilder struct {\n\tquery *gorm.DB\n}"
      }
    ]
  },
  "synthetic_switch_SortByField": {
    "scenario": "switch",
    "code_key": "SortByField",
    "code_value": "func (v *Video) SortByField() ([]VideoInfo, error) {\n\tvideos := make([]VideoInfo, 0)\n\tquery := base.GetInstance().MediaDriver().Table(\"player_rankings\")\n\n\tswitch v.SortField {\n\tcase \"views\":\n\t\tquery = query.Order(\"view_count DESC\")\n\tcase \"rating\":\n\t\tquery = query.Order(\"average_rating DESC\")\n\tcase \"date\":\n\t\tquery = query.Order(\"publish_date DESC\")\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported sort field\")\n\t}\n\n\tif v.SequenceNumber > 0 {\n\t\tquery = query.Where(\"sequence_number > ?\", v.SequenceNumber)\n\t}\n\n\terr := query.Limit(v.PageSize).Find(&videos).Error\n\treturn videos, err\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandlePopularVideos",
        "code_value": "func HandlePopularVideos() ([]VideoInfo, error) {\n\tmediaItem := Video{\n\t\tSortField:      \"views\",\n\t\tPageSize:       10,\n\t\tSequenceNumber: 0,\n\t}\n\treturn mediaItem.SortByField()\n}"
      },
      {
        "code_key": "HandleRecentUploads",
        "code_value": "func HandleRecentUploads() ([]VideoInfo, error) {\n\tclip := Video{\n\t\tSortField:      \"date\",\n\t\tPageSize:       5,\n\t\tSequenceNumber: 100,\n\t}\n\tresults, err := clip.SortByField()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get recent uploads: %v\", err)\n\t}\n\treturn results, nil\n}"
      },
      {
        "code_key": "HandleTopRatedContent",
        "code_value": "func HandleTopRatedContent(pageSize int) ([]VideoInfo, error) {\n\tif pageSize <= 0 {\n\t\treturn nil, errors.New(\"invalid page size\")\n\t}\n\tcontent := Video{\n\t\tSortField: \"rating\",\n\t\tPageSize:  pageSize,\n\t}\n\treturn content.SortByField()\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Video",
        "code_value": "type Video struct {\n\tSortField      string\n\tSequenceNumber int\n\tPageSize       int\n}"
      },
      {
        "code_key": "VideoInfo",
        "code_value": "type VideoInfo struct {\n\tID            int    `gorm:\"column:id\"`\n\tTitle         string `gorm:\"column:title\"`\n\tViewCount     int    `gorm:\"column:view_count\"`\n\tAverageRating float64 `gorm:\"column:average_rating\"`\n\tPublishDate   string `gorm:\"column:publish_date\"`\n\tSequenceNumber int   `gorm:\"column:sequence_number\"`\n}"
      },
      {
        "code_key": "SortFieldType",
        "code_value": "const (\n\tSortByViews  = \"views\"\n\tSortByRating = \"rating\"\n\tSortByDate   = \"date\"\n)"
      },
      {
        "code_key": "PlayerRankingsTable",
        "code_value": "const PlayerRankingsTable = \"player_rankings\""
      },
      {
        "code_key": "MediaDriverInstance",
        "code_value": "var MediaDriverInstance = base.GetInstance().MediaDriver()"
      }
    ]
  },
  "synthetic_switch_LoadBalance": {
    "scenario": "switch",
    "code_key": "LoadBalance",
    "code_value": "func (r *Route) LoadBalance() ([]Author, error) {\n\tauthors := make([]Author, 0)\n\tfilter := map[string]interface{}{\"status\": 1}\n\tswitch r.City {\n\tcase \"Beijing\":\n\t\tfilter[\"region\"] = \"north\"\n\tcase \"Shanghai\":\n\t\tfilter[\"region\"] = \"east\"\n\tcase \"Guangzhou\":\n\t\tfilter[\"region\"] = \"south\"\n\tcase \"Chengdu\":\n\t\tfilter[\"region\"] = \"west\"\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported city\")\n\t}\n\tif r.DatabaseName != \"\" {\n\t\tfilter[\"db_name\"] = r.DatabaseName\n\t}\n\terr := base.GetInstance().RouteDriver().Table(\"grade_records\").\n\t\tWhere(filter).Order(\"score DESC\").Limit(10).Find(&authors).Error\n\treturn authors, err\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleAuthorList",
        "code_value": "func HandleAuthorList() ([]Author, error) {\n\trouteCfg := &Route{City: \"Beijing\", DatabaseName: \"author_db\"}\n\tauthors, err := routeCfg.LoadBalance()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to load authors: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn authors, nil\n}"
      },
      {
        "code_key": "ProcessTopWriters",
        "code_value": "func ProcessTopWriters(regionCity string) ([]Author, error) {\n\tif regionCity == \"\" {\n\t\treturn nil, fmt.Errorf(\"city cannot be empty\")\n\t}\n\tr := &Route{City: regionCity}\n\tresult, err := r.LoadBalance()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"load balance failed: %w\", err)\n\t}\n\treturn result, nil\n}"
      },
      {
        "code_key": "FetchRegionalAuthors",
        "code_value": "func FetchRegionalAuthors() error {\n\tr := &Route{City: \"Shanghai\"}\n\tauthorList, err := r.LoadBalance()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to fetch authors: %v\", err)\n\t}\n\tfmt.Printf(\"Fetched %d authors\\n\", len(authorList))\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Route",
        "code_value": "type Route struct {\n\tCity         string\n\tDatabaseName string\n}"
      },
      {
        "code_key": "Author",
        "code_value": "type Author struct {\n\tID     int    `gorm:\"column:id\"`\n\tName   string `gorm:\"column:name\"`\n\tRegion string `gorm:\"column:region\"`\n\tScore  int    `gorm:\"column:score\"`\n\tStatus int    `gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "RegionType",
        "code_value": "const (\n\tRegionNorth = \"north\"\n\tRegionEast  = \"east\"\n\tRegionSouth = \"south\"\n\tRegionWest  = \"west\"\n)"
      },
      {
        "code_key": "GradeRecordsTable",
        "code_value": "const GradeRecordsTable = \"grade_records\""
      },
      {
        "code_key": "AuthorStatus",
        "code_value": "const (\n\tAuthorActive = 1\n\tAuthorInactive = 0\n)"
      },
      {
        "code_key": "ErrorMessages",
        "code_value": "var (\n\tErrUnsupportedCity = errors.New(\"unsupported city\")\n\tErrNoRecordsFound = errors.New(\"no records found\")\n)"
      }
    ]
  },
  "synthetic_switch_ProcessPayment": {
    "scenario": "switch",
    "code_key": "ProcessPayment",
    "code_value": "func (w *Wallet) ProcessPayment() ([]PaymentRecord, error) {\n\trecords := make([]PaymentRecord, 0)\n\tfilter := map[string]interface{}{\n\t\t\"status\": 1,\n\t}\n\n\tswitch w.PaymentType {\n\tcase 1:\n\t\tfilter[\"method\"] = \"credit_card\"\n\tcase 2:\n\t\tfilter[\"method\"] = \"wallet_balance\"\n\tcase 3:\n\t\tfilter[\"method\"] = \"bank_transfer\"\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported payment type\")\n\t}\n\n\tif w.CertificateId != \"\" {\n\t\tfilter[\"certificate_id\"] = w.CertificateId\n\t}\n\n\terr := base.GetInstance().BillingDriver().\n\t\tTable(\"payment_records\").\n\t\tWhere(filter).\n\t\tOrder(\"created_at DESC\").\n\t\tFind(&records).Error\n\n\treturn records, err\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleUserWalletPayment",
        "code_value": "func HandleUserWalletPayment(userID string) ([]PaymentRecord, error) {\n\twallet := &Wallet{\n\t\tPaymentType:    2,\n\t\tCertificateId:  userID,\n\t}\n\n\tpayments, err := wallet.ProcessPayment()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to process wallet payment: %v\", err)\n\t}\n\n\tif len(payments) == 0 {\n\t\treturn nil, errors.New(\"no payment records found\")\n\t}\n\n\treturn payments, nil\n}"
      },
      {
        "code_key": "ProcessCreditCardTransactions",
        "code_value": "func ProcessCreditCardTransactions(orderNum string) ([]PaymentRecord, error) {\n\tcreditWallet := &Wallet{\n\t\tPaymentType:   1,\n\t\tCertificateId: orderNum,\n\t}\n\n\ttransactions, err := creditWallet.ProcessPayment()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"credit card payment failed: %v\", err)\n\t}\n\n\treturn transactions, nil\n}"
      },
      {
        "code_key": "RetrieveBankTransferHistory",
        "code_value": "func RetrieveBankTransferHistory(reference string) ([]PaymentRecord, error) {\n\tbankWallet := &Wallet{\n\t\tPaymentType:   3,\n\t\tCertificateId: reference,\n\t}\n\n\thistory, err := bankWallet.ProcessPayment()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to retrieve bank transfers: %v\", err)\n\t}\n\n\treturn history, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Wallet",
        "code_value": "type Wallet struct {\n\tPaymentType    int\n\tCertificateId  string\n}"
      },
      {
        "code_key": "PaymentRecord",
        "code_value": "type PaymentRecord struct {\n\tID           uint   `gorm:\"primaryKey\"`\n\tMethod       string `gorm:\"column:method\"`\n\tStatus       int    `gorm:\"column:status\"`\n\tCertificateId string `gorm:\"column:certificate_id\"`\n\tCreatedAt    time.Time `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "PaymentStatus",
        "code_value": "const (\n\tPaymentPending = 0\n\tPaymentSuccess = 1\n\tPaymentFailed  = 2\n)"
      },
      {
        "code_key": "PaymentMethod",
        "code_value": "const (\n\tCreditCard    = 1\n\tWalletBalance = 2\n\tBankTransfer  = 3\n)"
      },
      {
        "code_key": "BillingTable",
        "code_value": "const BillingTable = \"payment_records\""
      }
    ]
  },
  "synthetic_switch_AssignTask": {
    "scenario": "switch",
    "code_key": "AssignTask",
    "code_value": "func (s *Shipment) AssignTask() ([]types.TaskInfo, error) {\n\ttasks := make([]types.TaskInfo, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tswitch s.Priority {\n\tcase 1:\n\t\tfilter[\"urgent\"] = true\n\tcase 2:\n\t\tfilter[\"normal\"] = true\n\tcase 3:\n\t\tfilter[\"low\"] = true\n\tdefault:\n\t\treturn nil, errors.New(\"invalid priority level\")\n\t}\n\n\tif s.LocationCode != \"\" {\n\t\tfilter[\"location_code\"] = s.LocationCode\n\t}\n\n\terr := base.GetInstance().LogisticsDriver().Table(\"brand_info\").\n\t\tWhere(filter).Order(\"created_at DESC\").Find(&tasks).Error\n\t\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn tasks, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleUrgentShipment",
        "code_value": "func HandleUrgentShipment() ([]types.TaskInfo, error) {\n\texpressShipment := &Shipment{\n\t\tPriority:     1,\n\t\tLocationCode: \"NYC123\",\n\t}\n\ttasks, err := expressShipment.AssignTask()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to assign urgent tasks: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn tasks, nil\n}"
      },
      {
        "code_key": "ProcessRegionalTasks",
        "code_value": "func ProcessRegionalTasks(region string) ([]types.TaskInfo, error) {\n\tregionalDelivery := Shipment{\n\t\tPriority:     2,\n\t\tLocationCode: region,\n\t}\n\n\tavailableTasks, err := regionalDelivery.AssignTask()\n\tif err != nil {\n\t\tlog.Printf(\"Error fetching regional tasks for %s: %v\", region, err)\n\t\treturn nil, fmt.Errorf(\"region processing error: %w\", err)\n\t}\n\treturn availableTasks, nil\n}"
      },
      {
        "code_key": "GetLowPriorityTasks",
        "code_value": "func GetLowPriorityTasks() []types.TaskInfo {\n\tbacklogShipment := Shipment{Priority: 3}\n\ttasks, err := backlogShipment.AssignTask()\n\tif err != nil {\n\t\tlog.Println(\"Non-critical error fetching low-priority tasks:\", err)\n\t\treturn []types.TaskInfo{}\n\t}\n\treturn tasks\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "TaskInfo",
        "code_value": "type TaskInfo struct {\n\tID          int       `json:\"id\" gorm:\"column:id\"`\n\tUrgent      bool      `json:\"urgent\" gorm:\"column:urgent\"`\n\tNormal      bool      `json:\"normal\" gorm:\"column:normal\"`\n\tLow         bool      `json:\"low\" gorm:\"column:low\"`\n\tLocationCode string    `json:\"location_code\" gorm:\"column:location_code\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "Shipment",
        "code_value": "type Shipment struct {\n\tPriority     int\n\tLocationCode string\n}"
      },
      {
        "code_key": "TaskStatus",
        "code_value": "const TaskStatusActive = 1"
      },
      {
        "code_key": "PriorityLevel",
        "code_value": "const (\n\tPriorityUrgent = 1\n\tPriorityNormal = 2\n\tPriorityLow    = 3\n)"
      },
      {
        "code_key": "BrandTable",
        "code_value": "const BrandTable = \"brand_info\""
      },
      {
        "code_key": "TaskAssignment",
        "code_value": "type TaskAssignment struct {\n\tTaskID   int\n\tDriverID int\n\tStatus   int\n}"
      }
    ]
  },
  "synthetic_switch_FilterByAttribute": {
    "scenario": "switch",
    "code_key": "FilterByAttribute",
    "code_value": "func (s *Skill) FilterByAttribute() ([]Result, error) {\n\tresults := make([]Result, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tif s.PermissionType > 0 {\n\t\tswitch s.PermissionType {\n\t\tcase 1:\n\t\t\tfilter[\"access_level\"] = \"basic\"\n\t\tcase 2:\n\t\t\tfilter[\"access_level\"] = \"advanced\"\n\t\tcase 3:\n\t\t\tfilter[\"is_premium\"] = true\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"unsupported permission type\")\n\t\t}\n\t}\n\n\tif s.ContractNumber != \"\" {\n\t\tfilter[\"contract_number\"] = s.ContractNumber\n\t}\n\n\terr := base.GetInstance().GuildDriver().Table(\"guild_memberships\").\n\t\tWhere(filter).Find(&results).Error\n\n\treturn results, err\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandlePremiumSkills",
        "code_value": "func HandlePremiumSkills() ([]Result, error) {\n\tpremiumSkill := Skill{\n\t\tPermissionType: 3,\n\t\tContractNumber: \"CON12345\"\n\t}\n\t\n\tresults, err := premiumSkill.FilterByAttribute()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to filter premium skills: %v\", err)\n\t}\n\treturn results, nil\n}"
      },
      {
        "code_key": "HandleBasicAccess",
        "code_value": "func HandleBasicAccess(memberID string) ([]Result, error) {\n\tbasicSkill := Skill{\n\t\tPermissionType: 1,\n\t\tContractNumber: memberID\n\t}\n\t\n\tmemberData, err := basicSkill.FilterByAttribute()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"basic access query failed: %v\", err)\n\t}\n\treturn memberData, nil\n}"
      },
      {
        "code_key": "HandleContractValidation",
        "code_value": "func HandleContractValidation(contractNum string) (bool, error) {\n\tvalidator := Skill{ContractNumber: contractNum}\n\t\n\tentries, err := validator.FilterByAttribute()\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"validation error: %v\", err)\n\t}\n\treturn len(entries) > 0, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Result",
        "code_value": "type Result struct {\n\tID             int    `gorm:\"column:id\"`\n\tContractNumber string `gorm:\"column:contract_number\"`\n\tAccessLevel    string `gorm:\"column:access_level\"`\n\tIsPremium      bool   `gorm:\"column:is_premium\"`\n\tStatus         int    `gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "Skill",
        "code_value": "type Skill struct {\n\tPermissionType int\n\tContractNumber string\n}"
      },
      {
        "code_key": "GuildMembershipsTable",
        "code_value": "const GuildMembershipsTable = \"guild_memberships\""
      },
      {
        "code_key": "AccessLevelBasic",
        "code_value": "const AccessLevelBasic = \"basic\""
      },
      {
        "code_key": "AccessLevelAdvanced",
        "code_value": "const AccessLevelAdvanced = \"advanced\""
      },
      {
        "code_key": "StatusActive",
        "code_value": "const StatusActive = 1"
      }
    ]
  },
  "synthetic_switch_CountByStatus": {
    "scenario": "switch",
    "code_key": "CountByStatus",
    "code_value": "func (z *Zone) CountByStatus() (int64, error) {\n\tvar count int64\n\tfilter := make(map[string]interface{})\n\tif z.Area != \"\" {\n\t\tfilter[\"area\"] = z.Area\n\t}\n\tif z.ResourceType > 0 {\n\t\tswitch z.ResourceType {\n\t\tcase 1:\n\t\t\tfilter[\"is_shared\"] = 1\n\t\tcase 2:\n\t\t\tfilter[\"is_active\"] = 1\n\t\tcase 3:\n\t\t\tfilter[\"is_locked\"] = 1\n\t\tdefault:\n\t\t\treturn 0, errors.New(\"invalid resource type\")\n\t\t}\n\t}\n\terr := base.GetInstance().HubDriver().Table(\"guild_memberships\").\n\t\tWhere(filter).Count(&count).Error\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn count, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleActiveGuildMembers",
        "code_value": "func HandleActiveGuildMembers() (int64, error) {\n\tactiveZone := &Zone{\n\t\tResourceType: 2,\n\t}\n\tmemberCount, err := activeZone.CountByStatus()\n\tif err != nil {\n\t\tlog.Printf(\"Error counting active members: %v\", err)\n\t\treturn 0, err\n\t}\n\treturn memberCount, nil\n}"
      },
      {
        "code_key": "HandleSharedResourcesInArea",
        "code_value": "func HandleSharedResourcesInArea(area string) (int64, error) {\n\tzoneFilter := &Zone{\n\t\tArea:         area,\n\t\tResourceType: 1,\n\t}\n\tcount, err := zoneFilter.CountByStatus()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to count shared resources in %s: %v\", area, err)\n\t\treturn 0, fmt.Errorf(\"query failed for area %s\", area)\n\t}\n\treturn count, nil\n}"
      },
      {
        "code_key": "HandleLockedResourceCheck",
        "code_value": "func HandleLockedResourceCheck() bool {\n\tlockCheck := Zone{ResourceType: 3}\n\tlockedCount, err := lockCheck.CountByStatus()\n\tif err != nil || lockedCount == 0 {\n\t\treturn false\n\t}\n\treturn true\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Zone",
        "code_value": "type Zone struct {\n\tArea         string\n\tResourceType int\n}"
      },
      {
        "code_key": "GuildMembership",
        "code_value": "type GuildMembership struct {\n\tID        int    `gorm:\"column:id\"`\n\tArea      string `gorm:\"column:area\"`\n\tIsShared  int    `gorm:\"column:is_shared\"`\n\tIsActive  int    `gorm:\"column:is_active\"`\n\tIsLocked  int    `gorm:\"column:is_locked\"`\n\tCreatedAt int64  `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "ResourceType",
        "code_value": "const (\n\tSharedResource = 1\n\tActiveResource = 2\n\tLockedResource = 3\n)"
      },
      {
        "code_key": "GuildTable",
        "code_value": "const GuildTable = \"guild_memberships\""
      },
      {
        "code_key": "ErrInvalidResource",
        "code_value": "var ErrInvalidResource = errors.New(\"invalid resource type\")"
      }
    ]
  },
  "synthetic_switch_MonitorActivity": {
    "scenario": "switch",
    "code_key": "MonitorActivity",
    "code_value": "func (p *Patient) MonitorActivity() ([]ActivityLog, error) {\n\tlogs := make([]ActivityLog, 0)\n\tfilter := map[string]interface{}{\"status\": 1}\n\n\tswitch p.MonitorType {\n\tcase HeartRate:\n\t\tfilter[\"sensor_type\"] = \"heart_rate\"\n\tcase BloodPressure:\n\t\tfilter[\"sensor_type\"] = \"blood_pressure\"\n\tcase OxygenLevel:\n\t\tfilter[\"sensor_type\"] = \"oxygen_level\"\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported monitor type\")\n\t}\n\n\tif p.PriorityRank > 0 {\n\t\tfilter[\"priority\"] = p.PriorityRank\n\t}\n\n\terr := base.GetInstance().HealthDriver().Table(\"exam_results\").\n\t\tWhere(filter).\n\t\tWhere(\"created_at BETWEEN ? AND ?\", p.StartTime, p.EndTime).\n\t\tOrder(\"recorded_at DESC\").\n\t\tFind(&logs).Error\n\n\treturn logs, err\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandlePatientMonitoring",
        "code_value": "func HandlePatientMonitoring() {\n\tpt := &Patient{\n\t\tMonitorType: HeartRate,\n\t\tPriorityRank: 3,\n\t\tStartTime:   time.Now().Add(-24 * time.Hour),\n\t\tEndTime:     time.Now(),\n\t}\n\n\tactivityRecords, err := pt.MonitorActivity()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to monitor patient activity: %v\", err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"Retrieved %d activity logs\\n\", len(activityRecords))\n}"
      },
      {
        "code_key": "ProcessCriticalVitals",
        "code_value": "func ProcessCriticalVitals() error {\n\tcriticalPatient := &Patient{\n\t\tMonitorType: BloodPressure,\n\t\tPriorityRank: 1,\n\t\tStartTime:   time.Date(2023, 1, 1, 0, 0, 0, 0, time.UTC),\n\t\tEndTime:     time.Date(2023, 1, 2, 0, 0, 0, 0, time.UTC),\n\t}\n\n\treadings, err := criticalPatient.MonitorActivity()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"vital monitoring failed: %w\", err)\n\t}\n\n\tif len(readings) == 0 {\n\t\treturn errors.New(\"no vital readings found\")\n\t}\n\n\t// Process critical readings here\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Patient",
        "code_value": "type Patient struct {\n\tMonitorType  MonitorType\n\tPriorityRank int\n\tStartTime    time.Time\n\tEndTime      time.Time\n}"
      },
      {
        "code_key": "ActivityLog",
        "code_value": "type ActivityLog struct {\n\tID         int       `gorm:\"column:id\"`\n\tSensorType string    `gorm:\"column:sensor_type\"`\n\tValue      float64   `gorm:\"column:value\"`\n\tRecordedAt time.Time `gorm:\"column:recorded_at\"`\n\tCreatedAt  time.Time `gorm:\"column:created_at\"`\n\tPriority   int       `gorm:\"column:priority\"`\n\tStatus     int       `gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "MonitorType",
        "code_value": "type MonitorType int\nconst (\n\tHeartRate MonitorType = iota + 1\n\tBloodPressure\n\tOxygenLevel\n)"
      },
      {
        "code_key": "ExamResultsTable",
        "code_value": "const ExamResultsTable = \"exam_results\""
      },
      {
        "code_key": "ActivityStatus",
        "code_value": "const (\n\tActivityActive = 1\n\tActivityInactive = 0\n)"
      }
    ]
  },
  "synthetic_switch_SendNotification": {
    "scenario": "switch",
    "code_key": "SendNotification",
    "code_value": "func (g *Guild) SendNotification(threshold int) ([]NotificationTarget, error) {\n\ttargets := make([]NotificationTarget, 0)\n\tfilter := map[string]interface{}{\"status\": 1}\n\t\n\tswitch g.CategoryType {\n\tcase 1:\n\t\tfilter[\"high_priority\"] = true\n\tcase 2:\n\t\tfilter[\"medium_priority\"] = true\n\tcase 3:\n\t\tfilter[\"low_priority\"] = true\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported category type\")\n\t}\n\t\n\tif threshold > 0 {\n\t\tfilter[\"score\"] = gorm.Expr(\"score > ?\", threshold)\n\t}\n\t\n\terr := base.GetInstance().NotifyDriver().Table(\"notification_targets\").\n\t\tWhere(filter).Find(&targets).Error\n\t\t\n\treturn targets, err\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleGuildAlerts",
        "code_value": "func HandleGuildAlerts() error {\n\tguild := &Guild{CategoryType: 2} // Medium priority guild\n\talerts, err := guild.SendNotification(75)\n\tif err != nil {\n\t\tlog.Printf(\"Failed to send alerts: %v\", err)\n\t\treturn err\n\t}\n\tlog.Printf(\"Sent %d medium priority alerts\", len(alerts))\n\treturn nil\n}"
      },
      {
        "code_key": "ProcessVIPNotifications",
        "code_value": "func ProcessVIPNotifications() (int, error) {\n\tvipGuild := &Guild{CategoryType: 1} // High priority VIP guild\n\ttargets, err := vipGuild.SendNotification(90)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"VIP notification failed: %w\", err)\n\t}\n\treturn len(targets), nil\n}"
      },
      {
        "code_key": "MonitorLowPriorityEvents",
        "code_value": "func MonitorLowPriorityEvents() {\n\tcasualGuild := &Guild{CategoryType: 3} // Low priority guild\n\trecipients, _ := casualGuild.SendNotification(0) // No threshold\n\tif len(recipients) > 0 {\n\t\tfmt.Println(\"Broadcasted to\", len(recipients), \"casual members\")\n\t}\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Guild",
        "code_value": "type Guild struct {\n\tCategoryType int\n}"
      },
      {
        "code_key": "NotificationTarget",
        "code_value": "type NotificationTarget struct {\n\tID           int    `gorm:\"column:id\"`\n\tTargetName   string `gorm:\"column:target_name\"`\n\tEmail        string `gorm:\"column:email\"`\n\tHighPriority bool   `gorm:\"column:high_priority\"`\n\tMediumPriority bool `gorm:\"column:medium_priority\"`\n\tLowPriority  bool   `gorm:\"column:low_priority\"`\n\tScore        int    `gorm:\"column:score\"`\n\tStatus       int    `gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "NotificationTargetsTable",
        "code_value": "const NotificationTargetsTable = \"notification_targets\""
      },
      {
        "code_key": "NotificationStatus",
        "code_value": "const (\n\tActiveStatus = 1\n\tInactiveStatus = 0\n)"
      },
      {
        "code_key": "CategoryType",
        "code_value": "const (\n\tHighPriorityCategory = 1\n\tMediumPriorityCategory = 2\n\tLowPriorityCategory = 3\n)"
      }
    ]
  },
  "synthetic_switch_ApproveRequest": {
    "scenario": "switch",
    "code_key": "ApproveRequest",
    "code_value": "func (c *Curriculum) ApproveRequest() ([]Student, error) {\n\tstudents := make([]Student, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tswitch c.Genre {\n\tcase \"science\":\n\t\tfilter[\"department\"] = \"science\"\n\tcase \"arts\":\n\t\tfilter[\"department\"] = \"arts\"\n\tcase \"business\":\n\t\tfilter[\"department\"] = \"business\"\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported curriculum genre\")\n\t}\n\n\terr := base.GetInstance().AcademicDriver().Table(\"author_profiles\").\n\t\tWhere(filter).Where(\"created_at >= ?\", c.StartDate).\n\t\tOrder(\"enrollment_date DESC\").Find(&students).Error\n\n\treturn students, err\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleScienceApprovals",
        "code_value": "func HandleScienceApprovals() ([]Student, error) {\n\tcourse := Curriculum{\n\t\tGenre:    \"science\",\n\t\tStartDate: time.Now().AddDate(0, -1, 0),\n\t}\n\n\tapprovedStudents, err := course.ApproveRequest()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to approve science students: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn approvedStudents, nil\n}"
      },
      {
        "code_key": "ProcessBusinessApplications",
        "code_value": "func ProcessBusinessApplications() error {\n\tbizCurriculum := Curriculum{\n\t\tGenre:    \"business\",\n\t\tStartDate: time.Date(2023, 1, 1, 0, 0, 0, 0, time.UTC),\n\t}\n\n\tapplicants, err := bizCurriculum.ApproveRequest()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"business approval processing failed: %w\", err)\n\t}\n\tfmt.Printf(\"Approved %d business students\\n\", len(applicants))\n\treturn nil\n}"
      },
      {
        "code_key": "ValidateArtsCandidates",
        "code_value": "func ValidateArtsCandidates() {\n\tartsReq := Curriculum{\n\t\tGenre:    \"arts\",\n\t\tStartDate: time.Now().Add(-720 * time.Hour),\n\t}\n\n\tcandidates, err := artsReq.ApproveRequest()\n\tif err != nil {\n\t\tlog.Println(\"Arts validation error:\", err)\n\t\treturn\n\t}\n\tfor _, c := range candidates {\n\t\tfmt.Println(\"Validated arts student:\", c.Name)\n\t}\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Student",
        "code_value": "type Student struct {\n\tID             int       `gorm:\"column:id\"`\n\tName           string    `gorm:\"column:name\"`\n\tDepartment     string    `gorm:\"column:department\"`\n\tStatus         int       `gorm:\"column:status\"`\n\tEnrollmentDate time.Time `gorm:\"column:enrollment_date\"`\n\tCreatedAt      time.Time `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "Curriculum",
        "code_value": "type Curriculum struct {\n\tGenre     string\n\tStartDate time.Time\n}"
      },
      {
        "code_key": "AcademicStatus",
        "code_value": "const (\n\tPendingStatus  = 0\n\tApprovedStatus = 1\n\tRejectedStatus = 2\n)"
      },
      {
        "code_key": "DepartmentType",
        "code_value": "const (\n\tScienceDept  = \"science\"\n\tArtsDept     = \"arts\"\n\tBusinessDept = \"business\"\n)"
      },
      {
        "code_key": "AcademicTable",
        "code_value": "const AuthorProfilesTable = \"author_profiles\""
      }
    ]
  },
  "synthetic_switch_FindByCategory": {
    "scenario": "switch",
    "code_key": "FindByCategory",
    "code_value": "func (w *Weapon) FindByCategory() ([]WeaponInfo, error) {\n\tweapons := make([]WeaponInfo, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\tif w.Editor != \"\" {\n\t\tfilter[\"editor\"] = w.Editor\n\t}\n\tswitch w.Category {\n\tcase \"melee\":\n\t\tfilter[\"range_type\"] = \"close\"\n\tcase \"ranged\":\n\t\tfilter[\"range_type\"] = \"far\"\n\tcase \"explosive\":\n\t\tfilter[\"damage_type\"] = \"aoe\"\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported weapon category\")\n\t}\n\terr := base.GetInstance().ArmoryDriver().Table(\"warehouse_stock\").\n\t\tWhere(filter).Find(&weapons).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn weapons, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleArmoryRequest",
        "code_value": "func HandleArmoryRequest(category string, editor string) ([]WeaponInfo, error) {\n\tarmoryItem := Weapon{\n\t\tCategory: category,\n\t\tEditor:   editor,\n\t}\n\tresult, err := armoryItem.FindByCategory()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to fetch armory items: %v\", err)\n\t\treturn nil, fmt.Errorf(\"armory request failed\")\n\t}\n\treturn result, nil\n}"
      },
      {
        "code_key": "ProcessCombatGear",
        "code_value": "func ProcessCombatGear() {\n\tcombatTools := Weapon{Category: \"ranged\", Editor: \"john_doe\"}\n\tgearList, err := combatTools.FindByCategory()\n\tif err != nil {\n\t\tlog.Fatal(\"Combat gear processing failed: \", err)\n\t}\n\tfmt.Printf(\"Retrieved %d combat gear items\\n\", len(gearList))\n}"
      },
      {
        "code_key": "AnalyzeExplosives",
        "code_value": "func AnalyzeExplosives(analyst string) error {\n\texplosiveWeapons := Weapon{\n\t\tCategory: \"explosive\",\n\t\tEditor:   analyst,\n\t}\n\tdata, err := explosiveWeapons.FindByCategory()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"explosive analysis failed: %w\", err)\n\t}\n\tfmt.Println(\"Explosive weapons analysis complete.\")\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Weapon",
        "code_value": "type Weapon struct {\n\tCategory string\n\tEditor   string\n\tStatus   int\n}"
      },
      {
        "code_key": "WeaponInfo",
        "code_value": "type WeaponInfo struct {\n\tID         int    `gorm:\"column:id\"`\n\tName       string `gorm:\"column:name\"`\n\tRangeType  string `gorm:\"column:range_type\"`\n\tDamageType string `gorm:\"column:damage_type\"`\n\tEditor     string `gorm:\"column:editor\"`\n\tStatus     int    `gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "WarehouseStockTable",
        "code_value": "const WarehouseStockTable = \"warehouse_stock\""
      },
      {
        "code_key": "WeaponStatusActive",
        "code_value": "const WeaponStatusActive = 1"
      },
      {
        "code_key": "RangeTypeClose",
        "code_value": "const RangeTypeClose = \"close\""
      },
      {
        "code_key": "RangeTypeFar",
        "code_value": "const RangeTypeFar = \"far\""
      },
      {
        "code_key": "DamageTypeAOE",
        "code_value": "const DamageTypeAOE = \"aoe\""
      }
    ]
  },
  "synthetic_switch_ConfigureSettings": {
    "scenario": "switch",
    "code_key": "ConfigureSettings",
    "code_value": "func (p *Policy) ConfigureSettings() error {\n\tswitch p.Category {\n\tcase \"security\":\n\t\tp.Description = \"High security policy settings applied\"\n\t\tp.ContractNumber = \"SEC-2023-001\"\n\tcase \"privacy\":\n\t\tp.Description = \"Strict privacy compliance enabled\"\n\t\tp.ContractNumber = \"PRV-2023-002\"\n\tcase \"retention\":\n\t\tp.Description = \"Data retention policy configured\"\n\t\tp.ContractNumber = \"RET-2023-003\"\n\tdefault:\n\t\treturn errors.New(\"unsupported policy category\")\n\t}\n\n\tp.ModificationDate = time.Now()\n\treturn base.GetInstance().PolicyDriver().Table(\"market_data\").\n\t\tWhere(\"id = ?\", p.ID).\n\t\tUpdates(map[string]interface{}{\n\t\t\t\"description\": p.Description,\n\t\t\t\"contract_number\": p.ContractNumber,\n\t\t\t\"modification_date\": p.ModificationDate,\n\t\t}).Error\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleSecurityPolicy",
        "code_value": "func HandleSecurityPolicy() error {\n\tsecPolicy := &Policy{\n\t\tID:       1001,\n\t\tCategory: \"security\",\n\t}\n\tif err := secPolicy.ConfigureSettings(); err != nil {\n\t\tlog.Printf(\"Failed to configure security policy: %v\", err)\n\t\treturn err\n\t}\n\tlog.Println(\"Security policy configured successfully\")\n\treturn nil\n}"
      },
      {
        "code_key": "HandlePrivacyUpdate",
        "code_value": "func HandlePrivacyUpdate() error {\n\tprivacyRule := &Policy{\n\t\tID:       2002,\n\t\tCategory: \"privacy\",\n\t}\n\terr := privacyRule.ConfigureSettings()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"privacy update failed: %w\", err)\n\t}\n\treturn nil\n}"
      },
      {
        "code_key": "ProcessRetentionPolicy",
        "code_value": "func ProcessRetentionPolicy(policyID int) error {\n\tretPolicy := &Policy{\n\t\tID:       policyID,\n\t\tCategory: \"retention\",\n\t}\n\tif err := retPolicy.ConfigureSettings(); err != nil {\n\t\treturn fmt.Errorf(\"retention policy error [ID:%d]: %v\", policyID, err)\n\t}\n\tlog.Printf(\"Updated retention policy %d\", policyID)\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Policy",
        "code_value": "type Policy struct {\n\tID              int\n\tCategory        string\n\tDescription     string\n\tContractNumber  string\n\tModificationDate time.Time\n}"
      },
      {
        "code_key": "PolicyCategory",
        "code_value": "const (\n\tSecurityPolicy = \"security\"\n\tPrivacyPolicy = \"privacy\"\n\tRetentionPolicy = \"retention\"\n)"
      },
      {
        "code_key": "MarketDataTable",
        "code_value": "const MarketDataTable = \"market_data\""
      },
      {
        "code_key": "ErrorMessages",
        "code_value": "const (\n\tErrUnsupportedPolicy = \"unsupported policy category\"\n)"
      },
      {
        "code_key": "BaseDriver",
        "code_value": "var BaseDriver *gorm.DB"
      }
    ]
  },
  "synthetic_switch_GenerateMetrics": {
    "scenario": "switch",
    "code_key": "GenerateMetrics",
    "code_value": "func (a *Account) GenerateMetrics(startTime string) ([]Container, error) {\n\tcontainers := make([]Container, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tif a.Zone != \"\" {\n\t\tswitch a.Zone {\n\t\tcase \"EAST\":\n\t\t\tfilter[\"region\"] = \"east-1\"\n\t\tcase \"WEST\":\n\t\t\tfilter[\"region\"] = \"west-2\"\n\t\tcase \"NORTH\":\n\t\t\tfilter[\"availability_zone\"] = \"north-3\"\n\t\tdefault:\n\t\t\treturn nil, errors.New(\"invalid zone\")\n\t\t}\n\t}\n\n\tquery := base.GetInstance().DataDriver().Table(\"achievement_records\").Where(filter)\n\tif startTime != \"\" {\n\t\tquery = query.Where(\"ActivationDate >= ?\", startTime)\n\t}\n\terr := query.Select(\"Content, ActivationDate\").Find(&containers).Error\n\treturn containers, err\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "ProcessContainerMetrics",
        "code_value": "func ProcessContainerMetrics() {\n\tacc := &Account{Zone: \"EAST\"}\n\tmetrics, err := acc.GenerateMetrics(\"2023-01-01\")\n\tif err != nil {\n\t\tlog.Printf(\"Error generating metrics: %v\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Found %d containers\\n\", len(metrics))\n}"
      },
      {
        "code_key": "AnalyzeZonePerformance",
        "code_value": "func AnalyzeZonePerformance(zone string) ([]Container, error) {\n\tacc := &Account{Zone: zone}\n\tresults, err := acc.GenerateMetrics(\"\")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"analysis failed: %w\", err)\n\t}\n\tif len(results) == 0 {\n\t\treturn nil, errors.New(\"no data found\")\n\t}\n\treturn results, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Container",
        "code_value": "type Container struct {\n\tContent         string    `json:\"content\" gorm:\"column:Content\"`\n\tActivationDate time.Time `json:\"activation_date\" gorm:\"column:ActivationDate\"`\n}"
      },
      {
        "code_key": "Account",
        "code_value": "type Account struct {\n\tZone string\n\tID   int\n}"
      },
      {
        "code_key": "AchievementTable",
        "code_value": "const AchievementTable = \"achievement_records\""
      },
      {
        "code_key": "RecordStatus",
        "code_value": "const (\n\tActiveStatus = 1\n\tDeletedStatus = 0\n)"
      },
      {
        "code_key": "RegionMapping",
        "code_value": "var RegionMapping = map[string]string{\n\t\"EAST\":  \"east-1\",\n\t\"WEST\":  \"west-2\",\n\t\"NORTH\": \"north-3\"\n}"
      }
    ]
  },
  "synthetic_switch_AnalyzePerformance": {
    "scenario": "switch",
    "code_key": "AnalyzePerformance",
    "code_value": "func (e *Exchange) AnalyzePerformance(threshold int) ([]Pallet, error) {\n\tpallets := make([]Pallet, 0)\n\tquery := base.GetInstance().DataDriver().Table(\"health_metrics\")\n\n\tswitch e.AccessLevel {\n\tcase 1:\n\t\tquery = query.Where(\"district = ? AND editor = ?\", e.District, e.Editor)\n\tcase 2:\n\t\tquery = query.Where(\"district = ?\", e.District)\n\tcase 3:\n\t\tquery = query.Where(\"editor = ?\", e.Editor)\n\tdefault:\n\t\treturn nil, errors.New(\"invalid access level\")\n\t}\n\n\tif threshold > 0 {\n\t\tquery = query.Where(\"score >= ?\", threshold)\n\t}\n\n\terr := query.Order(\"created_at DESC\").Find(&pallets).Error\n\treturn pallets, err\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleDistrictPerformance",
        "code_value": "func HandleDistrictPerformance() ([]Pallet, error) {\n\tmetricsAnalyzer := &Exchange{\n\t\tAccessLevel: 2,\n\t\tDistrict:    \"East\",\n\t}\n\t\n\tresults, err := metricsAnalyzer.AnalyzePerformance(80)\n\tif err != nil {\n\t\tlog.Printf(\"Failed to analyze performance: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}"
      },
      {
        "code_key": "HandleEditorMetrics",
        "code_value": "func HandleEditorMetrics() error {\n\teditorTracker := &Exchange{\n\t\tAccessLevel: 3,\n\t\tEditor:      \"john.doe\",\n\t}\n\t\n\tpallets, err := editorTracker.AnalyzePerformance(0)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"metrics retrieval failed: %w\", err)\n\t}\n\t\n\tfmt.Printf(\"Found %d pallets\\n\", len(pallets))\n\treturn nil\n}"
      },
      {
        "code_key": "HandleStrictAudit",
        "code_value": "func HandleStrictAudit() {\n\tstrictReview := &Exchange{\n\t\tAccessLevel: 1,\n\t\tDistrict:    \"North\",\n\t\tEditor:      \"audit.bot\",\n\t}\n\t\n\tif data, err := strictReview.AnalyzePerformance(95); err == nil {\n\t\tprocessAuditData(data)\n\t} else {\n\t\tnotifyAdmins(err)\n\t}\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Exchange",
        "code_value": "type Exchange struct {\n\tAccessLevel int\n\tDistrict    string\n\tEditor      string\n}"
      },
      {
        "code_key": "Pallet",
        "code_value": "type Pallet struct {\n\tID         int       `gorm:\"column:id\"`\n\tDistrict   string    `gorm:\"column:district\"`\n\tEditor     string    `gorm:\"column:editor\"`\n\tScore      int       `gorm:\"column:score\"`\n\tCreatedAt  time.Time `gorm:\"column:created_at\"`\n\tHealthData string    `gorm:\"column:health_data\"`\n}"
      },
      {
        "code_key": "health_metrics",
        "code_value": "const HealthMetricsTable = \"health_metrics\""
      },
      {
        "code_key": "AccessLevels",
        "code_value": "const (\n\tAccessBasic = 1\n\tAccessRegional = 2\n\tAccessEditorial = 3\n)"
      },
      {
        "code_key": "DefaultThreshold",
        "code_value": "var DefaultPerformanceThreshold = 80"
      }
    ]
  },
  "synthetic_switch_VerifySignature": {
    "scenario": "switch",
    "code_key": "VerifySignature",
    "code_value": "func (h *Hub) VerifySignature(authMethod string) (bool, error) {\n\tvalid := false\n\tdbQuery := base.GetInstance().AuthDriver().Table(\"fund_transfers\")\n\n\tswitch authMethod {\n\tcase \"RSA\":\n\t\tdbQuery = dbQuery.Where(\"method_name = ? AND points >= ?\", authMethod, 100)\n\tcase \"ECDSA\":\n\t\tdbQuery = dbQuery.Where(\"method_name = ? AND end_date > NOW()\", authMethod)\n\tcase \"HMAC\":\n\t\tdbQuery = dbQuery.Where(\"method_name = ? AND status = 1\", authMethod)\n\tdefault:\n\t\treturn false, errors.New(\"unsupported authentication method\")\n\t}\n\n\terr := dbQuery.Select(\"COUNT(*) > 0\").Scan(&valid).Error\n\treturn valid, err\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleTransactionAuth",
        "code_value": "func HandleTransactionAuth() {\n\tvar authHub Hub\n\tauthMethod := \"RSA\"\n\tisValid, err := authHub.VerifySignature(authMethod)\n\tif err != nil {\n\t\tlog.Printf(\"Authentication failed: %v\", err)\n\t\treturn\n\t}\n\tif isValid {\n\t\tlog.Println(\"Transaction authorized successfully\")\n\t} else {\n\t\tlog.Println(\"Transaction authorization failed\")\n\t}\n}"
      },
      {
        "code_key": "ProcessCryptoPayment",
        "code_value": "func ProcessCryptoPayment(cryptoType string) error {\n\tpaymentVerifier := Hub{}\n\tapproved, verifyErr := paymentVerifier.VerifySignature(cryptoType)\n\tif verifyErr != nil {\n\t\treturn fmt.Errorf(\"payment verification error: %w\", verifyErr)\n\t}\n\tif !approved {\n\t\treturn errors.New(\"crypto payment not authorized\")\n\t}\n\t// Proceed with payment processing\n\treturn nil\n}"
      },
      {
        "code_key": "CheckAPISecurity",
        "code_value": "func CheckAPISecurity() bool {\n\tsecurityCheck := Hub{}\n\tsigningMethod := \"ECDSA\"\n\tvalid, _ := securityCheck.VerifySignature(signingMethod)\n\treturn valid\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "AuthMethod",
        "code_value": "type AuthMethod string\nconst (\n\tRSA AuthMethod = \"RSA\"\n\tECDSA AuthMethod = \"ECDSA\"\n\tHMAC AuthMethod = \"HMAC\"\n)"
      },
      {
        "code_key": "FundTransfer",
        "code_value": "type FundTransfer struct {\n\tID         uint      `gorm:\"column:id\"`\n\tMethodName string    `gorm:\"column:method_name\"`\n\tPoints     int       `gorm:\"column:points\"`\n\tEndDate    time.Time `gorm:\"column:end_date\"`\n\tStatus     int8      `gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "Hub",
        "code_value": "type Hub struct {\n\t// 定义Hub结构体字段\n}"
      },
      {
        "code_key": "FundTransferTable",
        "code_value": "const FundTransferTable = \"fund_transfers\""
      },
      {
        "code_key": "AuthStatus",
        "code_value": "const (\n\tAuthActive = 1\n\tAuthInactive = 0\n)"
      },
      {
        "code_key": "DefaultPointsThreshold",
        "code_value": "const DefaultPointsThreshold = 100"
      }
    ]
  },
  "synthetic_switch_AuthorizeAccess": {
    "scenario": "switch",
    "code_key": "AuthorizeAccess",
    "code_value": "func (a *Allergy) AuthorizeAccess() (bool, error) {\n\tvar access bool\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tswitch a.RoleCode {\n\tcase \"admin\":\n\t\tfilter[\"permission_type\"] = \"full\"\n\tcase \"editor\":\n\t\tfilter[\"permission_type\"] = \"edit\"\n\tcase \"viewer\":\n\t\tfilter[\"permission_type\"] = \"read\"\n\tdefault:\n\t\treturn false, fmt.Errorf(\"unsupported role: %s\", a.RoleCode)\n\t}\n\n\tcomment := a.CommentFunc(SELECT_COMMENT)\n\terr := base.GetInstance().MediaDriver().Clauses(comment).Table(\"media_library\").\n\t\tSelect(\"COUNT(1) > 0\").Where(filter).Scan(&access).Error\n\n\treturn access, err\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleMediaAccess",
        "code_value": "func HandleMediaAccess() {\n\tmediaAllergy := &Allergy{RoleCode: \"editor\"}\n\tmediaAllergy.CommentFunc = DefaultCommentFunc\n\n\tgranted, err := mediaAllergy.AuthorizeAccess()\n\tif err != nil {\n\t\tlog.Printf(\"Authorization failed: %v\", err)\n\t\treturn\n\t}\n\n\tif granted {\n\t\tfmt.Println(\"Access granted for editor role\")\n\t} else {\n\t\tfmt.Println(\"Access denied\")\n\t}\n}"
      },
      {
        "code_key": "ValidateLibraryPermissions",
        "code_value": "func ValidateLibraryPermissions(role string) error {\n\tpermCheck := Allergy{RoleCode: role}\n\tpermCheck.CommentFunc = CustomCommentFunc\n\n\thasAccess, authErr := permCheck.AuthorizeAccess()\n\tif authErr != nil {\n\t\treturn fmt.Errorf(\"authorization error: %w\", authErr)\n\t}\n\n\tif !hasAccess {\n\t\treturn errors.New(\"insufficient permissions\")\n\t}\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Allergy",
        "code_value": "type Allergy struct {\n\tRoleCode    string\n\tCommentFunc func(string) hints.Hints\n}"
      },
      {
        "code_key": "MediaLibraryTable",
        "code_value": "const MediaLibraryTable = \"media_library\""
      },
      {
        "code_key": "PermissionStatus",
        "code_value": "const (\n\tActiveStatus = 1\n\tInactiveStatus = 0\n)"
      },
      {
        "code_key": "PermissionType",
        "code_value": "const (\n\tFullPermission = \"full\"\n\tEditPermission = \"edit\"\n\tReadPermission = \"read\"\n)"
      },
      {
        "code_key": "Comment",
        "code_value": "type Comment string\nconst SELECT_COMMENT = \"SELECT\""
      },
      {
        "code_key": "Hint",
        "code_value": "type Hint struct {\n\tAction  string\n\tContent string\n}"
      },
      {
        "code_key": "AccessResult",
        "code_value": "type AccessResult struct {\n\tHasAccess bool\n\tError     error\n}"
      }
    ]
  },
  "synthetic_switch_SearchByKeyword": {
    "scenario": "switch",
    "code_key": "SearchByKeyword",
    "code_value": "func (c *Course) SearchByKeyword() ([]Test, error) {\n\ttests := make([]Test, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tif c.Rating > 0 {\n\t\tswitch c.Rating {\n\t\tcase 1:\n\t\t\tfilter[\"security_level\"] = \"low\"\n\t\tcase 2:\n\t\t\tfilter[\"security_level\"] = \"medium\"\n\t\tcase 3:\n\t\t\tfilter[\"security_level\"] = \"high\"\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"invalid rating level\")\n\t\t}\n\t}\n\n\tquery := base.GetInstance().TestDriver().Table(\"tournament_brackets\").Where(filter)\n\tif c.SuspensionTime != \"\" {\n\t\tquery = query.Where(\"suspension_time <= ?\", c.SuspensionTime)\n\t}\n\terr := query.Find(&tests).Error\n\treturn tests, err\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleTestRetrieval",
        "code_value": "func HandleTestRetrieval(ratingLevel int, suspensionWindow string) ([]Test, error) {\n\tcourseObj := &Course{\n\t\tRating:        ratingLevel,\n\t\tSuspensionTime: suspensionWindow,\n\t}\n\tresultSet, err := courseObj.SearchByKeyword()\n\tif err != nil {\n\t\tlog.Printf(\"Failed retrieving tests: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn resultSet, nil\n}"
      },
      {
        "code_key": "ProcessSecurityAudit",
        "code_value": "func ProcessSecurityAudit() error {\n\tauditCourse := &Course{\n\t\tRating:         3,\n\t\tSuspensionTime: \"2023-12-31 23:59:59\",\n\t}\n\tauditRecords, auditErr := auditCourse.SearchByKeyword()\n\tif auditErr != nil {\n\t\treturn fmt.Errorf(\"security audit failed: %w\", auditErr)\n\t}\n\tlog.Printf(\"Found %d high security tests\", len(auditRecords))\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Test",
        "code_value": "type Test struct {\n\tID             int    `gorm:\"column:id\"`\n\tSecurityLevel  string `gorm:\"column:security_level\"`\n\tSuspensionTime string `gorm:\"column:suspension_time\"`\n\tStatus         int    `gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "Course",
        "code_value": "type Course struct {\n\tRating         int\n\tSuspensionTime string\n}"
      },
      {
        "code_key": "TournamentTable",
        "code_value": "const TournamentTable = \"tournament_brackets\""
      },
      {
        "code_key": "SecurityLevels",
        "code_value": "const (\n\tLowSecurity    = \"low\"\n\tMediumSecurity = \"medium\"\n\tHighSecurity   = \"high\"\n)"
      },
      {
        "code_key": "StatusValues",
        "code_value": "const (\n\tActiveStatus   = 1\n\tInactiveStatus = 0\n)"
      },
      {
        "code_key": "QueryBuilder",
        "code_value": "var QueryBuilder = struct {\n\tCreate func(string) string\n}{\n\tCreate: func(table string) string {\n\t\treturn fmt.Sprintf(\"SELECT * FROM %s WHERE status = ?\", table)\n\t},\n}"
      }
    ]
  },
  "synthetic_switch_ProcessAssessmentByStatus": {
    "scenario": "switch",
    "code_key": "ProcessAssessmentByStatus",
    "code_value": "func (a *Assessment) ProcessAssessmentByStatus() ([]Budget, error) {\n\tbudgets := make([]Budget, 0)\n\tquery := base.GetInstance().AssessmentDriver().Table(\"credit_scores\")\n\n\tswitch a.Status {\n\tcase \"pending\":\n\t\tquery = query.Where(\"Dimension = ? AND ZipCode IS NOT NULL\", a.Dimension)\n\tcase \"approved\":\n\t\tquery = query.Where(\"Longitude > ? AND processed_at IS NOT NULL\", a.Longitude)\n\tcase \"rejected\":\n\t\tquery = query.Where(\"Dimension = ? AND rejection_reason IS NOT NULL\", a.Dimension)\n\tdefault:\n\t\treturn nil, errors.New(\"invalid assessment status\")\n\t}\n\n\terr := query.Order(\"created_at DESC\").Limit(a.PageSize).Find(&budgets).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn budgets, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandlePendingAssessments",
        "code_value": "func HandlePendingAssessments(dimension string) ([]Budget, error) {\n\tassessment := &Assessment{\n\t\tStatus:    \"pending\",\n\t\tDimension: dimension,\n\t\tPageSize:  10,\n\t}\n\treturn assessment.ProcessAssessmentByStatus()\n}"
      },
      {
        "code_key": "HandleApprovedAssessments",
        "code_value": "func HandleApprovedAssessments(longitude float64) ([]Budget, error) {\n\tassessment := &Assessment{\n\t\tStatus:    \"approved\",\n\t\tLongitude: longitude,\n\t\tPageSize:  20,\n\t}\n\treturn assessment.ProcessAssessmentByStatus()\n}"
      },
      {
        "code_key": "HandleRejectedAssessments",
        "code_value": "func HandleRejectedAssessments(dimension string) ([]Budget, error) {\n\tassessment := &Assessment{\n\t\tStatus:    \"rejected\",\n\t\tDimension: dimension,\n\t\tPageSize:  15,\n\t}\n\treturn assessment.ProcessAssessmentByStatus()\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Assessment",
        "code_value": "type Assessment struct {\n\tStatus     string\n\tDimension  string\n\tLongitude  float64\n\tPageSize   int\n}"
      },
      {
        "code_key": "Budget",
        "code_value": "type Budget struct {\n\tID           int       `gorm:\"column:id\"`\n\tDimension    string    `gorm:\"column:dimension\"`\n\tZipCode      string    `gorm:\"column:zip_code\"`\n\tLongitude    float64   `gorm:\"column:longitude\"`\n\tProcessedAt  time.Time `gorm:\"column:processed_at\"`\n\tRejectionReason string  `gorm:\"column:rejection_reason\"`\n\tCreatedAt    time.Time `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "AssessmentStatus",
        "code_value": "const (\n\tPendingStatus  = \"pending\"\n\tApprovedStatus = \"approved\"\n\tRejectedStatus = \"rejected\"\n)"
      },
      {
        "code_key": "CreditScoresTable",
        "code_value": "const CreditScoresTable = \"credit_scores\""
      }
    ]
  },
  "synthetic_switch_AuditChanges": {
    "scenario": "switch",
    "code_key": "AuditChanges",
    "code_value": "func (t *Textbook) AuditChanges() ([]types.MediaInfo, error) {\n\tmediaList := make([]types.MediaInfo, 0)\n\tcomment := t.CommentFunc(SELECT_COMMENT)\n\tquery := base.GetInstance().LibraryDriver().Clauses(comment).Table(\"user_profiles\")\n\n\tswitch t.AuditStatus {\n\tcase Pending:\n\t\tquery = query.Where(\"modification_date >= ? AND language = ?\", t.StartTime, t.Language)\n\tcase Approved:\n\t\tquery = query.Where(\"modification_date <= ? AND suspension_time IS NULL\", t.EndTime)\n\tcase Rejected:\n\t\tquery = query.Where(\"modification_date BETWEEN ? AND ? AND suspension_time IS NOT NULL\", t.StartTime, t.EndTime)\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported audit status\")\n\t}\n\n\terr := query.Order(\"modification_date DESC\").Find(&mediaList).Error\n\treturn mediaList, err\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleTextbookAudit",
        "code_value": "func HandleTextbookAudit() ([]types.MediaInfo, error) {\n\tbook := &Textbook{\n\t\tAuditStatus: Approved,\n\t\tEndTime:     time.Now().Add(-24 * time.Hour),\n\t}\n\tmediaItems, err := book.AuditChanges()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to audit textbooks: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn mediaItems, nil\n}"
      },
      {
        "code_key": "ProcessPendingTextbooks",
        "code_value": "func ProcessPendingTextbooks(lang string) error {\n\ttextbook := Textbook{\n\t\tAuditStatus: Pending,\n\t\tStartTime:   time.Now().Add(-7 * 24 * time.Hour),\n\t\tLanguage:    lang,\n\t}\n\n\tresults, err := textbook.AuditChanges()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"pending audit failed: %w\", err)\n\t}\n\t\n\tlog.Printf(\"Found %d pending textbooks for language %s\", len(results), lang)\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Textbook",
        "code_value": "type Textbook struct {\n\tAuditStatus  int\n\tStartTime    int64\n\tEndTime      int64\n\tLanguage     string\n\tCommentFunc  func(string) hints.Hints\n}"
      },
      {
        "code_key": "MediaInfo",
        "code_value": "type MediaInfo struct {\n\tID              int    `gorm:\"column:id\"`\n\tModificationDate int64  `gorm:\"column:modification_date\"`\n\tLanguage        string `gorm:\"column:language\"`\n\tSuspensionTime  *int64 `gorm:\"column:suspension_time\"`\n}"
      },
      {
        "code_key": "AuditStatus",
        "code_value": "const (\n\tPending   = 1\n\tApproved  = 2\n\tRejected  = 3\n)"
      },
      {
        "code_key": "SELECT_COMMENT",
        "code_value": "const SELECT_COMMENT = \"SELECT\""
      },
      {
        "code_key": "UserProfilesTable",
        "code_value": "const UserProfilesTable = \"user_profiles\""
      },
      {
        "code_key": "BaseInstance",
        "code_value": "var BaseInstance = base.GetInstance()"
      }
    ]
  },
  "synthetic_switch_QueryByCondition": {
    "scenario": "switch",
    "code_key": "QueryByCondition",
    "code_value": "func (r *Resource) QueryByCondition() ([]Timeline, error) {\n\ttimelines := make([]Timeline, 0)\n\tquery := base.GetInstance().ResourceDriver().Table(\"price_history\")\n\t\n\tswitch r.Subject {\n\tcase \"monthly\":\n\t\tquery = query.Where(\"created_at >= DATE_SUB(NOW(), INTERVAL 1 MONTH)\")\n\tcase \"yearly\":\n\t\tquery = query.Where(\"created_at >= DATE_SUB(NOW(), INTERVAL 1 YEAR)\")\n\tcase \"daily\":\n\t\tquery = query.Where(\"created_at >= DATE_SUB(NOW(), INTERVAL 1 DAY)\")\n\tdefault:\n\t\tquery = query.Where(\"created_at >= ?\", r.Content)\n\t}\n\t\n\tif r.TableName != \"\" {\n\t\tquery = query.Where(\"table_name = ?\", r.TableName)\n\t}\n\t\n\terr := query.Order(\"created_at DESC\").Find(&timelines).Error\n\treturn timelines, err\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandlePriceHistory",
        "code_value": "func HandlePriceHistory() ([]Timeline, error) {\n\tpriceResource := &Resource{\n\t\tSubject:   \"monthly\",\n\t\tTableName: \"stock_prices\",\n\t}\n\t\n\trecords, err := priceResource.QueryByCondition()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to query price history: %v\", err)\n\t}\n\treturn records, nil\n}"
      },
      {
        "code_key": "ProcessRecentInventory",
        "code_value": "func ProcessRecentInventory() error {\n\tinvResource := &Resource{\n\t\tSubject:   \"daily\",\n\t\tTableName: \"inventory_log\",\n\t}\n\t\n\titems, err := invResource.QueryByCondition()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"inventory query failed: %w\", err)\n\t}\n\t\n\t// Process inventory items here\n\tfmt.Printf(\"Found %d recent inventory changes\\n\", len(items))\n\treturn nil\n}"
      },
      {
        "code_key": "GetAnnualSalesData",
        "code_value": "func GetAnnualSalesData() ([]Timeline, error) {\n\tsalesFilter := &Resource{\n\t\tSubject: \"yearly\",\n\t}\n\t\n\tresults, err := salesFilter.QueryByCondition()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"sales data retrieval error: %s\", err.Error())\n\t}\n\treturn results, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Resource",
        "code_value": "type Resource struct {\n\tSubject   string\n\tTableName string\n\tContent   string\n}"
      },
      {
        "code_key": "Timeline",
        "code_value": "type Timeline struct {\n\tID        int       `gorm:\"column:id\"`\n\tCreatedAt time.Time `gorm:\"column:created_at\"`\n\tTableName string    `gorm:\"column:table_name\"`\n}"
      },
      {
        "code_key": "price_history",
        "code_value": "const price_history = \"price_history\""
      },
      {
        "code_key": "TimeInterval",
        "code_value": "const (\n\tDailyInterval   = \"daily\"\n\tMonthlyInterval = \"monthly\"\n\tYearlyInterval  = \"yearly\"\n)"
      },
      {
        "code_key": "base",
        "code_value": "var base *BaseInstance"
      },
      {
        "code_key": "BaseInstance",
        "code_value": "type BaseInstance struct {\n\tdb *gorm.DB\n}"
      }
    ]
  },
  "synthetic_switch_MoveToArchive": {
    "scenario": "switch",
    "code_key": "MoveToArchive",
    "code_value": "func (f *Forecast) MoveToArchive() (int64, error) {\n\tvar result int64\n\tfilter := map[string]interface{}{\"status\": 1}\n\tswitch f.ApprovalLevel {\n\tcase 1:\n\t\tfilter[\"priority\"] = \"high\"\n\tcase 2:\n\t\tfilter[\"priority\"] = \"medium\"\n\tcase 3:\n\t\tfilter[\"priority\"] = \"low\"\n\tdefault:\n\t\treturn 0, errors.New(\"invalid approval level\")\n\t}\n\n\tif f.SequenceNumber > 0 {\n\t\tfilter[\"sequence_number\"] = f.SequenceNumber\n\t}\n\n\terr := base.GetInstance().ContentDriver().Table(\"content_archive\").\n\t\tWhere(filter).Count(&result).Error\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn result, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleArchiveMigration",
        "code_value": "func HandleArchiveMigration() {\n\tarchiveForecast := &Forecast{\n\t\tApprovalLevel: 2,\n\t\tSequenceNumber: 1001,\n\t}\n\n\tcount, err := archiveForecast.MoveToArchive()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to migrate forecast: %v\", err)\n\t\treturn\n\t}\n\tlog.Printf(\"Successfully archived %d records\", count)\n}"
      },
      {
        "code_key": "ProcessPriorityArchival",
        "code_value": "func ProcessPriorityArchival() error {\n\thighPriorityRecord := Forecast{\n\t\tApprovalLevel: 1,\n\t\tSequenceNumber: 0, // Intentionally left blank\n\t}\n\n\tarchivedCount, archErr := highPriorityRecord.MoveToArchive()\n\tif archErr != nil {\n\t\treturn fmt.Errorf(\"archival failed: %w\", archErr)\n\t}\n\n\tif archivedCount == 0 {\n\t\treturn errors.New(\"no matching records found\")\n\t}\n\treturn nil\n}"
      },
      {
        "code_key": "BatchArchiveLowPriority",
        "code_value": "func BatchArchiveLowPriority(batchID int) (int64, error) {\n\tlowPriorityBatch := &Forecast{\n\t\tApprovalLevel: 3,\n\t\tSequenceNumber: int64(batchID),\n\t}\n\n\tresult, err := lowPriorityBatch.MoveToArchive()\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"batch archive failed for ID %d: %v\", batchID, err)\n\t}\n\n\tif result == 0 {\n\t\tlog.Printf(\"Warning: No records archived for batch %d\", batchID)\n\t}\n\treturn result, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Forecast",
        "code_value": "type Forecast struct {\n\tApprovalLevel int\n\tSequenceNumber int\n}"
      },
      {
        "code_key": "ArchiveFilter",
        "code_value": "type ArchiveFilter struct {\n\tStatus        int\n\tPriority      string\n\tSequenceNumber int `gorm:\"column:sequence_number\"`\n}"
      },
      {
        "code_key": "ContentArchiveTable",
        "code_value": "const ContentArchiveTable = \"content_archive\""
      },
      {
        "code_key": "ApprovalStatus",
        "code_value": "const (\n\tHighPriority = \"high\"\n\tMediumPriority = \"medium\"\n\tLowPriority = \"low\"\n)"
      },
      {
        "code_key": "BaseError",
        "code_value": "var BaseError = errors.New(\"database operation failed\")"
      },
      {
        "code_key": "ArchiveResult",
        "code_value": "type ArchiveResult struct {\n\tCount int64 `gorm:\"column:count\"`\n}"
      }
    ]
  },
  "synthetic_switch_ScheduleDelivery": {
    "scenario": "switch",
    "code_key": "ScheduleDelivery",
    "code_value": "func (v *Vehicle) ScheduleDelivery() ([]DeliverySlot, error) {\n\tslots := make([]DeliverySlot, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tswitch v.VehicleType {\n\tcase Refrigerated:\n\t\tfilter[\"temperature_controlled\"] = 1\n\tcase Oversized:\n\t\tfilter[\"weight_limit\"] = 5000\n\tcase Hazardous:\n\t\tfilter[\"hazardous_material\"] = 1\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported vehicle type\")\n\t}\n\n\terr := base.GetInstance().FleetDriver().Table(\"vehicle_fleet\").\n\t\tWhere(filter).\n\t\tWhere(\"available_from <= ? AND available_to >= ?\", v.StartTime, v.EndTime).\n\t\tFind(&slots).Error\n\n\treturn slots, err\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "ProcessDeliveryRequest",
        "code_value": "func ProcessDeliveryRequest() {\n\tcarrier := &Vehicle{\n\t\tVehicleType: Refrigerated,\n\t\tStartTime:   time.Now(),\n\t\tEndTime:     time.Now().Add(24 * time.Hour),\n\t}\n\n\tdeliveryWindows, err := carrier.ScheduleDelivery()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to schedule delivery: %v\", err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"Available slots: %+v\\n\", deliveryWindows)\n}"
      },
      {
        "code_key": "HandleFleetAllocation",
        "code_value": "func HandleFleetAllocation(transportType string) error {\n\ttruck := &Vehicle{\n\t\tVehicleType: transportType,\n\t\tStartTime:   time.Now().Add(2 * time.Hour),\n\t\tEndTime:     time.Now().Add(6 * time.Hour),\n\t}\n\n\tallocations, err := truck.ScheduleDelivery()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"allocation failed: %w\", err)\n\t}\n\n\tif len(allocations) == 0 {\n\t\treturn errors.New(\"no available slots\")\n\t}\n\treturn nil\n}"
      },
      {
        "code_key": "ExecuteDeliveryPlan",
        "code_value": "func ExecuteDeliveryPlan() ([]DeliverySlot, error) {\n\theavyLoadTruck := &Vehicle{\n\t\tVehicleType: \"Oversized\",\n\t\tStartTime:   time.Date(2023, 11, 15, 8, 0, 0, 0, time.UTC),\n\t\tEndTime:     time.Date(2023, 11, 15, 18, 0, 0, 0, time.UTC),\n\t}\n\n\tavailableTimes, err := heavyLoadTruck.ScheduleDelivery()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"delivery scheduling error: %w\", err)\n\t}\n\n\tif len(availableTimes) < 3 {\n\t\treturn nil, errors.New(\"insufficient delivery windows\")\n\t}\n\treturn availableTimes, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Vehicle",
        "code_value": "type Vehicle struct {\n\tVehicleType VehicleType\n\tStartTime   int64\n\tEndTime     int64\n}"
      },
      {
        "code_key": "DeliverySlot",
        "code_value": "type DeliverySlot struct {\n\tSlotId     int `gorm:\"column:slot_id\"`\n\tStartTime  int64 `gorm:\"column:start_time\"`\n\tEndTime    int64 `gorm:\"column:end_time\"`\n\tIsAvailable bool `gorm:\"column:is_available\"`\n}"
      },
      {
        "code_key": "VehicleType",
        "code_value": "type VehicleType int\nconst (\n\tRefrigerated VehicleType = iota + 1\n\tOversized\n\tHazardous\n)"
      },
      {
        "code_key": "DeliveryStatus",
        "code_value": "const (\n\tDeliveryPending = 0\n\tDeliveryScheduled = 1\n\tDeliveryCompleted = 2\n)"
      },
      {
        "code_key": "DeliveryTable",
        "code_value": "const DeliveryTable = \"delivery_slots\""
      },
      {
        "code_key": "base",
        "code_value": "var base struct {\n\tGetInstance func() *Database\n}"
      },
      {
        "code_key": "Database",
        "code_value": "type Database struct {\n\tFleetDriver func() *gorm.DB\n}"
      }
    ]
  },
  "synthetic_switch_OptimizePerformance": {
    "scenario": "switch",
    "code_key": "OptimizePerformance",
    "code_value": "func (w *Wishlist) OptimizePerformance() ([]Blog, error) {\n\tblogs := make([]Blog, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tswitch w.Building {\n\tcase \"Residential\":\n\t\tfilter[\"weight\"] = 50\n\tcase \"Commercial\":\n\t\tfilter[\"weight\"] = 100\n\tcase \"Industrial\":\n\t\tfilter[\"weight\"] = 200\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported building type\")\n\t}\n\n\terr := base.GetInstance().BlogDriver().Table(\"shopping_carts\").\n\t\tWhere(filter).\n\t\tWhere(\"namespace_name LIKE ?\", w.NamespaceName+\"%\").\n\t\tOrder(\"created_at DESC\").\n\t\tFind(&blogs).Error\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn blogs, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleResidentialBlogs",
        "code_value": "func HandleResidentialBlogs() ([]Blog, error) {\n\tuserWishlist := Wishlist{\n\t\tBuilding:      \"Residential\",\n\t\tNamespaceName: \"home_decor\",\n\t}\n\tresult, err := userWishlist.OptimizePerformance()\n\tif err != nil {\n\t\tlog.Printf(\"Error optimizing residential blogs: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn result, nil\n}"
      },
      {
        "code_key": "ProcessCommercialContent",
        "code_value": "func ProcessCommercialContent(namespace string) ([]Blog, error) {\n\tstorePrefs := Wishlist{\n\t\tBuilding:      \"Commercial\",\n\t\tNamespaceName: namespace,\n\t}\n\tblogs, err := storePrefs.OptimizePerformance()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to process commercial content: %v\", err)\n\t\treturn nil, fmt.Errorf(\"content processing failed: %w\", err)\n\t}\n\treturn blogs, nil\n}"
      },
      {
        "code_key": "FetchIndustrialArticles",
        "code_value": "func FetchIndustrialArticles() {\n\tfactoryWish := Wishlist{\n\t\tBuilding:      \"Industrial\",\n\t\tNamespaceName: \"heavy_machinery\",\n\t}\n\tarticles, err := factoryWish.OptimizePerformance()\n\tif err != nil {\n\t\tlog.Fatalf(\"Critical failure fetching industrial articles: %v\", err)\n\t}\n\tfmt.Printf(\"Found %d industrial articles\\n\", len(articles))\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Wishlist",
        "code_value": "type Wishlist struct {\n\tBuilding       string\n\tNamespaceName  string\n\tOptimizationID int\n}"
      },
      {
        "code_key": "Blog",
        "code_value": "type Blog struct {\n\tID         int       `gorm:\"column:id\"`\n\tTitle      string    `gorm:\"column:title\"`\n\tContent    string    `gorm:\"column:content\"`\n\tStatus     int       `gorm:\"column:status\"`\n\tWeight     int       `gorm:\"column:weight\"`\n\tCreatedAt  time.Time `gorm:\"column:created_at\"`\n\tNamespace  string    `gorm:\"column:namespace_name\"`\n}"
      },
      {
        "code_key": "ShoppingCartTable",
        "code_value": "const ShoppingCartTable = \"shopping_carts\""
      },
      {
        "code_key": "BlogStatusActive",
        "code_value": "const BlogStatusActive = 1"
      },
      {
        "code_key": "BuildingTypeResidential",
        "code_value": "const BuildingTypeResidential = \"Residential\""
      },
      {
        "code_key": "BuildingTypeCommercial",
        "code_value": "const BuildingTypeCommercial = \"Commercial\""
      },
      {
        "code_key": "BuildingTypeIndustrial",
        "code_value": "const BuildingTypeIndustrial = \"Industrial\""
      }
    ]
  },
  "synthetic_switch_FilterBySecurityLevel": {
    "scenario": "switch",
    "code_key": "FilterBySecurityLevel",
    "code_value": "func (e *Employee) FilterBySecurityLevel() ([]EmployeeRecord, error) {\n\trecords := make([]EmployeeRecord, 0)\n\tquery := base.GetInstance().PersonnelDriver().Table(\"shipping_manifest\")\n\n\tswitch e.SecurityLevel {\n\tcase 1:\n\t\tquery = query.Where(\"security_level = ? AND activation_date >= ?\", 1, e.StartDate)\n\tcase 2:\n\t\tquery = query.Where(\"security_level = ? AND phone_number IS NOT NULL\", 2)\n\tcase 3:\n\t\tquery = query.Where(\"security_level = ? AND verified = ?\", 3, true)\n\tdefault:\n\t\treturn nil, errors.New(\"invalid security level\")\n\t}\n\n\terr := query.Order(\"created_at DESC\").Find(&records).Error\n\treturn records, err\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleShippingManifest",
        "code_value": "func HandleShippingManifest() ([]EmployeeRecord, error) {\n\temp := &Employee{\n\t\tSecurityLevel: 2,\n\t\tStartDate:    time.Now().AddDate(0, -1, 0),\n\t}\n\n\trecords, err := emp.FilterBySecurityLevel()\n\tif err != nil {\n\t\tlog.Printf(\"Error filtering manifests: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}"
      },
      {
        "code_key": "ProcessSecureEmployees",
        "code_value": "func ProcessSecureEmployees(level int, start time.Time) error {\n\tstaff := &Employee{\n\t\tSecurityLevel: level,\n\t\tStartDate:    start,\n\t}\n\n\tresults, err := staff.FilterBySecurityLevel()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"security filter failed: %w\", err)\n\t}\n\n\t// Process records...\n\tfmt.Printf(\"Found %d secure employees\\n\", len(results))\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Employee",
        "code_value": "type Employee struct {\n\tSecurityLevel int\n\tStartDate     time.Time\n}"
      },
      {
        "code_key": "EmployeeRecord",
        "code_value": "type EmployeeRecord struct {\n\tID            int       `gorm:\"column:id\"`\n\tSecurityLevel int       `gorm:\"column:security_level\"`\n\tActivationDate time.Time `gorm:\"column:activation_date\"`\n\tPhoneNumber   string    `gorm:\"column:phone_number\"`\n\tVerified      bool      `gorm:\"column:verified\"`\n\tCreatedAt     time.Time `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "ShippingManifestTable",
        "code_value": "const ShippingManifestTable = \"shipping_manifest\""
      },
      {
        "code_key": "SecurityLevelConstants",
        "code_value": "const (\n\tSecurityLevelBasic = 1\n\tSecurityLevelMedium = 2\n\tSecurityLevelHigh = 3\n)"
      }
    ]
  },
  "synthetic_switch_ValidatePermissions": {
    "scenario": "switch",
    "code_key": "ValidatePermissions",
    "code_value": "func (p *Player) ValidatePermissions() (bool, error) {\n\tvar accessLevel int\n\tcomment := p.CommentFunc(SELECT_COMMENT)\n\tquery := base.GetInstance().AuthDriver().Clauses(comment).Table(\"media_uploads\")\n\t\n\tswitch p.Role {\n\tcase \"admin\":\n\t\taccessLevel = 3\n\tcase \"editor\":\n\t\taccessLevel = 2\n\tcase \"viewer\":\n\t\taccessLevel = 1\n\tdefault:\n\t\treturn false, errors.New(\"invalid role\")\n\t}\n\t\n\tvar result struct {\n\t\tHasAccess bool `gorm:\"column:has_access\"`\n\t}\n\terr := query.Select(\"COUNT(1) > 0 AS has_access\").\n\t\tWhere(\"priority_rank <= ? AND product_code = ?\", accessLevel, p.ProductCode).\n\t\tScan(&result).Error\n\t\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn result.HasAccess, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "CheckMediaAccess",
        "code_value": "func CheckMediaAccess(userRole string, productID string) {\n\tmediaUser := &Player{\n\t\tRole:        userRole,\n\t\tProductCode: productID,\n\t}\n\n\thasAccess, err := mediaUser.ValidatePermissions()\n\tif err != nil {\n\t\tlog.Printf(\"Permission check failed: %v\", err)\n\t\treturn\n\t}\n\n\tif hasAccess {\n\t\tlog.Println(\"Access granted to media resources\")\n\t} else {\n\t\tlog.Println(\"Access denied to media resources\")\n\t}\n}"
      },
      {
        "code_key": "ProcessContentUpload",
        "code_value": "func ProcessContentUpload() error {\n\tcontentEditor := &Player{\n\t\tRole:        \"editor\",\n\t\tProductCode: \"PROD_789\",\n\t}\n\n\tapproved, verr := contentEditor.ValidatePermissions()\n\tif verr != nil {\n\t\treturn fmt.Errorf(\"validation failed: %w\", verr)\n\t}\n\n\tif !approved {\n\t\treturn errors.New(\"insufficient permissions for upload\")\n\t}\n\n\t// Proceed with upload logic\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Player",
        "code_value": "type Player struct {\n\tRole        string\n\tProductCode string\n\t*PermissionComment\n}"
      },
      {
        "code_key": "PermissionComment",
        "code_value": "type PermissionComment string\nconst SELECT_COMMENT = \"PERMISSION_CHECK\""
      },
      {
        "code_key": "MediaAccessResult",
        "code_value": "type MediaAccessResult struct {\n\tHasAccess bool `gorm:\"column:has_access\"`\n}"
      },
      {
        "code_key": "AuthDriverConfig",
        "code_value": "const MediaUploadsTable = \"media_uploads\""
      }
    ]
  },
  "synthetic_switch_MonitorHealth": {
    "scenario": "switch",
    "code_key": "MonitorHealth",
    "code_value": "func (w *Weapon) MonitorHealth(threshold int) ([]LabResults, error) {\n\tresults := make([]LabResults, 0)\n\tquery := base.GetInstance().LabDriver().Table(\"lab_test_results\")\n\n\tswitch w.CategoryType {\n\tcase 1:\n\t\tquery = query.Where(\"dimension = ? AND continent = ?\", w.Dimension, \"NA\")\n\tcase 2:\n\t\tquery = query.Where(\"dimension = ? AND continent IN (?)\", w.Dimension, []string{\"EU\", \"AS\"})\n\tcase 3:\n\t\tquery = query.Where(\"dimension > ?\", threshold)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported category type\")\n\t}\n\n\terr := query.Order(\"test_date DESC\").Limit(100).Find(&results).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleWeaponAnalysis",
        "code_value": "func HandleWeaponAnalysis() {\n\twep := &Weapon{\n\t\tCategoryType: 2,\n\t\tDimension:    15,\n\t}\n\n\tdataPoints, err := wep.MonitorHealth(10)\n\tif err != nil {\n\t\tlog.Printf(\"Failed to analyze weapon: %v\", err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"Retrieved %d test results\\n\", len(dataPoints))\n}"
      },
      {
        "code_key": "ProcessCriticalHealthChecks",
        "code_value": "func ProcessCriticalHealthChecks() error {\n\tcriticalWeapon := &Weapon{\n\t\tCategoryType: 3,\n\t\tDimension:    25,\n\t}\n\n\tlabReports, err := criticalWeapon.MonitorHealth(20)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"health check failure: %w\", err)\n\t}\n\n\tif len(labReports) == 0 {\n\t\treturn errors.New(\"no health data available\")\n\t}\n\treturn nil\n}"
      },
      {
        "code_key": "CheckRegionalWeapons",
        "code_value": "func CheckRegionalWeapons(regionCode int) {\n\tdevice := Weapon{\n\t\tCategoryType: regionCode,\n\t\tDimension:    8,\n\t}\n\n\tresults, err := device.MonitorHealth(5)\n\tif err != nil {\n\t\tlog.Println(\"Regional check failed:\", err)\n\t\treturn\n\t}\n\n\tfor _, r := range results {\n\t\tfmt.Println(r.TestDate, \"-\", r.Status)\n\t}\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "LabResults",
        "code_value": "type LabResults struct {\n\tTestID      int    `gorm:\"column:test_id\"`\n\tDimension   int    `gorm:\"column:dimension\"`\n\tContinent   string `gorm:\"column:continent\"`\n\tTestDate    string `gorm:\"column:test_date\"`\n\tResultValue int    `gorm:\"column:result_value\"`\n}"
      },
      {
        "code_key": "Weapon",
        "code_value": "type Weapon struct {\n\tCategoryType int\n\tDimension    int\n}"
      },
      {
        "code_key": "LabTestTable",
        "code_value": "const LabTestTable = \"lab_test_results\""
      },
      {
        "code_key": "DefaultThreshold",
        "code_value": "const DefaultThreshold = 50"
      },
      {
        "code_key": "HealthStatus",
        "code_value": "type HealthStatus int\nconst (\n\tCritical HealthStatus = iota\n\tWarning\n\tNormal\n)"
      }
    ]
  },
  "synthetic_switch_SyncWithExternal": {
    "scenario": "switch",
    "code_key": "SyncWithExternal",
    "code_value": "func (e *Employee) SyncWithExternal() error {\n\tvar policies []InsurancePolicy\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tswitch e.Department {\n\tcase \"Finance\":\n\t\tfilter[\"policy_type\"] = \"corporate\"\n\tcase \"HR\":\n\t\tfilter[\"policy_type\"] = \"employee_benefit\"\n\tcase \"IT\":\n\t\tfilter[\"policy_type\"] = \"equipment_coverage\"\n\tdefault:\n\t\treturn errors.New(\"unsupported department\")\n\t}\n\n\tif e.EmployeeId > 0 {\n\t\tfilter[\"employee_id\"] = e.EmployeeId\n\t}\n\n\terr := base.GetInstance().DB().Table(\"insurance_policies\").\n\t\tWhere(filter).Find(&policies).Error\n\t\n\tif err != nil {\n\t\treturn fmt.Errorf(\"sync failed: %v\", err)\n\t}\n\treturn nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleEmployeeSync",
        "code_value": "func HandleEmployeeSync() error {\n\tstaff := &Employee{\n\t\tEmployeeId: 1001,\n\t\tDepartment: \"HR\",\n\t}\n\terr := staff.SyncWithExternal()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to sync HR policies: %v\", err)\n\t\treturn err\n\t}\n\tfmt.Println(\"HR policies synced successfully\")\n\treturn nil\n}"
      },
      {
        "code_key": "ProcessFinancePolicies",
        "code_value": "func ProcessFinancePolicies(empID int) error {\n\taccountant := Employee{\n\t\tEmployeeId: empID,\n\t\tDepartment: \"Finance\",\n\t}\n\tif err := accountant.SyncWithExternal(); err != nil {\n\t\treturn fmt.Errorf(\"finance policy sync error: %w\", err)\n\t}\n\tfmt.Printf(\"Corporate policies updated for employee %d\\n\", empID)\n\treturn nil\n}"
      },
      {
        "code_key": "UpdateITEquipmentCoverage",
        "code_value": "func UpdateITEquipmentCoverage() {\n\tdevOps := Employee{Department: \"IT\"}\n\tif err := devOps.SyncWithExternal(); err != nil {\n\t\tlog.Fatalf(\"IT equipment sync failed: %v\", err)\n\t}\n\tfmt.Println(\"All IT equipment coverage policies updated\")\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Employee",
        "code_value": "type Employee struct {\n\tEmployeeId int\n\tDepartment string\n}"
      },
      {
        "code_key": "InsurancePolicy",
        "code_value": "type InsurancePolicy struct {\n\tPolicyType string `gorm:\"column:policy_type\"`\n\tEmployeeId int    `gorm:\"column:employee_id\"`\n\tStatus     int    `gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "InsurancePolicyTable",
        "code_value": "const InsurancePolicyTable = \"insurance_policies\""
      },
      {
        "code_key": "PolicyStatusActive",
        "code_value": "const PolicyStatusActive = 1"
      },
      {
        "code_key": "PolicyTypeCorporate",
        "code_value": "const PolicyTypeCorporate = \"corporate\""
      },
      {
        "code_key": "PolicyTypeEmployeeBenefit",
        "code_value": "const PolicyTypeEmployeeBenefit = \"employee_benefit\""
      },
      {
        "code_key": "PolicyTypeEquipmentCoverage",
        "code_value": "const PolicyTypeEquipmentCoverage = \"equipment_coverage\""
      }
    ]
  },
  "synthetic_switch_MeasureEfficiency": {
    "scenario": "switch",
    "code_key": "MeasureEfficiency",
    "code_value": "func (s *Section) MeasureEfficiency() ([]Portfolio, error) {\n\tportfolios := make([]Portfolio, 0)\n\tfilter := map[string]interface{}{\"status\": 1}\n\t\n\tif s.CategoryType > 0 {\n\t\tswitch s.CategoryType {\n\t\tcase 1:\n\t\t\tfilter[\"gross_value\"] = 100\n\t\tcase 2:\n\t\t\tfilter[\"gross_value\"] = 200\n\t\tcase 3:\n\t\t\tfilter[\"configuration_key\"] = \"premium\"\n\t\tdefault:\n\t\t\treturn nil, errors.New(\"unsupported category type\")\n\t\t}\n\t}\n\t\n\terr := base.GetInstance().ContentDriver().Table(\"content_licenses\").\n\t\tWhere(filter).Order(\"created_at DESC\").Find(&portfolios).Error\n\t\t\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn portfolios, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandlePremiumContent",
        "code_value": "func HandlePremiumContent() ([]Portfolio, error) {\n\tcontentSection := Section{CategoryType: 3}\n\tpremiumPortfolios, err := contentSection.MeasureEfficiency()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to measure premium content efficiency: %v\", err)\n\t}\n\treturn premiumPortfolios, nil\n}"
      },
      {
        "code_key": "AnalyzeHighValueAssets",
        "code_value": "func AnalyzeHighValueAssets(category int) ([]Portfolio, error) {\n\tif category < 1 || category > 2 {\n\t\treturn nil, errors.New(\"invalid category for high value assets\")\n\t}\n\tassetSection := Section{CategoryType: category}\n\tresults, err := assetSection.MeasureEfficiency()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"high value analysis failed: %v\", err)\n\t}\n\treturn results, nil\n}"
      },
      {
        "code_key": "ProcessActiveLicenses",
        "code_value": "func ProcessActiveLicenses() error {\n\tdefaultSection := Section{CategoryType: 0}\n\tactivePortfolios, err := defaultSection.MeasureEfficiency()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"license processing error: %v\", err)\n\t}\n\tif len(activePortfolios) == 0 {\n\t\treturn errors.New(\"no active licenses found\")\n\t}\n\t// Process portfolios here\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Portfolio",
        "code_value": "type Portfolio struct {\n\tID              int    `gorm:\"column:id\"`\n\tGrossValue      int    `gorm:\"column:gross_value\"`\n\tConfiguration   string `gorm:\"column:configuration_key\"`\n\tStatus          int    `gorm:\"column:status\"`\n\tCreatedAt       string `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "Section",
        "code_value": "type Section struct {\n\tCategoryType int\n}"
      },
      {
        "code_key": "ContentLicenseTable",
        "code_value": "const ContentLicenseTable = \"content_licenses\""
      },
      {
        "code_key": "PortfolioStatus",
        "code_value": "const PortfolioStatusActive = 1\nconst PortfolioStatusInactive = 0"
      },
      {
        "code_key": "EfficiencyThresholds",
        "code_value": "var EfficiencyThresholds = map[int]int{\n\t1: 100,\n\t2: 200,\n\t3: 0 // Premium has no threshold\n}"
      }
    ]
  },
  "synthetic_switch_UpdateEntity": {
    "scenario": "switch",
    "code_key": "UpdateEntity",
    "code_value": "func (b *Brand) UpdateEntity() error {\n\tupdateFields := make(map[string]interface{})\n\tif b.LocationCode != \"\" {\n\t\tupdateFields[\"location_code\"] = b.LocationCode\n\t}\n\tif b.FirstName != \"\" {\n\t\tupdateFields[\"first_name\"] = b.FirstName\n\t}\n\tif b.Author != \"\" {\n\t\tupdateFields[\"author\"] = b.Author\n\t}\n\tif len(updateFields) == 0 {\n\t\treturn nil\n\t}\n\tswitch b.Status {\n\tcase \"active\":\n\t\tupdateFields[\"is_active\"] = true\n\tcase \"inactive\":\n\t\tupdateFields[\"is_active\"] = false\n\tcase \"archived\":\n\t\tupdateFields[\"is_archived\"] = true\n\tdefault:\n\t\treturn fmt.Errorf(\"invalid status: %s\", b.Status)\n\t}\n\treturn base.GetInstance().BrandDriver().Table(\"skill_trees\").Where(\"id = ?\", b.ID).Updates(updateFields).Error\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleBrandUpdate",
        "code_value": "func HandleBrandUpdate(brandID uint, location, firstName string) error {\n\tbrand := &Brand{\n\t\tID:          brandID,\n\t\tLocationCode: location,\n\t\tFirstName:    firstName,\n\t\tStatus:      \"active\",\n\t}\n\tif err := brand.UpdateEntity(); err != nil {\n\t\tlog.Printf(\"Failed to update brand: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}"
      },
      {
        "code_key": "ArchiveBrandRecord",
        "code_value": "func ArchiveBrandRecord(recordID uint) error {\n\tarchivedBrand := &Brand{\n\t\tID:     recordID,\n\t\tStatus: \"archived\",\n\t}\n\terr := archivedBrand.UpdateEntity()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to archive brand ID %d: %v\", recordID, err)\n\t\treturn fmt.Errorf(\"archive operation failed\")\n\t}\n\treturn nil\n}"
      },
      {
        "code_key": "DeactivateBrandProfile",
        "code_value": "func DeactivateBrandProfile(profileID uint, authorName string) error {\n\tprofile := &Brand{\n\t\tID:     profileID,\n\t\tAuthor: authorName,\n\t\tStatus: \"inactive\",\n\t}\n\tif updateErr := profile.UpdateEntity(); updateErr != nil {\n\t\treturn fmt.Errorf(\"deactivation failed: %w\", updateErr)\n\t}\n\tlog.Printf(\"Successfully deactivated brand profile %d\", profileID)\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Brand",
        "code_value": "type Brand struct {\n\tID           int\n\tLocationCode string\n\tFirstName    string\n\tAuthor       string\n\tStatus       string\n\tIsActive     bool\n\tIsArchived   bool\n}"
      },
      {
        "code_key": "BaseDriver",
        "code_value": "var BaseDriver *gorm.DB"
      },
      {
        "code_key": "BrandStatus",
        "code_value": "const (\n\tActiveStatus   = \"active\"\n\tInactiveStatus = \"inactive\"\n\tArchivedStatus = \"archived\"\n)"
      },
      {
        "code_key": "SkillTreeTable",
        "code_value": "const SkillTreeTable = \"skill_trees\""
      },
      {
        "code_key": "ErrorMessages",
        "code_value": "const (\n\tInvalidStatusError = \"invalid status: %s\"\n)"
      }
    ]
  },
  "synthetic_switch_AggregateByType": {
    "scenario": "switch",
    "code_key": "AggregateByType",
    "code_value": "func (t *Trade) AggregateByType() ([]RegionBalance, error) {\n\tbalances := make([]RegionBalance, 0)\n\tfilter := map[string]interface{}{\"status\": 1}\n\t\n\tswitch t.TradeType {\n\tcase Domestic:\n\t\tfilter[\"domestic\"] = 1\n\tcase International:\n\t\tfilter[\"domestic\"] = 0\n\tcase Digital:\n\t\tfilter[\"digital\"] = 1\n\tcase Physical:\n\t\tfilter[\"digital\"] = 0\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported trade type\")\n\t}\n\t\n\tif t.RegionCode != \"\" {\n\t\tfilter[\"region_code\"] = t.RegionCode\n\t}\n\t\n\terr := base.GetInstance().TradeDriver().Table(\"transit_times\")\n\t\t.Select(\"region_code, sum(balance) as balance\")\n\t\t.Where(filter).Group(\"region_code\").Scan(&balances).Error\n\t\t\n\treturn balances, err\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleRegionBalance",
        "code_value": "func HandleRegionBalance() ([]RegionBalance, error) {\n\tdeal := &Trade{\n\t\tTradeType:  Domestic,\n\t\tRegionCode: \"US\",\n\t}\n\t\n\tresults, err := deal.AggregateByType()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to aggregate: %v\", err)\n\t}\n\t\n\treturn results, nil\n}"
      },
      {
        "code_key": "ProcessGlobalTransactions",
        "code_value": "func ProcessGlobalTransactions() (float64, error) {\n\tintlTrade := &Trade{\n\t\tTradeType: International,\n\t}\n\t\n\tregionBalances, err := intlTrade.AggregateByType()\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"international trade aggregation failed: %v\", err)\n\t}\n\t\n\ttotal := 0.0\n\tfor _, rb := range regionBalances {\n\t\ttotal += rb.Balance\n\t}\n\treturn total, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Trade",
        "code_value": "type Trade struct {\n\tTradeType   TradeType\n\tRegionCode  string\n}"
      },
      {
        "code_key": "RegionBalance",
        "code_value": "type RegionBalance struct {\n\tRegionCode string `gorm:\"column:region_code\"`\n\tBalance    float64 `gorm:\"column:balance\"`\n}"
      },
      {
        "code_key": "TradeType",
        "code_value": "type TradeType int\nconst (\n\tDomestic TradeType = iota + 1\n\tInternational\n\tDigital\n\tPhysical\n)"
      },
      {
        "code_key": "TransitTimesTable",
        "code_value": "const TransitTimesTable = \"transit_times\""
      },
      {
        "code_key": "TradeStatus",
        "code_value": "const TradeStatusActive = 1"
      }
    ]
  },
  "synthetic_switch_CompareData": {
    "scenario": "switch",
    "code_key": "CompareData",
    "code_value": "func (s *Seller) CompareData() ([]Tag, error) {\n\ttags := make([]Tag, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tif s.EntityId > 0 {\n\t\tswitch s.EntityId {\n\t\tcase 1:\n\t\t\tfilter[\"category_type\"] = \"premium\"\n\t\tcase 2:\n\t\t\tfilter[\"category_type\"] = \"standard\"\n\t\tcase 3:\n\t\t\tfilter[\"category_type\"] = \"basic\"\n\t\tdefault:\n\t\t\treturn nil, errors.New(\"unsupported entity type\")\n\t\t}\n\t}\n\n\terr := base.GetInstance().ReadDriver().Table(\"product_categories\").\n\t\tWhere(filter).\n\t\tWhere(\"created_at >= ?\", s.StartTime).\n\t\tOrder(\"price DESC\").\n\t\tFind(&tags).Error\n\n\treturn tags, err\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandlePremiumCategories",
        "code_value": "func HandlePremiumCategories() ([]Tag, error) {\n\tvendor := &Seller{\n\t\tEntityId: 1,\n\t\tStartTime: time.Now().AddDate(0, -1, 0),\n\t}\n\n\titems, err := vendor.CompareData()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to fetch premium categories: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn items, nil\n}"
      },
      {
        "code_key": "ProcessStandardInventory",
        "code_value": "func ProcessStandardInventory(startDate time.Time) error {\n\tmerchant := Seller{\n\t\tEntityId: 2,\n\t\tStartTime: startDate,\n\t}\n\n\tresults, err := merchant.CompareData()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"inventory processing failed: %w\", err)\n\t}\n\tlog.Printf(\"Found %d standard inventory items\", len(results))\n\treturn nil\n}"
      },
      {
        "code_key": "FetchBasicProducts",
        "code_value": "func FetchBasicProducts() ([]Tag, error) {\n\tbasicSeller := Seller{\n\t\tEntityId: 3,\n\t\tStartTime: time.Date(2023, 1, 1, 0, 0, 0, 0, time.UTC),\n\t}\n\n\tproducts, err := basicSeller.CompareData()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"basic product fetch error: %w\", err)\n\t}\n\treturn products, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Tag",
        "code_value": "type Tag struct {\n\tID          int     `gorm:\"column:id\"`\n\tName        string  `gorm:\"column:name\"`\n\tCategoryType string  `gorm:\"column:category_type\"`\n\tPrice       float64 `gorm:\"column:price\"`\n\tStatus      int     `gorm:\"column:status\"`\n\tCreatedAt   int64   `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "Seller",
        "code_value": "type Seller struct {\n\tEntityId   int\n\tStartTime  int64\n}"
      },
      {
        "code_key": "product_categories_table",
        "code_value": "const product_categories_table = \"product_categories\""
      },
      {
        "code_key": "StatusActive",
        "code_value": "const StatusActive = 1"
      },
      {
        "code_key": "CategoryPremium",
        "code_value": "const CategoryPremium = \"premium\""
      },
      {
        "code_key": "CategoryStandard",
        "code_value": "const CategoryStandard = \"standard\""
      },
      {
        "code_key": "CategoryBasic",
        "code_value": "const CategoryBasic = \"basic\""
      }
    ]
  },
  "synthetic_switch_CalculateByFormula": {
    "scenario": "switch",
    "code_key": "CalculateByFormula",
    "code_value": "func (v *Vendor) CalculateByFormula() ([]Permission, error) {\n\tpermissions := make([]Permission, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tswitch v.AuthLevel {\n\tcase 1:\n\t\tfilter[\"public_key\"] = v.PublicKey\n\tcase 2:\n\t\tfilter[\"longitude\"] = v.Longitude\n\t\tfilter[\"latitude\"] = v.Latitude\n\tcase 3:\n\t\tfilter[\"auth_token\"] = v.AuthToken\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported auth level\")\n\t}\n\n\terr := base.GetInstance().AuthDriver().Table(\"customer_reviews\").\n\t\tWhere(filter).Order(\"created_at desc\").Limit(v.PageSize).Find(&permissions).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn permissions, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleVendorPermissions",
        "code_value": "func HandleVendorPermissions() error {\n\tvendorObj := &Vendor{\n\t\tAuthLevel: 2,\n\t\tLongitude: 116.404,\n\t\tLatitude: 39.915,\n\t\tPageSize: 10,\n\t}\n\tperms, err := vendorObj.CalculateByFormula()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to calculate permissions: %v\", err)\n\t\treturn err\n\t}\n\tfmt.Printf(\"Retrieved %d permissions\\n\", len(perms))\n\treturn nil\n}"
      },
      {
        "code_key": "ProcessAuthRequests",
        "code_value": "func ProcessAuthRequests(authToken string) ([]Permission, error) {\n\tvendor := Vendor{\n\t\tAuthLevel: 3,\n\t\tAuthToken: authToken,\n\t\tPageSize: 20,\n\t}\n\tresults, err := vendor.CalculateByFormula()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"auth processing failed: %w\", err)\n\t}\n\treturn results, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Vendor",
        "code_value": "type Vendor struct {\n\tAuthLevel int\n\tPublicKey string\n\tLongitude float64\n\tLatitude  float64\n\tAuthToken string\n\tPageSize  int\n}"
      },
      {
        "code_key": "Permission",
        "code_value": "type Permission struct {\n\tID        int    `gorm:\"column:id\"`\n\tPublicKey string `gorm:\"column:public_key\"`\n\tLongitude float64 `gorm:\"column:longitude\"`\n\tLatitude  float64 `gorm:\"column:latitude\"`\n\tAuthToken string `gorm:\"column:auth_token\"`\n\tStatus    int    `gorm:\"column:status\"`\n\tCreatedAt string `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "CustomerReviewsTable",
        "code_value": "const CustomerReviewsTable = \"customer_reviews\""
      },
      {
        "code_key": "AuthStatus",
        "code_value": "const AuthStatusActive = 1"
      },
      {
        "code_key": "AuthError",
        "code_value": "var AuthError = errors.New(\"authentication error\")"
      }
    ]
  },
  "synthetic_switch_CheckIntegrity": {
    "scenario": "switch",
    "code_key": "CheckIntegrity",
    "code_value": "func (g *Guild) CheckIntegrity() ([]Permission, error) {\n\tperms := make([]Permission, 0)\n\tfilter := map[string]interface{}{\"is_active\": true}\n\n\tswitch g.CurrentStatus {\n\tcase 1:\n\t\tfilter[\"access_level\"] = \"admin\"\n\tcase 2:\n\t\tfilter[\"access_level\"] = \"moderator\"\n\tcase 3:\n\t\tfilter[\"access_level\"] = \"member\"\n\tdefault:\n\t\treturn nil, errors.New(\"invalid status\")\n\t}\n\n\tif g.CaseNumber != \"\" {\n\t\tfilter[\"case_reference\"] = g.CaseNumber\n\t}\n\n\terr := base.GetInstance().AuthDriver().Table(\"group_memberships\").\n\t\tWhere(filter).Find(&perms).Error\n\n\treturn perms, err\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "ValidateGuildPermissions",
        "code_value": "func ValidateGuildPermissions() error {\n\tguildObj := &Guild{\n\t\tCurrentStatus: 2,\n\t\tCaseNumber:   \"CASE-2023-456\",\n\t}\n\n\tperms, err := guildObj.CheckIntegrity()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"permission check failed: %v\", err)\n\t}\n\n\tif len(perms) == 0 {\n\t\treturn errors.New(\"no valid permissions found\")\n\t}\n\n\treturn nil\n}"
      },
      {
        "code_key": "ProcessMemberAccess",
        "code_value": "func ProcessMemberAccess(statusCode int, caseRef string) ([]Permission, error) {\n\tmemberGuild := &Guild{\n\t\tCurrentStatus: statusCode,\n\t\tCaseNumber:   caseRef,\n\t}\n\n\taccessList, err := memberGuild.CheckIntegrity()\n\tif err != nil {\n\t\tlog.Printf(\"Access verification error: %v\", err)\n\t\treturn nil, err\n\t}\n\n\treturn accessList, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Guild",
        "code_value": "type Guild struct {\n\tCurrentStatus int\n\tCaseNumber   string\n}"
      },
      {
        "code_key": "Permission",
        "code_value": "type Permission struct {\n\tID          int    `gorm:\"column:id\"`\n\tAccessLevel string `gorm:\"column:access_level\"`\n\tIsActive    bool   `gorm:\"column:is_active\"`\n\tCaseReference string `gorm:\"column:case_reference\"`\n}"
      },
      {
        "code_key": "GroupMembershipsTable",
        "code_value": "const GroupMembershipsTable = \"group_memberships\""
      },
      {
        "code_key": "AccessLevels",
        "code_value": "const (\n\tAdminLevel = \"admin\"\n\tModeratorLevel = \"moderator\"\n\tMemberLevel = \"member\"\n)"
      },
      {
        "code_key": "GuildStatus",
        "code_value": "const (\n\tGuildActive = 1\n\tGuildPending = 2\n\tGuildInactive = 3\n)"
      }
    ]
  },
  "synthetic_switch_VerifyIdentity": {
    "scenario": "switch",
    "code_key": "VerifyIdentity",
    "code_value": "func (n *Nurse) VerifyIdentity() (bool, error) {\n\tvar count int64\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tswitch n.AccessLevel {\n\tcase 1:\n\t\tfilter[\"department\"] = \"emergency\"\n\tcase 2:\n\t\tfilter[\"department\"] = \"surgery\"\n\tcase 3:\n\t\tfilter[\"department\"] = \"pediatrics\"\n\tdefault:\n\t\treturn false, errors.New(\"invalid access level\")\n\t}\n\n\terr := base.GetInstance().MedicalDriver().Table(\"hospital_departments\").\n\t\tWhere(filter).Where(\"phone_number = ?\", n.PhoneNumber).Count(&count).Error\n\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn count > 0, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleNurseVerification",
        "code_value": "func HandleNurseVerification() {\n\tstaff := &Nurse{\n\t\tAccessLevel: 2,\n\t\tPhoneNumber: \"555-1234\",\n\t}\n\tisValid, err := staff.VerifyIdentity()\n\tif err != nil {\n\t\tlog.Printf(\"Verification failed: %v\", err)\n\t\treturn\n\t}\n\tlog.Printf(\"Nurse verification status: %t\", isValid)\n}"
      },
      {
        "code_key": "ProcessDepartmentAccess",
        "code_value": "func ProcessDepartmentAccess(level int, contact string) error {\n\tmedicalStaff := Nurse{\n\t\tAccessLevel: level,\n\t\tPhoneNumber: contact,\n\t}\n\tapproved, verifyErr := medicalStaff.VerifyIdentity()\n\tif verifyErr != nil {\n\t\treturn fmt.Errorf(\"identity validation error: %w\", verifyErr)\n\t}\n\tif !approved {\n\t\treturn errors.New(\"access denied\")\n\t}\n\tfmt.Println(\"Access granted to restricted department\")\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Nurse",
        "code_value": "type Nurse struct {\n\tPhoneNumber string\n\tAccessLevel int\n}"
      },
      {
        "code_key": "HospitalDepartment",
        "code_value": "type HospitalDepartment struct {\n\tID           uint   `gorm:\"primaryKey\"`\n\tDepartment   string `gorm:\"column:department\"`\n\tPhoneNumber  string `gorm:\"column:phone_number\"`\n\tStatus       int    `gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "AccessLevel",
        "code_value": "const (\n\tEmergencyAccess = 1\n\tSurgeryAccess = 2\n\tPediatricsAccess = 3\n)"
      },
      {
        "code_key": "DepartmentStatus",
        "code_value": "const (\n\tActiveStatus = 1\n\tInactiveStatus = 0\n)"
      },
      {
        "code_key": "HospitalDepartmentTable",
        "code_value": "const HospitalDepartmentTable = \"hospital_departments\""
      },
      {
        "code_key": "BaseError",
        "code_value": "var BaseError = errors.New(\"base error\")"
      }
    ]
  },
  "synthetic_switch_CacheData": {
    "scenario": "switch",
    "code_key": "CacheData",
    "code_value": "func (v *Vaccine) CacheData() ([]Label, error) {\n\tlabels := make([]Label, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tif v.PriorityRank > 0 {\n\t\tswitch v.PriorityRank {\n\t\tcase 1:\n\t\t\tfilter[\"high_priority\"] = 1\n\t\tcase 2:\n\t\t\tfilter[\"medium_priority\"] = 1\n\t\tcase 3:\n\t\t\tfilter[\"low_priority\"] = 1\n\t\tdefault:\n\t\t\treturn nil, errors.New(\"invalid priority rank\")\n\t\t}\n\t}\n\n\tquery := base.GetInstance().MedicalDriver().Table(\"lab_test_results\").Where(filter)\n\tif v.Summary != \"\" {\n\t\tquery = query.Where(\"summary LIKE ?\", \"%\"+v.Summary+\"%\")\n\t}\n\terr := query.Find(&labels).Error\n\treturn labels, err\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandlePatientVaccines",
        "code_value": "func HandlePatientVaccines() ([]Label, error) {\n\tpatientVax := &Vaccine{\n\t\tPriorityRank: 2,\n\t\tSummary: \"annual flu\"\n\t}\n\n\ttags, err := patientVax.CacheData()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to fetch vaccine labels: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn tags, nil\n}"
      },
      {
        "code_key": "HandlePriorityVaccines",
        "code_value": "func HandlePriorityVaccines(priority int) ([]Label, error) {\n\tcritVax := &Vaccine{\n\t\tPriorityRank: priority,\n\t\tSummary: \"\"\n\t}\n\n\tresults, err := critVax.CacheData()\n\tif err != nil {\n\t\tlog.Printf(\"Priority vaccine query failed: %v\", err)\n\t\treturn nil, fmt.Errorf(\"priority search error: %w\", err)\n\t}\n\treturn results, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Vaccine",
        "code_value": "type Vaccine struct {\n\tPriorityRank int\n\tSummary      string\n}"
      },
      {
        "code_key": "Label",
        "code_value": "type Label struct {\n\tID            int    `gorm:\"column:id\"`\n\tHighPriority  int    `gorm:\"column:high_priority\"`\n\tMediumPriority int    `gorm:\"column:medium_priority\"`\n\tLowPriority   int    `gorm:\"column:low_priority\"`\n\tSummary       string `gorm:\"column:summary\"`\n\tStatus        int    `gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "LabTestResultsTable",
        "code_value": "const LabTestResultsTable = \"lab_test_results\""
      },
      {
        "code_key": "PriorityStatus",
        "code_value": "const (\n\tHighPriority = 1\n\tMediumPriority = 2\n\tLowPriority = 3\n)"
      },
      {
        "code_key": "BaseStatus",
        "code_value": "const (\n\tActiveStatus = 1\n\tInactiveStatus = 0\n)"
      }
    ]
  },
  "synthetic_switch_UpdateTournamentStatus": {
    "scenario": "switch",
    "code_key": "UpdateTournamentStatus",
    "code_value": "func (t *Tournament) UpdateTournamentStatus() error {\n\tupdateData := make(map[string]interface{})\n\tswitch t.ClassificationLevel {\n\tcase \"qualifier\":\n\t\tupdateData[\"stage\"] = \"qualifying\"\n\tcase \"main_event\":\n\t\tupdateData[\"stage\"] = \"brackets\"\n\tcase \"final\":\n\t\tupdateData[\"stage\"] = \"championship\"\n\tdefault:\n\t\treturn errors.New(\"invalid classification level\")\n\t}\n\terr := base.GetInstance().TournamentDriver().Table(\"tournament_brackets\").\n\t\tWhere(\"id = ? AND status = ?\", t.ID, \"active\").\n\t\tUpdates(updateData).Error\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to update tournament status: %v\", err)\n\t}\n\treturn nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleTournamentProgress",
        "code_value": "func HandleTournamentProgress(eventID uint) error {\n\tcompEvent := &Tournament{\n\t\tID:                  eventID,\n\t\tClassificationLevel: \"main_event\",\n\t}\n\terr := compEvent.UpdateTournamentStatus()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not advance tournament: %v\", err)\n\t}\n\treturn nil\n}"
      },
      {
        "code_key": "ProcessQualifierRound",
        "code_value": "func ProcessQualifierRound(championshipID uint) error {\n\tqualifier := Tournament{\n\t\tID:                  championshipID,\n\t\tClassificationLevel: \"qualifier\",\n\t}\n\tif updateErr := qualifier.UpdateTournamentStatus(); updateErr != nil {\n\t\treturn fmt.Errorf(\"qualifier stage update failed: %v\", updateErr)\n\t}\n\treturn nil\n}"
      },
      {
        "code_key": "FinalizeChampionshipEvent",
        "code_value": "func FinalizeChampionshipEvent(finalMatchID uint) error {\n\tfinalEvent := &Tournament{\n\t\tID:                  finalMatchID,\n\t\tClassificationLevel: \"final\",\n\t}\n\tif err := finalEvent.UpdateTournamentStatus(); err != nil {\n\t\treturn fmt.Errorf(\"championship finalization error: %v\", err)\n\t}\n\treturn nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Tournament",
        "code_value": "type Tournament struct {\n\tID                  int\n\tClassificationLevel string\n\tStatus              string\n}"
      },
      {
        "code_key": "TournamentStage",
        "code_value": "const (\n\tStageQualifying  = \"qualifying\"\n\tStageBrackets    = \"brackets\"\n\tStageChampionship = \"championship\"\n)"
      },
      {
        "code_key": "TournamentStatus",
        "code_value": "const (\n\tStatusActive   = \"active\"\n\tStatusInactive = \"inactive\"\n\tStatusPending  = \"pending\"\n)"
      },
      {
        "code_key": "TournamentTable",
        "code_value": "const TournamentBracketTable = \"tournament_brackets\""
      },
      {
        "code_key": "ClassificationLevel",
        "code_value": "const (\n\tLevelQualifier = \"qualifier\"\n\tLevelMainEvent = \"main_event\"\n\tLevelFinal     = \"final\"\n)"
      }
    ]
  },
  "synthetic_switch_UpdateInventory": {
    "scenario": "switch",
    "code_key": "UpdateInventory",
    "code_value": "func (c *Contract) UpdateInventory() error {\n\tvar query *gorm.DB\n\tswitch c.CurrentStatus {\n\tcase \"pending\":\n\t\tquery = base.GetInstance().WarehouseDriver().Table(\"attendance_logs\").\n\t\t\tWhere(\"contract_id = ? AND locale = ?\", c.ID, c.Locale).\n\t\t\tUpdate(\"quantity\", c.Quantity)\n\tcase \"approved\":\n\t\tquery = base.GetInstance().WarehouseDriver().Table(\"attendance_logs\").\n\t\t\tWhere(\"contract_id = ? AND phone_number = ?\", c.ID, c.PhoneNumber).\n\t\t\tUpdate(\"quantity\", c.Quantity * 2)\n\tcase \"rejected\":\n\t\tquery = base.GetInstance().WarehouseDriver().Table(\"attendance_logs\").\n\t\t\tWhere(\"contract_id = ?\", c.ID).\n\t\t\tUpdate(\"quantity\", 0)\n\tdefault:\n\t\treturn errors.New(\"invalid status\")\n\t}\n\treturn query.Error\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleWarehouseUpdate",
        "code_value": "func HandleWarehouseUpdate() error {\n\twarehouseContract := &Contract{\n\t\tID:           \"WH-12345\",\n\t\tCurrentStatus: \"approved\",\n\t\tLocale:       \"US\",\n\t\tPhoneNumber:  \"+15551234567\",\n\t\tQuantity:     100,\n\t}\n\tif err := warehouseContract.UpdateInventory(); err != nil {\n\t\tlog.Printf(\"Failed to update warehouse inventory: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}"
      },
      {
        "code_key": "ProcessInventoryAdjustment",
        "code_value": "func ProcessInventoryAdjustment(contractID string, status string) error {\n\tinventoryRecord := &Contract{\n\t\tID:           contractID,\n\t\tCurrentStatus: status,\n\t\tLocale:       \"JP\",\n\t\tPhoneNumber:  \"+819012345678\",\n\t\tQuantity:     50,\n\t}\n\terr := inventoryRecord.UpdateInventory()\n\tif err != nil && status == \"rejected\" {\n\t\tlog.Println(\"Inventory cleared for rejected contract\")\n\t\treturn nil\n\t}\n\treturn err\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Contract",
        "code_value": "type Contract struct {\n\tID           string\n\tCurrentStatus string\n\tLocale       string\n\tPhoneNumber  string\n\tQuantity     int\n}"
      },
      {
        "code_key": "AttendanceLog",
        "code_value": "type AttendanceLog struct {\n\tContractId   string `gorm:\"column:contract_id\"`\n\tLocale      string `gorm:\"column:locale\"`\n\tPhoneNumber string `gorm:\"column:phone_number\"`\n\tQuantity    int    `gorm:\"column:quantity\"`\n}"
      },
      {
        "code_key": "StatusConstants",
        "code_value": "const (\n\tPendingStatus  = \"pending\"\n\tApprovedStatus = \"approved\"\n\tRejectedStatus = \"rejected\"\n)"
      },
      {
        "code_key": "TableNames",
        "code_value": "const (\n\tAttendanceLogsTable = \"attendance_logs\"\n)"
      },
      {
        "code_key": "ErrorMessages",
        "code_value": "const InvalidStatusError = \"invalid status\""
      }
    ]
  },
  "synthetic_switch_FetchWithFilter": {
    "scenario": "switch",
    "code_key": "FetchWithFilter",
    "code_value": "func (g *GPS) FetchWithFilter() ([]Item, error) {\n\titems := make([]Item, 0)\n\tfilter := make(map[string]interface{})\n\tif g.ZoneId > 0 {\n\t\tfilter[\"zone_id\"] = g.ZoneId\n\t}\n\tif g.ProjectCode != \"\" {\n\t\tfilter[\"project_code\"] = g.ProjectCode\n\t}\n\tswitch g.Status {\n\tcase Active:\n\t\tfilter[\"active\"] = 1\n\tcase Inactive:\n\t\tfilter[\"active\"] = 0\n\tcase Archived:\n\t\tfilter[\"archived\"] = 1\n\tdefault:\n\t\treturn nil, errors.New(\"invalid status\")\n\t}\n\terr := base.GetInstance().TrackingDriver().Table(\"department_structure\").\n\t\tWhere(filter).Order(\"created_at desc\").Find(&items).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn items, nil\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleActiveProjects",
        "code_value": "func HandleActiveProjects(zoneID int, projectCode string) ([]Item, error) {\n\tgps := &GPS{\n\t\tZoneId:      zoneID,\n\t\tProjectCode: projectCode,\n\t\tStatus:      Active,\n\t}\n\tresults, err := gps.FetchWithFilter()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to fetch active projects: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}"
      },
      {
        "code_key": "HandleArchivedStructures",
        "code_value": "func HandleArchivedStructures() ([]Item, error) {\n\tgps := &GPS{\n\t\tStatus: Archived,\n\t}\n\tstructures, err := gps.FetchWithFilter()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to retrieve archived structures: %v\", err)\n\t\treturn nil, fmt.Errorf(\"archive query failed\")\n\t}\n\treturn structures, nil\n}"
      },
      {
        "code_key": "HandleZoneInactiveItems",
        "code_value": "func HandleZoneInactiveItems(zoneID int) ([]Item, error) {\n\tgps := &GPS{\n\t\tZoneId: zoneID,\n\t\tStatus: Inactive,\n\t}\n\titems, err := gps.FetchWithFilter()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"inactive items query failed for zone %d: %w\", zoneID, err)\n\t}\n\treturn items, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "GPS",
        "code_value": "type GPS struct {\n\tZoneId      int\n\tProjectCode string\n\tStatus      Status\n}"
      },
      {
        "code_key": "Item",
        "code_value": "type Item struct {\n\tID        int       `gorm:\"column:id\"`\n\tZoneId    int       `gorm:\"column:zone_id\"`\n\tProjectCode string   `gorm:\"column:project_code\"`\n\tActive    int       `gorm:\"column:active\"`\n\tArchived  int       `gorm:\"column:archived\"`\n\tCreatedAt time.Time `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "Status",
        "code_value": "type Status int\nconst (\n\tActive Status = iota + 1\n\tInactive\n\tArchived\n)"
      },
      {
        "code_key": "TableName",
        "code_value": "const TableName = \"department_structure\""
      },
      {
        "code_key": "TrackingDriver",
        "code_value": "var TrackingDriver = func() *gorm.DB {\n\treturn base.GetInstance().TrackingDriver()\n}"
      }
    ]
  },
  "synthetic_switch_ScanByPattern": {
    "scenario": "switch",
    "code_key": "ScanByPattern",
    "code_value": "func (m *Media) ScanByPattern() ([]MediaInfo, error) {\n\tmediaList := make([]MediaInfo, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tswitch m.Pattern {\n\tcase \"video\":\n\t\tfilter[\"sector\"] = \"video\"\n\tcase \"audio\":\n\t\tfilter[\"sector\"] = \"audio\"\n\tcase \"image\":\n\t\tfilter[\"sector\"] = \"image\"\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported media pattern\")\n\t}\n\n\tif m.RefreshKey != \"\" {\n\t\tfilter[\"refresh_key\"] = m.RefreshKey\n\t}\n\n\terr := base.GetInstance().MediaDriver().Table(\"media_resources\").\n\t\tWhere(filter).Order(\"created_at DESC\").Find(&mediaList).Error\n\n\treturn mediaList, err\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleVideoResources",
        "code_value": "func HandleVideoResources(refreshToken string) ([]MediaInfo, error) {\n\tvideoMedia := &Media{\n\t\tPattern:     \"video\",\n\t\tRefreshKey: refreshToken,\n\t}\n\n\tresources, err := videoMedia.ScanByPattern()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to fetch video resources: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn resources, nil\n}"
      },
      {
        "code_key": "HandleAudioCollection",
        "code_value": "func HandleAudioCollection() ([]MediaInfo, error) {\n\taudioData := &Media{Pattern: \"audio\"}\n\n\tcollection, err := audioData.ScanByPattern()\n\tif err != nil {\n\t\tlog.Printf(\"Error retrieving audio collection: %v\", err)\n\t\treturn nil, fmt.Errorf(\"audio query failed: %w\", err)\n\t}\n\treturn collection, nil\n}"
      },
      {
        "code_key": "ProcessGalleryImages",
        "code_value": "func ProcessGalleryImages() {\n\tgallery := &Media{Pattern: \"image\"}\n\n\timages, err := gallery.ScanByPattern()\n\tif err != nil {\n\t\tlog.Printf(\"Gallery processing error: %v\", err)\n\t\treturn\n\t}\n\t// Process images...\n\tfmt.Printf(\"Processed %d gallery images\\n\", len(images))\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Media",
        "code_value": "type Media struct {\n\tPattern     string\n\tRefreshKey string\n}"
      },
      {
        "code_key": "MediaInfo",
        "code_value": "type MediaInfo struct {\n\tID         int    `gorm:\"column:id\"`\n\tSector     string `gorm:\"column:sector\"`\n\tStatus     int    `gorm:\"column:status\"`\n\tRefreshKey string `gorm:\"column:refresh_key\"`\n\tCreatedAt  string `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "MediaResourceTable",
        "code_value": "const MediaResourceTable = \"media_resources\""
      },
      {
        "code_key": "DefaultMediaStatus",
        "code_value": "const DefaultMediaStatus = 1"
      },
      {
        "code_key": "VideoPattern",
        "code_value": "const VideoPattern = \"video\""
      },
      {
        "code_key": "AudioPattern",
        "code_value": "const AudioPattern = \"audio\""
      },
      {
        "code_key": "ImagePattern",
        "code_value": "const ImagePattern = \"image\""
      }
    ]
  },
  "synthetic_switch_EvaluateResults": {
    "scenario": "switch",
    "code_key": "EvaluateResults",
    "code_value": "func (t *Test) EvaluateResults() ([]types.ChapterScore, error) {\n\tscores := make([]types.ChapterScore, 0)\n\tquery := base.GetInstance().ResultDriver().Table(\"price_history\")\n\n\tswitch t.Content {\n\tcase \"basic\":\n\t\tquery = query.Where(\"score >= ? AND secret_hash IS NOT NULL\", 60)\n\tcase \"advanced\":\n\t\tquery = query.Where(\"score >= ? AND created_at > ?\", 80, t.StartTime)\n\tcase \"premium\":\n\t\tquery = query.Where(\"score >= ? AND created_at BETWEEN ? AND ?\", 90, t.StartTime, t.EndTime)\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported test type\")\n\t}\n\n\terr := query.Order(\"score DESC\").Limit(t.PageSize).Find(&scores).Error\n\treturn scores, err\n}",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_key": "HandleTestScores",
        "code_value": "func HandleTestScores() ([]types.ChapterScore, error) {\n\tassessment := &Test{\n\t\tContent:  \"premium\",\n\t\tStartTime: time.Now().AddDate(0, -1, 0),\n\t\tEndTime:   time.Now(),\n\t\tPageSize:  50,\n\t}\n\tresults, err := assessment.EvaluateResults()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to evaluate: %v\", err)\n\t}\n\treturn results, nil\n}"
      },
      {
        "code_key": "ProcessBasicEvaluations",
        "code_value": "func ProcessBasicEvaluations() error {\n\texamData := &Test{\n\t\tContent: \"basic\",\n\t\tPageSize: 100,\n\t}\n\tgrades, err := examData.EvaluateResults()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"evaluation error: %v\", err)\n\t}\n\tlog.Printf(\"Retrieved %d passing scores\", len(grades))\n\treturn nil\n}"
      },
      {
        "code_key": "AnalyzeAdvancedResults",
        "code_value": "func AnalyzeAdvancedResults(startDate time.Time) ([]types.ChapterScore, error) {\n\texam := &Test{\n\t\tContent:  \"advanced\",\n\t\tStartTime: startDate,\n\t\tPageSize:  20,\n\t}\n\toutcomes, err := exam.EvaluateResults()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"analysis failed: %v\", err)\n\t}\n\treturn outcomes, nil\n}"
      }
    ],
    "code_meta_data": [
      {
        "code_key": "Test",
        "code_value": "type Test struct {\n\tContent   string\n\tStartTime time.Time\n\tEndTime   time.Time\n\tPageSize  int\n}"
      },
      {
        "code_key": "ChapterScore",
        "code_value": "type ChapterScore struct {\n\tID         int       `gorm:\"column:id\"`\n\tScore      int       `gorm:\"column:score\"`\n\tSecretHash string    `gorm:\"column:secret_hash\"`\n\tCreatedAt  time.Time `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "TestType",
        "code_value": "const (\n\tBasicTest    = \"basic\"\n\tAdvancedTest = \"advanced\"\n\tPremiumTest  = \"premium\"\n)"
      },
      {
        "code_key": "PriceHistoryTable",
        "code_value": "const PriceHistoryTable = \"price_history\""
      },
      {
        "code_key": "ScoreThresholds",
        "code_value": "var ScoreThresholds = map[string]int{\n\tBasicTest:    60,\n\tAdvancedTest: 80,\n\tPremiumTest:  90\n}"
      }
    ]
  }
}