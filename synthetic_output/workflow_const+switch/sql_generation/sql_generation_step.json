[
  {
    "function_name": "ApproveRequest",
    "orm_code": "func (repo *RouteRepo) ApproveRequest(ctx context.Context, claim *model.Claim) error {\n\tcheckClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\texisting := &model.Claim{}\n\n\tif err := repo.db.Clauses(checkClause).Table(model.ClaimTableName).\n\t\tWhere(\"work_address = ? AND zip_code = ?\", claim.WorkAddress, claim.ZipCode).\n\t\tFirst(existing).Error; err != nil {\n\t\t\treturn err\n\t}\n\n\tif existing.State != claim.State {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.ClaimTableName).\n\t\t\tWhere(\"id = ?\", existing.Id).\n\t\t\tUpdate(\"state\", claim.State).Error; err != nil {\n\t\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "c.Genre = 'science'",
            "sql": "SELECT id, name, department, status, enrollment_date, created_at FROM author_profiles WHERE status = 1 AND department = 'science' AND created_at >= ? ORDER BY enrollment_date DESC;"
          },
          {
            "scenario": "c.Genre = 'arts'",
            "sql": "SELECT id, name, department, status, enrollment_date, created_at FROM author_profiles WHERE status = 1 AND department = 'arts' AND created_at >= ? ORDER BY enrollment_date DESC;"
          },
          {
            "scenario": "c.Genre = 'business'",
            "sql": "SELECT id, name, department, status, enrollment_date, created_at FROM author_profiles WHERE status = 1 AND department = 'business' AND created_at >= ? ORDER BY enrollment_date DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "RouteRepo",
        "code_value": "type RouteRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Claim",
        "code_value": "type Claim struct {\n\tId          int64  `gorm:\"column:id\"`\n\tWorkAddress string `gorm:\"column:work_address\"`\n\tZipCode     string `gorm:\"column:zip_code\"`\n\tState       int    `gorm:\"column:state\"`\n}"
      },
      {
        "code_key": "ClaimTableName",
        "code_value": "const ClaimTableName = \"maintenance_logs\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-event-alarm/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) hints.Hints {\n\tcommentInfo := icontext.GetSQLCommentFromContext(ctx)\n\tif len(commentInfo.ReqId) < 16 {\n\t\tcommentInfo.ReqId = uuid.NewString()\n\t}\n\n\tcomment := fmt.Sprintf(\"p=%v,a=%v,o=%v,s=%v,f=%v,i=%v\", ProductName,\n\t\tcommentInfo.AppId, commentInfo.OwnerUin, commentInfo.SubUin, commentInfo.Action, commentInfo.ReqId)\n\treturn hints.CommentBefore(clause, comment)\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"select\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"update\""
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "ApproveRequest",
    "orm_code": "func (repo *RouteRepo) ApproveRequest(ctx context.Context, claim *model.Claim) error {\n\tcheckClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\texisting := &model.Claim{}\n\n\tif err := repo.db.Clauses(checkClause).Table(model.ClaimTableName).\n\t\tWhere(\"work_address = ? AND zip_code = ?\", claim.WorkAddress, claim.ZipCode).\n\t\tFirst(existing).Error; err != nil {\n\t\t\treturn err\n\t}\n\n\tif existing.State != claim.State {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.ClaimTableName).\n\t\t\tWhere(\"id = ?\", existing.Id).\n\t\t\tUpdate(\"state\", claim.State).Error; err != nil {\n\t\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func HandleMaintenanceApproval(db *gorm.DB, address string, zip string) error {\n\tctx := context.Background()\n\trepo := &RouteRepo{db: db}\n\tclaim := &model.Claim{\n\t\tWorkAddress: address,\n\t\tZipCode:     zip,\n\t\tState:       2, // approved state\n\t}\n\n\tif err := repo.ApproveRequest(ctx, claim); err != nil {\n\t\treturn fmt.Errorf(\"approval failed: %v\", err)\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "SELECT statement to check existing claim",
            "sql": "SELECT * FROM maintenance_logs WHERE work_address = ? AND zip_code = ? LIMIT 1;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "UPDATE statement when existing.State != claim.State",
            "sql": "UPDATE maintenance_logs SET state = ? WHERE id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "RouteRepo",
        "code_value": "type RouteRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Claim",
        "code_value": "type Claim struct {\n\tId          int64  `gorm:\"column:id\"`\n\tWorkAddress string `gorm:\"column:work_address\"`\n\tZipCode     string `gorm:\"column:zip_code\"`\n\tState       int    `gorm:\"column:state\"`\n}"
      },
      {
        "code_key": "ClaimTableName",
        "code_value": "const ClaimTableName = \"maintenance_logs\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-event-alarm/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) hints.Hints {\n\tcommentInfo := icontext.GetSQLCommentFromContext(ctx)\n\tif len(commentInfo.ReqId) < 16 {\n\t\tcommentInfo.ReqId = uuid.NewString()\n\t}\n\n\tcomment := fmt.Sprintf(\"p=%v,a=%v,o=%v,s=%v,f=%v,i=%v\", ProductName,\n\t\tcommentInfo.AppId, commentInfo.OwnerUin, commentInfo.SubUin, commentInfo.Action, commentInfo.ReqId)\n\treturn hints.CommentBefore(clause, comment)\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"select\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"update\""
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "ApproveRequest",
    "orm_code": "func (repo *RouteRepo) ApproveRequest(ctx context.Context, claim *model.Claim) error {\n\tcheckClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\texisting := &model.Claim{}\n\n\tif err := repo.db.Clauses(checkClause).Table(model.ClaimTableName).\n\t\tWhere(\"work_address = ? AND zip_code = ?\", claim.WorkAddress, claim.ZipCode).\n\t\tFirst(existing).Error; err != nil {\n\t\t\treturn err\n\t}\n\n\tif existing.State != claim.State {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.ClaimTableName).\n\t\t\tWhere(\"id = ?\", existing.Id).\n\t\t\tUpdate(\"state\", claim.State).Error; err != nil {\n\t\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func ProcessFacilityClaims(db *gorm.DB) error {\n\tctx := context.Background()\n\trepo := &RouteRepo{db: db}\n\n\t// Sample claim data for processing\n\tfacilityClaim := &model.Claim{\n\t\tWorkAddress: \"123 Industrial Park\",\n\t\tZipCode:     \"90210\",\n\t\tState:       3, // processed state\n\t}\n\n\tif err := repo.ApproveRequest(ctx, facilityClaim); err != nil {\n\t\treturn fmt.Errorf(\"could not process facility claim: %v\", err)\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "SELECT with work_address and zip_code",
            "sql": "SELECT id, work_address, zip_code, state FROM maintenance_logs WHERE work_address = '123 Industrial Park' AND zip_code = '90210' LIMIT 1;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "UPDATE state when existing state differs",
            "sql": "UPDATE maintenance_logs SET state = 3 WHERE id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "RouteRepo",
        "code_value": "type RouteRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Claim",
        "code_value": "type Claim struct {\n\tId          int64  `gorm:\"column:id\"`\n\tWorkAddress string `gorm:\"column:work_address\"`\n\tZipCode     string `gorm:\"column:zip_code\"`\n\tState       int    `gorm:\"column:state\"`\n}"
      },
      {
        "code_key": "ClaimTableName",
        "code_value": "const ClaimTableName = \"maintenance_logs\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-event-alarm/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) hints.Hints {\n\tcommentInfo := icontext.GetSQLCommentFromContext(ctx)\n\tif len(commentInfo.ReqId) < 16 {\n\t\tcommentInfo.ReqId = uuid.NewString()\n\t}\n\n\tcomment := fmt.Sprintf(\"p=%v,a=%v,o=%v,s=%v,f=%v,i=%v\", ProductName,\n\t\tcommentInfo.AppId, commentInfo.OwnerUin, commentInfo.SubUin, commentInfo.Action, commentInfo.ReqId)\n\treturn hints.CommentBefore(clause, comment)\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"select\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"update\""
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "ApproveRequest",
    "orm_code": "func (repo *RouteRepo) ApproveRequest(ctx context.Context, claim *model.Claim) error {\n\tcheckClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\texisting := &model.Claim{}\n\n\tif err := repo.db.Clauses(checkClause).Table(model.ClaimTableName).\n\t\tWhere(\"work_address = ? AND zip_code = ?\", claim.WorkAddress, claim.ZipCode).\n\t\tFirst(existing).Error; err != nil {\n\t\t\treturn err\n\t}\n\n\tif existing.State != claim.State {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.ClaimTableName).\n\t\t\tWhere(\"id = ?\", existing.Id).\n\t\t\tUpdate(\"state\", claim.State).Error; err != nil {\n\t\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func HandleScienceApprovals() ([]Student, error) {\n\tcourse := Curriculum{\n\t\tGenre:    \"science\",\n\t\tStartDate: time.Now().AddDate(0, -1, 0),\n\t}\n\n\tapprovedStudents, err := course.ApproveRequest()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to approve science students: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn approvedStudents, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Genre = 'science'",
            "sql": "SELECT id, name, department, status, enrollment_date, created_at FROM author_profiles WHERE status = 1 AND department = 'science' AND created_at >= ? ORDER BY enrollment_date DESC;"
          },
          {
            "scenario": "Genre = 'arts'",
            "sql": "SELECT id, name, department, status, enrollment_date, created_at FROM author_profiles WHERE status = 1 AND department = 'arts' AND created_at >= ? ORDER BY enrollment_date DESC;"
          },
          {
            "scenario": "Genre = 'business'",
            "sql": "SELECT id, name, department, status, enrollment_date, created_at FROM author_profiles WHERE status = 1 AND department = 'business' AND created_at >= ? ORDER BY enrollment_date DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "RouteRepo",
        "code_value": "type RouteRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Claim",
        "code_value": "type Claim struct {\n\tId          int64  `gorm:\"column:id\"`\n\tWorkAddress string `gorm:\"column:work_address\"`\n\tZipCode     string `gorm:\"column:zip_code\"`\n\tState       int    `gorm:\"column:state\"`\n}"
      },
      {
        "code_key": "ClaimTableName",
        "code_value": "const ClaimTableName = \"maintenance_logs\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-event-alarm/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) hints.Hints {\n\tcommentInfo := icontext.GetSQLCommentFromContext(ctx)\n\tif len(commentInfo.ReqId) < 16 {\n\t\tcommentInfo.ReqId = uuid.NewString()\n\t}\n\n\tcomment := fmt.Sprintf(\"p=%v,a=%v,o=%v,s=%v,f=%v,i=%v\", ProductName,\n\t\tcommentInfo.AppId, commentInfo.OwnerUin, commentInfo.SubUin, commentInfo.Action, commentInfo.ReqId)\n\treturn hints.CommentBefore(clause, comment)\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"select\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"update\""
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "ApproveRequest",
    "orm_code": "func (repo *RouteRepo) ApproveRequest(ctx context.Context, claim *model.Claim) error {\n\tcheckClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\texisting := &model.Claim{}\n\n\tif err := repo.db.Clauses(checkClause).Table(model.ClaimTableName).\n\t\tWhere(\"work_address = ? AND zip_code = ?\", claim.WorkAddress, claim.ZipCode).\n\t\tFirst(existing).Error; err != nil {\n\t\t\treturn err\n\t}\n\n\tif existing.State != claim.State {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.ClaimTableName).\n\t\t\tWhere(\"id = ?\", existing.Id).\n\t\t\tUpdate(\"state\", claim.State).Error; err != nil {\n\t\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func ProcessBusinessApplications() error {\n\tbizCurriculum := Curriculum{\n\t\tGenre:    \"business\",\n\t\tStartDate: time.Date(2023, 1, 1, 0, 0, 0, 0, time.UTC),\n\t}\n\n\tapplicants, err := bizCurriculum.ApproveRequest()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"business approval processing failed: %w\", err)\n\t}\n\tfmt.Printf(\"Approved %d business students\\n\", len(applicants))\n\treturn nil\n}",
    "sql_statement_list": [
      "SELECT id, name, department, status, enrollment_date, created_at FROM author_profiles WHERE status = 1 AND department = 'business' AND created_at >= '2023-01-01 00:00:00' ORDER BY enrollment_date DESC;"
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "RouteRepo",
        "code_value": "type RouteRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Claim",
        "code_value": "type Claim struct {\n\tId          int64  `gorm:\"column:id\"`\n\tWorkAddress string `gorm:\"column:work_address\"`\n\tZipCode     string `gorm:\"column:zip_code\"`\n\tState       int    `gorm:\"column:state\"`\n}"
      },
      {
        "code_key": "ClaimTableName",
        "code_value": "const ClaimTableName = \"maintenance_logs\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-event-alarm/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) hints.Hints {\n\tcommentInfo := icontext.GetSQLCommentFromContext(ctx)\n\tif len(commentInfo.ReqId) < 16 {\n\t\tcommentInfo.ReqId = uuid.NewString()\n\t}\n\n\tcomment := fmt.Sprintf(\"p=%v,a=%v,o=%v,s=%v,f=%v,i=%v\", ProductName,\n\t\tcommentInfo.AppId, commentInfo.OwnerUin, commentInfo.SubUin, commentInfo.Action, commentInfo.ReqId)\n\treturn hints.CommentBefore(clause, comment)\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"select\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"update\""
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "ApproveRequest",
    "orm_code": "func (repo *RouteRepo) ApproveRequest(ctx context.Context, claim *model.Claim) error {\n\tcheckClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\texisting := &model.Claim{}\n\n\tif err := repo.db.Clauses(checkClause).Table(model.ClaimTableName).\n\t\tWhere(\"work_address = ? AND zip_code = ?\", claim.WorkAddress, claim.ZipCode).\n\t\tFirst(existing).Error; err != nil {\n\t\t\treturn err\n\t}\n\n\tif existing.State != claim.State {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.ClaimTableName).\n\t\t\tWhere(\"id = ?\", existing.Id).\n\t\t\tUpdate(\"state\", claim.State).Error; err != nil {\n\t\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func ValidateArtsCandidates() {\n\tartsReq := Curriculum{\n\t\tGenre:    \"arts\",\n\t\tStartDate: time.Now().Add(-720 * time.Hour),\n\t}\n\n\tcandidates, err := artsReq.ApproveRequest()\n\tif err != nil {\n\t\tlog.Println(\"Arts validation error:\", err)\n\t\treturn\n\t}\n\tfor _, c := range candidates {\n\t\tfmt.Println(\"Validated arts student:\", c.Name)\n\t}\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "当Genre为arts时生成的SQL",
            "sql": "SELECT id, name, department, status, enrollment_date, created_at FROM author_profiles WHERE status = 1 AND department = 'arts' AND created_at >= '2023-12-12 15:30:00' ORDER BY enrollment_date DESC;"
          },
          {
            "scenario": "当Genre为science时生成的SQL",
            "sql": "SELECT id, name, department, status, enrollment_date, created_at FROM author_profiles WHERE status = 1 AND department = 'science' AND created_at >= ? ORDER BY enrollment_date DESC;"
          },
          {
            "scenario": "当Genre为business时生成的SQL",
            "sql": "SELECT id, name, department, status, enrollment_date, created_at FROM author_profiles WHERE status = 1 AND department = 'business' AND created_at >= ? ORDER BY enrollment_date DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "RouteRepo",
        "code_value": "type RouteRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Claim",
        "code_value": "type Claim struct {\n\tId          int64  `gorm:\"column:id\"`\n\tWorkAddress string `gorm:\"column:work_address\"`\n\tZipCode     string `gorm:\"column:zip_code\"`\n\tState       int    `gorm:\"column:state\"`\n}"
      },
      {
        "code_key": "ClaimTableName",
        "code_value": "const ClaimTableName = \"maintenance_logs\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-event-alarm/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) hints.Hints {\n\tcommentInfo := icontext.GetSQLCommentFromContext(ctx)\n\tif len(commentInfo.ReqId) < 16 {\n\t\tcommentInfo.ReqId = uuid.NewString()\n\t}\n\n\tcomment := fmt.Sprintf(\"p=%v,a=%v,o=%v,s=%v,f=%v,i=%v\", ProductName,\n\t\tcommentInfo.AppId, commentInfo.OwnerUin, commentInfo.SubUin, commentInfo.Action, commentInfo.ReqId)\n\treturn hints.CommentBefore(clause, comment)\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"select\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"update\""
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "ValidatePermissions",
    "orm_code": "func (repo *PhotoRepo) ValidatePermissions(ctx context.Context, photo *model.Photo) (bool, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\ttarget := &model.Photo{}\n\n\terr := repo.db.Clauses(queryClause).Table(model.PhotoTableName).\n\t\tWhere(\"territory = ? AND gross_value > ?\", photo.Territory, photo.GrossValue).\n\t\tFirst(target).Error\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif target.Limit < photo.Limit {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "admin role with product code",
            "sql": "SELECT COUNT(1) > 0 AS has_access FROM media_uploads WHERE priority_rank <= 3 AND product_code = ?;"
          },
          {
            "scenario": "editor role with product code",
            "sql": "SELECT COUNT(1) > 0 AS has_access FROM media_uploads WHERE priority_rank <= 2 AND product_code = ?;"
          },
          {
            "scenario": "viewer role with product code",
            "sql": "SELECT COUNT(1) > 0 AS has_access FROM media_uploads WHERE priority_rank <= 1 AND product_code = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PortfolioRepo",
        "code_value": "type PortfolioRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "PortfolioTableName",
        "code_value": "const PortfolioTableName = \"user_portfolios\""
      },
      {
        "code_key": "Portfolio",
        "code_value": "type Portfolio struct {\n\tID          int64   `gorm:\"column:id\" json:\"id\"`\n\tUserID      int64   `gorm:\"column:user_id\" json:\"user_id\"`\n\tAssetType   string  `gorm:\"column:asset_type\" json:\"asset_type\"`\n\tAmount      float64 `gorm:\"column:amount\" json:\"amount\"`\n\tRiskLevel   int     `gorm:\"column:risk_level\" json:\"risk_level\"`\n\tCreatedTime int64   `gorm:\"column:created_time\" json:\"created_time\"`\n}"
      },
      {
        "code_key": "AppointmentRepo",
        "code_value": "type AppointmentRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "AppointmentTableName",
        "code_value": "const AppointmentTableName = \"client_appointments\""
      },
      {
        "code_key": "Appointment",
        "code_value": "type Appointment struct {\n\tID         int64  `gorm:\"column:id\" json:\"id\"`\n\tClientID   int64  `gorm:\"column:client_id\" json:\"client_id\"`\n\tAdvisorID  int64  `gorm:\"column:advisor_id\" json:\"advisor_id\"`\n\tStartTime  int64  `gorm:\"column:start_time\" json:\"start_time\"`\n\tEndTime    int64  `gorm:\"column:end_time\" json:\"end_time\"`\n\tStatus     string `gorm:\"column:status\" json:\"status\"`\n\tNotes      string `gorm:\"column:notes\" json:\"notes\"`\n}"
      },
      {
        "code_key": "MaxRiskLevel",
        "code_value": "const MaxRiskLevel = 5"
      },
      {
        "code_key": "DefaultAppointmentStatus",
        "code_value": "const DefaultAppointmentStatus = \"scheduled\""
      },
      {
        "code_key": "PortfolioQueryClause",
        "code_value": "utils.SetSQLComment(ctx, utils.QueryKey)"
      },
      {
        "code_key": "AppointmentQueryClause",
        "code_value": "utils.SetSQLComment(ctx, utils.QueryKey)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ValidatePermissions",
    "orm_code": "func (repo *PhotoRepo) ValidatePermissions(ctx context.Context, photo *model.Photo) (bool, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\ttarget := &model.Photo{}\n\n\terr := repo.db.Clauses(queryClause).Table(model.PhotoTableName).\n\t\tWhere(\"territory = ? AND gross_value > ?\", photo.Territory, photo.GrossValue).\n\t\tFirst(target).Error\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif target.Limit < photo.Limit {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "caller": "func HandlePhotoUpload(ctx context.Context, dbConn *gorm.DB, region string, valueThreshold int) error {\n\tphotoStorage := &PhotoRepo{db: dbConn}\n\tphotoData := &model.Photo{\n\t\tTerritory:  region,\n\t\tGrossValue: valueThreshold,\n\t\tLimit:      1000,\n\t}\n\n\tisValid, err := photoStorage.ValidatePermissions(ctx, photoData)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"permission validation failed: %v\", err)\n\t}\n\tif !isValid {\n\t\treturn errors.New(\"photo doesn't meet requirements\")\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "LACK_INFORMATION",
        "variants": [
          {
            "scenario": "缺少model.PhotoTableName常量的具体值",
            "sql": "SELECT * FROM photos WHERE territory = ? AND gross_value > ? LIMIT 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PortfolioRepo",
        "code_value": "type PortfolioRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "PortfolioTableName",
        "code_value": "const PortfolioTableName = \"user_portfolios\""
      },
      {
        "code_key": "Portfolio",
        "code_value": "type Portfolio struct {\n\tID          int64   `gorm:\"column:id\" json:\"id\"`\n\tUserID      int64   `gorm:\"column:user_id\" json:\"user_id\"`\n\tAssetType   string  `gorm:\"column:asset_type\" json:\"asset_type\"`\n\tAmount      float64 `gorm:\"column:amount\" json:\"amount\"`\n\tRiskLevel   int     `gorm:\"column:risk_level\" json:\"risk_level\"`\n\tCreatedTime int64   `gorm:\"column:created_time\" json:\"created_time\"`\n}"
      },
      {
        "code_key": "AppointmentRepo",
        "code_value": "type AppointmentRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "AppointmentTableName",
        "code_value": "const AppointmentTableName = \"client_appointments\""
      },
      {
        "code_key": "Appointment",
        "code_value": "type Appointment struct {\n\tID         int64  `gorm:\"column:id\" json:\"id\"`\n\tClientID   int64  `gorm:\"column:client_id\" json:\"client_id\"`\n\tAdvisorID  int64  `gorm:\"column:advisor_id\" json:\"advisor_id\"`\n\tStartTime  int64  `gorm:\"column:start_time\" json:\"start_time\"`\n\tEndTime    int64  `gorm:\"column:end_time\" json:\"end_time\"`\n\tStatus     string `gorm:\"column:status\" json:\"status\"`\n\tNotes      string `gorm:\"column:notes\" json:\"notes\"`\n}"
      },
      {
        "code_key": "MaxRiskLevel",
        "code_value": "const MaxRiskLevel = 5"
      },
      {
        "code_key": "DefaultAppointmentStatus",
        "code_value": "const DefaultAppointmentStatus = \"scheduled\""
      },
      {
        "code_key": "PortfolioQueryClause",
        "code_value": "utils.SetSQLComment(ctx, utils.QueryKey)"
      },
      {
        "code_key": "AppointmentQueryClause",
        "code_value": "utils.SetSQLComment(ctx, utils.QueryKey)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ValidatePermissions",
    "orm_code": "func (repo *PhotoRepo) ValidatePermissions(ctx context.Context, photo *model.Photo) (bool, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\ttarget := &model.Photo{}\n\n\terr := repo.db.Clauses(queryClause).Table(model.PhotoTableName).\n\t\tWhere(\"territory = ? AND gross_value > ?\", photo.Territory, photo.GrossValue).\n\t\tFirst(target).Error\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif target.Limit < photo.Limit {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "caller": "func CheckMediaEligibility(ctx context.Context, gormDB *gorm.DB, countryCode string, minValue int) (bool, error) {\n\tmediaRepo := PhotoRepo{db: gormDB}\n\tmediaItem := model.Photo{\n\t\tTerritory:  countryCode,\n\t\tGrossValue: minValue,\n\t\tLimit:      500,\n\t}\n\n\tapproved, checkErr := mediaRepo.ValidatePermissions(ctx, &mediaItem)\n\tif checkErr != nil {\n\t\treturn false, fmt.Errorf(\"eligibility check error: %w\", checkErr)\n\t}\n\treturn approved, nil\n}",
    "sql_statement_list": [
      {
        "type": "LACK_INFORMATION",
        "variants": [
          {
            "scenario": "缺少model.Photo结构体和PhotoTableName常量的定义",
            "sql": "SELECT * FROM photos WHERE territory = ? AND gross_value > ? ORDER BY photos.id LIMIT 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PortfolioRepo",
        "code_value": "type PortfolioRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "PortfolioTableName",
        "code_value": "const PortfolioTableName = \"user_portfolios\""
      },
      {
        "code_key": "Portfolio",
        "code_value": "type Portfolio struct {\n\tID          int64   `gorm:\"column:id\" json:\"id\"`\n\tUserID      int64   `gorm:\"column:user_id\" json:\"user_id\"`\n\tAssetType   string  `gorm:\"column:asset_type\" json:\"asset_type\"`\n\tAmount      float64 `gorm:\"column:amount\" json:\"amount\"`\n\tRiskLevel   int     `gorm:\"column:risk_level\" json:\"risk_level\"`\n\tCreatedTime int64   `gorm:\"column:created_time\" json:\"created_time\"`\n}"
      },
      {
        "code_key": "AppointmentRepo",
        "code_value": "type AppointmentRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "AppointmentTableName",
        "code_value": "const AppointmentTableName = \"client_appointments\""
      },
      {
        "code_key": "Appointment",
        "code_value": "type Appointment struct {\n\tID         int64  `gorm:\"column:id\" json:\"id\"`\n\tClientID   int64  `gorm:\"column:client_id\" json:\"client_id\"`\n\tAdvisorID  int64  `gorm:\"column:advisor_id\" json:\"advisor_id\"`\n\tStartTime  int64  `gorm:\"column:start_time\" json:\"start_time\"`\n\tEndTime    int64  `gorm:\"column:end_time\" json:\"end_time\"`\n\tStatus     string `gorm:\"column:status\" json:\"status\"`\n\tNotes      string `gorm:\"column:notes\" json:\"notes\"`\n}"
      },
      {
        "code_key": "MaxRiskLevel",
        "code_value": "const MaxRiskLevel = 5"
      },
      {
        "code_key": "DefaultAppointmentStatus",
        "code_value": "const DefaultAppointmentStatus = \"scheduled\""
      },
      {
        "code_key": "PortfolioQueryClause",
        "code_value": "utils.SetSQLComment(ctx, utils.QueryKey)"
      },
      {
        "code_key": "AppointmentQueryClause",
        "code_value": "utils.SetSQLComment(ctx, utils.QueryKey)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ValidatePermissions",
    "orm_code": "func (repo *PhotoRepo) ValidatePermissions(ctx context.Context, photo *model.Photo) (bool, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\ttarget := &model.Photo{}\n\n\terr := repo.db.Clauses(queryClause).Table(model.PhotoTableName).\n\t\tWhere(\"territory = ? AND gross_value > ?\", photo.Territory, photo.GrossValue).\n\t\tFirst(target).Error\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif target.Limit < photo.Limit {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "caller": "func CheckMediaAccess(userRole string, productID string) {\n\tmediaUser := &Player{\n\t\tRole:        userRole,\n\t\tProductCode: productID,\n\t}\n\n\thasAccess, err := mediaUser.ValidatePermissions()\n\tif err != nil {\n\t\tlog.Printf(\"Permission check failed: %v\", err)\n\t\treturn\n\t}\n\n\tif hasAccess {\n\t\tlog.Println(\"Access granted to media resources\")\n\t} else {\n\t\tlog.Println(\"Access denied to media resources\")\n\t}\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Role为admin时生成的SQL",
            "sql": "SELECT COUNT(1) > 0 AS has_access FROM media_uploads WHERE priority_rank <= 3 AND product_code = ?;"
          },
          {
            "scenario": "Role为editor时生成的SQL",
            "sql": "SELECT COUNT(1) > 0 AS has_access FROM media_uploads WHERE priority_rank <= 2 AND product_code = ?;"
          },
          {
            "scenario": "Role为viewer时生成的SQL",
            "sql": "SELECT COUNT(1) > 0 AS has_access FROM media_uploads WHERE priority_rank <= 1 AND product_code = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PortfolioRepo",
        "code_value": "type PortfolioRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "PortfolioTableName",
        "code_value": "const PortfolioTableName = \"user_portfolios\""
      },
      {
        "code_key": "Portfolio",
        "code_value": "type Portfolio struct {\n\tID          int64   `gorm:\"column:id\" json:\"id\"`\n\tUserID      int64   `gorm:\"column:user_id\" json:\"user_id\"`\n\tAssetType   string  `gorm:\"column:asset_type\" json:\"asset_type\"`\n\tAmount      float64 `gorm:\"column:amount\" json:\"amount\"`\n\tRiskLevel   int     `gorm:\"column:risk_level\" json:\"risk_level\"`\n\tCreatedTime int64   `gorm:\"column:created_time\" json:\"created_time\"`\n}"
      },
      {
        "code_key": "AppointmentRepo",
        "code_value": "type AppointmentRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "AppointmentTableName",
        "code_value": "const AppointmentTableName = \"client_appointments\""
      },
      {
        "code_key": "Appointment",
        "code_value": "type Appointment struct {\n\tID         int64  `gorm:\"column:id\" json:\"id\"`\n\tClientID   int64  `gorm:\"column:client_id\" json:\"client_id\"`\n\tAdvisorID  int64  `gorm:\"column:advisor_id\" json:\"advisor_id\"`\n\tStartTime  int64  `gorm:\"column:start_time\" json:\"start_time\"`\n\tEndTime    int64  `gorm:\"column:end_time\" json:\"end_time\"`\n\tStatus     string `gorm:\"column:status\" json:\"status\"`\n\tNotes      string `gorm:\"column:notes\" json:\"notes\"`\n}"
      },
      {
        "code_key": "MaxRiskLevel",
        "code_value": "const MaxRiskLevel = 5"
      },
      {
        "code_key": "DefaultAppointmentStatus",
        "code_value": "const DefaultAppointmentStatus = \"scheduled\""
      },
      {
        "code_key": "PortfolioQueryClause",
        "code_value": "utils.SetSQLComment(ctx, utils.QueryKey)"
      },
      {
        "code_key": "AppointmentQueryClause",
        "code_value": "utils.SetSQLComment(ctx, utils.QueryKey)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ValidatePermissions",
    "orm_code": "func (repo *PhotoRepo) ValidatePermissions(ctx context.Context, photo *model.Photo) (bool, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\ttarget := &model.Photo{}\n\n\terr := repo.db.Clauses(queryClause).Table(model.PhotoTableName).\n\t\tWhere(\"territory = ? AND gross_value > ?\", photo.Territory, photo.GrossValue).\n\t\tFirst(target).Error\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif target.Limit < photo.Limit {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "caller": "func ProcessContentUpload() error {\n\tcontentEditor := &Player{\n\t\tRole:        \"editor\",\n\t\tProductCode: \"PROD_789\",\n\t}\n\n\tapproved, verr := contentEditor.ValidatePermissions()\n\tif verr != nil {\n\t\treturn fmt.Errorf(\"validation failed: %w\", verr)\n\t}\n\n\tif !approved {\n\t\treturn errors.New(\"insufficient permissions for upload\")\n\t}\n\n\t// Proceed with upload logic\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "admin role with accessLevel = 3",
            "sql": "SELECT COUNT(1) > 0 AS has_access FROM media_uploads WHERE priority_rank <= 3 AND product_code = ?;"
          },
          {
            "scenario": "editor role with accessLevel = 2",
            "sql": "SELECT COUNT(1) > 0 AS has_access FROM media_uploads WHERE priority_rank <= 2 AND product_code = ?;"
          },
          {
            "scenario": "viewer role with accessLevel = 1",
            "sql": "SELECT COUNT(1) > 0 AS has_access FROM media_uploads WHERE priority_rank <= 1 AND product_code = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PortfolioRepo",
        "code_value": "type PortfolioRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "PortfolioTableName",
        "code_value": "const PortfolioTableName = \"user_portfolios\""
      },
      {
        "code_key": "Portfolio",
        "code_value": "type Portfolio struct {\n\tID          int64   `gorm:\"column:id\" json:\"id\"`\n\tUserID      int64   `gorm:\"column:user_id\" json:\"user_id\"`\n\tAssetType   string  `gorm:\"column:asset_type\" json:\"asset_type\"`\n\tAmount      float64 `gorm:\"column:amount\" json:\"amount\"`\n\tRiskLevel   int     `gorm:\"column:risk_level\" json:\"risk_level\"`\n\tCreatedTime int64   `gorm:\"column:created_time\" json:\"created_time\"`\n}"
      },
      {
        "code_key": "AppointmentRepo",
        "code_value": "type AppointmentRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "AppointmentTableName",
        "code_value": "const AppointmentTableName = \"client_appointments\""
      },
      {
        "code_key": "Appointment",
        "code_value": "type Appointment struct {\n\tID         int64  `gorm:\"column:id\" json:\"id\"`\n\tClientID   int64  `gorm:\"column:client_id\" json:\"client_id\"`\n\tAdvisorID  int64  `gorm:\"column:advisor_id\" json:\"advisor_id\"`\n\tStartTime  int64  `gorm:\"column:start_time\" json:\"start_time\"`\n\tEndTime    int64  `gorm:\"column:end_time\" json:\"end_time\"`\n\tStatus     string `gorm:\"column:status\" json:\"status\"`\n\tNotes      string `gorm:\"column:notes\" json:\"notes\"`\n}"
      },
      {
        "code_key": "MaxRiskLevel",
        "code_value": "const MaxRiskLevel = 5"
      },
      {
        "code_key": "DefaultAppointmentStatus",
        "code_value": "const DefaultAppointmentStatus = \"scheduled\""
      },
      {
        "code_key": "PortfolioQueryClause",
        "code_value": "utils.SetSQLComment(ctx, utils.QueryKey)"
      },
      {
        "code_key": "AppointmentQueryClause",
        "code_value": "utils.SetSQLComment(ctx, utils.QueryKey)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "MergeRecords",
    "orm_code": "func (repo *CurriculumRepo) MergeRecords(ctx context.Context, record *model.ContentArchive) error {\n    selectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n    updateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n    existing := &model.ContentArchive{}\n\n    if err := repo.db.Clauses(selectClause).Table(model.ContentArchiveTableName).\n        Where(\"location_code = ? AND classification_level = ?\", record.LocationCode, record.ClassificationLevel).\n        First(existing).Error; err != nil {\n        if errors.Is(err, gorm.ErrRecordNotFound) {\n            return repo.db.Table(model.ContentArchiveTableName).Create(record).Error\n        }\n        return err\n    }\n\n    if existing.UnitPrice != record.UnitPrice {\n        return repo.db.Clauses(updateClause).Table(model.ContentArchiveTableName).\n            Where(\"id = ?\", existing.Id).\n            Update(\"unit_price\", record.UnitPrice).Error\n    }\n    return nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "记录不存在（首次创建）",
            "sql": "SELECT id, location_code, classification_level, unit_price FROM content_archive WHERE location_code = ? AND classification_level = ? LIMIT 1;"
          },
          {
            "scenario": "记录不存在（首次创建）",
            "sql": "INSERT INTO content_archive (location_code, classification_level, unit_price) VALUES (?, ?, ?);"
          },
          {
            "scenario": "记录存在且价格不同（需要更新）",
            "sql": "SELECT id, location_code, classification_level, unit_price FROM content_archive WHERE location_code = ? AND classification_level = ? LIMIT 1;"
          },
          {
            "scenario": "记录存在且价格不同（需要更新）",
            "sql": "UPDATE content_archive SET unit_price = ? WHERE id = ?;"
          },
          {
            "scenario": "记录存在且价格相同（不做任何操作）",
            "sql": "SELECT id, location_code, classification_level, unit_price FROM content_archive WHERE location_code = ? AND classification_level = ? LIMIT 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "ContentArchive",
        "code_value": "type ContentArchive struct {\n\tId                   int64   `gorm:\"column:id\" json:\"id\"`\n\tLocationCode         string  `gorm:\"column:location_code\" json:\"location_code\"`\n\tClassificationLevel  int     `gorm:\"column:classification_level\" json:\"classification_level\"`\n\tUnitPrice            float64 `gorm:\"column:unit_price\" json:\"unit_price\"`\n}"
      },
      {
        "code_key": "ContentArchiveTableName",
        "code_value": "const ContentArchiveTableName = \"content_archive\""
      },
      {
        "code_key": "CurriculumRepo",
        "code_value": "type CurriculumRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "selectClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SelectKey)"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-content-management/pkg/utils"
      },
      {
        "code_key": "PriceHistory",
        "code_value": "type PriceHistory struct {\n\tId          int64   `gorm:\"column:id\" json:\"id\"`\n\tArchiveId   int64   `gorm:\"column:archive_id\" json:\"archive_id\"`\n\tOldPrice    float64 `gorm:\"column:old_price\" json:\"old_price\"`\n\tNewPrice    float64 `gorm:\"column:new_price\" json:\"new_price\"`\n\tUpdatedAt   int64   `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "PriceHistoryTableName",
        "code_value": "const PriceHistoryTableName = \"price_history\""
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "MergeRecords",
    "orm_code": "func (repo *CurriculumRepo) MergeRecords(ctx context.Context, record *model.ContentArchive) error {\n    selectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n    updateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n    existing := &model.ContentArchive{}\n\n    if err := repo.db.Clauses(selectClause).Table(model.ContentArchiveTableName).\n        Where(\"location_code = ? AND classification_level = ?\", record.LocationCode, record.ClassificationLevel).\n        First(existing).Error; err != nil {\n        if errors.Is(err, gorm.ErrRecordNotFound) {\n            return repo.db.Table(model.ContentArchiveTableName).Create(record).Error\n        }\n        return err\n    }\n\n    if existing.UnitPrice != record.UnitPrice {\n        return repo.db.Clauses(updateClause).Table(model.ContentArchiveTableName).\n            Where(\"id = ?\", existing.Id).\n            Update(\"unit_price\", record.UnitPrice).Error\n    }\n    return nil\n}",
    "caller": "func HandlePriceUpdate(ctx context.Context, location string, level int, newPrice float64) error {\n\tcurriculumRepo := &CurriculumRepo{db: globalDB}\n\tarchiveEntry := &model.ContentArchive{\n\t\tLocationCode:          location,\n\t\tClassificationLevel:   level,\n\t\tUnitPrice:            newPrice\n\t}\n\tif err := curriculumRepo.MergeRecords(ctx, archiveEntry); err != nil {\n\t\tlog.Printf(\"Failed to update price for %s level %d: %v\", location, level, err)\n\t\treturn err\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "记录不存在时执行SELECT和INSERT",
            "sql": "SELECT * FROM content_archive WHERE location_code = ? AND classification_level = ? LIMIT 1;"
          },
          {
            "scenario": "记录存在但价格相同只执行SELECT",
            "sql": "SELECT * FROM content_archive WHERE location_code = ? AND classification_level = ? LIMIT 1;"
          },
          {
            "scenario": "记录存在且价格不同时执行SELECT和UPDATE",
            "sql": "SELECT * FROM content_archive WHERE location_code = ? AND classification_level = ? LIMIT 1;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "记录不存在时执行INSERT",
            "sql": "INSERT INTO content_archive (location_code, classification_level, unit_price) VALUES (?, ?, ?);"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "记录存在且价格不同时执行UPDATE",
            "sql": "UPDATE content_archive SET unit_price = ? WHERE id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ContentArchive",
        "code_value": "type ContentArchive struct {\n\tId                   int64   `gorm:\"column:id\" json:\"id\"`\n\tLocationCode         string  `gorm:\"column:location_code\" json:\"location_code\"`\n\tClassificationLevel  int     `gorm:\"column:classification_level\" json:\"classification_level\"`\n\tUnitPrice            float64 `gorm:\"column:unit_price\" json:\"unit_price\"`\n}"
      },
      {
        "code_key": "ContentArchiveTableName",
        "code_value": "const ContentArchiveTableName = \"content_archive\""
      },
      {
        "code_key": "CurriculumRepo",
        "code_value": "type CurriculumRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "selectClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SelectKey)"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-content-management/pkg/utils"
      },
      {
        "code_key": "PriceHistory",
        "code_value": "type PriceHistory struct {\n\tId          int64   `gorm:\"column:id\" json:\"id\"`\n\tArchiveId   int64   `gorm:\"column:archive_id\" json:\"archive_id\"`\n\tOldPrice    float64 `gorm:\"column:old_price\" json:\"old_price\"`\n\tNewPrice    float64 `gorm:\"column:new_price\" json:\"new_price\"`\n\tUpdatedAt   int64   `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "PriceHistoryTableName",
        "code_value": "const PriceHistoryTableName = \"price_history\""
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "MergeRecords",
    "orm_code": "func (repo *CurriculumRepo) MergeRecords(ctx context.Context, record *model.ContentArchive) error {\n    selectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n    updateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n    existing := &model.ContentArchive{}\n\n    if err := repo.db.Clauses(selectClause).Table(model.ContentArchiveTableName).\n        Where(\"location_code = ? AND classification_level = ?\", record.LocationCode, record.ClassificationLevel).\n        First(existing).Error; err != nil {\n        if errors.Is(err, gorm.ErrRecordNotFound) {\n            return repo.db.Table(model.ContentArchiveTableName).Create(record).Error\n        }\n        return err\n    }\n\n    if existing.UnitPrice != record.UnitPrice {\n        return repo.db.Clauses(updateClause).Table(model.ContentArchiveTableName).\n            Where(\"id = ?\", existing.Id).\n            Update(\"unit_price\", record.UnitPrice).Error\n    }\n    return nil\n}",
    "caller": "func SyncCurriculumPrices(ctx context.Context, priceUpdates []model.PriceChange) error {\n\trepo := NewCurriculumRepo(GetDB())\n\tfor _, update := range priceUpdates {\n\t\tarchive := &model.ContentArchive{\n\t\t\tLocationCode:         update.RegionCode,\n\t\t\tClassificationLevel:  update.Grade,\n\t\t\tUnitPrice:           update.NewAmount\n\t\t}\n\t\tif err := repo.MergeRecords(ctx, archive); err != nil {\n\t\t\treturn fmt.Errorf(\"price sync failed for %s: %w\", update.RegionCode, err)\n\t\t}\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "记录不存在（首次创建）",
            "sql": "SELECT * FROM content_archive WHERE location_code = 'REGION_A' AND classification_level = 1 LIMIT 1;"
          },
          {
            "scenario": "记录存在且价格不同（需要更新）",
            "sql": "SELECT * FROM content_archive WHERE location_code = 'REGION_B' AND classification_level = 2 LIMIT 1;"
          },
          {
            "scenario": "记录存在且价格相同（无需操作）",
            "sql": "SELECT * FROM content_archive WHERE location_code = 'REGION_C' AND classification_level = 3 LIMIT 1;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "记录不存在时执行插入",
            "sql": "INSERT INTO content_archive (location_code, classification_level, unit_price) VALUES ('REGION_A', 1, 99.99);"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "记录存在且价格不同时执行更新",
            "sql": "UPDATE content_archive SET unit_price = 199.99 WHERE id = 123;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ContentArchive",
        "code_value": "type ContentArchive struct {\n\tId                   int64   `gorm:\"column:id\" json:\"id\"`\n\tLocationCode         string  `gorm:\"column:location_code\" json:\"location_code\"`\n\tClassificationLevel  int     `gorm:\"column:classification_level\" json:\"classification_level\"`\n\tUnitPrice            float64 `gorm:\"column:unit_price\" json:\"unit_price\"`\n}"
      },
      {
        "code_key": "ContentArchiveTableName",
        "code_value": "const ContentArchiveTableName = \"content_archive\""
      },
      {
        "code_key": "CurriculumRepo",
        "code_value": "type CurriculumRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "selectClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SelectKey)"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-content-management/pkg/utils"
      },
      {
        "code_key": "PriceHistory",
        "code_value": "type PriceHistory struct {\n\tId          int64   `gorm:\"column:id\" json:\"id\"`\n\tArchiveId   int64   `gorm:\"column:archive_id\" json:\"archive_id\"`\n\tOldPrice    float64 `gorm:\"column:old_price\" json:\"old_price\"`\n\tNewPrice    float64 `gorm:\"column:new_price\" json:\"new_price\"`\n\tUpdatedAt   int64   `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "PriceHistoryTableName",
        "code_value": "const PriceHistoryTableName = \"price_history\""
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "MonitorHealth",
    "orm_code": "func (repo *HealthRepo) MonitorHealth(ctx context.Context, check *model.HealthCheck) error {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tinsertClause := utils.SetSQLComment(ctx, utils.InsertKey)\n\tlastCheck := &model.HealthCheck{}\n\n\tif err := repo.db.Clauses(selectClause).Table(model.HealthCheckTableName).\n\t\tWhere(\"node_id = ?\", check.NodeId).\n\t\tLast(lastCheck).\n\t\tError; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\tif err = repo.db.Clauses(insertClause).Table(model.HealthCheckTableName).\n\t\t\t\tCreate(check).Error; err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif lastCheck.Dimension != check.Dimension {\n\t\tif err := repo.db.Clauses(insertClause).Table(model.HealthCheckTableName).\n\t\t\tCreate(check).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "CategoryType = 1",
            "sql": "SELECT test_id, dimension, continent, test_date, result_value FROM lab_test_results WHERE dimension = ? AND continent = 'NA' ORDER BY test_date DESC LIMIT 100;"
          },
          {
            "scenario": "CategoryType = 2",
            "sql": "SELECT test_id, dimension, continent, test_date, result_value FROM lab_test_results WHERE dimension = ? AND continent IN ('EU', 'AS') ORDER BY test_date DESC LIMIT 100;"
          },
          {
            "scenario": "CategoryType = 3",
            "sql": "SELECT test_id, dimension, continent, test_date, result_value FROM lab_test_results WHERE dimension > ? ORDER BY test_date DESC LIMIT 100;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "HealthRepo",
        "code_value": "type HealthRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "HealthCheck",
        "code_value": "type HealthCheck struct {\n\tID        int64  `gorm:\"column:id\" json:\"id\"`\n\tNodeId    string `gorm:\"column:node_id\" json:\"node_id\"`\n\tDimension int    `gorm:\"column:dimension\" json:\"dimension\"`\n\tStatus    string `gorm:\"column:status\" json:\"status\"`\n\tTimestamp int64  `gorm:\"column:timestamp\" json:\"timestamp\"`\n}"
      },
      {
        "code_key": "HealthCheckTableName",
        "code_value": "const HealthCheckTableName = \"system_health_checks\""
      },
      {
        "code_key": "HealthStatus",
        "code_value": "type HealthStatus string\n\nconst (\n\tStatusHealthy   HealthStatus = \"HEALTHY\"\n\tStatusDegraded  HealthStatus = \"DEGRADED\"\n\tStatusCritical  HealthStatus = \"CRITICAL\"\n\tStatusUnknown   HealthStatus = \"UNKNOWN\"\n)"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "NodeRole",
        "code_value": "type NodeRole string\n\nconst (\n\tRoleMaster NodeRole = \"MASTER\"\n\tRoleWorker NodeRole = \"WORKER\"\n\tRoleProxy  NodeRole = \"PROXY\"\n)"
      },
      {
        "code_key": "HealthDimension",
        "code_value": "type HealthDimension int\n\nconst (\n\tDimensionCPU     HealthDimension = 1\n\tDimensionMemory  HealthDimension = 2\n\tDimensionDisk    HealthDimension = 3\n\tDimensionNetwork HealthDimension = 4\n)"
      },
      {
        "code_key": "HealthThreshold",
        "code_value": "var HealthThreshold = map[HealthDimension]float64{\n\tDimensionCPU:     0.8,\n\tDimensionMemory:  0.85,\n\tDimensionDisk:    0.9,\n\tDimensionNetwork: 0.7,\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (hc *HealthCheck) TableName() string {\n\treturn HealthCheckTableName\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "MonitorHealth",
    "orm_code": "func (repo *HealthRepo) MonitorHealth(ctx context.Context, check *model.HealthCheck) error {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tinsertClause := utils.SetSQLComment(ctx, utils.InsertKey)\n\tlastCheck := &model.HealthCheck{}\n\n\tif err := repo.db.Clauses(selectClause).Table(model.HealthCheckTableName).\n\t\tWhere(\"node_id = ?\", check.NodeId).\n\t\tLast(lastCheck).\n\t\tError; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\tif err = repo.db.Clauses(insertClause).Table(model.HealthCheckTableName).\n\t\t\t\tCreate(check).Error; err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif lastCheck.Dimension != check.Dimension {\n\t\tif err := repo.db.Clauses(insertClause).Table(model.HealthCheckTableName).\n\t\t\tCreate(check).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func HandleClusterHealthCheck(ctx context.Context, nodeID string, dimension string, logger *zap.Logger) error {\n\thealthRepo := &HealthRepo{db: globalDB}\n\tcheck := &model.HealthCheck{\n\t\tNodeId:    nodeID,\n\t\tDimension: dimension,\n\t\tTimestamp: time.Now().Unix(),\n\t}\n\n\tif err := healthRepo.MonitorHealth(ctx, check); err != nil {\n\t\tlogger.Error(\"Failed to monitor cluster health\", zap.String(\"nodeID\", nodeID), zap.Error(err))\n\t\treturn fmt.Errorf(\"health check failed for node %s: %v\", nodeID, err)\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "未找到现有记录时执行的SELECT和INSERT",
            "sql": "SELECT * FROM system_health_checks WHERE node_id = ? ORDER BY system_health_checks.timestamp DESC LIMIT 1;"
          },
          {
            "scenario": "未找到现有记录时执行的INSERT",
            "sql": "INSERT INTO system_health_checks (node_id, dimension, timestamp) VALUES (?, ?, ?);"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "找到记录但维度不同时执行的SELECT和INSERT",
            "sql": "SELECT * FROM system_health_checks WHERE node_id = ? ORDER BY system_health_checks.timestamp DESC LIMIT 1;"
          },
          {
            "scenario": "找到记录但维度不同时执行的INSERT",
            "sql": "INSERT INTO system_health_checks (node_id, dimension, timestamp) VALUES (?, ?, ?);"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "找到记录且维度相同时只执行SELECT",
            "sql": "SELECT * FROM system_health_checks WHERE node_id = ? ORDER BY system_health_checks.timestamp DESC LIMIT 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "HealthRepo",
        "code_value": "type HealthRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "HealthCheck",
        "code_value": "type HealthCheck struct {\n\tID        int64  `gorm:\"column:id\" json:\"id\"`\n\tNodeId    string `gorm:\"column:node_id\" json:\"node_id\"`\n\tDimension int    `gorm:\"column:dimension\" json:\"dimension\"`\n\tStatus    string `gorm:\"column:status\" json:\"status\"`\n\tTimestamp int64  `gorm:\"column:timestamp\" json:\"timestamp\"`\n}"
      },
      {
        "code_key": "HealthCheckTableName",
        "code_value": "const HealthCheckTableName = \"system_health_checks\""
      },
      {
        "code_key": "HealthStatus",
        "code_value": "type HealthStatus string\n\nconst (\n\tStatusHealthy   HealthStatus = \"HEALTHY\"\n\tStatusDegraded  HealthStatus = \"DEGRADED\"\n\tStatusCritical  HealthStatus = \"CRITICAL\"\n\tStatusUnknown   HealthStatus = \"UNKNOWN\"\n)"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "NodeRole",
        "code_value": "type NodeRole string\n\nconst (\n\tRoleMaster NodeRole = \"MASTER\"\n\tRoleWorker NodeRole = \"WORKER\"\n\tRoleProxy  NodeRole = \"PROXY\"\n)"
      },
      {
        "code_key": "HealthDimension",
        "code_value": "type HealthDimension int\n\nconst (\n\tDimensionCPU     HealthDimension = 1\n\tDimensionMemory  HealthDimension = 2\n\tDimensionDisk    HealthDimension = 3\n\tDimensionNetwork HealthDimension = 4\n)"
      },
      {
        "code_key": "HealthThreshold",
        "code_value": "var HealthThreshold = map[HealthDimension]float64{\n\tDimensionCPU:     0.8,\n\tDimensionMemory:  0.85,\n\tDimensionDisk:    0.9,\n\tDimensionNetwork: 0.7,\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (hc *HealthCheck) TableName() string {\n\treturn HealthCheckTableName\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "MonitorHealth",
    "orm_code": "func (repo *HealthRepo) MonitorHealth(ctx context.Context, check *model.HealthCheck) error {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tinsertClause := utils.SetSQLComment(ctx, utils.InsertKey)\n\tlastCheck := &model.HealthCheck{}\n\n\tif err := repo.db.Clauses(selectClause).Table(model.HealthCheckTableName).\n\t\tWhere(\"node_id = ?\", check.NodeId).\n\t\tLast(lastCheck).\n\t\tError; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\tif err = repo.db.Clauses(insertClause).Table(model.HealthCheckTableName).\n\t\t\t\tCreate(check).Error; err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif lastCheck.Dimension != check.Dimension {\n\t\tif err := repo.db.Clauses(insertClause).Table(model.HealthCheckTableName).\n\t\t\tCreate(check).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func ProcessNodeHealthStatus(ctx context.Context, nodes []*model.ClusterNode) error {\n\thealthRepo := &HealthRepo{db: database.GetInstance()}\n\tfor _, node := range nodes {\n\t\tif node == nil {\n\t\t\tcontinue\n\t\t}\n\t\tcheck := &model.HealthCheck{\n\t\t\tNodeId:    node.ID,\n\t\t\tDimension: node.HealthDimension,\n\t\t\tTimestamp: time.Now().Unix(),\n\t\t}\n\t\tif err := healthRepo.MonitorHealth(ctx, check); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to process health status for node %s: %v\", node.ID, err)\n\t\t}\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "首次检查（记录不存在）",
            "sql": "SELECT * FROM system_health_checks WHERE node_id = ? ORDER BY system_health_checks.id DESC LIMIT 1;"
          },
          {
            "scenario": "非首次检查但维度不同",
            "sql": "SELECT * FROM system_health_checks WHERE node_id = ? ORDER BY system_health_checks.id DESC LIMIT 1;"
          },
          {
            "scenario": "非首次检查且维度相同",
            "sql": "SELECT * FROM system_health_checks WHERE node_id = ? ORDER BY system_health_checks.id DESC LIMIT 1;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "首次检查（记录不存在）",
            "sql": "INSERT INTO system_health_checks (node_id, dimension, timestamp) VALUES (?, ?, ?);"
          },
          {
            "scenario": "非首次检查但维度不同",
            "sql": "INSERT INTO system_health_checks (node_id, dimension, timestamp) VALUES (?, ?, ?);"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "HealthRepo",
        "code_value": "type HealthRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "HealthCheck",
        "code_value": "type HealthCheck struct {\n\tID        int64  `gorm:\"column:id\" json:\"id\"`\n\tNodeId    string `gorm:\"column:node_id\" json:\"node_id\"`\n\tDimension int    `gorm:\"column:dimension\" json:\"dimension\"`\n\tStatus    string `gorm:\"column:status\" json:\"status\"`\n\tTimestamp int64  `gorm:\"column:timestamp\" json:\"timestamp\"`\n}"
      },
      {
        "code_key": "HealthCheckTableName",
        "code_value": "const HealthCheckTableName = \"system_health_checks\""
      },
      {
        "code_key": "HealthStatus",
        "code_value": "type HealthStatus string\n\nconst (\n\tStatusHealthy   HealthStatus = \"HEALTHY\"\n\tStatusDegraded  HealthStatus = \"DEGRADED\"\n\tStatusCritical  HealthStatus = \"CRITICAL\"\n\tStatusUnknown   HealthStatus = \"UNKNOWN\"\n)"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "NodeRole",
        "code_value": "type NodeRole string\n\nconst (\n\tRoleMaster NodeRole = \"MASTER\"\n\tRoleWorker NodeRole = \"WORKER\"\n\tRoleProxy  NodeRole = \"PROXY\"\n)"
      },
      {
        "code_key": "HealthDimension",
        "code_value": "type HealthDimension int\n\nconst (\n\tDimensionCPU     HealthDimension = 1\n\tDimensionMemory  HealthDimension = 2\n\tDimensionDisk    HealthDimension = 3\n\tDimensionNetwork HealthDimension = 4\n)"
      },
      {
        "code_key": "HealthThreshold",
        "code_value": "var HealthThreshold = map[HealthDimension]float64{\n\tDimensionCPU:     0.8,\n\tDimensionMemory:  0.85,\n\tDimensionDisk:    0.9,\n\tDimensionNetwork: 0.7,\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (hc *HealthCheck) TableName() string {\n\treturn HealthCheckTableName\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "MonitorHealth",
    "orm_code": "func (repo *HealthRepo) MonitorHealth(ctx context.Context, check *model.HealthCheck) error {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tinsertClause := utils.SetSQLComment(ctx, utils.InsertKey)\n\tlastCheck := &model.HealthCheck{}\n\n\tif err := repo.db.Clauses(selectClause).Table(model.HealthCheckTableName).\n\t\tWhere(\"node_id = ?\", check.NodeId).\n\t\tLast(lastCheck).\n\t\tError; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\tif err = repo.db.Clauses(insertClause).Table(model.HealthCheckTableName).\n\t\t\t\tCreate(check).Error; err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif lastCheck.Dimension != check.Dimension {\n\t\tif err := repo.db.Clauses(insertClause).Table(model.HealthCheckTableName).\n\t\t\tCreate(check).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func HandleWeaponAnalysis() {\n\twep := &Weapon{\n\t\tCategoryType: 2,\n\t\tDimension:    15,\n\t}\n\n\tdataPoints, err := wep.MonitorHealth(10)\n\tif err != nil {\n\t\tlog.Printf(\"Failed to analyze weapon: %v\", err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"Retrieved %d test results\\n\", len(dataPoints))\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "CategoryType = 1",
            "sql": "SELECT test_id, dimension, continent, test_date, result_value FROM lab_test_results WHERE dimension = ? AND continent = 'NA' ORDER BY test_date DESC LIMIT 100;"
          },
          {
            "scenario": "CategoryType = 2",
            "sql": "SELECT test_id, dimension, continent, test_date, result_value FROM lab_test_results WHERE dimension = ? AND continent IN ('EU', 'AS') ORDER BY test_date DESC LIMIT 100;"
          },
          {
            "scenario": "CategoryType = 3",
            "sql": "SELECT test_id, dimension, continent, test_date, result_value FROM lab_test_results WHERE dimension > ? ORDER BY test_date DESC LIMIT 100;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "HealthRepo",
        "code_value": "type HealthRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "HealthCheck",
        "code_value": "type HealthCheck struct {\n\tID        int64  `gorm:\"column:id\" json:\"id\"`\n\tNodeId    string `gorm:\"column:node_id\" json:\"node_id\"`\n\tDimension int    `gorm:\"column:dimension\" json:\"dimension\"`\n\tStatus    string `gorm:\"column:status\" json:\"status\"`\n\tTimestamp int64  `gorm:\"column:timestamp\" json:\"timestamp\"`\n}"
      },
      {
        "code_key": "HealthCheckTableName",
        "code_value": "const HealthCheckTableName = \"system_health_checks\""
      },
      {
        "code_key": "HealthStatus",
        "code_value": "type HealthStatus string\n\nconst (\n\tStatusHealthy   HealthStatus = \"HEALTHY\"\n\tStatusDegraded  HealthStatus = \"DEGRADED\"\n\tStatusCritical  HealthStatus = \"CRITICAL\"\n\tStatusUnknown   HealthStatus = \"UNKNOWN\"\n)"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "NodeRole",
        "code_value": "type NodeRole string\n\nconst (\n\tRoleMaster NodeRole = \"MASTER\"\n\tRoleWorker NodeRole = \"WORKER\"\n\tRoleProxy  NodeRole = \"PROXY\"\n)"
      },
      {
        "code_key": "HealthDimension",
        "code_value": "type HealthDimension int\n\nconst (\n\tDimensionCPU     HealthDimension = 1\n\tDimensionMemory  HealthDimension = 2\n\tDimensionDisk    HealthDimension = 3\n\tDimensionNetwork HealthDimension = 4\n)"
      },
      {
        "code_key": "HealthThreshold",
        "code_value": "var HealthThreshold = map[HealthDimension]float64{\n\tDimensionCPU:     0.8,\n\tDimensionMemory:  0.85,\n\tDimensionDisk:    0.9,\n\tDimensionNetwork: 0.7,\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (hc *HealthCheck) TableName() string {\n\treturn HealthCheckTableName\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "MonitorHealth",
    "orm_code": "func (repo *HealthRepo) MonitorHealth(ctx context.Context, check *model.HealthCheck) error {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tinsertClause := utils.SetSQLComment(ctx, utils.InsertKey)\n\tlastCheck := &model.HealthCheck{}\n\n\tif err := repo.db.Clauses(selectClause).Table(model.HealthCheckTableName).\n\t\tWhere(\"node_id = ?\", check.NodeId).\n\t\tLast(lastCheck).\n\t\tError; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\tif err = repo.db.Clauses(insertClause).Table(model.HealthCheckTableName).\n\t\t\t\tCreate(check).Error; err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif lastCheck.Dimension != check.Dimension {\n\t\tif err := repo.db.Clauses(insertClause).Table(model.HealthCheckTableName).\n\t\t\tCreate(check).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func ProcessCriticalHealthChecks() error {\n\tcriticalWeapon := &Weapon{\n\t\tCategoryType: 3,\n\t\tDimension:    25,\n\t}\n\n\tlabReports, err := criticalWeapon.MonitorHealth(20)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"health check failure: %w\", err)\n\t}\n\n\tif len(labReports) == 0 {\n\t\treturn errors.New(\"no health data available\")\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "CategoryType == 1",
            "sql": "SELECT test_id, dimension, continent, test_date, result_value FROM lab_test_results WHERE dimension = ? AND continent = 'NA' ORDER BY test_date DESC LIMIT 100;"
          },
          {
            "scenario": "CategoryType == 2",
            "sql": "SELECT test_id, dimension, continent, test_date, result_value FROM lab_test_results WHERE dimension = ? AND continent IN ('EU', 'AS') ORDER BY test_date DESC LIMIT 100;"
          },
          {
            "scenario": "CategoryType == 3 (current execution path)",
            "sql": "SELECT test_id, dimension, continent, test_date, result_value FROM lab_test_results WHERE dimension > 20 ORDER BY test_date DESC LIMIT 100;"
          },
          {
            "scenario": "Unsupported CategoryType",
            "sql": ""
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "HealthRepo",
        "code_value": "type HealthRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "HealthCheck",
        "code_value": "type HealthCheck struct {\n\tID        int64  `gorm:\"column:id\" json:\"id\"`\n\tNodeId    string `gorm:\"column:node_id\" json:\"node_id\"`\n\tDimension int    `gorm:\"column:dimension\" json:\"dimension\"`\n\tStatus    string `gorm:\"column:status\" json:\"status\"`\n\tTimestamp int64  `gorm:\"column:timestamp\" json:\"timestamp\"`\n}"
      },
      {
        "code_key": "HealthCheckTableName",
        "code_value": "const HealthCheckTableName = \"system_health_checks\""
      },
      {
        "code_key": "HealthStatus",
        "code_value": "type HealthStatus string\n\nconst (\n\tStatusHealthy   HealthStatus = \"HEALTHY\"\n\tStatusDegraded  HealthStatus = \"DEGRADED\"\n\tStatusCritical  HealthStatus = \"CRITICAL\"\n\tStatusUnknown   HealthStatus = \"UNKNOWN\"\n)"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "NodeRole",
        "code_value": "type NodeRole string\n\nconst (\n\tRoleMaster NodeRole = \"MASTER\"\n\tRoleWorker NodeRole = \"WORKER\"\n\tRoleProxy  NodeRole = \"PROXY\"\n)"
      },
      {
        "code_key": "HealthDimension",
        "code_value": "type HealthDimension int\n\nconst (\n\tDimensionCPU     HealthDimension = 1\n\tDimensionMemory  HealthDimension = 2\n\tDimensionDisk    HealthDimension = 3\n\tDimensionNetwork HealthDimension = 4\n)"
      },
      {
        "code_key": "HealthThreshold",
        "code_value": "var HealthThreshold = map[HealthDimension]float64{\n\tDimensionCPU:     0.8,\n\tDimensionMemory:  0.85,\n\tDimensionDisk:    0.9,\n\tDimensionNetwork: 0.7,\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (hc *HealthCheck) TableName() string {\n\treturn HealthCheckTableName\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "MonitorHealth",
    "orm_code": "func (repo *HealthRepo) MonitorHealth(ctx context.Context, check *model.HealthCheck) error {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tinsertClause := utils.SetSQLComment(ctx, utils.InsertKey)\n\tlastCheck := &model.HealthCheck{}\n\n\tif err := repo.db.Clauses(selectClause).Table(model.HealthCheckTableName).\n\t\tWhere(\"node_id = ?\", check.NodeId).\n\t\tLast(lastCheck).\n\t\tError; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\tif err = repo.db.Clauses(insertClause).Table(model.HealthCheckTableName).\n\t\t\t\tCreate(check).Error; err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif lastCheck.Dimension != check.Dimension {\n\t\tif err := repo.db.Clauses(insertClause).Table(model.HealthCheckTableName).\n\t\t\tCreate(check).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func CheckRegionalWeapons(regionCode int) {\n\tdevice := Weapon{\n\t\tCategoryType: regionCode,\n\t\tDimension:    8,\n\t}\n\n\tresults, err := device.MonitorHealth(5)\n\tif err != nil {\n\t\tlog.Println(\"Regional check failed:\", err)\n\t\treturn\n\t}\n\n\tfor _, r := range results {\n\t\tfmt.Println(r.TestDate, \"-\", r.Status)\n\t}\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "CategoryType = 1",
            "sql": "SELECT test_id, dimension, continent, test_date, result_value FROM lab_test_results WHERE dimension = 8 AND continent = 'NA' ORDER BY test_date DESC LIMIT 100;"
          },
          {
            "scenario": "CategoryType = 2",
            "sql": "SELECT test_id, dimension, continent, test_date, result_value FROM lab_test_results WHERE dimension = 8 AND continent IN ('EU', 'AS') ORDER BY test_date DESC LIMIT 100;"
          },
          {
            "scenario": "CategoryType = 3",
            "sql": "SELECT test_id, dimension, continent, test_date, result_value FROM lab_test_results WHERE dimension > 5 ORDER BY test_date DESC LIMIT 100;"
          }
        ]
      },
      {
        "type": "NO_SQL_GENERATE",
        "variants": [
          {
            "scenario": "Unsupported category type (CategoryType not in 1,2,3)",
            "sql": ""
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "OTHER"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "HealthRepo",
        "code_value": "type HealthRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "HealthCheck",
        "code_value": "type HealthCheck struct {\n\tID        int64  `gorm:\"column:id\" json:\"id\"`\n\tNodeId    string `gorm:\"column:node_id\" json:\"node_id\"`\n\tDimension int    `gorm:\"column:dimension\" json:\"dimension\"`\n\tStatus    string `gorm:\"column:status\" json:\"status\"`\n\tTimestamp int64  `gorm:\"column:timestamp\" json:\"timestamp\"`\n}"
      },
      {
        "code_key": "HealthCheckTableName",
        "code_value": "const HealthCheckTableName = \"system_health_checks\""
      },
      {
        "code_key": "HealthStatus",
        "code_value": "type HealthStatus string\n\nconst (\n\tStatusHealthy   HealthStatus = \"HEALTHY\"\n\tStatusDegraded  HealthStatus = \"DEGRADED\"\n\tStatusCritical  HealthStatus = \"CRITICAL\"\n\tStatusUnknown   HealthStatus = \"UNKNOWN\"\n)"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "NodeRole",
        "code_value": "type NodeRole string\n\nconst (\n\tRoleMaster NodeRole = \"MASTER\"\n\tRoleWorker NodeRole = \"WORKER\"\n\tRoleProxy  NodeRole = \"PROXY\"\n)"
      },
      {
        "code_key": "HealthDimension",
        "code_value": "type HealthDimension int\n\nconst (\n\tDimensionCPU     HealthDimension = 1\n\tDimensionMemory  HealthDimension = 2\n\tDimensionDisk    HealthDimension = 3\n\tDimensionNetwork HealthDimension = 4\n)"
      },
      {
        "code_key": "HealthThreshold",
        "code_value": "var HealthThreshold = map[HealthDimension]float64{\n\tDimensionCPU:     0.8,\n\tDimensionMemory:  0.85,\n\tDimensionDisk:    0.9,\n\tDimensionNetwork: 0.7,\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (hc *HealthCheck) TableName() string {\n\treturn HealthCheckTableName\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "AggregateByType",
    "orm_code": "func (repo *RecommendationRepo) AggregateByType(ctx context.Context, categoryType int) ([]model.Recommendation, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tvar results []model.Recommendation\n\n\tif err := repo.db.Clauses(queryClause).Table(model.RecommendationTableName).\n\t\tWhere(\"category_type = ?\", categoryType).\n\t\tGroup(\"language\").\n\t\tSelect(\"language, sum(points) as points\").\n\t\tFind(&results).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn results, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "TradeType = Domestic, RegionCode为空",
            "sql": "SELECT region_code, sum(balance) as balance FROM transit_times WHERE status = 1 AND domestic = 1 GROUP BY region_code;"
          },
          {
            "scenario": "TradeType = International, RegionCode为空",
            "sql": "SELECT region_code, sum(balance) as balance FROM transit_times WHERE status = 1 AND domestic = 0 GROUP BY region_code;"
          },
          {
            "scenario": "TradeType = Digital, RegionCode为空",
            "sql": "SELECT region_code, sum(balance) as balance FROM transit_times WHERE status = 1 AND digital = 1 GROUP BY region_code;"
          },
          {
            "scenario": "TradeType = Physical, RegionCode为空",
            "sql": "SELECT region_code, sum(balance) as balance FROM transit_times WHERE status = 1 AND digital = 0 GROUP BY region_code;"
          },
          {
            "scenario": "TradeType = Domestic, RegionCode不为空",
            "sql": "SELECT region_code, sum(balance) as balance FROM transit_times WHERE status = 1 AND domestic = 1 AND region_code = ? GROUP BY region_code;"
          },
          {
            "scenario": "TradeType = International, RegionCode不为空",
            "sql": "SELECT region_code, sum(balance) as balance FROM transit_times WHERE status = 1 AND domestic = 0 AND region_code = ? GROUP BY region_code;"
          },
          {
            "scenario": "TradeType = Digital, RegionCode不为空",
            "sql": "SELECT region_code, sum(balance) as balance FROM transit_times WHERE status = 1 AND digital = 1 AND region_code = ? GROUP BY region_code;"
          },
          {
            "scenario": "TradeType = Physical, RegionCode不为空",
            "sql": "SELECT region_code, sum(balance) as balance FROM transit_times WHERE status = 1 AND digital = 0 AND region_code = ? GROUP BY region_code;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "RecommendationRepo",
        "code_value": "type RecommendationRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "RecommendationTableName",
        "code_value": "const RecommendationTableName = \"ivc_recommendation\""
      },
      {
        "code_key": "Recommendation",
        "code_value": "type Recommendation struct {\n\tId          int64  `gorm:\"column:id\" json:\"id\"`\n\tCategoryType int    `gorm:\"column:category_type\" json:\"category_type\"`\n\tLanguage    string `gorm:\"column:language\" json:\"language\"`\n\tPoints      int64  `gorm:\"column:points\" json:\"points\"`\n\tCreatedAt   int64  `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (r *Recommendation) TableName() string {\n\treturn RecommendationTableName\n}"
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"query\""
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"select\""
      },
      {
        "code_key": "hints",
        "code_value": "git.woa.com/IVC/ivc-event-alarm/pkg/hints"
      },
      {
        "code_key": "icontext",
        "code_value": "git.woa.com/IVC/ivc-event-alarm/pkg/icontext"
      },
      {
        "code_key": "ProductName",
        "code_value": "const ProductName = \"recommendation_service\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "AggregateByType",
    "orm_code": "func (repo *RecommendationRepo) AggregateByType(ctx context.Context, categoryType int) ([]model.Recommendation, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tvar results []model.Recommendation\n\n\tif err := repo.db.Clauses(queryClause).Table(model.RecommendationTableName).\n\t\tWhere(\"category_type = ?\", categoryType).\n\t\tGroup(\"language\").\n\t\tSelect(\"language, sum(points) as points\").\n\t\tFind(&results).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn results, nil\n}",
    "caller": "func HandleLanguagePoints(ctx context.Context, typeID int, logger *zap.Logger) (map[string]int, error) {\n\trepo := &RecommendationRepo{db: globalDB}\n\trecs, err := repo.AggregateByType(ctx, typeID)\n\tif err != nil {\n\t\tlogger.Error(\"failed to aggregate language points\", zap.Error(err))\n\t\treturn nil, err\n\t}\n\n\tpointMap := make(map[string]int)\n\tfor _, r := range recs {\n\t\tpointMap[r.Language] = r.Points\n\t}\n\treturn pointMap, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "根据category_type参数值查询并按language分组计算points总和",
            "sql": "SELECT language, sum(points) as points FROM ivc_recommendation WHERE category_type = ? GROUP BY language;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "RecommendationRepo",
        "code_value": "type RecommendationRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "RecommendationTableName",
        "code_value": "const RecommendationTableName = \"ivc_recommendation\""
      },
      {
        "code_key": "Recommendation",
        "code_value": "type Recommendation struct {\n\tId          int64  `gorm:\"column:id\" json:\"id\"`\n\tCategoryType int    `gorm:\"column:category_type\" json:\"category_type\"`\n\tLanguage    string `gorm:\"column:language\" json:\"language\"`\n\tPoints      int64  `gorm:\"column:points\" json:\"points\"`\n\tCreatedAt   int64  `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (r *Recommendation) TableName() string {\n\treturn RecommendationTableName\n}"
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"query\""
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"select\""
      },
      {
        "code_key": "hints",
        "code_value": "git.woa.com/IVC/ivc-event-alarm/pkg/hints"
      },
      {
        "code_key": "icontext",
        "code_value": "git.woa.com/IVC/ivc-event-alarm/pkg/icontext"
      },
      {
        "code_key": "ProductName",
        "code_value": "const ProductName = \"recommendation_service\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "AggregateByType",
    "orm_code": "func (repo *RecommendationRepo) AggregateByType(ctx context.Context, categoryType int) ([]model.Recommendation, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tvar results []model.Recommendation\n\n\tif err := repo.db.Clauses(queryClause).Table(model.RecommendationTableName).\n\t\tWhere(\"category_type = ?\", categoryType).\n\t\tGroup(\"language\").\n\t\tSelect(\"language, sum(points) as points\").\n\t\tFind(&results).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn results, nil\n}",
    "caller": "func ProcessContentRecommendations(ctx context.Context, contentType int) ([]model.Recommendation, error) {\n\trecommendationDB := initializeDB()\n\trepo := &RecommendationRepo{db: recommendationDB}\n\n\tresults, err := repo.AggregateByType(ctx, contentType)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"content processing failed: %w\", err)\n\t}\n\n\tif len(results) == 0 {\n\t\treturn nil, errors.New(\"no recommendations found\")\n\t}\n\treturn results, nil\n}",
    "sql_statement_list": [
      "SELECT language, sum(points) as points FROM ivc_recommendation WHERE category_type = ? GROUP BY language;"
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "RecommendationRepo",
        "code_value": "type RecommendationRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "RecommendationTableName",
        "code_value": "const RecommendationTableName = \"ivc_recommendation\""
      },
      {
        "code_key": "Recommendation",
        "code_value": "type Recommendation struct {\n\tId          int64  `gorm:\"column:id\" json:\"id\"`\n\tCategoryType int    `gorm:\"column:category_type\" json:\"category_type\"`\n\tLanguage    string `gorm:\"column:language\" json:\"language\"`\n\tPoints      int64  `gorm:\"column:points\" json:\"points\"`\n\tCreatedAt   int64  `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (r *Recommendation) TableName() string {\n\treturn RecommendationTableName\n}"
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"query\""
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"select\""
      },
      {
        "code_key": "hints",
        "code_value": "git.woa.com/IVC/ivc-event-alarm/pkg/hints"
      },
      {
        "code_key": "icontext",
        "code_value": "git.woa.com/IVC/ivc-event-alarm/pkg/icontext"
      },
      {
        "code_key": "ProductName",
        "code_value": "const ProductName = \"recommendation_service\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "AggregateByType",
    "orm_code": "func (repo *RecommendationRepo) AggregateByType(ctx context.Context, categoryType int) ([]model.Recommendation, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tvar results []model.Recommendation\n\n\tif err := repo.db.Clauses(queryClause).Table(model.RecommendationTableName).\n\t\tWhere(\"category_type = ?\", categoryType).\n\t\tGroup(\"language\").\n\t\tSelect(\"language, sum(points) as points\").\n\t\tFind(&results).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn results, nil\n}",
    "caller": "func HandleRegionBalance() ([]RegionBalance, error) {\n\tdeal := &Trade{\n\t\tTradeType:  Domestic,\n\t\tRegionCode: \"US\",\n\t}\n\t\n\tresults, err := deal.AggregateByType()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to aggregate: %v\", err)\n\t}\n\t\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Domestic交易，有RegionCode",
            "sql": "SELECT region_code, sum(balance) as balance FROM transit_times WHERE status = 1 AND domestic = 1 AND region_code = 'US' GROUP BY region_code;"
          },
          {
            "scenario": "Domestic交易，无RegionCode",
            "sql": "SELECT region_code, sum(balance) as balance FROM transit_times WHERE status = 1 AND domestic = 1 GROUP BY region_code;"
          },
          {
            "scenario": "International交易，有RegionCode",
            "sql": "SELECT region_code, sum(balance) as balance FROM transit_times WHERE status = 1 AND domestic = 0 AND region_code = ? GROUP BY region_code;"
          },
          {
            "scenario": "International交易，无RegionCode",
            "sql": "SELECT region_code, sum(balance) as balance FROM transit_times WHERE status = 1 AND domestic = 0 GROUP BY region_code;"
          },
          {
            "scenario": "Digital交易，有RegionCode",
            "sql": "SELECT region_code, sum(balance) as balance FROM transit_times WHERE status = 1 AND digital = 1 AND region_code = ? GROUP BY region_code;"
          },
          {
            "scenario": "Digital交易，无RegionCode",
            "sql": "SELECT region_code, sum(balance) as balance FROM transit_times WHERE status = 1 AND digital = 1 GROUP BY region_code;"
          },
          {
            "scenario": "Physical交易，有RegionCode",
            "sql": "SELECT region_code, sum(balance) as balance FROM transit_times WHERE status = 1 AND digital = 0 AND region_code = ? GROUP BY region_code;"
          },
          {
            "scenario": "Physical交易，无RegionCode",
            "sql": "SELECT region_code, sum(balance) as balance FROM transit_times WHERE status = 1 AND digital = 0 GROUP BY region_code;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "RecommendationRepo",
        "code_value": "type RecommendationRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "RecommendationTableName",
        "code_value": "const RecommendationTableName = \"ivc_recommendation\""
      },
      {
        "code_key": "Recommendation",
        "code_value": "type Recommendation struct {\n\tId          int64  `gorm:\"column:id\" json:\"id\"`\n\tCategoryType int    `gorm:\"column:category_type\" json:\"category_type\"`\n\tLanguage    string `gorm:\"column:language\" json:\"language\"`\n\tPoints      int64  `gorm:\"column:points\" json:\"points\"`\n\tCreatedAt   int64  `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (r *Recommendation) TableName() string {\n\treturn RecommendationTableName\n}"
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"query\""
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"select\""
      },
      {
        "code_key": "hints",
        "code_value": "git.woa.com/IVC/ivc-event-alarm/pkg/hints"
      },
      {
        "code_key": "icontext",
        "code_value": "git.woa.com/IVC/ivc-event-alarm/pkg/icontext"
      },
      {
        "code_key": "ProductName",
        "code_value": "const ProductName = \"recommendation_service\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "AggregateByType",
    "orm_code": "func (repo *RecommendationRepo) AggregateByType(ctx context.Context, categoryType int) ([]model.Recommendation, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tvar results []model.Recommendation\n\n\tif err := repo.db.Clauses(queryClause).Table(model.RecommendationTableName).\n\t\tWhere(\"category_type = ?\", categoryType).\n\t\tGroup(\"language\").\n\t\tSelect(\"language, sum(points) as points\").\n\t\tFind(&results).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn results, nil\n}",
    "caller": "func ProcessGlobalTransactions() (float64, error) {\n\tintlTrade := &Trade{\n\t\tTradeType: International,\n\t}\n\t\n\tregionBalances, err := intlTrade.AggregateByType()\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"international trade aggregation failed: %v\", err)\n\t}\n\t\n\ttotal := 0.0\n\tfor _, rb := range regionBalances {\n\t\ttotal += rb.Balance\n\t}\n\treturn total, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "国际交易类型，无特定地区代码",
            "sql": "SELECT region_code, sum(balance) as balance FROM transit_times WHERE status = 1 AND domestic = 0 GROUP BY region_code;"
          },
          {
            "scenario": "国际交易类型，有特定地区代码",
            "sql": "SELECT region_code, sum(balance) as balance FROM transit_times WHERE status = 1 AND domestic = 0 AND region_code = ? GROUP BY region_code;"
          },
          {
            "scenario": "国内交易类型，无特定地区代码",
            "sql": "SELECT region_code, sum(balance) as balance FROM transit_times WHERE status = 1 AND domestic = 1 GROUP BY region_code;"
          },
          {
            "scenario": "数字交易类型，有特定地区代码",
            "sql": "SELECT region_code, sum(balance) as balance FROM transit_times WHERE status = 1 AND digital = 1 AND region_code = ? GROUP BY region_code;"
          },
          {
            "scenario": "实体交易类型，无特定地区代码",
            "sql": "SELECT region_code, sum(balance) as balance FROM transit_times WHERE status = 1 AND digital = 0 GROUP BY region_code;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "RecommendationRepo",
        "code_value": "type RecommendationRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "RecommendationTableName",
        "code_value": "const RecommendationTableName = \"ivc_recommendation\""
      },
      {
        "code_key": "Recommendation",
        "code_value": "type Recommendation struct {\n\tId          int64  `gorm:\"column:id\" json:\"id\"`\n\tCategoryType int    `gorm:\"column:category_type\" json:\"category_type\"`\n\tLanguage    string `gorm:\"column:language\" json:\"language\"`\n\tPoints      int64  `gorm:\"column:points\" json:\"points\"`\n\tCreatedAt   int64  `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (r *Recommendation) TableName() string {\n\treturn RecommendationTableName\n}"
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"query\""
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"select\""
      },
      {
        "code_key": "hints",
        "code_value": "git.woa.com/IVC/ivc-event-alarm/pkg/hints"
      },
      {
        "code_key": "icontext",
        "code_value": "git.woa.com/IVC/ivc-event-alarm/pkg/icontext"
      },
      {
        "code_key": "ProductName",
        "code_value": "const ProductName = \"recommendation_service\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "RestoreFromBackup",
    "orm_code": "func (repo *WeaponRepo) RestoreFromBackup(ctx context.Context, item *model.Weapon) error {\n\tsaveClause := utils.SetSQLComment(ctx, utils.SaveKey)\n\tbackup := &model.Weapon{}\n\n\tif err := repo.db.Table(model.WeaponBackupTableName).\n\t\tWhere(\"security_level = ? AND genre = ?\", item.SecurityLevel, item.Genre).\n\t\tFirst(backup).Error; err != nil {\n\t\treturn fmt.Errorf(\"backup not found: %v\", err)\n\t}\n\n\tif err := repo.db.Clauses(saveClause).Table(model.WeaponTableName).\n\t\tWhere(\"id = ?\", item.Id).\n\t\tUpdates(map[string]interface{}{\n\t\t\t\"building\":       backup.Building,\n\t\t\t\"security_level\": backup.SecurityLevel,\n\t\t\t\"genre\":          backup.Genre,\n\t\t}).Error; err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
    "caller": "",
    "sql_statement_list": [
      "SELECT id, building, security_level, genre FROM armory_weapons_backup WHERE security_level = ? AND genre = ? LIMIT 1;",
      "UPDATE armory_weapons SET building = ?, security_level = ?, genre = ? WHERE id = ?;"
    ],
    "sql_types": [
      "SELECT",
      "UPDATE"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "WeaponRepo",
        "code_value": "type WeaponRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Weapon",
        "code_value": "type Weapon struct {\n\tId            int64  `gorm:\"column:id\" json:\"id\"`\n\tBuilding      string `gorm:\"column:building\" json:\"building\"`\n\tSecurityLevel int    `gorm:\"column:security_level\" json:\"security_level\"`\n\tGenre         string `gorm:\"column:genre\" json:\"genre\"`\n}"
      },
      {
        "code_key": "WeaponTableName",
        "code_value": "const WeaponTableName = \"armory_weapons\""
      },
      {
        "code_key": "WeaponBackupTableName",
        "code_value": "const WeaponBackupTableName = \"armory_weapons_backup\""
      },
      {
        "code_key": "saveClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SaveKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/armory/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Interface {\n\tcomment := icontext.GetCommentFromContext(ctx)\n\tif comment == \"\" {\n\t\tcomment = \"default_operation\"\n\t}\n\treturn clause.Comment(comment)\n}"
      },
      {
        "code_key": "backupWeapon",
        "code_value": "&model.Weapon{}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "RestoreFromBackup",
    "orm_code": "func (repo *WeaponRepo) RestoreFromBackup(ctx context.Context, item *model.Weapon) error {\n\tsaveClause := utils.SetSQLComment(ctx, utils.SaveKey)\n\tbackup := &model.Weapon{}\n\n\tif err := repo.db.Table(model.WeaponBackupTableName).\n\t\tWhere(\"security_level = ? AND genre = ?\", item.SecurityLevel, item.Genre).\n\t\tFirst(backup).Error; err != nil {\n\t\treturn fmt.Errorf(\"backup not found: %v\", err)\n\t}\n\n\tif err := repo.db.Clauses(saveClause).Table(model.WeaponTableName).\n\t\tWhere(\"id = ?\", item.Id).\n\t\tUpdates(map[string]interface{}{\n\t\t\t\"building\":       backup.Building,\n\t\t\t\"security_level\": backup.SecurityLevel,\n\t\t\t\"genre\":          backup.Genre,\n\t\t}).Error; err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
    "caller": "func HandleWeaponRecovery(ctx context.Context, weaponID string, securityLevel int, genre string, log *zap.Logger) error {\n\tweaponRepo := &WeaponRepo{db: GetDB()}\n\tweapon := &model.Weapon{\n\t\tId:            weaponID,\n\t\tSecurityLevel: securityLevel,\n\t\tGenre:         genre,\n\t}\n\n\tif err := weaponRepo.RestoreFromBackup(ctx, weapon); err != nil {\n\t\tlog.Error(\"failed to restore weapon from backup\", zap.Error(err))\n\t\treturn fmt.Errorf(\"weapon recovery failed: %v\", err)\n\t}\n\tlog.Info(\"weapon restored successfully\", zap.String(\"weaponID\", weaponID))\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "从备份表查询武器数据",
            "sql": "SELECT id, building, security_level, genre FROM armory_weapons_backup WHERE security_level = ? AND genre = ? LIMIT 1;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "更新主表武器数据",
            "sql": "UPDATE armory_weapons SET building = ?, security_level = ?, genre = ? WHERE id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "WeaponRepo",
        "code_value": "type WeaponRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Weapon",
        "code_value": "type Weapon struct {\n\tId            int64  `gorm:\"column:id\" json:\"id\"`\n\tBuilding      string `gorm:\"column:building\" json:\"building\"`\n\tSecurityLevel int    `gorm:\"column:security_level\" json:\"security_level\"`\n\tGenre         string `gorm:\"column:genre\" json:\"genre\"`\n}"
      },
      {
        "code_key": "WeaponTableName",
        "code_value": "const WeaponTableName = \"armory_weapons\""
      },
      {
        "code_key": "WeaponBackupTableName",
        "code_value": "const WeaponBackupTableName = \"armory_weapons_backup\""
      },
      {
        "code_key": "saveClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SaveKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/armory/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Interface {\n\tcomment := icontext.GetCommentFromContext(ctx)\n\tif comment == \"\" {\n\t\tcomment = \"default_operation\"\n\t}\n\treturn clause.Comment(comment)\n}"
      },
      {
        "code_key": "backupWeapon",
        "code_value": "&model.Weapon{}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "RestoreFromBackup",
    "orm_code": "func (repo *WeaponRepo) RestoreFromBackup(ctx context.Context, item *model.Weapon) error {\n\tsaveClause := utils.SetSQLComment(ctx, utils.SaveKey)\n\tbackup := &model.Weapon{}\n\n\tif err := repo.db.Table(model.WeaponBackupTableName).\n\t\tWhere(\"security_level = ? AND genre = ?\", item.SecurityLevel, item.Genre).\n\t\tFirst(backup).Error; err != nil {\n\t\treturn fmt.Errorf(\"backup not found: %v\", err)\n\t}\n\n\tif err := repo.db.Clauses(saveClause).Table(model.WeaponTableName).\n\t\tWhere(\"id = ?\", item.Id).\n\t\tUpdates(map[string]interface{}{\n\t\t\t\"building\":       backup.Building,\n\t\t\t\"security_level\": backup.SecurityLevel,\n\t\t\t\"genre\":          backup.Genre,\n\t\t}).Error; err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
    "caller": "func ProcessWeaponRestoration(ctx context.Context, weaponData *model.Weapon, dbConn *gorm.DB) (bool, error) {\n\trepo := WeaponRepo{db: dbConn}\n\n\terr := repo.RestoreFromBackup(ctx, weaponData)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"restoration process failed: %v\", err)\n\t}\n\n\treturn true, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Query backup weapon record by security_level and genre",
            "sql": "SELECT * FROM armory_weapons_backup WHERE security_level = ? AND genre = ? LIMIT 1;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Update main weapon record with backup values",
            "sql": "UPDATE armory_weapons SET building = ?, security_level = ?, genre = ? WHERE id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "WeaponRepo",
        "code_value": "type WeaponRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Weapon",
        "code_value": "type Weapon struct {\n\tId            int64  `gorm:\"column:id\" json:\"id\"`\n\tBuilding      string `gorm:\"column:building\" json:\"building\"`\n\tSecurityLevel int    `gorm:\"column:security_level\" json:\"security_level\"`\n\tGenre         string `gorm:\"column:genre\" json:\"genre\"`\n}"
      },
      {
        "code_key": "WeaponTableName",
        "code_value": "const WeaponTableName = \"armory_weapons\""
      },
      {
        "code_key": "WeaponBackupTableName",
        "code_value": "const WeaponBackupTableName = \"armory_weapons_backup\""
      },
      {
        "code_key": "saveClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SaveKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/armory/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Interface {\n\tcomment := icontext.GetCommentFromContext(ctx)\n\tif comment == \"\" {\n\t\tcomment = \"default_operation\"\n\t}\n\treturn clause.Comment(comment)\n}"
      },
      {
        "code_key": "backupWeapon",
        "code_value": "&model.Weapon{}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "RestoreFromBackup",
    "orm_code": "func (repo *WeaponRepo) RestoreFromBackup(ctx context.Context, item *model.Weapon) error {\n\tsaveClause := utils.SetSQLComment(ctx, utils.SaveKey)\n\tbackup := &model.Weapon{}\n\n\tif err := repo.db.Table(model.WeaponBackupTableName).\n\t\tWhere(\"security_level = ? AND genre = ?\", item.SecurityLevel, item.Genre).\n\t\tFirst(backup).Error; err != nil {\n\t\treturn fmt.Errorf(\"backup not found: %v\", err)\n\t}\n\n\tif err := repo.db.Clauses(saveClause).Table(model.WeaponTableName).\n\t\tWhere(\"id = ?\", item.Id).\n\t\tUpdates(map[string]interface{}{\n\t\t\t\"building\":       backup.Building,\n\t\t\t\"security_level\": backup.SecurityLevel,\n\t\t\t\"genre\":          backup.Genre,\n\t\t}).Error; err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
    "caller": "func RecoverWeaponByCriteria(ctx context.Context, criteria map[string]interface{}) error {\n\tweapon := &model.Weapon{\n\t\tSecurityLevel: criteria[\"security_level\"].(int),\n\t\tGenre:        criteria[\"genre\"].(string),\n\t}\n\n\trepo := NewWeaponRepository()\n\tif err := repo.RestoreFromBackup(ctx, weapon); err != nil {\n\t\treturn fmt.Errorf(\"could not recover weapon: %v\", err)\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "查询备份表中的武器记录",
            "sql": "SELECT * FROM armory_weapons_backup WHERE security_level = ? AND genre = ? LIMIT 1;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "更新主表中的武器记录",
            "sql": "UPDATE armory_weapons SET building = ?, security_level = ?, genre = ? WHERE id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "WeaponRepo",
        "code_value": "type WeaponRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Weapon",
        "code_value": "type Weapon struct {\n\tId            int64  `gorm:\"column:id\" json:\"id\"`\n\tBuilding      string `gorm:\"column:building\" json:\"building\"`\n\tSecurityLevel int    `gorm:\"column:security_level\" json:\"security_level\"`\n\tGenre         string `gorm:\"column:genre\" json:\"genre\"`\n}"
      },
      {
        "code_key": "WeaponTableName",
        "code_value": "const WeaponTableName = \"armory_weapons\""
      },
      {
        "code_key": "WeaponBackupTableName",
        "code_value": "const WeaponBackupTableName = \"armory_weapons_backup\""
      },
      {
        "code_key": "saveClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SaveKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/armory/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Interface {\n\tcomment := icontext.GetCommentFromContext(ctx)\n\tif comment == \"\" {\n\t\tcomment = \"default_operation\"\n\t}\n\treturn clause.Comment(comment)\n}"
      },
      {
        "code_key": "backupWeapon",
        "code_value": "&model.Weapon{}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "FetchWithFilter",
    "orm_code": "func (repo *ClientRepo) FetchWithFilter(ctx context.Context, projectCode string) ([]*model.Client, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tvar clients []*model.Client\n\n\tif err := repo.db.Clauses(queryClause).Table(model.ClientTableName).\n\t\tWhere(\"project_code = ?\", projectCode).\n\t\tWhere(\"status = ?\", model.ClientStatusActive).\n\t\tFind(&clients).Error; err != nil {\n\t\t\treturn nil, err\n\t}\n\n\treturn clients, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "ZoneId > 0, ProjectCode非空, Status = Active",
            "sql": "SELECT id, zone_id, project_code, active, archived, created_at FROM department_structure WHERE zone_id = ? AND project_code = ? AND active = 1 ORDER BY created_at DESC;"
          },
          {
            "scenario": "ZoneId > 0, ProjectCode为空, Status = Inactive",
            "sql": "SELECT id, zone_id, project_code, active, archived, created_at FROM department_structure WHERE zone_id = ? AND active = 0 ORDER BY created_at DESC;"
          },
          {
            "scenario": "ZoneId <= 0, ProjectCode非空, Status = Archived",
            "sql": "SELECT id, zone_id, project_code, active, archived, created_at FROM department_structure WHERE project_code = ? AND archived = 1 ORDER BY created_at DESC;"
          },
          {
            "scenario": "ZoneId <= 0, ProjectCode为空, Status = Active",
            "sql": "SELECT id, zone_id, project_code, active, archived, created_at FROM department_structure WHERE active = 1 ORDER BY created_at DESC;"
          },
          {
            "scenario": "ZoneId > 0, ProjectCode非空, Status = Archived",
            "sql": "SELECT id, zone_id, project_code, active, archived, created_at FROM department_structure WHERE zone_id = ? AND project_code = ? AND archived = 1 ORDER BY created_at DESC;"
          },
          {
            "scenario": "ZoneId > 0, ProjectCode为空, Status = Archived",
            "sql": "SELECT id, zone_id, project_code, active, archived, created_at FROM department_structure WHERE zone_id = ? AND archived = 1 ORDER BY created_at DESC;"
          },
          {
            "scenario": "ZoneId <= 0, ProjectCode非空, Status = Active",
            "sql": "SELECT id, zone_id, project_code, active, archived, created_at FROM department_structure WHERE project_code = ? AND active = 1 ORDER BY created_at DESC;"
          },
          {
            "scenario": "ZoneId <= 0, ProjectCode非空, Status = Inactive",
            "sql": "SELECT id, zone_id, project_code, active, archived, created_at FROM department_structure WHERE project_code = ? AND active = 0 ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ProjectLevelRepo",
        "code_value": "type ProjectLevelRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ProjectManifestTableName",
        "code_value": "const ProjectManifestTableName = \"project_manifests\""
      },
      {
        "code_key": "ProjectStatusActive",
        "code_value": "const ProjectStatusActive = 2"
      },
      {
        "code_key": "ProjectManifest",
        "code_value": "type ProjectManifest struct {\n\tID          int64  `gorm:\"column:id\" json:\"id\"`\n\tProjectCode string `gorm:\"column:project_code\" json:\"project_code\"`\n\tStatus      int    `gorm:\"column:status\" json:\"status\"`\n\tCategory    string `gorm:\"column:category\" json:\"category\"`\n\tCreatedAt   int64  `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "QueryBuilder",
        "code_value": "type QueryBuilder struct {\n\tClause string\n\tParams []interface{}\n}"
      },
      {
        "code_key": "DefaultQueryLimit",
        "code_value": "const DefaultQueryLimit = 100"
      },
      {
        "code_key": "ProjectCategoryTech",
        "code_value": "const ProjectCategoryTech = \"technology\""
      },
      {
        "code_key": "ProjectCategoryBusiness",
        "code_value": "const ProjectCategoryBusiness = \"business\""
      },
      {
        "code_key": "ManifestVersion",
        "code_value": "type ManifestVersion struct {\n\tMajor int `json:\"major\"`\n\tMinor int `json:\"minor\"`\n\tPatch int `json:\"patch\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (pm *ProjectManifest) TableName() string {\n\treturn ProjectManifestTableName\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "FetchWithFilter",
    "orm_code": "func (repo *ClientRepo) FetchWithFilter(ctx context.Context, projectCode string) ([]*model.Client, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tvar clients []*model.Client\n\n\tif err := repo.db.Clauses(queryClause).Table(model.ClientTableName).\n\t\tWhere(\"project_code = ?\", projectCode).\n\t\tWhere(\"status = ?\", model.ClientStatusActive).\n\t\tFind(&clients).Error; err != nil {\n\t\t\treturn nil, err\n\t}\n\n\treturn clients, nil\n}",
    "caller": "func HandleActiveClients(ctx context.Context, projectIdentifier string, logger *zap.Logger) ([]*model.Client, error) {\n\tclientStorage := &ClientRepo{db: database.GetDB()}\n\tactiveClients, err := clientStorage.FetchWithFilter(ctx, projectIdentifier)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to fetch active clients\", zap.String(\"project\", projectIdentifier), zap.Error(err))\n\t\treturn nil, fmt.Errorf(\"failed to fetch active clients: %w\", err)\n\t}\n\treturn activeClients, nil\n}",
    "sql_statement_list": [
      {
        "type": "LACK_INFORMATION",
        "variants": [
          {
            "scenario": "缺少model.ClientTableName常量的定义，表名无法确定",
            "sql": "SELECT * FROM clients WHERE project_code = ? AND status = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ProjectLevelRepo",
        "code_value": "type ProjectLevelRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ProjectManifestTableName",
        "code_value": "const ProjectManifestTableName = \"project_manifests\""
      },
      {
        "code_key": "ProjectStatusActive",
        "code_value": "const ProjectStatusActive = 2"
      },
      {
        "code_key": "ProjectManifest",
        "code_value": "type ProjectManifest struct {\n\tID          int64  `gorm:\"column:id\" json:\"id\"`\n\tProjectCode string `gorm:\"column:project_code\" json:\"project_code\"`\n\tStatus      int    `gorm:\"column:status\" json:\"status\"`\n\tCategory    string `gorm:\"column:category\" json:\"category\"`\n\tCreatedAt   int64  `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "QueryBuilder",
        "code_value": "type QueryBuilder struct {\n\tClause string\n\tParams []interface{}\n}"
      },
      {
        "code_key": "DefaultQueryLimit",
        "code_value": "const DefaultQueryLimit = 100"
      },
      {
        "code_key": "ProjectCategoryTech",
        "code_value": "const ProjectCategoryTech = \"technology\""
      },
      {
        "code_key": "ProjectCategoryBusiness",
        "code_value": "const ProjectCategoryBusiness = \"business\""
      },
      {
        "code_key": "ManifestVersion",
        "code_value": "type ManifestVersion struct {\n\tMajor int `json:\"major\"`\n\tMinor int `json:\"minor\"`\n\tPatch int `json:\"patch\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (pm *ProjectManifest) TableName() string {\n\treturn ProjectManifestTableName\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "FetchWithFilter",
    "orm_code": "func (repo *ClientRepo) FetchWithFilter(ctx context.Context, projectCode string) ([]*model.Client, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tvar clients []*model.Client\n\n\tif err := repo.db.Clauses(queryClause).Table(model.ClientTableName).\n\t\tWhere(\"project_code = ?\", projectCode).\n\t\tWhere(\"status = ?\", model.ClientStatusActive).\n\t\tFind(&clients).Error; err != nil {\n\t\t\treturn nil, err\n\t}\n\n\treturn clients, nil\n}",
    "caller": "func ProcessProjectClients(ctx context.Context, projectList []string) (map[string][]*model.Client, error) {\n\tresult := make(map[string][]*model.Client)\n\trepository := &ClientRepo{db: config.GetDatabaseConnection()}\n\n\tfor _, projCode := range projectList {\n\t\tclients, err := repository.FetchWithFilter(ctx, projCode)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to process project %s: %w\", projCode, err)\n\t\t}\n\t\tresult[projCode] = clients\n\t}\n\n\treturn result, nil\n}",
    "sql_statement_list": [
      {
        "type": "LACK_INFORMATION",
        "variants": [
          {
            "scenario": "缺少model.ClientTableName定义，根据结构体名称推测表名为clients",
            "sql": "SELECT * FROM clients WHERE project_code = ? AND status = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ProjectLevelRepo",
        "code_value": "type ProjectLevelRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ProjectManifestTableName",
        "code_value": "const ProjectManifestTableName = \"project_manifests\""
      },
      {
        "code_key": "ProjectStatusActive",
        "code_value": "const ProjectStatusActive = 2"
      },
      {
        "code_key": "ProjectManifest",
        "code_value": "type ProjectManifest struct {\n\tID          int64  `gorm:\"column:id\" json:\"id\"`\n\tProjectCode string `gorm:\"column:project_code\" json:\"project_code\"`\n\tStatus      int    `gorm:\"column:status\" json:\"status\"`\n\tCategory    string `gorm:\"column:category\" json:\"category\"`\n\tCreatedAt   int64  `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "QueryBuilder",
        "code_value": "type QueryBuilder struct {\n\tClause string\n\tParams []interface{}\n}"
      },
      {
        "code_key": "DefaultQueryLimit",
        "code_value": "const DefaultQueryLimit = 100"
      },
      {
        "code_key": "ProjectCategoryTech",
        "code_value": "const ProjectCategoryTech = \"technology\""
      },
      {
        "code_key": "ProjectCategoryBusiness",
        "code_value": "const ProjectCategoryBusiness = \"business\""
      },
      {
        "code_key": "ManifestVersion",
        "code_value": "type ManifestVersion struct {\n\tMajor int `json:\"major\"`\n\tMinor int `json:\"minor\"`\n\tPatch int `json:\"patch\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (pm *ProjectManifest) TableName() string {\n\treturn ProjectManifestTableName\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "FetchWithFilter",
    "orm_code": "func (repo *ClientRepo) FetchWithFilter(ctx context.Context, projectCode string) ([]*model.Client, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tvar clients []*model.Client\n\n\tif err := repo.db.Clauses(queryClause).Table(model.ClientTableName).\n\t\tWhere(\"project_code = ?\", projectCode).\n\t\tWhere(\"status = ?\", model.ClientStatusActive).\n\t\tFind(&clients).Error; err != nil {\n\t\t\treturn nil, err\n\t}\n\n\treturn clients, nil\n}",
    "caller": "func SyncClientData(ctx context.Context, targetProject string, cacheClient cache.Provider) error {\n\tdbHandler := &ClientRepo{db: global.DBInstance}\n\tfilteredClients, err := dbHandler.FetchWithFilter(ctx, targetProject)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"database fetch failed: %w\", err)\n\t}\n\n\tcacheKey := fmt.Sprintf(\"active_clients:%s\", targetProject)\n\tif err := cacheClient.Set(ctx, cacheKey, filteredClients, 24*time.Hour); err != nil {\n\t\treturn fmt.Errorf(\"cache update failed: %w\", err)\n\t}\n\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "LACK_INFORMATION",
        "variants": [
          {
            "scenario": "缺少model.Client结构定义和ClientStatusActive常量值",
            "sql": "SELECT * FROM clients WHERE project_code = ? AND status = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ProjectLevelRepo",
        "code_value": "type ProjectLevelRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ProjectManifestTableName",
        "code_value": "const ProjectManifestTableName = \"project_manifests\""
      },
      {
        "code_key": "ProjectStatusActive",
        "code_value": "const ProjectStatusActive = 2"
      },
      {
        "code_key": "ProjectManifest",
        "code_value": "type ProjectManifest struct {\n\tID          int64  `gorm:\"column:id\" json:\"id\"`\n\tProjectCode string `gorm:\"column:project_code\" json:\"project_code\"`\n\tStatus      int    `gorm:\"column:status\" json:\"status\"`\n\tCategory    string `gorm:\"column:category\" json:\"category\"`\n\tCreatedAt   int64  `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "QueryBuilder",
        "code_value": "type QueryBuilder struct {\n\tClause string\n\tParams []interface{}\n}"
      },
      {
        "code_key": "DefaultQueryLimit",
        "code_value": "const DefaultQueryLimit = 100"
      },
      {
        "code_key": "ProjectCategoryTech",
        "code_value": "const ProjectCategoryTech = \"technology\""
      },
      {
        "code_key": "ProjectCategoryBusiness",
        "code_value": "const ProjectCategoryBusiness = \"business\""
      },
      {
        "code_key": "ManifestVersion",
        "code_value": "type ManifestVersion struct {\n\tMajor int `json:\"major\"`\n\tMinor int `json:\"minor\"`\n\tPatch int `json:\"patch\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (pm *ProjectManifest) TableName() string {\n\treturn ProjectManifestTableName\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "FetchWithFilter",
    "orm_code": "func (repo *ClientRepo) FetchWithFilter(ctx context.Context, projectCode string) ([]*model.Client, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tvar clients []*model.Client\n\n\tif err := repo.db.Clauses(queryClause).Table(model.ClientTableName).\n\t\tWhere(\"project_code = ?\", projectCode).\n\t\tWhere(\"status = ?\", model.ClientStatusActive).\n\t\tFind(&clients).Error; err != nil {\n\t\t\treturn nil, err\n\t}\n\n\treturn clients, nil\n}",
    "caller": "func HandleActiveProjects(zoneID int, projectCode string) ([]Item, error) {\n\tgps := &GPS{\n\t\tZoneId:      zoneID,\n\t\tProjectCode: projectCode,\n\t\tStatus:      Active,\n\t}\n\tresults, err := gps.FetchWithFilter()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to fetch active projects: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "zoneID > 0 and projectCode not empty",
            "sql": "SELECT id, zone_id, project_code, active, archived, created_at FROM department_structure WHERE zone_id = ? AND project_code = ? AND active = 1 ORDER BY created_at DESC;"
          },
          {
            "scenario": "zoneID > 0 and projectCode empty",
            "sql": "SELECT id, zone_id, project_code, active, archived, created_at FROM department_structure WHERE zone_id = ? AND active = 1 ORDER BY created_at DESC;"
          },
          {
            "scenario": "zoneID = 0 and projectCode not empty",
            "sql": "SELECT id, zone_id, project_code, active, archived, created_at FROM department_structure WHERE project_code = ? AND active = 1 ORDER BY created_at DESC;"
          },
          {
            "scenario": "zoneID = 0 and projectCode empty",
            "sql": "SELECT id, zone_id, project_code, active, archived, created_at FROM department_structure WHERE active = 1 ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ProjectLevelRepo",
        "code_value": "type ProjectLevelRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ProjectManifestTableName",
        "code_value": "const ProjectManifestTableName = \"project_manifests\""
      },
      {
        "code_key": "ProjectStatusActive",
        "code_value": "const ProjectStatusActive = 2"
      },
      {
        "code_key": "ProjectManifest",
        "code_value": "type ProjectManifest struct {\n\tID          int64  `gorm:\"column:id\" json:\"id\"`\n\tProjectCode string `gorm:\"column:project_code\" json:\"project_code\"`\n\tStatus      int    `gorm:\"column:status\" json:\"status\"`\n\tCategory    string `gorm:\"column:category\" json:\"category\"`\n\tCreatedAt   int64  `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "QueryBuilder",
        "code_value": "type QueryBuilder struct {\n\tClause string\n\tParams []interface{}\n}"
      },
      {
        "code_key": "DefaultQueryLimit",
        "code_value": "const DefaultQueryLimit = 100"
      },
      {
        "code_key": "ProjectCategoryTech",
        "code_value": "const ProjectCategoryTech = \"technology\""
      },
      {
        "code_key": "ProjectCategoryBusiness",
        "code_value": "const ProjectCategoryBusiness = \"business\""
      },
      {
        "code_key": "ManifestVersion",
        "code_value": "type ManifestVersion struct {\n\tMajor int `json:\"major\"`\n\tMinor int `json:\"minor\"`\n\tPatch int `json:\"patch\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (pm *ProjectManifest) TableName() string {\n\treturn ProjectManifestTableName\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "FetchWithFilter",
    "orm_code": "func (repo *ClientRepo) FetchWithFilter(ctx context.Context, projectCode string) ([]*model.Client, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tvar clients []*model.Client\n\n\tif err := repo.db.Clauses(queryClause).Table(model.ClientTableName).\n\t\tWhere(\"project_code = ?\", projectCode).\n\t\tWhere(\"status = ?\", model.ClientStatusActive).\n\t\tFind(&clients).Error; err != nil {\n\t\t\treturn nil, err\n\t}\n\n\treturn clients, nil\n}",
    "caller": "func HandleArchivedStructures() ([]Item, error) {\n\tgps := &GPS{\n\t\tStatus: Archived,\n\t}\n\tstructures, err := gps.FetchWithFilter()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to retrieve archived structures: %v\", err)\n\t\treturn nil, fmt.Errorf(\"archive query failed\")\n\t}\n\treturn structures, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Status=Archived without ZoneId and ProjectCode",
            "sql": "SELECT * FROM department_structure WHERE archived = 1 ORDER BY created_at DESC;"
          },
          {
            "scenario": "Status=Active with ZoneId",
            "sql": "SELECT * FROM department_structure WHERE zone_id = ? AND active = 1 ORDER BY created_at DESC;"
          },
          {
            "scenario": "Status=Inactive with ProjectCode",
            "sql": "SELECT * FROM department_structure WHERE project_code = ? AND active = 0 ORDER BY created_at DESC;"
          },
          {
            "scenario": "Status=Archived with both ZoneId and ProjectCode",
            "sql": "SELECT * FROM department_structure WHERE zone_id = ? AND project_code = ? AND archived = 1 ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ProjectLevelRepo",
        "code_value": "type ProjectLevelRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ProjectManifestTableName",
        "code_value": "const ProjectManifestTableName = \"project_manifests\""
      },
      {
        "code_key": "ProjectStatusActive",
        "code_value": "const ProjectStatusActive = 2"
      },
      {
        "code_key": "ProjectManifest",
        "code_value": "type ProjectManifest struct {\n\tID          int64  `gorm:\"column:id\" json:\"id\"`\n\tProjectCode string `gorm:\"column:project_code\" json:\"project_code\"`\n\tStatus      int    `gorm:\"column:status\" json:\"status\"`\n\tCategory    string `gorm:\"column:category\" json:\"category\"`\n\tCreatedAt   int64  `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "QueryBuilder",
        "code_value": "type QueryBuilder struct {\n\tClause string\n\tParams []interface{}\n}"
      },
      {
        "code_key": "DefaultQueryLimit",
        "code_value": "const DefaultQueryLimit = 100"
      },
      {
        "code_key": "ProjectCategoryTech",
        "code_value": "const ProjectCategoryTech = \"technology\""
      },
      {
        "code_key": "ProjectCategoryBusiness",
        "code_value": "const ProjectCategoryBusiness = \"business\""
      },
      {
        "code_key": "ManifestVersion",
        "code_value": "type ManifestVersion struct {\n\tMajor int `json:\"major\"`\n\tMinor int `json:\"minor\"`\n\tPatch int `json:\"patch\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (pm *ProjectManifest) TableName() string {\n\treturn ProjectManifestTableName\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "FetchWithFilter",
    "orm_code": "func (repo *ClientRepo) FetchWithFilter(ctx context.Context, projectCode string) ([]*model.Client, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tvar clients []*model.Client\n\n\tif err := repo.db.Clauses(queryClause).Table(model.ClientTableName).\n\t\tWhere(\"project_code = ?\", projectCode).\n\t\tWhere(\"status = ?\", model.ClientStatusActive).\n\t\tFind(&clients).Error; err != nil {\n\t\t\treturn nil, err\n\t}\n\n\treturn clients, nil\n}",
    "caller": "func HandleZoneInactiveItems(zoneID int) ([]Item, error) {\n\tgps := &GPS{\n\t\tZoneId: zoneID,\n\t\tStatus: Inactive,\n\t}\n\titems, err := gps.FetchWithFilter()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"inactive items query failed for zone %d: %w\", zoneID, err)\n\t}\n\treturn items, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Status=Inactive (from caller), ZoneId set, ProjectCode not set",
            "sql": "SELECT id, zone_id, project_code, active, archived, created_at FROM department_structure WHERE zone_id = ? AND active = 0 ORDER BY created_at DESC;"
          },
          {
            "scenario": "Status=Active, ZoneId set, ProjectCode not set",
            "sql": "SELECT id, zone_id, project_code, active, archived, created_at FROM department_structure WHERE zone_id = ? AND active = 1 ORDER BY created_at DESC;"
          },
          {
            "scenario": "Status=Archived, ZoneId set, ProjectCode not set",
            "sql": "SELECT id, zone_id, project_code, active, archived, created_at FROM department_structure WHERE zone_id = ? AND archived = 1 ORDER BY created_at DESC;"
          },
          {
            "scenario": "Status=Inactive, ZoneId set, ProjectCode set",
            "sql": "SELECT id, zone_id, project_code, active, archived, created_at FROM department_structure WHERE zone_id = ? AND project_code = ? AND active = 0 ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ProjectLevelRepo",
        "code_value": "type ProjectLevelRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ProjectManifestTableName",
        "code_value": "const ProjectManifestTableName = \"project_manifests\""
      },
      {
        "code_key": "ProjectStatusActive",
        "code_value": "const ProjectStatusActive = 2"
      },
      {
        "code_key": "ProjectManifest",
        "code_value": "type ProjectManifest struct {\n\tID          int64  `gorm:\"column:id\" json:\"id\"`\n\tProjectCode string `gorm:\"column:project_code\" json:\"project_code\"`\n\tStatus      int    `gorm:\"column:status\" json:\"status\"`\n\tCategory    string `gorm:\"column:category\" json:\"category\"`\n\tCreatedAt   int64  `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "QueryBuilder",
        "code_value": "type QueryBuilder struct {\n\tClause string\n\tParams []interface{}\n}"
      },
      {
        "code_key": "DefaultQueryLimit",
        "code_value": "const DefaultQueryLimit = 100"
      },
      {
        "code_key": "ProjectCategoryTech",
        "code_value": "const ProjectCategoryTech = \"technology\""
      },
      {
        "code_key": "ProjectCategoryBusiness",
        "code_value": "const ProjectCategoryBusiness = \"business\""
      },
      {
        "code_key": "ManifestVersion",
        "code_value": "type ManifestVersion struct {\n\tMajor int `json:\"major\"`\n\tMinor int `json:\"minor\"`\n\tPatch int `json:\"patch\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (pm *ProjectManifest) TableName() string {\n\treturn ProjectManifestTableName\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "RetrieveByDate",
    "orm_code": "func (repo *TaskRepo) RetrieveByDate(ctx context.Context, startDate, endDate int64) ([]*model.Task, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\ttasks := make([]*model.Task, 0)\n\n\tif err := repo.db.Clauses(queryClause).Table(model.TaskTableName).\n\t\tWhere(\"created_at BETWEEN ? AND ?\", startDate, endDate).\n\t\tOrder(\"created_at DESC\").\n\t\tFind(&tasks).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn tasks, nil\n}",
    "caller": "",
    "sql_statement_list": [
      "SELECT id, name, status, created_at, updated_at FROM user_tasks WHERE created_at BETWEEN ? AND ? ORDER BY created_at DESC;"
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "TaskRepo",
        "code_value": "type TaskRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Task",
        "code_value": "type Task struct {\n\tID        int64  `gorm:\"column:id\" json:\"id\"`\n\tName      string `gorm:\"column:name\" json:\"name\"`\n\tStatus    int    `gorm:\"column:status\" json:\"status\"`\n\tCreatedAt int64  `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt int64  `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "TaskTableName",
        "code_value": "const TaskTableName = \"user_tasks\""
      },
      {
        "code_key": "TaskStatusPending",
        "code_value": "const TaskStatusPending = 1"
      },
      {
        "code_key": "TaskStatusCompleted",
        "code_value": "const TaskStatusCompleted = 2"
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"SELECT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (t *Task) TableName() string {\n\treturn TaskTableName\n}"
      },
      {
        "code_key": "defaultTask",
        "code_value": "var defaultTask = &Task{Status: TaskStatusPending}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "RetrieveByDate",
    "orm_code": "func (repo *TaskRepo) RetrieveByDate(ctx context.Context, startDate, endDate int64) ([]*model.Task, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\ttasks := make([]*model.Task, 0)\n\n\tif err := repo.db.Clauses(queryClause).Table(model.TaskTableName).\n\t\tWhere(\"created_at BETWEEN ? AND ?\", startDate, endDate).\n\t\tOrder(\"created_at DESC\").\n\t\tFind(&tasks).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn tasks, nil\n}",
    "caller": "func HandleTaskReport(ctx context.Context, log *zap.Logger) error {\n\trepo := &TaskRepo{db: conf.GetDBEngine()}\n\tnow := time.Now().Unix()\n\tstartTime := now - 86400 // last 24 hours\n\n\ttasks, err := repo.RetrieveByDate(ctx, startTime, now)\n\tif err != nil {\n\t\tlog.Error(\"failed to retrieve tasks\", zap.Error(err))\n\t\treturn err\n\t}\n\n\tif len(tasks) == 0 {\n\t\tlog.Info(\"no tasks found in the given period\")\n\t\treturn nil\n\t}\n\n\t// Process tasks...\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "查询在指定日期范围内创建的任务，按创建时间降序排列",
            "sql": "SELECT * FROM user_tasks WHERE created_at BETWEEN ? AND ? ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "TaskRepo",
        "code_value": "type TaskRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Task",
        "code_value": "type Task struct {\n\tID        int64  `gorm:\"column:id\" json:\"id\"`\n\tName      string `gorm:\"column:name\" json:\"name\"`\n\tStatus    int    `gorm:\"column:status\" json:\"status\"`\n\tCreatedAt int64  `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt int64  `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "TaskTableName",
        "code_value": "const TaskTableName = \"user_tasks\""
      },
      {
        "code_key": "TaskStatusPending",
        "code_value": "const TaskStatusPending = 1"
      },
      {
        "code_key": "TaskStatusCompleted",
        "code_value": "const TaskStatusCompleted = 2"
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"SELECT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (t *Task) TableName() string {\n\treturn TaskTableName\n}"
      },
      {
        "code_key": "defaultTask",
        "code_value": "var defaultTask = &Task{Status: TaskStatusPending}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "RetrieveByDate",
    "orm_code": "func (repo *TaskRepo) RetrieveByDate(ctx context.Context, startDate, endDate int64) ([]*model.Task, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\ttasks := make([]*model.Task, 0)\n\n\tif err := repo.db.Clauses(queryClause).Table(model.TaskTableName).\n\t\tWhere(\"created_at BETWEEN ? AND ?\", startDate, endDate).\n\t\tOrder(\"created_at DESC\").\n\t\tFind(&tasks).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn tasks, nil\n}",
    "caller": "func HandleArchiveExpiredTasks(ctx context.Context, retentionDays int) (int, error) {\n\trepo := &TaskRepo{db: conf.GetDBEngine()}\n\tendTime := time.Now().AddDate(0, 0, -retentionDays).Unix()\n\n\texpiredTasks, err := repo.RetrieveByDate(ctx, 0, endTime)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to get expired tasks: %w\", err)\n\t}\n\n\t// Archive tasks...\n\treturn len(expiredTasks), nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Retrieve tasks between startDate and endDate",
            "sql": "SELECT id, name, status, created_at, updated_at FROM user_tasks WHERE created_at BETWEEN ? AND ? ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "TaskRepo",
        "code_value": "type TaskRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Task",
        "code_value": "type Task struct {\n\tID        int64  `gorm:\"column:id\" json:\"id\"`\n\tName      string `gorm:\"column:name\" json:\"name\"`\n\tStatus    int    `gorm:\"column:status\" json:\"status\"`\n\tCreatedAt int64  `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt int64  `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "TaskTableName",
        "code_value": "const TaskTableName = \"user_tasks\""
      },
      {
        "code_key": "TaskStatusPending",
        "code_value": "const TaskStatusPending = 1"
      },
      {
        "code_key": "TaskStatusCompleted",
        "code_value": "const TaskStatusCompleted = 2"
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"SELECT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (t *Task) TableName() string {\n\treturn TaskTableName\n}"
      },
      {
        "code_key": "defaultTask",
        "code_value": "var defaultTask = &Task{Status: TaskStatusPending}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "GroupByCategory",
    "orm_code": "func (repo *ScannerRepo) GroupByCategory(ctx context.Context, pattern string) (map[string][]*model.Publication, error) {\n\tcategoryClause := utils.SetSQLComment(ctx, utils.GroupKey)\n\tresults := make([]*model.Publication, 0)\n\tcategoryMap := make(map[string][]*model.Publication)\n\n\tif err := repo.db.Clauses(categoryClause).Table(model.PublicationTableName).\n\t\tWhere(\"unique_key LIKE ?\", pattern).\n\t\tFind(&results).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, pub := range results {\n\t\tcategoryMap[pub.RoleCode] = append(categoryMap[pub.RoleCode], pub)\n\t}\n\n\treturn categoryMap, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "ApprovalLevel = 1 (Prescription)",
            "sql": "SELECT category, count(*) as total FROM payment_records WHERE zone = ? AND category = 'Prescription' GROUP BY category;"
          },
          {
            "scenario": "ApprovalLevel = 2 (OTC)",
            "sql": "SELECT category, count(*) as total FROM payment_records WHERE zone = ? AND category = 'OTC' GROUP BY category;"
          },
          {
            "scenario": "ApprovalLevel = 3 (Restricted)",
            "sql": "SELECT category, count(*) as total FROM payment_records WHERE zone IN (?, 'Special') AND category = 'Restricted' GROUP BY category;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PatientRepo",
        "code_value": "type PatientRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "MedicalRecordTableName",
        "code_value": "const MedicalRecordTableName = \"hospital_medical_records\""
      },
      {
        "code_key": "MedicalRecord",
        "code_value": "type MedicalRecord struct {\n\tRecordID    int64  `gorm:\"column:record_id\" json:\"record_id\"`\n\tPatientID   string `gorm:\"column:patient_id\" json:\"patient_id\"`\n\tDiagnosis   string `gorm:\"column:diagnosis\" json:\"diagnosis\"`\n\tDoctorID    string `gorm:\"column:doctor_id\" json:\"doctor_id\"`\n\tRecordDate  int64  `gorm:\"column:record_date\" json:\"record_date\"`\n\tIsCritical  bool   `gorm:\"column:is_critical\" json:\"is_critical\"`\n}"
      },
      {
        "code_key": "searchClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SearchKey)"
      },
      {
        "code_key": "medUtils",
        "code_value": "git.woa.com/Medical/health-record/pkg/medUtils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, operation string) hints.Hints {\n\tctxInfo := medcontext.GetMedContextFromContext(ctx)\n\tif len(ctxInfo.SessionID) < 10 {\n\t\tctxInfo.SessionID = uuid.New().String()[:8]\n\t}\n\n\tcomment := fmt.Sprintf(\"h=%v,d=%v,p=%v,s=%v\", HospitalID,\n\t\tctxInfo.Department, ctxInfo.PhysicianID, ctxInfo.SessionID)\n\treturn hints.CommentBefore(operation, comment)\n}"
      },
      {
        "code_key": "HospitalID",
        "code_value": "const HospitalID = \"GH12345\""
      },
      {
        "code_key": "PatientRecord",
        "code_value": "&model.MedicalRecord{}"
      },
      {
        "code_key": "CriticalStatus",
        "code_value": "const CriticalStatus = true"
      },
      {
        "code_key": "DepartmentCodes",
        "code_value": "var DepartmentCodes = map[string]int{\n\t\"Cardiology\":    1,\n\t\"Neurology\":     2,\n\t\"Orthopedics\":   3,\n\t\"Pediatrics\":    4,\n\t\"Dermatology\":   5\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "GroupByCategory",
    "orm_code": "func (repo *ScannerRepo) GroupByCategory(ctx context.Context, pattern string) (map[string][]*model.Publication, error) {\n\tcategoryClause := utils.SetSQLComment(ctx, utils.GroupKey)\n\tresults := make([]*model.Publication, 0)\n\tcategoryMap := make(map[string][]*model.Publication)\n\n\tif err := repo.db.Clauses(categoryClause).Table(model.PublicationTableName).\n\t\tWhere(\"unique_key LIKE ?\", pattern).\n\t\tFind(&results).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, pub := range results {\n\t\tcategoryMap[pub.RoleCode] = append(categoryMap[pub.RoleCode], pub)\n\t}\n\n\treturn categoryMap, nil\n}",
    "caller": "func HandlePublicationGrouping(db *gorm.DB, ctx context.Context) (map[string][]*model.Publication, error) {\n\tscannerRepo := &ScannerRepo{db: db}\n\tpattern := \"user-%\"\n\t\n\tgroupedPubs, err := scannerRepo.GroupByCategory(ctx, pattern)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to group publications: %v\", err)\n\t}\n\t\n\treturn groupedPubs, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Default query with LIKE condition and SQL comment",
            "sql": "/* h=GH12345,d=,p=,s=[generated-session-id] */ SELECT * FROM publications WHERE unique_key LIKE 'user-%';"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PatientRepo",
        "code_value": "type PatientRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "MedicalRecordTableName",
        "code_value": "const MedicalRecordTableName = \"hospital_medical_records\""
      },
      {
        "code_key": "MedicalRecord",
        "code_value": "type MedicalRecord struct {\n\tRecordID    int64  `gorm:\"column:record_id\" json:\"record_id\"`\n\tPatientID   string `gorm:\"column:patient_id\" json:\"patient_id\"`\n\tDiagnosis   string `gorm:\"column:diagnosis\" json:\"diagnosis\"`\n\tDoctorID    string `gorm:\"column:doctor_id\" json:\"doctor_id\"`\n\tRecordDate  int64  `gorm:\"column:record_date\" json:\"record_date\"`\n\tIsCritical  bool   `gorm:\"column:is_critical\" json:\"is_critical\"`\n}"
      },
      {
        "code_key": "searchClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SearchKey)"
      },
      {
        "code_key": "medUtils",
        "code_value": "git.woa.com/Medical/health-record/pkg/medUtils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, operation string) hints.Hints {\n\tctxInfo := medcontext.GetMedContextFromContext(ctx)\n\tif len(ctxInfo.SessionID) < 10 {\n\t\tctxInfo.SessionID = uuid.New().String()[:8]\n\t}\n\n\tcomment := fmt.Sprintf(\"h=%v,d=%v,p=%v,s=%v\", HospitalID,\n\t\tctxInfo.Department, ctxInfo.PhysicianID, ctxInfo.SessionID)\n\treturn hints.CommentBefore(operation, comment)\n}"
      },
      {
        "code_key": "HospitalID",
        "code_value": "const HospitalID = \"GH12345\""
      },
      {
        "code_key": "PatientRecord",
        "code_value": "&model.MedicalRecord{}"
      },
      {
        "code_key": "CriticalStatus",
        "code_value": "const CriticalStatus = true"
      },
      {
        "code_key": "DepartmentCodes",
        "code_value": "var DepartmentCodes = map[string]int{\n\t\"Cardiology\":    1,\n\t\"Neurology\":     2,\n\t\"Orthopedics\":   3,\n\t\"Pediatrics\":    4,\n\t\"Dermatology\":   5\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "GroupByCategory",
    "orm_code": "func (repo *ScannerRepo) GroupByCategory(ctx context.Context, pattern string) (map[string][]*model.Publication, error) {\n\tcategoryClause := utils.SetSQLComment(ctx, utils.GroupKey)\n\tresults := make([]*model.Publication, 0)\n\tcategoryMap := make(map[string][]*model.Publication)\n\n\tif err := repo.db.Clauses(categoryClause).Table(model.PublicationTableName).\n\t\tWhere(\"unique_key LIKE ?\", pattern).\n\t\tFind(&results).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, pub := range results {\n\t\tcategoryMap[pub.RoleCode] = append(categoryMap[pub.RoleCode], pub)\n\t}\n\n\treturn categoryMap, nil\n}",
    "caller": "func HandlePrescriptionReports(region string) ([]Deal, error) {\n\tmedData := Medicine{Zone: region, ApprovalLevel: 1}\n\tresults, err := medData.GroupByCategory()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to group prescription data: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "ApprovalLevel = 1 (Prescription)",
            "sql": "SELECT category, count(*) as total FROM payment_records WHERE zone = ? AND category = 'Prescription' GROUP BY category;"
          },
          {
            "scenario": "ApprovalLevel = 2 (OTC)",
            "sql": "SELECT category, count(*) as total FROM payment_records WHERE zone = ? AND category = 'OTC' GROUP BY category;"
          },
          {
            "scenario": "ApprovalLevel = 3 (Restricted)",
            "sql": "SELECT category, count(*) as total FROM payment_records WHERE zone IN (?, 'Special') AND category = 'Restricted' GROUP BY category;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PatientRepo",
        "code_value": "type PatientRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "MedicalRecordTableName",
        "code_value": "const MedicalRecordTableName = \"hospital_medical_records\""
      },
      {
        "code_key": "MedicalRecord",
        "code_value": "type MedicalRecord struct {\n\tRecordID    int64  `gorm:\"column:record_id\" json:\"record_id\"`\n\tPatientID   string `gorm:\"column:patient_id\" json:\"patient_id\"`\n\tDiagnosis   string `gorm:\"column:diagnosis\" json:\"diagnosis\"`\n\tDoctorID    string `gorm:\"column:doctor_id\" json:\"doctor_id\"`\n\tRecordDate  int64  `gorm:\"column:record_date\" json:\"record_date\"`\n\tIsCritical  bool   `gorm:\"column:is_critical\" json:\"is_critical\"`\n}"
      },
      {
        "code_key": "searchClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SearchKey)"
      },
      {
        "code_key": "medUtils",
        "code_value": "git.woa.com/Medical/health-record/pkg/medUtils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, operation string) hints.Hints {\n\tctxInfo := medcontext.GetMedContextFromContext(ctx)\n\tif len(ctxInfo.SessionID) < 10 {\n\t\tctxInfo.SessionID = uuid.New().String()[:8]\n\t}\n\n\tcomment := fmt.Sprintf(\"h=%v,d=%v,p=%v,s=%v\", HospitalID,\n\t\tctxInfo.Department, ctxInfo.PhysicianID, ctxInfo.SessionID)\n\treturn hints.CommentBefore(operation, comment)\n}"
      },
      {
        "code_key": "HospitalID",
        "code_value": "const HospitalID = \"GH12345\""
      },
      {
        "code_key": "PatientRecord",
        "code_value": "&model.MedicalRecord{}"
      },
      {
        "code_key": "CriticalStatus",
        "code_value": "const CriticalStatus = true"
      },
      {
        "code_key": "DepartmentCodes",
        "code_value": "var DepartmentCodes = map[string]int{\n\t\"Cardiology\":    1,\n\t\"Neurology\":     2,\n\t\"Orthopedics\":   3,\n\t\"Pediatrics\":    4,\n\t\"Dermatology\":   5\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "GroupByCategory",
    "orm_code": "func (repo *ScannerRepo) GroupByCategory(ctx context.Context, pattern string) (map[string][]*model.Publication, error) {\n\tcategoryClause := utils.SetSQLComment(ctx, utils.GroupKey)\n\tresults := make([]*model.Publication, 0)\n\tcategoryMap := make(map[string][]*model.Publication)\n\n\tif err := repo.db.Clauses(categoryClause).Table(model.PublicationTableName).\n\t\tWhere(\"unique_key LIKE ?\", pattern).\n\t\tFind(&results).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, pub := range results {\n\t\tcategoryMap[pub.RoleCode] = append(categoryMap[pub.RoleCode], pub)\n\t}\n\n\treturn categoryMap, nil\n}",
    "caller": "func ProcessOTCSales(district string) {\n\tdrug := Medicine{Zone: district, ApprovalLevel: 2}\n\tstats, err := drug.GroupByCategory()\n\tif err != nil {\n\t\tlog.Printf(\"OTC processing error: %v\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"OTC Sales Report: %+v\\n\", stats)\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "ApprovalLevel is 2 (OTC) with dynamic zone parameter",
            "sql": "SELECT category, count(*) as total FROM payment_records WHERE zone = ? AND category = 'OTC' GROUP BY category;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PatientRepo",
        "code_value": "type PatientRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "MedicalRecordTableName",
        "code_value": "const MedicalRecordTableName = \"hospital_medical_records\""
      },
      {
        "code_key": "MedicalRecord",
        "code_value": "type MedicalRecord struct {\n\tRecordID    int64  `gorm:\"column:record_id\" json:\"record_id\"`\n\tPatientID   string `gorm:\"column:patient_id\" json:\"patient_id\"`\n\tDiagnosis   string `gorm:\"column:diagnosis\" json:\"diagnosis\"`\n\tDoctorID    string `gorm:\"column:doctor_id\" json:\"doctor_id\"`\n\tRecordDate  int64  `gorm:\"column:record_date\" json:\"record_date\"`\n\tIsCritical  bool   `gorm:\"column:is_critical\" json:\"is_critical\"`\n}"
      },
      {
        "code_key": "searchClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SearchKey)"
      },
      {
        "code_key": "medUtils",
        "code_value": "git.woa.com/Medical/health-record/pkg/medUtils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, operation string) hints.Hints {\n\tctxInfo := medcontext.GetMedContextFromContext(ctx)\n\tif len(ctxInfo.SessionID) < 10 {\n\t\tctxInfo.SessionID = uuid.New().String()[:8]\n\t}\n\n\tcomment := fmt.Sprintf(\"h=%v,d=%v,p=%v,s=%v\", HospitalID,\n\t\tctxInfo.Department, ctxInfo.PhysicianID, ctxInfo.SessionID)\n\treturn hints.CommentBefore(operation, comment)\n}"
      },
      {
        "code_key": "HospitalID",
        "code_value": "const HospitalID = \"GH12345\""
      },
      {
        "code_key": "PatientRecord",
        "code_value": "&model.MedicalRecord{}"
      },
      {
        "code_key": "CriticalStatus",
        "code_value": "const CriticalStatus = true"
      },
      {
        "code_key": "DepartmentCodes",
        "code_value": "var DepartmentCodes = map[string]int{\n\t\"Cardiology\":    1,\n\t\"Neurology\":     2,\n\t\"Orthopedics\":   3,\n\t\"Pediatrics\":    4,\n\t\"Dermatology\":   5\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "GroupByCategory",
    "orm_code": "func (repo *ScannerRepo) GroupByCategory(ctx context.Context, pattern string) (map[string][]*model.Publication, error) {\n\tcategoryClause := utils.SetSQLComment(ctx, utils.GroupKey)\n\tresults := make([]*model.Publication, 0)\n\tcategoryMap := make(map[string][]*model.Publication)\n\n\tif err := repo.db.Clauses(categoryClause).Table(model.PublicationTableName).\n\t\tWhere(\"unique_key LIKE ?\", pattern).\n\t\tFind(&results).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, pub := range results {\n\t\tcategoryMap[pub.RoleCode] = append(categoryMap[pub.RoleCode], pub)\n\t}\n\n\treturn categoryMap, nil\n}",
    "caller": "func GenerateRestrictedAnalytics() error {\n\tpharma := Medicine{Zone: \"North\", ApprovalLevel: 3}\n\trestrictedData, err := pharma.GroupByCategory()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"restricted drugs analysis failed: %w\", err)\n\t}\n\tfmt.Println(\"Restricted Categories:\", restrictedData)\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "ApprovalLevel = 1",
            "sql": "SELECT category, count(*) as total FROM payment_records WHERE zone = ? AND category = 'Prescription' GROUP BY category;"
          },
          {
            "scenario": "ApprovalLevel = 2",
            "sql": "SELECT category, count(*) as total FROM payment_records WHERE zone = ? AND category = 'OTC' GROUP BY category;"
          },
          {
            "scenario": "ApprovalLevel = 3 (current caller scenario)",
            "sql": "SELECT category, count(*) as total FROM payment_records WHERE zone IN ('North', 'Special') AND category = 'Restricted' GROUP BY category;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PatientRepo",
        "code_value": "type PatientRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "MedicalRecordTableName",
        "code_value": "const MedicalRecordTableName = \"hospital_medical_records\""
      },
      {
        "code_key": "MedicalRecord",
        "code_value": "type MedicalRecord struct {\n\tRecordID    int64  `gorm:\"column:record_id\" json:\"record_id\"`\n\tPatientID   string `gorm:\"column:patient_id\" json:\"patient_id\"`\n\tDiagnosis   string `gorm:\"column:diagnosis\" json:\"diagnosis\"`\n\tDoctorID    string `gorm:\"column:doctor_id\" json:\"doctor_id\"`\n\tRecordDate  int64  `gorm:\"column:record_date\" json:\"record_date\"`\n\tIsCritical  bool   `gorm:\"column:is_critical\" json:\"is_critical\"`\n}"
      },
      {
        "code_key": "searchClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SearchKey)"
      },
      {
        "code_key": "medUtils",
        "code_value": "git.woa.com/Medical/health-record/pkg/medUtils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, operation string) hints.Hints {\n\tctxInfo := medcontext.GetMedContextFromContext(ctx)\n\tif len(ctxInfo.SessionID) < 10 {\n\t\tctxInfo.SessionID = uuid.New().String()[:8]\n\t}\n\n\tcomment := fmt.Sprintf(\"h=%v,d=%v,p=%v,s=%v\", HospitalID,\n\t\tctxInfo.Department, ctxInfo.PhysicianID, ctxInfo.SessionID)\n\treturn hints.CommentBefore(operation, comment)\n}"
      },
      {
        "code_key": "HospitalID",
        "code_value": "const HospitalID = \"GH12345\""
      },
      {
        "code_key": "PatientRecord",
        "code_value": "&model.MedicalRecord{}"
      },
      {
        "code_key": "CriticalStatus",
        "code_value": "const CriticalStatus = true"
      },
      {
        "code_key": "DepartmentCodes",
        "code_value": "var DepartmentCodes = map[string]int{\n\t\"Cardiology\":    1,\n\t\"Neurology\":     2,\n\t\"Orthopedics\":   3,\n\t\"Pediatrics\":    4,\n\t\"Dermatology\":   5\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "HardDelete",
    "orm_code": "func (repo *TagRepo) HardDelete(ctx context.Context, tagID string) error {\n\tdeleteClause := utils.SetSQLComment(ctx, utils.DeleteKey)\n\n\tif err := repo.db.Clauses(deleteClause).Table(model.TagTableName).\n\t\tWhere(\"tag_id = ?\", tagID).\n\t\tDelete(&model.Tag{}).Error; err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
    "caller": "",
    "sql_statement_list": [
      "DELETE FROM inventory_tags WHERE tag_id = ?;"
    ],
    "sql_types": [
      "DELETE"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "TagRepo",
        "code_value": "type TagRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "TagTableName",
        "code_value": "const TagTableName = \"inventory_tags\""
      },
      {
        "code_key": "Tag",
        "code_value": "type Tag struct {\n\tTagID      string `gorm:\"column:tag_id\" json:\"tag_id\"`\n\tLabel      string `gorm:\"column:label\" json:\"label\"`\n\tCategory   string `gorm:\"column:category\" json:\"category\"`\n\tStatus     int    `gorm:\"column:status\" json:\"status\"`\n\tCreatedAt  int64  `gorm:\"column:created_at\" json:\"created_at\"`\n\tModifiedAt int64  `gorm:\"column:modified_at\" json:\"modified_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (t *Tag) TableName() string {\n\treturn TagTableName\n}"
      },
      {
        "code_key": "DeleteKey",
        "code_value": "const DeleteKey = \"hard_delete\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/inventory-service/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) hints.Hints {\n\tcommentInfo := icontext.GetSQLCommentFromContext(ctx)\n\tif len(commentInfo.OperationID) < 12 {\n\t\tcommentInfo.OperationID = generateOpID()\n\t}\n\n\tcomment := fmt.Sprintf(\"svc=%v,op=%v,req=%v\", ServiceIdentifier,\n\t\tcommentInfo.OperationType, commentInfo.OperationID)\n\treturn hints.CommentBefore(clause, comment)\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "HardDelete",
    "orm_code": "func (repo *TagRepo) HardDelete(ctx context.Context, tagID string) error {\n\tdeleteClause := utils.SetSQLComment(ctx, utils.DeleteKey)\n\n\tif err := repo.db.Clauses(deleteClause).Table(model.TagTableName).\n\t\tWhere(\"tag_id = ?\", tagID).\n\t\tDelete(&model.Tag{}).Error; err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
    "caller": "func HandleExpiredTags(ctx context.Context, expiredTagIDs []string, logger *zap.Logger) error {\n\ttagRepo := NewTagRepo()\n\tfor _, id := range expiredTagIDs {\n\t\terr := tagRepo.HardDelete(ctx, id)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"failed to delete expired tag\", zap.String(\"tagID\", id), zap.Error(err))\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Hard delete a tag by ID with SQL comment",
            "sql": "/* svc=inventory-service,op=hard_delete,req=<generated_op_id> */ DELETE FROM inventory_tags WHERE tag_id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "TagRepo",
        "code_value": "type TagRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "TagTableName",
        "code_value": "const TagTableName = \"inventory_tags\""
      },
      {
        "code_key": "Tag",
        "code_value": "type Tag struct {\n\tTagID      string `gorm:\"column:tag_id\" json:\"tag_id\"`\n\tLabel      string `gorm:\"column:label\" json:\"label\"`\n\tCategory   string `gorm:\"column:category\" json:\"category\"`\n\tStatus     int    `gorm:\"column:status\" json:\"status\"`\n\tCreatedAt  int64  `gorm:\"column:created_at\" json:\"created_at\"`\n\tModifiedAt int64  `gorm:\"column:modified_at\" json:\"modified_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (t *Tag) TableName() string {\n\treturn TagTableName\n}"
      },
      {
        "code_key": "DeleteKey",
        "code_value": "const DeleteKey = \"hard_delete\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/inventory-service/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) hints.Hints {\n\tcommentInfo := icontext.GetSQLCommentFromContext(ctx)\n\tif len(commentInfo.OperationID) < 12 {\n\t\tcommentInfo.OperationID = generateOpID()\n\t}\n\n\tcomment := fmt.Sprintf(\"svc=%v,op=%v,req=%v\", ServiceIdentifier,\n\t\tcommentInfo.OperationType, commentInfo.OperationID)\n\treturn hints.CommentBefore(clause, comment)\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "HardDelete",
    "orm_code": "func (repo *TagRepo) HardDelete(ctx context.Context, tagID string) error {\n\tdeleteClause := utils.SetSQLComment(ctx, utils.DeleteKey)\n\n\tif err := repo.db.Clauses(deleteClause).Table(model.TagTableName).\n\t\tWhere(\"tag_id = ?\", tagID).\n\t\tDelete(&model.Tag{}).Error; err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
    "caller": "func CleanupOrphanedTags(ctx context.Context, dbClient *gorm.DB) error {\n\ttagRepo := &TagRepo{db: dbClient}\n\terr := tagRepo.HardDelete(ctx, \"orphaned_tag_123\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to cleanup orphaned tag: %v\", err)\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Hard delete tag with specific ID and SQL comment",
            "sql": "/* hard_delete svc=IVC,op=[operation_type],req=[operation_id] */ DELETE FROM inventory_tags WHERE tag_id = 'orphaned_tag_123';"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "TagRepo",
        "code_value": "type TagRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "TagTableName",
        "code_value": "const TagTableName = \"inventory_tags\""
      },
      {
        "code_key": "Tag",
        "code_value": "type Tag struct {\n\tTagID      string `gorm:\"column:tag_id\" json:\"tag_id\"`\n\tLabel      string `gorm:\"column:label\" json:\"label\"`\n\tCategory   string `gorm:\"column:category\" json:\"category\"`\n\tStatus     int    `gorm:\"column:status\" json:\"status\"`\n\tCreatedAt  int64  `gorm:\"column:created_at\" json:\"created_at\"`\n\tModifiedAt int64  `gorm:\"column:modified_at\" json:\"modified_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (t *Tag) TableName() string {\n\treturn TagTableName\n}"
      },
      {
        "code_key": "DeleteKey",
        "code_value": "const DeleteKey = \"hard_delete\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/inventory-service/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) hints.Hints {\n\tcommentInfo := icontext.GetSQLCommentFromContext(ctx)\n\tif len(commentInfo.OperationID) < 12 {\n\t\tcommentInfo.OperationID = generateOpID()\n\t}\n\n\tcomment := fmt.Sprintf(\"svc=%v,op=%v,req=%v\", ServiceIdentifier,\n\t\tcommentInfo.OperationType, commentInfo.OperationID)\n\treturn hints.CommentBefore(clause, comment)\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "HardDelete",
    "orm_code": "func (repo *TagRepo) HardDelete(ctx context.Context, tagID string) error {\n\tdeleteClause := utils.SetSQLComment(ctx, utils.DeleteKey)\n\n\tif err := repo.db.Clauses(deleteClause).Table(model.TagTableName).\n\t\tWhere(\"tag_id = ?\", tagID).\n\t\tDelete(&model.Tag{}).Error; err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
    "caller": "func ProcessTagRemovalRequest(ctx context.Context, requestID string, tagService TagService) error {\n\ttagID := \"req_\" + requestID\n\tif err := tagService.GetRepo().HardDelete(ctx, tagID); err != nil {\n\t\treturn fmt.Errorf(\"tag removal failed for request %s: %v\", requestID, err)\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "删除指定标签",
            "sql": "DELETE FROM inventory_tags WHERE tag_id = 'req_123';"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "TagRepo",
        "code_value": "type TagRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "TagTableName",
        "code_value": "const TagTableName = \"inventory_tags\""
      },
      {
        "code_key": "Tag",
        "code_value": "type Tag struct {\n\tTagID      string `gorm:\"column:tag_id\" json:\"tag_id\"`\n\tLabel      string `gorm:\"column:label\" json:\"label\"`\n\tCategory   string `gorm:\"column:category\" json:\"category\"`\n\tStatus     int    `gorm:\"column:status\" json:\"status\"`\n\tCreatedAt  int64  `gorm:\"column:created_at\" json:\"created_at\"`\n\tModifiedAt int64  `gorm:\"column:modified_at\" json:\"modified_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (t *Tag) TableName() string {\n\treturn TagTableName\n}"
      },
      {
        "code_key": "DeleteKey",
        "code_value": "const DeleteKey = \"hard_delete\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/inventory-service/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) hints.Hints {\n\tcommentInfo := icontext.GetSQLCommentFromContext(ctx)\n\tif len(commentInfo.OperationID) < 12 {\n\t\tcommentInfo.OperationID = generateOpID()\n\t}\n\n\tcomment := fmt.Sprintf(\"svc=%v,op=%v,req=%v\", ServiceIdentifier,\n\t\tcommentInfo.OperationType, commentInfo.OperationID)\n\treturn hints.CommentBefore(clause, comment)\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CalculateByFormula",
    "orm_code": "func (repo *DiplomaRepo) CalculateByFormula(ctx context.Context, scoreThreshold float64) ([]*model.Diploma, error) {\n    selectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n    var diplomas []*model.Diploma\n\n    if err := repo.db.Clauses(selectClause).Table(model.DiplomaTableName).\n        Where(\"final_score >= ?\", scoreThreshold).\n        Find(&diplomas).Error; err != nil {\n        return nil, err\n    }\n\n    return diplomas, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "AuthLevel = 1",
            "sql": "SELECT id, public_key, longitude, latitude, auth_token, status, created_at FROM customer_reviews WHERE status = 1 AND public_key = ? ORDER BY created_at DESC LIMIT ?;"
          },
          {
            "scenario": "AuthLevel = 2",
            "sql": "SELECT id, public_key, longitude, latitude, auth_token, status, created_at FROM customer_reviews WHERE status = 1 AND longitude = ? AND latitude = ? ORDER BY created_at DESC LIMIT ?;"
          },
          {
            "scenario": "AuthLevel = 3",
            "sql": "SELECT id, public_key, longitude, latitude, auth_token, status, created_at FROM customer_reviews WHERE status = 1 AND auth_token = ? ORDER BY created_at DESC LIMIT ?;"
          }
        ]
      },
      {
        "type": "NO_SQL_GENERATE",
        "variants": [
          {
            "scenario": "unsupported auth level (AuthLevel not in 1-3)",
            "sql": ""
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "OTHER"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "DiplomaRepo",
        "code_value": "type DiplomaRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Diploma",
        "code_value": "type Diploma struct {\n\tID          int64   `gorm:\"column:id\" json:\"id\"`\n\tStudentName string  `gorm:\"column:student_name\" json:\"student_name\"`\n\tMajor       string  `gorm:\"column:major\" json:\"major\"`\n\tFinalScore  float64 `gorm:\"column:final_score\" json:\"final_score\"`\n\tIsGraduated bool    `gorm:\"column:is_graduated\" json:\"is_graduated\"`\n}"
      },
      {
        "code_key": "DiplomaTableName",
        "code_value": "const DiplomaTableName = \"academic_diploma\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (d *Diploma) TableName() string {\n\treturn DiplomaTableName\n}"
      },
      {
        "code_key": "ScoreThreshold",
        "code_value": "const ScoreThreshold = 60.0"
      },
      {
        "code_key": "GraduateStatus",
        "code_value": "type GraduateStatus int\n\nconst (\n\tPending GraduateStatus = iota\n\tApproved\n\tRejected\n)"
      },
      {
        "code_key": "AcademicUtils",
        "code_value": "package academic\n\nimport \"context\"\n\ntype Hints struct{}\n\nfunc SetSQLComment(ctx context.Context, clause string) Hints {\n\treturn Hints{}\n}"
      },
      {
        "code_key": "QueryOptions",
        "code_value": "type QueryOptions struct {\n\tLimit  int\n\tOffset int\n\tSortBy string\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CalculateByFormula",
    "orm_code": "func (repo *DiplomaRepo) CalculateByFormula(ctx context.Context, scoreThreshold float64) ([]*model.Diploma, error) {\n    selectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n    var diplomas []*model.Diploma\n\n    if err := repo.db.Clauses(selectClause).Table(model.DiplomaTableName).\n        Where(\"final_score >= ?\", scoreThreshold).\n        Find(&diplomas).Error; err != nil {\n        return nil, err\n    }\n\n    return diplomas, nil\n}",
    "caller": "func HandleGraduationEligibility(ctx context.Context, logger *zap.Logger) error {\n    diplomaRepo, err := data.NewDiplomaRepo()\n    if err != nil {\n        logger.Error(\"failed to initialize diploma repo\", zap.Error(err))\n        return err\n    }\n\n    passingStudents, err := diplomaRepo.CalculateByFormula(ctx, 70.0)\n    if err != nil {\n        logger.Error(\"failed to calculate graduation eligibility\", zap.Error(err))\n        return err\n    }\n\n    logger.Info(\"successfully retrieved eligible graduates\", zap.Int(\"count\", len(passingStudents)))\n    return nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Default scenario with parameterized threshold",
            "sql": "SELECT id, student_name, major, final_score, is_graduated FROM academic_diploma WHERE final_score >= ?;"
          },
          {
            "scenario": "Specific scenario with threshold 70.0 as called by HandleGraduationEligibility",
            "sql": "SELECT id, student_name, major, final_score, is_graduated FROM academic_diploma WHERE final_score >= 70.0;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "DiplomaRepo",
        "code_value": "type DiplomaRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Diploma",
        "code_value": "type Diploma struct {\n\tID          int64   `gorm:\"column:id\" json:\"id\"`\n\tStudentName string  `gorm:\"column:student_name\" json:\"student_name\"`\n\tMajor       string  `gorm:\"column:major\" json:\"major\"`\n\tFinalScore  float64 `gorm:\"column:final_score\" json:\"final_score\"`\n\tIsGraduated bool    `gorm:\"column:is_graduated\" json:\"is_graduated\"`\n}"
      },
      {
        "code_key": "DiplomaTableName",
        "code_value": "const DiplomaTableName = \"academic_diploma\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (d *Diploma) TableName() string {\n\treturn DiplomaTableName\n}"
      },
      {
        "code_key": "ScoreThreshold",
        "code_value": "const ScoreThreshold = 60.0"
      },
      {
        "code_key": "GraduateStatus",
        "code_value": "type GraduateStatus int\n\nconst (\n\tPending GraduateStatus = iota\n\tApproved\n\tRejected\n)"
      },
      {
        "code_key": "AcademicUtils",
        "code_value": "package academic\n\nimport \"context\"\n\ntype Hints struct{}\n\nfunc SetSQLComment(ctx context.Context, clause string) Hints {\n\treturn Hints{}\n}"
      },
      {
        "code_key": "QueryOptions",
        "code_value": "type QueryOptions struct {\n\tLimit  int\n\tOffset int\n\tSortBy string\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CalculateByFormula",
    "orm_code": "func (repo *DiplomaRepo) CalculateByFormula(ctx context.Context, scoreThreshold float64) ([]*model.Diploma, error) {\n    selectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n    var diplomas []*model.Diploma\n\n    if err := repo.db.Clauses(selectClause).Table(model.DiplomaTableName).\n        Where(\"final_score >= ?\", scoreThreshold).\n        Find(&diplomas).Error; err != nil {\n        return nil, err\n    }\n\n    return diplomas, nil\n}",
    "caller": "func ProcessScholarshipCandidates(ctx context.Context, threshold float64) ([]*model.Diploma, error) {\n    repo := data.DiplomaRepo{db: globalDB}\n    \n    candidates, err := repo.CalculateByFormula(ctx, threshold)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to fetch scholarship candidates: %v\", err)\n    }\n\n    if len(candidates) == 0 {\n        return nil, errors.New(\"no eligible candidates found\")\n    }\n\n    return candidates, nil\n}",
    "sql_statement_list": [
      "SELECT id, student_name, major, final_score, is_graduated FROM academic_diploma WHERE final_score >= ?;"
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "DiplomaRepo",
        "code_value": "type DiplomaRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Diploma",
        "code_value": "type Diploma struct {\n\tID          int64   `gorm:\"column:id\" json:\"id\"`\n\tStudentName string  `gorm:\"column:student_name\" json:\"student_name\"`\n\tMajor       string  `gorm:\"column:major\" json:\"major\"`\n\tFinalScore  float64 `gorm:\"column:final_score\" json:\"final_score\"`\n\tIsGraduated bool    `gorm:\"column:is_graduated\" json:\"is_graduated\"`\n}"
      },
      {
        "code_key": "DiplomaTableName",
        "code_value": "const DiplomaTableName = \"academic_diploma\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (d *Diploma) TableName() string {\n\treturn DiplomaTableName\n}"
      },
      {
        "code_key": "ScoreThreshold",
        "code_value": "const ScoreThreshold = 60.0"
      },
      {
        "code_key": "GraduateStatus",
        "code_value": "type GraduateStatus int\n\nconst (\n\tPending GraduateStatus = iota\n\tApproved\n\tRejected\n)"
      },
      {
        "code_key": "AcademicUtils",
        "code_value": "package academic\n\nimport \"context\"\n\ntype Hints struct{}\n\nfunc SetSQLComment(ctx context.Context, clause string) Hints {\n\treturn Hints{}\n}"
      },
      {
        "code_key": "QueryOptions",
        "code_value": "type QueryOptions struct {\n\tLimit  int\n\tOffset int\n\tSortBy string\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CalculateByFormula",
    "orm_code": "func (repo *DiplomaRepo) CalculateByFormula(ctx context.Context, scoreThreshold float64) ([]*model.Diploma, error) {\n    selectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n    var diplomas []*model.Diploma\n\n    if err := repo.db.Clauses(selectClause).Table(model.DiplomaTableName).\n        Where(\"final_score >= ?\", scoreThreshold).\n        Find(&diplomas).Error; err != nil {\n        return nil, err\n    }\n\n    return diplomas, nil\n}",
    "caller": "func HandleVendorPermissions() error {\n\tvendorObj := &Vendor{\n\t\tAuthLevel: 2,\n\t\tLongitude: 116.404,\n\t\tLatitude: 39.915,\n\t\tPageSize: 10,\n\t}\n\tperms, err := vendorObj.CalculateByFormula()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to calculate permissions: %v\", err)\n\t\treturn err\n\t}\n\tfmt.Printf(\"Retrieved %d permissions\\n\", len(perms))\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "AuthLevel = 1",
            "sql": "SELECT id, public_key, longitude, latitude, auth_token, status, created_at FROM customer_reviews WHERE status = 1 AND public_key = ? ORDER BY created_at DESC LIMIT ?;"
          },
          {
            "scenario": "AuthLevel = 2",
            "sql": "SELECT id, public_key, longitude, latitude, auth_token, status, created_at FROM customer_reviews WHERE status = 1 AND longitude = ? AND latitude = ? ORDER BY created_at DESC LIMIT ?;"
          },
          {
            "scenario": "AuthLevel = 3",
            "sql": "SELECT id, public_key, longitude, latitude, auth_token, status, created_at FROM customer_reviews WHERE status = 1 AND auth_token = ? ORDER BY created_at DESC LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "DiplomaRepo",
        "code_value": "type DiplomaRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Diploma",
        "code_value": "type Diploma struct {\n\tID          int64   `gorm:\"column:id\" json:\"id\"`\n\tStudentName string  `gorm:\"column:student_name\" json:\"student_name\"`\n\tMajor       string  `gorm:\"column:major\" json:\"major\"`\n\tFinalScore  float64 `gorm:\"column:final_score\" json:\"final_score\"`\n\tIsGraduated bool    `gorm:\"column:is_graduated\" json:\"is_graduated\"`\n}"
      },
      {
        "code_key": "DiplomaTableName",
        "code_value": "const DiplomaTableName = \"academic_diploma\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (d *Diploma) TableName() string {\n\treturn DiplomaTableName\n}"
      },
      {
        "code_key": "ScoreThreshold",
        "code_value": "const ScoreThreshold = 60.0"
      },
      {
        "code_key": "GraduateStatus",
        "code_value": "type GraduateStatus int\n\nconst (\n\tPending GraduateStatus = iota\n\tApproved\n\tRejected\n)"
      },
      {
        "code_key": "AcademicUtils",
        "code_value": "package academic\n\nimport \"context\"\n\ntype Hints struct{}\n\nfunc SetSQLComment(ctx context.Context, clause string) Hints {\n\treturn Hints{}\n}"
      },
      {
        "code_key": "QueryOptions",
        "code_value": "type QueryOptions struct {\n\tLimit  int\n\tOffset int\n\tSortBy string\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CalculateByFormula",
    "orm_code": "func (repo *DiplomaRepo) CalculateByFormula(ctx context.Context, scoreThreshold float64) ([]*model.Diploma, error) {\n    selectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n    var diplomas []*model.Diploma\n\n    if err := repo.db.Clauses(selectClause).Table(model.DiplomaTableName).\n        Where(\"final_score >= ?\", scoreThreshold).\n        Find(&diplomas).Error; err != nil {\n        return nil, err\n    }\n\n    return diplomas, nil\n}",
    "caller": "func ProcessAuthRequests(authToken string) ([]Permission, error) {\n\tvendor := Vendor{\n\t\tAuthLevel: 3,\n\t\tAuthToken: authToken,\n\t\tPageSize: 20,\n\t}\n\tresults, err := vendor.CalculateByFormula()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"auth processing failed: %w\", err)\n\t}\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "AuthLevel=3 with auth_token filter",
            "sql": "SELECT id, public_key, longitude, latitude, auth_token, status, created_at FROM customer_reviews WHERE status = 1 AND auth_token = ? ORDER BY created_at DESC LIMIT 20;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "DiplomaRepo",
        "code_value": "type DiplomaRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Diploma",
        "code_value": "type Diploma struct {\n\tID          int64   `gorm:\"column:id\" json:\"id\"`\n\tStudentName string  `gorm:\"column:student_name\" json:\"student_name\"`\n\tMajor       string  `gorm:\"column:major\" json:\"major\"`\n\tFinalScore  float64 `gorm:\"column:final_score\" json:\"final_score\"`\n\tIsGraduated bool    `gorm:\"column:is_graduated\" json:\"is_graduated\"`\n}"
      },
      {
        "code_key": "DiplomaTableName",
        "code_value": "const DiplomaTableName = \"academic_diploma\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (d *Diploma) TableName() string {\n\treturn DiplomaTableName\n}"
      },
      {
        "code_key": "ScoreThreshold",
        "code_value": "const ScoreThreshold = 60.0"
      },
      {
        "code_key": "GraduateStatus",
        "code_value": "type GraduateStatus int\n\nconst (\n\tPending GraduateStatus = iota\n\tApproved\n\tRejected\n)"
      },
      {
        "code_key": "AcademicUtils",
        "code_value": "package academic\n\nimport \"context\"\n\ntype Hints struct{}\n\nfunc SetSQLComment(ctx context.Context, clause string) Hints {\n\treturn Hints{}\n}"
      },
      {
        "code_key": "QueryOptions",
        "code_value": "type QueryOptions struct {\n\tLimit  int\n\tOffset int\n\tSortBy string\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "AnalyzePerformance",
    "orm_code": "func (repo *SpellRepo) AnalyzePerformance(ctx context.Context, spellID string) (*model.SpellPerformance, error) {\n\tconst performanceTable = \"spell_performance_data\"\n\tselectClause := analytics.SetTrackingComment(ctx, analytics.SelectKey)\n\tperformance := &model.SpellPerformance{}\n\n\tif err := repo.db.Clauses(selectClause).Table(performanceTable).\n\t\tWhere(\"spell_id = ?\", spellID).\n\t\tFirst(performance).Error; err != nil {\n\t\t\tif err == gorm.ErrRecordNotFound {\n\t\t\t\treturn nil, nil\n\t\t\t}\n\t\t\treturn nil, err\n\t}\n\n\tif performance.LastAccessTime < time.Now().Unix()-86400 {\n\t\treturn nil, errors.New(\"performance data outdated\")\n\t}\n\n\treturn performance, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "AccessLevel = 1, threshold > 0",
            "sql": "SELECT id, district, editor, score, created_at, health_data FROM health_metrics WHERE district = ? AND editor = ? AND score >= ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "AccessLevel = 1, threshold <= 0",
            "sql": "SELECT id, district, editor, score, created_at, health_data FROM health_metrics WHERE district = ? AND editor = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "AccessLevel = 2, threshold > 0",
            "sql": "SELECT id, district, editor, score, created_at, health_data FROM health_metrics WHERE district = ? AND score >= ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "AccessLevel = 2, threshold <= 0",
            "sql": "SELECT id, district, editor, score, created_at, health_data FROM health_metrics WHERE district = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "AccessLevel = 3, threshold > 0",
            "sql": "SELECT id, district, editor, score, created_at, health_data FROM health_metrics WHERE editor = ? AND score >= ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "AccessLevel = 3, threshold <= 0",
            "sql": "SELECT id, district, editor, score, created_at, health_data FROM health_metrics WHERE editor = ? ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "SpellRepo",
        "code_value": "type SpellRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "SpellPerformance",
        "code_value": "type SpellPerformance struct {\n\tSpellID        string `gorm:\"column:spell_id\" json:\"spell_id\"`\n\tSuccessRate    float64 `gorm:\"column:success_rate\" json:\"success_rate\"`\n\tAvgCastTime    float64 `gorm:\"column:avg_cast_time\" json:\"avg_cast_time\"`\n\tLastAccessTime int64  `gorm:\"column:last_access_time\" json:\"last_access_time\"`\n}"
      },
      {
        "code_key": "spell_performance_data",
        "code_value": "const spell_performance_data = \"spell_performance_data\""
      },
      {
        "code_key": "analytics",
        "code_value": "import \"git.woa.com/magic/magic-analytics/pkg/analytics\""
      },
      {
        "code_key": "SetTrackingComment",
        "code_value": "func SetTrackingComment(ctx context.Context, operation string) clause.Expression {\n\ttraceID := ctx.Value(\"trace_id\")\n\tif traceID == nil {\n\t\ttraceID = \"not_provided\"\n\t}\n\treturn gorm.Expr(\"/* operation=%s,trace_id=%s */\", operation, traceID)\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"select\""
      },
      {
        "code_key": "time",
        "code_value": "import \"time\""
      },
      {
        "code_key": "gorm",
        "code_value": "import \"gorm.io/gorm\""
      },
      {
        "code_key": "errors",
        "code_value": "import \"errors\""
      },
      {
        "code_key": "context",
        "code_value": "import \"context\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "AnalyzePerformance",
    "orm_code": "func (repo *SpellRepo) AnalyzePerformance(ctx context.Context, spellID string) (*model.SpellPerformance, error) {\n\tconst performanceTable = \"spell_performance_data\"\n\tselectClause := analytics.SetTrackingComment(ctx, analytics.SelectKey)\n\tperformance := &model.SpellPerformance{}\n\n\tif err := repo.db.Clauses(selectClause).Table(performanceTable).\n\t\tWhere(\"spell_id = ?\", spellID).\n\t\tFirst(performance).Error; err != nil {\n\t\t\tif err == gorm.ErrRecordNotFound {\n\t\t\t\treturn nil, nil\n\t\t\t}\n\t\t\treturn nil, err\n\t}\n\n\tif performance.LastAccessTime < time.Now().Unix()-86400 {\n\t\treturn nil, errors.New(\"performance data outdated\")\n\t}\n\n\treturn performance, nil\n}",
    "caller": "func HandleSpellPerformance(ctx context.Context, spellIdentifier string, logger *zap.Logger) (*model.SpellPerformance, error) {\n\tspellRepo, err := data.NewSpellRepo()\n\tif err != nil {\n\t\tlogger.Error(\"failed to initialize spell repository\", zap.Error(err))\n\t\treturn nil, err\n\t}\n\n\tperfData, err := spellRepo.AnalyzePerformance(ctx, spellIdentifier)\n\tif err != nil {\n\t\tlogger.Error(\"failed to analyze spell performance\", \n\t\t\tzap.String(\"spellID\", spellIdentifier), \n\t\t\tzap.Error(err))\n\t\treturn nil, err\n\t}\n\n\tif perfData == nil {\n\t\tlogger.Warn(\"no performance data found\", zap.String(\"spellID\", spellIdentifier))\n\t\treturn nil, nil\n\t}\n\n\treturn perfData, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "normal query with trace_id",
            "sql": "SELECT spell_id, success_rate, avg_cast_time, last_access_time FROM spell_performance_data WHERE spell_id = ? LIMIT 1;"
          },
          {
            "scenario": "query when trace_id not provided",
            "sql": "SELECT spell_id, success_rate, avg_cast_time, last_access_time FROM spell_performance_data WHERE spell_id = ? LIMIT 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "SpellRepo",
        "code_value": "type SpellRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "SpellPerformance",
        "code_value": "type SpellPerformance struct {\n\tSpellID        string `gorm:\"column:spell_id\" json:\"spell_id\"`\n\tSuccessRate    float64 `gorm:\"column:success_rate\" json:\"success_rate\"`\n\tAvgCastTime    float64 `gorm:\"column:avg_cast_time\" json:\"avg_cast_time\"`\n\tLastAccessTime int64  `gorm:\"column:last_access_time\" json:\"last_access_time\"`\n}"
      },
      {
        "code_key": "spell_performance_data",
        "code_value": "const spell_performance_data = \"spell_performance_data\""
      },
      {
        "code_key": "analytics",
        "code_value": "import \"git.woa.com/magic/magic-analytics/pkg/analytics\""
      },
      {
        "code_key": "SetTrackingComment",
        "code_value": "func SetTrackingComment(ctx context.Context, operation string) clause.Expression {\n\ttraceID := ctx.Value(\"trace_id\")\n\tif traceID == nil {\n\t\ttraceID = \"not_provided\"\n\t}\n\treturn gorm.Expr(\"/* operation=%s,trace_id=%s */\", operation, traceID)\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"select\""
      },
      {
        "code_key": "time",
        "code_value": "import \"time\""
      },
      {
        "code_key": "gorm",
        "code_value": "import \"gorm.io/gorm\""
      },
      {
        "code_key": "errors",
        "code_value": "import \"errors\""
      },
      {
        "code_key": "context",
        "code_value": "import \"context\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "AnalyzePerformance",
    "orm_code": "func (repo *SpellRepo) AnalyzePerformance(ctx context.Context, spellID string) (*model.SpellPerformance, error) {\n\tconst performanceTable = \"spell_performance_data\"\n\tselectClause := analytics.SetTrackingComment(ctx, analytics.SelectKey)\n\tperformance := &model.SpellPerformance{}\n\n\tif err := repo.db.Clauses(selectClause).Table(performanceTable).\n\t\tWhere(\"spell_id = ?\", spellID).\n\t\tFirst(performance).Error; err != nil {\n\t\t\tif err == gorm.ErrRecordNotFound {\n\t\t\t\treturn nil, nil\n\t\t\t}\n\t\t\treturn nil, err\n\t}\n\n\tif performance.LastAccessTime < time.Now().Unix()-86400 {\n\t\treturn nil, errors.New(\"performance data outdated\")\n\t}\n\n\treturn performance, nil\n}",
    "caller": "func HandleDistrictPerformance() ([]Pallet, error) {\n\tmetricsAnalyzer := &Exchange{\n\t\tAccessLevel: 2,\n\t\tDistrict:    \"East\",\n\t}\n\t\n\tresults, err := metricsAnalyzer.AnalyzePerformance(80)\n\tif err != nil {\n\t\tlog.Printf(\"Failed to analyze performance: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "AccessLevel=1 with threshold>0",
            "sql": "SELECT id, district, editor, score, created_at, health_data FROM health_metrics WHERE district = ? AND editor = ? AND score >= ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "AccessLevel=2 with threshold>0 (caller's context)",
            "sql": "SELECT id, district, editor, score, created_at, health_data FROM health_metrics WHERE district = 'East' AND score >= 80 ORDER BY created_at DESC;"
          },
          {
            "scenario": "AccessLevel=3 with threshold>0",
            "sql": "SELECT id, district, editor, score, created_at, health_data FROM health_metrics WHERE editor = ? AND score >= ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "AccessLevel=2 with threshold<=0",
            "sql": "SELECT id, district, editor, score, created_at, health_data FROM health_metrics WHERE district = ? ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "SpellRepo",
        "code_value": "type SpellRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "SpellPerformance",
        "code_value": "type SpellPerformance struct {\n\tSpellID        string `gorm:\"column:spell_id\" json:\"spell_id\"`\n\tSuccessRate    float64 `gorm:\"column:success_rate\" json:\"success_rate\"`\n\tAvgCastTime    float64 `gorm:\"column:avg_cast_time\" json:\"avg_cast_time\"`\n\tLastAccessTime int64  `gorm:\"column:last_access_time\" json:\"last_access_time\"`\n}"
      },
      {
        "code_key": "spell_performance_data",
        "code_value": "const spell_performance_data = \"spell_performance_data\""
      },
      {
        "code_key": "analytics",
        "code_value": "import \"git.woa.com/magic/magic-analytics/pkg/analytics\""
      },
      {
        "code_key": "SetTrackingComment",
        "code_value": "func SetTrackingComment(ctx context.Context, operation string) clause.Expression {\n\ttraceID := ctx.Value(\"trace_id\")\n\tif traceID == nil {\n\t\ttraceID = \"not_provided\"\n\t}\n\treturn gorm.Expr(\"/* operation=%s,trace_id=%s */\", operation, traceID)\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"select\""
      },
      {
        "code_key": "time",
        "code_value": "import \"time\""
      },
      {
        "code_key": "gorm",
        "code_value": "import \"gorm.io/gorm\""
      },
      {
        "code_key": "errors",
        "code_value": "import \"errors\""
      },
      {
        "code_key": "context",
        "code_value": "import \"context\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "AnalyzePerformance",
    "orm_code": "func (repo *SpellRepo) AnalyzePerformance(ctx context.Context, spellID string) (*model.SpellPerformance, error) {\n\tconst performanceTable = \"spell_performance_data\"\n\tselectClause := analytics.SetTrackingComment(ctx, analytics.SelectKey)\n\tperformance := &model.SpellPerformance{}\n\n\tif err := repo.db.Clauses(selectClause).Table(performanceTable).\n\t\tWhere(\"spell_id = ?\", spellID).\n\t\tFirst(performance).Error; err != nil {\n\t\t\tif err == gorm.ErrRecordNotFound {\n\t\t\t\treturn nil, nil\n\t\t\t}\n\t\t\treturn nil, err\n\t}\n\n\tif performance.LastAccessTime < time.Now().Unix()-86400 {\n\t\treturn nil, errors.New(\"performance data outdated\")\n\t}\n\n\treturn performance, nil\n}",
    "caller": "func HandleEditorMetrics() error {\n\teditorTracker := &Exchange{\n\t\tAccessLevel: 3,\n\t\tEditor:      \"john.doe\",\n\t}\n\t\n\tpallets, err := editorTracker.AnalyzePerformance(0)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"metrics retrieval failed: %w\", err)\n\t}\n\t\n\tfmt.Printf(\"Found %d pallets\\n\", len(pallets))\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "AccessLevel=1 with threshold>0",
            "sql": "SELECT id, district, editor, score, created_at, health_data FROM health_metrics WHERE district = ? AND editor = ? AND score >= ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "AccessLevel=1 with threshold=0",
            "sql": "SELECT id, district, editor, score, created_at, health_data FROM health_metrics WHERE district = ? AND editor = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "AccessLevel=2 with threshold>0",
            "sql": "SELECT id, district, editor, score, created_at, health_data FROM health_metrics WHERE district = ? AND score >= ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "AccessLevel=2 with threshold=0",
            "sql": "SELECT id, district, editor, score, created_at, health_data FROM health_metrics WHERE district = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "AccessLevel=3 with threshold>0",
            "sql": "SELECT id, district, editor, score, created_at, health_data FROM health_metrics WHERE editor = ? AND score >= ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "AccessLevel=3 with threshold=0",
            "sql": "SELECT id, district, editor, score, created_at, health_data FROM health_metrics WHERE editor = ? ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "SpellRepo",
        "code_value": "type SpellRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "SpellPerformance",
        "code_value": "type SpellPerformance struct {\n\tSpellID        string `gorm:\"column:spell_id\" json:\"spell_id\"`\n\tSuccessRate    float64 `gorm:\"column:success_rate\" json:\"success_rate\"`\n\tAvgCastTime    float64 `gorm:\"column:avg_cast_time\" json:\"avg_cast_time\"`\n\tLastAccessTime int64  `gorm:\"column:last_access_time\" json:\"last_access_time\"`\n}"
      },
      {
        "code_key": "spell_performance_data",
        "code_value": "const spell_performance_data = \"spell_performance_data\""
      },
      {
        "code_key": "analytics",
        "code_value": "import \"git.woa.com/magic/magic-analytics/pkg/analytics\""
      },
      {
        "code_key": "SetTrackingComment",
        "code_value": "func SetTrackingComment(ctx context.Context, operation string) clause.Expression {\n\ttraceID := ctx.Value(\"trace_id\")\n\tif traceID == nil {\n\t\ttraceID = \"not_provided\"\n\t}\n\treturn gorm.Expr(\"/* operation=%s,trace_id=%s */\", operation, traceID)\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"select\""
      },
      {
        "code_key": "time",
        "code_value": "import \"time\""
      },
      {
        "code_key": "gorm",
        "code_value": "import \"gorm.io/gorm\""
      },
      {
        "code_key": "errors",
        "code_value": "import \"errors\""
      },
      {
        "code_key": "context",
        "code_value": "import \"context\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "AnalyzePerformance",
    "orm_code": "func (repo *SpellRepo) AnalyzePerformance(ctx context.Context, spellID string) (*model.SpellPerformance, error) {\n\tconst performanceTable = \"spell_performance_data\"\n\tselectClause := analytics.SetTrackingComment(ctx, analytics.SelectKey)\n\tperformance := &model.SpellPerformance{}\n\n\tif err := repo.db.Clauses(selectClause).Table(performanceTable).\n\t\tWhere(\"spell_id = ?\", spellID).\n\t\tFirst(performance).Error; err != nil {\n\t\t\tif err == gorm.ErrRecordNotFound {\n\t\t\t\treturn nil, nil\n\t\t\t}\n\t\t\treturn nil, err\n\t}\n\n\tif performance.LastAccessTime < time.Now().Unix()-86400 {\n\t\treturn nil, errors.New(\"performance data outdated\")\n\t}\n\n\treturn performance, nil\n}",
    "caller": "func HandleStrictAudit() {\n\tstrictReview := &Exchange{\n\t\tAccessLevel: 1,\n\t\tDistrict:    \"North\",\n\t\tEditor:      \"audit.bot\",\n\t}\n\t\n\tif data, err := strictReview.AnalyzePerformance(95); err == nil {\n\t\tprocessAuditData(data)\n\t} else {\n\t\tnotifyAdmins(err)\n\t}\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "AccessLevel = 1 with threshold > 0",
            "sql": "SELECT id, district, editor, score, created_at, health_data FROM health_metrics WHERE district = 'North' AND editor = 'audit.bot' AND score >= 95 ORDER BY created_at DESC;"
          },
          {
            "scenario": "AccessLevel = 1 with threshold = 0",
            "sql": "SELECT id, district, editor, score, created_at, health_data FROM health_metrics WHERE district = 'North' AND editor = 'audit.bot' ORDER BY created_at DESC;"
          },
          {
            "scenario": "AccessLevel = 2 with threshold > 0",
            "sql": "SELECT id, district, editor, score, created_at, health_data FROM health_metrics WHERE district = 'North' AND score >= ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "AccessLevel = 2 with threshold = 0",
            "sql": "SELECT id, district, editor, score, created_at, health_data FROM health_metrics WHERE district = 'North' ORDER BY created_at DESC;"
          },
          {
            "scenario": "AccessLevel = 3 with threshold > 0",
            "sql": "SELECT id, district, editor, score, created_at, health_data FROM health_metrics WHERE editor = ? AND score >= ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "AccessLevel = 3 with threshold = 0",
            "sql": "SELECT id, district, editor, score, created_at, health_data FROM health_metrics WHERE editor = ? ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "SpellRepo",
        "code_value": "type SpellRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "SpellPerformance",
        "code_value": "type SpellPerformance struct {\n\tSpellID        string `gorm:\"column:spell_id\" json:\"spell_id\"`\n\tSuccessRate    float64 `gorm:\"column:success_rate\" json:\"success_rate\"`\n\tAvgCastTime    float64 `gorm:\"column:avg_cast_time\" json:\"avg_cast_time\"`\n\tLastAccessTime int64  `gorm:\"column:last_access_time\" json:\"last_access_time\"`\n}"
      },
      {
        "code_key": "spell_performance_data",
        "code_value": "const spell_performance_data = \"spell_performance_data\""
      },
      {
        "code_key": "analytics",
        "code_value": "import \"git.woa.com/magic/magic-analytics/pkg/analytics\""
      },
      {
        "code_key": "SetTrackingComment",
        "code_value": "func SetTrackingComment(ctx context.Context, operation string) clause.Expression {\n\ttraceID := ctx.Value(\"trace_id\")\n\tif traceID == nil {\n\t\ttraceID = \"not_provided\"\n\t}\n\treturn gorm.Expr(\"/* operation=%s,trace_id=%s */\", operation, traceID)\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"select\""
      },
      {
        "code_key": "time",
        "code_value": "import \"time\""
      },
      {
        "code_key": "gorm",
        "code_value": "import \"gorm.io/gorm\""
      },
      {
        "code_key": "errors",
        "code_value": "import \"errors\""
      },
      {
        "code_key": "context",
        "code_value": "import \"context\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "MonitorActivity",
    "orm_code": "func (repo *ActivityRepo) MonitorActivity(ctx context.Context, achievement *model.Achievement) error {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\toldAchievement := &model.Achievement{}\n\n\tif err := repo.db.Clauses(selectClause).Table(model.AchievementTableName).\n\t\tWhere(\"reference_code = ?\", achievement.ReferenceCode).\n\t\tFirst(oldAchievement).Error; err != nil {\n\t\tif !errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn err\n\t\t}\n\t\t// 不存在则创建\n\t\tif err := repo.db.Clauses(updateClause).Table(model.AchievementTableName).\n\t\t\tCreate(achievement).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\t// 存在则更新\n\t\tif err := repo.db.Clauses(updateClause).Table(model.AchievementTableName).\n\t\t\tWhere(\"reference_code = ?\", achievement.ReferenceCode).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"role_code\": achievement.RoleCode,\n\t\t\t\t\"service_name\": achievement.ServiceName,\n\t\t\t}).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "HeartRate监测类型，无优先级过滤",
            "sql": "SELECT id, sensor_type, value, recorded_at, created_at, priority, status FROM exam_results WHERE status = 1 AND sensor_type = 'heart_rate' AND created_at BETWEEN ? AND ? ORDER BY recorded_at DESC;"
          },
          {
            "scenario": "HeartRate监测类型，有优先级过滤",
            "sql": "SELECT id, sensor_type, value, recorded_at, created_at, priority, status FROM exam_results WHERE status = 1 AND sensor_type = 'heart_rate' AND priority = ? AND created_at BETWEEN ? AND ? ORDER BY recorded_at DESC;"
          },
          {
            "scenario": "BloodPressure监测类型，无优先级过滤",
            "sql": "SELECT id, sensor_type, value, recorded_at, created_at, priority, status FROM exam_results WHERE status = 1 AND sensor_type = 'blood_pressure' AND created_at BETWEEN ? AND ? ORDER BY recorded_at DESC;"
          },
          {
            "scenario": "BloodPressure监测类型，有优先级过滤",
            "sql": "SELECT id, sensor_type, value, recorded_at, created_at, priority, status FROM exam_results WHERE status = 1 AND sensor_type = 'blood_pressure' AND priority = ? AND created_at BETWEEN ? AND ? ORDER BY recorded_at DESC;"
          },
          {
            "scenario": "OxygenLevel监测类型，无优先级过滤",
            "sql": "SELECT id, sensor_type, value, recorded_at, created_at, priority, status FROM exam_results WHERE status = 1 AND sensor_type = 'oxygen_level' AND created_at BETWEEN ? AND ? ORDER BY recorded_at DESC;"
          },
          {
            "scenario": "OxygenLevel监测类型，有优先级过滤",
            "sql": "SELECT id, sensor_type, value, recorded_at, created_at, priority, status FROM exam_results WHERE status = 1 AND sensor_type = 'oxygen_level' AND priority = ? AND created_at BETWEEN ? AND ? ORDER BY recorded_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ActivityRepo",
        "code_value": "type ActivityRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "AchievementTableName",
        "code_value": "const AchievementTableName = \"ivc_activity_achievement\""
      },
      {
        "code_key": "Achievement",
        "code_value": "type Achievement struct {\n\tID           int64  `gorm:\"column:id\" json:\"id\"`\n\tReferenceCode string `gorm:\"column:reference_code\" json:\"reference_code\"`\n\tRoleCode      string `gorm:\"column:role_code\" json:\"role_code\"`\n\tServiceName   string `gorm:\"column:service_name\" json:\"service_name\"`\n\tCreatedAt    int64  `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt    int64  `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (a *Achievement) TableName() string {\n\treturn AchievementTableName\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "hints",
        "code_value": "git.woa.com/IVC/ivc-event-alarm/pkg/hints"
      },
      {
        "code_key": "icontext",
        "code_value": "git.woa.com/IVC/ivc-event-alarm/pkg/icontext"
      },
      {
        "code_key": "uuid",
        "code_value": "github.com/google/uuid"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "MonitorActivity",
    "orm_code": "func (repo *ActivityRepo) MonitorActivity(ctx context.Context, achievement *model.Achievement) error {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\toldAchievement := &model.Achievement{}\n\n\tif err := repo.db.Clauses(selectClause).Table(model.AchievementTableName).\n\t\tWhere(\"reference_code = ?\", achievement.ReferenceCode).\n\t\tFirst(oldAchievement).Error; err != nil {\n\t\tif !errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn err\n\t\t}\n\t\t// 不存在则创建\n\t\tif err := repo.db.Clauses(updateClause).Table(model.AchievementTableName).\n\t\t\tCreate(achievement).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\t// 存在则更新\n\t\tif err := repo.db.Clauses(updateClause).Table(model.AchievementTableName).\n\t\t\tWhere(\"reference_code = ?\", achievement.ReferenceCode).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"role_code\": achievement.RoleCode,\n\t\t\t\t\"service_name\": achievement.ServiceName,\n\t\t\t}).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func HandleUserAchievement(ctx context.Context, refCode string, roleCode string, serviceName string, logger *zap.Logger) error {\n\tactivityRepo, err := data.NewActivityRepo()\n\tif err != nil {\n\t\tlogger.Error(\"Failed to create activity repo\", zap.Error(err))\n\t\treturn err\n\t}\n\n\tachievement := &model.Achievement{\n\t\tReferenceCode: refCode,\n\t\tRoleCode:      roleCode,\n\t\tServiceName:   serviceName,\n\t}\n\n\tif err := activityRepo.MonitorActivity(ctx, achievement); err != nil {\n\t\tlogger.Error(\"Failed to monitor activity\", zap.Error(err))\n\t\treturn err\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Initial SELECT query to check if record exists",
            "sql": "SELECT id, reference_code, role_code, service_name, created_at, updated_at FROM ivc_activity_achievement WHERE reference_code = ? LIMIT 1;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "INSERT when record doesn't exist",
            "sql": "INSERT INTO ivc_activity_achievement (reference_code, role_code, service_name, created_at, updated_at) VALUES (?, ?, ?, ?, ?);"
          },
          {
            "scenario": "UPDATE when record exists",
            "sql": "UPDATE ivc_activity_achievement SET role_code = ?, service_name = ?, updated_at = ? WHERE reference_code = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ActivityRepo",
        "code_value": "type ActivityRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "AchievementTableName",
        "code_value": "const AchievementTableName = \"ivc_activity_achievement\""
      },
      {
        "code_key": "Achievement",
        "code_value": "type Achievement struct {\n\tID           int64  `gorm:\"column:id\" json:\"id\"`\n\tReferenceCode string `gorm:\"column:reference_code\" json:\"reference_code\"`\n\tRoleCode      string `gorm:\"column:role_code\" json:\"role_code\"`\n\tServiceName   string `gorm:\"column:service_name\" json:\"service_name\"`\n\tCreatedAt    int64  `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt    int64  `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (a *Achievement) TableName() string {\n\treturn AchievementTableName\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "hints",
        "code_value": "git.woa.com/IVC/ivc-event-alarm/pkg/hints"
      },
      {
        "code_key": "icontext",
        "code_value": "git.woa.com/IVC/ivc-event-alarm/pkg/icontext"
      },
      {
        "code_key": "uuid",
        "code_value": "github.com/google/uuid"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "MonitorActivity",
    "orm_code": "func (repo *ActivityRepo) MonitorActivity(ctx context.Context, achievement *model.Achievement) error {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\toldAchievement := &model.Achievement{}\n\n\tif err := repo.db.Clauses(selectClause).Table(model.AchievementTableName).\n\t\tWhere(\"reference_code = ?\", achievement.ReferenceCode).\n\t\tFirst(oldAchievement).Error; err != nil {\n\t\tif !errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn err\n\t\t}\n\t\t// 不存在则创建\n\t\tif err := repo.db.Clauses(updateClause).Table(model.AchievementTableName).\n\t\t\tCreate(achievement).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\t// 存在则更新\n\t\tif err := repo.db.Clauses(updateClause).Table(model.AchievementTableName).\n\t\t\tWhere(\"reference_code = ?\", achievement.ReferenceCode).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"role_code\": achievement.RoleCode,\n\t\t\t\t\"service_name\": achievement.ServiceName,\n\t\t\t}).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func ProcessGameProgress(ctx context.Context, playerID string, gameLevel string) error {\n\trepo := &ActivityRepo{db: database.GetDefaultDB()}\n\tprogress := &model.Achievement{\n\t\tReferenceCode: playerID,\n\t\tRoleCode:      \"player\",\n\t\tServiceName:   gameLevel,\n\t}\n\n\tif err := repo.MonitorActivity(ctx, progress); err != nil {\n\t\tmetrics.Increment(\"game_progress_error\")\n\t\treturn fmt.Errorf(\"failed to update game progress: %w\", err)\n\t}\n\tmetrics.Increment(\"game_progress_success\")\n\treturn nil\n}",
    "sql_statement_list": [
      "{\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\n        \"scenario\": \"Record does not exist (create new)\",\n        \"sql\": [\n          \"SELECT id, reference_code, role_code, service_name, created_at, updated_at FROM ivc_activity_achievement WHERE reference_code = 'player123' ORDER BY ivc_activity_achievement.id LIMIT 1;\",\n          \"INSERT INTO ivc_activity_achievement (reference_code, role_code, service_name, created_at, updated_at) VALUES ('player123', 'player', 'level1', UNIX_TIMESTAMP(), UNIX_TIMESTAMP());\"\n        ]\n      }",
      "create new)\",\n        \"sql\": [\n          \"SELECT id, reference_code, role_code, service_name, created_at, updated_at FROM ivc_activity_achievement WHERE reference_code = 'player123' ORDER BY ivc_activity_achievement.id LIMIT 1;",
      "INSERT INTO ivc_activity_achievement (reference_code, role_code, service_name, created_at, updated_at) VALUES ('player123', 'player', 'level1', UNIX_TIMESTAMP(), UNIX_TIMESTAMP());",
      "update existing)\",\n        \"sql\": [\n          \"SELECT id, reference_code, role_code, service_name, created_at, updated_at FROM ivc_activity_achievement WHERE reference_code = 'player456' ORDER BY ivc_activity_achievement.id LIMIT 1;",
      "UPDATE ivc_activity_achievement SET role_code = 'player', service_name = 'level2', updated_at = UNIX_TIMESTAMP() WHERE reference_code = 'player456';"
    ],
    "sql_types": [
      "OTHER",
      "OTHER",
      "INSERT",
      "UPDATE",
      "UPDATE"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "ActivityRepo",
        "code_value": "type ActivityRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "AchievementTableName",
        "code_value": "const AchievementTableName = \"ivc_activity_achievement\""
      },
      {
        "code_key": "Achievement",
        "code_value": "type Achievement struct {\n\tID           int64  `gorm:\"column:id\" json:\"id\"`\n\tReferenceCode string `gorm:\"column:reference_code\" json:\"reference_code\"`\n\tRoleCode      string `gorm:\"column:role_code\" json:\"role_code\"`\n\tServiceName   string `gorm:\"column:service_name\" json:\"service_name\"`\n\tCreatedAt    int64  `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt    int64  `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (a *Achievement) TableName() string {\n\treturn AchievementTableName\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "hints",
        "code_value": "git.woa.com/IVC/ivc-event-alarm/pkg/hints"
      },
      {
        "code_key": "icontext",
        "code_value": "git.woa.com/IVC/ivc-event-alarm/pkg/icontext"
      },
      {
        "code_key": "uuid",
        "code_value": "github.com/google/uuid"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "MonitorActivity",
    "orm_code": "func (repo *ActivityRepo) MonitorActivity(ctx context.Context, achievement *model.Achievement) error {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\toldAchievement := &model.Achievement{}\n\n\tif err := repo.db.Clauses(selectClause).Table(model.AchievementTableName).\n\t\tWhere(\"reference_code = ?\", achievement.ReferenceCode).\n\t\tFirst(oldAchievement).Error; err != nil {\n\t\tif !errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn err\n\t\t}\n\t\t// 不存在则创建\n\t\tif err := repo.db.Clauses(updateClause).Table(model.AchievementTableName).\n\t\t\tCreate(achievement).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\t// 存在则更新\n\t\tif err := repo.db.Clauses(updateClause).Table(model.AchievementTableName).\n\t\t\tWhere(\"reference_code = ?\", achievement.ReferenceCode).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"role_code\": achievement.RoleCode,\n\t\t\t\t\"service_name\": achievement.ServiceName,\n\t\t\t}).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func HandlePatientMonitoring() {\n\tpt := &Patient{\n\t\tMonitorType: HeartRate,\n\t\tPriorityRank: 3,\n\t\tStartTime:   time.Now().Add(-24 * time.Hour),\n\t\tEndTime:     time.Now(),\n\t}\n\n\tactivityRecords, err := pt.MonitorActivity()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to monitor patient activity: %v\", err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"Retrieved %d activity logs\\n\", len(activityRecords))\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "HeartRate monitor type without priority condition",
            "sql": "SELECT id, sensor_type, value, recorded_at, created_at, priority, status FROM exam_results WHERE status = 1 AND sensor_type = 'heart_rate' AND created_at BETWEEN ? AND ? ORDER BY recorded_at DESC;"
          },
          {
            "scenario": "BloodPressure monitor type without priority condition",
            "sql": "SELECT id, sensor_type, value, recorded_at, created_at, priority, status FROM exam_results WHERE status = 1 AND sensor_type = 'blood_pressure' AND created_at BETWEEN ? AND ? ORDER BY recorded_at DESC;"
          },
          {
            "scenario": "OxygenLevel monitor type without priority condition",
            "sql": "SELECT id, sensor_type, value, recorded_at, created_at, priority, status FROM exam_results WHERE status = 1 AND sensor_type = 'oxygen_level' AND created_at BETWEEN ? AND ? ORDER BY recorded_at DESC;"
          },
          {
            "scenario": "HeartRate monitor type with priority condition",
            "sql": "SELECT id, sensor_type, value, recorded_at, created_at, priority, status FROM exam_results WHERE status = 1 AND sensor_type = 'heart_rate' AND priority = ? AND created_at BETWEEN ? AND ? ORDER BY recorded_at DESC;"
          },
          {
            "scenario": "BloodPressure monitor type with priority condition",
            "sql": "SELECT id, sensor_type, value, recorded_at, created_at, priority, status FROM exam_results WHERE status = 1 AND sensor_type = 'blood_pressure' AND priority = ? AND created_at BETWEEN ? AND ? ORDER BY recorded_at DESC;"
          },
          {
            "scenario": "OxygenLevel monitor type with priority condition",
            "sql": "SELECT id, sensor_type, value, recorded_at, created_at, priority, status FROM exam_results WHERE status = 1 AND sensor_type = 'oxygen_level' AND priority = ? AND created_at BETWEEN ? AND ? ORDER BY recorded_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ActivityRepo",
        "code_value": "type ActivityRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "AchievementTableName",
        "code_value": "const AchievementTableName = \"ivc_activity_achievement\""
      },
      {
        "code_key": "Achievement",
        "code_value": "type Achievement struct {\n\tID           int64  `gorm:\"column:id\" json:\"id\"`\n\tReferenceCode string `gorm:\"column:reference_code\" json:\"reference_code\"`\n\tRoleCode      string `gorm:\"column:role_code\" json:\"role_code\"`\n\tServiceName   string `gorm:\"column:service_name\" json:\"service_name\"`\n\tCreatedAt    int64  `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt    int64  `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (a *Achievement) TableName() string {\n\treturn AchievementTableName\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "hints",
        "code_value": "git.woa.com/IVC/ivc-event-alarm/pkg/hints"
      },
      {
        "code_key": "icontext",
        "code_value": "git.woa.com/IVC/ivc-event-alarm/pkg/icontext"
      },
      {
        "code_key": "uuid",
        "code_value": "github.com/google/uuid"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "MonitorActivity",
    "orm_code": "func (repo *ActivityRepo) MonitorActivity(ctx context.Context, achievement *model.Achievement) error {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\toldAchievement := &model.Achievement{}\n\n\tif err := repo.db.Clauses(selectClause).Table(model.AchievementTableName).\n\t\tWhere(\"reference_code = ?\", achievement.ReferenceCode).\n\t\tFirst(oldAchievement).Error; err != nil {\n\t\tif !errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn err\n\t\t}\n\t\t// 不存在则创建\n\t\tif err := repo.db.Clauses(updateClause).Table(model.AchievementTableName).\n\t\t\tCreate(achievement).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\t// 存在则更新\n\t\tif err := repo.db.Clauses(updateClause).Table(model.AchievementTableName).\n\t\t\tWhere(\"reference_code = ?\", achievement.ReferenceCode).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"role_code\": achievement.RoleCode,\n\t\t\t\t\"service_name\": achievement.ServiceName,\n\t\t\t}).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func ProcessCriticalVitals() error {\n\tcriticalPatient := &Patient{\n\t\tMonitorType: BloodPressure,\n\t\tPriorityRank: 1,\n\t\tStartTime:   time.Date(2023, 1, 1, 0, 0, 0, 0, time.UTC),\n\t\tEndTime:     time.Date(2023, 1, 2, 0, 0, 0, 0, time.UTC),\n\t}\n\n\treadings, err := criticalPatient.MonitorActivity()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"vital monitoring failed: %w\", err)\n\t}\n\n\tif len(readings) == 0 {\n\t\treturn errors.New(\"no vital readings found\")\n\t}\n\n\t// Process critical readings here\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "基础查询（无priority条件）",
            "sql": "SELECT id, sensor_type, value, recorded_at, created_at, priority, status FROM exam_results WHERE status = 1 AND sensor_type = ? AND created_at BETWEEN ? AND ? ORDER BY recorded_at DESC;"
          },
          {
            "scenario": "包含priority条件（当前调用者场景）",
            "sql": "SELECT id, sensor_type, value, recorded_at, created_at, priority, status FROM exam_results WHERE status = 1 AND sensor_type = ? AND priority = ? AND created_at BETWEEN ? AND ? ORDER BY recorded_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ActivityRepo",
        "code_value": "type ActivityRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "AchievementTableName",
        "code_value": "const AchievementTableName = \"ivc_activity_achievement\""
      },
      {
        "code_key": "Achievement",
        "code_value": "type Achievement struct {\n\tID           int64  `gorm:\"column:id\" json:\"id\"`\n\tReferenceCode string `gorm:\"column:reference_code\" json:\"reference_code\"`\n\tRoleCode      string `gorm:\"column:role_code\" json:\"role_code\"`\n\tServiceName   string `gorm:\"column:service_name\" json:\"service_name\"`\n\tCreatedAt    int64  `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt    int64  `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (a *Achievement) TableName() string {\n\treturn AchievementTableName\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "hints",
        "code_value": "git.woa.com/IVC/ivc-event-alarm/pkg/hints"
      },
      {
        "code_key": "icontext",
        "code_value": "git.woa.com/IVC/ivc-event-alarm/pkg/icontext"
      },
      {
        "code_key": "uuid",
        "code_value": "github.com/google/uuid"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "CountByStatus",
    "orm_code": "func (repo *BudgetRepo) CountByStatus(ctx context.Context, status int) (int64, error) {\n\tcountClause := utils.SetSQLComment(ctx, utils.CountKey)\n\tvar count int64\n\n\tif err := repo.db.Clauses(countClause).Table(model.BudgetTableName).\n\t\tWhere(\"status = ?\", status).\n\t\tCount(&count).Error; err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn count, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Area has value, ResourceType is 0",
            "sql": "SELECT COUNT(*) FROM guild_memberships WHERE area = ?;"
          },
          {
            "scenario": "Area has value, ResourceType is 1 (SharedResource)",
            "sql": "SELECT COUNT(*) FROM guild_memberships WHERE area = ? AND is_shared = 1;"
          },
          {
            "scenario": "Area has value, ResourceType is 2 (ActiveResource)",
            "sql": "SELECT COUNT(*) FROM guild_memberships WHERE area = ? AND is_active = 1;"
          },
          {
            "scenario": "Area has value, ResourceType is 3 (LockedResource)",
            "sql": "SELECT COUNT(*) FROM guild_memberships WHERE area = ? AND is_locked = 1;"
          },
          {
            "scenario": "Area is empty, ResourceType is 1 (SharedResource)",
            "sql": "SELECT COUNT(*) FROM guild_memberships WHERE is_shared = 1;"
          },
          {
            "scenario": "Area is empty, ResourceType is 2 (ActiveResource)",
            "sql": "SELECT COUNT(*) FROM guild_memberships WHERE is_active = 1;"
          },
          {
            "scenario": "Area is empty, ResourceType is 3 (LockedResource)",
            "sql": "SELECT COUNT(*) FROM guild_memberships WHERE is_locked = 1;"
          },
          {
            "scenario": "Area is empty, ResourceType is 0",
            "sql": "SELECT COUNT(*) FROM guild_memberships;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "FuelConsumptionRepo",
        "code_value": "type FuelConsumptionRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "FuelConsumptionTableName",
        "code_value": "const FuelConsumptionTableName = \"vehicle_fuel_records\""
      },
      {
        "code_key": "FuelConsumption",
        "code_value": "type FuelConsumption struct {\n\tID          int64   `gorm:\"column:id\" json:\"id\"`\n\tVehicleID   string  `gorm:\"column:vehicle_id\" json:\"vehicle_id\"`\n\tFuelAmount  float64 `gorm:\"column:fuel_amount\" json:\"fuel_amount\"`\n\tCost        float64 `gorm:\"column:cost\" json:\"cost\"`\n\tStatus      int     `gorm:\"column:status\" json:\"status\"`\n\tRecordedAt  int64   `gorm:\"column:recorded_at\" json:\"recorded_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (fc *FuelConsumption) TableName() string {\n\treturn FuelConsumptionTableName\n}"
      },
      {
        "code_key": "FuelStatusActive",
        "code_value": "const FuelStatusActive = 1"
      },
      {
        "code_key": "FuelStatusInactive",
        "code_value": "const FuelStatusInactive = 0"
      },
      {
        "code_key": "FuelStatusArchived",
        "code_value": "const FuelStatusArchived = 2"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/vehicle-service/pkg/utils"
      },
      {
        "code_key": "CountKey",
        "code_value": "const CountKey = \"count\""
      },
      {
        "code_key": "VehicleRecord",
        "code_value": "type VehicleRecord struct {\n\tID          int64   `gorm:\"column:id\" json:\"id\"`\n\tPlateNumber string  `gorm:\"column:plate_number\" json:\"plate_number\"`\n\tModel       string  `gorm:\"column:model\" json:\"model\"`\n\tStatus      int     `gorm:\"column:status\" json:\"status\"`\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CountByStatus",
    "orm_code": "func (repo *BudgetRepo) CountByStatus(ctx context.Context, status int) (int64, error) {\n\tcountClause := utils.SetSQLComment(ctx, utils.CountKey)\n\tvar count int64\n\n\tif err := repo.db.Clauses(countClause).Table(model.BudgetTableName).\n\t\tWhere(\"status = ?\", status).\n\t\tCount(&count).Error; err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn count, nil\n}",
    "caller": "func HandleBudgetAnalysis(ctx context.Context, db *gorm.DB) (int64, error) {\n\trepo := &BudgetRepo{db: db}\n\tactiveCount, err := repo.CountByStatus(ctx, 1)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to count active budgets: %v\", err)\n\t}\n\treturn activeCount, nil\n}",
    "sql_statement_list": [
      {
        "type": "LACK_INFORMATION",
        "variants": [
          {
            "scenario": "缺少model.BudgetTableName定义，根据BudgetRepo和BudgetTableName推测表名",
            "sql": "SELECT COUNT(*) FROM budget WHERE status = 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "FuelConsumptionRepo",
        "code_value": "type FuelConsumptionRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "FuelConsumptionTableName",
        "code_value": "const FuelConsumptionTableName = \"vehicle_fuel_records\""
      },
      {
        "code_key": "FuelConsumption",
        "code_value": "type FuelConsumption struct {\n\tID          int64   `gorm:\"column:id\" json:\"id\"`\n\tVehicleID   string  `gorm:\"column:vehicle_id\" json:\"vehicle_id\"`\n\tFuelAmount  float64 `gorm:\"column:fuel_amount\" json:\"fuel_amount\"`\n\tCost        float64 `gorm:\"column:cost\" json:\"cost\"`\n\tStatus      int     `gorm:\"column:status\" json:\"status\"`\n\tRecordedAt  int64   `gorm:\"column:recorded_at\" json:\"recorded_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (fc *FuelConsumption) TableName() string {\n\treturn FuelConsumptionTableName\n}"
      },
      {
        "code_key": "FuelStatusActive",
        "code_value": "const FuelStatusActive = 1"
      },
      {
        "code_key": "FuelStatusInactive",
        "code_value": "const FuelStatusInactive = 0"
      },
      {
        "code_key": "FuelStatusArchived",
        "code_value": "const FuelStatusArchived = 2"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/vehicle-service/pkg/utils"
      },
      {
        "code_key": "CountKey",
        "code_value": "const CountKey = \"count\""
      },
      {
        "code_key": "VehicleRecord",
        "code_value": "type VehicleRecord struct {\n\tID          int64   `gorm:\"column:id\" json:\"id\"`\n\tPlateNumber string  `gorm:\"column:plate_number\" json:\"plate_number\"`\n\tModel       string  `gorm:\"column:model\" json:\"model\"`\n\tStatus      int     `gorm:\"column:status\" json:\"status\"`\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CountByStatus",
    "orm_code": "func (repo *BudgetRepo) CountByStatus(ctx context.Context, status int) (int64, error) {\n\tcountClause := utils.SetSQLComment(ctx, utils.CountKey)\n\tvar count int64\n\n\tif err := repo.db.Clauses(countClause).Table(model.BudgetTableName).\n\t\tWhere(\"status = ?\", status).\n\t\tCount(&count).Error; err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn count, nil\n}",
    "caller": "func ProcessBudgetReport(ctx context.Context, dbConn *gorm.DB, targetStatus int) error {\n\tbudgetRepo := &BudgetRepo{db: dbConn}\n\ttotal, err := budgetRepo.CountByStatus(ctx, targetStatus)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"budget status count failed: %w\", err)\n\t}\n\tlog.Printf(\"Found %d budgets with status %d\", total, targetStatus)\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "LACK_INFORMATION",
        "variants": [
          {
            "scenario": "缺少model.BudgetTableName的定义，根据函数名推测表名为budget",
            "sql": "SELECT COUNT(*) FROM budget WHERE status = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "FuelConsumptionRepo",
        "code_value": "type FuelConsumptionRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "FuelConsumptionTableName",
        "code_value": "const FuelConsumptionTableName = \"vehicle_fuel_records\""
      },
      {
        "code_key": "FuelConsumption",
        "code_value": "type FuelConsumption struct {\n\tID          int64   `gorm:\"column:id\" json:\"id\"`\n\tVehicleID   string  `gorm:\"column:vehicle_id\" json:\"vehicle_id\"`\n\tFuelAmount  float64 `gorm:\"column:fuel_amount\" json:\"fuel_amount\"`\n\tCost        float64 `gorm:\"column:cost\" json:\"cost\"`\n\tStatus      int     `gorm:\"column:status\" json:\"status\"`\n\tRecordedAt  int64   `gorm:\"column:recorded_at\" json:\"recorded_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (fc *FuelConsumption) TableName() string {\n\treturn FuelConsumptionTableName\n}"
      },
      {
        "code_key": "FuelStatusActive",
        "code_value": "const FuelStatusActive = 1"
      },
      {
        "code_key": "FuelStatusInactive",
        "code_value": "const FuelStatusInactive = 0"
      },
      {
        "code_key": "FuelStatusArchived",
        "code_value": "const FuelStatusArchived = 2"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/vehicle-service/pkg/utils"
      },
      {
        "code_key": "CountKey",
        "code_value": "const CountKey = \"count\""
      },
      {
        "code_key": "VehicleRecord",
        "code_value": "type VehicleRecord struct {\n\tID          int64   `gorm:\"column:id\" json:\"id\"`\n\tPlateNumber string  `gorm:\"column:plate_number\" json:\"plate_number\"`\n\tModel       string  `gorm:\"column:model\" json:\"model\"`\n\tStatus      int     `gorm:\"column:status\" json:\"status\"`\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CountByStatus",
    "orm_code": "func (repo *BudgetRepo) CountByStatus(ctx context.Context, status int) (int64, error) {\n\tcountClause := utils.SetSQLComment(ctx, utils.CountKey)\n\tvar count int64\n\n\tif err := repo.db.Clauses(countClause).Table(model.BudgetTableName).\n\t\tWhere(\"status = ?\", status).\n\t\tCount(&count).Error; err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn count, nil\n}",
    "caller": "func HandleActiveGuildMembers() (int64, error) {\n\tactiveZone := &Zone{\n\t\tResourceType: 2,\n\t}\n\tmemberCount, err := activeZone.CountByStatus()\n\tif err != nil {\n\t\tlog.Printf(\"Error counting active members: %v\", err)\n\t\treturn 0, err\n\t}\n\treturn memberCount, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Area is empty and ResourceType is 2 (ActiveResource)",
            "sql": "SELECT COUNT(*) FROM guild_memberships WHERE is_active = 1;"
          },
          {
            "scenario": "Area is not empty and ResourceType is 1 (SharedResource)",
            "sql": "SELECT COUNT(*) FROM guild_memberships WHERE area = ? AND is_shared = 1;"
          },
          {
            "scenario": "Area is not empty and ResourceType is 2 (ActiveResource)",
            "sql": "SELECT COUNT(*) FROM guild_memberships WHERE area = ? AND is_active = 1;"
          },
          {
            "scenario": "Area is not empty and ResourceType is 3 (LockedResource)",
            "sql": "SELECT COUNT(*) FROM guild_memberships WHERE area = ? AND is_locked = 1;"
          },
          {
            "scenario": "Area is empty and ResourceType is 1 (SharedResource)",
            "sql": "SELECT COUNT(*) FROM guild_memberships WHERE is_shared = 1;"
          },
          {
            "scenario": "Area is empty and ResourceType is 3 (LockedResource)",
            "sql": "SELECT COUNT(*) FROM guild_memberships WHERE is_locked = 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "FuelConsumptionRepo",
        "code_value": "type FuelConsumptionRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "FuelConsumptionTableName",
        "code_value": "const FuelConsumptionTableName = \"vehicle_fuel_records\""
      },
      {
        "code_key": "FuelConsumption",
        "code_value": "type FuelConsumption struct {\n\tID          int64   `gorm:\"column:id\" json:\"id\"`\n\tVehicleID   string  `gorm:\"column:vehicle_id\" json:\"vehicle_id\"`\n\tFuelAmount  float64 `gorm:\"column:fuel_amount\" json:\"fuel_amount\"`\n\tCost        float64 `gorm:\"column:cost\" json:\"cost\"`\n\tStatus      int     `gorm:\"column:status\" json:\"status\"`\n\tRecordedAt  int64   `gorm:\"column:recorded_at\" json:\"recorded_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (fc *FuelConsumption) TableName() string {\n\treturn FuelConsumptionTableName\n}"
      },
      {
        "code_key": "FuelStatusActive",
        "code_value": "const FuelStatusActive = 1"
      },
      {
        "code_key": "FuelStatusInactive",
        "code_value": "const FuelStatusInactive = 0"
      },
      {
        "code_key": "FuelStatusArchived",
        "code_value": "const FuelStatusArchived = 2"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/vehicle-service/pkg/utils"
      },
      {
        "code_key": "CountKey",
        "code_value": "const CountKey = \"count\""
      },
      {
        "code_key": "VehicleRecord",
        "code_value": "type VehicleRecord struct {\n\tID          int64   `gorm:\"column:id\" json:\"id\"`\n\tPlateNumber string  `gorm:\"column:plate_number\" json:\"plate_number\"`\n\tModel       string  `gorm:\"column:model\" json:\"model\"`\n\tStatus      int     `gorm:\"column:status\" json:\"status\"`\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CountByStatus",
    "orm_code": "func (repo *BudgetRepo) CountByStatus(ctx context.Context, status int) (int64, error) {\n\tcountClause := utils.SetSQLComment(ctx, utils.CountKey)\n\tvar count int64\n\n\tif err := repo.db.Clauses(countClause).Table(model.BudgetTableName).\n\t\tWhere(\"status = ?\", status).\n\t\tCount(&count).Error; err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn count, nil\n}",
    "caller": "func HandleSharedResourcesInArea(area string) (int64, error) {\n\tzoneFilter := &Zone{\n\t\tArea:         area,\n\t\tResourceType: 1,\n\t}\n\tcount, err := zoneFilter.CountByStatus()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to count shared resources in %s: %v\", area, err)\n\t\treturn 0, fmt.Errorf(\"query failed for area %s\", area)\n\t}\n\treturn count, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Count shared resources in specific area",
            "sql": "SELECT COUNT(*) FROM guild_memberships WHERE area = ? AND is_shared = 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "FuelConsumptionRepo",
        "code_value": "type FuelConsumptionRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "FuelConsumptionTableName",
        "code_value": "const FuelConsumptionTableName = \"vehicle_fuel_records\""
      },
      {
        "code_key": "FuelConsumption",
        "code_value": "type FuelConsumption struct {\n\tID          int64   `gorm:\"column:id\" json:\"id\"`\n\tVehicleID   string  `gorm:\"column:vehicle_id\" json:\"vehicle_id\"`\n\tFuelAmount  float64 `gorm:\"column:fuel_amount\" json:\"fuel_amount\"`\n\tCost        float64 `gorm:\"column:cost\" json:\"cost\"`\n\tStatus      int     `gorm:\"column:status\" json:\"status\"`\n\tRecordedAt  int64   `gorm:\"column:recorded_at\" json:\"recorded_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (fc *FuelConsumption) TableName() string {\n\treturn FuelConsumptionTableName\n}"
      },
      {
        "code_key": "FuelStatusActive",
        "code_value": "const FuelStatusActive = 1"
      },
      {
        "code_key": "FuelStatusInactive",
        "code_value": "const FuelStatusInactive = 0"
      },
      {
        "code_key": "FuelStatusArchived",
        "code_value": "const FuelStatusArchived = 2"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/vehicle-service/pkg/utils"
      },
      {
        "code_key": "CountKey",
        "code_value": "const CountKey = \"count\""
      },
      {
        "code_key": "VehicleRecord",
        "code_value": "type VehicleRecord struct {\n\tID          int64   `gorm:\"column:id\" json:\"id\"`\n\tPlateNumber string  `gorm:\"column:plate_number\" json:\"plate_number\"`\n\tModel       string  `gorm:\"column:model\" json:\"model\"`\n\tStatus      int     `gorm:\"column:status\" json:\"status\"`\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CountByStatus",
    "orm_code": "func (repo *BudgetRepo) CountByStatus(ctx context.Context, status int) (int64, error) {\n\tcountClause := utils.SetSQLComment(ctx, utils.CountKey)\n\tvar count int64\n\n\tif err := repo.db.Clauses(countClause).Table(model.BudgetTableName).\n\t\tWhere(\"status = ?\", status).\n\t\tCount(&count).Error; err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn count, nil\n}",
    "caller": "func HandleLockedResourceCheck() bool {\n\tlockCheck := Zone{ResourceType: 3}\n\tlockedCount, err := lockCheck.CountByStatus()\n\tif err != nil || lockedCount == 0 {\n\t\treturn false\n\t}\n\treturn true\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "ResourceType: 1 (SharedResource), Area not set",
            "sql": "SELECT COUNT(*) FROM guild_memberships WHERE is_shared = 1;"
          },
          {
            "scenario": "ResourceType: 2 (ActiveResource), Area not set",
            "sql": "SELECT COUNT(*) FROM guild_memberships WHERE is_active = 1;"
          },
          {
            "scenario": "ResourceType: 3 (LockedResource), Area not set",
            "sql": "SELECT COUNT(*) FROM guild_memberships WHERE is_locked = 1;"
          },
          {
            "scenario": "ResourceType: 1 (SharedResource), Area set to 'north'",
            "sql": "SELECT COUNT(*) FROM guild_memberships WHERE is_shared = 1 AND area = 'north';"
          },
          {
            "scenario": "ResourceType: 2 (ActiveResource), Area set to 'south'",
            "sql": "SELECT COUNT(*) FROM guild_memberships WHERE is_active = 1 AND area = 'south';"
          },
          {
            "scenario": "ResourceType: 3 (LockedResource), Area set to 'east'",
            "sql": "SELECT COUNT(*) FROM guild_memberships WHERE is_locked = 1 AND area = 'east';"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "FuelConsumptionRepo",
        "code_value": "type FuelConsumptionRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "FuelConsumptionTableName",
        "code_value": "const FuelConsumptionTableName = \"vehicle_fuel_records\""
      },
      {
        "code_key": "FuelConsumption",
        "code_value": "type FuelConsumption struct {\n\tID          int64   `gorm:\"column:id\" json:\"id\"`\n\tVehicleID   string  `gorm:\"column:vehicle_id\" json:\"vehicle_id\"`\n\tFuelAmount  float64 `gorm:\"column:fuel_amount\" json:\"fuel_amount\"`\n\tCost        float64 `gorm:\"column:cost\" json:\"cost\"`\n\tStatus      int     `gorm:\"column:status\" json:\"status\"`\n\tRecordedAt  int64   `gorm:\"column:recorded_at\" json:\"recorded_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (fc *FuelConsumption) TableName() string {\n\treturn FuelConsumptionTableName\n}"
      },
      {
        "code_key": "FuelStatusActive",
        "code_value": "const FuelStatusActive = 1"
      },
      {
        "code_key": "FuelStatusInactive",
        "code_value": "const FuelStatusInactive = 0"
      },
      {
        "code_key": "FuelStatusArchived",
        "code_value": "const FuelStatusArchived = 2"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/vehicle-service/pkg/utils"
      },
      {
        "code_key": "CountKey",
        "code_value": "const CountKey = \"count\""
      },
      {
        "code_key": "VehicleRecord",
        "code_value": "type VehicleRecord struct {\n\tID          int64   `gorm:\"column:id\" json:\"id\"`\n\tPlateNumber string  `gorm:\"column:plate_number\" json:\"plate_number\"`\n\tModel       string  `gorm:\"column:model\" json:\"model\"`\n\tStatus      int     `gorm:\"column:status\" json:\"status\"`\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "MeasureEfficiency",
    "orm_code": "func (repo *ContainerRepo) MeasureEfficiency(ctx context.Context, containerID string) (float64, error) {\n\tconst EfficiencyThreshold = 0.7\n\tvar container model.Container\n\t\n\tif err := repo.db.Table(model.ContainerTableName).\n\t\tWhere(\"container_id = ?\", containerID).\n\t\tFirst(&container).Error; err != nil {\n\t\treturn 0, err\n\t}\n\t\n\tefficiency := float64(container.ProcessedUnits) / float64(container.TotalCapacity)\n\tif efficiency < EfficiencyThreshold {\n\t\tif err := repo.db.Table(model.ContainerTableName).\n\t\t\tWhere(\"container_id = ?\", containerID).\n\t\t\tUpdate(\"status\", model.StatusNeedsMaintenance).Error; err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\t\n\treturn efficiency, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "CategoryType == 0",
            "sql": "SELECT * FROM content_licenses WHERE status = 1 ORDER BY created_at DESC;"
          },
          {
            "scenario": "CategoryType == 1",
            "sql": "SELECT * FROM content_licenses WHERE status = 1 AND gross_value = 100 ORDER BY created_at DESC;"
          },
          {
            "scenario": "CategoryType == 2",
            "sql": "SELECT * FROM content_licenses WHERE status = 1 AND gross_value = 200 ORDER BY created_at DESC;"
          },
          {
            "scenario": "CategoryType == 3",
            "sql": "SELECT * FROM content_licenses WHERE status = 1 AND configuration_key = 'premium' ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Container",
        "code_value": "type Container struct {\n\tContainerID     string `gorm:\"column:container_id\" json:\"container_id\"`\n\tProcessedUnits  int    `gorm:\"column:processed_units\" json:\"processed_units\"`\n\tTotalCapacity   int    `gorm:\"column:total_capacity\" json:\"total_capacity\"`\n\tStatus          string `gorm:\"column:status\" json:\"status\"`\n}"
      },
      {
        "code_key": "ContainerTableName",
        "code_value": "const ContainerTableName = \"container_metrics\""
      },
      {
        "code_key": "StatusNeedsMaintenance",
        "code_value": "const StatusNeedsMaintenance = \"NEEDS_MAINTENANCE\""
      },
      {
        "code_key": "ContainerRepo",
        "code_value": "type ContainerRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "EfficiencyThreshold",
        "code_value": "const EfficiencyThreshold = 0.7"
      },
      {
        "code_key": "EfficiencyReport",
        "code_value": "type EfficiencyReport struct {\n\tContainerID string  `json:\"container_id\"`\n\tEfficiency  float64 `json:\"efficiency\"`\n\tStatus      string  `json:\"status\"`\n}"
      },
      {
        "code_key": "ContainerStatus",
        "code_value": "type ContainerStatus string"
      },
      {
        "code_key": "TableName",
        "code_value": "func (c *Container) TableName() string {\n\treturn ContainerTableName\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "MeasureEfficiency",
    "orm_code": "func (repo *ContainerRepo) MeasureEfficiency(ctx context.Context, containerID string) (float64, error) {\n\tconst EfficiencyThreshold = 0.7\n\tvar container model.Container\n\t\n\tif err := repo.db.Table(model.ContainerTableName).\n\t\tWhere(\"container_id = ?\", containerID).\n\t\tFirst(&container).Error; err != nil {\n\t\treturn 0, err\n\t}\n\t\n\tefficiency := float64(container.ProcessedUnits) / float64(container.TotalCapacity)\n\tif efficiency < EfficiencyThreshold {\n\t\tif err := repo.db.Table(model.ContainerTableName).\n\t\t\tWhere(\"container_id = ?\", containerID).\n\t\t\tUpdate(\"status\", model.StatusNeedsMaintenance).Error; err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\t\n\treturn efficiency, nil\n}",
    "caller": "func HandleContainerEfficiency(containerRepo *ContainerRepo, containerID string) {\n\tctx := context.Background()\n\teff, err := containerRepo.MeasureEfficiency(ctx, containerID)\n\tif err != nil {\n\t\tlog.Printf(\"Error measuring container efficiency: %v\", err)\n\t\treturn\n\t}\n\tlog.Printf(\"Container %s efficiency: %.2f\", containerID, eff)\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "效率高于阈值（仅执行SELECT）",
            "sql": "SELECT container_id, processed_units, total_capacity, status FROM container_metrics WHERE container_id = ? LIMIT 1;"
          },
          {
            "scenario": "效率低于阈值（执行SELECT+UPDATE）",
            "sql": "SELECT container_id, processed_units, total_capacity, status FROM container_metrics WHERE container_id = ? LIMIT 1; UPDATE container_metrics SET status = 'NEEDS_MAINTENANCE' WHERE container_id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "Container",
        "code_value": "type Container struct {\n\tContainerID     string `gorm:\"column:container_id\" json:\"container_id\"`\n\tProcessedUnits  int    `gorm:\"column:processed_units\" json:\"processed_units\"`\n\tTotalCapacity   int    `gorm:\"column:total_capacity\" json:\"total_capacity\"`\n\tStatus          string `gorm:\"column:status\" json:\"status\"`\n}"
      },
      {
        "code_key": "ContainerTableName",
        "code_value": "const ContainerTableName = \"container_metrics\""
      },
      {
        "code_key": "StatusNeedsMaintenance",
        "code_value": "const StatusNeedsMaintenance = \"NEEDS_MAINTENANCE\""
      },
      {
        "code_key": "ContainerRepo",
        "code_value": "type ContainerRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "EfficiencyThreshold",
        "code_value": "const EfficiencyThreshold = 0.7"
      },
      {
        "code_key": "EfficiencyReport",
        "code_value": "type EfficiencyReport struct {\n\tContainerID string  `json:\"container_id\"`\n\tEfficiency  float64 `json:\"efficiency\"`\n\tStatus      string  `json:\"status\"`\n}"
      },
      {
        "code_key": "ContainerStatus",
        "code_value": "type ContainerStatus string"
      },
      {
        "code_key": "TableName",
        "code_value": "func (c *Container) TableName() string {\n\treturn ContainerTableName\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "MeasureEfficiency",
    "orm_code": "func (repo *ContainerRepo) MeasureEfficiency(ctx context.Context, containerID string) (float64, error) {\n\tconst EfficiencyThreshold = 0.7\n\tvar container model.Container\n\t\n\tif err := repo.db.Table(model.ContainerTableName).\n\t\tWhere(\"container_id = ?\", containerID).\n\t\tFirst(&container).Error; err != nil {\n\t\treturn 0, err\n\t}\n\t\n\tefficiency := float64(container.ProcessedUnits) / float64(container.TotalCapacity)\n\tif efficiency < EfficiencyThreshold {\n\t\tif err := repo.db.Table(model.ContainerTableName).\n\t\t\tWhere(\"container_id = ?\", containerID).\n\t\t\tUpdate(\"status\", model.StatusNeedsMaintenance).Error; err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\t\n\treturn efficiency, nil\n}",
    "caller": "func MonitorFleetEfficiency(db *gorm.DB, containerIDs []string) map[string]float64 {\n\tresults := make(map[string]float64)\n\trepo := &ContainerRepo{db: db}\n\tctx := context.Background()\n\n\tfor _, id := range containerIDs {\n\t\teff, err := repo.MeasureEfficiency(ctx, id)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Skipping container %s due to error: %v\", id, err)\n\t\t\tcontinue\n\t\t}\n\t\tresults[id] = eff\n\t}\n\n\treturn results\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Select container data",
            "sql": "SELECT container_id, processed_units, total_capacity, status FROM container_metrics WHERE container_id = ? LIMIT 1;"
          },
          {
            "scenario": "Update container status when efficiency < 0.7",
            "sql": "UPDATE container_metrics SET status = 'NEEDS_MAINTENANCE' WHERE container_id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "Container",
        "code_value": "type Container struct {\n\tContainerID     string `gorm:\"column:container_id\" json:\"container_id\"`\n\tProcessedUnits  int    `gorm:\"column:processed_units\" json:\"processed_units\"`\n\tTotalCapacity   int    `gorm:\"column:total_capacity\" json:\"total_capacity\"`\n\tStatus          string `gorm:\"column:status\" json:\"status\"`\n}"
      },
      {
        "code_key": "ContainerTableName",
        "code_value": "const ContainerTableName = \"container_metrics\""
      },
      {
        "code_key": "StatusNeedsMaintenance",
        "code_value": "const StatusNeedsMaintenance = \"NEEDS_MAINTENANCE\""
      },
      {
        "code_key": "ContainerRepo",
        "code_value": "type ContainerRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "EfficiencyThreshold",
        "code_value": "const EfficiencyThreshold = 0.7"
      },
      {
        "code_key": "EfficiencyReport",
        "code_value": "type EfficiencyReport struct {\n\tContainerID string  `json:\"container_id\"`\n\tEfficiency  float64 `json:\"efficiency\"`\n\tStatus      string  `json:\"status\"`\n}"
      },
      {
        "code_key": "ContainerStatus",
        "code_value": "type ContainerStatus string"
      },
      {
        "code_key": "TableName",
        "code_value": "func (c *Container) TableName() string {\n\treturn ContainerTableName\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "MeasureEfficiency",
    "orm_code": "func (repo *ContainerRepo) MeasureEfficiency(ctx context.Context, containerID string) (float64, error) {\n\tconst EfficiencyThreshold = 0.7\n\tvar container model.Container\n\t\n\tif err := repo.db.Table(model.ContainerTableName).\n\t\tWhere(\"container_id = ?\", containerID).\n\t\tFirst(&container).Error; err != nil {\n\t\treturn 0, err\n\t}\n\t\n\tefficiency := float64(container.ProcessedUnits) / float64(container.TotalCapacity)\n\tif efficiency < EfficiencyThreshold {\n\t\tif err := repo.db.Table(model.ContainerTableName).\n\t\t\tWhere(\"container_id = ?\", containerID).\n\t\t\tUpdate(\"status\", model.StatusNeedsMaintenance).Error; err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\t\n\treturn efficiency, nil\n}",
    "caller": "func HandlePremiumContent() ([]Portfolio, error) {\n\tcontentSection := Section{CategoryType: 3}\n\tpremiumPortfolios, err := contentSection.MeasureEfficiency()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to measure premium content efficiency: %v\", err)\n\t}\n\treturn premiumPortfolios, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "CategoryType=3 (called by HandlePremiumContent)",
            "sql": "SELECT id, gross_value, configuration_key, status, created_at FROM content_licenses WHERE status = 1 AND configuration_key = 'premium' ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Container",
        "code_value": "type Container struct {\n\tContainerID     string `gorm:\"column:container_id\" json:\"container_id\"`\n\tProcessedUnits  int    `gorm:\"column:processed_units\" json:\"processed_units\"`\n\tTotalCapacity   int    `gorm:\"column:total_capacity\" json:\"total_capacity\"`\n\tStatus          string `gorm:\"column:status\" json:\"status\"`\n}"
      },
      {
        "code_key": "ContainerTableName",
        "code_value": "const ContainerTableName = \"container_metrics\""
      },
      {
        "code_key": "StatusNeedsMaintenance",
        "code_value": "const StatusNeedsMaintenance = \"NEEDS_MAINTENANCE\""
      },
      {
        "code_key": "ContainerRepo",
        "code_value": "type ContainerRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "EfficiencyThreshold",
        "code_value": "const EfficiencyThreshold = 0.7"
      },
      {
        "code_key": "EfficiencyReport",
        "code_value": "type EfficiencyReport struct {\n\tContainerID string  `json:\"container_id\"`\n\tEfficiency  float64 `json:\"efficiency\"`\n\tStatus      string  `json:\"status\"`\n}"
      },
      {
        "code_key": "ContainerStatus",
        "code_value": "type ContainerStatus string"
      },
      {
        "code_key": "TableName",
        "code_value": "func (c *Container) TableName() string {\n\treturn ContainerTableName\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "MeasureEfficiency",
    "orm_code": "func (repo *ContainerRepo) MeasureEfficiency(ctx context.Context, containerID string) (float64, error) {\n\tconst EfficiencyThreshold = 0.7\n\tvar container model.Container\n\t\n\tif err := repo.db.Table(model.ContainerTableName).\n\t\tWhere(\"container_id = ?\", containerID).\n\t\tFirst(&container).Error; err != nil {\n\t\treturn 0, err\n\t}\n\t\n\tefficiency := float64(container.ProcessedUnits) / float64(container.TotalCapacity)\n\tif efficiency < EfficiencyThreshold {\n\t\tif err := repo.db.Table(model.ContainerTableName).\n\t\t\tWhere(\"container_id = ?\", containerID).\n\t\t\tUpdate(\"status\", model.StatusNeedsMaintenance).Error; err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\t\n\treturn efficiency, nil\n}",
    "caller": "func AnalyzeHighValueAssets(category int) ([]Portfolio, error) {\n\tif category < 1 || category > 2 {\n\t\treturn nil, errors.New(\"invalid category for high value assets\")\n\t}\n\tassetSection := Section{CategoryType: category}\n\tresults, err := assetSection.MeasureEfficiency()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"high value analysis failed: %v\", err)\n\t}\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "category = 1",
            "sql": "SELECT id, gross_value, configuration_key, status, created_at FROM content_licenses WHERE status = 1 AND gross_value = 100 ORDER BY created_at DESC;"
          },
          {
            "scenario": "category = 2",
            "sql": "SELECT id, gross_value, configuration_key, status, created_at FROM content_licenses WHERE status = 1 AND gross_value = 200 ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Container",
        "code_value": "type Container struct {\n\tContainerID     string `gorm:\"column:container_id\" json:\"container_id\"`\n\tProcessedUnits  int    `gorm:\"column:processed_units\" json:\"processed_units\"`\n\tTotalCapacity   int    `gorm:\"column:total_capacity\" json:\"total_capacity\"`\n\tStatus          string `gorm:\"column:status\" json:\"status\"`\n}"
      },
      {
        "code_key": "ContainerTableName",
        "code_value": "const ContainerTableName = \"container_metrics\""
      },
      {
        "code_key": "StatusNeedsMaintenance",
        "code_value": "const StatusNeedsMaintenance = \"NEEDS_MAINTENANCE\""
      },
      {
        "code_key": "ContainerRepo",
        "code_value": "type ContainerRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "EfficiencyThreshold",
        "code_value": "const EfficiencyThreshold = 0.7"
      },
      {
        "code_key": "EfficiencyReport",
        "code_value": "type EfficiencyReport struct {\n\tContainerID string  `json:\"container_id\"`\n\tEfficiency  float64 `json:\"efficiency\"`\n\tStatus      string  `json:\"status\"`\n}"
      },
      {
        "code_key": "ContainerStatus",
        "code_value": "type ContainerStatus string"
      },
      {
        "code_key": "TableName",
        "code_value": "func (c *Container) TableName() string {\n\treturn ContainerTableName\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "MeasureEfficiency",
    "orm_code": "func (repo *ContainerRepo) MeasureEfficiency(ctx context.Context, containerID string) (float64, error) {\n\tconst EfficiencyThreshold = 0.7\n\tvar container model.Container\n\t\n\tif err := repo.db.Table(model.ContainerTableName).\n\t\tWhere(\"container_id = ?\", containerID).\n\t\tFirst(&container).Error; err != nil {\n\t\treturn 0, err\n\t}\n\t\n\tefficiency := float64(container.ProcessedUnits) / float64(container.TotalCapacity)\n\tif efficiency < EfficiencyThreshold {\n\t\tif err := repo.db.Table(model.ContainerTableName).\n\t\t\tWhere(\"container_id = ?\", containerID).\n\t\t\tUpdate(\"status\", model.StatusNeedsMaintenance).Error; err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\t\n\treturn efficiency, nil\n}",
    "caller": "func ProcessActiveLicenses() error {\n\tdefaultSection := Section{CategoryType: 0}\n\tactivePortfolios, err := defaultSection.MeasureEfficiency()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"license processing error: %v\", err)\n\t}\n\tif len(activePortfolios) == 0 {\n\t\treturn errors.New(\"no active licenses found\")\n\t}\n\t// Process portfolios here\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "CategoryType=0",
            "sql": "SELECT id, gross_value, configuration_key, status, created_at FROM content_licenses WHERE status = 1 ORDER BY created_at DESC;"
          },
          {
            "scenario": "CategoryType=1",
            "sql": "SELECT id, gross_value, configuration_key, status, created_at FROM content_licenses WHERE status = 1 AND gross_value = 100 ORDER BY created_at DESC;"
          },
          {
            "scenario": "CategoryType=2",
            "sql": "SELECT id, gross_value, configuration_key, status, created_at FROM content_licenses WHERE status = 1 AND gross_value = 200 ORDER BY created_at DESC;"
          },
          {
            "scenario": "CategoryType=3",
            "sql": "SELECT id, gross_value, configuration_key, status, created_at FROM content_licenses WHERE status = 1 AND configuration_key = 'premium' ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Container",
        "code_value": "type Container struct {\n\tContainerID     string `gorm:\"column:container_id\" json:\"container_id\"`\n\tProcessedUnits  int    `gorm:\"column:processed_units\" json:\"processed_units\"`\n\tTotalCapacity   int    `gorm:\"column:total_capacity\" json:\"total_capacity\"`\n\tStatus          string `gorm:\"column:status\" json:\"status\"`\n}"
      },
      {
        "code_key": "ContainerTableName",
        "code_value": "const ContainerTableName = \"container_metrics\""
      },
      {
        "code_key": "StatusNeedsMaintenance",
        "code_value": "const StatusNeedsMaintenance = \"NEEDS_MAINTENANCE\""
      },
      {
        "code_key": "ContainerRepo",
        "code_value": "type ContainerRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "EfficiencyThreshold",
        "code_value": "const EfficiencyThreshold = 0.7"
      },
      {
        "code_key": "EfficiencyReport",
        "code_value": "type EfficiencyReport struct {\n\tContainerID string  `json:\"container_id\"`\n\tEfficiency  float64 `json:\"efficiency\"`\n\tStatus      string  `json:\"status\"`\n}"
      },
      {
        "code_key": "ContainerStatus",
        "code_value": "type ContainerStatus string"
      },
      {
        "code_key": "TableName",
        "code_value": "func (c *Container) TableName() string {\n\treturn ContainerTableName\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "ValidatePublication",
    "orm_code": "func (repo *PublicationRepo) ValidatePublication(ctx context.Context, pub *model.Publication) (bool, error) {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\texistingPub := &model.Publication{}\n\n\tif err := repo.db.Clauses(selectClause).Table(model.PublicationTableName).\n\t\tWhere(\"isbn = ? AND edition = ?\", pub.ISBN, pub.Edition).\n\t\tFirst(existingPub).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn true, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif existingPub.Description != pub.Description || existingPub.FullName != pub.FullName {\n\t\treturn false, fmt.Errorf(\"publication validation failed: description or fullName mismatch\")\n\t}\n\n\treturn true, nil\n}",
    "caller": "",
    "sql_statement_list": [
      "SELECT isbn, edition, description, full_name FROM publication WHERE isbn = ? AND edition = ? LIMIT 1;"
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PublicationRepo",
        "code_value": "type PublicationRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Publication",
        "code_value": "type Publication struct {\n\tISBN        string `gorm:\"column:isbn\" json:\"isbn\"`\n\tEdition     string `gorm:\"column:edition\" json:\"edition\"`\n\tDescription string `gorm:\"column:description\" json:\"description\"`\n\tFullName    string `gorm:\"column:full_name\" json:\"full_name\"`\n}"
      },
      {
        "code_key": "PublicationTableName",
        "code_value": "const PublicationTableName = \"publication\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (p *Publication) TableName() string {\n\treturn PublicationTableName\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "DeleteKey",
        "code_value": "const DeleteKey = \"DELETE\""
      },
      {
        "code_key": "existingPub",
        "code_value": "&model.Publication{}"
      },
      {
        "code_key": "selectClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SelectKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-publication/pkg/utils"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ValidatePublication",
    "orm_code": "func (repo *PublicationRepo) ValidatePublication(ctx context.Context, pub *model.Publication) (bool, error) {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\texistingPub := &model.Publication{}\n\n\tif err := repo.db.Clauses(selectClause).Table(model.PublicationTableName).\n\t\tWhere(\"isbn = ? AND edition = ?\", pub.ISBN, pub.Edition).\n\t\tFirst(existingPub).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn true, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif existingPub.Description != pub.Description || existingPub.FullName != pub.FullName {\n\t\treturn false, fmt.Errorf(\"publication validation failed: description or fullName mismatch\")\n\t}\n\n\treturn true, nil\n}",
    "caller": "func ProcessPublicationUpload(ctx context.Context, uploadData *model.Publication, logger *zap.Logger) error {\n\tpubRepo, err := data.NewPublicationRepo()\n\tif err != nil {\n\t\tlogger.Error(\"failed to create publication repo\", zap.Error(err))\n\t\treturn err\n\t}\n\n\tisValid, err := pubRepo.ValidatePublication(ctx, uploadData)\n\tif err != nil {\n\t\tlogger.Error(\"publication validation failed\", zap.Error(err))\n\t\treturn err\n\t}\n\n\tif !isValid {\n\t\treturn fmt.Errorf(\"invalid publication data\")\n\t}\n\n\t// Continue with upload processing\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Query with ISBN and Edition parameters",
            "sql": "SELECT isbn, edition, description, full_name FROM publication WHERE isbn = ? AND edition = ? LIMIT 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PublicationRepo",
        "code_value": "type PublicationRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Publication",
        "code_value": "type Publication struct {\n\tISBN        string `gorm:\"column:isbn\" json:\"isbn\"`\n\tEdition     string `gorm:\"column:edition\" json:\"edition\"`\n\tDescription string `gorm:\"column:description\" json:\"description\"`\n\tFullName    string `gorm:\"column:full_name\" json:\"full_name\"`\n}"
      },
      {
        "code_key": "PublicationTableName",
        "code_value": "const PublicationTableName = \"publication\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (p *Publication) TableName() string {\n\treturn PublicationTableName\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "DeleteKey",
        "code_value": "const DeleteKey = \"DELETE\""
      },
      {
        "code_key": "existingPub",
        "code_value": "&model.Publication{}"
      },
      {
        "code_key": "selectClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SelectKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-publication/pkg/utils"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ValidatePublication",
    "orm_code": "func (repo *PublicationRepo) ValidatePublication(ctx context.Context, pub *model.Publication) (bool, error) {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\texistingPub := &model.Publication{}\n\n\tif err := repo.db.Clauses(selectClause).Table(model.PublicationTableName).\n\t\tWhere(\"isbn = ? AND edition = ?\", pub.ISBN, pub.Edition).\n\t\tFirst(existingPub).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn true, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif existingPub.Description != pub.Description || existingPub.FullName != pub.FullName {\n\t\treturn false, fmt.Errorf(\"publication validation failed: description or fullName mismatch\")\n\t}\n\n\treturn true, nil\n}",
    "caller": "func SyncPublicationCatalog(ctx context.Context, catalogItem *model.Publication, syncID string) (bool, error) {\n\trepo := &data.PublicationRepo{DB: global.DB}\n\n\tvalid, err := repo.ValidatePublication(ctx, catalogItem)\n\tif err != nil {\n\t\tglobal.Metrics.Increment(\"publication_validation_failure\")\n\t\treturn false, fmt.Errorf(\"sync failed for %s: %v\", syncID, err)\n\t}\n\n\tif !valid {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Default query with placeholders",
            "sql": "SELECT * FROM publication WHERE isbn = ? AND edition = ? LIMIT 1;"
          },
          {
            "scenario": "Example query with concrete values",
            "sql": "SELECT * FROM publication WHERE isbn = '1234567890' AND edition = '1st' LIMIT 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PublicationRepo",
        "code_value": "type PublicationRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Publication",
        "code_value": "type Publication struct {\n\tISBN        string `gorm:\"column:isbn\" json:\"isbn\"`\n\tEdition     string `gorm:\"column:edition\" json:\"edition\"`\n\tDescription string `gorm:\"column:description\" json:\"description\"`\n\tFullName    string `gorm:\"column:full_name\" json:\"full_name\"`\n}"
      },
      {
        "code_key": "PublicationTableName",
        "code_value": "const PublicationTableName = \"publication\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (p *Publication) TableName() string {\n\treturn PublicationTableName\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "DeleteKey",
        "code_value": "const DeleteKey = \"DELETE\""
      },
      {
        "code_key": "existingPub",
        "code_value": "&model.Publication{}"
      },
      {
        "code_key": "selectClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SelectKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-publication/pkg/utils"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "GenerateReport",
    "orm_code": "func (repo *ReportRepo) GenerateReport(ctx context.Context, params *model.ReportParams) (*model.ReportResult, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tresult := &model.ReportResult{}\n\n\terr := repo.db.Clauses(queryClause).Table(model.ReportTableName).\n\t\tSelect(\"sum(Credits) as total_credits, count(TrackingId) as record_count\").\n\t\tWhere(\"Language = ?\", params.Language).\n\t\tWhere(\"created_at BETWEEN ? AND ?\", params.StartTime, params.EndTime).\n\t\tGroup(\"Language\").\n\t\tScan(result).Error\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn result, nil\n}",
    "caller": "",
    "sql_statement_list": [
      "SELECT sum(credits) AS total_credits, count(tracking_id) AS record_count FROM monthly_financial_report WHERE language = ? AND created_at BETWEEN ? AND ? GROUP BY language;"
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ReportRepo",
        "code_value": "type ReportRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ReportTableName",
        "code_value": "const ReportTableName = \"monthly_financial_report\""
      },
      {
        "code_key": "ReportParams",
        "code_value": "type ReportParams struct {\n\tLanguage  string\n\tStartTime time.Time\n\tEndTime   time.Time\n}"
      },
      {
        "code_key": "ReportResult",
        "code_value": "type ReportResult struct {\n\tTotalCredits float64 `json:\"total_credits\"`\n\tRecordCount  int64   `json:\"record_count\"`\n}"
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"QUERY\""
      },
      {
        "code_key": "TrackingRecord",
        "code_value": "type TrackingRecord struct {\n\tTrackingId string `gorm:\"column:tracking_id\"`\n\tCredits    float64 `gorm:\"column:credits\"`\n\tLanguage   string `gorm:\"column:language\"`\n\tCreatedAt  time.Time `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (tr *TrackingRecord) TableName() string {\n\treturn ReportTableName\n}"
      },
      {
        "code_key": "CreditStatus",
        "code_value": "const (\n\tCreditStatusPending = iota\n\tCreditProcessed\n\tCreditRejected\n)"
      },
      {
        "code_key": "DefaultLanguage",
        "code_value": "var DefaultLanguage = \"en-US\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "GenerateReport",
    "orm_code": "func (repo *ReportRepo) GenerateReport(ctx context.Context, params *model.ReportParams) (*model.ReportResult, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tresult := &model.ReportResult{}\n\n\terr := repo.db.Clauses(queryClause).Table(model.ReportTableName).\n\t\tSelect(\"sum(Credits) as total_credits, count(TrackingId) as record_count\").\n\t\tWhere(\"Language = ?\", params.Language).\n\t\tWhere(\"created_at BETWEEN ? AND ?\", params.StartTime, params.EndTime).\n\t\tGroup(\"Language\").\n\t\tScan(result).Error\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn result, nil\n}",
    "caller": "func HandleDailyLanguageReport(ctx context.Context, lang string, logger *zap.Logger) (*model.ReportResult, error) {\n\treportRepo, err := data.NewReportRepo()\n\tif err != nil {\n\t\tlogger.Error(\"failed to create report repo\", zap.Error(err))\n\t\treturn nil, err\n\t}\n\n\tparams := &model.ReportParams{\n\t\tLanguage:  lang,\n\t\tStartTime: time.Now().AddDate(0, 0, -1),\n\t\tEndTime:   time.Now(),\n\t}\n\n\tstats, err := reportRepo.GenerateReport(ctx, params)\n\tif err != nil {\n\t\tlogger.Error(\"failed to generate report\", zap.Error(err))\n\t\treturn nil, err\n\t}\n\n\treturn stats, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Default case with parameterized values",
            "sql": "SELECT sum(credits) as total_credits, count(tracking_id) as record_count FROM monthly_financial_report WHERE language = ? AND created_at BETWEEN ? AND ? GROUP BY language;"
          },
          {
            "scenario": "Example with specific parameter values (lang='en-US')",
            "sql": "SELECT sum(credits) as total_credits, count(tracking_id) as record_count FROM monthly_financial_report WHERE language = 'en-US' AND created_at BETWEEN '2023-11-01 12:00:00' AND '2023-11-02 12:00:00' GROUP BY language;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ReportRepo",
        "code_value": "type ReportRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ReportTableName",
        "code_value": "const ReportTableName = \"monthly_financial_report\""
      },
      {
        "code_key": "ReportParams",
        "code_value": "type ReportParams struct {\n\tLanguage  string\n\tStartTime time.Time\n\tEndTime   time.Time\n}"
      },
      {
        "code_key": "ReportResult",
        "code_value": "type ReportResult struct {\n\tTotalCredits float64 `json:\"total_credits\"`\n\tRecordCount  int64   `json:\"record_count\"`\n}"
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"QUERY\""
      },
      {
        "code_key": "TrackingRecord",
        "code_value": "type TrackingRecord struct {\n\tTrackingId string `gorm:\"column:tracking_id\"`\n\tCredits    float64 `gorm:\"column:credits\"`\n\tLanguage   string `gorm:\"column:language\"`\n\tCreatedAt  time.Time `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (tr *TrackingRecord) TableName() string {\n\treturn ReportTableName\n}"
      },
      {
        "code_key": "CreditStatus",
        "code_value": "const (\n\tCreditStatusPending = iota\n\tCreditProcessed\n\tCreditRejected\n)"
      },
      {
        "code_key": "DefaultLanguage",
        "code_value": "var DefaultLanguage = \"en-US\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "GenerateMetrics",
    "orm_code": "func (repo *SectionRepo) GenerateMetrics(ctx context.Context, forecast *model.Forecast) ([]*model.Marketplace, error) {\n\tmetrics := make([]*model.Marketplace, 0)\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\n\tif err := repo.db.Clauses(queryClause).Table(model.AchievementRecordsTableName).\n\t\tWhere(\"product_code = ?\", forecast.ProductCode).\n\t\tWhere(\"nick_name = ?\", forecast.NickName).\n\t\tFind(&metrics).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(metrics) == 0 {\n\t\tdefaultMetric := &model.Marketplace{\n\t\t\tProductCode: forecast.ProductCode,\n\t\t\tNickName:    forecast.NickName,\n\t\t\tStreet:      \"default\",\n\t\t}\n\t\tif err := repo.db.Clauses(queryClause).Table(model.AchievementRecordsTableName).\n\t\t\tCreate(defaultMetric).Error; err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tmetrics = append(metrics, defaultMetric)\n\t}\n\n\treturn metrics, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Zone为EAST，startTime不为空",
            "sql": "SELECT Content, ActivationDate FROM achievement_records WHERE status = 1 AND region = 'east-1' AND ActivationDate >= ?;"
          },
          {
            "scenario": "Zone为WEST，startTime为空",
            "sql": "SELECT Content, ActivationDate FROM achievement_records WHERE status = 1 AND region = 'west-2';"
          },
          {
            "scenario": "Zone为NORTH，startTime不为空",
            "sql": "SELECT Content, ActivationDate FROM achievement_records WHERE status = 1 AND availability_zone = 'north-3' AND ActivationDate >= ?;"
          },
          {
            "scenario": "Zone为空，startTime不为空",
            "sql": "SELECT Content, ActivationDate FROM achievement_records WHERE status = 1 AND ActivationDate >= ?;"
          },
          {
            "scenario": "Zone为空，startTime为空",
            "sql": "SELECT Content, ActivationDate FROM achievement_records WHERE status = 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "SectionRepo",
        "code_value": "type SectionRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Forecast",
        "code_value": "type Forecast struct {\n\tProductCode string `json:\"product_code\"`\n\tNickName    string `json:\"nick_name\"`\n}"
      },
      {
        "code_key": "Marketplace",
        "code_value": "type Marketplace struct {\n\tProductCode string `gorm:\"column:product_code\" json:\"product_code\"`\n\tNickName    string `gorm:\"column:nick_name\" json:\"nick_name\"`\n\tStreet      string `gorm:\"column:street\" json:\"street\"`\n}"
      },
      {
        "code_key": "AchievementRecordsTableName",
        "code_value": "const AchievementRecordsTableName = \"marketplace_achievements\""
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"QUERY\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-marketplace/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Interface {\n\tcomment := icontext.GetSQLCommentFromContext(ctx)\n\tif comment == nil {\n\t\tcomment = &SQLComment{ReqId: uuid.NewString()}\n\t}\n\treturn clause.Comment(fmt.Sprintf(\"/* %s */\", comment.ReqId))\n}"
      },
      {
        "code_key": "SQLComment",
        "code_value": "type SQLComment struct {\n\tReqId string `json:\"req_id\"`\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "GenerateMetrics",
    "orm_code": "func (repo *SectionRepo) GenerateMetrics(ctx context.Context, forecast *model.Forecast) ([]*model.Marketplace, error) {\n\tmetrics := make([]*model.Marketplace, 0)\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\n\tif err := repo.db.Clauses(queryClause).Table(model.AchievementRecordsTableName).\n\t\tWhere(\"product_code = ?\", forecast.ProductCode).\n\t\tWhere(\"nick_name = ?\", forecast.NickName).\n\t\tFind(&metrics).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(metrics) == 0 {\n\t\tdefaultMetric := &model.Marketplace{\n\t\t\tProductCode: forecast.ProductCode,\n\t\t\tNickName:    forecast.NickName,\n\t\t\tStreet:      \"default\",\n\t\t}\n\t\tif err := repo.db.Clauses(queryClause).Table(model.AchievementRecordsTableName).\n\t\t\tCreate(defaultMetric).Error; err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tmetrics = append(metrics, defaultMetric)\n\t}\n\n\treturn metrics, nil\n}",
    "caller": "func HandleMarketplaceMetrics(ctx context.Context, productID string, sellerAlias string, logger *zap.Logger) (*model.Marketplace, error) {\n\trepo, err := data.NewSectionRepo()\n\tif err != nil {\n\t\tlogger.Error(\"failed to initialize section repo\", zap.Error(err))\n\t\treturn nil, err\n\t}\n\n\tforecastData := &model.Forecast{\n\t\tProductCode: productID,\n\t\tNickName:    sellerAlias,\n\t}\n\n\tmarketStats, err := repo.GenerateMetrics(ctx, forecastData)\n\tif err != nil || len(marketStats) == 0 {\n\t\tlogger.Error(\"failed to generate marketplace metrics\", zap.Error(err))\n\t\treturn nil, err\n\t}\n\n\treturn marketStats[0], nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "查询到记录",
            "sql": "SELECT product_code, nick_name, street FROM marketplace_achievements WHERE product_code = ? AND nick_name = ?;"
          },
          {
            "scenario": "未查询到记录",
            "sql": "INSERT INTO marketplace_achievements (product_code, nick_name, street) VALUES (?, ?, 'default');"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "SectionRepo",
        "code_value": "type SectionRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Forecast",
        "code_value": "type Forecast struct {\n\tProductCode string `json:\"product_code\"`\n\tNickName    string `json:\"nick_name\"`\n}"
      },
      {
        "code_key": "Marketplace",
        "code_value": "type Marketplace struct {\n\tProductCode string `gorm:\"column:product_code\" json:\"product_code\"`\n\tNickName    string `gorm:\"column:nick_name\" json:\"nick_name\"`\n\tStreet      string `gorm:\"column:street\" json:\"street\"`\n}"
      },
      {
        "code_key": "AchievementRecordsTableName",
        "code_value": "const AchievementRecordsTableName = \"marketplace_achievements\""
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"QUERY\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-marketplace/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Interface {\n\tcomment := icontext.GetSQLCommentFromContext(ctx)\n\tif comment == nil {\n\t\tcomment = &SQLComment{ReqId: uuid.NewString()}\n\t}\n\treturn clause.Comment(fmt.Sprintf(\"/* %s */\", comment.ReqId))\n}"
      },
      {
        "code_key": "SQLComment",
        "code_value": "type SQLComment struct {\n\tReqId string `json:\"req_id\"`\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "GenerateMetrics",
    "orm_code": "func (repo *SectionRepo) GenerateMetrics(ctx context.Context, forecast *model.Forecast) ([]*model.Marketplace, error) {\n\tmetrics := make([]*model.Marketplace, 0)\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\n\tif err := repo.db.Clauses(queryClause).Table(model.AchievementRecordsTableName).\n\t\tWhere(\"product_code = ?\", forecast.ProductCode).\n\t\tWhere(\"nick_name = ?\", forecast.NickName).\n\t\tFind(&metrics).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(metrics) == 0 {\n\t\tdefaultMetric := &model.Marketplace{\n\t\t\tProductCode: forecast.ProductCode,\n\t\t\tNickName:    forecast.NickName,\n\t\t\tStreet:      \"default\",\n\t\t}\n\t\tif err := repo.db.Clauses(queryClause).Table(model.AchievementRecordsTableName).\n\t\t\tCreate(defaultMetric).Error; err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tmetrics = append(metrics, defaultMetric)\n\t}\n\n\treturn metrics, nil\n}",
    "caller": "func ProcessVendorPerformance(appCtx context.Context, vendor *model.VendorProfile) ([]*model.Marketplace, error) {\n\tdbRepo := &SectionRepo{db: global.GetDB()}\n\n\tperformanceForecast := &model.Forecast{\n\t\tProductCode: vendor.PrimarySKU,\n\t\tNickName:    vendor.StoreName,\n\t}\n\n\tvendorMetrics, err := dbRepo.GenerateMetrics(appCtx, performanceForecast)\n\tif err != nil {\n\t\tglobal.Logger.Errorf(\"vendor %s metrics error: %v\", vendor.ID, err)\n\t\treturn nil, fmt.Errorf(\"metrics generation failed: %w\", err)\n\t}\n\n\treturn vendorMetrics, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "查询到记录（metrics 不为空）",
            "sql": "SELECT product_code, nick_name, street FROM marketplace_achievements WHERE product_code = ? AND nick_name = ?;"
          },
          {
            "scenario": "未查询到记录（metrics 为空）",
            "sql": "INSERT INTO marketplace_achievements (product_code, nick_name, street) VALUES (?, ?, 'default');"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "SectionRepo",
        "code_value": "type SectionRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Forecast",
        "code_value": "type Forecast struct {\n\tProductCode string `json:\"product_code\"`\n\tNickName    string `json:\"nick_name\"`\n}"
      },
      {
        "code_key": "Marketplace",
        "code_value": "type Marketplace struct {\n\tProductCode string `gorm:\"column:product_code\" json:\"product_code\"`\n\tNickName    string `gorm:\"column:nick_name\" json:\"nick_name\"`\n\tStreet      string `gorm:\"column:street\" json:\"street\"`\n}"
      },
      {
        "code_key": "AchievementRecordsTableName",
        "code_value": "const AchievementRecordsTableName = \"marketplace_achievements\""
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"QUERY\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-marketplace/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Interface {\n\tcomment := icontext.GetSQLCommentFromContext(ctx)\n\tif comment == nil {\n\t\tcomment = &SQLComment{ReqId: uuid.NewString()}\n\t}\n\treturn clause.Comment(fmt.Sprintf(\"/* %s */\", comment.ReqId))\n}"
      },
      {
        "code_key": "SQLComment",
        "code_value": "type SQLComment struct {\n\tReqId string `json:\"req_id\"`\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "GenerateMetrics",
    "orm_code": "func (repo *SectionRepo) GenerateMetrics(ctx context.Context, forecast *model.Forecast) ([]*model.Marketplace, error) {\n\tmetrics := make([]*model.Marketplace, 0)\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\n\tif err := repo.db.Clauses(queryClause).Table(model.AchievementRecordsTableName).\n\t\tWhere(\"product_code = ?\", forecast.ProductCode).\n\t\tWhere(\"nick_name = ?\", forecast.NickName).\n\t\tFind(&metrics).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(metrics) == 0 {\n\t\tdefaultMetric := &model.Marketplace{\n\t\t\tProductCode: forecast.ProductCode,\n\t\t\tNickName:    forecast.NickName,\n\t\t\tStreet:      \"default\",\n\t\t}\n\t\tif err := repo.db.Clauses(queryClause).Table(model.AchievementRecordsTableName).\n\t\t\tCreate(defaultMetric).Error; err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tmetrics = append(metrics, defaultMetric)\n\t}\n\n\treturn metrics, nil\n}",
    "caller": "func ProcessContainerMetrics() {\n\tacc := &Account{Zone: \"EAST\"}\n\tmetrics, err := acc.GenerateMetrics(\"2023-01-01\")\n\tif err != nil {\n\t\tlog.Printf(\"Error generating metrics: %v\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Found %d containers\\n\", len(metrics))\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Zone = \"EAST\", startTime = \"2023-01-01\"",
            "sql": "SELECT Content, ActivationDate FROM achievement_records WHERE status = 1 AND region = 'east-1' AND ActivationDate >= '2023-01-01';"
          },
          {
            "scenario": "Zone = \"WEST\", startTime = \"2023-01-01\"",
            "sql": "SELECT Content, ActivationDate FROM achievement_records WHERE status = 1 AND region = 'west-2' AND ActivationDate >= '2023-01-01';"
          },
          {
            "scenario": "Zone = \"NORTH\", startTime = \"2023-01-01\"",
            "sql": "SELECT Content, ActivationDate FROM achievement_records WHERE status = 1 AND availability_zone = 'north-3' AND ActivationDate >= '2023-01-01';"
          },
          {
            "scenario": "Zone = \"\", startTime = \"2023-01-01\"",
            "sql": "SELECT Content, ActivationDate FROM achievement_records WHERE status = 1 AND ActivationDate >= '2023-01-01';"
          },
          {
            "scenario": "Zone = \"EAST\", startTime = \"\"",
            "sql": "SELECT Content, ActivationDate FROM achievement_records WHERE status = 1 AND region = 'east-1';"
          },
          {
            "scenario": "Zone = \"\", startTime = \"\"",
            "sql": "SELECT Content, ActivationDate FROM achievement_records WHERE status = 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "SectionRepo",
        "code_value": "type SectionRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Forecast",
        "code_value": "type Forecast struct {\n\tProductCode string `json:\"product_code\"`\n\tNickName    string `json:\"nick_name\"`\n}"
      },
      {
        "code_key": "Marketplace",
        "code_value": "type Marketplace struct {\n\tProductCode string `gorm:\"column:product_code\" json:\"product_code\"`\n\tNickName    string `gorm:\"column:nick_name\" json:\"nick_name\"`\n\tStreet      string `gorm:\"column:street\" json:\"street\"`\n}"
      },
      {
        "code_key": "AchievementRecordsTableName",
        "code_value": "const AchievementRecordsTableName = \"marketplace_achievements\""
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"QUERY\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-marketplace/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Interface {\n\tcomment := icontext.GetSQLCommentFromContext(ctx)\n\tif comment == nil {\n\t\tcomment = &SQLComment{ReqId: uuid.NewString()}\n\t}\n\treturn clause.Comment(fmt.Sprintf(\"/* %s */\", comment.ReqId))\n}"
      },
      {
        "code_key": "SQLComment",
        "code_value": "type SQLComment struct {\n\tReqId string `json:\"req_id\"`\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "GenerateMetrics",
    "orm_code": "func (repo *SectionRepo) GenerateMetrics(ctx context.Context, forecast *model.Forecast) ([]*model.Marketplace, error) {\n\tmetrics := make([]*model.Marketplace, 0)\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\n\tif err := repo.db.Clauses(queryClause).Table(model.AchievementRecordsTableName).\n\t\tWhere(\"product_code = ?\", forecast.ProductCode).\n\t\tWhere(\"nick_name = ?\", forecast.NickName).\n\t\tFind(&metrics).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(metrics) == 0 {\n\t\tdefaultMetric := &model.Marketplace{\n\t\t\tProductCode: forecast.ProductCode,\n\t\t\tNickName:    forecast.NickName,\n\t\t\tStreet:      \"default\",\n\t\t}\n\t\tif err := repo.db.Clauses(queryClause).Table(model.AchievementRecordsTableName).\n\t\t\tCreate(defaultMetric).Error; err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tmetrics = append(metrics, defaultMetric)\n\t}\n\n\treturn metrics, nil\n}",
    "caller": "func AnalyzeZonePerformance(zone string) ([]Container, error) {\n\tacc := &Account{Zone: zone}\n\tresults, err := acc.GenerateMetrics(\"\")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"analysis failed: %w\", err)\n\t}\n\tif len(results) == 0 {\n\t\treturn nil, errors.New(\"no data found\")\n\t}\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Zone为EAST",
            "sql": "SELECT Content, ActivationDate FROM achievement_records WHERE status = 1 AND region = 'east-1';"
          },
          {
            "scenario": "Zone为WEST",
            "sql": "SELECT Content, ActivationDate FROM achievement_records WHERE status = 1 AND region = 'west-2';"
          },
          {
            "scenario": "Zone为NORTH",
            "sql": "SELECT Content, ActivationDate FROM achievement_records WHERE status = 1 AND availability_zone = 'north-3';"
          },
          {
            "scenario": "Zone为空",
            "sql": "SELECT Content, ActivationDate FROM achievement_records WHERE status = 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "SectionRepo",
        "code_value": "type SectionRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Forecast",
        "code_value": "type Forecast struct {\n\tProductCode string `json:\"product_code\"`\n\tNickName    string `json:\"nick_name\"`\n}"
      },
      {
        "code_key": "Marketplace",
        "code_value": "type Marketplace struct {\n\tProductCode string `gorm:\"column:product_code\" json:\"product_code\"`\n\tNickName    string `gorm:\"column:nick_name\" json:\"nick_name\"`\n\tStreet      string `gorm:\"column:street\" json:\"street\"`\n}"
      },
      {
        "code_key": "AchievementRecordsTableName",
        "code_value": "const AchievementRecordsTableName = \"marketplace_achievements\""
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"QUERY\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-marketplace/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Interface {\n\tcomment := icontext.GetSQLCommentFromContext(ctx)\n\tif comment == nil {\n\t\tcomment = &SQLComment{ReqId: uuid.NewString()}\n\t}\n\treturn clause.Comment(fmt.Sprintf(\"/* %s */\", comment.ReqId))\n}"
      },
      {
        "code_key": "SQLComment",
        "code_value": "type SQLComment struct {\n\tReqId string `json:\"req_id\"`\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "ForecastDemand",
    "orm_code": "func (repo *ThemeRepo) ForecastDemand(ctx context.Context, audio *model.Audio) (int, error) {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tvar existingTheme model.Theme\n\n\tif err := repo.db.Clauses(selectClause).Table(model.ThemeTableName).\n\t\tWhere(\"product_code = ?\", audio.ProductCode).\n\t\tFirst(&existingTheme).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn 0, nil\n\t\t}\n\t\treturn 0, err\n\t}\n\n\tbalance := existingTheme.Balance * audio.PlaybackFactor\n\treturn int(balance), nil\n}",
    "caller": "",
    "sql_statement_list": [
      "SELECT id, product_code, balance, created_at, updated_at FROM theme_metadata WHERE product_code = ? LIMIT 1;"
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ThemeRepo",
        "code_value": "type ThemeRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ThemeTableName",
        "code_value": "const ThemeTableName = \"theme_metadata\""
      },
      {
        "code_key": "Theme",
        "code_value": "type Theme struct {\n\tID          int64   `gorm:\"column:id\" json:\"id\"`\n\tProductCode string  `gorm:\"column:product_code\" json:\"product_code\"`\n\tBalance     float64 `gorm:\"column:balance\" json:\"balance\"`\n\tCreatedAt   int64   `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt   int64   `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "Audio",
        "code_value": "type Audio struct {\n\tProductCode    string  `json:\"product_code\"`\n\tPlaybackFactor float64 `json:\"playback_factor\"`\n\tDuration       int     `json:\"duration\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (t *Theme) TableName() string {\n\treturn ThemeTableName\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "PlaybackThreshold",
        "code_value": "const PlaybackThreshold = 0.8"
      },
      {
        "code_key": "DefaultBalance",
        "code_value": "const DefaultBalance = 100.0"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ForecastDemand",
    "orm_code": "func (repo *ThemeRepo) ForecastDemand(ctx context.Context, audio *model.Audio) (int, error) {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tvar existingTheme model.Theme\n\n\tif err := repo.db.Clauses(selectClause).Table(model.ThemeTableName).\n\t\tWhere(\"product_code = ?\", audio.ProductCode).\n\t\tFirst(&existingTheme).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn 0, nil\n\t\t}\n\t\treturn 0, err\n\t}\n\n\tbalance := existingTheme.Balance * audio.PlaybackFactor\n\treturn int(balance), nil\n}",
    "caller": "func HandleAudioDemand(ctx context.Context, track *model.Audio, logger *zap.Logger) {\n\trepo, err := data.NewThemeRepo()\n\tif err != nil {\n\t\tlogger.Error(\"Failed to create theme repo\", zap.Error(err))\n\t\treturn\n\t}\n\n\tdemand, err := repo.ForecastDemand(ctx, track)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to forecast demand\", zap.Error(err))\n\t\treturn\n\t}\n\n\tlogger.Info(\"Forecast demand result\", \n\t\tzap.String(\"productCode\", track.ProductCode),\n\t\tzap.Int(\"demand\", demand))\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "根据产品代码查询主题元数据",
            "sql": "SELECT id, product_code, balance, created_at, updated_at FROM theme_metadata WHERE product_code = ? ORDER BY id LIMIT 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ThemeRepo",
        "code_value": "type ThemeRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ThemeTableName",
        "code_value": "const ThemeTableName = \"theme_metadata\""
      },
      {
        "code_key": "Theme",
        "code_value": "type Theme struct {\n\tID          int64   `gorm:\"column:id\" json:\"id\"`\n\tProductCode string  `gorm:\"column:product_code\" json:\"product_code\"`\n\tBalance     float64 `gorm:\"column:balance\" json:\"balance\"`\n\tCreatedAt   int64   `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt   int64   `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "Audio",
        "code_value": "type Audio struct {\n\tProductCode    string  `json:\"product_code\"`\n\tPlaybackFactor float64 `json:\"playback_factor\"`\n\tDuration       int     `json:\"duration\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (t *Theme) TableName() string {\n\treturn ThemeTableName\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "PlaybackThreshold",
        "code_value": "const PlaybackThreshold = 0.8"
      },
      {
        "code_key": "DefaultBalance",
        "code_value": "const DefaultBalance = 100.0"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "LoadByType",
    "orm_code": "func (repo *CertificateRepo) LoadByType(ctx context.Context, sector string) ([]*model.Certificate, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tvar certificates []*model.Certificate\n\n\tif err := repo.db.Clauses(queryClause).Table(model.CertificateTableName).\n\t\tWhere(\"sector = ?\", sector).\n\t\tFind(&certificates).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(certificates) == 0 {\n\t\treturn nil, gorm.ErrRecordNotFound\n\t}\n\n\treturn certificates, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "LACK_INFORMATION",
        "variants": [
          {
            "scenario": "缺少Certificate结构体和CertificateTableName常量的定义，根据上下文推测表名为certificates",
            "sql": "/* app=,user=,session=<generated_uuid>,action=query */ SELECT * FROM certificates WHERE sector = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "OTHER"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PatientRepo",
        "code_value": "type PatientRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "queryClause",
        "code_value": "utils.SetSQLComment(ctx, utils.QueryKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/healthcare/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) hints.Hints {\n\tcommentInfo := icontext.GetSQLCommentFromContext(ctx)\n\tif len(commentInfo.SessionId) < 10 {\n\t\tcommentInfo.SessionId = uuid.New().String()\n\t}\n\n\tcomment := fmt.Sprintf(\"app=%v,user=%v,session=%v,action=%v\", AppName,\n\t\tcommentInfo.UserId, commentInfo.SessionId, commentInfo.Action)\n\treturn hints.CommentBefore(clause, comment)\n}"
      },
      {
        "code_key": "PatientTableName",
        "code_value": "const PatientTableName = \"medical_patients\""
      },
      {
        "code_key": "Patient",
        "code_value": "type Patient struct {\n\tID             int64  `gorm:\"column:id\" json:\"id\"`\n\tMedicalRecord  string `gorm:\"column:medical_record\" json:\"medical_record\"`\n\tName           string `gorm:\"column:name\" json:\"name\"`\n\tAge            int    `gorm:\"column:age\" json:\"age\"`\n\tGender         string `gorm:\"column:gender\" json:\"gender\"`\n\tAdmissionDate  int64  `gorm:\"column:admission_date\" json:\"admission_date\"`\n\tDischargeDate  int64  `gorm:\"column:discharge_date\" json:\"discharge_date\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (p *Patient) TableName() string {\n\treturn PatientTableName\n}"
      },
      {
        "code_key": "insertClause",
        "code_value": "utils.SetSQLComment(ctx, utils.InsertKey)"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      },
      {
        "code_key": "NewsletterRepo",
        "code_value": "type NewsletterRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "NewsletterTableName",
        "code_value": "const NewsletterTableName = \"marketing_newsletters\""
      },
      {
        "code_key": "Newsletter",
        "code_value": "type Newsletter struct {\n\tID          int64  `gorm:\"column:id\" json:\"id\"`\n\tTitle       string `gorm:\"column:title\" json:\"title\"`\n\tContent     string `gorm:\"column:content\" json:\"content\"`\n\tStatus      int    `gorm:\"column:status\" json:\"status\"`\n\tPublishedAt int64  `gorm:\"column:published_at\" json:\"published_at\"`\n\tAuthorId    int64  `gorm:\"column:author_id\" json:\"author_id\"`\n}"
      },
      {
        "code_key": "NewsletterStatus",
        "code_value": "const (\n\tDraft = iota\n\tPendingReview\n\tPublished\n\tArchived\n)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "LoadByType",
    "orm_code": "func (repo *CertificateRepo) LoadByType(ctx context.Context, sector string) ([]*model.Certificate, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tvar certificates []*model.Certificate\n\n\tif err := repo.db.Clauses(queryClause).Table(model.CertificateTableName).\n\t\tWhere(\"sector = ?\", sector).\n\t\tFind(&certificates).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(certificates) == 0 {\n\t\treturn nil, gorm.ErrRecordNotFound\n\t}\n\n\treturn certificates, nil\n}",
    "caller": "func HandleTrainingCertificates(ctx context.Context, db *gorm.DB, industry string) ([]*model.Certificate, error) {\n\trepo := &CertificateRepo{db: db}\n\tcerts, err := repo.LoadByType(ctx, industry)\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, fmt.Errorf(\"no certificates found for sector: %s\", industry)\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to load certificates: %v\", err)\n\t}\n\treturn certs, nil\n}",
    "sql_statement_list": [
      {
        "type": "LACK_INFORMATION",
        "variants": [
          {
            "scenario": "缺少 Certificate 结构体定义和 CertificateTableName 常量值，只能基于结构体名称推测表名为 certificate",
            "sql": "/* app=,user=,session=?,action= */ SELECT * FROM certificate WHERE sector = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "OTHER"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PatientRepo",
        "code_value": "type PatientRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "queryClause",
        "code_value": "utils.SetSQLComment(ctx, utils.QueryKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/healthcare/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) hints.Hints {\n\tcommentInfo := icontext.GetSQLCommentFromContext(ctx)\n\tif len(commentInfo.SessionId) < 10 {\n\t\tcommentInfo.SessionId = uuid.New().String()\n\t}\n\n\tcomment := fmt.Sprintf(\"app=%v,user=%v,session=%v,action=%v\", AppName,\n\t\tcommentInfo.UserId, commentInfo.SessionId, commentInfo.Action)\n\treturn hints.CommentBefore(clause, comment)\n}"
      },
      {
        "code_key": "PatientTableName",
        "code_value": "const PatientTableName = \"medical_patients\""
      },
      {
        "code_key": "Patient",
        "code_value": "type Patient struct {\n\tID             int64  `gorm:\"column:id\" json:\"id\"`\n\tMedicalRecord  string `gorm:\"column:medical_record\" json:\"medical_record\"`\n\tName           string `gorm:\"column:name\" json:\"name\"`\n\tAge            int    `gorm:\"column:age\" json:\"age\"`\n\tGender         string `gorm:\"column:gender\" json:\"gender\"`\n\tAdmissionDate  int64  `gorm:\"column:admission_date\" json:\"admission_date\"`\n\tDischargeDate  int64  `gorm:\"column:discharge_date\" json:\"discharge_date\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (p *Patient) TableName() string {\n\treturn PatientTableName\n}"
      },
      {
        "code_key": "insertClause",
        "code_value": "utils.SetSQLComment(ctx, utils.InsertKey)"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      },
      {
        "code_key": "NewsletterRepo",
        "code_value": "type NewsletterRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "NewsletterTableName",
        "code_value": "const NewsletterTableName = \"marketing_newsletters\""
      },
      {
        "code_key": "Newsletter",
        "code_value": "type Newsletter struct {\n\tID          int64  `gorm:\"column:id\" json:\"id\"`\n\tTitle       string `gorm:\"column:title\" json:\"title\"`\n\tContent     string `gorm:\"column:content\" json:\"content\"`\n\tStatus      int    `gorm:\"column:status\" json:\"status\"`\n\tPublishedAt int64  `gorm:\"column:published_at\" json:\"published_at\"`\n\tAuthorId    int64  `gorm:\"column:author_id\" json:\"author_id\"`\n}"
      },
      {
        "code_key": "NewsletterStatus",
        "code_value": "const (\n\tDraft = iota\n\tPendingReview\n\tPublished\n\tArchived\n)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "LoadByType",
    "orm_code": "func (repo *CertificateRepo) LoadByType(ctx context.Context, sector string) ([]*model.Certificate, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tvar certificates []*model.Certificate\n\n\tif err := repo.db.Clauses(queryClause).Table(model.CertificateTableName).\n\t\tWhere(\"sector = ?\", sector).\n\t\tFind(&certificates).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(certificates) == 0 {\n\t\treturn nil, gorm.ErrRecordNotFound\n\t}\n\n\treturn certificates, nil\n}",
    "caller": "func ProcessSectorCompliance(ctx context.Context, dbConn *gorm.DB, targetSector string) error {\n\tcertRepo := &CertificateRepo{db: dbConn}\n\tvalidCerts, err := certRepo.LoadByType(ctx, targetSector)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"compliance check failed: %v\", err)\n\t}\n\n\tif len(validCerts) < 5 {\n\t\treturn fmt.Errorf(\"insufficient certificates for %s compliance\", targetSector)\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "LACK_INFORMATION",
        "variants": [
          {
            "scenario": "缺少Certificate结构体和CertificateTableName定义，根据上下文推测表名为certificates",
            "sql": "SELECT * FROM certificates WHERE sector = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PatientRepo",
        "code_value": "type PatientRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "queryClause",
        "code_value": "utils.SetSQLComment(ctx, utils.QueryKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/healthcare/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) hints.Hints {\n\tcommentInfo := icontext.GetSQLCommentFromContext(ctx)\n\tif len(commentInfo.SessionId) < 10 {\n\t\tcommentInfo.SessionId = uuid.New().String()\n\t}\n\n\tcomment := fmt.Sprintf(\"app=%v,user=%v,session=%v,action=%v\", AppName,\n\t\tcommentInfo.UserId, commentInfo.SessionId, commentInfo.Action)\n\treturn hints.CommentBefore(clause, comment)\n}"
      },
      {
        "code_key": "PatientTableName",
        "code_value": "const PatientTableName = \"medical_patients\""
      },
      {
        "code_key": "Patient",
        "code_value": "type Patient struct {\n\tID             int64  `gorm:\"column:id\" json:\"id\"`\n\tMedicalRecord  string `gorm:\"column:medical_record\" json:\"medical_record\"`\n\tName           string `gorm:\"column:name\" json:\"name\"`\n\tAge            int    `gorm:\"column:age\" json:\"age\"`\n\tGender         string `gorm:\"column:gender\" json:\"gender\"`\n\tAdmissionDate  int64  `gorm:\"column:admission_date\" json:\"admission_date\"`\n\tDischargeDate  int64  `gorm:\"column:discharge_date\" json:\"discharge_date\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (p *Patient) TableName() string {\n\treturn PatientTableName\n}"
      },
      {
        "code_key": "insertClause",
        "code_value": "utils.SetSQLComment(ctx, utils.InsertKey)"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      },
      {
        "code_key": "NewsletterRepo",
        "code_value": "type NewsletterRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "NewsletterTableName",
        "code_value": "const NewsletterTableName = \"marketing_newsletters\""
      },
      {
        "code_key": "Newsletter",
        "code_value": "type Newsletter struct {\n\tID          int64  `gorm:\"column:id\" json:\"id\"`\n\tTitle       string `gorm:\"column:title\" json:\"title\"`\n\tContent     string `gorm:\"column:content\" json:\"content\"`\n\tStatus      int    `gorm:\"column:status\" json:\"status\"`\n\tPublishedAt int64  `gorm:\"column:published_at\" json:\"published_at\"`\n\tAuthorId    int64  `gorm:\"column:author_id\" json:\"author_id\"`\n}"
      },
      {
        "code_key": "NewsletterStatus",
        "code_value": "const (\n\tDraft = iota\n\tPendingReview\n\tPublished\n\tArchived\n)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "SelectByRange",
    "orm_code": "func (repo *ProposalRepo) SelectByRange(ctx context.Context, startTime int64, endTime int64) ([]*model.Progress, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tresults := make([]*model.Progress, 0)\n\n\tif err := repo.db.Clauses(queryClause).Table(model.ProgressTableName).\n\t\tWhere(\"create_time BETWEEN ? AND ?\", startTime, endTime).\n\t\tWhere(\"processing_state = ?\", model.StateActive).\n\t\tFind(&results).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn results, nil\n}",
    "caller": "",
    "sql_statement_list": [
      "SELECT * FROM proposal_progress WHERE create_time BETWEEN ? AND ? AND processing_state = ?;"
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ProposalRepo",
        "code_value": "type ProposalRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Progress",
        "code_value": "type Progress struct {\n\tID             int64  `gorm:\"column:id\" json:\"id\"`\n\tProposalID     string `gorm:\"column:proposal_id\" json:\"proposal_id\"`\n\tCreateTime     int64  `gorm:\"column:create_time\" json:\"create_time\"`\n\tProcessingState int    `gorm:\"column:processing_state\" json:\"processing_state\"`\n\tCurrentStage   string `gorm:\"column:current_stage\" json:\"current_stage\"`\n}"
      },
      {
        "code_key": "ProgressTableName",
        "code_value": "const ProgressTableName = \"proposal_progress\""
      },
      {
        "code_key": "StateActive",
        "code_value": "const StateActive = 1"
      },
      {
        "code_key": "StateCompleted",
        "code_value": "const StateCompleted = 2"
      },
      {
        "code_key": "StateCancelled",
        "code_value": "const StateCancelled = 3"
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"SELECT\""
      },
      {
        "code_key": "TableNameMethod",
        "code_value": "func (p *Progress) TableName() string {\n\treturn ProgressTableName\n}"
      },
      {
        "code_key": "ProposalContract",
        "code_value": "type ProposalContract struct {\n\tContractID   string `gorm:\"column:contract_id\" json:\"contract_id\"`\n\tContractName string `gorm:\"column:contract_name\" json:\"contract_name\"`\n\tSignDate     int64  `gorm:\"column:sign_date\" json:\"sign_date\"`\n}"
      },
      {
        "code_key": "ContractTableName",
        "code_value": "const ContractTableName = \"proposal_contracts\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "SelectByRange",
    "orm_code": "func (repo *ProposalRepo) SelectByRange(ctx context.Context, startTime int64, endTime int64) ([]*model.Progress, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tresults := make([]*model.Progress, 0)\n\n\tif err := repo.db.Clauses(queryClause).Table(model.ProgressTableName).\n\t\tWhere(\"create_time BETWEEN ? AND ?\", startTime, endTime).\n\t\tWhere(\"processing_state = ?\", model.StateActive).\n\t\tFind(&results).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn results, nil\n}",
    "caller": "func HandleProgressReport(ctx context.Context, logger *zap.Logger) ([]*model.Progress, error) {\n\trepo, err := NewProposalRepo()\n\tif err != nil {\n\t\tlogger.Error(\"failed to initialize proposal repo\", zap.Error(err))\n\t\treturn nil, err\n\t}\n\n\tnow := time.Now().Unix()\n\tlastWeek := now - 7*24*60*60\n\t\n\tactiveProgresses, err := repo.SelectByRange(ctx, lastWeek, now)\n\tif err != nil {\n\t\tlogger.Error(\"failed to fetch active progresses\", \n\t\t\tzap.Int64(\"start_time\", lastWeek),\n\t\t\tzap.Int64(\"end_time\", now),\n\t\t\tzap.Error(err))\n\t\treturn nil, err\n\t}\n\n\treturn activeProgresses, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "查询上周到现在的活跃进度",
            "sql": "SELECT id, proposal_id, create_time, processing_state, current_stage FROM proposal_progress WHERE create_time BETWEEN ? AND ? AND processing_state = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ProposalRepo",
        "code_value": "type ProposalRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Progress",
        "code_value": "type Progress struct {\n\tID             int64  `gorm:\"column:id\" json:\"id\"`\n\tProposalID     string `gorm:\"column:proposal_id\" json:\"proposal_id\"`\n\tCreateTime     int64  `gorm:\"column:create_time\" json:\"create_time\"`\n\tProcessingState int    `gorm:\"column:processing_state\" json:\"processing_state\"`\n\tCurrentStage   string `gorm:\"column:current_stage\" json:\"current_stage\"`\n}"
      },
      {
        "code_key": "ProgressTableName",
        "code_value": "const ProgressTableName = \"proposal_progress\""
      },
      {
        "code_key": "StateActive",
        "code_value": "const StateActive = 1"
      },
      {
        "code_key": "StateCompleted",
        "code_value": "const StateCompleted = 2"
      },
      {
        "code_key": "StateCancelled",
        "code_value": "const StateCancelled = 3"
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"SELECT\""
      },
      {
        "code_key": "TableNameMethod",
        "code_value": "func (p *Progress) TableName() string {\n\treturn ProgressTableName\n}"
      },
      {
        "code_key": "ProposalContract",
        "code_value": "type ProposalContract struct {\n\tContractID   string `gorm:\"column:contract_id\" json:\"contract_id\"`\n\tContractName string `gorm:\"column:contract_name\" json:\"contract_name\"`\n\tSignDate     int64  `gorm:\"column:sign_date\" json:\"sign_date\"`\n}"
      },
      {
        "code_key": "ContractTableName",
        "code_value": "const ContractTableName = \"proposal_contracts\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "SelectByRange",
    "orm_code": "func (repo *ProposalRepo) SelectByRange(ctx context.Context, startTime int64, endTime int64) ([]*model.Progress, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tresults := make([]*model.Progress, 0)\n\n\tif err := repo.db.Clauses(queryClause).Table(model.ProgressTableName).\n\t\tWhere(\"create_time BETWEEN ? AND ?\", startTime, endTime).\n\t\tWhere(\"processing_state = ?\", model.StateActive).\n\t\tFind(&results).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn results, nil\n}",
    "caller": "func ProcessQuarterlyReview(ctx context.Context) error {\n\trepo := &ProposalRepo{db: globalDB}\n\t\n\tcurrentYear := time.Now().Year()\n\tq1Start := time.Date(currentYear, 1, 1, 0, 0, 0, 0, time.UTC).Unix()\n\tq1End := time.Date(currentYear, 3, 31, 23, 59, 59, 0, time.UTC).Unix()\n\t\n\tresults, err := repo.SelectByRange(ctx, q1Start, q1End)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get Q1 progress: %w\", err)\n\t}\n\t\n\tif len(results) == 0 {\n\t\treturn errors.New(\"no active progress in Q1\")\n\t}\n\t\n\t// Process results...\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Standard query with time range and active state",
            "sql": "SELECT id, proposal_id, create_time, processing_state, current_stage FROM proposal_progress WHERE create_time BETWEEN ? AND ? AND processing_state = 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ProposalRepo",
        "code_value": "type ProposalRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Progress",
        "code_value": "type Progress struct {\n\tID             int64  `gorm:\"column:id\" json:\"id\"`\n\tProposalID     string `gorm:\"column:proposal_id\" json:\"proposal_id\"`\n\tCreateTime     int64  `gorm:\"column:create_time\" json:\"create_time\"`\n\tProcessingState int    `gorm:\"column:processing_state\" json:\"processing_state\"`\n\tCurrentStage   string `gorm:\"column:current_stage\" json:\"current_stage\"`\n}"
      },
      {
        "code_key": "ProgressTableName",
        "code_value": "const ProgressTableName = \"proposal_progress\""
      },
      {
        "code_key": "StateActive",
        "code_value": "const StateActive = 1"
      },
      {
        "code_key": "StateCompleted",
        "code_value": "const StateCompleted = 2"
      },
      {
        "code_key": "StateCancelled",
        "code_value": "const StateCancelled = 3"
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"SELECT\""
      },
      {
        "code_key": "TableNameMethod",
        "code_value": "func (p *Progress) TableName() string {\n\treturn ProgressTableName\n}"
      },
      {
        "code_key": "ProposalContract",
        "code_value": "type ProposalContract struct {\n\tContractID   string `gorm:\"column:contract_id\" json:\"contract_id\"`\n\tContractName string `gorm:\"column:contract_name\" json:\"contract_name\"`\n\tSignDate     int64  `gorm:\"column:sign_date\" json:\"sign_date\"`\n}"
      },
      {
        "code_key": "ContractTableName",
        "code_value": "const ContractTableName = \"proposal_contracts\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ConfigureSettings",
    "orm_code": "func (repo *ProjectRepo) ConfigureSettings(ctx context.Context, config *model.ProjectConfig) error {\n\tinsertClause := utils.SetSQLComment(ctx, utils.InsertKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\n\texisting := &model.ProjectConfig{}\n\tif err := repo.db.Table(model.ProjectConfigTableName).\n\t\tWhere(\"application_id = ?\", config.ApplicationId).\n\t\tFirst(existing).Error; err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\tif err := repo.db.Clauses(insertClause).Table(model.ProjectConfigTableName).\n\t\t\t\tCreate(config).Error; err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.ProjectConfigTableName).\n\t\t\tWhere(\"id = ?\", existing.Id).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"points\": config.Points,\n\t\t\t\t\"subject\": config.Subject,\n\t\t\t}).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Update policy settings with security category",
            "sql": "UPDATE market_data SET description = 'High security policy settings applied', contract_number = 'SEC-2023-001', modification_date = ? WHERE id = ?;"
          },
          {
            "scenario": "Update policy settings with privacy category",
            "sql": "UPDATE market_data SET description = 'Strict privacy compliance enabled', contract_number = 'PRV-2023-002', modification_date = ? WHERE id = ?;"
          },
          {
            "scenario": "Update policy settings with retention category",
            "sql": "UPDATE market_data SET description = 'Data retention policy configured', contract_number = 'RET-2023-003', modification_date = ? WHERE id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ProjectRepo",
        "code_value": "type ProjectRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ProjectConfigTableName",
        "code_value": "const ProjectConfigTableName = \"project_config\""
      },
      {
        "code_key": "ProjectConfig",
        "code_value": "type ProjectConfig struct {\n\tId            int64   `gorm:\"column:id\" json:\"id\"`\n\tApplicationId string  `gorm:\"column:application_id\" json:\"application_id\"`\n\tPoints        float64 `gorm:\"column:points\" json:\"points\"`\n\tSubject       string  `gorm:\"column:subject\" json:\"subject\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (pc *ProjectConfig) TableName() string {\n\treturn ProjectConfigTableName\n}"
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "SQLCommentInfo",
        "code_value": "type SQLCommentInfo struct {\n\tAppId    string\n\tOwnerUin string\n\tSubUin   string\n\tAction   string\n\tReqId    string\n}"
      },
      {
        "code_key": "GetSQLCommentFromContext",
        "code_value": "func GetSQLCommentFromContext(ctx context.Context) SQLCommentInfo {\n\t// implementation details\n\treturn SQLCommentInfo{}\n}"
      },
      {
        "code_key": "hints",
        "code_value": "import \"git.woa.com/IVC/ivc-event-alarm/pkg/hints\""
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "ConfigureSettings",
    "orm_code": "func (repo *ProjectRepo) ConfigureSettings(ctx context.Context, config *model.ProjectConfig) error {\n\tinsertClause := utils.SetSQLComment(ctx, utils.InsertKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\n\texisting := &model.ProjectConfig{}\n\tif err := repo.db.Table(model.ProjectConfigTableName).\n\t\tWhere(\"application_id = ?\", config.ApplicationId).\n\t\tFirst(existing).Error; err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\tif err := repo.db.Clauses(insertClause).Table(model.ProjectConfigTableName).\n\t\t\t\tCreate(config).Error; err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.ProjectConfigTableName).\n\t\t\tWhere(\"id = ?\", existing.Id).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"points\": config.Points,\n\t\t\t\t\"subject\": config.Subject,\n\t\t\t}).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
    "caller": "func HandleProjectConfigUpdate(ctx context.Context, appID string, points int, subject string) error {\n\trepo := &ProjectRepo{db: GetDBInstance()}\n\tcfg := &model.ProjectConfig{\n\t\tApplicationId: appID,\n\t\tPoints:       points,\n\t\tSubject:      subject,\n\t}\n\tif err := repo.ConfigureSettings(ctx, cfg); err != nil {\n\t\tlog.Printf(\"Failed to update project config: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      "{\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\n        \"scenario\": \"记录不存在时的SQL序列\",\n        \"sql\": [\n          \"SELECT id, application_id, points, subject FROM project_config WHERE application_id = ? LIMIT 1;\",\n          \"INSERT INTO project_config (application_id, points, subject) VALUES (?, ?, ?);\"\n        ]\n      }",
      "SELECT id, application_id, points, subject FROM project_config WHERE application_id = ? LIMIT 1;",
      "INSERT INTO project_config (application_id, points, subject) VALUES (?, ?, ?);",
      "SELECT id, application_id, points, subject FROM project_config WHERE application_id = ? LIMIT 1;",
      "UPDATE project_config SET points = ?, subject = ? WHERE id = ?;"
    ],
    "sql_types": [
      "OTHER",
      "SELECT",
      "INSERT",
      "SELECT",
      "UPDATE"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "ProjectRepo",
        "code_value": "type ProjectRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ProjectConfigTableName",
        "code_value": "const ProjectConfigTableName = \"project_config\""
      },
      {
        "code_key": "ProjectConfig",
        "code_value": "type ProjectConfig struct {\n\tId            int64   `gorm:\"column:id\" json:\"id\"`\n\tApplicationId string  `gorm:\"column:application_id\" json:\"application_id\"`\n\tPoints        float64 `gorm:\"column:points\" json:\"points\"`\n\tSubject       string  `gorm:\"column:subject\" json:\"subject\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (pc *ProjectConfig) TableName() string {\n\treturn ProjectConfigTableName\n}"
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "SQLCommentInfo",
        "code_value": "type SQLCommentInfo struct {\n\tAppId    string\n\tOwnerUin string\n\tSubUin   string\n\tAction   string\n\tReqId    string\n}"
      },
      {
        "code_key": "GetSQLCommentFromContext",
        "code_value": "func GetSQLCommentFromContext(ctx context.Context) SQLCommentInfo {\n\t// implementation details\n\treturn SQLCommentInfo{}\n}"
      },
      {
        "code_key": "hints",
        "code_value": "import \"git.woa.com/IVC/ivc-event-alarm/pkg/hints\""
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "ConfigureSettings",
    "orm_code": "func (repo *ProjectRepo) ConfigureSettings(ctx context.Context, config *model.ProjectConfig) error {\n\tinsertClause := utils.SetSQLComment(ctx, utils.InsertKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\n\texisting := &model.ProjectConfig{}\n\tif err := repo.db.Table(model.ProjectConfigTableName).\n\t\tWhere(\"application_id = ?\", config.ApplicationId).\n\t\tFirst(existing).Error; err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\tif err := repo.db.Clauses(insertClause).Table(model.ProjectConfigTableName).\n\t\t\t\tCreate(config).Error; err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.ProjectConfigTableName).\n\t\t\tWhere(\"id = ?\", existing.Id).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"points\": config.Points,\n\t\t\t\t\"subject\": config.Subject,\n\t\t\t}).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
    "caller": "func InitDefaultProjectSettings(ctx context.Context) error {\n\trepo := &ProjectRepo{db: globalDB}\n\tdefaultCfg := &model.ProjectConfig{\n\t\tApplicationId: \"default-app\",\n\t\tPoints:       100,\n\t\tSubject:      \"General\",\n\t}\n\treturn repo.ConfigureSettings(ctx, defaultCfg)",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "记录不存在时生成的SQL",
            "sql": "SELECT id, application_id, points, subject FROM project_config WHERE application_id = 'default-app' LIMIT 1;"
          },
          {
            "scenario": "记录存在时生成的SQL",
            "sql": "SELECT id, application_id, points, subject FROM project_config WHERE application_id = 'default-app' LIMIT 1;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "记录不存在时生成的SQL",
            "sql": "INSERT INTO project_config (application_id, points, subject) VALUES ('default-app', 100, 'General');"
          },
          {
            "scenario": "记录存在时生成的SQL",
            "sql": "UPDATE project_config SET points = 100, subject = 'General' WHERE id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ProjectRepo",
        "code_value": "type ProjectRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ProjectConfigTableName",
        "code_value": "const ProjectConfigTableName = \"project_config\""
      },
      {
        "code_key": "ProjectConfig",
        "code_value": "type ProjectConfig struct {\n\tId            int64   `gorm:\"column:id\" json:\"id\"`\n\tApplicationId string  `gorm:\"column:application_id\" json:\"application_id\"`\n\tPoints        float64 `gorm:\"column:points\" json:\"points\"`\n\tSubject       string  `gorm:\"column:subject\" json:\"subject\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (pc *ProjectConfig) TableName() string {\n\treturn ProjectConfigTableName\n}"
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "SQLCommentInfo",
        "code_value": "type SQLCommentInfo struct {\n\tAppId    string\n\tOwnerUin string\n\tSubUin   string\n\tAction   string\n\tReqId    string\n}"
      },
      {
        "code_key": "GetSQLCommentFromContext",
        "code_value": "func GetSQLCommentFromContext(ctx context.Context) SQLCommentInfo {\n\t// implementation details\n\treturn SQLCommentInfo{}\n}"
      },
      {
        "code_key": "hints",
        "code_value": "import \"git.woa.com/IVC/ivc-event-alarm/pkg/hints\""
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "ConfigureSettings",
    "orm_code": "func (repo *ProjectRepo) ConfigureSettings(ctx context.Context, config *model.ProjectConfig) error {\n\tinsertClause := utils.SetSQLComment(ctx, utils.InsertKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\n\texisting := &model.ProjectConfig{}\n\tif err := repo.db.Table(model.ProjectConfigTableName).\n\t\tWhere(\"application_id = ?\", config.ApplicationId).\n\t\tFirst(existing).Error; err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\tif err := repo.db.Clauses(insertClause).Table(model.ProjectConfigTableName).\n\t\t\t\tCreate(config).Error; err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.ProjectConfigTableName).\n\t\t\tWhere(\"id = ?\", existing.Id).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"points\": config.Points,\n\t\t\t\t\"subject\": config.Subject,\n\t\t\t}).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
    "caller": "func SyncProjectConfiguration(ctx context.Context, sourceCfg *ExternalConfig) error {\n\trepo := NewProjectRepository()\n\ttargetCfg := &model.ProjectConfig{\n\t\tApplicationId: sourceCfg.AppID,\n\t\tPoints:       sourceCfg.Score,\n\t\tSubject:      sourceCfg.Category,\n\t}\n\treturn repo.ConfigureSettings(ctx, targetCfg)",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "记录不存在时先查询后插入",
            "sql": "SELECT id, application_id, points, subject FROM project_config WHERE application_id = ? ORDER BY project_config.id LIMIT 1;"
          },
          {
            "scenario": "记录存在时先查询后更新",
            "sql": "SELECT id, application_id, points, subject FROM project_config WHERE application_id = ? ORDER BY project_config.id LIMIT 1;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "记录不存在时执行插入操作",
            "sql": "INSERT INTO project_config (application_id, points, subject) VALUES (?, ?, ?);"
          },
          {
            "scenario": "记录存在时执行更新操作",
            "sql": "UPDATE project_config SET points = ?, subject = ? WHERE id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ProjectRepo",
        "code_value": "type ProjectRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ProjectConfigTableName",
        "code_value": "const ProjectConfigTableName = \"project_config\""
      },
      {
        "code_key": "ProjectConfig",
        "code_value": "type ProjectConfig struct {\n\tId            int64   `gorm:\"column:id\" json:\"id\"`\n\tApplicationId string  `gorm:\"column:application_id\" json:\"application_id\"`\n\tPoints        float64 `gorm:\"column:points\" json:\"points\"`\n\tSubject       string  `gorm:\"column:subject\" json:\"subject\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (pc *ProjectConfig) TableName() string {\n\treturn ProjectConfigTableName\n}"
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "SQLCommentInfo",
        "code_value": "type SQLCommentInfo struct {\n\tAppId    string\n\tOwnerUin string\n\tSubUin   string\n\tAction   string\n\tReqId    string\n}"
      },
      {
        "code_key": "GetSQLCommentFromContext",
        "code_value": "func GetSQLCommentFromContext(ctx context.Context) SQLCommentInfo {\n\t// implementation details\n\treturn SQLCommentInfo{}\n}"
      },
      {
        "code_key": "hints",
        "code_value": "import \"git.woa.com/IVC/ivc-event-alarm/pkg/hints\""
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "ConfigureSettings",
    "orm_code": "func (repo *ProjectRepo) ConfigureSettings(ctx context.Context, config *model.ProjectConfig) error {\n\tinsertClause := utils.SetSQLComment(ctx, utils.InsertKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\n\texisting := &model.ProjectConfig{}\n\tif err := repo.db.Table(model.ProjectConfigTableName).\n\t\tWhere(\"application_id = ?\", config.ApplicationId).\n\t\tFirst(existing).Error; err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\tif err := repo.db.Clauses(insertClause).Table(model.ProjectConfigTableName).\n\t\t\t\tCreate(config).Error; err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.ProjectConfigTableName).\n\t\t\tWhere(\"id = ?\", existing.Id).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"points\": config.Points,\n\t\t\t\t\"subject\": config.Subject,\n\t\t\t}).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
    "caller": "func HandleSecurityPolicy() error {\n\tsecPolicy := &Policy{\n\t\tID:       1001,\n\t\tCategory: \"security\",\n\t}\n\tif err := secPolicy.ConfigureSettings(); err != nil {\n\t\tlog.Printf(\"Failed to configure security policy: %v\", err)\n\t\treturn err\n\t}\n\tlog.Println(\"Security policy configured successfully\")\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Category is security",
            "sql": "UPDATE market_data SET description = 'High security policy settings applied', contract_number = 'SEC-2023-001', modification_date = CURRENT_TIMESTAMP WHERE id = 1001;"
          },
          {
            "scenario": "Category is privacy",
            "sql": "UPDATE market_data SET description = 'Strict privacy compliance enabled', contract_number = 'PRV-2023-002', modification_date = CURRENT_TIMESTAMP WHERE id = ?;"
          },
          {
            "scenario": "Category is retention",
            "sql": "UPDATE market_data SET description = 'Data retention policy configured', contract_number = 'RET-2023-003', modification_date = CURRENT_TIMESTAMP WHERE id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ProjectRepo",
        "code_value": "type ProjectRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ProjectConfigTableName",
        "code_value": "const ProjectConfigTableName = \"project_config\""
      },
      {
        "code_key": "ProjectConfig",
        "code_value": "type ProjectConfig struct {\n\tId            int64   `gorm:\"column:id\" json:\"id\"`\n\tApplicationId string  `gorm:\"column:application_id\" json:\"application_id\"`\n\tPoints        float64 `gorm:\"column:points\" json:\"points\"`\n\tSubject       string  `gorm:\"column:subject\" json:\"subject\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (pc *ProjectConfig) TableName() string {\n\treturn ProjectConfigTableName\n}"
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "SQLCommentInfo",
        "code_value": "type SQLCommentInfo struct {\n\tAppId    string\n\tOwnerUin string\n\tSubUin   string\n\tAction   string\n\tReqId    string\n}"
      },
      {
        "code_key": "GetSQLCommentFromContext",
        "code_value": "func GetSQLCommentFromContext(ctx context.Context) SQLCommentInfo {\n\t// implementation details\n\treturn SQLCommentInfo{}\n}"
      },
      {
        "code_key": "hints",
        "code_value": "import \"git.woa.com/IVC/ivc-event-alarm/pkg/hints\""
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "ConfigureSettings",
    "orm_code": "func (repo *ProjectRepo) ConfigureSettings(ctx context.Context, config *model.ProjectConfig) error {\n\tinsertClause := utils.SetSQLComment(ctx, utils.InsertKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\n\texisting := &model.ProjectConfig{}\n\tif err := repo.db.Table(model.ProjectConfigTableName).\n\t\tWhere(\"application_id = ?\", config.ApplicationId).\n\t\tFirst(existing).Error; err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\tif err := repo.db.Clauses(insertClause).Table(model.ProjectConfigTableName).\n\t\t\t\tCreate(config).Error; err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.ProjectConfigTableName).\n\t\t\tWhere(\"id = ?\", existing.Id).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"points\": config.Points,\n\t\t\t\t\"subject\": config.Subject,\n\t\t\t}).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
    "caller": "func HandlePrivacyUpdate() error {\n\tprivacyRule := &Policy{\n\t\tID:       2002,\n\t\tCategory: \"privacy\",\n\t}\n\terr := privacyRule.ConfigureSettings()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"privacy update failed: %w\", err)\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "security policy update",
            "sql": "UPDATE market_data SET description = 'High security policy settings applied', contract_number = 'SEC-2023-001', modification_date = CURRENT_TIMESTAMP WHERE id = ?;"
          },
          {
            "scenario": "privacy policy update",
            "sql": "UPDATE market_data SET description = 'Strict privacy compliance enabled', contract_number = 'PRV-2023-002', modification_date = CURRENT_TIMESTAMP WHERE id = 2002;"
          },
          {
            "scenario": "retention policy update",
            "sql": "UPDATE market_data SET description = 'Data retention policy configured', contract_number = 'RET-2023-003', modification_date = CURRENT_TIMESTAMP WHERE id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ProjectRepo",
        "code_value": "type ProjectRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ProjectConfigTableName",
        "code_value": "const ProjectConfigTableName = \"project_config\""
      },
      {
        "code_key": "ProjectConfig",
        "code_value": "type ProjectConfig struct {\n\tId            int64   `gorm:\"column:id\" json:\"id\"`\n\tApplicationId string  `gorm:\"column:application_id\" json:\"application_id\"`\n\tPoints        float64 `gorm:\"column:points\" json:\"points\"`\n\tSubject       string  `gorm:\"column:subject\" json:\"subject\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (pc *ProjectConfig) TableName() string {\n\treturn ProjectConfigTableName\n}"
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "SQLCommentInfo",
        "code_value": "type SQLCommentInfo struct {\n\tAppId    string\n\tOwnerUin string\n\tSubUin   string\n\tAction   string\n\tReqId    string\n}"
      },
      {
        "code_key": "GetSQLCommentFromContext",
        "code_value": "func GetSQLCommentFromContext(ctx context.Context) SQLCommentInfo {\n\t// implementation details\n\treturn SQLCommentInfo{}\n}"
      },
      {
        "code_key": "hints",
        "code_value": "import \"git.woa.com/IVC/ivc-event-alarm/pkg/hints\""
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "ConfigureSettings",
    "orm_code": "func (repo *ProjectRepo) ConfigureSettings(ctx context.Context, config *model.ProjectConfig) error {\n\tinsertClause := utils.SetSQLComment(ctx, utils.InsertKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\n\texisting := &model.ProjectConfig{}\n\tif err := repo.db.Table(model.ProjectConfigTableName).\n\t\tWhere(\"application_id = ?\", config.ApplicationId).\n\t\tFirst(existing).Error; err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\tif err := repo.db.Clauses(insertClause).Table(model.ProjectConfigTableName).\n\t\t\t\tCreate(config).Error; err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.ProjectConfigTableName).\n\t\t\tWhere(\"id = ?\", existing.Id).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"points\": config.Points,\n\t\t\t\t\"subject\": config.Subject,\n\t\t\t}).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
    "caller": "func ProcessRetentionPolicy(policyID int) error {\n\tretPolicy := &Policy{\n\t\tID:       policyID,\n\t\tCategory: \"retention\",\n\t}\n\tif err := retPolicy.ConfigureSettings(); err != nil {\n\t\treturn fmt.Errorf(\"retention policy error [ID:%d]: %v\", policyID, err)\n\t}\n\tlog.Printf(\"Updated retention policy %d\", policyID)\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Update policy with retention category",
            "sql": "UPDATE market_data SET description = 'Data retention policy configured', contract_number = 'RET-2023-003', modification_date = CURRENT_TIMESTAMP WHERE id = ?;"
          },
          {
            "scenario": "Update policy with security category",
            "sql": "UPDATE market_data SET description = 'High security policy settings applied', contract_number = 'SEC-2023-001', modification_date = CURRENT_TIMESTAMP WHERE id = ?;"
          },
          {
            "scenario": "Update policy with privacy category",
            "sql": "UPDATE market_data SET description = 'Strict privacy compliance enabled', contract_number = 'PRV-2023-002', modification_date = CURRENT_TIMESTAMP WHERE id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ProjectRepo",
        "code_value": "type ProjectRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ProjectConfigTableName",
        "code_value": "const ProjectConfigTableName = \"project_config\""
      },
      {
        "code_key": "ProjectConfig",
        "code_value": "type ProjectConfig struct {\n\tId            int64   `gorm:\"column:id\" json:\"id\"`\n\tApplicationId string  `gorm:\"column:application_id\" json:\"application_id\"`\n\tPoints        float64 `gorm:\"column:points\" json:\"points\"`\n\tSubject       string  `gorm:\"column:subject\" json:\"subject\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (pc *ProjectConfig) TableName() string {\n\treturn ProjectConfigTableName\n}"
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "SQLCommentInfo",
        "code_value": "type SQLCommentInfo struct {\n\tAppId    string\n\tOwnerUin string\n\tSubUin   string\n\tAction   string\n\tReqId    string\n}"
      },
      {
        "code_key": "GetSQLCommentFromContext",
        "code_value": "func GetSQLCommentFromContext(ctx context.Context) SQLCommentInfo {\n\t// implementation details\n\treturn SQLCommentInfo{}\n}"
      },
      {
        "code_key": "hints",
        "code_value": "import \"git.woa.com/IVC/ivc-event-alarm/pkg/hints\""
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "MatchByPattern",
    "orm_code": "func (repo *BookRepo) MatchByPattern(ctx context.Context, pattern string) ([]*model.Book, error) {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tvar books []*model.Book\n\n\tif err := repo.db.Clauses(selectClause).\n\t\tTable(model.BookTableName).\n\t\tWhere(\"title LIKE ?\", \"%\"+pattern+\"%\").\n\t\tOr(\"MiddleName LIKE ?\", \"%\"+pattern+\"%\").\n\t\tFind(&books).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(books) == 0 {\n\t\tif err := repo.db.Clauses(selectClause).\n\t\t\tTable(model.BookTableName).\n\t\t\tWhere(\"DiscountRate > ?\", 0.5).\n\t\t\tFind(&books).Error; err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn books, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "匹配到符合条件的书籍",
            "sql": "SELECT * FROM books WHERE title LIKE '%golang%' OR middle_name LIKE '%golang%';"
          },
          {
            "scenario": "没有匹配到任何书籍",
            "sql": "SELECT * FROM books WHERE title LIKE '%nonexistentpattern%' OR middle_name LIKE '%nonexistentpattern%';"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "主查询无结果时执行",
            "sql": "SELECT * FROM books WHERE discount_rate > 0.5;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "VideoRepo",
        "code_value": "type VideoRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "VideoTableName",
        "code_value": "const VideoTableName = \"media_videos\""
      },
      {
        "code_key": "Video",
        "code_value": "type Video struct {\n\tID          int64   `gorm:\"column:id\"`\n\tTitle       string  `gorm:\"column:title\"`\n\tDuration    float64 `gorm:\"column:duration\"`\n\tViews       int64   `gorm:\"column:views\"`\n\tIsPublished bool    `gorm:\"column:is_published\"`\n}"
      },
      {
        "code_key": "TestRepo",
        "code_value": "type TestRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "TestTableName",
        "code_value": "const TestTableName = \"user_tests\""
      },
      {
        "code_key": "Test",
        "code_value": "type Test struct {\n\tID         int64   `gorm:\"column:id\"`\n\tUserId     int64   `gorm:\"column:user_id\"`\n\tScore      float64 `gorm:\"column:score\"`\n\tIsComplete bool    `gorm:\"column:is_complete\"`\n}"
      },
      {
        "code_key": "SQLUtils",
        "code_value": "git.woa.com/media-platform/sql-utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Expression {\n\tcommentInfo := GetCommentFromContext(ctx)\n\tif commentInfo == nil {\n\t\treturn clause.Expr{}\n\t}\n\tcomment := fmt.Sprintf(\"app=%s,user=%s\", commentInfo.AppName, commentInfo.UserID)\n\treturn clause.Expr{SQL: \"/* \" + comment + \" */\", Vars: nil}\n}"
      },
      {
        "code_key": "MediaStatus",
        "code_value": "const (\n\tMediaStatusDraft = \"draft\"\n\tMediaStatusPublished = \"published\"\n\tMediaStatusArchived = \"archived\"\n)"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "MatchByPattern",
    "orm_code": "func (repo *BookRepo) MatchByPattern(ctx context.Context, pattern string) ([]*model.Book, error) {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tvar books []*model.Book\n\n\tif err := repo.db.Clauses(selectClause).\n\t\tTable(model.BookTableName).\n\t\tWhere(\"title LIKE ?\", \"%\"+pattern+\"%\").\n\t\tOr(\"MiddleName LIKE ?\", \"%\"+pattern+\"%\").\n\t\tFind(&books).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(books) == 0 {\n\t\tif err := repo.db.Clauses(selectClause).\n\t\t\tTable(model.BookTableName).\n\t\t\tWhere(\"DiscountRate > ?\", 0.5).\n\t\t\tFind(&books).Error; err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn books, nil\n}",
    "caller": "func HandleSearchBooks(ctx context.Context, searchQuery string) ([]*model.Book, error) {\n\tbookStore := &BookRepo{db: GetDBConnection()}\n\tmatchedBooks, err := bookStore.MatchByPattern(ctx, searchQuery)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to search books: %v\", err)\n\t}\n\treturn matchedBooks, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "匹配到与pattern相符的书籍",
            "sql": "SELECT * FROM books WHERE title LIKE ? OR MiddleName LIKE ?;"
          },
          {
            "scenario": "未匹配到与pattern相符的书籍",
            "sql": "SELECT * FROM books WHERE DiscountRate > 0.5;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "VideoRepo",
        "code_value": "type VideoRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "VideoTableName",
        "code_value": "const VideoTableName = \"media_videos\""
      },
      {
        "code_key": "Video",
        "code_value": "type Video struct {\n\tID          int64   `gorm:\"column:id\"`\n\tTitle       string  `gorm:\"column:title\"`\n\tDuration    float64 `gorm:\"column:duration\"`\n\tViews       int64   `gorm:\"column:views\"`\n\tIsPublished bool    `gorm:\"column:is_published\"`\n}"
      },
      {
        "code_key": "TestRepo",
        "code_value": "type TestRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "TestTableName",
        "code_value": "const TestTableName = \"user_tests\""
      },
      {
        "code_key": "Test",
        "code_value": "type Test struct {\n\tID         int64   `gorm:\"column:id\"`\n\tUserId     int64   `gorm:\"column:user_id\"`\n\tScore      float64 `gorm:\"column:score\"`\n\tIsComplete bool    `gorm:\"column:is_complete\"`\n}"
      },
      {
        "code_key": "SQLUtils",
        "code_value": "git.woa.com/media-platform/sql-utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Expression {\n\tcommentInfo := GetCommentFromContext(ctx)\n\tif commentInfo == nil {\n\t\treturn clause.Expr{}\n\t}\n\tcomment := fmt.Sprintf(\"app=%s,user=%s\", commentInfo.AppName, commentInfo.UserID)\n\treturn clause.Expr{SQL: \"/* \" + comment + \" */\", Vars: nil}\n}"
      },
      {
        "code_key": "MediaStatus",
        "code_value": "const (\n\tMediaStatusDraft = \"draft\"\n\tMediaStatusPublished = \"published\"\n\tMediaStatusArchived = \"archived\"\n)"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "MatchByPattern",
    "orm_code": "func (repo *BookRepo) MatchByPattern(ctx context.Context, pattern string) ([]*model.Book, error) {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tvar books []*model.Book\n\n\tif err := repo.db.Clauses(selectClause).\n\t\tTable(model.BookTableName).\n\t\tWhere(\"title LIKE ?\", \"%\"+pattern+\"%\").\n\t\tOr(\"MiddleName LIKE ?\", \"%\"+pattern+\"%\").\n\t\tFind(&books).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(books) == 0 {\n\t\tif err := repo.db.Clauses(selectClause).\n\t\t\tTable(model.BookTableName).\n\t\t\tWhere(\"DiscountRate > ?\", 0.5).\n\t\t\tFind(&books).Error; err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn books, nil\n}",
    "caller": "func ProcessDiscountRecommendations(ctx context.Context) error {\n\tbookHandler := &BookRepo{db: InitDatabase()}\n\tdiscountedBooks, err := bookHandler.MatchByPattern(ctx, \"\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get discounted books: %v\", err)\n\t}\n\tif len(discountedBooks) > 0 {\n\t\tSendRecommendations(discountedBooks)\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "LACK_INFORMATION",
        "variants": [
          {
            "scenario": "缺少Book结构体和BookTableName的定义",
            "sql": "SELECT /* app=?,user=? */ * FROM books WHERE title LIKE '%%' OR MiddleName LIKE '%%';"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "pattern非空且匹配到记录",
            "sql": "SELECT /* app=?,user=? */ * FROM books WHERE title LIKE '%pattern%' OR MiddleName LIKE '%pattern%';"
          },
          {
            "scenario": "pattern非空且未匹配到记录",
            "sql": "SELECT /* app=?,user=? */ * FROM books WHERE DiscountRate > 0.5;"
          }
        ]
      }
    ],
    "sql_types": [
      "SELECT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "VideoRepo",
        "code_value": "type VideoRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "VideoTableName",
        "code_value": "const VideoTableName = \"media_videos\""
      },
      {
        "code_key": "Video",
        "code_value": "type Video struct {\n\tID          int64   `gorm:\"column:id\"`\n\tTitle       string  `gorm:\"column:title\"`\n\tDuration    float64 `gorm:\"column:duration\"`\n\tViews       int64   `gorm:\"column:views\"`\n\tIsPublished bool    `gorm:\"column:is_published\"`\n}"
      },
      {
        "code_key": "TestRepo",
        "code_value": "type TestRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "TestTableName",
        "code_value": "const TestTableName = \"user_tests\""
      },
      {
        "code_key": "Test",
        "code_value": "type Test struct {\n\tID         int64   `gorm:\"column:id\"`\n\tUserId     int64   `gorm:\"column:user_id\"`\n\tScore      float64 `gorm:\"column:score\"`\n\tIsComplete bool    `gorm:\"column:is_complete\"`\n}"
      },
      {
        "code_key": "SQLUtils",
        "code_value": "git.woa.com/media-platform/sql-utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Expression {\n\tcommentInfo := GetCommentFromContext(ctx)\n\tif commentInfo == nil {\n\t\treturn clause.Expr{}\n\t}\n\tcomment := fmt.Sprintf(\"app=%s,user=%s\", commentInfo.AppName, commentInfo.UserID)\n\treturn clause.Expr{SQL: \"/* \" + comment + \" */\", Vars: nil}\n}"
      },
      {
        "code_key": "MediaStatus",
        "code_value": "const (\n\tMediaStatusDraft = \"draft\"\n\tMediaStatusPublished = \"published\"\n\tMediaStatusArchived = \"archived\"\n)"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "VerifyIdentity",
    "orm_code": "func (repo *SecurityRepo) VerifyIdentity(ctx context.Context, template *model.IdentityTemplate) (bool, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tverification := &model.IdentityVerification{}\n\n\tif err := repo.db.Clauses(queryClause).Table(model.SecurityClearancesTableName).\n\t\tWhere(\"function_name = ? AND private_key = ?\", template.FunctionName, template.PrivateKey).\n\t\tFirst(verification).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif verification.RefreshKey != template.RefreshKey {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "AccessLevel = 1 (Emergency)",
            "sql": "SELECT COUNT(*) FROM hospital_departments WHERE status = 1 AND department = 'emergency' AND phone_number = ?;"
          },
          {
            "scenario": "AccessLevel = 2 (Surgery)",
            "sql": "SELECT COUNT(*) FROM hospital_departments WHERE status = 1 AND department = 'surgery' AND phone_number = ?;"
          },
          {
            "scenario": "AccessLevel = 3 (Pediatrics)",
            "sql": "SELECT COUNT(*) FROM hospital_departments WHERE status = 1 AND department = 'pediatrics' AND phone_number = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "SecurityRepo",
        "code_value": "type SecurityRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "IdentityTemplate",
        "code_value": "type IdentityTemplate struct {\n\tFunctionName string `json:\"function_name\"`\n\tPrivateKey   string `json:\"private_key\"`\n\tRefreshKey   string `json:\"refresh_key\"`\n}"
      },
      {
        "code_key": "IdentityVerification",
        "code_value": "type IdentityVerification struct {\n\tFunctionName string `gorm:\"column:function_name\" json:\"function_name\"`\n\tPrivateKey   string `gorm:\"column:private_key\" json:\"private_key\"`\n\tRefreshKey   string `gorm:\"column:refresh_key\" json:\"refresh_key\"`\n\tCreatedAt    int64  `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "SecurityClearancesTableName",
        "code_value": "const SecurityClearancesTableName = \"security_clearances\""
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"QUERY\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-security/pkg/utils"
      },
      {
        "code_key": "TableName",
        "code_value": "func (iv *IdentityVerification) TableName() string {\n\treturn SecurityClearancesTableName\n}"
      },
      {
        "code_key": "hints",
        "code_value": "git.woa.com/IVC/gorm-hints"
      },
      {
        "code_key": "icontext",
        "code_value": "git.woa.com/IVC/ivc-context"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "VerifyIdentity",
    "orm_code": "func (repo *SecurityRepo) VerifyIdentity(ctx context.Context, template *model.IdentityTemplate) (bool, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tverification := &model.IdentityVerification{}\n\n\tif err := repo.db.Clauses(queryClause).Table(model.SecurityClearancesTableName).\n\t\tWhere(\"function_name = ? AND private_key = ?\", template.FunctionName, template.PrivateKey).\n\t\tFirst(verification).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif verification.RefreshKey != template.RefreshKey {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "caller": "func HandleSecurityVerification(ctx context.Context, funcName string, privKey string, refreshToken string) (bool, error) {\n\trepo := &SecurityRepo{db: GetDBInstance()}\n\ttemplate := &model.IdentityTemplate{\n\t\tFunctionName: funcName,\n\t\tPrivateKey:   privKey,\n\t\tRefreshKey:   refreshToken,\n\t}\n\n\tverified, err := repo.VerifyIdentity(ctx, template)\n\tif err != nil {\n\t\tlog.Printf(\"Security verification failed: %v\", err)\n\t\treturn false, err\n\t}\n\n\treturn verified, nil\n}",
    "sql_statement_list": [
      "SELECT function_name, private_key, refresh_key, created_at FROM security_clearances WHERE function_name = ? AND private_key = ? LIMIT 1;"
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "SecurityRepo",
        "code_value": "type SecurityRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "IdentityTemplate",
        "code_value": "type IdentityTemplate struct {\n\tFunctionName string `json:\"function_name\"`\n\tPrivateKey   string `json:\"private_key\"`\n\tRefreshKey   string `json:\"refresh_key\"`\n}"
      },
      {
        "code_key": "IdentityVerification",
        "code_value": "type IdentityVerification struct {\n\tFunctionName string `gorm:\"column:function_name\" json:\"function_name\"`\n\tPrivateKey   string `gorm:\"column:private_key\" json:\"private_key\"`\n\tRefreshKey   string `gorm:\"column:refresh_key\" json:\"refresh_key\"`\n\tCreatedAt    int64  `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "SecurityClearancesTableName",
        "code_value": "const SecurityClearancesTableName = \"security_clearances\""
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"QUERY\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-security/pkg/utils"
      },
      {
        "code_key": "TableName",
        "code_value": "func (iv *IdentityVerification) TableName() string {\n\treturn SecurityClearancesTableName\n}"
      },
      {
        "code_key": "hints",
        "code_value": "git.woa.com/IVC/gorm-hints"
      },
      {
        "code_key": "icontext",
        "code_value": "git.woa.com/IVC/ivc-context"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "VerifyIdentity",
    "orm_code": "func (repo *SecurityRepo) VerifyIdentity(ctx context.Context, template *model.IdentityTemplate) (bool, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tverification := &model.IdentityVerification{}\n\n\tif err := repo.db.Clauses(queryClause).Table(model.SecurityClearancesTableName).\n\t\tWhere(\"function_name = ? AND private_key = ?\", template.FunctionName, template.PrivateKey).\n\t\tFirst(verification).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif verification.RefreshKey != template.RefreshKey {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "caller": "func ProcessApiAuthentication(ctx context.Context, apiCreds *ApiCredentials) error {\n\tsecRepo := NewSecurityRepository()\n\tidentTemplate := &model.IdentityTemplate{\n\t\tFunctionName: apiCreds.Endpoint,\n\t\tPrivateKey:   apiCreds.SecretKey,\n\t\tRefreshKey:   apiCreds.SessionToken,\n\t}\n\n\tisValid, verifyErr := secRepo.VerifyIdentity(ctx, identTemplate)\n\tif verifyErr != nil || !isValid {\n\t\treturn errors.New(\"API authentication failed\")\n\t}\n\n\treturn nil\n}",
    "sql_statement_list": [
      "SELECT * FROM security_clearances WHERE function_name = ? AND private_key = ? ORDER BY security_clearances.function_name, security_clearances.private_key LIMIT 1;"
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "SecurityRepo",
        "code_value": "type SecurityRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "IdentityTemplate",
        "code_value": "type IdentityTemplate struct {\n\tFunctionName string `json:\"function_name\"`\n\tPrivateKey   string `json:\"private_key\"`\n\tRefreshKey   string `json:\"refresh_key\"`\n}"
      },
      {
        "code_key": "IdentityVerification",
        "code_value": "type IdentityVerification struct {\n\tFunctionName string `gorm:\"column:function_name\" json:\"function_name\"`\n\tPrivateKey   string `gorm:\"column:private_key\" json:\"private_key\"`\n\tRefreshKey   string `gorm:\"column:refresh_key\" json:\"refresh_key\"`\n\tCreatedAt    int64  `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "SecurityClearancesTableName",
        "code_value": "const SecurityClearancesTableName = \"security_clearances\""
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"QUERY\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-security/pkg/utils"
      },
      {
        "code_key": "TableName",
        "code_value": "func (iv *IdentityVerification) TableName() string {\n\treturn SecurityClearancesTableName\n}"
      },
      {
        "code_key": "hints",
        "code_value": "git.woa.com/IVC/gorm-hints"
      },
      {
        "code_key": "icontext",
        "code_value": "git.woa.com/IVC/ivc-context"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "VerifyIdentity",
    "orm_code": "func (repo *SecurityRepo) VerifyIdentity(ctx context.Context, template *model.IdentityTemplate) (bool, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tverification := &model.IdentityVerification{}\n\n\tif err := repo.db.Clauses(queryClause).Table(model.SecurityClearancesTableName).\n\t\tWhere(\"function_name = ? AND private_key = ?\", template.FunctionName, template.PrivateKey).\n\t\tFirst(verification).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif verification.RefreshKey != template.RefreshKey {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "caller": "func HandleNurseVerification() {\n\tstaff := &Nurse{\n\t\tAccessLevel: 2,\n\t\tPhoneNumber: \"555-1234\",\n\t}\n\tisValid, err := staff.VerifyIdentity()\n\tif err != nil {\n\t\tlog.Printf(\"Verification failed: %v\", err)\n\t\treturn\n\t}\n\tlog.Printf(\"Nurse verification status: %t\", isValid)\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "AccessLevel = 1 (Emergency)",
            "sql": "SELECT COUNT(*) FROM hospital_departments WHERE status = 1 AND department = 'emergency' AND phone_number = ?;"
          },
          {
            "scenario": "AccessLevel = 2 (Surgery)",
            "sql": "SELECT COUNT(*) FROM hospital_departments WHERE status = 1 AND department = 'surgery' AND phone_number = ?;"
          },
          {
            "scenario": "AccessLevel = 3 (Pediatrics)",
            "sql": "SELECT COUNT(*) FROM hospital_departments WHERE status = 1 AND department = 'pediatrics' AND phone_number = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "SecurityRepo",
        "code_value": "type SecurityRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "IdentityTemplate",
        "code_value": "type IdentityTemplate struct {\n\tFunctionName string `json:\"function_name\"`\n\tPrivateKey   string `json:\"private_key\"`\n\tRefreshKey   string `json:\"refresh_key\"`\n}"
      },
      {
        "code_key": "IdentityVerification",
        "code_value": "type IdentityVerification struct {\n\tFunctionName string `gorm:\"column:function_name\" json:\"function_name\"`\n\tPrivateKey   string `gorm:\"column:private_key\" json:\"private_key\"`\n\tRefreshKey   string `gorm:\"column:refresh_key\" json:\"refresh_key\"`\n\tCreatedAt    int64  `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "SecurityClearancesTableName",
        "code_value": "const SecurityClearancesTableName = \"security_clearances\""
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"QUERY\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-security/pkg/utils"
      },
      {
        "code_key": "TableName",
        "code_value": "func (iv *IdentityVerification) TableName() string {\n\treturn SecurityClearancesTableName\n}"
      },
      {
        "code_key": "hints",
        "code_value": "git.woa.com/IVC/gorm-hints"
      },
      {
        "code_key": "icontext",
        "code_value": "git.woa.com/IVC/ivc-context"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "VerifyIdentity",
    "orm_code": "func (repo *SecurityRepo) VerifyIdentity(ctx context.Context, template *model.IdentityTemplate) (bool, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tverification := &model.IdentityVerification{}\n\n\tif err := repo.db.Clauses(queryClause).Table(model.SecurityClearancesTableName).\n\t\tWhere(\"function_name = ? AND private_key = ?\", template.FunctionName, template.PrivateKey).\n\t\tFirst(verification).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif verification.RefreshKey != template.RefreshKey {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "caller": "func ProcessDepartmentAccess(level int, contact string) error {\n\tmedicalStaff := Nurse{\n\t\tAccessLevel: level,\n\t\tPhoneNumber: contact,\n\t}\n\tapproved, verifyErr := medicalStaff.VerifyIdentity()\n\tif verifyErr != nil {\n\t\treturn fmt.Errorf(\"identity validation error: %w\", verifyErr)\n\t}\n\tif !approved {\n\t\treturn errors.New(\"access denied\")\n\t}\n\tfmt.Println(\"Access granted to restricted department\")\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Emergency department (AccessLevel = 1)",
            "sql": "SELECT COUNT(*) FROM hospital_departments WHERE status = 1 AND department = 'emergency' AND phone_number = ?;"
          },
          {
            "scenario": "Surgery department (AccessLevel = 2)",
            "sql": "SELECT COUNT(*) FROM hospital_departments WHERE status = 1 AND department = 'surgery' AND phone_number = ?;"
          },
          {
            "scenario": "Pediatrics department (AccessLevel = 3)",
            "sql": "SELECT COUNT(*) FROM hospital_departments WHERE status = 1 AND department = 'pediatrics' AND phone_number = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "SecurityRepo",
        "code_value": "type SecurityRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "IdentityTemplate",
        "code_value": "type IdentityTemplate struct {\n\tFunctionName string `json:\"function_name\"`\n\tPrivateKey   string `json:\"private_key\"`\n\tRefreshKey   string `json:\"refresh_key\"`\n}"
      },
      {
        "code_key": "IdentityVerification",
        "code_value": "type IdentityVerification struct {\n\tFunctionName string `gorm:\"column:function_name\" json:\"function_name\"`\n\tPrivateKey   string `gorm:\"column:private_key\" json:\"private_key\"`\n\tRefreshKey   string `gorm:\"column:refresh_key\" json:\"refresh_key\"`\n\tCreatedAt    int64  `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "SecurityClearancesTableName",
        "code_value": "const SecurityClearancesTableName = \"security_clearances\""
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"QUERY\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-security/pkg/utils"
      },
      {
        "code_key": "TableName",
        "code_value": "func (iv *IdentityVerification) TableName() string {\n\treturn SecurityClearancesTableName\n}"
      },
      {
        "code_key": "hints",
        "code_value": "git.woa.com/IVC/gorm-hints"
      },
      {
        "code_key": "icontext",
        "code_value": "git.woa.com/IVC/ivc-context"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "RefreshIndex",
    "orm_code": "func (repo *CarrierRepo) RefreshIndex(ctx context.Context, carrier *model.Carrier) error {\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\toldCarrier := &model.Carrier{}\n\n\tif err := repo.db.Table(model.CarrierTableName).\n\t\tWhere(\"publication = ?\", carrier.Publication).\n\t\tFirst(oldCarrier).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif oldCarrier.ReactivationDate != carrier.ReactivationDate {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.CarrierTableName).\n\t\t\tWhere(\"id = ?\", oldCarrier.Id).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"reactivation_date\": carrier.ReactivationDate,\n\t\t\t\t\"auth_token\":       carrier.AuthToken,\n\t\t\t}).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "production environment",
            "sql": "SELECT id, status, cluster_type, created_at FROM health_metrics WHERE status = 1 AND cluster_type = 'primary' ORDER BY created_at DESC;"
          },
          {
            "scenario": "staging environment",
            "sql": "SELECT id, status, cluster_type, created_at FROM health_metrics WHERE status = 1 AND cluster_type = 'secondary' ORDER BY created_at DESC;"
          },
          {
            "scenario": "development environment",
            "sql": "SELECT id, status, cluster_type, created_at FROM health_metrics WHERE status = 1 AND cluster_type = 'local' ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "CarrierRepo",
        "code_value": "type CarrierRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "CarrierTableName",
        "code_value": "const CarrierTableName = \"ivc_carrier_info\""
      },
      {
        "code_key": "Carrier",
        "code_value": "type Carrier struct {\n\tId               int64   `gorm:\"column:id\" json:\"id\"`\n\tPublication      string  `gorm:\"column:publication\" json:\"publication\"`\n\tReactivationDate int64   `gorm:\"column:reactivation_date\" json:\"reactivation_date\"`\n\tAuthToken        string  `gorm:\"column:auth_token\" json:\"auth_token\"`\n\tStatus           int     `gorm:\"column:status\" json:\"status\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (c *Carrier) TableName() string {\n\treturn CarrierTableName\n}"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-core/pkg/utils"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      },
      {
        "code_key": "CarrierStatusActive",
        "code_value": "const CarrierStatusActive = 1"
      },
      {
        "code_key": "CarrierStatusInactive",
        "code_value": "const CarrierStatusInactive = 0"
      },
      {
        "code_key": "oldCarrier",
        "code_value": "&model.Carrier{}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "RefreshIndex",
    "orm_code": "func (repo *CarrierRepo) RefreshIndex(ctx context.Context, carrier *model.Carrier) error {\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\toldCarrier := &model.Carrier{}\n\n\tif err := repo.db.Table(model.CarrierTableName).\n\t\tWhere(\"publication = ?\", carrier.Publication).\n\t\tFirst(oldCarrier).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif oldCarrier.ReactivationDate != carrier.ReactivationDate {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.CarrierTableName).\n\t\t\tWhere(\"id = ?\", oldCarrier.Id).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"reactivation_date\": carrier.ReactivationDate,\n\t\t\t\t\"auth_token\":       carrier.AuthToken,\n\t\t\t}).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func HandleCarrierReactivation(ctx context.Context, publication string, newDate time.Time, token string) error {\n\trepo := &CarrierRepo{db: GetDBInstance()}\n\tcarrier := &model.Carrier{\n\t\tPublication:      publication,\n\t\tReactivationDate: newDate,\n\t\tAuthToken:        token,\n\t}\n\tif err := repo.RefreshIndex(ctx, carrier); err != nil {\n\t\treturn fmt.Errorf(\"failed to refresh carrier index: %v\", err)\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "SELECT query to find existing carrier record",
            "sql": "SELECT id, publication, reactivation_date, auth_token, status FROM ivc_carrier_info WHERE publication = ? LIMIT 1;"
          },
          {
            "scenario": "UPDATE when reactivation_date differs",
            "sql": "UPDATE ivc_carrier_info SET reactivation_date = ?, auth_token = ? WHERE id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "CarrierRepo",
        "code_value": "type CarrierRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "CarrierTableName",
        "code_value": "const CarrierTableName = \"ivc_carrier_info\""
      },
      {
        "code_key": "Carrier",
        "code_value": "type Carrier struct {\n\tId               int64   `gorm:\"column:id\" json:\"id\"`\n\tPublication      string  `gorm:\"column:publication\" json:\"publication\"`\n\tReactivationDate int64   `gorm:\"column:reactivation_date\" json:\"reactivation_date\"`\n\tAuthToken        string  `gorm:\"column:auth_token\" json:\"auth_token\"`\n\tStatus           int     `gorm:\"column:status\" json:\"status\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (c *Carrier) TableName() string {\n\treturn CarrierTableName\n}"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-core/pkg/utils"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      },
      {
        "code_key": "CarrierStatusActive",
        "code_value": "const CarrierStatusActive = 1"
      },
      {
        "code_key": "CarrierStatusInactive",
        "code_value": "const CarrierStatusInactive = 0"
      },
      {
        "code_key": "oldCarrier",
        "code_value": "&model.Carrier{}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "RefreshIndex",
    "orm_code": "func (repo *CarrierRepo) RefreshIndex(ctx context.Context, carrier *model.Carrier) error {\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\toldCarrier := &model.Carrier{}\n\n\tif err := repo.db.Table(model.CarrierTableName).\n\t\tWhere(\"publication = ?\", carrier.Publication).\n\t\tFirst(oldCarrier).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif oldCarrier.ReactivationDate != carrier.ReactivationDate {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.CarrierTableName).\n\t\t\tWhere(\"id = ?\", oldCarrier.Id).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"reactivation_date\": carrier.ReactivationDate,\n\t\t\t\t\"auth_token\":       carrier.AuthToken,\n\t\t\t}).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func UpdateDistributorTokens(ctx context.Context, distributorID string, authToken string) error {\n\trepo := NewCarrierRepository()\n\tcarrierData := &model.Carrier{\n\t\tPublication:      distributorID,\n\t\tReactivationDate: time.Now(),\n\t\tAuthToken:        authToken,\n\t}\n\terr := repo.RefreshIndex(ctx, carrierData)\n\tif err != nil {\n\t\tlog.Printf(\"Error updating distributor tokens: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "首次查询到carrier记录且reactivation_date有变化",
            "sql": "SELECT id, publication, reactivation_date, auth_token, status FROM ivc_carrier_info WHERE publication = 'distributorID' LIMIT 1;"
          },
          {
            "scenario": "首次查询到carrier记录但reactivation_date无变化",
            "sql": "SELECT id, publication, reactivation_date, auth_token, status FROM ivc_carrier_info WHERE publication = 'distributorID' LIMIT 1;"
          },
          {
            "scenario": "未查询到carrier记录",
            "sql": "SELECT id, publication, reactivation_date, auth_token, status FROM ivc_carrier_info WHERE publication = 'distributorID' LIMIT 1;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "reactivation_date有变化时的UPDATE操作",
            "sql": "UPDATE ivc_carrier_info SET reactivation_date = 1234567890, auth_token = 'authToken' WHERE id = 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "CarrierRepo",
        "code_value": "type CarrierRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "CarrierTableName",
        "code_value": "const CarrierTableName = \"ivc_carrier_info\""
      },
      {
        "code_key": "Carrier",
        "code_value": "type Carrier struct {\n\tId               int64   `gorm:\"column:id\" json:\"id\"`\n\tPublication      string  `gorm:\"column:publication\" json:\"publication\"`\n\tReactivationDate int64   `gorm:\"column:reactivation_date\" json:\"reactivation_date\"`\n\tAuthToken        string  `gorm:\"column:auth_token\" json:\"auth_token\"`\n\tStatus           int     `gorm:\"column:status\" json:\"status\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (c *Carrier) TableName() string {\n\treturn CarrierTableName\n}"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-core/pkg/utils"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      },
      {
        "code_key": "CarrierStatusActive",
        "code_value": "const CarrierStatusActive = 1"
      },
      {
        "code_key": "CarrierStatusInactive",
        "code_value": "const CarrierStatusInactive = 0"
      },
      {
        "code_key": "oldCarrier",
        "code_value": "&model.Carrier{}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "RefreshIndex",
    "orm_code": "func (repo *CarrierRepo) RefreshIndex(ctx context.Context, carrier *model.Carrier) error {\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\toldCarrier := &model.Carrier{}\n\n\tif err := repo.db.Table(model.CarrierTableName).\n\t\tWhere(\"publication = ?\", carrier.Publication).\n\t\tFirst(oldCarrier).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif oldCarrier.ReactivationDate != carrier.ReactivationDate {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.CarrierTableName).\n\t\t\tWhere(\"id = ?\", oldCarrier.Id).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"reactivation_date\": carrier.ReactivationDate,\n\t\t\t\t\"auth_token\":       carrier.AuthToken,\n\t\t\t}).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func HandleSystemHealth() error {\n\tproj := Project{EnvType: \"production\"}\n\tstats, err := proj.RefreshIndex()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to refresh health metrics: %v\", err)\n\t\treturn err\n\t}\n\tfmt.Printf(\"Retrieved %d health metrics\\n\", len(stats))\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "production environment",
            "sql": "SELECT id, status, cluster_type, created_at FROM health_metrics WHERE status = 1 AND cluster_type = 'primary' ORDER BY created_at DESC;"
          },
          {
            "scenario": "staging environment",
            "sql": "SELECT id, status, cluster_type, created_at FROM health_metrics WHERE status = 1 AND cluster_type = 'secondary' ORDER BY created_at DESC;"
          },
          {
            "scenario": "development environment",
            "sql": "SELECT id, status, cluster_type, created_at FROM health_metrics WHERE status = 1 AND cluster_type = 'local' ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "CarrierRepo",
        "code_value": "type CarrierRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "CarrierTableName",
        "code_value": "const CarrierTableName = \"ivc_carrier_info\""
      },
      {
        "code_key": "Carrier",
        "code_value": "type Carrier struct {\n\tId               int64   `gorm:\"column:id\" json:\"id\"`\n\tPublication      string  `gorm:\"column:publication\" json:\"publication\"`\n\tReactivationDate int64   `gorm:\"column:reactivation_date\" json:\"reactivation_date\"`\n\tAuthToken        string  `gorm:\"column:auth_token\" json:\"auth_token\"`\n\tStatus           int     `gorm:\"column:status\" json:\"status\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (c *Carrier) TableName() string {\n\treturn CarrierTableName\n}"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-core/pkg/utils"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      },
      {
        "code_key": "CarrierStatusActive",
        "code_value": "const CarrierStatusActive = 1"
      },
      {
        "code_key": "CarrierStatusInactive",
        "code_value": "const CarrierStatusInactive = 0"
      },
      {
        "code_key": "oldCarrier",
        "code_value": "&model.Carrier{}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "RefreshIndex",
    "orm_code": "func (repo *CarrierRepo) RefreshIndex(ctx context.Context, carrier *model.Carrier) error {\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\toldCarrier := &model.Carrier{}\n\n\tif err := repo.db.Table(model.CarrierTableName).\n\t\tWhere(\"publication = ?\", carrier.Publication).\n\t\tFirst(oldCarrier).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif oldCarrier.ReactivationDate != carrier.ReactivationDate {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.CarrierTableName).\n\t\t\tWhere(\"id = ?\", oldCarrier.Id).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"reactivation_date\": carrier.ReactivationDate,\n\t\t\t\t\"auth_token\":       carrier.AuthToken,\n\t\t\t}).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func HandleDevClusterMonitoring() ([]HealthMetrics, error) {\n\tdevProject := &Project{EnvType: \"development\"}\n\tresults, err := devProject.RefreshIndex()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"development cluster monitoring failed: %w\", err)\n\t}\n\tif len(results) == 0 {\n\t\treturn nil, errors.New(\"no health data available\")\n\t}\n\treturn results, nil\n}",
    "sql_statement_list": [
      "SELECT id, status, cluster_type, created_at FROM health_metrics WHERE status = 1 AND cluster_type = 'local' ORDER BY created_at DESC;"
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "CarrierRepo",
        "code_value": "type CarrierRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "CarrierTableName",
        "code_value": "const CarrierTableName = \"ivc_carrier_info\""
      },
      {
        "code_key": "Carrier",
        "code_value": "type Carrier struct {\n\tId               int64   `gorm:\"column:id\" json:\"id\"`\n\tPublication      string  `gorm:\"column:publication\" json:\"publication\"`\n\tReactivationDate int64   `gorm:\"column:reactivation_date\" json:\"reactivation_date\"`\n\tAuthToken        string  `gorm:\"column:auth_token\" json:\"auth_token\"`\n\tStatus           int     `gorm:\"column:status\" json:\"status\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (c *Carrier) TableName() string {\n\treturn CarrierTableName\n}"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-core/pkg/utils"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      },
      {
        "code_key": "CarrierStatusActive",
        "code_value": "const CarrierStatusActive = 1"
      },
      {
        "code_key": "CarrierStatusInactive",
        "code_value": "const CarrierStatusInactive = 0"
      },
      {
        "code_key": "oldCarrier",
        "code_value": "&model.Carrier{}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "RefreshIndex",
    "orm_code": "func (repo *CarrierRepo) RefreshIndex(ctx context.Context, carrier *model.Carrier) error {\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\toldCarrier := &model.Carrier{}\n\n\tif err := repo.db.Table(model.CarrierTableName).\n\t\tWhere(\"publication = ?\", carrier.Publication).\n\t\tFirst(oldCarrier).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif oldCarrier.ReactivationDate != carrier.ReactivationDate {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.CarrierTableName).\n\t\t\tWhere(\"id = ?\", oldCarrier.Id).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"reactivation_date\": carrier.ReactivationDate,\n\t\t\t\t\"auth_token\":       carrier.AuthToken,\n\t\t\t}).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func HandleStagingMetricsReport() {\n\tstagingProj := Project{EnvType: \"staging\"}\n\tmetrics, err := stagingProj.RefreshIndex()\n\tif err != nil {\n\t\tlog.Fatal(\"Staging metrics report generation failed: \", err)\n\t}\n\tfor _, m := range metrics {\n\t\tfmt.Printf(\"Metric ID: %s, Status: %d\\n\", m.ID, m.Status)\n\t}\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "EnvType is production",
            "sql": "SELECT id, status, cluster_type, created_at FROM health_metrics WHERE status = 1 AND cluster_type = 'primary' ORDER BY created_at DESC;"
          },
          {
            "scenario": "EnvType is staging",
            "sql": "SELECT id, status, cluster_type, created_at FROM health_metrics WHERE status = 1 AND cluster_type = 'secondary' ORDER BY created_at DESC;"
          },
          {
            "scenario": "EnvType is development",
            "sql": "SELECT id, status, cluster_type, created_at FROM health_metrics WHERE status = 1 AND cluster_type = 'local' ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "CarrierRepo",
        "code_value": "type CarrierRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "CarrierTableName",
        "code_value": "const CarrierTableName = \"ivc_carrier_info\""
      },
      {
        "code_key": "Carrier",
        "code_value": "type Carrier struct {\n\tId               int64   `gorm:\"column:id\" json:\"id\"`\n\tPublication      string  `gorm:\"column:publication\" json:\"publication\"`\n\tReactivationDate int64   `gorm:\"column:reactivation_date\" json:\"reactivation_date\"`\n\tAuthToken        string  `gorm:\"column:auth_token\" json:\"auth_token\"`\n\tStatus           int     `gorm:\"column:status\" json:\"status\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (c *Carrier) TableName() string {\n\treturn CarrierTableName\n}"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-core/pkg/utils"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      },
      {
        "code_key": "CarrierStatusActive",
        "code_value": "const CarrierStatusActive = 1"
      },
      {
        "code_key": "CarrierStatusInactive",
        "code_value": "const CarrierStatusInactive = 0"
      },
      {
        "code_key": "oldCarrier",
        "code_value": "&model.Carrier{}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "BulkUpdate",
    "orm_code": "func (repo *ResourceRepo) BulkUpdate(ctx context.Context, updates []*model.ResourceUpdate) error {\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\tdb := repo.db.Clauses(updateClause).Table(model.ResourceTableName)\n\n\tfor _, update := range updates {\n\t\tif update == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tresult := db.Where(\"OrderNumber = ?\", update.OrderNumber).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"Credits\":         update.Credits,\n\t\t\t\t\"MailingAddress\":  update.MailingAddress,\n\t\t\t})\n\n\t\tif result.Error != nil {\n\t\t\treturn result.Error\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "ClassName is Warrior",
            "sql": "UPDATE skill_assessments SET attack_power = ? WHERE player_id = ? AND assessment_date >= ?;"
          },
          {
            "scenario": "ClassName is Mage",
            "sql": "UPDATE skill_assessments SET spell_power = ? WHERE player_id = ? AND assessment_date >= ?;"
          },
          {
            "scenario": "ClassName is Rogue",
            "sql": "UPDATE skill_assessments SET critical_chance = ? WHERE player_id = ? AND assessment_date >= ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ResourceRepo",
        "code_value": "type ResourceRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ResourceUpdate",
        "code_value": "type ResourceUpdate struct {\n\tOrderNumber     string  `json:\"order_number\"`\n\tCredits         float64 `json:\"credits\"`\n\tMailingAddress  string  `json:\"mailing_address\"`\n}"
      },
      {
        "code_key": "ResourceTableName",
        "code_value": "const ResourceTableName = \"inventory_resources\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "Resource",
        "code_value": "type Resource struct {\n\tOrderNumber    string  `gorm:\"column:order_number\" json:\"order_number\"`\n\tCredits        float64 `gorm:\"column:credits\" json:\"credits\"`\n\tMailingAddress string  `gorm:\"column:mailing_address\" json:\"mailing_address\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (r *Resource) TableName() string {\n\treturn ResourceTableName\n}"
      },
      {
        "code_key": "hints",
        "code_value": "import \"gorm.io/hints\""
      },
      {
        "code_key": "icontext",
        "code_value": "import \"git.woa.com/common/pkg/icontext\""
      },
      {
        "code_key": "uuid",
        "code_value": "import \"github.com/google/uuid\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "BulkUpdate",
    "orm_code": "func (repo *ResourceRepo) BulkUpdate(ctx context.Context, updates []*model.ResourceUpdate) error {\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\tdb := repo.db.Clauses(updateClause).Table(model.ResourceTableName)\n\n\tfor _, update := range updates {\n\t\tif update == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tresult := db.Where(\"OrderNumber = ?\", update.OrderNumber).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"Credits\":         update.Credits,\n\t\t\t\t\"MailingAddress\":  update.MailingAddress,\n\t\t\t})\n\n\t\tif result.Error != nil {\n\t\t\treturn result.Error\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func HandleResourceCreditsUpdate(ctx context.Context, resourceUpdates []*model.ResourceUpdate, logger *zap.Logger) error {\n\trepo, err := data.NewResourceRepo()\n\tif err != nil {\n\t\tlogger.Error(\"failed to initialize resource repository\", zap.Error(err))\n\t\treturn err\n\t}\n\n\tif len(resourceUpdates) == 0 {\n\t\tlogger.Warn(\"no resource updates provided\")\n\t\treturn nil\n\t}\n\n\tif err := repo.BulkUpdate(ctx, resourceUpdates); err != nil {\n\t\tlogger.Error(\"failed to bulk update resources\", zap.Error(err))\n\t\treturn fmt.Errorf(\"resource update failed: %w\", err)\n\t}\n\n\tlogger.Info(\"successfully updated resources\", zap.Int(\"count\", len(resourceUpdates)))\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "批量更新资源记录",
            "sql": "UPDATE inventory_resources SET credits = ?, mailing_address = ? WHERE order_number = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ResourceRepo",
        "code_value": "type ResourceRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ResourceUpdate",
        "code_value": "type ResourceUpdate struct {\n\tOrderNumber     string  `json:\"order_number\"`\n\tCredits         float64 `json:\"credits\"`\n\tMailingAddress  string  `json:\"mailing_address\"`\n}"
      },
      {
        "code_key": "ResourceTableName",
        "code_value": "const ResourceTableName = \"inventory_resources\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "Resource",
        "code_value": "type Resource struct {\n\tOrderNumber    string  `gorm:\"column:order_number\" json:\"order_number\"`\n\tCredits        float64 `gorm:\"column:credits\" json:\"credits\"`\n\tMailingAddress string  `gorm:\"column:mailing_address\" json:\"mailing_address\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (r *Resource) TableName() string {\n\treturn ResourceTableName\n}"
      },
      {
        "code_key": "hints",
        "code_value": "import \"gorm.io/hints\""
      },
      {
        "code_key": "icontext",
        "code_value": "import \"git.woa.com/common/pkg/icontext\""
      },
      {
        "code_key": "uuid",
        "code_value": "import \"github.com/google/uuid\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "BulkUpdate",
    "orm_code": "func (repo *ResourceRepo) BulkUpdate(ctx context.Context, updates []*model.ResourceUpdate) error {\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\tdb := repo.db.Clauses(updateClause).Table(model.ResourceTableName)\n\n\tfor _, update := range updates {\n\t\tif update == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tresult := db.Where(\"OrderNumber = ?\", update.OrderNumber).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"Credits\":         update.Credits,\n\t\t\t\t\"MailingAddress\":  update.MailingAddress,\n\t\t\t})\n\n\t\tif result.Error != nil {\n\t\t\treturn result.Error\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func HandleWarriorSkillUpdate() error {\n\twarrior := &Player{\n\t\tClassName: \"Warrior\",\n\t\tID:       1001,\n\t\tVersion:  5,\n\t\tStartTime: time.Now().AddDate(0, -1, 0),\n\t}\n\n\tupdatedRows, err := warrior.BulkUpdateSkillLevels()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to update warrior skills: %v\", err)\n\t}\n\tlog.Printf(\"Successfully updated %d warrior skill records\\n\", updatedRows)\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Warrior class update",
            "sql": "UPDATE skill_assessments SET attack_power = 50 WHERE player_id = 1001 AND assessment_date >= ?;"
          },
          {
            "scenario": "Mage class update",
            "sql": "UPDATE skill_assessments SET spell_power = 24 WHERE player_id = 1002 AND assessment_date >= ?;"
          },
          {
            "scenario": "Rogue class update",
            "sql": "UPDATE skill_assessments SET critical_chance = 2.0 WHERE player_id = 1003 AND assessment_date >= ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ResourceRepo",
        "code_value": "type ResourceRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ResourceUpdate",
        "code_value": "type ResourceUpdate struct {\n\tOrderNumber     string  `json:\"order_number\"`\n\tCredits         float64 `json:\"credits\"`\n\tMailingAddress  string  `json:\"mailing_address\"`\n}"
      },
      {
        "code_key": "ResourceTableName",
        "code_value": "const ResourceTableName = \"inventory_resources\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "Resource",
        "code_value": "type Resource struct {\n\tOrderNumber    string  `gorm:\"column:order_number\" json:\"order_number\"`\n\tCredits        float64 `gorm:\"column:credits\" json:\"credits\"`\n\tMailingAddress string  `gorm:\"column:mailing_address\" json:\"mailing_address\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (r *Resource) TableName() string {\n\treturn ResourceTableName\n}"
      },
      {
        "code_key": "hints",
        "code_value": "import \"gorm.io/hints\""
      },
      {
        "code_key": "icontext",
        "code_value": "import \"git.woa.com/common/pkg/icontext\""
      },
      {
        "code_key": "uuid",
        "code_value": "import \"github.com/google/uuid\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "BulkUpdate",
    "orm_code": "func (repo *ResourceRepo) BulkUpdate(ctx context.Context, updates []*model.ResourceUpdate) error {\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\tdb := repo.db.Clauses(updateClause).Table(model.ResourceTableName)\n\n\tfor _, update := range updates {\n\t\tif update == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tresult := db.Where(\"OrderNumber = ?\", update.OrderNumber).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"Credits\":         update.Credits,\n\t\t\t\t\"MailingAddress\":  update.MailingAddress,\n\t\t\t})\n\n\t\tif result.Error != nil {\n\t\t\treturn result.Error\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func ProcessMageSkillAssessment(mageID int) (int64, error) {\n\tmage := &Player{\n\t\tClassName: \"Mage\",\n\t\tID:       mageID,\n\t\tVersion:  3,\n\t\tStartTime: time.Date(2023, 1, 1, 0, 0, 0, 0, time.UTC),\n\t}\n\n\taffectedRows, err := mage.BulkUpdateSkillLevels()\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"mage skill update failed: %w\", err)\n\t}\n\treturn affectedRows, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Mage class update",
            "sql": "UPDATE skill_assessments SET spell_power = 24 WHERE player_id = ? AND assessment_date >= 1672531200;"
          },
          {
            "scenario": "Warrior class update",
            "sql": "UPDATE skill_assessments SET attack_power = ? WHERE player_id = ? AND assessment_date >= ?;"
          },
          {
            "scenario": "Rogue class update",
            "sql": "UPDATE skill_assessments SET critical_chance = ? WHERE player_id = ? AND assessment_date >= ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ResourceRepo",
        "code_value": "type ResourceRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ResourceUpdate",
        "code_value": "type ResourceUpdate struct {\n\tOrderNumber     string  `json:\"order_number\"`\n\tCredits         float64 `json:\"credits\"`\n\tMailingAddress  string  `json:\"mailing_address\"`\n}"
      },
      {
        "code_key": "ResourceTableName",
        "code_value": "const ResourceTableName = \"inventory_resources\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "Resource",
        "code_value": "type Resource struct {\n\tOrderNumber    string  `gorm:\"column:order_number\" json:\"order_number\"`\n\tCredits        float64 `gorm:\"column:credits\" json:\"credits\"`\n\tMailingAddress string  `gorm:\"column:mailing_address\" json:\"mailing_address\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (r *Resource) TableName() string {\n\treturn ResourceTableName\n}"
      },
      {
        "code_key": "hints",
        "code_value": "import \"gorm.io/hints\""
      },
      {
        "code_key": "icontext",
        "code_value": "import \"git.woa.com/common/pkg/icontext\""
      },
      {
        "code_key": "uuid",
        "code_value": "import \"github.com/google/uuid\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "BulkUpdate",
    "orm_code": "func (repo *ResourceRepo) BulkUpdate(ctx context.Context, updates []*model.ResourceUpdate) error {\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\tdb := repo.db.Clauses(updateClause).Table(model.ResourceTableName)\n\n\tfor _, update := range updates {\n\t\tif update == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tresult := db.Where(\"OrderNumber = ?\", update.OrderNumber).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"Credits\":         update.Credits,\n\t\t\t\t\"MailingAddress\":  update.MailingAddress,\n\t\t\t})\n\n\t\tif result.Error != nil {\n\t\t\treturn result.Error\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func RefreshRogueSkills(rogue *Player) error {\n\tif rogue == nil {\n\t\treturn fmt.Errorf(\"nil player provided\")\n\t}\n\trogue.ClassName = \"Rogue\"\n\trogue.Version = 7\n\trogue.StartTime = time.Now().Add(-240 * time.Hour)\n\n\tcount, err := rogue.BulkUpdateSkillLevels()\n\tif err != nil || count == 0 {\n\t\treturn fmt.Errorf(\"no rogue skills updated: %v\", err)\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Rogue class update",
            "sql": "UPDATE skill_assessments SET critical_chance = 3.5 WHERE player_id = ? AND assessment_date >= ?;"
          },
          {
            "scenario": "Warrior class update",
            "sql": "UPDATE skill_assessments SET attack_power = ? WHERE player_id = ? AND assessment_date >= ?;"
          },
          {
            "scenario": "Mage class update",
            "sql": "UPDATE skill_assessments SET spell_power = ? WHERE player_id = ? AND assessment_date >= ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ResourceRepo",
        "code_value": "type ResourceRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ResourceUpdate",
        "code_value": "type ResourceUpdate struct {\n\tOrderNumber     string  `json:\"order_number\"`\n\tCredits         float64 `json:\"credits\"`\n\tMailingAddress  string  `json:\"mailing_address\"`\n}"
      },
      {
        "code_key": "ResourceTableName",
        "code_value": "const ResourceTableName = \"inventory_resources\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "Resource",
        "code_value": "type Resource struct {\n\tOrderNumber    string  `gorm:\"column:order_number\" json:\"order_number\"`\n\tCredits        float64 `gorm:\"column:credits\" json:\"credits\"`\n\tMailingAddress string  `gorm:\"column:mailing_address\" json:\"mailing_address\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (r *Resource) TableName() string {\n\treturn ResourceTableName\n}"
      },
      {
        "code_key": "hints",
        "code_value": "import \"gorm.io/hints\""
      },
      {
        "code_key": "icontext",
        "code_value": "import \"git.woa.com/common/pkg/icontext\""
      },
      {
        "code_key": "uuid",
        "code_value": "import \"github.com/google/uuid\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CalculateStatistics",
    "orm_code": "func (repo *ArmorRepo) CalculateStatistics(ctx context.Context, territory string) (map[string]interface{}, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tresult := make(map[string]interface{})\n\tdbQuery := repo.db.Clauses(queryClause).Table(model.ArmorTableName)\n\n\tif territory != \"\" {\n\t\tdbQuery = dbQuery.Where(\"territory = ?\", territory)\n\t}\n\n\tif err := dbQuery.Select(\n\t\t\"SUM(tax_amount) as total_tax\",\n\t\t\"AVG(suspension_time) as avg_suspension\",\n\t\t\"COUNT(*) as record_count\",\n\t).Scan(&result).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn result, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Employee.Points > threshold",
            "sql": "SELECT id, points, department_code, deadline_date FROM resource_allocation WHERE points > ? AND department_code = ? ORDER BY deadline_date DESC;"
          },
          {
            "scenario": "Employee.Points == threshold",
            "sql": "SELECT id, points, department_code, deadline_date FROM resource_allocation WHERE points = ? AND deadline_date IS NOT NULL ORDER BY deadline_date DESC;"
          },
          {
            "scenario": "Employee.Points < threshold",
            "sql": "SELECT id, points, department_code, deadline_date FROM resource_allocation WHERE points < ? ORDER BY deadline_date DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "AchievementRepo",
        "code_value": "type AchievementRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "AchievementTableName",
        "code_value": "const AchievementTableName = \"user_achievements\""
      },
      {
        "code_key": "Achievement",
        "code_value": "type Achievement struct {\n\tID          uint    `gorm:\"column:id\"`\n\tUserID      string  `gorm:\"column:user_id\"`\n\tLevel       int     `gorm:\"column:level\"`\n\tPoints      float64 `gorm:\"column:points\"`\n\tCompletedAt int64   `gorm:\"column:completed_at\"`\n}"
      },
      {
        "code_key": "TaskRepo",
        "code_value": "type TaskRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "TaskTableName",
        "code_value": "const TaskTableName = \"user_tasks\""
      },
      {
        "code_key": "Task",
        "code_value": "type Task struct {\n\tID        uint   `gorm:\"column:id\"`\n\tName      string `gorm:\"column:name\"`\n\tStatus    int    `gorm:\"column:status\"`\n\tCreatedBy string `gorm:\"column:created_by\"`\n\tDueDate   int64  `gorm:\"column:due_date\"`\n}"
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"QUERY\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "TaskStatusPending",
        "code_value": "const TaskStatusPending = 0"
      },
      {
        "code_key": "TaskStatusCompleted",
        "code_value": "const TaskStatusCompleted = 1"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CalculateStatistics",
    "orm_code": "func (repo *ArmorRepo) CalculateStatistics(ctx context.Context, territory string) (map[string]interface{}, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tresult := make(map[string]interface{})\n\tdbQuery := repo.db.Clauses(queryClause).Table(model.ArmorTableName)\n\n\tif territory != \"\" {\n\t\tdbQuery = dbQuery.Where(\"territory = ?\", territory)\n\t}\n\n\tif err := dbQuery.Select(\n\t\t\"SUM(tax_amount) as total_tax\",\n\t\t\"AVG(suspension_time) as avg_suspension\",\n\t\t\"COUNT(*) as record_count\",\n\t).Scan(&result).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn result, nil\n}",
    "caller": "func HandleArmorStats(db *gorm.DB, region string) (map[string]interface{}, error) {\n\trepo := &ArmorRepo{db: db}\n\tstats, err := repo.CalculateStatistics(context.Background(), region)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to calculate armor stats: %v\", err)\n\t}\n\treturn stats, nil\n}",
    "sql_statement_list": [
      {
        "type": "LACK_INFORMATION",
        "variants": [
          {
            "scenario": "缺少model.ArmorTableName定义，根据context推测表名为armor",
            "sql": "SELECT SUM(tax_amount) as total_tax, AVG(suspension_time) as avg_suspension, COUNT(*) as record_count FROM armor;"
          },
          {
            "scenario": "缺少model.ArmorTableName定义，根据context推测表名为armor",
            "sql": "SELECT SUM(tax_amount) as total_tax, AVG(suspension_time) as avg_suspension, COUNT(*) as record_count FROM armor WHERE territory = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "AchievementRepo",
        "code_value": "type AchievementRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "AchievementTableName",
        "code_value": "const AchievementTableName = \"user_achievements\""
      },
      {
        "code_key": "Achievement",
        "code_value": "type Achievement struct {\n\tID          uint    `gorm:\"column:id\"`\n\tUserID      string  `gorm:\"column:user_id\"`\n\tLevel       int     `gorm:\"column:level\"`\n\tPoints      float64 `gorm:\"column:points\"`\n\tCompletedAt int64   `gorm:\"column:completed_at\"`\n}"
      },
      {
        "code_key": "TaskRepo",
        "code_value": "type TaskRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "TaskTableName",
        "code_value": "const TaskTableName = \"user_tasks\""
      },
      {
        "code_key": "Task",
        "code_value": "type Task struct {\n\tID        uint   `gorm:\"column:id\"`\n\tName      string `gorm:\"column:name\"`\n\tStatus    int    `gorm:\"column:status\"`\n\tCreatedBy string `gorm:\"column:created_by\"`\n\tDueDate   int64  `gorm:\"column:due_date\"`\n}"
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"QUERY\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "TaskStatusPending",
        "code_value": "const TaskStatusPending = 0"
      },
      {
        "code_key": "TaskStatusCompleted",
        "code_value": "const TaskStatusCompleted = 1"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CalculateStatistics",
    "orm_code": "func (repo *ArmorRepo) CalculateStatistics(ctx context.Context, territory string) (map[string]interface{}, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tresult := make(map[string]interface{})\n\tdbQuery := repo.db.Clauses(queryClause).Table(model.ArmorTableName)\n\n\tif territory != \"\" {\n\t\tdbQuery = dbQuery.Where(\"territory = ?\", territory)\n\t}\n\n\tif err := dbQuery.Select(\n\t\t\"SUM(tax_amount) as total_tax\",\n\t\t\"AVG(suspension_time) as avg_suspension\",\n\t\t\"COUNT(*) as record_count\",\n\t).Scan(&result).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn result, nil\n}",
    "caller": "func ProcessTerritoryReport(conn *gorm.DB) error {\n\treportRepo := &ArmorRepo{db: conn}\n\tmetrics, err := reportRepo.CalculateStatistics(context.TODO(), \"europe\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"territory report generation failed: %w\", err)\n\t}\n\tlog.Printf(\"Territory metrics: %+v\", metrics)\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "LACK_INFORMATION",
        "variants": [
          {
            "scenario": "缺少model.ArmorTableName的具体定义，推测表名为armor",
            "sql": "SELECT SUM(tax_amount) as total_tax, AVG(suspension_time) as avg_suspension, COUNT(*) as record_count FROM armor WHERE territory = 'europe';"
          }
        ]
      }
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "AchievementRepo",
        "code_value": "type AchievementRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "AchievementTableName",
        "code_value": "const AchievementTableName = \"user_achievements\""
      },
      {
        "code_key": "Achievement",
        "code_value": "type Achievement struct {\n\tID          uint    `gorm:\"column:id\"`\n\tUserID      string  `gorm:\"column:user_id\"`\n\tLevel       int     `gorm:\"column:level\"`\n\tPoints      float64 `gorm:\"column:points\"`\n\tCompletedAt int64   `gorm:\"column:completed_at\"`\n}"
      },
      {
        "code_key": "TaskRepo",
        "code_value": "type TaskRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "TaskTableName",
        "code_value": "const TaskTableName = \"user_tasks\""
      },
      {
        "code_key": "Task",
        "code_value": "type Task struct {\n\tID        uint   `gorm:\"column:id\"`\n\tName      string `gorm:\"column:name\"`\n\tStatus    int    `gorm:\"column:status\"`\n\tCreatedBy string `gorm:\"column:created_by\"`\n\tDueDate   int64  `gorm:\"column:due_date\"`\n}"
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"QUERY\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "TaskStatusPending",
        "code_value": "const TaskStatusPending = 0"
      },
      {
        "code_key": "TaskStatusCompleted",
        "code_value": "const TaskStatusCompleted = 1"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CalculateStatistics",
    "orm_code": "func (repo *ArmorRepo) CalculateStatistics(ctx context.Context, territory string) (map[string]interface{}, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tresult := make(map[string]interface{})\n\tdbQuery := repo.db.Clauses(queryClause).Table(model.ArmorTableName)\n\n\tif territory != \"\" {\n\t\tdbQuery = dbQuery.Where(\"territory = ?\", territory)\n\t}\n\n\tif err := dbQuery.Select(\n\t\t\"SUM(tax_amount) as total_tax\",\n\t\t\"AVG(suspension_time) as avg_suspension\",\n\t\t\"COUNT(*) as record_count\",\n\t).Scan(&result).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn result, nil\n}",
    "caller": "func GenerateGlobalArmorSummary(dbClient *gorm.DB) (float64, error) {\n\tarmorRepo := ArmorRepo{db: dbClient}\n\tresults, err := armorRepo.CalculateStatistics(context.Background(), \"\")\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"global summary error: %w\", err)\n\t}\n\treturn results[\"total_tax\"].(float64), nil\n}",
    "sql_statement_list": [
      {
        "type": "LACK_INFORMATION",
        "variants": [
          {
            "scenario": "缺少model.ArmorTableName定义，假设表名为armor",
            "sql": "SELECT SUM(tax_amount) as total_tax, AVG(suspension_time) as avg_suspension, COUNT(*) as record_count FROM armor;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "territory参数不为空",
            "sql": "SELECT SUM(tax_amount) as total_tax, AVG(suspension_time) as avg_suspension, COUNT(*) as record_count FROM armor WHERE territory = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "SELECT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "AchievementRepo",
        "code_value": "type AchievementRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "AchievementTableName",
        "code_value": "const AchievementTableName = \"user_achievements\""
      },
      {
        "code_key": "Achievement",
        "code_value": "type Achievement struct {\n\tID          uint    `gorm:\"column:id\"`\n\tUserID      string  `gorm:\"column:user_id\"`\n\tLevel       int     `gorm:\"column:level\"`\n\tPoints      float64 `gorm:\"column:points\"`\n\tCompletedAt int64   `gorm:\"column:completed_at\"`\n}"
      },
      {
        "code_key": "TaskRepo",
        "code_value": "type TaskRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "TaskTableName",
        "code_value": "const TaskTableName = \"user_tasks\""
      },
      {
        "code_key": "Task",
        "code_value": "type Task struct {\n\tID        uint   `gorm:\"column:id\"`\n\tName      string `gorm:\"column:name\"`\n\tStatus    int    `gorm:\"column:status\"`\n\tCreatedBy string `gorm:\"column:created_by\"`\n\tDueDate   int64  `gorm:\"column:due_date\"`\n}"
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"QUERY\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "TaskStatusPending",
        "code_value": "const TaskStatusPending = 0"
      },
      {
        "code_key": "TaskStatusCompleted",
        "code_value": "const TaskStatusCompleted = 1"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CalculateStatistics",
    "orm_code": "func (repo *ArmorRepo) CalculateStatistics(ctx context.Context, territory string) (map[string]interface{}, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tresult := make(map[string]interface{})\n\tdbQuery := repo.db.Clauses(queryClause).Table(model.ArmorTableName)\n\n\tif territory != \"\" {\n\t\tdbQuery = dbQuery.Where(\"territory = ?\", territory)\n\t}\n\n\tif err := dbQuery.Select(\n\t\t\"SUM(tax_amount) as total_tax\",\n\t\t\"AVG(suspension_time) as avg_suspension\",\n\t\t\"COUNT(*) as record_count\",\n\t).Scan(&result).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn result, nil\n}",
    "caller": "func HandleResourceAnalysis() error {\n\temp := &Employee{\n\t\tPoints:         85,\n\t\tDepartmentCode: \"DEV\",\n\t}\n\n\tzones, err := emp.CalculateStatistics(80)\n\tif err != nil {\n\t\tlog.Printf(\"Failed to calculate statistics: %v\", err)\n\t\treturn err\n\t}\n\n\tlog.Printf(\"Retrieved %d matching zones\", len(zones))\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Points > threshold",
            "sql": "SELECT id, points, department_code, deadline_date FROM resource_allocation WHERE points > 80 AND department_code = 'DEV' ORDER BY deadline_date DESC;"
          },
          {
            "scenario": "Points == threshold",
            "sql": "SELECT id, points, department_code, deadline_date FROM resource_allocation WHERE points = 80 AND deadline_date IS NOT NULL ORDER BY deadline_date DESC;"
          },
          {
            "scenario": "Points < threshold",
            "sql": "SELECT id, points, department_code, deadline_date FROM resource_allocation WHERE points < 80 ORDER BY deadline_date DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "AchievementRepo",
        "code_value": "type AchievementRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "AchievementTableName",
        "code_value": "const AchievementTableName = \"user_achievements\""
      },
      {
        "code_key": "Achievement",
        "code_value": "type Achievement struct {\n\tID          uint    `gorm:\"column:id\"`\n\tUserID      string  `gorm:\"column:user_id\"`\n\tLevel       int     `gorm:\"column:level\"`\n\tPoints      float64 `gorm:\"column:points\"`\n\tCompletedAt int64   `gorm:\"column:completed_at\"`\n}"
      },
      {
        "code_key": "TaskRepo",
        "code_value": "type TaskRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "TaskTableName",
        "code_value": "const TaskTableName = \"user_tasks\""
      },
      {
        "code_key": "Task",
        "code_value": "type Task struct {\n\tID        uint   `gorm:\"column:id\"`\n\tName      string `gorm:\"column:name\"`\n\tStatus    int    `gorm:\"column:status\"`\n\tCreatedBy string `gorm:\"column:created_by\"`\n\tDueDate   int64  `gorm:\"column:due_date\"`\n}"
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"QUERY\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "TaskStatusPending",
        "code_value": "const TaskStatusPending = 0"
      },
      {
        "code_key": "TaskStatusCompleted",
        "code_value": "const TaskStatusCompleted = 1"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CalculateStatistics",
    "orm_code": "func (repo *ArmorRepo) CalculateStatistics(ctx context.Context, territory string) (map[string]interface{}, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tresult := make(map[string]interface{})\n\tdbQuery := repo.db.Clauses(queryClause).Table(model.ArmorTableName)\n\n\tif territory != \"\" {\n\t\tdbQuery = dbQuery.Where(\"territory = ?\", territory)\n\t}\n\n\tif err := dbQuery.Select(\n\t\t\"SUM(tax_amount) as total_tax\",\n\t\t\"AVG(suspension_time) as avg_suspension\",\n\t\t\"COUNT(*) as record_count\",\n\t).Scan(&result).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn result, nil\n}",
    "caller": "func ProcessDepartmentMetrics(deptCode string, score int) ([]Zone, error) {\n\tstaffMember := &Employee{\n\t\tPoints:         score,\n\t\tDepartmentCode: deptCode,\n\t}\n\n\tresults, err := staffMember.CalculateStatistics(75)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"metrics calculation failed: %w\", err)\n\t}\n\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Points > threshold",
            "sql": "SELECT id, points, department_code, deadline_date FROM resource_allocation WHERE points > ? AND department_code = ? ORDER BY deadline_date DESC;"
          },
          {
            "scenario": "Points == threshold",
            "sql": "SELECT id, points, department_code, deadline_date FROM resource_allocation WHERE points = ? AND deadline_date IS NOT NULL ORDER BY deadline_date DESC;"
          },
          {
            "scenario": "Points < threshold",
            "sql": "SELECT id, points, department_code, deadline_date FROM resource_allocation WHERE points < ? ORDER BY deadline_date DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "AchievementRepo",
        "code_value": "type AchievementRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "AchievementTableName",
        "code_value": "const AchievementTableName = \"user_achievements\""
      },
      {
        "code_key": "Achievement",
        "code_value": "type Achievement struct {\n\tID          uint    `gorm:\"column:id\"`\n\tUserID      string  `gorm:\"column:user_id\"`\n\tLevel       int     `gorm:\"column:level\"`\n\tPoints      float64 `gorm:\"column:points\"`\n\tCompletedAt int64   `gorm:\"column:completed_at\"`\n}"
      },
      {
        "code_key": "TaskRepo",
        "code_value": "type TaskRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "TaskTableName",
        "code_value": "const TaskTableName = \"user_tasks\""
      },
      {
        "code_key": "Task",
        "code_value": "type Task struct {\n\tID        uint   `gorm:\"column:id\"`\n\tName      string `gorm:\"column:name\"`\n\tStatus    int    `gorm:\"column:status\"`\n\tCreatedBy string `gorm:\"column:created_by\"`\n\tDueDate   int64  `gorm:\"column:due_date\"`\n}"
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"QUERY\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "TaskStatusPending",
        "code_value": "const TaskStatusPending = 0"
      },
      {
        "code_key": "TaskStatusCompleted",
        "code_value": "const TaskStatusCompleted = 1"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CalculateStatistics",
    "orm_code": "func (repo *ArmorRepo) CalculateStatistics(ctx context.Context, territory string) (map[string]interface{}, error) {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tresult := make(map[string]interface{})\n\tdbQuery := repo.db.Clauses(queryClause).Table(model.ArmorTableName)\n\n\tif territory != \"\" {\n\t\tdbQuery = dbQuery.Where(\"territory = ?\", territory)\n\t}\n\n\tif err := dbQuery.Select(\n\t\t\"SUM(tax_amount) as total_tax\",\n\t\t\"AVG(suspension_time) as avg_suspension\",\n\t\t\"COUNT(*) as record_count\",\n\t).Scan(&result).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn result, nil\n}",
    "caller": "func GenerateQuarterlyReport() {\n\treportEmployee := Employee{\n\t\tPoints:         90,\n\t\tDepartmentCode: \"FIN\",\n\t}\n\n\tfinancialZones, err := reportEmployee.CalculateStatistics(100)\n\tif err != nil {\n\t\tlog.Fatal(\"Critical report generation error: \", err)\n\t}\n\n\tfmt.Println(\"Quarterly financial zones:\", financialZones)\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "e.Points > threshold",
            "sql": "SELECT id, points, department_code, deadline_date FROM resource_allocation WHERE points > ? AND department_code = ? ORDER BY deadline_date DESC;"
          },
          {
            "scenario": "e.Points == threshold",
            "sql": "SELECT id, points, department_code, deadline_date FROM resource_allocation WHERE points = ? AND deadline_date IS NOT NULL ORDER BY deadline_date DESC;"
          },
          {
            "scenario": "e.Points < threshold (current execution path)",
            "sql": "SELECT id, points, department_code, deadline_date FROM resource_allocation WHERE points < ? ORDER BY deadline_date DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "AchievementRepo",
        "code_value": "type AchievementRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "AchievementTableName",
        "code_value": "const AchievementTableName = \"user_achievements\""
      },
      {
        "code_key": "Achievement",
        "code_value": "type Achievement struct {\n\tID          uint    `gorm:\"column:id\"`\n\tUserID      string  `gorm:\"column:user_id\"`\n\tLevel       int     `gorm:\"column:level\"`\n\tPoints      float64 `gorm:\"column:points\"`\n\tCompletedAt int64   `gorm:\"column:completed_at\"`\n}"
      },
      {
        "code_key": "TaskRepo",
        "code_value": "type TaskRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "TaskTableName",
        "code_value": "const TaskTableName = \"user_tasks\""
      },
      {
        "code_key": "Task",
        "code_value": "type Task struct {\n\tID        uint   `gorm:\"column:id\"`\n\tName      string `gorm:\"column:name\"`\n\tStatus    int    `gorm:\"column:status\"`\n\tCreatedBy string `gorm:\"column:created_by\"`\n\tDueDate   int64  `gorm:\"column:due_date\"`\n}"
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"QUERY\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "TaskStatusPending",
        "code_value": "const TaskStatusPending = 0"
      },
      {
        "code_key": "TaskStatusCompleted",
        "code_value": "const TaskStatusCompleted = 1"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "RejectApplication",
    "orm_code": "func (repo *TestRepo) RejectApplication(ctx context.Context, app *model.Application) error {\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\tconst RejectedStatus = 3\n\n\texisting := &model.Application{}\n\tif err := repo.db.Table(model.ApplicationTableName).\n\t\tWhere(\"application_id = ?\", app.ApplicationID).\n\t\tFirst(existing).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif existing.Status != RejectedStatus {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.ApplicationTableName).\n\t\t\tWhere(\"id = ?\", existing.ID).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"status\": RejectedStatus,\n\t\t\t\t\"end_date\": time.Now().Unix(),\n\t\t\t}).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "默认查询场景",
            "sql": "SELECT id, application_id, status, end_date FROM applications WHERE application_id = ? LIMIT 1;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "当查询到的应用状态不是已拒绝时执行更新",
            "sql": "UPDATE applications SET status = ?, end_date = ? WHERE id = ?;"
          },
          {
            "scenario": "当查询到的应用状态已是已拒绝时不执行更新",
            "sql": ""
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Application",
        "code_value": "type Application struct {\n\tID            int64  `gorm:\"column:id\" json:\"id\"`\n\tApplicationID string `gorm:\"column:application_id\" json:\"application_id\"`\n\tStatus        int    `gorm:\"column:status\" json:\"status\"`\n\tEndDate       int64  `gorm:\"column:end_date\" json:\"end_date\"`\n}"
      },
      {
        "code_key": "ApplicationTableName",
        "code_value": "const ApplicationTableName = \"applications\""
      },
      {
        "code_key": "RejectedStatus",
        "code_value": "const RejectedStatus = 3"
      },
      {
        "code_key": "TestRepo",
        "code_value": "type TestRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/company/project/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) hints.Hints {\n\tcommentInfo := icontext.GetSQLCommentFromContext(ctx)\n\tif len(commentInfo.ReqId) == 0 {\n\t\tcommentInfo.ReqId = uuid.New().String()\n\t}\n\n\tcomment := fmt.Sprintf(\"p=%s,a=%s,o=%s\", \n\t\tcommentInfo.Product, commentInfo.AppName, commentInfo.Owner)\n\treturn hints.CommentBefore(clause, comment)\n}"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      },
      {
        "code_key": "ApplicationRequest",
        "code_value": "type ApplicationRequest struct {\n\tApplicationID string `json:\"application_id\"`\n\tStatus       int    `json:\"status\"`\n}"
      },
      {
        "code_key": "PendingStatus",
        "code_value": "const PendingStatus = 1"
      },
      {
        "code_key": "ApprovedStatus",
        "code_value": "const ApprovedStatus = 2"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "RejectApplication",
    "orm_code": "func (repo *TestRepo) RejectApplication(ctx context.Context, app *model.Application) error {\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\tconst RejectedStatus = 3\n\n\texisting := &model.Application{}\n\tif err := repo.db.Table(model.ApplicationTableName).\n\t\tWhere(\"application_id = ?\", app.ApplicationID).\n\t\tFirst(existing).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif existing.Status != RejectedStatus {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.ApplicationTableName).\n\t\t\tWhere(\"id = ?\", existing.ID).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"status\": RejectedStatus,\n\t\t\t\t\"end_date\": time.Now().Unix(),\n\t\t\t}).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
    "caller": "func ProcessApplicationRejection(ctx context.Context, appID string) error {\n\trepo := &TestRepo{db: initializeDB()}\n\tapplication := &model.Application{ApplicationID: appID}\n\tif err := repo.RejectApplication(ctx, application); err != nil {\n\t\tlog.Printf(\"Failed to reject application %s: %v\", appID, err)\n\t\treturn err\n\t}\n\tlog.Printf(\"Successfully rejected application %s\", appID)\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "查询应用状态",
            "sql": "SELECT id, application_id, status, end_date FROM applications WHERE application_id = ? LIMIT 1;"
          }
        ]
      },
      "UPDATE applications SET status = 3, end_date = ? WHERE id = ?;"
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "UPDATE"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Application",
        "code_value": "type Application struct {\n\tID            int64  `gorm:\"column:id\" json:\"id\"`\n\tApplicationID string `gorm:\"column:application_id\" json:\"application_id\"`\n\tStatus        int    `gorm:\"column:status\" json:\"status\"`\n\tEndDate       int64  `gorm:\"column:end_date\" json:\"end_date\"`\n}"
      },
      {
        "code_key": "ApplicationTableName",
        "code_value": "const ApplicationTableName = \"applications\""
      },
      {
        "code_key": "RejectedStatus",
        "code_value": "const RejectedStatus = 3"
      },
      {
        "code_key": "TestRepo",
        "code_value": "type TestRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/company/project/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) hints.Hints {\n\tcommentInfo := icontext.GetSQLCommentFromContext(ctx)\n\tif len(commentInfo.ReqId) == 0 {\n\t\tcommentInfo.ReqId = uuid.New().String()\n\t}\n\n\tcomment := fmt.Sprintf(\"p=%s,a=%s,o=%s\", \n\t\tcommentInfo.Product, commentInfo.AppName, commentInfo.Owner)\n\treturn hints.CommentBefore(clause, comment)\n}"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      },
      {
        "code_key": "ApplicationRequest",
        "code_value": "type ApplicationRequest struct {\n\tApplicationID string `json:\"application_id\"`\n\tStatus       int    `json:\"status\"`\n}"
      },
      {
        "code_key": "PendingStatus",
        "code_value": "const PendingStatus = 1"
      },
      {
        "code_key": "ApprovedStatus",
        "code_value": "const ApprovedStatus = 2"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "RejectApplication",
    "orm_code": "func (repo *TestRepo) RejectApplication(ctx context.Context, app *model.Application) error {\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\tconst RejectedStatus = 3\n\n\texisting := &model.Application{}\n\tif err := repo.db.Table(model.ApplicationTableName).\n\t\tWhere(\"application_id = ?\", app.ApplicationID).\n\t\tFirst(existing).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif existing.Status != RejectedStatus {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.ApplicationTableName).\n\t\t\tWhere(\"id = ?\", existing.ID).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"status\": RejectedStatus,\n\t\t\t\t\"end_date\": time.Now().Unix(),\n\t\t\t}).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
    "caller": "func HandleExpiredApplications(ctx context.Context, expiredApps []string) error {\n\trepo := &TestRepo{db: getDatabaseConnection()}\n\tfor _, appID := range expiredApps {\n\t\tapp := &model.Application{ApplicationID: appID}\n\t\tif err := repo.RejectApplication(ctx, app); err != nil {\n\t\t\treturn fmt.Errorf(\"error rejecting app %s: %w\", appID, err)\n\t\t}\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "应用当前状态不是已拒绝状态",
            "sql": "SELECT id, application_id, status, end_date FROM applications WHERE application_id = ? LIMIT 1;"
          },
          {
            "scenario": "应用当前状态不是已拒绝状态",
            "sql": "UPDATE applications SET status = 3, end_date = ? WHERE id = ?;"
          },
          {
            "scenario": "应用当前状态已经是已拒绝状态",
            "sql": "SELECT id, application_id, status, end_date FROM applications WHERE application_id = ? LIMIT 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "Application",
        "code_value": "type Application struct {\n\tID            int64  `gorm:\"column:id\" json:\"id\"`\n\tApplicationID string `gorm:\"column:application_id\" json:\"application_id\"`\n\tStatus        int    `gorm:\"column:status\" json:\"status\"`\n\tEndDate       int64  `gorm:\"column:end_date\" json:\"end_date\"`\n}"
      },
      {
        "code_key": "ApplicationTableName",
        "code_value": "const ApplicationTableName = \"applications\""
      },
      {
        "code_key": "RejectedStatus",
        "code_value": "const RejectedStatus = 3"
      },
      {
        "code_key": "TestRepo",
        "code_value": "type TestRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/company/project/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) hints.Hints {\n\tcommentInfo := icontext.GetSQLCommentFromContext(ctx)\n\tif len(commentInfo.ReqId) == 0 {\n\t\tcommentInfo.ReqId = uuid.New().String()\n\t}\n\n\tcomment := fmt.Sprintf(\"p=%s,a=%s,o=%s\", \n\t\tcommentInfo.Product, commentInfo.AppName, commentInfo.Owner)\n\treturn hints.CommentBefore(clause, comment)\n}"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      },
      {
        "code_key": "ApplicationRequest",
        "code_value": "type ApplicationRequest struct {\n\tApplicationID string `json:\"application_id\"`\n\tStatus       int    `json:\"status\"`\n}"
      },
      {
        "code_key": "PendingStatus",
        "code_value": "const PendingStatus = 1"
      },
      {
        "code_key": "ApprovedStatus",
        "code_value": "const ApprovedStatus = 2"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "ValidateEdition",
    "orm_code": "func (repo *BlogRepo) ValidateEdition(ctx context.Context, blog *model.BlogContent) error {\n\tconst ContentReportsTable = \"content_reports\"\n\tselectClause := utils.SetSQLComment(ctx, \"select_edition\")\n\texisting := &model.BlogContent{}\n\n\tif err := repo.db.Clauses(selectClause).Table(ContentReportsTable).\n\t\tWhere(\"edition = ? AND latitude > ?\", blog.Edition, 0).\n\t\tFirst(existing).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif existing.DiscountRate != blog.DiscountRate {\n\t\treturn fmt.Errorf(\"discount rate mismatch for edition %d\", blog.Edition)\n\t}\n\n\treturn nil\n}",
    "caller": "",
    "sql_statement_list": [
      "SELECT * FROM content_reports WHERE edition = ? AND latitude > 0 LIMIT 1;"
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "BlogContent",
        "code_value": "type BlogContent struct {\n\tEdition      int     `gorm:\"column:edition\" json:\"edition\"`\n\tDiscountRate float64 `gorm:\"column:discount_rate\" json:\"discount_rate\"`\n\tLatitude     float64 `gorm:\"column:latitude\" json:\"latitude\"`\n}"
      },
      {
        "code_key": "BlogRepo",
        "code_value": "type BlogRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ContentReportsTable",
        "code_value": "const ContentReportsTable = \"content_reports\""
      },
      {
        "code_key": "select_edition",
        "code_value": "utils.SetSQLComment(ctx, \"select_edition\")"
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/org/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Expression {\n\tcomment := \"/* \" + clause + \" */\"\n\treturn gorm.Expr(comment)\n}"
      },
      {
        "code_key": "DiscountReport",
        "code_value": "type DiscountReport struct {\n\tID           int64   `gorm:\"column:id\" json:\"id\"`\n\tEdition      int     `gorm:\"column:edition\" json:\"edition\"`\n\tDiscountRate float64 `gorm:\"column:discount_rate\" json:\"discount_rate\"`\n\tLatitude     float64 `gorm:\"column:latitude\" json:\"latitude\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (d *DiscountReport) TableName() string {\n\treturn ContentReportsTable\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ValidateEdition",
    "orm_code": "func (repo *BlogRepo) ValidateEdition(ctx context.Context, blog *model.BlogContent) error {\n\tconst ContentReportsTable = \"content_reports\"\n\tselectClause := utils.SetSQLComment(ctx, \"select_edition\")\n\texisting := &model.BlogContent{}\n\n\tif err := repo.db.Clauses(selectClause).Table(ContentReportsTable).\n\t\tWhere(\"edition = ? AND latitude > ?\", blog.Edition, 0).\n\t\tFirst(existing).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif existing.DiscountRate != blog.DiscountRate {\n\t\treturn fmt.Errorf(\"discount rate mismatch for edition %d\", blog.Edition)\n\t}\n\n\treturn nil\n}",
    "caller": "func HandleBlogUpdate(ctx context.Context, editionID int, discount float64) error {\n\trepo := &BlogRepo{db: GetDB()}\n\tblog := &model.BlogContent{\n\t\tEdition:      editionID,\n\t\tDiscountRate: discount,\n\t}\n\n\tif err := repo.ValidateEdition(ctx, blog); err != nil {\n\t\treturn fmt.Errorf(\"validation failed: %v\", err)\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "正常验证场景",
            "sql": "SELECT edition, discount_rate, latitude FROM content_reports WHERE edition = ? AND latitude > ? ORDER BY content_reports.edition LIMIT 1;"
          },
          {
            "scenario": "记录不存在场景",
            "sql": "SELECT edition, discount_rate, latitude FROM content_reports WHERE edition = ? AND latitude > ? ORDER BY content_reports.edition LIMIT 1;"
          },
          {
            "scenario": "折扣率不匹配场景",
            "sql": "SELECT edition, discount_rate, latitude FROM content_reports WHERE edition = ? AND latitude > ? ORDER BY content_reports.edition LIMIT 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "BlogContent",
        "code_value": "type BlogContent struct {\n\tEdition      int     `gorm:\"column:edition\" json:\"edition\"`\n\tDiscountRate float64 `gorm:\"column:discount_rate\" json:\"discount_rate\"`\n\tLatitude     float64 `gorm:\"column:latitude\" json:\"latitude\"`\n}"
      },
      {
        "code_key": "BlogRepo",
        "code_value": "type BlogRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ContentReportsTable",
        "code_value": "const ContentReportsTable = \"content_reports\""
      },
      {
        "code_key": "select_edition",
        "code_value": "utils.SetSQLComment(ctx, \"select_edition\")"
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/org/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Expression {\n\tcomment := \"/* \" + clause + \" */\"\n\treturn gorm.Expr(comment)\n}"
      },
      {
        "code_key": "DiscountReport",
        "code_value": "type DiscountReport struct {\n\tID           int64   `gorm:\"column:id\" json:\"id\"`\n\tEdition      int     `gorm:\"column:edition\" json:\"edition\"`\n\tDiscountRate float64 `gorm:\"column:discount_rate\" json:\"discount_rate\"`\n\tLatitude     float64 `gorm:\"column:latitude\" json:\"latitude\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (d *DiscountReport) TableName() string {\n\treturn ContentReportsTable\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ValidateEdition",
    "orm_code": "func (repo *BlogRepo) ValidateEdition(ctx context.Context, blog *model.BlogContent) error {\n\tconst ContentReportsTable = \"content_reports\"\n\tselectClause := utils.SetSQLComment(ctx, \"select_edition\")\n\texisting := &model.BlogContent{}\n\n\tif err := repo.db.Clauses(selectClause).Table(ContentReportsTable).\n\t\tWhere(\"edition = ? AND latitude > ?\", blog.Edition, 0).\n\t\tFirst(existing).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif existing.DiscountRate != blog.DiscountRate {\n\t\treturn fmt.Errorf(\"discount rate mismatch for edition %d\", blog.Edition)\n\t}\n\n\treturn nil\n}",
    "caller": "func ProcessEditionCheck(ctx context.Context, contentData *model.BlogContent) (bool, error) {\n\trepository := NewBlogRepository(globalDB)\n\terr := repository.ValidateEdition(ctx, contentData)\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn true, nil\n\t\t}\n\t\treturn false, fmt.Errorf(\"edition validation error: %w\", err)\n\t}\n\treturn true, nil\n}",
    "sql_statement_list": [
      "SELECT * FROM content_reports WHERE edition = ? AND latitude > ? ORDER BY content_reports.id LIMIT 1;"
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "BlogContent",
        "code_value": "type BlogContent struct {\n\tEdition      int     `gorm:\"column:edition\" json:\"edition\"`\n\tDiscountRate float64 `gorm:\"column:discount_rate\" json:\"discount_rate\"`\n\tLatitude     float64 `gorm:\"column:latitude\" json:\"latitude\"`\n}"
      },
      {
        "code_key": "BlogRepo",
        "code_value": "type BlogRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ContentReportsTable",
        "code_value": "const ContentReportsTable = \"content_reports\""
      },
      {
        "code_key": "select_edition",
        "code_value": "utils.SetSQLComment(ctx, \"select_edition\")"
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/org/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Expression {\n\tcomment := \"/* \" + clause + \" */\"\n\treturn gorm.Expr(comment)\n}"
      },
      {
        "code_key": "DiscountReport",
        "code_value": "type DiscountReport struct {\n\tID           int64   `gorm:\"column:id\" json:\"id\"`\n\tEdition      int     `gorm:\"column:edition\" json:\"edition\"`\n\tDiscountRate float64 `gorm:\"column:discount_rate\" json:\"discount_rate\"`\n\tLatitude     float64 `gorm:\"column:latitude\" json:\"latitude\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (d *DiscountReport) TableName() string {\n\treturn ContentReportsTable\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "PurgeExpiredRecords",
    "orm_code": "func (repo *TimelineRepo) PurgeExpiredRecords(ctx context.Context, threshold int64) error {\n\tdeleteClause := utils.SetSQLComment(ctx, utils.DeleteKey)\n\t\n\tif err := repo.db.Clauses(deleteClause).Table(model.TimelineTableName).\n\t\tWhere(\"last_updated < ?\", threshold).\n\t\tDelete(&model.Timeline{}).Error; err != nil {\n\t\treturn err\n\t}\n\t\n\treturn nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "LACK_INFORMATION",
        "variants": [
          {
            "scenario": "缺少model.Timeline结构体和TimelineTableName常量定义",
            "sql": "DELETE FROM timeline WHERE last_updated < ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "DELETE"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PatientRepo",
        "code_value": "type PatientRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "queryClause",
        "code_value": "utils.SetSQLComment(ctx, utils.QueryKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/medical/patient-management/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) hints.Hints {\n\tcommentInfo := icontext.GetSQLCommentFromContext(ctx)\n\tif len(commentInfo.SessionId) < 16 {\n\t\tcommentInfo.SessionId = uuid.NewString()\n\t}\n\n\tcomment := fmt.Sprintf(\"m=%v,d=%v,p=%v,t=%v,s=%v\", MedicalCenter,\n\t\tcommentInfo.DoctorId, commentInfo.PatientId, commentInfo.Timestamp, commentInfo.SessionId)\n\treturn hints.CommentBefore(clause, comment)\n}"
      },
      {
        "code_key": "PatientRecordTableName",
        "code_value": "const PatientRecordTableName = \"hospital_patient_records\""
      },
      {
        "code_key": "patientRecord",
        "code_value": "&model.PatientRecord{}"
      },
      {
        "code_key": "PatientRecord",
        "code_value": "type PatientRecord struct {\n\tId            int64   `gorm:\"column:id\" json:\"id\"`\n\tPatientName   string  `gorm:\"column:patient_name\" json:\"patient_name\"`\n\tAge           int     `gorm:\"column:age\" json:\"age\"`\n\tGender        string  `gorm:\"column:gender\" json:\"gender\"`\n\tMedicalStatus int     `gorm:\"column:medical_status\" json:\"medical_status\"`\n\tLastCheckup   int64   `gorm:\"column:last_checkup\" json:\"last_checkup\"`\n\tBloodType     string  `gorm:\"column:blood_type\" json:\"blood_type\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (pr *PatientRecord) TableName() string {\n\treturn PatientRecordTableName\n}"
      },
      {
        "code_key": "MedicalCenter",
        "code_value": "const MedicalCenter = \"Central_Hospital\""
      },
      {
        "code_key": "createClause",
        "code_value": "utils.SetSQLComment(ctx, utils.CreateKey)"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "PurgeExpiredRecords",
    "orm_code": "func (repo *TimelineRepo) PurgeExpiredRecords(ctx context.Context, threshold int64) error {\n\tdeleteClause := utils.SetSQLComment(ctx, utils.DeleteKey)\n\t\n\tif err := repo.db.Clauses(deleteClause).Table(model.TimelineTableName).\n\t\tWhere(\"last_updated < ?\", threshold).\n\t\tDelete(&model.Timeline{}).Error; err != nil {\n\t\treturn err\n\t}\n\t\n\treturn nil\n}",
    "caller": "func HandlePostCleanup(ctx context.Context, dbConn *gorm.DB, retentionDays int) error {\n\trepo := &TimelineRepo{db: dbConn}\n\tthreshold := time.Now().AddDate(0, 0, -retentionDays).Unix()\n\tif err := repo.PurgeExpiredRecords(ctx, threshold); err != nil {\n\t\treturn fmt.Errorf(\"failed to purge old posts: %w\", err)\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "LACK_INFORMATION",
        "variants": [
          {
            "scenario": "缺少model.TimelineTableName定义，根据Timeline结构体推测表名",
            "sql": "DELETE FROM timeline WHERE last_updated < ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "DELETE"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PatientRepo",
        "code_value": "type PatientRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "queryClause",
        "code_value": "utils.SetSQLComment(ctx, utils.QueryKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/medical/patient-management/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) hints.Hints {\n\tcommentInfo := icontext.GetSQLCommentFromContext(ctx)\n\tif len(commentInfo.SessionId) < 16 {\n\t\tcommentInfo.SessionId = uuid.NewString()\n\t}\n\n\tcomment := fmt.Sprintf(\"m=%v,d=%v,p=%v,t=%v,s=%v\", MedicalCenter,\n\t\tcommentInfo.DoctorId, commentInfo.PatientId, commentInfo.Timestamp, commentInfo.SessionId)\n\treturn hints.CommentBefore(clause, comment)\n}"
      },
      {
        "code_key": "PatientRecordTableName",
        "code_value": "const PatientRecordTableName = \"hospital_patient_records\""
      },
      {
        "code_key": "patientRecord",
        "code_value": "&model.PatientRecord{}"
      },
      {
        "code_key": "PatientRecord",
        "code_value": "type PatientRecord struct {\n\tId            int64   `gorm:\"column:id\" json:\"id\"`\n\tPatientName   string  `gorm:\"column:patient_name\" json:\"patient_name\"`\n\tAge           int     `gorm:\"column:age\" json:\"age\"`\n\tGender        string  `gorm:\"column:gender\" json:\"gender\"`\n\tMedicalStatus int     `gorm:\"column:medical_status\" json:\"medical_status\"`\n\tLastCheckup   int64   `gorm:\"column:last_checkup\" json:\"last_checkup\"`\n\tBloodType     string  `gorm:\"column:blood_type\" json:\"blood_type\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (pr *PatientRecord) TableName() string {\n\treturn PatientRecordTableName\n}"
      },
      {
        "code_key": "MedicalCenter",
        "code_value": "const MedicalCenter = \"Central_Hospital\""
      },
      {
        "code_key": "createClause",
        "code_value": "utils.SetSQLComment(ctx, utils.CreateKey)"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "PurgeExpiredRecords",
    "orm_code": "func (repo *TimelineRepo) PurgeExpiredRecords(ctx context.Context, threshold int64) error {\n\tdeleteClause := utils.SetSQLComment(ctx, utils.DeleteKey)\n\t\n\tif err := repo.db.Clauses(deleteClause).Table(model.TimelineTableName).\n\t\tWhere(\"last_updated < ?\", threshold).\n\t\tDelete(&model.Timeline{}).Error; err != nil {\n\t\treturn err\n\t}\n\t\n\treturn nil\n}",
    "caller": "func ProcessRegionDataMaintenance(ctx context.Context, storage *gorm.DB, regionCode string) error {\n\trepo := &TimelineRepo{db: storage}\n\t// Purge records older than 90 days for specific region\n\texpiryCutoff := time.Now().AddDate(0, -3, 0).Unix()\n\terr := repo.PurgeExpiredRecords(ctx, expiryCutoff)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"region %s cleanup failed: %v\", regionCode, err)\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "LACK_INFORMATION",
        "variants": [
          {
            "scenario": "缺少model.TimelineTableName定义，根据Timeline结构体推测表名",
            "sql": "DELETE FROM timeline WHERE last_updated < ?;"
          },
          {
            "scenario": "缺少model.Timeline结构体定义，无法确认完整字段",
            "sql": "DELETE FROM timeline WHERE last_updated < ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "DELETE"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PatientRepo",
        "code_value": "type PatientRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "queryClause",
        "code_value": "utils.SetSQLComment(ctx, utils.QueryKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/medical/patient-management/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) hints.Hints {\n\tcommentInfo := icontext.GetSQLCommentFromContext(ctx)\n\tif len(commentInfo.SessionId) < 16 {\n\t\tcommentInfo.SessionId = uuid.NewString()\n\t}\n\n\tcomment := fmt.Sprintf(\"m=%v,d=%v,p=%v,t=%v,s=%v\", MedicalCenter,\n\t\tcommentInfo.DoctorId, commentInfo.PatientId, commentInfo.Timestamp, commentInfo.SessionId)\n\treturn hints.CommentBefore(clause, comment)\n}"
      },
      {
        "code_key": "PatientRecordTableName",
        "code_value": "const PatientRecordTableName = \"hospital_patient_records\""
      },
      {
        "code_key": "patientRecord",
        "code_value": "&model.PatientRecord{}"
      },
      {
        "code_key": "PatientRecord",
        "code_value": "type PatientRecord struct {\n\tId            int64   `gorm:\"column:id\" json:\"id\"`\n\tPatientName   string  `gorm:\"column:patient_name\" json:\"patient_name\"`\n\tAge           int     `gorm:\"column:age\" json:\"age\"`\n\tGender        string  `gorm:\"column:gender\" json:\"gender\"`\n\tMedicalStatus int     `gorm:\"column:medical_status\" json:\"medical_status\"`\n\tLastCheckup   int64   `gorm:\"column:last_checkup\" json:\"last_checkup\"`\n\tBloodType     string  `gorm:\"column:blood_type\" json:\"blood_type\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (pr *PatientRecord) TableName() string {\n\treturn PatientRecordTableName\n}"
      },
      {
        "code_key": "MedicalCenter",
        "code_value": "const MedicalCenter = \"Central_Hospital\""
      },
      {
        "code_key": "createClause",
        "code_value": "utils.SetSQLComment(ctx, utils.CreateKey)"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "PurgeExpiredRecords",
    "orm_code": "func (repo *TimelineRepo) PurgeExpiredRecords(ctx context.Context, threshold int64) error {\n\tdeleteClause := utils.SetSQLComment(ctx, utils.DeleteKey)\n\t\n\tif err := repo.db.Clauses(deleteClause).Table(model.TimelineTableName).\n\t\tWhere(\"last_updated < ?\", threshold).\n\t\tDelete(&model.Timeline{}).Error; err != nil {\n\t\treturn err\n\t}\n\t\n\treturn nil\n}",
    "caller": "func ExecuteScheduledPurge(dbInstance *gorm.DB) error {\n\trepository := &TimelineRepo{db: dbInstance}\n\t// Keep only last 30 days of data\n\tcutoffTime := time.Now().Add(-720 * time.Hour).Unix()\n\tif err := repository.PurgeExpiredRecords(context.Background(), cutoffTime); err != nil {\n\t\tlog.Printf(\"Database maintenance error: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "LACK_INFORMATION",
        "variants": [
          {
            "scenario": "缺少model.TimelineTableName定义，根据Timeline结构体推测表名",
            "sql": "DELETE FROM timeline WHERE last_updated < ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "DELETE"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PatientRepo",
        "code_value": "type PatientRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "queryClause",
        "code_value": "utils.SetSQLComment(ctx, utils.QueryKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/medical/patient-management/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) hints.Hints {\n\tcommentInfo := icontext.GetSQLCommentFromContext(ctx)\n\tif len(commentInfo.SessionId) < 16 {\n\t\tcommentInfo.SessionId = uuid.NewString()\n\t}\n\n\tcomment := fmt.Sprintf(\"m=%v,d=%v,p=%v,t=%v,s=%v\", MedicalCenter,\n\t\tcommentInfo.DoctorId, commentInfo.PatientId, commentInfo.Timestamp, commentInfo.SessionId)\n\treturn hints.CommentBefore(clause, comment)\n}"
      },
      {
        "code_key": "PatientRecordTableName",
        "code_value": "const PatientRecordTableName = \"hospital_patient_records\""
      },
      {
        "code_key": "patientRecord",
        "code_value": "&model.PatientRecord{}"
      },
      {
        "code_key": "PatientRecord",
        "code_value": "type PatientRecord struct {\n\tId            int64   `gorm:\"column:id\" json:\"id\"`\n\tPatientName   string  `gorm:\"column:patient_name\" json:\"patient_name\"`\n\tAge           int     `gorm:\"column:age\" json:\"age\"`\n\tGender        string  `gorm:\"column:gender\" json:\"gender\"`\n\tMedicalStatus int     `gorm:\"column:medical_status\" json:\"medical_status\"`\n\tLastCheckup   int64   `gorm:\"column:last_checkup\" json:\"last_checkup\"`\n\tBloodType     string  `gorm:\"column:blood_type\" json:\"blood_type\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (pr *PatientRecord) TableName() string {\n\treturn PatientRecordTableName\n}"
      },
      {
        "code_key": "MedicalCenter",
        "code_value": "const MedicalCenter = \"Central_Hospital\""
      },
      {
        "code_key": "createClause",
        "code_value": "utils.SetSQLComment(ctx, utils.CreateKey)"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ListWithPaging",
    "orm_code": "func (repo *QuizRepo) ListWithPaging(ctx context.Context, filter *QuizFilter, page, size int) ([]*Quiz, error) {\n\tconst QuizTableName = \"performance_reviews\"\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tvar quizzes []*Quiz\n\n\tquery := repo.db.Clauses(selectClause).Table(QuizTableName)\n\tif filter.FunctionName != \"\" {\n\t\tquery = query.Where(\"function_name = ?\", filter.FunctionName)\n\t}\n\tif filter.DepartmentCode != 0 {\n\t\tquery = query.Where(\"department_code = ?\", filter.DepartmentCode)\n\t}\n\n\tif err := query.Offset((page - 1) * size).\n\t\tLimit(size).\n\t\tFind(&quizzes).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn quizzes, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "无过滤条件",
            "sql": "SELECT id, function_name, department_code, review_score, created_at FROM performance_reviews LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "仅FunctionName条件",
            "sql": "SELECT id, function_name, department_code, review_score, created_at FROM performance_reviews WHERE function_name = ? LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "仅DepartmentCode条件",
            "sql": "SELECT id, function_name, department_code, review_score, created_at FROM performance_reviews WHERE department_code = ? LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "同时有FunctionName和DepartmentCode条件",
            "sql": "SELECT id, function_name, department_code, review_score, created_at FROM performance_reviews WHERE function_name = ? AND department_code = ? LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "QuizRepo",
        "code_value": "type QuizRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Quiz",
        "code_value": "type Quiz struct {\n\tID            int64  `gorm:\"column:id\" json:\"id\"`\n\tFunctionName  string `gorm:\"column:function_name\" json:\"function_name\"`\n\tDepartmentCode int    `gorm:\"column:department_code\" json:\"department_code\"`\n\tReviewScore   int    `gorm:\"column:review_score\" json:\"review_score\"`\n\tCreatedAt    time.Time `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "QuizFilter",
        "code_value": "type QuizFilter struct {\n\tFunctionName  string\n\tDepartmentCode int\n}"
      },
      {
        "code_key": "QuizTableName",
        "code_value": "const QuizTableName = \"performance_reviews\""
      },
      {
        "code_key": "PageSizeDefault",
        "code_value": "const PageSizeDefault = 20"
      },
      {
        "code_key": "MaxPageSize",
        "code_value": "const MaxPageSize = 100"
      },
      {
        "code_key": "ReviewStatusPending",
        "code_value": "const ReviewStatusPending = 1"
      },
      {
        "code_key": "ReviewStatusCompleted",
        "code_value": "const ReviewStatusCompleted = 2"
      },
      {
        "code_key": "selectClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SelectKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/org/pkg/utils"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ListWithPaging",
    "orm_code": "func (repo *QuizRepo) ListWithPaging(ctx context.Context, filter *QuizFilter, page, size int) ([]*Quiz, error) {\n\tconst QuizTableName = \"performance_reviews\"\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tvar quizzes []*Quiz\n\n\tquery := repo.db.Clauses(selectClause).Table(QuizTableName)\n\tif filter.FunctionName != \"\" {\n\t\tquery = query.Where(\"function_name = ?\", filter.FunctionName)\n\t}\n\tif filter.DepartmentCode != 0 {\n\t\tquery = query.Where(\"department_code = ?\", filter.DepartmentCode)\n\t}\n\n\tif err := query.Offset((page - 1) * size).\n\t\tLimit(size).\n\t\tFind(&quizzes).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn quizzes, nil\n}",
    "caller": "func HandlePerformanceReview(ctx context.Context, role string) ([]*Quiz, error) {\n\treviewRepo, err := InitializeQuizRepo()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to init repo: %v\", err)\n\t}\n\n\tcriteria := &QuizFilter{\n\t\tFunctionName:   role,\n\t\tDepartmentCode: 0,\n\t}\n\n\tresults, err := reviewRepo.ListWithPaging(ctx, criteria, 1, 10)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"query failed: %v\", err)\n\t}\n\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "FunctionName filter only",
            "sql": "SELECT id, function_name, department_code, review_score, created_at FROM performance_reviews WHERE function_name = ? LIMIT 10 OFFSET 0;"
          },
          {
            "scenario": "FunctionName and DepartmentCode filters",
            "sql": "SELECT id, function_name, department_code, review_score, created_at FROM performance_reviews WHERE function_name = ? AND department_code = ? LIMIT 10 OFFSET 0;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "QuizRepo",
        "code_value": "type QuizRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Quiz",
        "code_value": "type Quiz struct {\n\tID            int64  `gorm:\"column:id\" json:\"id\"`\n\tFunctionName  string `gorm:\"column:function_name\" json:\"function_name\"`\n\tDepartmentCode int    `gorm:\"column:department_code\" json:\"department_code\"`\n\tReviewScore   int    `gorm:\"column:review_score\" json:\"review_score\"`\n\tCreatedAt    time.Time `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "QuizFilter",
        "code_value": "type QuizFilter struct {\n\tFunctionName  string\n\tDepartmentCode int\n}"
      },
      {
        "code_key": "QuizTableName",
        "code_value": "const QuizTableName = \"performance_reviews\""
      },
      {
        "code_key": "PageSizeDefault",
        "code_value": "const PageSizeDefault = 20"
      },
      {
        "code_key": "MaxPageSize",
        "code_value": "const MaxPageSize = 100"
      },
      {
        "code_key": "ReviewStatusPending",
        "code_value": "const ReviewStatusPending = 1"
      },
      {
        "code_key": "ReviewStatusCompleted",
        "code_value": "const ReviewStatusCompleted = 2"
      },
      {
        "code_key": "selectClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SelectKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/org/pkg/utils"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ListWithPaging",
    "orm_code": "func (repo *QuizRepo) ListWithPaging(ctx context.Context, filter *QuizFilter, page, size int) ([]*Quiz, error) {\n\tconst QuizTableName = \"performance_reviews\"\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tvar quizzes []*Quiz\n\n\tquery := repo.db.Clauses(selectClause).Table(QuizTableName)\n\tif filter.FunctionName != \"\" {\n\t\tquery = query.Where(\"function_name = ?\", filter.FunctionName)\n\t}\n\tif filter.DepartmentCode != 0 {\n\t\tquery = query.Where(\"department_code = ?\", filter.DepartmentCode)\n\t}\n\n\tif err := query.Offset((page - 1) * size).\n\t\tLimit(size).\n\t\tFind(&quizzes).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn quizzes, nil\n}",
    "caller": "func FetchDepartmentReviews(ctx context.Context, deptID int, pageSize int) ([]*Quiz, error) {\n\tdbRepo := NewQuizRepository()\n\tif dbRepo == nil {\n\t\treturn nil, errors.New(\"repository initialization failed\")\n\t}\n\n\tfilters := &QuizFilter{\n\t\tDepartmentCode: deptID,\n\t}\n\n\treviews, err := dbRepo.ListWithPaging(ctx, filters, 1, pageSize)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"paging query error: %w\", err)\n\t}\n\n\tif len(reviews) == 0 {\n\t\treturn nil, nil\n\t}\n\n\treturn reviews, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "只有DepartmentCode条件（调用者传递的场景）",
            "sql": "SELECT id, function_name, department_code, review_score, created_at FROM performance_reviews WHERE department_code = ? LIMIT ? OFFSET 0;"
          },
          {
            "scenario": "FunctionName和DepartmentCode都有条件（潜在可能）",
            "sql": "SELECT id, function_name, department_code, review_score, created_at FROM performance_reviews WHERE function_name = ? AND department_code = ? LIMIT ? OFFSET ?;"
          },
          {
            "scenario": "无条件查询（潜在可能）",
            "sql": "SELECT id, function_name, department_code, review_score, created_at FROM performance_reviews LIMIT ? OFFSET ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "QuizRepo",
        "code_value": "type QuizRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Quiz",
        "code_value": "type Quiz struct {\n\tID            int64  `gorm:\"column:id\" json:\"id\"`\n\tFunctionName  string `gorm:\"column:function_name\" json:\"function_name\"`\n\tDepartmentCode int    `gorm:\"column:department_code\" json:\"department_code\"`\n\tReviewScore   int    `gorm:\"column:review_score\" json:\"review_score\"`\n\tCreatedAt    time.Time `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "QuizFilter",
        "code_value": "type QuizFilter struct {\n\tFunctionName  string\n\tDepartmentCode int\n}"
      },
      {
        "code_key": "QuizTableName",
        "code_value": "const QuizTableName = \"performance_reviews\""
      },
      {
        "code_key": "PageSizeDefault",
        "code_value": "const PageSizeDefault = 20"
      },
      {
        "code_key": "MaxPageSize",
        "code_value": "const MaxPageSize = 100"
      },
      {
        "code_key": "ReviewStatusPending",
        "code_value": "const ReviewStatusPending = 1"
      },
      {
        "code_key": "ReviewStatusCompleted",
        "code_value": "const ReviewStatusCompleted = 2"
      },
      {
        "code_key": "selectClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SelectKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/org/pkg/utils"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "MigrateData",
    "orm_code": "func (repo *ScannerRepo) MigrateData(ctx context.Context, pattern string) error {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tinsertClause := utils.SetSQLComment(ctx, utils.InsertKey)\n\tvar scanners []*model.Scanner\n\n\tif err := repo.db.Clauses(selectClause).Table(model.ScannerTableName).\n\t\tWhere(\"summary LIKE ?\", \"%\"+pattern+\"%\").\n\t\tFind(&scanners).\n\t\tError; err != nil {\n\t\treturn err\n\t}\n\n\tfor _, s := range scanners {\n\t\tif err := repo.db.Clauses(insertClause).Table(model.ScannerArchiveTableName).\n\t\t\tCreate(s).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "SELECT query with pattern matching",
            "sql": "SELECT id, name, summary, status FROM scanners WHERE summary LIKE '%pattern%';"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "INSERT each scanner record into archive",
            "sql": "INSERT INTO scanner_archives (id, name, summary, archived_at) VALUES (?, ?, ?, ?);"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ScannerRepo",
        "code_value": "type ScannerRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Scanner",
        "code_value": "type Scanner struct {\n\tID      int64  `gorm:\"column:id\" json:\"id\"`\n\tName    string `gorm:\"column:name\" json:\"name\"`\n\tSummary string `gorm:\"column:summary\" json:\"summary\"`\n\tStatus  int    `gorm:\"column:status\" json:\"status\"`\n}"
      },
      {
        "code_key": "ScannerArchive",
        "code_value": "type ScannerArchive struct {\n\tID      int64  `gorm:\"column:id\" json:\"id\"`\n\tName    string `gorm:\"column:name\" json:\"name\"`\n\tSummary string `gorm:\"column:summary\" json:\"summary\"`\n\tArchivedAt int64 `gorm:\"column:archived_at\" json:\"archived_at\"`\n}"
      },
      {
        "code_key": "ScannerTableName",
        "code_value": "const ScannerTableName = \"scanners\""
      },
      {
        "code_key": "ScannerArchiveTableName",
        "code_value": "const ScannerArchiveTableName = \"scanner_archives\""
      },
      {
        "code_key": "ActiveStatus",
        "code_value": "const ActiveStatus = 1"
      },
      {
        "code_key": "InactiveStatus",
        "code_value": "const InactiveStatus = 0"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "DefaultPattern",
        "code_value": "const DefaultPattern = \"test\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (s *Scanner) TableName() string {\n\treturn ScannerTableName\n}"
      },
      {
        "code_key": "ArchiveTableName",
        "code_value": "func (sa *ScannerArchive) TableName() string {\n\treturn ScannerArchiveTableName\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "MigrateData",
    "orm_code": "func (repo *ScannerRepo) MigrateData(ctx context.Context, pattern string) error {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tinsertClause := utils.SetSQLComment(ctx, utils.InsertKey)\n\tvar scanners []*model.Scanner\n\n\tif err := repo.db.Clauses(selectClause).Table(model.ScannerTableName).\n\t\tWhere(\"summary LIKE ?\", \"%\"+pattern+\"%\").\n\t\tFind(&scanners).\n\t\tError; err != nil {\n\t\treturn err\n\t}\n\n\tfor _, s := range scanners {\n\t\tif err := repo.db.Clauses(insertClause).Table(model.ScannerArchiveTableName).\n\t\t\tCreate(s).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func HandleScannerMigration(ctx context.Context, searchPattern string, logger *zap.Logger) error {\n\tdbConn, err := config.GetDatabaseConnection()\n\tif err != nil {\n\t\tlogger.Error(\"Failed to get DB connection\", zap.Error(err))\n\t\treturn err\n\t}\n\n\tscannerRepo := &repository.ScannerRepo{db: dbConn}\n\terr = scannerRepo.MigrateData(ctx, searchPattern)\n\tif err != nil {\n\t\tlogger.Error(\"Data migration failed\", \n\t\t\tzap.String(\"pattern\", searchPattern), \n\t\t\tzap.Error(err))\n\t\treturn fmt.Errorf(\"migration error: %w\", err)\n\t}\n\tlogger.Info(\"Scanner data migrated successfully\")\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "SELECT query with pattern filter",
            "sql": "SELECT id, name, summary, status FROM scanners WHERE summary LIKE '%pattern%';"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "INSERT into archive table for each matching record",
            "sql": "INSERT INTO scanner_archives (id, name, summary, archived_at) VALUES (?, ?, ?, ?);"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ScannerRepo",
        "code_value": "type ScannerRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Scanner",
        "code_value": "type Scanner struct {\n\tID      int64  `gorm:\"column:id\" json:\"id\"`\n\tName    string `gorm:\"column:name\" json:\"name\"`\n\tSummary string `gorm:\"column:summary\" json:\"summary\"`\n\tStatus  int    `gorm:\"column:status\" json:\"status\"`\n}"
      },
      {
        "code_key": "ScannerArchive",
        "code_value": "type ScannerArchive struct {\n\tID      int64  `gorm:\"column:id\" json:\"id\"`\n\tName    string `gorm:\"column:name\" json:\"name\"`\n\tSummary string `gorm:\"column:summary\" json:\"summary\"`\n\tArchivedAt int64 `gorm:\"column:archived_at\" json:\"archived_at\"`\n}"
      },
      {
        "code_key": "ScannerTableName",
        "code_value": "const ScannerTableName = \"scanners\""
      },
      {
        "code_key": "ScannerArchiveTableName",
        "code_value": "const ScannerArchiveTableName = \"scanner_archives\""
      },
      {
        "code_key": "ActiveStatus",
        "code_value": "const ActiveStatus = 1"
      },
      {
        "code_key": "InactiveStatus",
        "code_value": "const InactiveStatus = 0"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "DefaultPattern",
        "code_value": "const DefaultPattern = \"test\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (s *Scanner) TableName() string {\n\treturn ScannerTableName\n}"
      },
      {
        "code_key": "ArchiveTableName",
        "code_value": "func (sa *ScannerArchive) TableName() string {\n\treturn ScannerArchiveTableName\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "MigrateData",
    "orm_code": "func (repo *ScannerRepo) MigrateData(ctx context.Context, pattern string) error {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tinsertClause := utils.SetSQLComment(ctx, utils.InsertKey)\n\tvar scanners []*model.Scanner\n\n\tif err := repo.db.Clauses(selectClause).Table(model.ScannerTableName).\n\t\tWhere(\"summary LIKE ?\", \"%\"+pattern+\"%\").\n\t\tFind(&scanners).\n\t\tError; err != nil {\n\t\treturn err\n\t}\n\n\tfor _, s := range scanners {\n\t\tif err := repo.db.Clauses(insertClause).Table(model.ScannerArchiveTableName).\n\t\t\tCreate(s).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func ProcessSecurityScanArchive(ctx context.Context) error {\n\tdbEngine := infrastructure.GetDB()\n\tif dbEngine == nil {\n\t\treturn errors.New(\"database engine not initialized\")\n\t}\n\n\trepo := &scanner.ScannerRepo{db: dbEngine}\n\terr := repo.MigrateData(ctx, \"CVE-\")\n\tif err != nil {\n\t\tmetrics.Increment(\"scanner_migration_failure\")\n\t\treturn err\n\t}\n\tmetrics.Increment(\"scanner_migration_success\")\n\treturn nil\n}",
    "sql_statement_list": [
      "SELECT id, name, summary, status FROM scanners WHERE summary LIKE '%CVE-%';",
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Insert each scanner record into archive table",
            "sql": "INSERT INTO scanner_archives (id, name, summary, archived_at) VALUES (?, ?, ?, ?);"
          }
        ]
      }
    ],
    "sql_types": [
      "SELECT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ScannerRepo",
        "code_value": "type ScannerRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Scanner",
        "code_value": "type Scanner struct {\n\tID      int64  `gorm:\"column:id\" json:\"id\"`\n\tName    string `gorm:\"column:name\" json:\"name\"`\n\tSummary string `gorm:\"column:summary\" json:\"summary\"`\n\tStatus  int    `gorm:\"column:status\" json:\"status\"`\n}"
      },
      {
        "code_key": "ScannerArchive",
        "code_value": "type ScannerArchive struct {\n\tID      int64  `gorm:\"column:id\" json:\"id\"`\n\tName    string `gorm:\"column:name\" json:\"name\"`\n\tSummary string `gorm:\"column:summary\" json:\"summary\"`\n\tArchivedAt int64 `gorm:\"column:archived_at\" json:\"archived_at\"`\n}"
      },
      {
        "code_key": "ScannerTableName",
        "code_value": "const ScannerTableName = \"scanners\""
      },
      {
        "code_key": "ScannerArchiveTableName",
        "code_value": "const ScannerArchiveTableName = \"scanner_archives\""
      },
      {
        "code_key": "ActiveStatus",
        "code_value": "const ActiveStatus = 1"
      },
      {
        "code_key": "InactiveStatus",
        "code_value": "const InactiveStatus = 0"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "DefaultPattern",
        "code_value": "const DefaultPattern = \"test\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (s *Scanner) TableName() string {\n\treturn ScannerTableName\n}"
      },
      {
        "code_key": "ArchiveTableName",
        "code_value": "func (sa *ScannerArchive) TableName() string {\n\treturn ScannerArchiveTableName\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "PreventAttack",
    "orm_code": "func (repo *SecurityRepo) PreventAttack(ctx context.Context, log *AuditLog) error {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tinsertClause := utils.SetSQLComment(ctx, utils.InsertKey)\n\texistingLog := &AuditLog{}\n\n\tif err := repo.db.Clauses(queryClause).Table(model.AuditLogTableName).\n\t\tWhere(\"room = ? AND database_name = ?\", log.Room, log.DatabaseName).\n\t\tFirst(existingLog).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\tif err := repo.db.Clauses(insertClause).Table(model.AuditLogTableName).\n\t\t\t\tCreate(log).Error; err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif existingLog.DeliveryCode != log.DeliveryCode {\n\t\tif err := repo.db.Table(model.AuditLogTableName).\n\t\t\tWhere(\"id = ?\", existingLog.ID).\n\t\t\tUpdate(\"delivery_code\", log.DeliveryCode).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "记录不存在（首次创建）",
            "sql": "SELECT id, room, database_name, delivery_code, created_at FROM security_audit_log WHERE room = ? AND database_name = ? ORDER BY security_audit_log.id LIMIT 1;"
          },
          {
            "scenario": "记录存在但DeliveryCode相同",
            "sql": "SELECT id, room, database_name, delivery_code, created_at FROM security_audit_log WHERE room = ? AND database_name = ? ORDER BY security_audit_log.id LIMIT 1;"
          },
          {
            "scenario": "记录存在且DeliveryCode不同",
            "sql": "SELECT id, room, database_name, delivery_code, created_at FROM security_audit_log WHERE room = ? AND database_name = ? ORDER BY security_audit_log.id LIMIT 1;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "记录不存在（首次创建）- 创建新记录",
            "sql": "INSERT INTO security_audit_log (room, database_name, delivery_code, created_at) VALUES (?, ?, ?, ?);"
          },
          {
            "scenario": "记录存在且DeliveryCode不同 - 更新记录",
            "sql": "UPDATE security_audit_log SET delivery_code = ? WHERE id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "SecurityRepo",
        "code_value": "type SecurityRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "AuditLogTableName",
        "code_value": "const AuditLogTableName = \"security_audit_log\""
      },
      {
        "code_key": "AuditLog",
        "code_value": "type AuditLog struct {\n\tID           uint   `gorm:\"column:id\" json:\"id\"`\n\tRoom         string `gorm:\"column:room\" json:\"room\"`\n\tDatabaseName string `gorm:\"column:database_name\" json:\"database_name\"`\n\tDeliveryCode string `gorm:\"column:delivery_code\" json:\"delivery_code\"`\n\tCreatedAt    int64  `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"QUERY\""
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "SecurityEvent",
        "code_value": "type SecurityEvent struct {\n\tEventType   string `json:\"event_type\"`\n\tDescription string `json:\"description\"`\n\tSeverity    int    `json:\"severity\"`\n}"
      },
      {
        "code_key": "AuditLogResponse",
        "code_value": "type AuditLogResponse struct {\n\tSuccess bool   `json:\"success\"`\n\tMessage string `json:\"message\"`\n\tLogID   uint   `json:\"log_id\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (al *AuditLog) TableName() string {\n\treturn AuditLogTableName\n}"
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "PreventAttack",
    "orm_code": "func (repo *SecurityRepo) PreventAttack(ctx context.Context, log *AuditLog) error {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tinsertClause := utils.SetSQLComment(ctx, utils.InsertKey)\n\texistingLog := &AuditLog{}\n\n\tif err := repo.db.Clauses(queryClause).Table(model.AuditLogTableName).\n\t\tWhere(\"room = ? AND database_name = ?\", log.Room, log.DatabaseName).\n\t\tFirst(existingLog).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\tif err := repo.db.Clauses(insertClause).Table(model.AuditLogTableName).\n\t\t\t\tCreate(log).Error; err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif existingLog.DeliveryCode != log.DeliveryCode {\n\t\tif err := repo.db.Table(model.AuditLogTableName).\n\t\t\tWhere(\"id = ?\", existingLog.ID).\n\t\t\tUpdate(\"delivery_code\", log.DeliveryCode).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func HandleAuditLogUpdate(ctx context.Context, dbConn *gorm.DB) error {\n\tsecRepo := &SecurityRepo{db: dbConn}\n\tauditEntry := &AuditLog{\n\t\tRoom:         \"conference_room\",\n\t\tDatabaseName: \"medical_records\",\n\t\tDeliveryCode: \"SECURE123\",\n\t}\n\n\tif err := secRepo.PreventAttack(ctx, auditEntry); err != nil {\n\t\treturn fmt.Errorf(\"failed to process audit log: %v\", err)\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "查询日志记录",
            "sql": "SELECT id, room, database_name, delivery_code, created_at FROM security_audit_log WHERE room = 'conference_room' AND database_name = 'medical_records' ORDER BY security_audit_log.id LIMIT 1;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "当记录不存在时插入新记录",
            "sql": "INSERT INTO security_audit_log (room, database_name, delivery_code, created_at) VALUES ('conference_room', 'medical_records', 'SECURE123', UNIX_TIMESTAMP());"
          },
          {
            "scenario": "当记录存在但DeliveryCode不同时更新记录",
            "sql": "UPDATE security_audit_log SET delivery_code = 'NEW_CODE' WHERE id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "SecurityRepo",
        "code_value": "type SecurityRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "AuditLogTableName",
        "code_value": "const AuditLogTableName = \"security_audit_log\""
      },
      {
        "code_key": "AuditLog",
        "code_value": "type AuditLog struct {\n\tID           uint   `gorm:\"column:id\" json:\"id\"`\n\tRoom         string `gorm:\"column:room\" json:\"room\"`\n\tDatabaseName string `gorm:\"column:database_name\" json:\"database_name\"`\n\tDeliveryCode string `gorm:\"column:delivery_code\" json:\"delivery_code\"`\n\tCreatedAt    int64  `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"QUERY\""
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "SecurityEvent",
        "code_value": "type SecurityEvent struct {\n\tEventType   string `json:\"event_type\"`\n\tDescription string `json:\"description\"`\n\tSeverity    int    `json:\"severity\"`\n}"
      },
      {
        "code_key": "AuditLogResponse",
        "code_value": "type AuditLogResponse struct {\n\tSuccess bool   `json:\"success\"`\n\tMessage string `json:\"message\"`\n\tLogID   uint   `json:\"log_id\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (al *AuditLog) TableName() string {\n\treturn AuditLogTableName\n}"
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "PreventAttack",
    "orm_code": "func (repo *SecurityRepo) PreventAttack(ctx context.Context, log *AuditLog) error {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\tinsertClause := utils.SetSQLComment(ctx, utils.InsertKey)\n\texistingLog := &AuditLog{}\n\n\tif err := repo.db.Clauses(queryClause).Table(model.AuditLogTableName).\n\t\tWhere(\"room = ? AND database_name = ?\", log.Room, log.DatabaseName).\n\t\tFirst(existingLog).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\tif err := repo.db.Clauses(insertClause).Table(model.AuditLogTableName).\n\t\t\t\tCreate(log).Error; err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif existingLog.DeliveryCode != log.DeliveryCode {\n\t\tif err := repo.db.Table(model.AuditLogTableName).\n\t\t\tWhere(\"id = ?\", existingLog.ID).\n\t\t\tUpdate(\"delivery_code\", log.DeliveryCode).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func ProcessSecurityCheck(ctx context.Context, dbEngine *gorm.DB, facility string) error {\n\tsecurityRepo := &SecurityRepo{db: dbEngine}\n\tlogData := &AuditLog{\n\t\tRoom:         facility,\n\t\tDatabaseName: \"patient_data\",\n\t\tDeliveryCode: \"HEALTH456\",\n\t}\n\n\terr := securityRepo.PreventAttack(ctx, logData)\n\tif err != nil {\n\t\tlog.Printf(\"security check failed for %s: %v\", facility, err)\n\t\treturn err\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "基本查询语句（总是执行）",
            "sql": "SELECT id, room, database_name, delivery_code, created_at FROM security_audit_log WHERE room = ? AND database_name = ? LIMIT 1;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "插入语句（当记录不存在时执行）",
            "sql": "INSERT INTO security_audit_log (room, database_name, delivery_code, created_at) VALUES (?, ?, ?, ?);"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "更新语句（当记录存在且DeliveryCode不同时执行）",
            "sql": "UPDATE security_audit_log SET delivery_code = ? WHERE id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "SecurityRepo",
        "code_value": "type SecurityRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "AuditLogTableName",
        "code_value": "const AuditLogTableName = \"security_audit_log\""
      },
      {
        "code_key": "AuditLog",
        "code_value": "type AuditLog struct {\n\tID           uint   `gorm:\"column:id\" json:\"id\"`\n\tRoom         string `gorm:\"column:room\" json:\"room\"`\n\tDatabaseName string `gorm:\"column:database_name\" json:\"database_name\"`\n\tDeliveryCode string `gorm:\"column:delivery_code\" json:\"delivery_code\"`\n\tCreatedAt    int64  `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"QUERY\""
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "SecurityEvent",
        "code_value": "type SecurityEvent struct {\n\tEventType   string `json:\"event_type\"`\n\tDescription string `json:\"description\"`\n\tSeverity    int    `json:\"severity\"`\n}"
      },
      {
        "code_key": "AuditLogResponse",
        "code_value": "type AuditLogResponse struct {\n\tSuccess bool   `json:\"success\"`\n\tMessage string `json:\"message\"`\n\tLogID   uint   `json:\"log_id\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (al *AuditLog) TableName() string {\n\treturn AuditLogTableName\n}"
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "SyncWithExternal",
    "orm_code": "func (repo *RiskRepo) SyncWithExternal(ctx context.Context, externalData *model.Express) error {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\texisting := &model.Express{}\n\n\tif err := repo.db.Clauses(selectClause).Table(model.ExpressTableName).\n\t\tWhere(\"transaction_id = ?\", externalData.TransactionId).\n\t\tFirst(existing).Error; err != nil {\n\t\tif !errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn err\n\t\t}\n\t\t// 不存在则创建\n\t\treturn repo.db.Table(model.ExpressTableName).Create(externalData).Error\n\t}\n\n\t// 存在则更新时区字段\n\tif existing.Timezone != externalData.Timezone {\n\t\treturn repo.db.Clauses(updateClause).Table(model.ExpressTableName).\n\t\t\tWhere(\"transaction_id = ?\", externalData.TransactionId).\n\t\t\tUpdate(\"timezone\", externalData.Timezone).Error\n\t}\n\n\treturn nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "EmployeeId > 0 and Department is Finance",
            "sql": "SELECT * FROM insurance_policies WHERE status = 1 AND policy_type = 'corporate' AND employee_id = ?;"
          },
          {
            "scenario": "EmployeeId > 0 and Department is HR",
            "sql": "SELECT * FROM insurance_policies WHERE status = 1 AND policy_type = 'employee_benefit' AND employee_id = ?;"
          },
          {
            "scenario": "EmployeeId > 0 and Department is IT",
            "sql": "SELECT * FROM insurance_policies WHERE status = 1 AND policy_type = 'equipment_coverage' AND employee_id = ?;"
          },
          {
            "scenario": "EmployeeId <= 0 and Department is Finance",
            "sql": "SELECT * FROM insurance_policies WHERE status = 1 AND policy_type = 'corporate';"
          },
          {
            "scenario": "EmployeeId <= 0 and Department is HR",
            "sql": "SELECT * FROM insurance_policies WHERE status = 1 AND policy_type = 'employee_benefit';"
          },
          {
            "scenario": "EmployeeId <= 0 and Department is IT",
            "sql": "SELECT * FROM insurance_policies WHERE status = 1 AND policy_type = 'equipment_coverage';"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "RiskRepo",
        "code_value": "type RiskRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ExpressTableName",
        "code_value": "const ExpressTableName = \"risk_express_record\""
      },
      {
        "code_key": "Express",
        "code_value": "type Express struct {\n\tTransactionId string `gorm:\"column:transaction_id\" json:\"transaction_id\"`\n\tTimezone      string `gorm:\"column:timezone\" json:\"timezone\"`\n\tStatus        int    `gorm:\"column:status\" json:\"status\"`\n\tCreatedAt     int64  `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (e *Express) TableName() string {\n\treturn ExpressTableName\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "hints",
        "code_value": "import \"gorm.io/hints\""
      },
      {
        "code_key": "gorm",
        "code_value": "import \"gorm.io/gorm\""
      },
      {
        "code_key": "errors",
        "code_value": "import \"errors\""
      },
      {
        "code_key": "icontext",
        "code_value": "import \"git.woa.com/IVC/ivc-risk/pkg/icontext\""
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "SyncWithExternal",
    "orm_code": "func (repo *RiskRepo) SyncWithExternal(ctx context.Context, externalData *model.Express) error {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\texisting := &model.Express{}\n\n\tif err := repo.db.Clauses(selectClause).Table(model.ExpressTableName).\n\t\tWhere(\"transaction_id = ?\", externalData.TransactionId).\n\t\tFirst(existing).Error; err != nil {\n\t\tif !errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn err\n\t\t}\n\t\t// 不存在则创建\n\t\treturn repo.db.Table(model.ExpressTableName).Create(externalData).Error\n\t}\n\n\t// 存在则更新时区字段\n\tif existing.Timezone != externalData.Timezone {\n\t\treturn repo.db.Clauses(updateClause).Table(model.ExpressTableName).\n\t\t\tWhere(\"transaction_id = ?\", externalData.TransactionId).\n\t\t\tUpdate(\"timezone\", externalData.Timezone).Error\n\t}\n\n\treturn nil\n}",
    "caller": "func HandleExpressSync(ctx context.Context, transID string, zone string, log *zap.Logger) error {\n\trepo := &RiskRepo{db: conf.GetDBEngine()}\n\texpressData := &model.Express{\n\t\tTransactionId: transID,\n\t\tTimezone:      zone,\n\t}\n\n\tif err := repo.SyncWithExternal(ctx, expressData); err != nil {\n\t\tlog.Error(\"failed to sync express data\", zap.Error(err))\n\t\treturn err\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "SELECT query for existing record",
            "sql": "SELECT * FROM risk_express_record WHERE transaction_id = ? ORDER BY risk_express_record.transaction_id LIMIT 1;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "INSERT when record not exists",
            "sql": "INSERT INTO risk_express_record (transaction_id, timezone, status, created_at) VALUES (?, ?, ?, ?);"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "UPDATE when timezone differs",
            "sql": "UPDATE risk_express_record SET timezone = ? WHERE transaction_id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "RiskRepo",
        "code_value": "type RiskRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ExpressTableName",
        "code_value": "const ExpressTableName = \"risk_express_record\""
      },
      {
        "code_key": "Express",
        "code_value": "type Express struct {\n\tTransactionId string `gorm:\"column:transaction_id\" json:\"transaction_id\"`\n\tTimezone      string `gorm:\"column:timezone\" json:\"timezone\"`\n\tStatus        int    `gorm:\"column:status\" json:\"status\"`\n\tCreatedAt     int64  `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (e *Express) TableName() string {\n\treturn ExpressTableName\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "hints",
        "code_value": "import \"gorm.io/hints\""
      },
      {
        "code_key": "gorm",
        "code_value": "import \"gorm.io/gorm\""
      },
      {
        "code_key": "errors",
        "code_value": "import \"errors\""
      },
      {
        "code_key": "icontext",
        "code_value": "import \"git.woa.com/IVC/ivc-risk/pkg/icontext\""
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "SyncWithExternal",
    "orm_code": "func (repo *RiskRepo) SyncWithExternal(ctx context.Context, externalData *model.Express) error {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\texisting := &model.Express{}\n\n\tif err := repo.db.Clauses(selectClause).Table(model.ExpressTableName).\n\t\tWhere(\"transaction_id = ?\", externalData.TransactionId).\n\t\tFirst(existing).Error; err != nil {\n\t\tif !errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn err\n\t\t}\n\t\t// 不存在则创建\n\t\treturn repo.db.Table(model.ExpressTableName).Create(externalData).Error\n\t}\n\n\t// 存在则更新时区字段\n\tif existing.Timezone != externalData.Timezone {\n\t\treturn repo.db.Clauses(updateClause).Table(model.ExpressTableName).\n\t\t\tWhere(\"transaction_id = ?\", externalData.TransactionId).\n\t\t\tUpdate(\"timezone\", externalData.Timezone).Error\n\t}\n\n\treturn nil\n}",
    "caller": "func ProcessShippingUpdate(ctx context.Context, shippingInfo *model.Express) error {\n\trepo := &RiskRepo{db: conf.GetDBEngine()}\n\tif shippingInfo == nil {\n\t\treturn errors.New(\"invalid shipping info\")\n\t}\n\n\treturn repo.SyncWithExternal(ctx, shippingInfo)\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "SELECT existing record",
            "sql": "SELECT transaction_id, timezone, status, created_at FROM risk_express_record WHERE transaction_id = ? LIMIT 1;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "INSERT new record when not exists",
            "sql": "INSERT INTO risk_express_record (transaction_id, timezone, status, created_at) VALUES (?, ?, ?, ?);"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "UPDATE timezone when exists and timezone differs",
            "sql": "UPDATE risk_express_record SET timezone = ? WHERE transaction_id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "RiskRepo",
        "code_value": "type RiskRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ExpressTableName",
        "code_value": "const ExpressTableName = \"risk_express_record\""
      },
      {
        "code_key": "Express",
        "code_value": "type Express struct {\n\tTransactionId string `gorm:\"column:transaction_id\" json:\"transaction_id\"`\n\tTimezone      string `gorm:\"column:timezone\" json:\"timezone\"`\n\tStatus        int    `gorm:\"column:status\" json:\"status\"`\n\tCreatedAt     int64  `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (e *Express) TableName() string {\n\treturn ExpressTableName\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "hints",
        "code_value": "import \"gorm.io/hints\""
      },
      {
        "code_key": "gorm",
        "code_value": "import \"gorm.io/gorm\""
      },
      {
        "code_key": "errors",
        "code_value": "import \"errors\""
      },
      {
        "code_key": "icontext",
        "code_value": "import \"git.woa.com/IVC/ivc-risk/pkg/icontext\""
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "SyncWithExternal",
    "orm_code": "func (repo *RiskRepo) SyncWithExternal(ctx context.Context, externalData *model.Express) error {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\texisting := &model.Express{}\n\n\tif err := repo.db.Clauses(selectClause).Table(model.ExpressTableName).\n\t\tWhere(\"transaction_id = ?\", externalData.TransactionId).\n\t\tFirst(existing).Error; err != nil {\n\t\tif !errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn err\n\t\t}\n\t\t// 不存在则创建\n\t\treturn repo.db.Table(model.ExpressTableName).Create(externalData).Error\n\t}\n\n\t// 存在则更新时区字段\n\tif existing.Timezone != externalData.Timezone {\n\t\treturn repo.db.Clauses(updateClause).Table(model.ExpressTableName).\n\t\t\tWhere(\"transaction_id = ?\", externalData.TransactionId).\n\t\t\tUpdate(\"timezone\", externalData.Timezone).Error\n\t}\n\n\treturn nil\n}",
    "caller": "func HandleEmployeeSync() error {\n\tstaff := &Employee{\n\t\tEmployeeId: 1001,\n\t\tDepartment: \"HR\",\n\t}\n\terr := staff.SyncWithExternal()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to sync HR policies: %v\", err)\n\t\treturn err\n\t}\n\tfmt.Println(\"HR policies synced successfully\")\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Department is Finance and employee_id is provided",
            "sql": "SELECT * FROM insurance_policies WHERE status = 1 AND policy_type = 'corporate' AND employee_id = ?;"
          },
          {
            "scenario": "Department is HR and employee_id is provided",
            "sql": "SELECT * FROM insurance_policies WHERE status = 1 AND policy_type = 'employee_benefit' AND employee_id = ?;"
          },
          {
            "scenario": "Department is IT and employee_id is provided",
            "sql": "SELECT * FROM insurance_policies WHERE status = 1 AND policy_type = 'equipment_coverage' AND employee_id = ?;"
          },
          {
            "scenario": "Department is specified but employee_id is 0",
            "sql": "SELECT * FROM insurance_policies WHERE status = 1 AND policy_type = ?;"
          },
          {
            "scenario": "Current caller scenario (Department HR, employee_id 1001)",
            "sql": "SELECT * FROM insurance_policies WHERE status = 1 AND policy_type = 'employee_benefit' AND employee_id = 1001;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "RiskRepo",
        "code_value": "type RiskRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ExpressTableName",
        "code_value": "const ExpressTableName = \"risk_express_record\""
      },
      {
        "code_key": "Express",
        "code_value": "type Express struct {\n\tTransactionId string `gorm:\"column:transaction_id\" json:\"transaction_id\"`\n\tTimezone      string `gorm:\"column:timezone\" json:\"timezone\"`\n\tStatus        int    `gorm:\"column:status\" json:\"status\"`\n\tCreatedAt     int64  `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (e *Express) TableName() string {\n\treturn ExpressTableName\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "hints",
        "code_value": "import \"gorm.io/hints\""
      },
      {
        "code_key": "gorm",
        "code_value": "import \"gorm.io/gorm\""
      },
      {
        "code_key": "errors",
        "code_value": "import \"errors\""
      },
      {
        "code_key": "icontext",
        "code_value": "import \"git.woa.com/IVC/ivc-risk/pkg/icontext\""
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "SyncWithExternal",
    "orm_code": "func (repo *RiskRepo) SyncWithExternal(ctx context.Context, externalData *model.Express) error {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\texisting := &model.Express{}\n\n\tif err := repo.db.Clauses(selectClause).Table(model.ExpressTableName).\n\t\tWhere(\"transaction_id = ?\", externalData.TransactionId).\n\t\tFirst(existing).Error; err != nil {\n\t\tif !errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn err\n\t\t}\n\t\t// 不存在则创建\n\t\treturn repo.db.Table(model.ExpressTableName).Create(externalData).Error\n\t}\n\n\t// 存在则更新时区字段\n\tif existing.Timezone != externalData.Timezone {\n\t\treturn repo.db.Clauses(updateClause).Table(model.ExpressTableName).\n\t\t\tWhere(\"transaction_id = ?\", externalData.TransactionId).\n\t\t\tUpdate(\"timezone\", externalData.Timezone).Error\n\t}\n\n\treturn nil\n}",
    "caller": "func ProcessFinancePolicies(empID int) error {\n\taccountant := Employee{\n\t\tEmployeeId: empID,\n\t\tDepartment: \"Finance\",\n\t}\n\tif err := accountant.SyncWithExternal(); err != nil {\n\t\treturn fmt.Errorf(\"finance policy sync error: %w\", err)\n\t}\n\tfmt.Printf(\"Corporate policies updated for employee %d\\n\", empID)\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Finance department with employee ID",
            "sql": "SELECT * FROM insurance_policies WHERE status = 1 AND policy_type = 'corporate' AND employee_id = ?;"
          },
          {
            "scenario": "HR department with employee ID",
            "sql": "SELECT * FROM insurance_policies WHERE status = 1 AND policy_type = 'employee_benefit' AND employee_id = ?;"
          },
          {
            "scenario": "IT department with employee ID",
            "sql": "SELECT * FROM insurance_policies WHERE status = 1 AND policy_type = 'equipment_coverage' AND employee_id = ?;"
          },
          {
            "scenario": "Any department without employee ID",
            "sql": "SELECT * FROM insurance_policies WHERE status = 1 AND policy_type = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "RiskRepo",
        "code_value": "type RiskRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ExpressTableName",
        "code_value": "const ExpressTableName = \"risk_express_record\""
      },
      {
        "code_key": "Express",
        "code_value": "type Express struct {\n\tTransactionId string `gorm:\"column:transaction_id\" json:\"transaction_id\"`\n\tTimezone      string `gorm:\"column:timezone\" json:\"timezone\"`\n\tStatus        int    `gorm:\"column:status\" json:\"status\"`\n\tCreatedAt     int64  `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (e *Express) TableName() string {\n\treturn ExpressTableName\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "hints",
        "code_value": "import \"gorm.io/hints\""
      },
      {
        "code_key": "gorm",
        "code_value": "import \"gorm.io/gorm\""
      },
      {
        "code_key": "errors",
        "code_value": "import \"errors\""
      },
      {
        "code_key": "icontext",
        "code_value": "import \"git.woa.com/IVC/ivc-risk/pkg/icontext\""
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "SyncWithExternal",
    "orm_code": "func (repo *RiskRepo) SyncWithExternal(ctx context.Context, externalData *model.Express) error {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\texisting := &model.Express{}\n\n\tif err := repo.db.Clauses(selectClause).Table(model.ExpressTableName).\n\t\tWhere(\"transaction_id = ?\", externalData.TransactionId).\n\t\tFirst(existing).Error; err != nil {\n\t\tif !errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn err\n\t\t}\n\t\t// 不存在则创建\n\t\treturn repo.db.Table(model.ExpressTableName).Create(externalData).Error\n\t}\n\n\t// 存在则更新时区字段\n\tif existing.Timezone != externalData.Timezone {\n\t\treturn repo.db.Clauses(updateClause).Table(model.ExpressTableName).\n\t\t\tWhere(\"transaction_id = ?\", externalData.TransactionId).\n\t\t\tUpdate(\"timezone\", externalData.Timezone).Error\n\t}\n\n\treturn nil\n}",
    "caller": "func UpdateITEquipmentCoverage() {\n\tdevOps := Employee{Department: \"IT\"}\n\tif err := devOps.SyncWithExternal(); err != nil {\n\t\tlog.Fatalf(\"IT equipment sync failed: %v\", err)\n\t}\n\tfmt.Println(\"All IT equipment coverage policies updated\")\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "IT部门设备保险策略同步（EmployeeId未设置）",
            "sql": "SELECT * FROM insurance_policies WHERE status = 1 AND policy_type = 'equipment_coverage';"
          },
          {
            "scenario": "IT部门设备保险策略同步（EmployeeId被设置）",
            "sql": "SELECT * FROM insurance_policies WHERE status = 1 AND policy_type = 'equipment_coverage' AND employee_id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "RiskRepo",
        "code_value": "type RiskRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ExpressTableName",
        "code_value": "const ExpressTableName = \"risk_express_record\""
      },
      {
        "code_key": "Express",
        "code_value": "type Express struct {\n\tTransactionId string `gorm:\"column:transaction_id\" json:\"transaction_id\"`\n\tTimezone      string `gorm:\"column:timezone\" json:\"timezone\"`\n\tStatus        int    `gorm:\"column:status\" json:\"status\"`\n\tCreatedAt     int64  `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (e *Express) TableName() string {\n\treturn ExpressTableName\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "hints",
        "code_value": "import \"gorm.io/hints\""
      },
      {
        "code_key": "gorm",
        "code_value": "import \"gorm.io/gorm\""
      },
      {
        "code_key": "errors",
        "code_value": "import \"errors\""
      },
      {
        "code_key": "icontext",
        "code_value": "import \"git.woa.com/IVC/ivc-risk/pkg/icontext\""
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "SearchByKeyword",
    "orm_code": "func (repo *DiseaseRepo) SearchByKeyword(ctx context.Context, keyword string) ([]*model.Disease, error) {\n\tsearchClause := utils.SetSQLComment(ctx, utils.SearchKey)\n\tresult := make([]*model.Disease, 0)\n\n\tquery := repo.db.Clauses(searchClause).Table(model.DiseaseTableName)\n\tif keyword != \"\" {\n\t\tquery = query.Where(\n\t\t\t\"disease_name LIKE ? OR disease_code LIKE ?\", \n\t\t\t\"%\"+keyword+\"%\", \n\t\t\t\"%\"+keyword+\"%\")\n\t}\n\n\tif err := query.Find(&result).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn result, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "c.Rating > 0且c.SuspensionTime不为空",
            "sql": "SELECT id, security_level, suspension_time, status FROM tournament_brackets WHERE status = 1 AND security_level = ? AND suspension_time <= ?;"
          },
          {
            "scenario": "c.Rating > 0且c.SuspensionTime为空",
            "sql": "SELECT id, security_level, suspension_time, status FROM tournament_brackets WHERE status = 1 AND security_level = ?;"
          },
          {
            "scenario": "c.Rating <= 0且c.SuspensionTime不为空",
            "sql": "SELECT id, security_level, suspension_time, status FROM tournament_brackets WHERE status = 1 AND suspension_time <= ?;"
          },
          {
            "scenario": "c.Rating <= 0且c.SuspensionTime为空",
            "sql": "SELECT id, security_level, suspension_time, status FROM tournament_brackets WHERE status = 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "DiseaseRepo",
        "code_value": "type DiseaseRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Disease",
        "code_value": "type Disease struct {\n\tID          int64  `gorm:\"column:id\" json:\"id\"`\n\tDiseaseCode string `gorm:\"column:disease_code\" json:\"disease_code\"`\n\tDiseaseName string `gorm:\"column:disease_name\" json:\"disease_name\"`\n\tDescription string `gorm:\"column:description\" json:\"description\"`\n\tCreatedAt   int64  `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt   int64  `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "DiseaseTableName",
        "code_value": "const DiseaseTableName = \"medical_diseases\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (d *Disease) TableName() string {\n\treturn DiseaseTableName\n}"
      },
      {
        "code_key": "SearchKey",
        "code_value": "const SearchKey = \"SEARCH\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/medical/pkg/utils"
      },
      {
        "code_key": "icontext",
        "code_value": "git.woa.com/common/pkg/icontext"
      },
      {
        "code_key": "hints",
        "code_value": "gorm.io/hints"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "SearchByKeyword",
    "orm_code": "func (repo *DiseaseRepo) SearchByKeyword(ctx context.Context, keyword string) ([]*model.Disease, error) {\n\tsearchClause := utils.SetSQLComment(ctx, utils.SearchKey)\n\tresult := make([]*model.Disease, 0)\n\n\tquery := repo.db.Clauses(searchClause).Table(model.DiseaseTableName)\n\tif keyword != \"\" {\n\t\tquery = query.Where(\n\t\t\t\"disease_name LIKE ? OR disease_code LIKE ?\", \n\t\t\t\"%\"+keyword+\"%\", \n\t\t\t\"%\"+keyword+\"%\")\n\t}\n\n\tif err := query.Find(&result).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn result, nil\n}",
    "caller": "func HandleDiseaseSearch(ctx context.Context, searchTerm string, logger *zap.Logger) ([]*model.Disease, error) {\n\tdbEngine := conf.GetDBEngine()\n\tif dbEngine == nil {\n\t\treturn nil, fmt.Errorf(\"database engine not initialized\")\n\t}\n\n\tdiseaseRepo := &DiseaseRepo{db: dbEngine}\n\tmatchedDiseases, err := diseaseRepo.SearchByKeyword(ctx, searchTerm)\n\tif err != nil {\n\t\tlogger.Error(\"Disease search failed\", zap.Error(err))\n\t\treturn nil, fmt.Errorf(\"search failed: %v\", err)\n\t}\n\n\tif len(matchedDiseases) == 0 {\n\t\tlogger.Info(\"No diseases found matching criteria\", zap.String(\"term\", searchTerm))\n\t}\n\n\treturn matchedDiseases, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "keyword为空字符串",
            "sql": "SELECT id, disease_code, disease_name, description, created_at, updated_at FROM medical_diseases;"
          },
          {
            "scenario": "keyword非空",
            "sql": "SELECT id, disease_code, disease_name, description, created_at, updated_at FROM medical_diseases WHERE (disease_name LIKE ? OR disease_code LIKE ?);"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "DiseaseRepo",
        "code_value": "type DiseaseRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Disease",
        "code_value": "type Disease struct {\n\tID          int64  `gorm:\"column:id\" json:\"id\"`\n\tDiseaseCode string `gorm:\"column:disease_code\" json:\"disease_code\"`\n\tDiseaseName string `gorm:\"column:disease_name\" json:\"disease_name\"`\n\tDescription string `gorm:\"column:description\" json:\"description\"`\n\tCreatedAt   int64  `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt   int64  `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "DiseaseTableName",
        "code_value": "const DiseaseTableName = \"medical_diseases\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (d *Disease) TableName() string {\n\treturn DiseaseTableName\n}"
      },
      {
        "code_key": "SearchKey",
        "code_value": "const SearchKey = \"SEARCH\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/medical/pkg/utils"
      },
      {
        "code_key": "icontext",
        "code_value": "git.woa.com/common/pkg/icontext"
      },
      {
        "code_key": "hints",
        "code_value": "gorm.io/hints"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "SearchByKeyword",
    "orm_code": "func (repo *DiseaseRepo) SearchByKeyword(ctx context.Context, keyword string) ([]*model.Disease, error) {\n\tsearchClause := utils.SetSQLComment(ctx, utils.SearchKey)\n\tresult := make([]*model.Disease, 0)\n\n\tquery := repo.db.Clauses(searchClause).Table(model.DiseaseTableName)\n\tif keyword != \"\" {\n\t\tquery = query.Where(\n\t\t\t\"disease_name LIKE ? OR disease_code LIKE ?\", \n\t\t\t\"%\"+keyword+\"%\", \n\t\t\t\"%\"+keyword+\"%\")\n\t}\n\n\tif err := query.Find(&result).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn result, nil\n}",
    "caller": "func HandleTestRetrieval(ratingLevel int, suspensionWindow string) ([]Test, error) {\n\tcourseObj := &Course{\n\t\tRating:        ratingLevel,\n\t\tSuspensionTime: suspensionWindow,\n\t}\n\tresultSet, err := courseObj.SearchByKeyword()\n\tif err != nil {\n\t\tlog.Printf(\"Failed retrieving tests: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn resultSet, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "ratingLevel为0，suspensionWindow为空字符串",
            "sql": "SELECT * FROM tournament_brackets WHERE status = 1;"
          },
          {
            "scenario": "ratingLevel为1，suspensionWindow为空字符串",
            "sql": "SELECT * FROM tournament_brackets WHERE status = 1 AND security_level = 'low';"
          },
          {
            "scenario": "ratingLevel为2，suspensionWindow为空字符串",
            "sql": "SELECT * FROM tournament_brackets WHERE status = 1 AND security_level = 'medium';"
          },
          {
            "scenario": "ratingLevel为3，suspensionWindow为空字符串",
            "sql": "SELECT * FROM tournament_brackets WHERE status = 1 AND security_level = 'high';"
          },
          {
            "scenario": "ratingLevel为0，suspensionWindow非空",
            "sql": "SELECT * FROM tournament_brackets WHERE status = 1 AND suspension_time <= ?;"
          },
          {
            "scenario": "ratingLevel为1，suspensionWindow非空",
            "sql": "SELECT * FROM tournament_brackets WHERE status = 1 AND security_level = 'low' AND suspension_time <= ?;"
          },
          {
            "scenario": "ratingLevel为2，suspensionWindow非空",
            "sql": "SELECT * FROM tournament_brackets WHERE status = 1 AND security_level = 'medium' AND suspension_time <= ?;"
          },
          {
            "scenario": "ratingLevel为3，suspensionWindow非空",
            "sql": "SELECT * FROM tournament_brackets WHERE status = 1 AND security_level = 'high' AND suspension_time <= ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "DiseaseRepo",
        "code_value": "type DiseaseRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Disease",
        "code_value": "type Disease struct {\n\tID          int64  `gorm:\"column:id\" json:\"id\"`\n\tDiseaseCode string `gorm:\"column:disease_code\" json:\"disease_code\"`\n\tDiseaseName string `gorm:\"column:disease_name\" json:\"disease_name\"`\n\tDescription string `gorm:\"column:description\" json:\"description\"`\n\tCreatedAt   int64  `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt   int64  `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "DiseaseTableName",
        "code_value": "const DiseaseTableName = \"medical_diseases\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (d *Disease) TableName() string {\n\treturn DiseaseTableName\n}"
      },
      {
        "code_key": "SearchKey",
        "code_value": "const SearchKey = \"SEARCH\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/medical/pkg/utils"
      },
      {
        "code_key": "icontext",
        "code_value": "git.woa.com/common/pkg/icontext"
      },
      {
        "code_key": "hints",
        "code_value": "gorm.io/hints"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "SearchByKeyword",
    "orm_code": "func (repo *DiseaseRepo) SearchByKeyword(ctx context.Context, keyword string) ([]*model.Disease, error) {\n\tsearchClause := utils.SetSQLComment(ctx, utils.SearchKey)\n\tresult := make([]*model.Disease, 0)\n\n\tquery := repo.db.Clauses(searchClause).Table(model.DiseaseTableName)\n\tif keyword != \"\" {\n\t\tquery = query.Where(\n\t\t\t\"disease_name LIKE ? OR disease_code LIKE ?\", \n\t\t\t\"%\"+keyword+\"%\", \n\t\t\t\"%\"+keyword+\"%\")\n\t}\n\n\tif err := query.Find(&result).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn result, nil\n}",
    "caller": "func ProcessSecurityAudit() error {\n\tauditCourse := &Course{\n\t\tRating:         3,\n\t\tSuspensionTime: \"2023-12-31 23:59:59\",\n\t}\n\tauditRecords, auditErr := auditCourse.SearchByKeyword()\n\tif auditErr != nil {\n\t\treturn fmt.Errorf(\"security audit failed: %w\", auditErr)\n\t}\n\tlog.Printf(\"Found %d high security tests\", len(auditRecords))\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Rating=3 and SuspensionTime provided",
            "sql": "SELECT * FROM tournament_brackets WHERE status = 1 AND security_level = 'high' AND suspension_time <= '2023-12-31 23:59:59';"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "DiseaseRepo",
        "code_value": "type DiseaseRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Disease",
        "code_value": "type Disease struct {\n\tID          int64  `gorm:\"column:id\" json:\"id\"`\n\tDiseaseCode string `gorm:\"column:disease_code\" json:\"disease_code\"`\n\tDiseaseName string `gorm:\"column:disease_name\" json:\"disease_name\"`\n\tDescription string `gorm:\"column:description\" json:\"description\"`\n\tCreatedAt   int64  `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt   int64  `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "DiseaseTableName",
        "code_value": "const DiseaseTableName = \"medical_diseases\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (d *Disease) TableName() string {\n\treturn DiseaseTableName\n}"
      },
      {
        "code_key": "SearchKey",
        "code_value": "const SearchKey = \"SEARCH\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/medical/pkg/utils"
      },
      {
        "code_key": "icontext",
        "code_value": "git.woa.com/common/pkg/icontext"
      },
      {
        "code_key": "hints",
        "code_value": "gorm.io/hints"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "UpdateQuestStatus",
    "orm_code": "func (repo *QuestRepo) UpdateQuestStatus(ctx context.Context, quest *model.Quest) error {\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\tcurrentQuest := &model.Quest{}\n\n\tif err := repo.db.Table(model.QuestTableName).\n\t\tWhere(\"unique_key = ?\", quest.UniqueKey).\n\t\tFirst(currentQuest).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif currentQuest.SuspensionTime != quest.SuspensionTime {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.QuestTableName).\n\t\t\tWhere(\"id = ?\", currentQuest.Id).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"suspension_time\": quest.SuspensionTime,\n\t\t\t\t\"nick_name\":      quest.NickName,\n\t\t\t}).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "",
    "sql_statement_list": [
      "{\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\n        \"scenario\": \"suspension_time未改变，仅执行查询\",\n        \"sql\": \"SELECT id, unique_key, suspension_time, nick_name FROM user_quests WHERE unique_key = ? LIMIT 1;\"\n      },\n      {\n        \"scenario\": \"suspension_time改变，先查询后更新\",\n        \"sql\": [\n          \"SELECT id, unique_key, suspension_time, nick_name FROM user_quests WHERE unique_key = ? LIMIT 1;\",\n          \"UPDATE user_quests SET suspension_time = ?, nick_name = ? WHERE id = ?;\"\n        ]\n      }",
      "SELECT id, unique_key, suspension_time, nick_name FROM user_quests WHERE unique_key = ? LIMIT 1;",
      "SELECT id, unique_key, suspension_time, nick_name FROM user_quests WHERE unique_key = ? LIMIT 1;",
      "UPDATE user_quests SET suspension_time = ?, nick_name = ? WHERE id = ?;"
    ],
    "sql_types": [
      "OTHER",
      "SELECT",
      "SELECT",
      "UPDATE"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "QuestRepo",
        "code_value": "type QuestRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Quest",
        "code_value": "type Quest struct {\n\tId            int64  `gorm:\"column:id\" json:\"id\"`\n\tUniqueKey     string `gorm:\"column:unique_key\" json:\"unique_key\"`\n\tSuspensionTime int64  `gorm:\"column:suspension_time\" json:\"suspension_time\"`\n\tNickName      string `gorm:\"column:nick_name\" json:\"nick_name\"`\n}"
      },
      {
        "code_key": "QuestTableName",
        "code_value": "const QuestTableName = \"user_quests\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "hints",
        "code_value": "import \"gorm.io/hints\""
      },
      {
        "code_key": "icontext",
        "code_value": "import \"git.woa.com/common/icontext\""
      },
      {
        "code_key": "uuid",
        "code_value": "import \"github.com/google/uuid\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (q *Quest) TableName() string {\n\treturn QuestTableName\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "UpdateQuestStatus",
    "orm_code": "func (repo *QuestRepo) UpdateQuestStatus(ctx context.Context, quest *model.Quest) error {\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\tcurrentQuest := &model.Quest{}\n\n\tif err := repo.db.Table(model.QuestTableName).\n\t\tWhere(\"unique_key = ?\", quest.UniqueKey).\n\t\tFirst(currentQuest).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif currentQuest.SuspensionTime != quest.SuspensionTime {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.QuestTableName).\n\t\t\tWhere(\"id = ?\", currentQuest.Id).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"suspension_time\": quest.SuspensionTime,\n\t\t\t\t\"nick_name\":      quest.NickName,\n\t\t\t}).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func HandleQuestSuspension(ctx context.Context, questID string, suspendUntil time.Time, logger *zap.Logger) error {\n\trepo, err := data.NewQuestRepo()\n\tif err != nil {\n\t\tlogger.Error(\"failed to create quest repo\", zap.Error(err))\n\t\treturn err\n\t}\n\n\ttargetQuest := &model.Quest{\n\t\tUniqueKey:      questID,\n\t\tSuspensionTime: suspendUntil,\n\t\tNickName:       \"system_admin\",\n\t}\n\n\tif err := repo.UpdateQuestStatus(ctx, targetQuest); err != nil {\n\t\tlogger.Error(\"failed to update quest status\", \n\t\t\tzap.String(\"questID\", questID),\n\t\t\tzap.Error(err))\n\t\treturn err\n\t}\n\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "查询当前任务状态",
            "sql": "SELECT id, unique_key, suspension_time, nick_name FROM user_quests WHERE unique_key = 'quest123' LIMIT 1;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "更新任务状态（当suspension_time不同时）",
            "sql": "UPDATE user_quests SET suspension_time = 1698765432, nick_name = 'system_admin' WHERE id = 12345;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "QuestRepo",
        "code_value": "type QuestRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Quest",
        "code_value": "type Quest struct {\n\tId            int64  `gorm:\"column:id\" json:\"id\"`\n\tUniqueKey     string `gorm:\"column:unique_key\" json:\"unique_key\"`\n\tSuspensionTime int64  `gorm:\"column:suspension_time\" json:\"suspension_time\"`\n\tNickName      string `gorm:\"column:nick_name\" json:\"nick_name\"`\n}"
      },
      {
        "code_key": "QuestTableName",
        "code_value": "const QuestTableName = \"user_quests\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "hints",
        "code_value": "import \"gorm.io/hints\""
      },
      {
        "code_key": "icontext",
        "code_value": "import \"git.woa.com/common/icontext\""
      },
      {
        "code_key": "uuid",
        "code_value": "import \"github.com/google/uuid\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (q *Quest) TableName() string {\n\treturn QuestTableName\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "CalculateDiscount",
    "orm_code": "func (repo *VendorRepo) CalculateDiscount(ctx context.Context, contract *model.VendorContract) (float64, error) {\n\tbaseClause := utils.SetSQLComment(ctx, utils.BaseKey)\n\tvar existingContract model.VendorContract\n\n\terr := repo.db.Clauses(baseClause).Table(model.VendorContractsTableName).\n\t\tWhere(\"vendor_id = ? AND product_type = ?\", contract.VendorId, contract.ProductType).\n\t\tFirst(&existingContract).Error\n\n\tif err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn 0.0, nil\n\t\t}\n\t\treturn 0.0, err\n\t}\n\n\tdiscount := existingContract.BaseRate * (1 - existingContract.NegotiatedRate)\n\treturn discount, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "AuthLevel=1, NetValue=500, ID=100",
            "sql": "UPDATE user_profiles SET discount = 0.1 WHERE nurse_id = 100;"
          },
          {
            "scenario": "AuthLevel=2, NetValue=1200, ID=101",
            "sql": "UPDATE user_profiles SET discount = 0.25 WHERE nurse_id = 101;"
          },
          {
            "scenario": "AuthLevel=3, NetValue=800, ID=102",
            "sql": "UPDATE user_profiles SET discount = 0.3 WHERE nurse_id = 102;"
          },
          {
            "scenario": "AuthLevel=3, NetValue=1500, ID=103",
            "sql": "UPDATE user_profiles SET discount = 0.35 WHERE nurse_id = 103;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "DiscountCalculatorRepo",
        "code_value": "type DiscountCalculatorRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ProductDiscountTableName",
        "code_value": "const ProductDiscountTableName = \"product_discounts\""
      },
      {
        "code_key": "ProductDiscount",
        "code_value": "type ProductDiscount struct {\n\tID             int64   `gorm:\"column:id\"`\n\tMerchantId     string  `gorm:\"column:merchant_id\"`\n\tCategoryId     int     `gorm:\"column:category_id\"`\n\tStandardPrice  float64 `gorm:\"column:standard_price\"`\n\tDiscountRate   float64 `gorm:\"column:discount_rate\"`\n\tEffectiveDate  int64   `gorm:\"column:effective_date\"`\n\tExpirationDate int64   `gorm:\"column:expiration_date\"`\n}"
      },
      {
        "code_key": "DiscountPolicy",
        "code_value": "type DiscountPolicy struct {\n\tMinAmount    float64\n\tMaxAmount    float64\n\tTieredRates  map[float64]float64\n\tSpecialRules []SpecialRule\n}"
      },
      {
        "code_key": "SpecialRule",
        "code_value": "type SpecialRule struct {\n\tCondition  string\n\tAdjustment float64\n}"
      },
      {
        "code_key": "GlobalDiscountSettings",
        "code_value": "var GlobalDiscountSettings = struct {\n\tDefaultRate    float64\n\tMaxDiscount    float64\n\tBlacklist      []string\n\tWhitelist      []string\n\tActiveCampaign bool\n}{\n\tDefaultRate:    0.1,\n\tMaxDiscount:    0.5,\n\tActiveCampaign: true,\n}"
      },
      {
        "code_key": "PriceTier",
        "code_value": "const (\n\tTierBasic    = 1\n\tTierStandard = 2\n\tTierPremium  = 3\n)"
      },
      {
        "code_key": "DiscountCache",
        "code_value": "var DiscountCache = sync.Map{}"
      },
      {
        "code_key": "CategoryDiscount",
        "code_value": "type CategoryDiscount struct {\n\tCategoryId      int\n\tBaseMultiplier  float64\n\tSeasonalAdjust  float64\n\tInventoryFactor float64\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CalculateDiscount",
    "orm_code": "func (repo *VendorRepo) CalculateDiscount(ctx context.Context, contract *model.VendorContract) (float64, error) {\n\tbaseClause := utils.SetSQLComment(ctx, utils.BaseKey)\n\tvar existingContract model.VendorContract\n\n\terr := repo.db.Clauses(baseClause).Table(model.VendorContractsTableName).\n\t\tWhere(\"vendor_id = ? AND product_type = ?\", contract.VendorId, contract.ProductType).\n\t\tFirst(&existingContract).Error\n\n\tif err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn 0.0, nil\n\t\t}\n\t\treturn 0.0, err\n\t}\n\n\tdiscount := existingContract.BaseRate * (1 - existingContract.NegotiatedRate)\n\treturn discount, nil\n}",
    "caller": "func ProcessVendorDiscount(ctx context.Context, db *gorm.DB, vendorID string, productType int) (float64, error) {\n\trepo := &VendorRepo{db: db}\n\tcontract := &model.VendorContract{\n\t\tVendorId:    vendorID,\n\t\tProductType: productType,\n\t}\n\n\tdiscount, err := repo.CalculateDiscount(ctx, contract)\n\tif err != nil {\n\t\treturn 0.0, fmt.Errorf(\"failed to calculate discount: %v\", err)\n\t}\n\t\n\tif discount > 0 {\n\t\tlog.Printf(\"Discount calculated: %.2f for vendor %s\", discount, vendorID)\n\t}\n\treturn discount, nil\n}",
    "sql_statement_list": [
      {
        "type": "LACK_INFORMATION",
        "variants": [
          {
            "scenario": "缺少model.VendorContractsTableName定义，推测表名为vendor_contracts",
            "sql": "SELECT * FROM vendor_contracts WHERE vendor_id = ? AND product_type = ? LIMIT 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "DiscountCalculatorRepo",
        "code_value": "type DiscountCalculatorRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ProductDiscountTableName",
        "code_value": "const ProductDiscountTableName = \"product_discounts\""
      },
      {
        "code_key": "ProductDiscount",
        "code_value": "type ProductDiscount struct {\n\tID             int64   `gorm:\"column:id\"`\n\tMerchantId     string  `gorm:\"column:merchant_id\"`\n\tCategoryId     int     `gorm:\"column:category_id\"`\n\tStandardPrice  float64 `gorm:\"column:standard_price\"`\n\tDiscountRate   float64 `gorm:\"column:discount_rate\"`\n\tEffectiveDate  int64   `gorm:\"column:effective_date\"`\n\tExpirationDate int64   `gorm:\"column:expiration_date\"`\n}"
      },
      {
        "code_key": "DiscountPolicy",
        "code_value": "type DiscountPolicy struct {\n\tMinAmount    float64\n\tMaxAmount    float64\n\tTieredRates  map[float64]float64\n\tSpecialRules []SpecialRule\n}"
      },
      {
        "code_key": "SpecialRule",
        "code_value": "type SpecialRule struct {\n\tCondition  string\n\tAdjustment float64\n}"
      },
      {
        "code_key": "GlobalDiscountSettings",
        "code_value": "var GlobalDiscountSettings = struct {\n\tDefaultRate    float64\n\tMaxDiscount    float64\n\tBlacklist      []string\n\tWhitelist      []string\n\tActiveCampaign bool\n}{\n\tDefaultRate:    0.1,\n\tMaxDiscount:    0.5,\n\tActiveCampaign: true,\n}"
      },
      {
        "code_key": "PriceTier",
        "code_value": "const (\n\tTierBasic    = 1\n\tTierStandard = 2\n\tTierPremium  = 3\n)"
      },
      {
        "code_key": "DiscountCache",
        "code_value": "var DiscountCache = sync.Map{}"
      },
      {
        "code_key": "CategoryDiscount",
        "code_value": "type CategoryDiscount struct {\n\tCategoryId      int\n\tBaseMultiplier  float64\n\tSeasonalAdjust  float64\n\tInventoryFactor float64\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CalculateDiscount",
    "orm_code": "func (repo *VendorRepo) CalculateDiscount(ctx context.Context, contract *model.VendorContract) (float64, error) {\n\tbaseClause := utils.SetSQLComment(ctx, utils.BaseKey)\n\tvar existingContract model.VendorContract\n\n\terr := repo.db.Clauses(baseClause).Table(model.VendorContractsTableName).\n\t\tWhere(\"vendor_id = ? AND product_type = ?\", contract.VendorId, contract.ProductType).\n\t\tFirst(&existingContract).Error\n\n\tif err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn 0.0, nil\n\t\t}\n\t\treturn 0.0, err\n\t}\n\n\tdiscount := existingContract.BaseRate * (1 - existingContract.NegotiatedRate)\n\treturn discount, nil\n}",
    "caller": "func HandlePrescriptionDiscount() error {\n\tnurse := &Nurse{\n\t\tID:        123,\n\t\tAuthLevel: 2,\n\t\tNetValue:  1500,\n\t}\n\n\tdiscount, err := nurse.CalculateDiscount()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to calculate discount: %v\", err)\n\t}\n\n\tlog.Printf(\"Applied discount: %.2f\", discount)\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "AuthLevel=2 and NetValue>1000",
            "sql": "UPDATE user_profiles SET discount = 0.25 WHERE nurse_id = 123;"
          },
          {
            "scenario": "AuthLevel=1 and NetValue<=1000",
            "sql": "UPDATE user_profiles SET discount = 0.1 WHERE nurse_id = ?;"
          },
          {
            "scenario": "AuthLevel=2 and NetValue<=1000",
            "sql": "UPDATE user_profiles SET discount = 0.2 WHERE nurse_id = ?;"
          },
          {
            "scenario": "AuthLevel=3 and NetValue>1000",
            "sql": "UPDATE user_profiles SET discount = 0.35 WHERE nurse_id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "DiscountCalculatorRepo",
        "code_value": "type DiscountCalculatorRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ProductDiscountTableName",
        "code_value": "const ProductDiscountTableName = \"product_discounts\""
      },
      {
        "code_key": "ProductDiscount",
        "code_value": "type ProductDiscount struct {\n\tID             int64   `gorm:\"column:id\"`\n\tMerchantId     string  `gorm:\"column:merchant_id\"`\n\tCategoryId     int     `gorm:\"column:category_id\"`\n\tStandardPrice  float64 `gorm:\"column:standard_price\"`\n\tDiscountRate   float64 `gorm:\"column:discount_rate\"`\n\tEffectiveDate  int64   `gorm:\"column:effective_date\"`\n\tExpirationDate int64   `gorm:\"column:expiration_date\"`\n}"
      },
      {
        "code_key": "DiscountPolicy",
        "code_value": "type DiscountPolicy struct {\n\tMinAmount    float64\n\tMaxAmount    float64\n\tTieredRates  map[float64]float64\n\tSpecialRules []SpecialRule\n}"
      },
      {
        "code_key": "SpecialRule",
        "code_value": "type SpecialRule struct {\n\tCondition  string\n\tAdjustment float64\n}"
      },
      {
        "code_key": "GlobalDiscountSettings",
        "code_value": "var GlobalDiscountSettings = struct {\n\tDefaultRate    float64\n\tMaxDiscount    float64\n\tBlacklist      []string\n\tWhitelist      []string\n\tActiveCampaign bool\n}{\n\tDefaultRate:    0.1,\n\tMaxDiscount:    0.5,\n\tActiveCampaign: true,\n}"
      },
      {
        "code_key": "PriceTier",
        "code_value": "const (\n\tTierBasic    = 1\n\tTierStandard = 2\n\tTierPremium  = 3\n)"
      },
      {
        "code_key": "DiscountCache",
        "code_value": "var DiscountCache = sync.Map{}"
      },
      {
        "code_key": "CategoryDiscount",
        "code_value": "type CategoryDiscount struct {\n\tCategoryId      int\n\tBaseMultiplier  float64\n\tSeasonalAdjust  float64\n\tInventoryFactor float64\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CalculateDiscount",
    "orm_code": "func (repo *VendorRepo) CalculateDiscount(ctx context.Context, contract *model.VendorContract) (float64, error) {\n\tbaseClause := utils.SetSQLComment(ctx, utils.BaseKey)\n\tvar existingContract model.VendorContract\n\n\terr := repo.db.Clauses(baseClause).Table(model.VendorContractsTableName).\n\t\tWhere(\"vendor_id = ? AND product_type = ?\", contract.VendorId, contract.ProductType).\n\t\tFirst(&existingContract).Error\n\n\tif err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn 0.0, nil\n\t\t}\n\t\treturn 0.0, err\n\t}\n\n\tdiscount := existingContract.BaseRate * (1 - existingContract.NegotiatedRate)\n\treturn discount, nil\n}",
    "caller": "func ProcessNurseDiscount(nurseID uint, authLevel int, netValue float64) (float64, error) {\n\tnurse := &Nurse{\n\t\tID:        nurseID,\n\t\tAuthLevel: authLevel,\n\t\tNetValue:  netValue,\n\t}\n\n\tdiscount, err := nurse.CalculateDiscount()\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"discount calculation failed: %v\", err)\n\t}\n\n\treturn discount, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Update discount for nurse based on auth level and net value",
            "sql": "UPDATE user_profiles SET discount = ? WHERE nurse_id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "DiscountCalculatorRepo",
        "code_value": "type DiscountCalculatorRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ProductDiscountTableName",
        "code_value": "const ProductDiscountTableName = \"product_discounts\""
      },
      {
        "code_key": "ProductDiscount",
        "code_value": "type ProductDiscount struct {\n\tID             int64   `gorm:\"column:id\"`\n\tMerchantId     string  `gorm:\"column:merchant_id\"`\n\tCategoryId     int     `gorm:\"column:category_id\"`\n\tStandardPrice  float64 `gorm:\"column:standard_price\"`\n\tDiscountRate   float64 `gorm:\"column:discount_rate\"`\n\tEffectiveDate  int64   `gorm:\"column:effective_date\"`\n\tExpirationDate int64   `gorm:\"column:expiration_date\"`\n}"
      },
      {
        "code_key": "DiscountPolicy",
        "code_value": "type DiscountPolicy struct {\n\tMinAmount    float64\n\tMaxAmount    float64\n\tTieredRates  map[float64]float64\n\tSpecialRules []SpecialRule\n}"
      },
      {
        "code_key": "SpecialRule",
        "code_value": "type SpecialRule struct {\n\tCondition  string\n\tAdjustment float64\n}"
      },
      {
        "code_key": "GlobalDiscountSettings",
        "code_value": "var GlobalDiscountSettings = struct {\n\tDefaultRate    float64\n\tMaxDiscount    float64\n\tBlacklist      []string\n\tWhitelist      []string\n\tActiveCampaign bool\n}{\n\tDefaultRate:    0.1,\n\tMaxDiscount:    0.5,\n\tActiveCampaign: true,\n}"
      },
      {
        "code_key": "PriceTier",
        "code_value": "const (\n\tTierBasic    = 1\n\tTierStandard = 2\n\tTierPremium  = 3\n)"
      },
      {
        "code_key": "DiscountCache",
        "code_value": "var DiscountCache = sync.Map{}"
      },
      {
        "code_key": "CategoryDiscount",
        "code_value": "type CategoryDiscount struct {\n\tCategoryId      int\n\tBaseMultiplier  float64\n\tSeasonalAdjust  float64\n\tInventoryFactor float64\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CompareData",
    "orm_code": "func (repo *AssetRepo) CompareData(ctx context.Context, scanner *model.Scanner) (bool, error) {\n\tdbClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tstoredAsset := &model.Asset{}\n\n\tif err := repo.db.Clauses(dbClause).Table(model.AssetTableName).\n\t\tWhere(\"scanner_id = ?\", scanner.ID).\n\t\tFirst(&storedAsset).Error; err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif storedAsset.Percentage != scanner.Percentage || \n\t   storedAsset.CurrentStatus != scanner.CurrentStatus {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "EntityId = 1 (Premium类型)",
            "sql": "SELECT id, name, category_type, price, status, created_at FROM product_categories WHERE status = 1 AND category_type = 'premium' AND created_at >= ? ORDER BY price DESC;"
          },
          {
            "scenario": "EntityId = 2 (Standard类型)",
            "sql": "SELECT id, name, category_type, price, status, created_at FROM product_categories WHERE status = 1 AND category_type = 'standard' AND created_at >= ? ORDER BY price DESC;"
          },
          {
            "scenario": "EntityId = 3 (Basic类型)",
            "sql": "SELECT id, name, category_type, price, status, created_at FROM product_categories WHERE status = 1 AND category_type = 'basic' AND created_at >= ? ORDER BY price DESC;"
          },
          {
            "scenario": "EntityId = 0 (无category_type条件)",
            "sql": "SELECT id, name, category_type, price, status, created_at FROM product_categories WHERE status = 1 AND created_at >= ? ORDER BY price DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Scanner",
        "code_value": "type Scanner struct {\n\tID            string  `gorm:\"column:scanner_id\" json:\"scanner_id\"`\n\tPercentage    float64 `gorm:\"column:percentage\" json:\"percentage\"`\n\tCurrentStatus int     `gorm:\"column:current_status\" json:\"current_status\"`\n}"
      },
      {
        "code_key": "ReportContentTableName",
        "code_value": "const ReportContentTableName = \"scan_reports\""
      },
      {
        "code_key": "ContentReport",
        "code_value": "type ContentReport struct {\n\tID            int64   `gorm:\"column:id\" json:\"id\"`\n\tScannerID     string  `gorm:\"column:scanner_id\" json:\"scanner_id\"`\n\tPercentage    float64 `gorm:\"column:percentage\" json:\"percentage\"`\n\tCurrentStatus int     `gorm:\"column:current_status\" json:\"current_status\"`\n\tCreatedAt     int64   `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt     int64   `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "ScanResult",
        "code_value": "type ScanResult struct {\n\tIsMatch      bool   `json:\"is_match\"`\n\tErrorMessage string `json:\"error_message,omitempty\"`\n}"
      },
      {
        "code_key": "ReportRepo",
        "code_value": "type ReportRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ScanThreshold",
        "code_value": "const ScanThreshold = 0.95"
      },
      {
        "code_key": "StatusCompleted",
        "code_value": "const StatusCompleted = 1"
      },
      {
        "code_key": "StatusPending",
        "code_value": "const StatusPending = 0"
      },
      {
        "code_key": "TableName",
        "code_value": "func (cr *ContentReport) TableName() string {\n\treturn ReportContentTableName\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CompareData",
    "orm_code": "func (repo *AssetRepo) CompareData(ctx context.Context, scanner *model.Scanner) (bool, error) {\n\tdbClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tstoredAsset := &model.Asset{}\n\n\tif err := repo.db.Clauses(dbClause).Table(model.AssetTableName).\n\t\tWhere(\"scanner_id = ?\", scanner.ID).\n\t\tFirst(&storedAsset).Error; err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif storedAsset.Percentage != scanner.Percentage || \n\t   storedAsset.CurrentStatus != scanner.CurrentStatus {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "caller": "func HandleScanValidation(ctx context.Context, scanTool *model.Scanner, dbConn *gorm.DB) (bool, error) {\n\trepo := &AssetRepo{db: dbConn}\n\tisIdentical, err := repo.CompareData(ctx, scanTool)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"scan validation failed: %w\", err)\n\t}\n\tif !isIdentical {\n\t\treturn false, nil\n\t}\n\treturn true, nil\n}",
    "sql_statement_list": [
      {
        "type": "LACK_INFORMATION",
        "variants": [
          {
            "scenario": "缺少model.AssetTableName常量的定义，无法确定确切的表名",
            "sql": "SELECT * FROM asset WHERE scanner_id = ? LIMIT 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Scanner",
        "code_value": "type Scanner struct {\n\tID            string  `gorm:\"column:scanner_id\" json:\"scanner_id\"`\n\tPercentage    float64 `gorm:\"column:percentage\" json:\"percentage\"`\n\tCurrentStatus int     `gorm:\"column:current_status\" json:\"current_status\"`\n}"
      },
      {
        "code_key": "ReportContentTableName",
        "code_value": "const ReportContentTableName = \"scan_reports\""
      },
      {
        "code_key": "ContentReport",
        "code_value": "type ContentReport struct {\n\tID            int64   `gorm:\"column:id\" json:\"id\"`\n\tScannerID     string  `gorm:\"column:scanner_id\" json:\"scanner_id\"`\n\tPercentage    float64 `gorm:\"column:percentage\" json:\"percentage\"`\n\tCurrentStatus int     `gorm:\"column:current_status\" json:\"current_status\"`\n\tCreatedAt     int64   `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt     int64   `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "ScanResult",
        "code_value": "type ScanResult struct {\n\tIsMatch      bool   `json:\"is_match\"`\n\tErrorMessage string `json:\"error_message,omitempty\"`\n}"
      },
      {
        "code_key": "ReportRepo",
        "code_value": "type ReportRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ScanThreshold",
        "code_value": "const ScanThreshold = 0.95"
      },
      {
        "code_key": "StatusCompleted",
        "code_value": "const StatusCompleted = 1"
      },
      {
        "code_key": "StatusPending",
        "code_value": "const StatusPending = 0"
      },
      {
        "code_key": "TableName",
        "code_value": "func (cr *ContentReport) TableName() string {\n\treturn ReportContentTableName\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CompareData",
    "orm_code": "func (repo *AssetRepo) CompareData(ctx context.Context, scanner *model.Scanner) (bool, error) {\n\tdbClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tstoredAsset := &model.Asset{}\n\n\tif err := repo.db.Clauses(dbClause).Table(model.AssetTableName).\n\t\tWhere(\"scanner_id = ?\", scanner.ID).\n\t\tFirst(&storedAsset).Error; err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif storedAsset.Percentage != scanner.Percentage || \n\t   storedAsset.CurrentStatus != scanner.CurrentStatus {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "caller": "func ProcessContentReport(ctx context.Context, contentScanner *model.Scanner, storage *gorm.DB) error {\n\tassetRep := AssetRepo{db: storage}\n\tmatched, compareErr := assetRep.CompareData(ctx, contentScanner)\n\tif compareErr != nil {\n\t\treturn compareErr\n\t}\n\tif !matched {\n\t\treturn fmt.Errorf(\"content report data mismatch\")\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "LACK_INFORMATION",
        "variants": [
          {
            "scenario": "缺少model.AssetTableName具体值和model.Asset结构体定义",
            "sql": "SELECT * FROM assets WHERE scanner_id = ? LIMIT 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Scanner",
        "code_value": "type Scanner struct {\n\tID            string  `gorm:\"column:scanner_id\" json:\"scanner_id\"`\n\tPercentage    float64 `gorm:\"column:percentage\" json:\"percentage\"`\n\tCurrentStatus int     `gorm:\"column:current_status\" json:\"current_status\"`\n}"
      },
      {
        "code_key": "ReportContentTableName",
        "code_value": "const ReportContentTableName = \"scan_reports\""
      },
      {
        "code_key": "ContentReport",
        "code_value": "type ContentReport struct {\n\tID            int64   `gorm:\"column:id\" json:\"id\"`\n\tScannerID     string  `gorm:\"column:scanner_id\" json:\"scanner_id\"`\n\tPercentage    float64 `gorm:\"column:percentage\" json:\"percentage\"`\n\tCurrentStatus int     `gorm:\"column:current_status\" json:\"current_status\"`\n\tCreatedAt     int64   `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt     int64   `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "ScanResult",
        "code_value": "type ScanResult struct {\n\tIsMatch      bool   `json:\"is_match\"`\n\tErrorMessage string `json:\"error_message,omitempty\"`\n}"
      },
      {
        "code_key": "ReportRepo",
        "code_value": "type ReportRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ScanThreshold",
        "code_value": "const ScanThreshold = 0.95"
      },
      {
        "code_key": "StatusCompleted",
        "code_value": "const StatusCompleted = 1"
      },
      {
        "code_key": "StatusPending",
        "code_value": "const StatusPending = 0"
      },
      {
        "code_key": "TableName",
        "code_value": "func (cr *ContentReport) TableName() string {\n\treturn ReportContentTableName\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CompareData",
    "orm_code": "func (repo *AssetRepo) CompareData(ctx context.Context, scanner *model.Scanner) (bool, error) {\n\tdbClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tstoredAsset := &model.Asset{}\n\n\tif err := repo.db.Clauses(dbClause).Table(model.AssetTableName).\n\t\tWhere(\"scanner_id = ?\", scanner.ID).\n\t\tFirst(&storedAsset).Error; err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif storedAsset.Percentage != scanner.Percentage || \n\t   storedAsset.CurrentStatus != scanner.CurrentStatus {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "caller": "func VerifyAssetConsistency(ctx context.Context, detector *model.Scanner, database *gorm.DB) bool {\n\tassetChecker := &AssetRepo{db: database}\n\tisConsistent, _ := assetChecker.CompareData(ctx, detector)\n\treturn isConsistent\n}",
    "sql_statement_list": [
      {
        "type": "LACK_INFORMATION",
        "variants": [
          {
            "scenario": "缺少model.AssetTableName的具体定义，根据上下文推测表名为assets",
            "sql": "SELECT id, scanner_id, percentage, current_status, created_at, updated_at FROM assets WHERE scanner_id = ? LIMIT 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Scanner",
        "code_value": "type Scanner struct {\n\tID            string  `gorm:\"column:scanner_id\" json:\"scanner_id\"`\n\tPercentage    float64 `gorm:\"column:percentage\" json:\"percentage\"`\n\tCurrentStatus int     `gorm:\"column:current_status\" json:\"current_status\"`\n}"
      },
      {
        "code_key": "ReportContentTableName",
        "code_value": "const ReportContentTableName = \"scan_reports\""
      },
      {
        "code_key": "ContentReport",
        "code_value": "type ContentReport struct {\n\tID            int64   `gorm:\"column:id\" json:\"id\"`\n\tScannerID     string  `gorm:\"column:scanner_id\" json:\"scanner_id\"`\n\tPercentage    float64 `gorm:\"column:percentage\" json:\"percentage\"`\n\tCurrentStatus int     `gorm:\"column:current_status\" json:\"current_status\"`\n\tCreatedAt     int64   `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt     int64   `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "ScanResult",
        "code_value": "type ScanResult struct {\n\tIsMatch      bool   `json:\"is_match\"`\n\tErrorMessage string `json:\"error_message,omitempty\"`\n}"
      },
      {
        "code_key": "ReportRepo",
        "code_value": "type ReportRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ScanThreshold",
        "code_value": "const ScanThreshold = 0.95"
      },
      {
        "code_key": "StatusCompleted",
        "code_value": "const StatusCompleted = 1"
      },
      {
        "code_key": "StatusPending",
        "code_value": "const StatusPending = 0"
      },
      {
        "code_key": "TableName",
        "code_value": "func (cr *ContentReport) TableName() string {\n\treturn ReportContentTableName\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CompareData",
    "orm_code": "func (repo *AssetRepo) CompareData(ctx context.Context, scanner *model.Scanner) (bool, error) {\n\tdbClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tstoredAsset := &model.Asset{}\n\n\tif err := repo.db.Clauses(dbClause).Table(model.AssetTableName).\n\t\tWhere(\"scanner_id = ?\", scanner.ID).\n\t\tFirst(&storedAsset).Error; err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif storedAsset.Percentage != scanner.Percentage || \n\t   storedAsset.CurrentStatus != scanner.CurrentStatus {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "caller": "func HandlePremiumCategories() ([]Tag, error) {\n\tvendor := &Seller{\n\t\tEntityId: 1,\n\t\tStartTime: time.Now().AddDate(0, -1, 0),\n\t}\n\n\titems, err := vendor.CompareData()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to fetch premium categories: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn items, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "EntityId = 1 (premium category)",
            "sql": "SELECT id, name, category_type, price, status, created_at FROM product_categories WHERE status = 1 AND category_type = 'premium' AND created_at >= ? ORDER BY price DESC;"
          },
          {
            "scenario": "EntityId = 2 (standard category)",
            "sql": "SELECT id, name, category_type, price, status, created_at FROM product_categories WHERE status = 1 AND category_type = 'standard' AND created_at >= ? ORDER BY price DESC;"
          },
          {
            "scenario": "EntityId = 3 (basic category)",
            "sql": "SELECT id, name, category_type, price, status, created_at FROM product_categories WHERE status = 1 AND category_type = 'basic' AND created_at >= ? ORDER BY price DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Scanner",
        "code_value": "type Scanner struct {\n\tID            string  `gorm:\"column:scanner_id\" json:\"scanner_id\"`\n\tPercentage    float64 `gorm:\"column:percentage\" json:\"percentage\"`\n\tCurrentStatus int     `gorm:\"column:current_status\" json:\"current_status\"`\n}"
      },
      {
        "code_key": "ReportContentTableName",
        "code_value": "const ReportContentTableName = \"scan_reports\""
      },
      {
        "code_key": "ContentReport",
        "code_value": "type ContentReport struct {\n\tID            int64   `gorm:\"column:id\" json:\"id\"`\n\tScannerID     string  `gorm:\"column:scanner_id\" json:\"scanner_id\"`\n\tPercentage    float64 `gorm:\"column:percentage\" json:\"percentage\"`\n\tCurrentStatus int     `gorm:\"column:current_status\" json:\"current_status\"`\n\tCreatedAt     int64   `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt     int64   `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "ScanResult",
        "code_value": "type ScanResult struct {\n\tIsMatch      bool   `json:\"is_match\"`\n\tErrorMessage string `json:\"error_message,omitempty\"`\n}"
      },
      {
        "code_key": "ReportRepo",
        "code_value": "type ReportRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ScanThreshold",
        "code_value": "const ScanThreshold = 0.95"
      },
      {
        "code_key": "StatusCompleted",
        "code_value": "const StatusCompleted = 1"
      },
      {
        "code_key": "StatusPending",
        "code_value": "const StatusPending = 0"
      },
      {
        "code_key": "TableName",
        "code_value": "func (cr *ContentReport) TableName() string {\n\treturn ReportContentTableName\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CompareData",
    "orm_code": "func (repo *AssetRepo) CompareData(ctx context.Context, scanner *model.Scanner) (bool, error) {\n\tdbClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tstoredAsset := &model.Asset{}\n\n\tif err := repo.db.Clauses(dbClause).Table(model.AssetTableName).\n\t\tWhere(\"scanner_id = ?\", scanner.ID).\n\t\tFirst(&storedAsset).Error; err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif storedAsset.Percentage != scanner.Percentage || \n\t   storedAsset.CurrentStatus != scanner.CurrentStatus {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "caller": "func ProcessStandardInventory(startDate time.Time) error {\n\tmerchant := Seller{\n\t\tEntityId: 2,\n\t\tStartTime: startDate,\n\t}\n\n\tresults, err := merchant.CompareData()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"inventory processing failed: %w\", err)\n\t}\n\tlog.Printf(\"Found %d standard inventory items\", len(results))\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "EntityId=1 (premium)",
            "sql": "SELECT id, name, category_type, price, status, created_at FROM product_categories WHERE status = 1 AND category_type = 'premium' AND created_at >= ? ORDER BY price DESC;"
          },
          {
            "scenario": "EntityId=2 (standard)",
            "sql": "SELECT id, name, category_type, price, status, created_at FROM product_categories WHERE status = 1 AND category_type = 'standard' AND created_at >= ? ORDER BY price DESC;"
          },
          {
            "scenario": "EntityId=3 (basic)",
            "sql": "SELECT id, name, category_type, price, status, created_at FROM product_categories WHERE status = 1 AND category_type = 'basic' AND created_at >= ? ORDER BY price DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Scanner",
        "code_value": "type Scanner struct {\n\tID            string  `gorm:\"column:scanner_id\" json:\"scanner_id\"`\n\tPercentage    float64 `gorm:\"column:percentage\" json:\"percentage\"`\n\tCurrentStatus int     `gorm:\"column:current_status\" json:\"current_status\"`\n}"
      },
      {
        "code_key": "ReportContentTableName",
        "code_value": "const ReportContentTableName = \"scan_reports\""
      },
      {
        "code_key": "ContentReport",
        "code_value": "type ContentReport struct {\n\tID            int64   `gorm:\"column:id\" json:\"id\"`\n\tScannerID     string  `gorm:\"column:scanner_id\" json:\"scanner_id\"`\n\tPercentage    float64 `gorm:\"column:percentage\" json:\"percentage\"`\n\tCurrentStatus int     `gorm:\"column:current_status\" json:\"current_status\"`\n\tCreatedAt     int64   `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt     int64   `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "ScanResult",
        "code_value": "type ScanResult struct {\n\tIsMatch      bool   `json:\"is_match\"`\n\tErrorMessage string `json:\"error_message,omitempty\"`\n}"
      },
      {
        "code_key": "ReportRepo",
        "code_value": "type ReportRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ScanThreshold",
        "code_value": "const ScanThreshold = 0.95"
      },
      {
        "code_key": "StatusCompleted",
        "code_value": "const StatusCompleted = 1"
      },
      {
        "code_key": "StatusPending",
        "code_value": "const StatusPending = 0"
      },
      {
        "code_key": "TableName",
        "code_value": "func (cr *ContentReport) TableName() string {\n\treturn ReportContentTableName\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CompareData",
    "orm_code": "func (repo *AssetRepo) CompareData(ctx context.Context, scanner *model.Scanner) (bool, error) {\n\tdbClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tstoredAsset := &model.Asset{}\n\n\tif err := repo.db.Clauses(dbClause).Table(model.AssetTableName).\n\t\tWhere(\"scanner_id = ?\", scanner.ID).\n\t\tFirst(&storedAsset).Error; err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif storedAsset.Percentage != scanner.Percentage || \n\t   storedAsset.CurrentStatus != scanner.CurrentStatus {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "caller": "func FetchBasicProducts() ([]Tag, error) {\n\tbasicSeller := Seller{\n\t\tEntityId: 3,\n\t\tStartTime: time.Date(2023, 1, 1, 0, 0, 0, 0, time.UTC),\n\t}\n\n\tproducts, err := basicSeller.CompareData()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"basic product fetch error: %w\", err)\n\t}\n\treturn products, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "EntityId=1 (Premium)",
            "sql": "SELECT id, name, category_type, price, status, created_at FROM product_categories WHERE status = 1 AND category_type = 'premium' AND created_at >= 1672531200 ORDER BY price DESC;"
          },
          {
            "scenario": "EntityId=2 (Standard)",
            "sql": "SELECT id, name, category_type, price, status, created_at FROM product_categories WHERE status = 1 AND category_type = 'standard' AND created_at >= 1672531200 ORDER BY price DESC;"
          },
          {
            "scenario": "EntityId=3 (Basic) - Current calling context",
            "sql": "SELECT id, name, category_type, price, status, created_at FROM product_categories WHERE status = 1 AND category_type = 'basic' AND created_at >= 1672531200 ORDER BY price DESC;"
          },
          {
            "scenario": "EntityId=0 (No category_type filter)",
            "sql": "SELECT id, name, category_type, price, status, created_at FROM product_categories WHERE status = 1 AND created_at >= 1672531200 ORDER BY price DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Scanner",
        "code_value": "type Scanner struct {\n\tID            string  `gorm:\"column:scanner_id\" json:\"scanner_id\"`\n\tPercentage    float64 `gorm:\"column:percentage\" json:\"percentage\"`\n\tCurrentStatus int     `gorm:\"column:current_status\" json:\"current_status\"`\n}"
      },
      {
        "code_key": "ReportContentTableName",
        "code_value": "const ReportContentTableName = \"scan_reports\""
      },
      {
        "code_key": "ContentReport",
        "code_value": "type ContentReport struct {\n\tID            int64   `gorm:\"column:id\" json:\"id\"`\n\tScannerID     string  `gorm:\"column:scanner_id\" json:\"scanner_id\"`\n\tPercentage    float64 `gorm:\"column:percentage\" json:\"percentage\"`\n\tCurrentStatus int     `gorm:\"column:current_status\" json:\"current_status\"`\n\tCreatedAt     int64   `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt     int64   `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "ScanResult",
        "code_value": "type ScanResult struct {\n\tIsMatch      bool   `json:\"is_match\"`\n\tErrorMessage string `json:\"error_message,omitempty\"`\n}"
      },
      {
        "code_key": "ReportRepo",
        "code_value": "type ReportRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "ScanThreshold",
        "code_value": "const ScanThreshold = 0.95"
      },
      {
        "code_key": "StatusCompleted",
        "code_value": "const StatusCompleted = 1"
      },
      {
        "code_key": "StatusPending",
        "code_value": "const StatusPending = 0"
      },
      {
        "code_key": "TableName",
        "code_value": "func (cr *ContentReport) TableName() string {\n\treturn ReportContentTableName\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "TrackBehavior",
    "orm_code": "func (repo *GameBehaviorRepo) TrackBehavior(ctx context.Context, session *model.PlayerSession) error {\n\tactionClause := utils.SetSQLComment(ctx, utils.ActionKey)\n\tbehavior := &model.PlayerBehavior{SessionID: session.ID, AuthToken: session.Token}\n\n\tif err := repo.db.Clauses(actionClause).Table(model.BehaviorTableName).\n\t\tWhere(\"session_id = ? AND auth_token = ?\", session.ID, session.Token).\n\t\tFirstOrCreate(behavior).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif behavior.GrossValue < session.Score {\n\t\tif err := repo.db.Clauses(actionClause).Table(model.BehaviorTableName).\n\t\t\tWhere(\"id = ?\", behavior.ID).\n\t\t\tUpdate(\"gross_value\", session.Score).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "BehaviorType = 1 (NamespaceBehavior)",
            "sql": "SELECT id, namespace_name, email_address, modification_date, status, created_at FROM performance_reviews WHERE status = 1 AND namespace_name = ? ORDER BY created_at DESC LIMIT ?;"
          },
          {
            "scenario": "BehaviorType = 2 (EmailBehavior)",
            "sql": "SELECT id, namespace_name, email_address, modification_date, status, created_at FROM performance_reviews WHERE status = 1 AND email_address = ? ORDER BY created_at DESC LIMIT ?;"
          },
          {
            "scenario": "BehaviorType = 3 (DateBehavior)",
            "sql": "SELECT id, namespace_name, email_address, modification_date, status, created_at FROM performance_reviews WHERE status = 1 AND modification_date = ? ORDER BY created_at DESC LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PlayerSession",
        "code_value": "type PlayerSession struct {\n\tID    string `gorm:\"column:id\" json:\"id\"`\n\tToken string `gorm:\"column:auth_token\" json:\"auth_token\"`\n\tScore int    `gorm:\"column:score\" json:\"score\"`\n}"
      },
      {
        "code_key": "PlayerBehavior",
        "code_value": "type PlayerBehavior struct {\n\tID         int    `gorm:\"column:id\" json:\"id\"`\n\tSessionID  string `gorm:\"column:session_id\" json:\"session_id\"`\n\tAuthToken  string `gorm:\"column:auth_token\" json:\"auth_token\"`\n\tGrossValue int    `gorm:\"column:gross_value\" json:\"gross_value\"`\n}"
      },
      {
        "code_key": "GameBehaviorRepo",
        "code_value": "type GameBehaviorRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "BehaviorTableName",
        "code_value": "const BehaviorTableName = \"player_behavior\""
      },
      {
        "code_key": "ActionKey",
        "code_value": "const ActionKey = \"action\""
      },
      {
        "code_key": "ScoreThreshold",
        "code_value": "const ScoreThreshold = 1000"
      },
      {
        "code_key": "hints",
        "code_value": "import \"gorm.io/hints\""
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "TrackBehavior",
    "orm_code": "func (repo *GameBehaviorRepo) TrackBehavior(ctx context.Context, session *model.PlayerSession) error {\n\tactionClause := utils.SetSQLComment(ctx, utils.ActionKey)\n\tbehavior := &model.PlayerBehavior{SessionID: session.ID, AuthToken: session.Token}\n\n\tif err := repo.db.Clauses(actionClause).Table(model.BehaviorTableName).\n\t\tWhere(\"session_id = ? AND auth_token = ?\", session.ID, session.Token).\n\t\tFirstOrCreate(behavior).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif behavior.GrossValue < session.Score {\n\t\tif err := repo.db.Clauses(actionClause).Table(model.BehaviorTableName).\n\t\t\tWhere(\"id = ?\", behavior.ID).\n\t\t\tUpdate(\"gross_value\", session.Score).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func HandleGameSessionUpdate(ctx context.Context, gameSession *model.PlayerSession, logger *zap.Logger) error {\n\tgameRepo, err := data.NewGameBehaviorRepo()\n\tif err != nil {\n\t\tlogger.Error(\"Failed to initialize game behavior repository\", zap.Error(err))\n\t\treturn err\n\t}\n\n\tif err := gameRepo.TrackBehavior(ctx, gameSession); err != nil {\n\t\tlogger.Error(\"Failed to track player behavior\", \n\t\t\tzap.String(\"sessionID\", gameSession.ID),\n\t\t\tzap.Error(err))\n\t\treturn fmt.Errorf(\"track behavior failed: %w\", err)\n\t}\n\n\tlogger.Info(\"Successfully tracked player behavior\",\n\t\tzap.String(\"sessionID\", gameSession.ID),\n\t\tzap.Int(\"score\", gameSession.Score))\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "首次记录玩家行为（不存在匹配记录）",
            "sql": "SELECT id, session_id, auth_token, gross_value FROM player_behavior WHERE session_id = ? AND auth_token = ? LIMIT 1;"
          },
          {
            "scenario": "首次记录玩家行为（不存在匹配记录）- 插入新记录",
            "sql": "INSERT INTO player_behavior (session_id, auth_token, gross_value) VALUES (?, ?, ?);"
          },
          {
            "scenario": "已有记录但分数更高",
            "sql": "SELECT id, session_id, auth_token, gross_value FROM player_behavior WHERE session_id = ? AND auth_token = ? LIMIT 1;"
          },
          {
            "scenario": "已有记录但分数更高 - 更新记录",
            "sql": "UPDATE player_behavior SET gross_value = ? WHERE id = ?;"
          },
          {
            "scenario": "已有记录且分数不高",
            "sql": "SELECT id, session_id, auth_token, gross_value FROM player_behavior WHERE session_id = ? AND auth_token = ? LIMIT 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "PlayerSession",
        "code_value": "type PlayerSession struct {\n\tID    string `gorm:\"column:id\" json:\"id\"`\n\tToken string `gorm:\"column:auth_token\" json:\"auth_token\"`\n\tScore int    `gorm:\"column:score\" json:\"score\"`\n}"
      },
      {
        "code_key": "PlayerBehavior",
        "code_value": "type PlayerBehavior struct {\n\tID         int    `gorm:\"column:id\" json:\"id\"`\n\tSessionID  string `gorm:\"column:session_id\" json:\"session_id\"`\n\tAuthToken  string `gorm:\"column:auth_token\" json:\"auth_token\"`\n\tGrossValue int    `gorm:\"column:gross_value\" json:\"gross_value\"`\n}"
      },
      {
        "code_key": "GameBehaviorRepo",
        "code_value": "type GameBehaviorRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "BehaviorTableName",
        "code_value": "const BehaviorTableName = \"player_behavior\""
      },
      {
        "code_key": "ActionKey",
        "code_value": "const ActionKey = \"action\""
      },
      {
        "code_key": "ScoreThreshold",
        "code_value": "const ScoreThreshold = 1000"
      },
      {
        "code_key": "hints",
        "code_value": "import \"gorm.io/hints\""
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "TrackBehavior",
    "orm_code": "func (repo *GameBehaviorRepo) TrackBehavior(ctx context.Context, session *model.PlayerSession) error {\n\tactionClause := utils.SetSQLComment(ctx, utils.ActionKey)\n\tbehavior := &model.PlayerBehavior{SessionID: session.ID, AuthToken: session.Token}\n\n\tif err := repo.db.Clauses(actionClause).Table(model.BehaviorTableName).\n\t\tWhere(\"session_id = ? AND auth_token = ?\", session.ID, session.Token).\n\t\tFirstOrCreate(behavior).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif behavior.GrossValue < session.Score {\n\t\tif err := repo.db.Clauses(actionClause).Table(model.BehaviorTableName).\n\t\t\tWhere(\"id = ?\", behavior.ID).\n\t\t\tUpdate(\"gross_value\", session.Score).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func HandleUserPolicies() ([]Policy, error) {\n\tuserProfile := &Portfolio{\n\t\tBehaviorType:     2,\n\t\tEmailAddress:     \"user@example.com\",\n\t\tPageSize:         10,\n\t}\n\treturn userProfile.TrackBehavior()\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "BehaviorType = 2 (EmailBehavior) with specific email address",
            "sql": "SELECT id, namespace_name, email_address, modification_date, status, created_at FROM performance_reviews WHERE status = 1 AND email_address = 'user@example.com' ORDER BY created_at DESC LIMIT 10;"
          },
          {
            "scenario": "BehaviorType = 1 (NamespaceBehavior)",
            "sql": "SELECT id, namespace_name, email_address, modification_date, status, created_at FROM performance_reviews WHERE status = 1 AND namespace_name = ? ORDER BY created_at DESC LIMIT ?;"
          },
          {
            "scenario": "BehaviorType = 3 (DateBehavior)",
            "sql": "SELECT id, namespace_name, email_address, modification_date, status, created_at FROM performance_reviews WHERE status = 1 AND modification_date = ? ORDER BY created_at DESC LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PlayerSession",
        "code_value": "type PlayerSession struct {\n\tID    string `gorm:\"column:id\" json:\"id\"`\n\tToken string `gorm:\"column:auth_token\" json:\"auth_token\"`\n\tScore int    `gorm:\"column:score\" json:\"score\"`\n}"
      },
      {
        "code_key": "PlayerBehavior",
        "code_value": "type PlayerBehavior struct {\n\tID         int    `gorm:\"column:id\" json:\"id\"`\n\tSessionID  string `gorm:\"column:session_id\" json:\"session_id\"`\n\tAuthToken  string `gorm:\"column:auth_token\" json:\"auth_token\"`\n\tGrossValue int    `gorm:\"column:gross_value\" json:\"gross_value\"`\n}"
      },
      {
        "code_key": "GameBehaviorRepo",
        "code_value": "type GameBehaviorRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "BehaviorTableName",
        "code_value": "const BehaviorTableName = \"player_behavior\""
      },
      {
        "code_key": "ActionKey",
        "code_value": "const ActionKey = \"action\""
      },
      {
        "code_key": "ScoreThreshold",
        "code_value": "const ScoreThreshold = 1000"
      },
      {
        "code_key": "hints",
        "code_value": "import \"gorm.io/hints\""
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "TrackBehavior",
    "orm_code": "func (repo *GameBehaviorRepo) TrackBehavior(ctx context.Context, session *model.PlayerSession) error {\n\tactionClause := utils.SetSQLComment(ctx, utils.ActionKey)\n\tbehavior := &model.PlayerBehavior{SessionID: session.ID, AuthToken: session.Token}\n\n\tif err := repo.db.Clauses(actionClause).Table(model.BehaviorTableName).\n\t\tWhere(\"session_id = ? AND auth_token = ?\", session.ID, session.Token).\n\t\tFirstOrCreate(behavior).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif behavior.GrossValue < session.Score {\n\t\tif err := repo.db.Clauses(actionClause).Table(model.BehaviorTableName).\n\t\t\tWhere(\"id = ?\", behavior.ID).\n\t\t\tUpdate(\"gross_value\", session.Score).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func HandleNamespaceReviews() ([]Policy, error) {\n\tnsReview := &Portfolio{\n\t\tBehaviorType:     1,\n\t\tNamespaceName:    \"prod-cluster\",\n\t\tPageSize:         5,\n\t}\n\treturn nsReview.TrackBehavior()\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "BehaviorType=1 (NamespaceBehavior)",
            "sql": "SELECT id, namespace_name, email_address, modification_date, status, created_at FROM performance_reviews WHERE status = 1 AND namespace_name = 'prod-cluster' ORDER BY created_at DESC LIMIT 5;"
          },
          {
            "scenario": "BehaviorType=2 (EmailBehavior)",
            "sql": "SELECT id, namespace_name, email_address, modification_date, status, created_at FROM performance_reviews WHERE status = 1 AND email_address = ? ORDER BY created_at DESC LIMIT ?;"
          },
          {
            "scenario": "BehaviorType=3 (DateBehavior)",
            "sql": "SELECT id, namespace_name, email_address, modification_date, status, created_at FROM performance_reviews WHERE status = 1 AND modification_date = ? ORDER BY created_at DESC LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PlayerSession",
        "code_value": "type PlayerSession struct {\n\tID    string `gorm:\"column:id\" json:\"id\"`\n\tToken string `gorm:\"column:auth_token\" json:\"auth_token\"`\n\tScore int    `gorm:\"column:score\" json:\"score\"`\n}"
      },
      {
        "code_key": "PlayerBehavior",
        "code_value": "type PlayerBehavior struct {\n\tID         int    `gorm:\"column:id\" json:\"id\"`\n\tSessionID  string `gorm:\"column:session_id\" json:\"session_id\"`\n\tAuthToken  string `gorm:\"column:auth_token\" json:\"auth_token\"`\n\tGrossValue int    `gorm:\"column:gross_value\" json:\"gross_value\"`\n}"
      },
      {
        "code_key": "GameBehaviorRepo",
        "code_value": "type GameBehaviorRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "BehaviorTableName",
        "code_value": "const BehaviorTableName = \"player_behavior\""
      },
      {
        "code_key": "ActionKey",
        "code_value": "const ActionKey = \"action\""
      },
      {
        "code_key": "ScoreThreshold",
        "code_value": "const ScoreThreshold = 1000"
      },
      {
        "code_key": "hints",
        "code_value": "import \"gorm.io/hints\""
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "TrackBehavior",
    "orm_code": "func (repo *GameBehaviorRepo) TrackBehavior(ctx context.Context, session *model.PlayerSession) error {\n\tactionClause := utils.SetSQLComment(ctx, utils.ActionKey)\n\tbehavior := &model.PlayerBehavior{SessionID: session.ID, AuthToken: session.Token}\n\n\tif err := repo.db.Clauses(actionClause).Table(model.BehaviorTableName).\n\t\tWhere(\"session_id = ? AND auth_token = ?\", session.ID, session.Token).\n\t\tFirstOrCreate(behavior).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif behavior.GrossValue < session.Score {\n\t\tif err := repo.db.Clauses(actionClause).Table(model.BehaviorTableName).\n\t\t\tWhere(\"id = ?\", behavior.ID).\n\t\t\tUpdate(\"gross_value\", session.Score).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func HandleDateFilteredAudits() ([]Policy, error) {\n\tauditCheck := &Portfolio{\n\t\tBehaviorType:     3,\n\t\tModificationDate: \"2023-11-15\",\n\t\tPageSize:         20,\n\t}\n\treturn auditCheck.TrackBehavior()\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "BehaviorType=3 with ModificationDate filter",
            "sql": "SELECT performance_reviews.id, performance_reviews.namespace_name, performance_reviews.email_address, performance_reviews.modification_date, performance_reviews.status, performance_reviews.created_at FROM performance_reviews WHERE performance_reviews.status = 1 AND performance_reviews.modification_date = '2023-11-15' ORDER BY performance_reviews.created_at DESC LIMIT 20;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PlayerSession",
        "code_value": "type PlayerSession struct {\n\tID    string `gorm:\"column:id\" json:\"id\"`\n\tToken string `gorm:\"column:auth_token\" json:\"auth_token\"`\n\tScore int    `gorm:\"column:score\" json:\"score\"`\n}"
      },
      {
        "code_key": "PlayerBehavior",
        "code_value": "type PlayerBehavior struct {\n\tID         int    `gorm:\"column:id\" json:\"id\"`\n\tSessionID  string `gorm:\"column:session_id\" json:\"session_id\"`\n\tAuthToken  string `gorm:\"column:auth_token\" json:\"auth_token\"`\n\tGrossValue int    `gorm:\"column:gross_value\" json:\"gross_value\"`\n}"
      },
      {
        "code_key": "GameBehaviorRepo",
        "code_value": "type GameBehaviorRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "BehaviorTableName",
        "code_value": "const BehaviorTableName = \"player_behavior\""
      },
      {
        "code_key": "ActionKey",
        "code_value": "const ActionKey = \"action\""
      },
      {
        "code_key": "ScoreThreshold",
        "code_value": "const ScoreThreshold = 1000"
      },
      {
        "code_key": "hints",
        "code_value": "import \"gorm.io/hints\""
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "SortByField",
    "orm_code": "func (repo *StreamRepo) SortByField(ctx context.Context, fieldName string, ascending bool) ([]*model.Stream, error) {\n\torderClause := utils.SetSQLComment(ctx, utils.OrderKey)\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\t\n\tvar streams []*model.Stream\n\tdbQuery := repo.db.Clauses(queryClause).Table(model.StreamTableName)\n\t\n\tif ascending {\n\t\tdbQuery = dbQuery.Clauses(orderClause).Order(fieldName + \" ASC\")\n\t} else {\n\t\tdbQuery = dbQuery.Clauses(orderClause).Order(fieldName + \" DESC\")\n\t}\n\t\n\tif err := dbQuery.Find(&streams).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn streams, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按观看数排序（views）且无序列号条件",
            "sql": "SELECT id, title, view_count, average_rating, publish_date, sequence_number FROM player_rankings ORDER BY view_count DESC LIMIT 10;"
          },
          {
            "scenario": "按观看数排序（views）且有序列号条件",
            "sql": "SELECT id, title, view_count, average_rating, publish_date, sequence_number FROM player_rankings WHERE sequence_number > 100 ORDER BY view_count DESC LIMIT 10;"
          },
          {
            "scenario": "按评分排序（rating）且无序列号条件",
            "sql": "SELECT id, title, view_count, average_rating, publish_date, sequence_number FROM player_rankings ORDER BY average_rating DESC LIMIT 10;"
          },
          {
            "scenario": "按评分排序（rating）且有序列号条件",
            "sql": "SELECT id, title, view_count, average_rating, publish_date, sequence_number FROM player_rankings WHERE sequence_number > 100 ORDER BY average_rating DESC LIMIT 10;"
          },
          {
            "scenario": "按发布日期排序（date）且无序列号条件",
            "sql": "SELECT id, title, view_count, average_rating, publish_date, sequence_number FROM player_rankings ORDER BY publish_date DESC LIMIT 10;"
          },
          {
            "scenario": "按发布日期排序（date）且有序列号条件",
            "sql": "SELECT id, title, view_count, average_rating, publish_date, sequence_number FROM player_rankings WHERE sequence_number > 100 ORDER BY publish_date DESC LIMIT 10;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "StreamRepo",
        "code_value": "type StreamRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "StreamTableName",
        "code_value": "const StreamTableName = \"media_streams\""
      },
      {
        "code_key": "Stream",
        "code_value": "type Stream struct {\n\tID          uint      `gorm:\"column:id;primaryKey\" json:\"id\"`\n\tName        string    `gorm:\"column:name\" json:\"name\"`\n\tStatus      int       `gorm:\"column:status\" json:\"status\"`\n\tCreatedAt   time.Time `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt   time.Time `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "StreamStatusActive",
        "code_value": "const StreamStatusActive = 1"
      },
      {
        "code_key": "StreamStatusInactive",
        "code_value": "const StreamStatusInactive = 0"
      },
      {
        "code_key": "OrderKey",
        "code_value": "const OrderKey = \"ORDER\""
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"QUERY\""
      },
      {
        "code_key": "StreamSortFields",
        "code_value": "var StreamSortFields = []string{\"name\", \"created_at\", \"updated_at\"}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (s *Stream) TableName() string {\n\treturn StreamTableName\n}"
      },
      {
        "code_key": "StreamFilter",
        "code_value": "type StreamFilter struct {\n\tStatus *int\n\tName   *string\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "SortByField",
    "orm_code": "func (repo *StreamRepo) SortByField(ctx context.Context, fieldName string, ascending bool) ([]*model.Stream, error) {\n\torderClause := utils.SetSQLComment(ctx, utils.OrderKey)\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\t\n\tvar streams []*model.Stream\n\tdbQuery := repo.db.Clauses(queryClause).Table(model.StreamTableName)\n\t\n\tif ascending {\n\t\tdbQuery = dbQuery.Clauses(orderClause).Order(fieldName + \" ASC\")\n\t} else {\n\t\tdbQuery = dbQuery.Clauses(orderClause).Order(fieldName + \" DESC\")\n\t}\n\t\n\tif err := dbQuery.Find(&streams).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn streams, nil\n}",
    "caller": "func HandleLiveStreamSorting(ctx context.Context, log *zap.Logger) ([]*model.Stream, error) {\n\tdb := conf.GetDBEngine()\n\tif db == nil {\n\t\treturn nil, fmt.Errorf(\"database engine not initialized\")\n\t}\n\n\trepo := &StreamRepo{db: db}\n\tsortedStreams, err := repo.SortByField(ctx, \"viewers_count\", false)\n\tif err != nil {\n\t\tlog.Error(\"Failed to sort streams by viewers\", zap.Error(err))\n\t\treturn nil, err\n\t}\n\treturn sortedStreams, nil\n}",
    "sql_statement_list": [
      {
        "type": "LACK_INFORMATION",
        "variants": [
          {
            "scenario": "字段 'viewers_count' 在表结构 'media_streams' 中不存在，可能导致查询错误",
            "sql": "SELECT media_streams.id, media_streams.name, media_streams.status, media_streams.created_at, media_streams.updated_at FROM media_streams ORDER BY viewers_count DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "StreamRepo",
        "code_value": "type StreamRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "StreamTableName",
        "code_value": "const StreamTableName = \"media_streams\""
      },
      {
        "code_key": "Stream",
        "code_value": "type Stream struct {\n\tID          uint      `gorm:\"column:id;primaryKey\" json:\"id\"`\n\tName        string    `gorm:\"column:name\" json:\"name\"`\n\tStatus      int       `gorm:\"column:status\" json:\"status\"`\n\tCreatedAt   time.Time `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt   time.Time `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "StreamStatusActive",
        "code_value": "const StreamStatusActive = 1"
      },
      {
        "code_key": "StreamStatusInactive",
        "code_value": "const StreamStatusInactive = 0"
      },
      {
        "code_key": "OrderKey",
        "code_value": "const OrderKey = \"ORDER\""
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"QUERY\""
      },
      {
        "code_key": "StreamSortFields",
        "code_value": "var StreamSortFields = []string{\"name\", \"created_at\", \"updated_at\"}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (s *Stream) TableName() string {\n\treturn StreamTableName\n}"
      },
      {
        "code_key": "StreamFilter",
        "code_value": "type StreamFilter struct {\n\tStatus *int\n\tName   *string\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "SortByField",
    "orm_code": "func (repo *StreamRepo) SortByField(ctx context.Context, fieldName string, ascending bool) ([]*model.Stream, error) {\n\torderClause := utils.SetSQLComment(ctx, utils.OrderKey)\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\t\n\tvar streams []*model.Stream\n\tdbQuery := repo.db.Clauses(queryClause).Table(model.StreamTableName)\n\t\n\tif ascending {\n\t\tdbQuery = dbQuery.Clauses(orderClause).Order(fieldName + \" ASC\")\n\t} else {\n\t\tdbQuery = dbQuery.Clauses(orderClause).Order(fieldName + \" DESC\")\n\t}\n\t\n\tif err := dbQuery.Find(&streams).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn streams, nil\n}",
    "caller": "func HandleNewestStreams(ctx context.Context) ([]*model.Stream, error) {\n\tdbConn, err := data.NewDBConnection()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create db connection: %v\", err)\n\t}\n\n\trepo := &StreamRepo{db: dbConn}\n\tresult, err := repo.SortByField(ctx, \"created_at\", false)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"sorting failed: %v\", err)\n\t}\n\treturn result, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Sort by created_at in descending order",
            "sql": "SELECT id, name, status, created_at, updated_at FROM media_streams ORDER BY created_at DESC;"
          },
          {
            "scenario": "Sort by created_at in ascending order",
            "sql": "SELECT id, name, status, created_at, updated_at FROM media_streams ORDER BY created_at ASC;"
          },
          {
            "scenario": "Sort by name in descending order",
            "sql": "SELECT id, name, status, created_at, updated_at FROM media_streams ORDER BY name DESC;"
          },
          {
            "scenario": "Sort by name in ascending order",
            "sql": "SELECT id, name, status, created_at, updated_at FROM media_streams ORDER BY name ASC;"
          },
          {
            "scenario": "Sort by updated_at in descending order",
            "sql": "SELECT id, name, status, created_at, updated_at FROM media_streams ORDER BY updated_at DESC;"
          },
          {
            "scenario": "Sort by updated_at in ascending order",
            "sql": "SELECT id, name, status, created_at, updated_at FROM media_streams ORDER BY updated_at ASC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "StreamRepo",
        "code_value": "type StreamRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "StreamTableName",
        "code_value": "const StreamTableName = \"media_streams\""
      },
      {
        "code_key": "Stream",
        "code_value": "type Stream struct {\n\tID          uint      `gorm:\"column:id;primaryKey\" json:\"id\"`\n\tName        string    `gorm:\"column:name\" json:\"name\"`\n\tStatus      int       `gorm:\"column:status\" json:\"status\"`\n\tCreatedAt   time.Time `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt   time.Time `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "StreamStatusActive",
        "code_value": "const StreamStatusActive = 1"
      },
      {
        "code_key": "StreamStatusInactive",
        "code_value": "const StreamStatusInactive = 0"
      },
      {
        "code_key": "OrderKey",
        "code_value": "const OrderKey = \"ORDER\""
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"QUERY\""
      },
      {
        "code_key": "StreamSortFields",
        "code_value": "var StreamSortFields = []string{\"name\", \"created_at\", \"updated_at\"}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (s *Stream) TableName() string {\n\treturn StreamTableName\n}"
      },
      {
        "code_key": "StreamFilter",
        "code_value": "type StreamFilter struct {\n\tStatus *int\n\tName   *string\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "SortByField",
    "orm_code": "func (repo *StreamRepo) SortByField(ctx context.Context, fieldName string, ascending bool) ([]*model.Stream, error) {\n\torderClause := utils.SetSQLComment(ctx, utils.OrderKey)\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\t\n\tvar streams []*model.Stream\n\tdbQuery := repo.db.Clauses(queryClause).Table(model.StreamTableName)\n\t\n\tif ascending {\n\t\tdbQuery = dbQuery.Clauses(orderClause).Order(fieldName + \" ASC\")\n\t} else {\n\t\tdbQuery = dbQuery.Clauses(orderClause).Order(fieldName + \" DESC\")\n\t}\n\t\n\tif err := dbQuery.Find(&streams).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn streams, nil\n}",
    "caller": "func HandlePopularVideos() ([]VideoInfo, error) {\n\tmediaItem := Video{\n\t\tSortField:      \"views\",\n\t\tPageSize:       10,\n\t\tSequenceNumber: 0,\n\t}\n\treturn mediaItem.SortByField()\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "按views排序且无sequence_number条件",
            "sql": "SELECT id, title, view_count, average_rating, publish_date, sequence_number FROM player_rankings ORDER BY view_count DESC LIMIT 10;"
          },
          {
            "scenario": "按rating排序且无sequence_number条件",
            "sql": "SELECT id, title, view_count, average_rating, publish_date, sequence_number FROM player_rankings ORDER BY average_rating DESC LIMIT ?;"
          },
          {
            "scenario": "按date排序且无sequence_number条件",
            "sql": "SELECT id, title, view_count, average_rating, publish_date, sequence_number FROM player_rankings ORDER BY publish_date DESC LIMIT ?;"
          },
          {
            "scenario": "按views排序且有sequence_number条件",
            "sql": "SELECT id, title, view_count, average_rating, publish_date, sequence_number FROM player_rankings WHERE sequence_number > ? ORDER BY view_count DESC LIMIT ?;"
          },
          {
            "scenario": "按rating排序且有sequence_number条件",
            "sql": "SELECT id, title, view_count, average_rating, publish_date, sequence_number FROM player_rankings WHERE sequence_number > ? ORDER BY average_rating DESC LIMIT ?;"
          },
          {
            "scenario": "按date排序且有sequence_number条件",
            "sql": "SELECT id, title, view_count, average_rating, publish_date, sequence_number FROM player_rankings WHERE sequence_number > ? ORDER BY publish_date DESC LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "StreamRepo",
        "code_value": "type StreamRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "StreamTableName",
        "code_value": "const StreamTableName = \"media_streams\""
      },
      {
        "code_key": "Stream",
        "code_value": "type Stream struct {\n\tID          uint      `gorm:\"column:id;primaryKey\" json:\"id\"`\n\tName        string    `gorm:\"column:name\" json:\"name\"`\n\tStatus      int       `gorm:\"column:status\" json:\"status\"`\n\tCreatedAt   time.Time `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt   time.Time `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "StreamStatusActive",
        "code_value": "const StreamStatusActive = 1"
      },
      {
        "code_key": "StreamStatusInactive",
        "code_value": "const StreamStatusInactive = 0"
      },
      {
        "code_key": "OrderKey",
        "code_value": "const OrderKey = \"ORDER\""
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"QUERY\""
      },
      {
        "code_key": "StreamSortFields",
        "code_value": "var StreamSortFields = []string{\"name\", \"created_at\", \"updated_at\"}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (s *Stream) TableName() string {\n\treturn StreamTableName\n}"
      },
      {
        "code_key": "StreamFilter",
        "code_value": "type StreamFilter struct {\n\tStatus *int\n\tName   *string\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "SortByField",
    "orm_code": "func (repo *StreamRepo) SortByField(ctx context.Context, fieldName string, ascending bool) ([]*model.Stream, error) {\n\torderClause := utils.SetSQLComment(ctx, utils.OrderKey)\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\t\n\tvar streams []*model.Stream\n\tdbQuery := repo.db.Clauses(queryClause).Table(model.StreamTableName)\n\t\n\tif ascending {\n\t\tdbQuery = dbQuery.Clauses(orderClause).Order(fieldName + \" ASC\")\n\t} else {\n\t\tdbQuery = dbQuery.Clauses(orderClause).Order(fieldName + \" DESC\")\n\t}\n\t\n\tif err := dbQuery.Find(&streams).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn streams, nil\n}",
    "caller": "func HandleRecentUploads() ([]VideoInfo, error) {\n\tclip := Video{\n\t\tSortField:      \"date\",\n\t\tPageSize:       5,\n\t\tSequenceNumber: 100,\n\t}\n\tresults, err := clip.SortByField()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get recent uploads: %v\", err)\n\t}\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Sort by date with sequence number",
            "sql": "SELECT id, title, view_count, average_rating, publish_date, sequence_number FROM player_rankings WHERE sequence_number > 100 ORDER BY publish_date DESC LIMIT 5;"
          },
          {
            "scenario": "Sort by views with sequence number",
            "sql": "SELECT id, title, view_count, average_rating, publish_date, sequence_number FROM player_rankings WHERE sequence_number > ? ORDER BY view_count DESC LIMIT ?;"
          },
          {
            "scenario": "Sort by rating with sequence number",
            "sql": "SELECT id, title, view_count, average_rating, publish_date, sequence_number FROM player_rankings WHERE sequence_number > ? ORDER BY average_rating DESC LIMIT ?;"
          },
          {
            "scenario": "Sort by date without sequence number",
            "sql": "SELECT id, title, view_count, average_rating, publish_date, sequence_number FROM player_rankings ORDER BY publish_date DESC LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "StreamRepo",
        "code_value": "type StreamRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "StreamTableName",
        "code_value": "const StreamTableName = \"media_streams\""
      },
      {
        "code_key": "Stream",
        "code_value": "type Stream struct {\n\tID          uint      `gorm:\"column:id;primaryKey\" json:\"id\"`\n\tName        string    `gorm:\"column:name\" json:\"name\"`\n\tStatus      int       `gorm:\"column:status\" json:\"status\"`\n\tCreatedAt   time.Time `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt   time.Time `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "StreamStatusActive",
        "code_value": "const StreamStatusActive = 1"
      },
      {
        "code_key": "StreamStatusInactive",
        "code_value": "const StreamStatusInactive = 0"
      },
      {
        "code_key": "OrderKey",
        "code_value": "const OrderKey = \"ORDER\""
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"QUERY\""
      },
      {
        "code_key": "StreamSortFields",
        "code_value": "var StreamSortFields = []string{\"name\", \"created_at\", \"updated_at\"}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (s *Stream) TableName() string {\n\treturn StreamTableName\n}"
      },
      {
        "code_key": "StreamFilter",
        "code_value": "type StreamFilter struct {\n\tStatus *int\n\tName   *string\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "SortByField",
    "orm_code": "func (repo *StreamRepo) SortByField(ctx context.Context, fieldName string, ascending bool) ([]*model.Stream, error) {\n\torderClause := utils.SetSQLComment(ctx, utils.OrderKey)\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\t\n\tvar streams []*model.Stream\n\tdbQuery := repo.db.Clauses(queryClause).Table(model.StreamTableName)\n\t\n\tif ascending {\n\t\tdbQuery = dbQuery.Clauses(orderClause).Order(fieldName + \" ASC\")\n\t} else {\n\t\tdbQuery = dbQuery.Clauses(orderClause).Order(fieldName + \" DESC\")\n\t}\n\t\n\tif err := dbQuery.Find(&streams).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn streams, nil\n}",
    "caller": "func HandleTopRatedContent(pageSize int) ([]VideoInfo, error) {\n\tif pageSize <= 0 {\n\t\treturn nil, errors.New(\"invalid page size\")\n\t}\n\tcontent := Video{\n\t\tSortField: \"rating\",\n\t\tPageSize:  pageSize,\n\t}\n\treturn content.SortByField()\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Sort by rating without sequence number condition",
            "sql": "SELECT id, title, view_count, average_rating, publish_date, sequence_number FROM player_rankings ORDER BY average_rating DESC LIMIT ?;"
          },
          {
            "scenario": "Sort by views without sequence number condition",
            "sql": "SELECT id, title, view_count, average_rating, publish_date, sequence_number FROM player_rankings ORDER BY view_count DESC LIMIT ?;"
          },
          {
            "scenario": "Sort by date without sequence number condition",
            "sql": "SELECT id, title, view_count, average_rating, publish_date, sequence_number FROM player_rankings ORDER BY publish_date DESC LIMIT ?;"
          },
          {
            "scenario": "Sort by rating with sequence number condition",
            "sql": "SELECT id, title, view_count, average_rating, publish_date, sequence_number FROM player_rankings WHERE sequence_number > ? ORDER BY average_rating DESC LIMIT ?;"
          },
          {
            "scenario": "Sort by views with sequence number condition",
            "sql": "SELECT id, title, view_count, average_rating, publish_date, sequence_number FROM player_rankings WHERE sequence_number > ? ORDER BY view_count DESC LIMIT ?;"
          },
          {
            "scenario": "Sort by date with sequence number condition",
            "sql": "SELECT id, title, view_count, average_rating, publish_date, sequence_number FROM player_rankings WHERE sequence_number > ? ORDER BY publish_date DESC LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "StreamRepo",
        "code_value": "type StreamRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "StreamTableName",
        "code_value": "const StreamTableName = \"media_streams\""
      },
      {
        "code_key": "Stream",
        "code_value": "type Stream struct {\n\tID          uint      `gorm:\"column:id;primaryKey\" json:\"id\"`\n\tName        string    `gorm:\"column:name\" json:\"name\"`\n\tStatus      int       `gorm:\"column:status\" json:\"status\"`\n\tCreatedAt   time.Time `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt   time.Time `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "StreamStatusActive",
        "code_value": "const StreamStatusActive = 1"
      },
      {
        "code_key": "StreamStatusInactive",
        "code_value": "const StreamStatusInactive = 0"
      },
      {
        "code_key": "OrderKey",
        "code_value": "const OrderKey = \"ORDER\""
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"QUERY\""
      },
      {
        "code_key": "StreamSortFields",
        "code_value": "var StreamSortFields = []string{\"name\", \"created_at\", \"updated_at\"}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (s *Stream) TableName() string {\n\treturn StreamTableName\n}"
      },
      {
        "code_key": "StreamFilter",
        "code_value": "type StreamFilter struct {\n\tStatus *int\n\tName   *string\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "FilterByAttribute",
    "orm_code": "func (repo *MagazineRepo) FilterByAttribute(ctx context.Context, regionCode string, categoryType int) ([]*model.Magazine, error) {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tvar results []*model.Magazine\n\n\tif err := repo.db.Clauses(selectClause).Table(model.MagazineTableName).\n\t\tWhere(\"region_code = ? AND category_type = ?\", regionCode, categoryType).\n\t\tFind(&results).Error; err != nil {\n\t\t\treturn nil, err\n\t}\n\n\tif len(results) == 0 {\n\t\treturn nil, gorm.ErrRecordNotFound\n\t}\n\n\treturn results, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "PermissionType = 0, ContractNumber为空",
            "sql": "SELECT id, contract_number, access_level, is_premium, status FROM guild_memberships WHERE status = 1;"
          },
          {
            "scenario": "PermissionType = 1, ContractNumber为空",
            "sql": "SELECT id, contract_number, access_level, is_premium, status FROM guild_memberships WHERE status = 1 AND access_level = 'basic';"
          },
          {
            "scenario": "PermissionType = 2, ContractNumber为空",
            "sql": "SELECT id, contract_number, access_level, is_premium, status FROM guild_memberships WHERE status = 1 AND access_level = 'advanced';"
          },
          {
            "scenario": "PermissionType = 3, ContractNumber为空",
            "sql": "SELECT id, contract_number, access_level, is_premium, status FROM guild_memberships WHERE status = 1 AND is_premium = true;"
          },
          {
            "scenario": "PermissionType = 0, ContractNumber有值",
            "sql": "SELECT id, contract_number, access_level, is_premium, status FROM guild_memberships WHERE status = 1 AND contract_number = ?;"
          },
          {
            "scenario": "PermissionType = 1, ContractNumber有值",
            "sql": "SELECT id, contract_number, access_level, is_premium, status FROM guild_memberships WHERE status = 1 AND access_level = 'basic' AND contract_number = ?;"
          },
          {
            "scenario": "PermissionType = 2, ContractNumber有值",
            "sql": "SELECT id, contract_number, access_level, is_premium, status FROM guild_memberships WHERE status = 1 AND access_level = 'advanced' AND contract_number = ?;"
          },
          {
            "scenario": "PermissionType = 3, ContractNumber有值",
            "sql": "SELECT id, contract_number, access_level, is_premium, status FROM guild_memberships WHERE status = 1 AND is_premium = true AND contract_number = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "MagazineRepo",
        "code_value": "type MagazineRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Magazine",
        "code_value": "type Magazine struct {\n\tID           int64  `gorm:\"column:id\" json:\"id\"`\n\tRegionCode   string `gorm:\"column:region_code\" json:\"region_code\"`\n\tCategoryType int    `gorm:\"column:category_type\" json:\"category_type\"`\n\tTitle        string `gorm:\"column:title\" json:\"title\"`\n\tPublishDate  int64  `gorm:\"column:publish_date\" json:\"publish_date\"`\n}"
      },
      {
        "code_key": "MagazineTableName",
        "code_value": "const MagazineTableName = \"game_magazines\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (m *Magazine) TableName() string {\n\treturn MagazineTableName\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "hints",
        "code_value": "git.woa.com/gorm/hints"
      },
      {
        "code_key": "icontext",
        "code_value": "git.woa.com/context/icontext"
      },
      {
        "code_key": "defaultRegion",
        "code_value": "var defaultRegion = \"CN\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "FilterByAttribute",
    "orm_code": "func (repo *MagazineRepo) FilterByAttribute(ctx context.Context, regionCode string, categoryType int) ([]*model.Magazine, error) {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tvar results []*model.Magazine\n\n\tif err := repo.db.Clauses(selectClause).Table(model.MagazineTableName).\n\t\tWhere(\"region_code = ? AND category_type = ?\", regionCode, categoryType).\n\t\tFind(&results).Error; err != nil {\n\t\t\treturn nil, err\n\t}\n\n\tif len(results) == 0 {\n\t\treturn nil, gorm.ErrRecordNotFound\n\t}\n\n\treturn results, nil\n}",
    "caller": "func HandleRegionalMagazines(ctx context.Context, region string, category int) ([]*model.Magazine, error) {\n\trepo := &MagazineRepo{db: conf.GetDBEngine()}\n\tmagazines, err := repo.FilterByAttribute(ctx, region, category)\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to get regional magazines: %w\", err)\n\t}\n\treturn magazines, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "region='CN', category=1",
            "sql": "SELECT * FROM game_magazines WHERE region_code = 'CN' AND category_type = 1;"
          },
          {
            "scenario": "region='US', category=2",
            "sql": "SELECT * FROM game_magazines WHERE region_code = 'US' AND category_type = 2;"
          },
          {
            "scenario": "generic parameterized query",
            "sql": "SELECT * FROM game_magazines WHERE region_code = ? AND category_type = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "MagazineRepo",
        "code_value": "type MagazineRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Magazine",
        "code_value": "type Magazine struct {\n\tID           int64  `gorm:\"column:id\" json:\"id\"`\n\tRegionCode   string `gorm:\"column:region_code\" json:\"region_code\"`\n\tCategoryType int    `gorm:\"column:category_type\" json:\"category_type\"`\n\tTitle        string `gorm:\"column:title\" json:\"title\"`\n\tPublishDate  int64  `gorm:\"column:publish_date\" json:\"publish_date\"`\n}"
      },
      {
        "code_key": "MagazineTableName",
        "code_value": "const MagazineTableName = \"game_magazines\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (m *Magazine) TableName() string {\n\treturn MagazineTableName\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "hints",
        "code_value": "git.woa.com/gorm/hints"
      },
      {
        "code_key": "icontext",
        "code_value": "git.woa.com/context/icontext"
      },
      {
        "code_key": "defaultRegion",
        "code_value": "var defaultRegion = \"CN\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "FilterByAttribute",
    "orm_code": "func (repo *MagazineRepo) FilterByAttribute(ctx context.Context, regionCode string, categoryType int) ([]*model.Magazine, error) {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tvar results []*model.Magazine\n\n\tif err := repo.db.Clauses(selectClause).Table(model.MagazineTableName).\n\t\tWhere(\"region_code = ? AND category_type = ?\", regionCode, categoryType).\n\t\tFind(&results).Error; err != nil {\n\t\t\treturn nil, err\n\t}\n\n\tif len(results) == 0 {\n\t\treturn nil, gorm.ErrRecordNotFound\n\t}\n\n\treturn results, nil\n}",
    "caller": "func ProcessMagazineFeed(ctx context.Context, locationCode string) error {\n\trepo := &MagazineRepo{db: conf.GetDefaultDB()}\n\titems, err := repo.FilterByAttribute(ctx, locationCode, model.CategoryMonthly)\n\tif err != nil {\n\t\tlog.Printf(\"Error fetching monthly magazines: %v\", err)\n\t\treturn err\n\t}\n\tfor _, item := range items {\n\t\tsendToFeedService(item)\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Filter magazines by region and category",
            "sql": "SELECT id, region_code, category_type, title, publish_date FROM game_magazines WHERE region_code = ? AND category_type = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "MagazineRepo",
        "code_value": "type MagazineRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Magazine",
        "code_value": "type Magazine struct {\n\tID           int64  `gorm:\"column:id\" json:\"id\"`\n\tRegionCode   string `gorm:\"column:region_code\" json:\"region_code\"`\n\tCategoryType int    `gorm:\"column:category_type\" json:\"category_type\"`\n\tTitle        string `gorm:\"column:title\" json:\"title\"`\n\tPublishDate  int64  `gorm:\"column:publish_date\" json:\"publish_date\"`\n}"
      },
      {
        "code_key": "MagazineTableName",
        "code_value": "const MagazineTableName = \"game_magazines\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (m *Magazine) TableName() string {\n\treturn MagazineTableName\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "hints",
        "code_value": "git.woa.com/gorm/hints"
      },
      {
        "code_key": "icontext",
        "code_value": "git.woa.com/context/icontext"
      },
      {
        "code_key": "defaultRegion",
        "code_value": "var defaultRegion = \"CN\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "FilterByAttribute",
    "orm_code": "func (repo *MagazineRepo) FilterByAttribute(ctx context.Context, regionCode string, categoryType int) ([]*model.Magazine, error) {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tvar results []*model.Magazine\n\n\tif err := repo.db.Clauses(selectClause).Table(model.MagazineTableName).\n\t\tWhere(\"region_code = ? AND category_type = ?\", regionCode, categoryType).\n\t\tFind(&results).Error; err != nil {\n\t\t\treturn nil, err\n\t}\n\n\tif len(results) == 0 {\n\t\treturn nil, gorm.ErrRecordNotFound\n\t}\n\n\treturn results, nil\n}",
    "caller": "func HandlePremiumSkills() ([]Result, error) {\n\tpremiumSkill := Skill{\n\t\tPermissionType: 3,\n\t\tContractNumber: \"CON12345\"\n\t}\n\t\n\tresults, err := premiumSkill.FilterByAttribute()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to filter premium skills: %v\", err)\n\t}\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "PermissionType=3 with ContractNumber",
            "sql": "SELECT id, contract_number, access_level, is_premium, status FROM guild_memberships WHERE status = 1 AND is_premium = true AND contract_number = 'CON12345';"
          },
          {
            "scenario": "PermissionType=1 without ContractNumber",
            "sql": "SELECT id, contract_number, access_level, is_premium, status FROM guild_memberships WHERE status = 1 AND access_level = 'basic';"
          },
          {
            "scenario": "PermissionType=2 with ContractNumber",
            "sql": "SELECT id, contract_number, access_level, is_premium, status FROM guild_memberships WHERE status = 1 AND access_level = 'advanced' AND contract_number = ?;"
          },
          {
            "scenario": "No PermissionType with ContractNumber",
            "sql": "SELECT id, contract_number, access_level, is_premium, status FROM guild_memberships WHERE status = 1 AND contract_number = ?;"
          },
          {
            "scenario": "No PermissionType and no ContractNumber",
            "sql": "SELECT id, contract_number, access_level, is_premium, status FROM guild_memberships WHERE status = 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "MagazineRepo",
        "code_value": "type MagazineRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Magazine",
        "code_value": "type Magazine struct {\n\tID           int64  `gorm:\"column:id\" json:\"id\"`\n\tRegionCode   string `gorm:\"column:region_code\" json:\"region_code\"`\n\tCategoryType int    `gorm:\"column:category_type\" json:\"category_type\"`\n\tTitle        string `gorm:\"column:title\" json:\"title\"`\n\tPublishDate  int64  `gorm:\"column:publish_date\" json:\"publish_date\"`\n}"
      },
      {
        "code_key": "MagazineTableName",
        "code_value": "const MagazineTableName = \"game_magazines\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (m *Magazine) TableName() string {\n\treturn MagazineTableName\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "hints",
        "code_value": "git.woa.com/gorm/hints"
      },
      {
        "code_key": "icontext",
        "code_value": "git.woa.com/context/icontext"
      },
      {
        "code_key": "defaultRegion",
        "code_value": "var defaultRegion = \"CN\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "FilterByAttribute",
    "orm_code": "func (repo *MagazineRepo) FilterByAttribute(ctx context.Context, regionCode string, categoryType int) ([]*model.Magazine, error) {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tvar results []*model.Magazine\n\n\tif err := repo.db.Clauses(selectClause).Table(model.MagazineTableName).\n\t\tWhere(\"region_code = ? AND category_type = ?\", regionCode, categoryType).\n\t\tFind(&results).Error; err != nil {\n\t\t\treturn nil, err\n\t}\n\n\tif len(results) == 0 {\n\t\treturn nil, gorm.ErrRecordNotFound\n\t}\n\n\treturn results, nil\n}",
    "caller": "func HandleBasicAccess(memberID string) ([]Result, error) {\n\tbasicSkill := Skill{\n\t\tPermissionType: 1,\n\t\tContractNumber: memberID\n\t}\n\t\n\tmemberData, err := basicSkill.FilterByAttribute()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"basic access query failed: %v\", err)\n\t}\n\treturn memberData, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "PermissionType=1 with ContractNumber",
            "sql": "SELECT id, contract_number, access_level, is_premium, status FROM guild_memberships WHERE status = 1 AND access_level = 'basic' AND contract_number = ?;"
          },
          {
            "scenario": "PermissionType=2 with ContractNumber",
            "sql": "SELECT id, contract_number, access_level, is_premium, status FROM guild_memberships WHERE status = 1 AND access_level = 'advanced' AND contract_number = ?;"
          },
          {
            "scenario": "PermissionType=3 with ContractNumber",
            "sql": "SELECT id, contract_number, access_level, is_premium, status FROM guild_memberships WHERE status = 1 AND is_premium = true AND contract_number = ?;"
          },
          {
            "scenario": "PermissionType=1 without ContractNumber",
            "sql": "SELECT id, contract_number, access_level, is_premium, status FROM guild_memberships WHERE status = 1 AND access_level = 'basic';"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "MagazineRepo",
        "code_value": "type MagazineRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Magazine",
        "code_value": "type Magazine struct {\n\tID           int64  `gorm:\"column:id\" json:\"id\"`\n\tRegionCode   string `gorm:\"column:region_code\" json:\"region_code\"`\n\tCategoryType int    `gorm:\"column:category_type\" json:\"category_type\"`\n\tTitle        string `gorm:\"column:title\" json:\"title\"`\n\tPublishDate  int64  `gorm:\"column:publish_date\" json:\"publish_date\"`\n}"
      },
      {
        "code_key": "MagazineTableName",
        "code_value": "const MagazineTableName = \"game_magazines\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (m *Magazine) TableName() string {\n\treturn MagazineTableName\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "hints",
        "code_value": "git.woa.com/gorm/hints"
      },
      {
        "code_key": "icontext",
        "code_value": "git.woa.com/context/icontext"
      },
      {
        "code_key": "defaultRegion",
        "code_value": "var defaultRegion = \"CN\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "FilterByAttribute",
    "orm_code": "func (repo *MagazineRepo) FilterByAttribute(ctx context.Context, regionCode string, categoryType int) ([]*model.Magazine, error) {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tvar results []*model.Magazine\n\n\tif err := repo.db.Clauses(selectClause).Table(model.MagazineTableName).\n\t\tWhere(\"region_code = ? AND category_type = ?\", regionCode, categoryType).\n\t\tFind(&results).Error; err != nil {\n\t\t\treturn nil, err\n\t}\n\n\tif len(results) == 0 {\n\t\treturn nil, gorm.ErrRecordNotFound\n\t}\n\n\treturn results, nil\n}",
    "caller": "func HandleContractValidation(contractNum string) (bool, error) {\n\tvalidator := Skill{ContractNumber: contractNum}\n\t\n\tentries, err := validator.FilterByAttribute()\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"validation error: %v\", err)\n\t}\n\treturn len(entries) > 0, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "仅按ContractNumber查询",
            "sql": "SELECT id, contract_number, access_level, is_premium, status FROM guild_memberships WHERE status = 1 AND contract_number = ?;"
          },
          {
            "scenario": "按ContractNumber和PermissionType=1查询",
            "sql": "SELECT id, contract_number, access_level, is_premium, status FROM guild_memberships WHERE status = 1 AND contract_number = ? AND access_level = 'basic';"
          },
          {
            "scenario": "按ContractNumber和PermissionType=2查询",
            "sql": "SELECT id, contract_number, access_level, is_premium, status FROM guild_memberships WHERE status = 1 AND contract_number = ? AND access_level = 'advanced';"
          },
          {
            "scenario": "按ContractNumber和PermissionType=3查询",
            "sql": "SELECT id, contract_number, access_level, is_premium, status FROM guild_memberships WHERE status = 1 AND contract_number = ? AND is_premium = true;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "MagazineRepo",
        "code_value": "type MagazineRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Magazine",
        "code_value": "type Magazine struct {\n\tID           int64  `gorm:\"column:id\" json:\"id\"`\n\tRegionCode   string `gorm:\"column:region_code\" json:\"region_code\"`\n\tCategoryType int    `gorm:\"column:category_type\" json:\"category_type\"`\n\tTitle        string `gorm:\"column:title\" json:\"title\"`\n\tPublishDate  int64  `gorm:\"column:publish_date\" json:\"publish_date\"`\n}"
      },
      {
        "code_key": "MagazineTableName",
        "code_value": "const MagazineTableName = \"game_magazines\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (m *Magazine) TableName() string {\n\treturn MagazineTableName\n}"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "InsertKey",
        "code_value": "const InsertKey = \"INSERT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "hints",
        "code_value": "git.woa.com/gorm/hints"
      },
      {
        "code_key": "icontext",
        "code_value": "git.woa.com/context/icontext"
      },
      {
        "code_key": "defaultRegion",
        "code_value": "var defaultRegion = \"CN\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "UpdateAchievementStatus",
    "orm_code": "func (repo *AchievementRepo) UpdateAchievementStatus(ctx context.Context, achievement *model.Achievement) error {\n\tconst AchievementTableName = \"comment_moderation\"\n\tstatusClause := utils.SetSQLComment(ctx, utils.StatusKey)\n\tcurrentAchievement := &model.Achievement{}\n\n\tif err := repo.db.Clauses(statusClause).Table(AchievementTableName).\n\t\tWhere(\"subject = ?\", achievement.Subject).\n\t\tFirst(currentAchievement).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif currentAchievement.Status != achievement.Status {\n\t\tif err := repo.db.Clauses(statusClause).Table(AchievementTableName).\n\t\t\tWhere(\"id = ?\", currentAchievement.ID).\n\t\t\tUpdate(\"status\", achievement.Status).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "查询当前记录",
            "sql": "SELECT id, subject, status FROM comment_moderation WHERE subject = ?;"
          },
          {
            "scenario": "更新记录状态（当状态不同时）",
            "sql": "UPDATE comment_moderation SET status = ? WHERE id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "AchievementRepo",
        "code_value": "type AchievementRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Achievement",
        "code_value": "type Achievement struct {\n\tID      int64  `gorm:\"column:id\" json:\"id\"`\n\tSubject string `gorm:\"column:subject\" json:\"subject\"`\n\tStatus  int    `gorm:\"column:status\" json:\"status\"`\n}"
      },
      {
        "code_key": "StatusKey",
        "code_value": "const StatusKey = \"status\""
      },
      {
        "code_key": "CommentModerationTable",
        "code_value": "const CommentModerationTable = \"comment_moderation\""
      },
      {
        "code_key": "ModelPackage",
        "code_value": "git.woa.com/IVC/ivc-achievement/pkg/model"
      },
      {
        "code_key": "AchievementStatusPending",
        "code_value": "const AchievementStatusPending = 0"
      },
      {
        "code_key": "AchievementStatusCompleted",
        "code_value": "const AchievementStatusCompleted = 1"
      },
      {
        "code_key": "AchievementStatusFailed",
        "code_value": "const AchievementStatusFailed = 2"
      },
      {
        "code_key": "DBContextKey",
        "code_value": "const DBContextKey = \"db_context\""
      },
      {
        "code_key": "TableNameMethod",
        "code_value": "func (a *Achievement) TableName() string {\n\treturn CommentModerationTable\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "UpdateAchievementStatus",
    "orm_code": "func (repo *AchievementRepo) UpdateAchievementStatus(ctx context.Context, achievement *model.Achievement) error {\n\tconst AchievementTableName = \"comment_moderation\"\n\tstatusClause := utils.SetSQLComment(ctx, utils.StatusKey)\n\tcurrentAchievement := &model.Achievement{}\n\n\tif err := repo.db.Clauses(statusClause).Table(AchievementTableName).\n\t\tWhere(\"subject = ?\", achievement.Subject).\n\t\tFirst(currentAchievement).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif currentAchievement.Status != achievement.Status {\n\t\tif err := repo.db.Clauses(statusClause).Table(AchievementTableName).\n\t\t\tWhere(\"id = ?\", currentAchievement.ID).\n\t\t\tUpdate(\"status\", achievement.Status).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
    "caller": "func HandleTournamentCompletion(ctx context.Context, tournamentID string) error {\n\tachievementRepo := &AchievementRepo{db: globalDB}\n\tachievement := &model.Achievement{\n\t\tSubject: tournamentID,\n\t\tStatus:  model.StatusCompleted,\n\t}\n\n\tif err := achievementRepo.UpdateAchievementStatus(ctx, achievement); err != nil {\n\t\tlog.Printf(\"failed to update tournament status: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Record status is not Completed (requires update)",
            "sql": "SELECT id, subject, status FROM comment_moderation WHERE subject = ? LIMIT 1;"
          },
          {
            "scenario": "Record status is not Completed (requires update) - follow-up update",
            "sql": "UPDATE comment_moderation SET status = ? WHERE id = ?;"
          },
          {
            "scenario": "Record status is already Completed (no update needed)",
            "sql": "SELECT id, subject, status FROM comment_moderation WHERE subject = ? LIMIT 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "AchievementRepo",
        "code_value": "type AchievementRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Achievement",
        "code_value": "type Achievement struct {\n\tID      int64  `gorm:\"column:id\" json:\"id\"`\n\tSubject string `gorm:\"column:subject\" json:\"subject\"`\n\tStatus  int    `gorm:\"column:status\" json:\"status\"`\n}"
      },
      {
        "code_key": "StatusKey",
        "code_value": "const StatusKey = \"status\""
      },
      {
        "code_key": "CommentModerationTable",
        "code_value": "const CommentModerationTable = \"comment_moderation\""
      },
      {
        "code_key": "ModelPackage",
        "code_value": "git.woa.com/IVC/ivc-achievement/pkg/model"
      },
      {
        "code_key": "AchievementStatusPending",
        "code_value": "const AchievementStatusPending = 0"
      },
      {
        "code_key": "AchievementStatusCompleted",
        "code_value": "const AchievementStatusCompleted = 1"
      },
      {
        "code_key": "AchievementStatusFailed",
        "code_value": "const AchievementStatusFailed = 2"
      },
      {
        "code_key": "DBContextKey",
        "code_value": "const DBContextKey = \"db_context\""
      },
      {
        "code_key": "TableNameMethod",
        "code_value": "func (a *Achievement) TableName() string {\n\treturn CommentModerationTable\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "UpdateAchievementStatus",
    "orm_code": "func (repo *AchievementRepo) UpdateAchievementStatus(ctx context.Context, achievement *model.Achievement) error {\n\tconst AchievementTableName = \"comment_moderation\"\n\tstatusClause := utils.SetSQLComment(ctx, utils.StatusKey)\n\tcurrentAchievement := &model.Achievement{}\n\n\tif err := repo.db.Clauses(statusClause).Table(AchievementTableName).\n\t\tWhere(\"subject = ?\", achievement.Subject).\n\t\tFirst(currentAchievement).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif currentAchievement.Status != achievement.Status {\n\t\tif err := repo.db.Clauses(statusClause).Table(AchievementTableName).\n\t\t\tWhere(\"id = ?\", currentAchievement.ID).\n\t\t\tUpdate(\"status\", achievement.Status).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
    "caller": "func HandleLevelProgress(ctx context.Context, userID string, newStatus int) error {\n\tlevelRepo := &AchievementRepo{db: globalDB}\n\tprogress := &model.Achievement{\n\t\tSubject: userID,\n\t\tStatus:  newStatus,\n\t}\n\n\tif err := levelRepo.UpdateAchievementStatus(ctx, progress); err != nil {\n\t\tlog.Printf(\"failed to update level status: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Query existing record",
            "sql": "SELECT comment_moderation.id, comment_moderation.subject, comment_moderation.status FROM comment_moderation WHERE comment_moderation.subject = ? LIMIT 1;"
          },
          {
            "scenario": "Update record when status differs",
            "sql": "UPDATE comment_moderation SET status = ? WHERE comment_moderation.id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "AchievementRepo",
        "code_value": "type AchievementRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Achievement",
        "code_value": "type Achievement struct {\n\tID      int64  `gorm:\"column:id\" json:\"id\"`\n\tSubject string `gorm:\"column:subject\" json:\"subject\"`\n\tStatus  int    `gorm:\"column:status\" json:\"status\"`\n}"
      },
      {
        "code_key": "StatusKey",
        "code_value": "const StatusKey = \"status\""
      },
      {
        "code_key": "CommentModerationTable",
        "code_value": "const CommentModerationTable = \"comment_moderation\""
      },
      {
        "code_key": "ModelPackage",
        "code_value": "git.woa.com/IVC/ivc-achievement/pkg/model"
      },
      {
        "code_key": "AchievementStatusPending",
        "code_value": "const AchievementStatusPending = 0"
      },
      {
        "code_key": "AchievementStatusCompleted",
        "code_value": "const AchievementStatusCompleted = 1"
      },
      {
        "code_key": "AchievementStatusFailed",
        "code_value": "const AchievementStatusFailed = 2"
      },
      {
        "code_key": "DBContextKey",
        "code_value": "const DBContextKey = \"db_context\""
      },
      {
        "code_key": "TableNameMethod",
        "code_value": "func (a *Achievement) TableName() string {\n\treturn CommentModerationTable\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "QueryByCondition",
    "orm_code": "func (repo *NurseRepo) QueryByCondition(ctx context.Context, condition *model.NurseQueryCondition) ([]*model.Nurse, error) {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tvar nurses []*model.Nurse\n\n\tquery := repo.db.Clauses(selectClause).Table(model.NurseTableName)\n\tif condition.WardId > 0 {\n\t\tquery = query.Where(\"ward_id = ?\", condition.WardId)\n\t}\n\tif condition.ShiftType != \"\" {\n\t\tquery = query.Where(\"shift_type = ?\", condition.ShiftType)\n\t}\n\tif condition.IsCertified {\n\t\tquery = query.Where(\"certification_status = ?\", model.CertificationStatusActive)\n\t}\n\n\tif err := query.Find(&nurses).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn nurses, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Subject为monthly且TableName不为空",
            "sql": "SELECT id, created_at, table_name FROM price_history WHERE created_at >= DATE_SUB(NOW(), INTERVAL 1 MONTH) AND table_name = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "Subject为monthly且TableName为空",
            "sql": "SELECT id, created_at, table_name FROM price_history WHERE created_at >= DATE_SUB(NOW(), INTERVAL 1 MONTH) ORDER BY created_at DESC;"
          },
          {
            "scenario": "Subject为yearly且TableName不为空",
            "sql": "SELECT id, created_at, table_name FROM price_history WHERE created_at >= DATE_SUB(NOW(), INTERVAL 1 YEAR) AND table_name = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "Subject为yearly且TableName为空",
            "sql": "SELECT id, created_at, table_name FROM price_history WHERE created_at >= DATE_SUB(NOW(), INTERVAL 1 YEAR) ORDER BY created_at DESC;"
          },
          {
            "scenario": "Subject为daily且TableName不为空",
            "sql": "SELECT id, created_at, table_name FROM price_history WHERE created_at >= DATE_SUB(NOW(), INTERVAL 1 DAY) AND table_name = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "Subject为daily且TableName为空",
            "sql": "SELECT id, created_at, table_name FROM price_history WHERE created_at >= DATE_SUB(NOW(), INTERVAL 1 DAY) ORDER BY created_at DESC;"
          },
          {
            "scenario": "Subject为其他且TableName不为空",
            "sql": "SELECT id, created_at, table_name FROM price_history WHERE created_at >= ? AND table_name = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "Subject为其他且TableName为空",
            "sql": "SELECT id, created_at, table_name FROM price_history WHERE created_at >= ? ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PatientRepo",
        "code_value": "type PatientRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "PatientTableName",
        "code_value": "const PatientTableName = \"medical_patients\""
      },
      {
        "code_key": "PatientQueryCondition",
        "code_value": "type PatientQueryCondition struct {\n\tDepartmentId int\n\tBedNumber    string\n\tIsCritical   bool\n}"
      },
      {
        "code_key": "CriticalStatus",
        "code_value": "const CriticalStatus = 2"
      },
      {
        "code_key": "Patient",
        "code_value": "type Patient struct {\n\tId           int64  `gorm:\"column:id\" json:\"id\"`\n\tName         string `gorm:\"column:name\" json:\"name\"`\n\tAge          int    `gorm:\"column:age\" json:\"age\"`\n\tDepartmentId int    `gorm:\"column:department_id\" json:\"department_id\"`\n\tBedNumber    string `gorm:\"column:bed_number\" json:\"bed_number\"`\n\tStatus       int    `gorm:\"column:status\" json:\"status\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (p *Patient) TableName() string {\n\treturn PatientTableName\n}"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Expression {\n\tcommentInfo := GetCommentFromContext(ctx)\n\tcomment := fmt.Sprintf(\"app=%s,req_id=%s\", commentInfo.AppName, commentInfo.RequestID)\n\treturn clause.Comment(comment)"
      },
      {
        "code_key": "CommentInfo",
        "code_value": "type CommentInfo struct {\n\tAppName   string\n\tRequestID string\n}"
      },
      {
        "code_key": "GetCommentFromContext",
        "code_value": "func GetCommentFromContext(ctx context.Context) *CommentInfo {\n\tif v, ok := ctx.Value(commentCtxKey).(*CommentInfo); ok {\n\t\treturn v\n\t}\n\treturn &CommentInfo{}\n}"
      },
      {
        "code_key": "commentCtxKey",
        "code_value": "type contextKey string\n\nvar commentCtxKey = contextKey(\"sql_comment\")"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "QueryByCondition",
    "orm_code": "func (repo *NurseRepo) QueryByCondition(ctx context.Context, condition *model.NurseQueryCondition) ([]*model.Nurse, error) {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tvar nurses []*model.Nurse\n\n\tquery := repo.db.Clauses(selectClause).Table(model.NurseTableName)\n\tif condition.WardId > 0 {\n\t\tquery = query.Where(\"ward_id = ?\", condition.WardId)\n\t}\n\tif condition.ShiftType != \"\" {\n\t\tquery = query.Where(\"shift_type = ?\", condition.ShiftType)\n\t}\n\tif condition.IsCertified {\n\t\tquery = query.Where(\"certification_status = ?\", model.CertificationStatusActive)\n\t}\n\n\tif err := query.Find(&nurses).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn nurses, nil\n}",
    "caller": "func HandleNurseShiftAssignment(ctx context.Context, db *gorm.DB, wardID int, shiftType string) ([]*model.Nurse, error) {\n\tnurseRepo := &NurseRepo{db: db}\n\tcondition := &model.NurseQueryCondition{\n\t\tWardId:    wardID,\n\t\tShiftType: shiftType,\n\t\tIsCertified: true,\n\t}\n\n\tnurses, err := nurseRepo.QueryByCondition(ctx, condition)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to query nurses: %v\", err)\n\t}\n\n\tif len(nurses) == 0 {\n\t\treturn nil, errors.New(\"no certified nurses available for this shift\")\n\t}\n\n\treturn nurses, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "All conditions provided (ward_id, shift_type, and certification_status)",
            "sql": "SELECT * FROM nurses WHERE ward_id = ? AND shift_type = ? AND certification_status = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PatientRepo",
        "code_value": "type PatientRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "PatientTableName",
        "code_value": "const PatientTableName = \"medical_patients\""
      },
      {
        "code_key": "PatientQueryCondition",
        "code_value": "type PatientQueryCondition struct {\n\tDepartmentId int\n\tBedNumber    string\n\tIsCritical   bool\n}"
      },
      {
        "code_key": "CriticalStatus",
        "code_value": "const CriticalStatus = 2"
      },
      {
        "code_key": "Patient",
        "code_value": "type Patient struct {\n\tId           int64  `gorm:\"column:id\" json:\"id\"`\n\tName         string `gorm:\"column:name\" json:\"name\"`\n\tAge          int    `gorm:\"column:age\" json:\"age\"`\n\tDepartmentId int    `gorm:\"column:department_id\" json:\"department_id\"`\n\tBedNumber    string `gorm:\"column:bed_number\" json:\"bed_number\"`\n\tStatus       int    `gorm:\"column:status\" json:\"status\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (p *Patient) TableName() string {\n\treturn PatientTableName\n}"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Expression {\n\tcommentInfo := GetCommentFromContext(ctx)\n\tcomment := fmt.Sprintf(\"app=%s,req_id=%s\", commentInfo.AppName, commentInfo.RequestID)\n\treturn clause.Comment(comment)"
      },
      {
        "code_key": "CommentInfo",
        "code_value": "type CommentInfo struct {\n\tAppName   string\n\tRequestID string\n}"
      },
      {
        "code_key": "GetCommentFromContext",
        "code_value": "func GetCommentFromContext(ctx context.Context) *CommentInfo {\n\tif v, ok := ctx.Value(commentCtxKey).(*CommentInfo); ok {\n\t\treturn v\n\t}\n\treturn &CommentInfo{}\n}"
      },
      {
        "code_key": "commentCtxKey",
        "code_value": "type contextKey string\n\nvar commentCtxKey = contextKey(\"sql_comment\")"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "QueryByCondition",
    "orm_code": "func (repo *NurseRepo) QueryByCondition(ctx context.Context, condition *model.NurseQueryCondition) ([]*model.Nurse, error) {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tvar nurses []*model.Nurse\n\n\tquery := repo.db.Clauses(selectClause).Table(model.NurseTableName)\n\tif condition.WardId > 0 {\n\t\tquery = query.Where(\"ward_id = ?\", condition.WardId)\n\t}\n\tif condition.ShiftType != \"\" {\n\t\tquery = query.Where(\"shift_type = ?\", condition.ShiftType)\n\t}\n\tif condition.IsCertified {\n\t\tquery = query.Where(\"certification_status = ?\", model.CertificationStatusActive)\n\t}\n\n\tif err := query.Find(&nurses).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn nurses, nil\n}",
    "caller": "func HandleWardStaffingReport(ctx context.Context, db *gorm.DB) (map[int][]*model.Nurse, error) {\n\tnurseRepo := &NurseRepo{db: db}\n\tresult := make(map[int][]*model.Nurse)\n\n\tfor wardID := 1; wardID <= 5; wardID++ {\n\t\tcondition := &model.NurseQueryCondition{WardId: wardID}\n\t\tnurses, err := nurseRepo.QueryByCondition(ctx, condition)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to get nurses for ward %d: %v\", wardID, err)\n\t\t}\n\t\tresult[wardID] = nurses\n\t}\n\n\treturn result, nil\n}",
    "sql_statement_list": [
      {
        "type": "LACK_INFORMATION",
        "variants": [
          {
            "scenario": "缺少model.NurseTableName的具体定义，根据Nurse结构体推测表名为nurse",
            "sql": "/* app=?,req_id=? */ SELECT * FROM nurse WHERE ward_id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "OTHER"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PatientRepo",
        "code_value": "type PatientRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "PatientTableName",
        "code_value": "const PatientTableName = \"medical_patients\""
      },
      {
        "code_key": "PatientQueryCondition",
        "code_value": "type PatientQueryCondition struct {\n\tDepartmentId int\n\tBedNumber    string\n\tIsCritical   bool\n}"
      },
      {
        "code_key": "CriticalStatus",
        "code_value": "const CriticalStatus = 2"
      },
      {
        "code_key": "Patient",
        "code_value": "type Patient struct {\n\tId           int64  `gorm:\"column:id\" json:\"id\"`\n\tName         string `gorm:\"column:name\" json:\"name\"`\n\tAge          int    `gorm:\"column:age\" json:\"age\"`\n\tDepartmentId int    `gorm:\"column:department_id\" json:\"department_id\"`\n\tBedNumber    string `gorm:\"column:bed_number\" json:\"bed_number\"`\n\tStatus       int    `gorm:\"column:status\" json:\"status\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (p *Patient) TableName() string {\n\treturn PatientTableName\n}"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Expression {\n\tcommentInfo := GetCommentFromContext(ctx)\n\tcomment := fmt.Sprintf(\"app=%s,req_id=%s\", commentInfo.AppName, commentInfo.RequestID)\n\treturn clause.Comment(comment)"
      },
      {
        "code_key": "CommentInfo",
        "code_value": "type CommentInfo struct {\n\tAppName   string\n\tRequestID string\n}"
      },
      {
        "code_key": "GetCommentFromContext",
        "code_value": "func GetCommentFromContext(ctx context.Context) *CommentInfo {\n\tif v, ok := ctx.Value(commentCtxKey).(*CommentInfo); ok {\n\t\treturn v\n\t}\n\treturn &CommentInfo{}\n}"
      },
      {
        "code_key": "commentCtxKey",
        "code_value": "type contextKey string\n\nvar commentCtxKey = contextKey(\"sql_comment\")"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "QueryByCondition",
    "orm_code": "func (repo *NurseRepo) QueryByCondition(ctx context.Context, condition *model.NurseQueryCondition) ([]*model.Nurse, error) {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tvar nurses []*model.Nurse\n\n\tquery := repo.db.Clauses(selectClause).Table(model.NurseTableName)\n\tif condition.WardId > 0 {\n\t\tquery = query.Where(\"ward_id = ?\", condition.WardId)\n\t}\n\tif condition.ShiftType != \"\" {\n\t\tquery = query.Where(\"shift_type = ?\", condition.ShiftType)\n\t}\n\tif condition.IsCertified {\n\t\tquery = query.Where(\"certification_status = ?\", model.CertificationStatusActive)\n\t}\n\n\tif err := query.Find(&nurses).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn nurses, nil\n}",
    "caller": "func HandlePriceHistory() ([]Timeline, error) {\n\tpriceResource := &Resource{\n\t\tSubject:   \"monthly\",\n\t\tTableName: \"stock_prices\",\n\t}\n\t\n\trecords, err := priceResource.QueryByCondition()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to query price history: %v\", err)\n\t}\n\treturn records, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Subject is 'monthly' and TableName is not empty",
            "sql": "SELECT id, created_at, table_name FROM price_history WHERE created_at >= DATE_SUB(NOW(), INTERVAL 1 MONTH) AND table_name = 'stock_prices' ORDER BY created_at DESC;"
          },
          {
            "scenario": "Subject is 'yearly' and TableName is not empty",
            "sql": "SELECT id, created_at, table_name FROM price_history WHERE created_at >= DATE_SUB(NOW(), INTERVAL 1 YEAR) AND table_name = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "Subject is 'daily' and TableName is not empty",
            "sql": "SELECT id, created_at, table_name FROM price_history WHERE created_at >= DATE_SUB(NOW(), INTERVAL 1 DAY) AND table_name = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "Subject is default and Content is not empty",
            "sql": "SELECT id, created_at, table_name FROM price_history WHERE created_at >= ? AND table_name = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "Subject is 'monthly' and TableName is empty",
            "sql": "SELECT id, created_at, table_name FROM price_history WHERE created_at >= DATE_SUB(NOW(), INTERVAL 1 MONTH) ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PatientRepo",
        "code_value": "type PatientRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "PatientTableName",
        "code_value": "const PatientTableName = \"medical_patients\""
      },
      {
        "code_key": "PatientQueryCondition",
        "code_value": "type PatientQueryCondition struct {\n\tDepartmentId int\n\tBedNumber    string\n\tIsCritical   bool\n}"
      },
      {
        "code_key": "CriticalStatus",
        "code_value": "const CriticalStatus = 2"
      },
      {
        "code_key": "Patient",
        "code_value": "type Patient struct {\n\tId           int64  `gorm:\"column:id\" json:\"id\"`\n\tName         string `gorm:\"column:name\" json:\"name\"`\n\tAge          int    `gorm:\"column:age\" json:\"age\"`\n\tDepartmentId int    `gorm:\"column:department_id\" json:\"department_id\"`\n\tBedNumber    string `gorm:\"column:bed_number\" json:\"bed_number\"`\n\tStatus       int    `gorm:\"column:status\" json:\"status\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (p *Patient) TableName() string {\n\treturn PatientTableName\n}"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Expression {\n\tcommentInfo := GetCommentFromContext(ctx)\n\tcomment := fmt.Sprintf(\"app=%s,req_id=%s\", commentInfo.AppName, commentInfo.RequestID)\n\treturn clause.Comment(comment)"
      },
      {
        "code_key": "CommentInfo",
        "code_value": "type CommentInfo struct {\n\tAppName   string\n\tRequestID string\n}"
      },
      {
        "code_key": "GetCommentFromContext",
        "code_value": "func GetCommentFromContext(ctx context.Context) *CommentInfo {\n\tif v, ok := ctx.Value(commentCtxKey).(*CommentInfo); ok {\n\t\treturn v\n\t}\n\treturn &CommentInfo{}\n}"
      },
      {
        "code_key": "commentCtxKey",
        "code_value": "type contextKey string\n\nvar commentCtxKey = contextKey(\"sql_comment\")"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "QueryByCondition",
    "orm_code": "func (repo *NurseRepo) QueryByCondition(ctx context.Context, condition *model.NurseQueryCondition) ([]*model.Nurse, error) {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tvar nurses []*model.Nurse\n\n\tquery := repo.db.Clauses(selectClause).Table(model.NurseTableName)\n\tif condition.WardId > 0 {\n\t\tquery = query.Where(\"ward_id = ?\", condition.WardId)\n\t}\n\tif condition.ShiftType != \"\" {\n\t\tquery = query.Where(\"shift_type = ?\", condition.ShiftType)\n\t}\n\tif condition.IsCertified {\n\t\tquery = query.Where(\"certification_status = ?\", model.CertificationStatusActive)\n\t}\n\n\tif err := query.Find(&nurses).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn nurses, nil\n}",
    "caller": "func ProcessRecentInventory() error {\n\tinvResource := &Resource{\n\t\tSubject:   \"daily\",\n\t\tTableName: \"inventory_log\",\n\t}\n\t\n\titems, err := invResource.QueryByCondition()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"inventory query failed: %w\", err)\n\t}\n\t\n\t// Process inventory items here\n\tfmt.Printf(\"Found %d recent inventory changes\\n\", len(items))\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "daily interval with table_name condition",
            "sql": "SELECT id, created_at, table_name FROM price_history WHERE created_at >= DATE_SUB(NOW(), INTERVAL 1 DAY) AND table_name = 'inventory_log' ORDER BY created_at DESC;"
          },
          {
            "scenario": "monthly interval with table_name condition",
            "sql": "SELECT id, created_at, table_name FROM price_history WHERE created_at >= DATE_SUB(NOW(), INTERVAL 1 MONTH) AND table_name = 'inventory_log' ORDER BY created_at DESC;"
          },
          {
            "scenario": "yearly interval with table_name condition",
            "sql": "SELECT id, created_at, table_name FROM price_history WHERE created_at >= DATE_SUB(NOW(), INTERVAL 1 YEAR) AND table_name = 'inventory_log' ORDER BY created_at DESC;"
          },
          {
            "scenario": "custom date with table_name condition",
            "sql": "SELECT id, created_at, table_name FROM price_history WHERE created_at >= ? AND table_name = 'inventory_log' ORDER BY created_at DESC;"
          },
          {
            "scenario": "daily interval without table_name condition",
            "sql": "SELECT id, created_at, table_name FROM price_history WHERE created_at >= DATE_SUB(NOW(), INTERVAL 1 DAY) ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PatientRepo",
        "code_value": "type PatientRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "PatientTableName",
        "code_value": "const PatientTableName = \"medical_patients\""
      },
      {
        "code_key": "PatientQueryCondition",
        "code_value": "type PatientQueryCondition struct {\n\tDepartmentId int\n\tBedNumber    string\n\tIsCritical   bool\n}"
      },
      {
        "code_key": "CriticalStatus",
        "code_value": "const CriticalStatus = 2"
      },
      {
        "code_key": "Patient",
        "code_value": "type Patient struct {\n\tId           int64  `gorm:\"column:id\" json:\"id\"`\n\tName         string `gorm:\"column:name\" json:\"name\"`\n\tAge          int    `gorm:\"column:age\" json:\"age\"`\n\tDepartmentId int    `gorm:\"column:department_id\" json:\"department_id\"`\n\tBedNumber    string `gorm:\"column:bed_number\" json:\"bed_number\"`\n\tStatus       int    `gorm:\"column:status\" json:\"status\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (p *Patient) TableName() string {\n\treturn PatientTableName\n}"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Expression {\n\tcommentInfo := GetCommentFromContext(ctx)\n\tcomment := fmt.Sprintf(\"app=%s,req_id=%s\", commentInfo.AppName, commentInfo.RequestID)\n\treturn clause.Comment(comment)"
      },
      {
        "code_key": "CommentInfo",
        "code_value": "type CommentInfo struct {\n\tAppName   string\n\tRequestID string\n}"
      },
      {
        "code_key": "GetCommentFromContext",
        "code_value": "func GetCommentFromContext(ctx context.Context) *CommentInfo {\n\tif v, ok := ctx.Value(commentCtxKey).(*CommentInfo); ok {\n\t\treturn v\n\t}\n\treturn &CommentInfo{}\n}"
      },
      {
        "code_key": "commentCtxKey",
        "code_value": "type contextKey string\n\nvar commentCtxKey = contextKey(\"sql_comment\")"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "QueryByCondition",
    "orm_code": "func (repo *NurseRepo) QueryByCondition(ctx context.Context, condition *model.NurseQueryCondition) ([]*model.Nurse, error) {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tvar nurses []*model.Nurse\n\n\tquery := repo.db.Clauses(selectClause).Table(model.NurseTableName)\n\tif condition.WardId > 0 {\n\t\tquery = query.Where(\"ward_id = ?\", condition.WardId)\n\t}\n\tif condition.ShiftType != \"\" {\n\t\tquery = query.Where(\"shift_type = ?\", condition.ShiftType)\n\t}\n\tif condition.IsCertified {\n\t\tquery = query.Where(\"certification_status = ?\", model.CertificationStatusActive)\n\t}\n\n\tif err := query.Find(&nurses).Error; err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn nurses, nil\n}",
    "caller": "func GetAnnualSalesData() ([]Timeline, error) {\n\tsalesFilter := &Resource{\n\t\tSubject: \"yearly\",\n\t}\n\t\n\tresults, err := salesFilter.QueryByCondition()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"sales data retrieval error: %s\", err.Error())\n\t}\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "yearly interval without table_name condition",
            "sql": "SELECT price_history.id, price_history.created_at, price_history.table_name FROM price_history WHERE created_at >= DATE_SUB(NOW(), INTERVAL 1 YEAR) ORDER BY created_at DESC;"
          },
          {
            "scenario": "monthly interval with table_name condition",
            "sql": "SELECT price_history.id, price_history.created_at, price_history.table_name FROM price_history WHERE created_at >= DATE_SUB(NOW(), INTERVAL 1 MONTH) AND table_name = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "daily interval with table_name condition",
            "sql": "SELECT price_history.id, price_history.created_at, price_history.table_name FROM price_history WHERE created_at >= DATE_SUB(NOW(), INTERVAL 1 DAY) AND table_name = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "default interval with custom date and table_name condition",
            "sql": "SELECT price_history.id, price_history.created_at, price_history.table_name FROM price_history WHERE created_at >= ? AND table_name = ? ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PatientRepo",
        "code_value": "type PatientRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "PatientTableName",
        "code_value": "const PatientTableName = \"medical_patients\""
      },
      {
        "code_key": "PatientQueryCondition",
        "code_value": "type PatientQueryCondition struct {\n\tDepartmentId int\n\tBedNumber    string\n\tIsCritical   bool\n}"
      },
      {
        "code_key": "CriticalStatus",
        "code_value": "const CriticalStatus = 2"
      },
      {
        "code_key": "Patient",
        "code_value": "type Patient struct {\n\tId           int64  `gorm:\"column:id\" json:\"id\"`\n\tName         string `gorm:\"column:name\" json:\"name\"`\n\tAge          int    `gorm:\"column:age\" json:\"age\"`\n\tDepartmentId int    `gorm:\"column:department_id\" json:\"department_id\"`\n\tBedNumber    string `gorm:\"column:bed_number\" json:\"bed_number\"`\n\tStatus       int    `gorm:\"column:status\" json:\"status\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (p *Patient) TableName() string {\n\treturn PatientTableName\n}"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Expression {\n\tcommentInfo := GetCommentFromContext(ctx)\n\tcomment := fmt.Sprintf(\"app=%s,req_id=%s\", commentInfo.AppName, commentInfo.RequestID)\n\treturn clause.Comment(comment)"
      },
      {
        "code_key": "CommentInfo",
        "code_value": "type CommentInfo struct {\n\tAppName   string\n\tRequestID string\n}"
      },
      {
        "code_key": "GetCommentFromContext",
        "code_value": "func GetCommentFromContext(ctx context.Context) *CommentInfo {\n\tif v, ok := ctx.Value(commentCtxKey).(*CommentInfo); ok {\n\t\treturn v\n\t}\n\treturn &CommentInfo{}\n}"
      },
      {
        "code_key": "commentCtxKey",
        "code_value": "type contextKey string\n\nvar commentCtxKey = contextKey(\"sql_comment\")"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "RestoreDeletedClinic",
    "orm_code": "func (repo *ClinicRepo) RestoreDeletedClinic(ctx context.Context, licenseKey string) error {\n\trestoreClause := utils.SetSQLComment(ctx, utils.RestoreKey)\n\tclinic := &model.Clinic{}\n\n\tif err := repo.db.Clauses(restoreClause).Table(model.ClinicTableName).\n\t\tWhere(\"license_key = ? AND is_deleted = true\", licenseKey).\n\t\tFirst(&clinic).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif clinic.ID == 0 {\n\t\treturn errors.New(\"no deletable clinic found\")\n\t}\n\n\tif err := repo.db.Clauses(restoreClause).Table(model.ClinicTableName).\n\t\tWhere(\"license_key = ?\", licenseKey).\n\t\tUpdate(\"is_deleted\", false).Error; err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "LACK_INFORMATION",
        "variants": [
          {
            "scenario": "缺少model.ClinicTableName常量的定义，根据Clinic结构体推测表名为clinic",
            "sql": "SELECT * FROM clinic WHERE license_key = ? AND is_deleted = true LIMIT 1;"
          },
          {
            "scenario": "缺少model.ClinicTableName常量的定义，根据Clinic结构体推测表名为clinic",
            "sql": "UPDATE clinic SET is_deleted = false WHERE license_key = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "ClinicRepo",
        "code_value": "type ClinicRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "RestoreKey",
        "code_value": "const RestoreKey = \"restore\""
      },
      {
        "code_key": "SecurityClearanceTableName",
        "code_value": "const SecurityClearanceTableName = \"security_clearances\""
      },
      {
        "code_key": "Clearance",
        "code_value": "type Clearance struct {\n\tID        uint   `gorm:\"primaryKey\"`\n\tClearanceLevel string `gorm:\"uniqueIndex\"`\n\tIsActive bool\n\tCreatedAt time.Time\n\tUpdatedAt time.Time\n}"
      },
      {
        "code_key": "hints",
        "code_value": "git.woa.com/common/gorm/hints"
      },
      {
        "code_key": "icontext",
        "code_value": "git.woa.com/common/context"
      },
      {
        "code_key": "uuid",
        "code_value": "github.com/google/uuid"
      },
      {
        "code_key": "ProductName",
        "code_value": "const ProductName = \"SecurityService\""
      },
      {
        "code_key": "SQLCommentInfo",
        "code_value": "type SQLCommentInfo struct {\n\tReqId   string\n\tAppId   string\n\tOwnerUin string\n\tSubUin  string\n\tAction  string\n}"
      },
      {
        "code_key": "GetSQLCommentFromContext",
        "code_value": "func GetSQLCommentFromContext(ctx context.Context) *SQLCommentInfo {\n\tif v := ctx.Value(commentCtxKey); v != nil {\n\t\treturn v.(*SQLCommentInfo)\n\t}\n\treturn &SQLCommentInfo{}\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "RestoreDeletedClinic",
    "orm_code": "func (repo *ClinicRepo) RestoreDeletedClinic(ctx context.Context, licenseKey string) error {\n\trestoreClause := utils.SetSQLComment(ctx, utils.RestoreKey)\n\tclinic := &model.Clinic{}\n\n\tif err := repo.db.Clauses(restoreClause).Table(model.ClinicTableName).\n\t\tWhere(\"license_key = ? AND is_deleted = true\", licenseKey).\n\t\tFirst(&clinic).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif clinic.ID == 0 {\n\t\treturn errors.New(\"no deletable clinic found\")\n\t}\n\n\tif err := repo.db.Clauses(restoreClause).Table(model.ClinicTableName).\n\t\tWhere(\"license_key = ?\", licenseKey).\n\t\tUpdate(\"is_deleted\", false).Error; err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
    "caller": "func HandleClinicRecovery(ctx context.Context, medicalLicense string, logger *zap.Logger) error {\n\tclinicStore := &ClinicRepo{db: globalDatabase}\n\tif err := clinicStore.RestoreDeletedClinic(ctx, medicalLicense); err != nil {\n\t\tlogger.Error(\"Failed to restore clinic\", zap.String(\"license\", medicalLicense), zap.Error(err))\n\t\treturn fmt.Errorf(\"clinic recovery failed: %w\", err)\n\t}\n\tlogger.Info(\"Successfully restored clinic\", zap.String(\"license\", medicalLicense))\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "LACK_INFORMATION",
        "variants": [
          {
            "scenario": "缺少model.ClinicTableName的具体定义，根据常见命名规范推测表名为'clinics'",
            "sql": "SELECT * FROM clinics WHERE license_key = ? AND is_deleted = true LIMIT 1;"
          }
        ]
      },
      {
        "type": "LACK_INFORMATION",
        "variants": [
          {
            "scenario": "缺少model.ClinicTableName的具体定义，根据常见命名规范推测表名为'clinics'",
            "sql": "UPDATE clinics SET is_deleted = false WHERE license_key = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "SELECT",
      "UPDATE"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ClinicRepo",
        "code_value": "type ClinicRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "RestoreKey",
        "code_value": "const RestoreKey = \"restore\""
      },
      {
        "code_key": "SecurityClearanceTableName",
        "code_value": "const SecurityClearanceTableName = \"security_clearances\""
      },
      {
        "code_key": "Clearance",
        "code_value": "type Clearance struct {\n\tID        uint   `gorm:\"primaryKey\"`\n\tClearanceLevel string `gorm:\"uniqueIndex\"`\n\tIsActive bool\n\tCreatedAt time.Time\n\tUpdatedAt time.Time\n}"
      },
      {
        "code_key": "hints",
        "code_value": "git.woa.com/common/gorm/hints"
      },
      {
        "code_key": "icontext",
        "code_value": "git.woa.com/common/context"
      },
      {
        "code_key": "uuid",
        "code_value": "github.com/google/uuid"
      },
      {
        "code_key": "ProductName",
        "code_value": "const ProductName = \"SecurityService\""
      },
      {
        "code_key": "SQLCommentInfo",
        "code_value": "type SQLCommentInfo struct {\n\tReqId   string\n\tAppId   string\n\tOwnerUin string\n\tSubUin  string\n\tAction  string\n}"
      },
      {
        "code_key": "GetSQLCommentFromContext",
        "code_value": "func GetSQLCommentFromContext(ctx context.Context) *SQLCommentInfo {\n\tif v := ctx.Value(commentCtxKey); v != nil {\n\t\treturn v.(*SQLCommentInfo)\n\t}\n\treturn &SQLCommentInfo{}\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "RestoreDeletedClinic",
    "orm_code": "func (repo *ClinicRepo) RestoreDeletedClinic(ctx context.Context, licenseKey string) error {\n\trestoreClause := utils.SetSQLComment(ctx, utils.RestoreKey)\n\tclinic := &model.Clinic{}\n\n\tif err := repo.db.Clauses(restoreClause).Table(model.ClinicTableName).\n\t\tWhere(\"license_key = ? AND is_deleted = true\", licenseKey).\n\t\tFirst(&clinic).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif clinic.ID == 0 {\n\t\treturn errors.New(\"no deletable clinic found\")\n\t}\n\n\tif err := repo.db.Clauses(restoreClause).Table(model.ClinicTableName).\n\t\tWhere(\"license_key = ?\", licenseKey).\n\t\tUpdate(\"is_deleted\", false).Error; err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
    "caller": "func ProcessHospitalReactivation(credential string) error {\n\tctx := context.WithValue(context.Background(), utils.RestoreKey, \"system-auto-recovery\")\n\trepository := ClinicRepo{db: initializeDBConnection()}\n\tif err := repository.RestoreDeletedClinic(ctx, credential); err != nil {\n\t\tmetrics.Increment(\"clinic_restore_failure\")\n\t\treturn fmt.Errorf(\"reactivation failed for %s: %v\", credential, err)\n\t}\n\tmetrics.Increment(\"clinic_restore_success\")\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "LACK_INFORMATION",
        "variants": [
          {
            "scenario": "缺少model.ClinicTableName定义，无法确定表名",
            "sql": "SELECT * FROM clinic WHERE license_key = ? AND is_deleted = true LIMIT 1;"
          }
        ]
      },
      {
        "type": "LACK_INFORMATION",
        "variants": [
          {
            "scenario": "缺少model.ClinicTableName定义，无法确定表名",
            "sql": "UPDATE clinic SET is_deleted = false WHERE license_key = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "SELECT",
      "UPDATE"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ClinicRepo",
        "code_value": "type ClinicRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "RestoreKey",
        "code_value": "const RestoreKey = \"restore\""
      },
      {
        "code_key": "SecurityClearanceTableName",
        "code_value": "const SecurityClearanceTableName = \"security_clearances\""
      },
      {
        "code_key": "Clearance",
        "code_value": "type Clearance struct {\n\tID        uint   `gorm:\"primaryKey\"`\n\tClearanceLevel string `gorm:\"uniqueIndex\"`\n\tIsActive bool\n\tCreatedAt time.Time\n\tUpdatedAt time.Time\n}"
      },
      {
        "code_key": "hints",
        "code_value": "git.woa.com/common/gorm/hints"
      },
      {
        "code_key": "icontext",
        "code_value": "git.woa.com/common/context"
      },
      {
        "code_key": "uuid",
        "code_value": "github.com/google/uuid"
      },
      {
        "code_key": "ProductName",
        "code_value": "const ProductName = \"SecurityService\""
      },
      {
        "code_key": "SQLCommentInfo",
        "code_value": "type SQLCommentInfo struct {\n\tReqId   string\n\tAppId   string\n\tOwnerUin string\n\tSubUin  string\n\tAction  string\n}"
      },
      {
        "code_key": "GetSQLCommentFromContext",
        "code_value": "func GetSQLCommentFromContext(ctx context.Context) *SQLCommentInfo {\n\tif v := ctx.Value(commentCtxKey); v != nil {\n\t\treturn v.(*SQLCommentInfo)\n\t}\n\treturn &SQLCommentInfo{}\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "VerifySignature",
    "orm_code": "func (repo *CertificateRepo) VerifySignature(ctx context.Context, doc *model.TaxDocument) (bool, error) {\n\tsignClause := utils.SetSQLComment(ctx, \"verify_sign\")\n\tconst TaxDocTable = \"tax_documents\"\n\n\tvar existingDoc model.TaxDocument\n\terr := repo.db.Clauses(signClause).Table(TaxDocTable).\n\t\tWhere(\"document_id = ? AND location_code = ?\", doc.DocumentId, doc.LocationCode).\n\t\tFirst(&existingDoc).Error\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif existingDoc.SignatureHash != doc.SignatureHash {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "authMethod = RSA",
            "sql": "SELECT COUNT(*) > 0 FROM fund_transfers WHERE method_name = 'RSA' AND points >= 100;"
          },
          {
            "scenario": "authMethod = ECDSA",
            "sql": "SELECT COUNT(*) > 0 FROM fund_transfers WHERE method_name = 'ECDSA' AND end_date > NOW();"
          },
          {
            "scenario": "authMethod = HMAC",
            "sql": "SELECT COUNT(*) > 0 FROM fund_transfers WHERE method_name = 'HMAC' AND status = 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "CertificateRepo",
        "code_value": "type CertificateRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "TaxDocument",
        "code_value": "type TaxDocument struct {\n\tDocumentId     string `gorm:\"column:document_id\" json:\"document_id\"`\n\tLocationCode   string `gorm:\"column:location_code\" json:\"location_code\"`\n\tSignatureHash  string `gorm:\"column:signature_hash\" json:\"signature_hash\"`\n\tIssuerId       int64  `gorm:\"column:issuer_id\" json:\"issuer_id\"`\n\tExpirationDate int64  `gorm:\"column:expiration_date\" json:\"expiration_date\"`\n}"
      },
      {
        "code_key": "TaxDocTable",
        "code_value": "const TaxDocTable = \"tax_documents\""
      },
      {
        "code_key": "SignatureStatus",
        "code_value": "type SignatureStatus struct {\n\tIsValid      bool   `json:\"is_valid\"`\n\tErrorMessage string `json:\"error_message,omitempty\"`\n}"
      },
      {
        "code_key": "TaxDocumentFilter",
        "code_value": "type TaxDocumentFilter struct {\n\tDocumentId   string `json:\"document_id\"`\n\tLocationCode string `json:\"location_code\"`\n}"
      },
      {
        "code_key": "DocumentVerificationResult",
        "code_value": "type DocumentVerificationResult struct {\n\tIsSignatureValid bool `json:\"is_signature_valid\"`\n\tIsDocumentActive bool `json:\"is_document_active\"`\n}"
      },
      {
        "code_key": "MaxRetryCount",
        "code_value": "const MaxRetryCount = 3"
      },
      {
        "code_key": "DefaultTimeout",
        "code_value": "const DefaultTimeout = 30 * time.Second"
      },
      {
        "code_key": "VerificationCache",
        "code_value": "var VerificationCache = sync.Map{}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "VerifySignature",
    "orm_code": "func (repo *CertificateRepo) VerifySignature(ctx context.Context, doc *model.TaxDocument) (bool, error) {\n\tsignClause := utils.SetSQLComment(ctx, \"verify_sign\")\n\tconst TaxDocTable = \"tax_documents\"\n\n\tvar existingDoc model.TaxDocument\n\terr := repo.db.Clauses(signClause).Table(TaxDocTable).\n\t\tWhere(\"document_id = ? AND location_code = ?\", doc.DocumentId, doc.LocationCode).\n\t\tFirst(&existingDoc).Error\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif existingDoc.SignatureHash != doc.SignatureHash {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "caller": "func HandleTaxDocVerification(ctx context.Context, docID string, locCode string, sigHash string, logger *zap.Logger) (bool, error) {\n\trepo, err := data.NewCertificateRepo()\n\tif err != nil {\n\t\tlogger.Error(\"failed to initialize certificate repo\", zap.Error(err))\n\t\treturn false, err\n\t}\n\n\ttaxDoc := &model.TaxDocument{\n\t\tDocumentId:     docID,\n\t\tLocationCode:   locCode,\n\t\tSignatureHash:  sigHash,\n\t}\n\n\tisValid, err := repo.VerifySignature(ctx, taxDoc)\n\tif err != nil {\n\t\tlogger.Error(\"signature verification failed\", zap.Error(err))\n\t\treturn false, err\n\t}\n\n\treturn isValid, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "根据文档ID和位置代码查询税务文档",
            "sql": "SELECT document_id, location_code, signature_hash, issuer_id, expiration_date FROM tax_documents WHERE document_id = ? AND location_code = ? LIMIT 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "CertificateRepo",
        "code_value": "type CertificateRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "TaxDocument",
        "code_value": "type TaxDocument struct {\n\tDocumentId     string `gorm:\"column:document_id\" json:\"document_id\"`\n\tLocationCode   string `gorm:\"column:location_code\" json:\"location_code\"`\n\tSignatureHash  string `gorm:\"column:signature_hash\" json:\"signature_hash\"`\n\tIssuerId       int64  `gorm:\"column:issuer_id\" json:\"issuer_id\"`\n\tExpirationDate int64  `gorm:\"column:expiration_date\" json:\"expiration_date\"`\n}"
      },
      {
        "code_key": "TaxDocTable",
        "code_value": "const TaxDocTable = \"tax_documents\""
      },
      {
        "code_key": "SignatureStatus",
        "code_value": "type SignatureStatus struct {\n\tIsValid      bool   `json:\"is_valid\"`\n\tErrorMessage string `json:\"error_message,omitempty\"`\n}"
      },
      {
        "code_key": "TaxDocumentFilter",
        "code_value": "type TaxDocumentFilter struct {\n\tDocumentId   string `json:\"document_id\"`\n\tLocationCode string `json:\"location_code\"`\n}"
      },
      {
        "code_key": "DocumentVerificationResult",
        "code_value": "type DocumentVerificationResult struct {\n\tIsSignatureValid bool `json:\"is_signature_valid\"`\n\tIsDocumentActive bool `json:\"is_document_active\"`\n}"
      },
      {
        "code_key": "MaxRetryCount",
        "code_value": "const MaxRetryCount = 3"
      },
      {
        "code_key": "DefaultTimeout",
        "code_value": "const DefaultTimeout = 30 * time.Second"
      },
      {
        "code_key": "VerificationCache",
        "code_value": "var VerificationCache = sync.Map{}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "VerifySignature",
    "orm_code": "func (repo *CertificateRepo) VerifySignature(ctx context.Context, doc *model.TaxDocument) (bool, error) {\n\tsignClause := utils.SetSQLComment(ctx, \"verify_sign\")\n\tconst TaxDocTable = \"tax_documents\"\n\n\tvar existingDoc model.TaxDocument\n\terr := repo.db.Clauses(signClause).Table(TaxDocTable).\n\t\tWhere(\"document_id = ? AND location_code = ?\", doc.DocumentId, doc.LocationCode).\n\t\tFirst(&existingDoc).Error\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif existingDoc.SignatureHash != doc.SignatureHash {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "caller": "func ProcessInvoiceSignature(ctx context.Context, invoice *model.Invoice, dbConfig *config.DB) (bool, error) {\n\trepo := &data.CertificateRepo{db: dbConfig.GetDB()}\n\n\tdoc := &model.TaxDocument{\n\t\tDocumentId:     invoice.DocRef,\n\t\tLocationCode:   invoice.RegionCode,\n\t\tSignatureHash:  invoice.DigitalSig,\n\t}\n\n\tverified, err := repo.VerifySignature(ctx, doc)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"signature verification error: %w\", err)\n\t}\n\n\tif !verified {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Select tax document by document_id and location_code",
            "sql": "SELECT document_id, location_code, signature_hash, issuer_id, expiration_date FROM tax_documents WHERE document_id = ? AND location_code = ? LIMIT 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "CertificateRepo",
        "code_value": "type CertificateRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "TaxDocument",
        "code_value": "type TaxDocument struct {\n\tDocumentId     string `gorm:\"column:document_id\" json:\"document_id\"`\n\tLocationCode   string `gorm:\"column:location_code\" json:\"location_code\"`\n\tSignatureHash  string `gorm:\"column:signature_hash\" json:\"signature_hash\"`\n\tIssuerId       int64  `gorm:\"column:issuer_id\" json:\"issuer_id\"`\n\tExpirationDate int64  `gorm:\"column:expiration_date\" json:\"expiration_date\"`\n}"
      },
      {
        "code_key": "TaxDocTable",
        "code_value": "const TaxDocTable = \"tax_documents\""
      },
      {
        "code_key": "SignatureStatus",
        "code_value": "type SignatureStatus struct {\n\tIsValid      bool   `json:\"is_valid\"`\n\tErrorMessage string `json:\"error_message,omitempty\"`\n}"
      },
      {
        "code_key": "TaxDocumentFilter",
        "code_value": "type TaxDocumentFilter struct {\n\tDocumentId   string `json:\"document_id\"`\n\tLocationCode string `json:\"location_code\"`\n}"
      },
      {
        "code_key": "DocumentVerificationResult",
        "code_value": "type DocumentVerificationResult struct {\n\tIsSignatureValid bool `json:\"is_signature_valid\"`\n\tIsDocumentActive bool `json:\"is_document_active\"`\n}"
      },
      {
        "code_key": "MaxRetryCount",
        "code_value": "const MaxRetryCount = 3"
      },
      {
        "code_key": "DefaultTimeout",
        "code_value": "const DefaultTimeout = 30 * time.Second"
      },
      {
        "code_key": "VerificationCache",
        "code_value": "var VerificationCache = sync.Map{}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "VerifySignature",
    "orm_code": "func (repo *CertificateRepo) VerifySignature(ctx context.Context, doc *model.TaxDocument) (bool, error) {\n\tsignClause := utils.SetSQLComment(ctx, \"verify_sign\")\n\tconst TaxDocTable = \"tax_documents\"\n\n\tvar existingDoc model.TaxDocument\n\terr := repo.db.Clauses(signClause).Table(TaxDocTable).\n\t\tWhere(\"document_id = ? AND location_code = ?\", doc.DocumentId, doc.LocationCode).\n\t\tFirst(&existingDoc).Error\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif existingDoc.SignatureHash != doc.SignatureHash {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "caller": "func HandleTransactionAuth() {\n\tvar authHub Hub\n\tauthMethod := \"RSA\"\n\tisValid, err := authHub.VerifySignature(authMethod)\n\tif err != nil {\n\t\tlog.Printf(\"Authentication failed: %v\", err)\n\t\treturn\n\t}\n\tif isValid {\n\t\tlog.Println(\"Transaction authorized successfully\")\n\t} else {\n\t\tlog.Println(\"Transaction authorization failed\")\n\t}\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "RSA认证方法",
            "sql": "SELECT COUNT(*) > 0 FROM fund_transfers WHERE method_name = 'RSA' AND points >= 100;"
          },
          {
            "scenario": "ECDSA认证方法",
            "sql": "SELECT COUNT(*) > 0 FROM fund_transfers WHERE method_name = 'ECDSA' AND end_date > NOW();"
          },
          {
            "scenario": "HMAC认证方法",
            "sql": "SELECT COUNT(*) > 0 FROM fund_transfers WHERE method_name = 'HMAC' AND status = 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "CertificateRepo",
        "code_value": "type CertificateRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "TaxDocument",
        "code_value": "type TaxDocument struct {\n\tDocumentId     string `gorm:\"column:document_id\" json:\"document_id\"`\n\tLocationCode   string `gorm:\"column:location_code\" json:\"location_code\"`\n\tSignatureHash  string `gorm:\"column:signature_hash\" json:\"signature_hash\"`\n\tIssuerId       int64  `gorm:\"column:issuer_id\" json:\"issuer_id\"`\n\tExpirationDate int64  `gorm:\"column:expiration_date\" json:\"expiration_date\"`\n}"
      },
      {
        "code_key": "TaxDocTable",
        "code_value": "const TaxDocTable = \"tax_documents\""
      },
      {
        "code_key": "SignatureStatus",
        "code_value": "type SignatureStatus struct {\n\tIsValid      bool   `json:\"is_valid\"`\n\tErrorMessage string `json:\"error_message,omitempty\"`\n}"
      },
      {
        "code_key": "TaxDocumentFilter",
        "code_value": "type TaxDocumentFilter struct {\n\tDocumentId   string `json:\"document_id\"`\n\tLocationCode string `json:\"location_code\"`\n}"
      },
      {
        "code_key": "DocumentVerificationResult",
        "code_value": "type DocumentVerificationResult struct {\n\tIsSignatureValid bool `json:\"is_signature_valid\"`\n\tIsDocumentActive bool `json:\"is_document_active\"`\n}"
      },
      {
        "code_key": "MaxRetryCount",
        "code_value": "const MaxRetryCount = 3"
      },
      {
        "code_key": "DefaultTimeout",
        "code_value": "const DefaultTimeout = 30 * time.Second"
      },
      {
        "code_key": "VerificationCache",
        "code_value": "var VerificationCache = sync.Map{}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "VerifySignature",
    "orm_code": "func (repo *CertificateRepo) VerifySignature(ctx context.Context, doc *model.TaxDocument) (bool, error) {\n\tsignClause := utils.SetSQLComment(ctx, \"verify_sign\")\n\tconst TaxDocTable = \"tax_documents\"\n\n\tvar existingDoc model.TaxDocument\n\terr := repo.db.Clauses(signClause).Table(TaxDocTable).\n\t\tWhere(\"document_id = ? AND location_code = ?\", doc.DocumentId, doc.LocationCode).\n\t\tFirst(&existingDoc).Error\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif existingDoc.SignatureHash != doc.SignatureHash {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "caller": "func ProcessCryptoPayment(cryptoType string) error {\n\tpaymentVerifier := Hub{}\n\tapproved, verifyErr := paymentVerifier.VerifySignature(cryptoType)\n\tif verifyErr != nil {\n\t\treturn fmt.Errorf(\"payment verification error: %w\", verifyErr)\n\t}\n\tif !approved {\n\t\treturn errors.New(\"crypto payment not authorized\")\n\t}\n\t// Proceed with payment processing\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "RSA认证",
            "sql": "SELECT COUNT(*) > 0 FROM fund_transfers WHERE method_name = 'RSA' AND points >= 100;"
          },
          {
            "scenario": "ECDSA认证",
            "sql": "SELECT COUNT(*) > 0 FROM fund_transfers WHERE method_name = 'ECDSA' AND end_date > NOW();"
          },
          {
            "scenario": "HMAC认证",
            "sql": "SELECT COUNT(*) > 0 FROM fund_transfers WHERE method_name = 'HMAC' AND status = 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "CertificateRepo",
        "code_value": "type CertificateRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "TaxDocument",
        "code_value": "type TaxDocument struct {\n\tDocumentId     string `gorm:\"column:document_id\" json:\"document_id\"`\n\tLocationCode   string `gorm:\"column:location_code\" json:\"location_code\"`\n\tSignatureHash  string `gorm:\"column:signature_hash\" json:\"signature_hash\"`\n\tIssuerId       int64  `gorm:\"column:issuer_id\" json:\"issuer_id\"`\n\tExpirationDate int64  `gorm:\"column:expiration_date\" json:\"expiration_date\"`\n}"
      },
      {
        "code_key": "TaxDocTable",
        "code_value": "const TaxDocTable = \"tax_documents\""
      },
      {
        "code_key": "SignatureStatus",
        "code_value": "type SignatureStatus struct {\n\tIsValid      bool   `json:\"is_valid\"`\n\tErrorMessage string `json:\"error_message,omitempty\"`\n}"
      },
      {
        "code_key": "TaxDocumentFilter",
        "code_value": "type TaxDocumentFilter struct {\n\tDocumentId   string `json:\"document_id\"`\n\tLocationCode string `json:\"location_code\"`\n}"
      },
      {
        "code_key": "DocumentVerificationResult",
        "code_value": "type DocumentVerificationResult struct {\n\tIsSignatureValid bool `json:\"is_signature_valid\"`\n\tIsDocumentActive bool `json:\"is_document_active\"`\n}"
      },
      {
        "code_key": "MaxRetryCount",
        "code_value": "const MaxRetryCount = 3"
      },
      {
        "code_key": "DefaultTimeout",
        "code_value": "const DefaultTimeout = 30 * time.Second"
      },
      {
        "code_key": "VerificationCache",
        "code_value": "var VerificationCache = sync.Map{}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "VerifySignature",
    "orm_code": "func (repo *CertificateRepo) VerifySignature(ctx context.Context, doc *model.TaxDocument) (bool, error) {\n\tsignClause := utils.SetSQLComment(ctx, \"verify_sign\")\n\tconst TaxDocTable = \"tax_documents\"\n\n\tvar existingDoc model.TaxDocument\n\terr := repo.db.Clauses(signClause).Table(TaxDocTable).\n\t\tWhere(\"document_id = ? AND location_code = ?\", doc.DocumentId, doc.LocationCode).\n\t\tFirst(&existingDoc).Error\n\n\tif err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif existingDoc.SignatureHash != doc.SignatureHash {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "caller": "func CheckAPISecurity() bool {\n\tsecurityCheck := Hub{}\n\tsigningMethod := \"ECDSA\"\n\tvalid, _ := securityCheck.VerifySignature(signingMethod)\n\treturn valid\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "authMethod = 'RSA'",
            "sql": "SELECT COUNT(*) > 0 FROM fund_transfers WHERE method_name = 'RSA' AND points >= 100;"
          },
          {
            "scenario": "authMethod = 'ECDSA'",
            "sql": "SELECT COUNT(*) > 0 FROM fund_transfers WHERE method_name = 'ECDSA' AND end_date > NOW();"
          },
          {
            "scenario": "authMethod = 'HMAC'",
            "sql": "SELECT COUNT(*) > 0 FROM fund_transfers WHERE method_name = 'HMAC' AND status = 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "CertificateRepo",
        "code_value": "type CertificateRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "TaxDocument",
        "code_value": "type TaxDocument struct {\n\tDocumentId     string `gorm:\"column:document_id\" json:\"document_id\"`\n\tLocationCode   string `gorm:\"column:location_code\" json:\"location_code\"`\n\tSignatureHash  string `gorm:\"column:signature_hash\" json:\"signature_hash\"`\n\tIssuerId       int64  `gorm:\"column:issuer_id\" json:\"issuer_id\"`\n\tExpirationDate int64  `gorm:\"column:expiration_date\" json:\"expiration_date\"`\n}"
      },
      {
        "code_key": "TaxDocTable",
        "code_value": "const TaxDocTable = \"tax_documents\""
      },
      {
        "code_key": "SignatureStatus",
        "code_value": "type SignatureStatus struct {\n\tIsValid      bool   `json:\"is_valid\"`\n\tErrorMessage string `json:\"error_message,omitempty\"`\n}"
      },
      {
        "code_key": "TaxDocumentFilter",
        "code_value": "type TaxDocumentFilter struct {\n\tDocumentId   string `json:\"document_id\"`\n\tLocationCode string `json:\"location_code\"`\n}"
      },
      {
        "code_key": "DocumentVerificationResult",
        "code_value": "type DocumentVerificationResult struct {\n\tIsSignatureValid bool `json:\"is_signature_valid\"`\n\tIsDocumentActive bool `json:\"is_document_active\"`\n}"
      },
      {
        "code_key": "MaxRetryCount",
        "code_value": "const MaxRetryCount = 3"
      },
      {
        "code_key": "DefaultTimeout",
        "code_value": "const DefaultTimeout = 30 * time.Second"
      },
      {
        "code_key": "VerificationCache",
        "code_value": "var VerificationCache = sync.Map{}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CheckIntegrity",
    "orm_code": "func (repo *DeliveryRepo) CheckIntegrity(ctx context.Context, deliveryID string) (bool, error) {\n\tverifyClause := utils.SetSQLComment(ctx, utils.VerifyKey)\n\tdelivery := &Delivery{}\n\n\tif err := repo.db.Clauses(verifyClause).Table(model.DeliveryTableName).\n\t\tWhere(\"delivery_id = ?\", deliveryID).\n\t\tFirst(delivery).Error; err != nil {\n\t\treturn false, err\n\t}\n\n\tif delivery.Quantity <= 0 || delivery.City == \"\" {\n\t\treturn false, nil\n\t}\n\n\tif delivery.RefreshKey != model.DefaultRefreshKey {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "CurrentStatus=1 (GuildActive) 且 CaseNumber为空",
            "sql": "SELECT id, access_level, is_active, case_reference FROM group_memberships WHERE is_active = 1 AND access_level = 'admin';"
          },
          {
            "scenario": "CurrentStatus=2 (GuildPending) 且 CaseNumber为空",
            "sql": "SELECT id, access_level, is_active, case_reference FROM group_memberships WHERE is_active = 1 AND access_level = 'moderator';"
          },
          {
            "scenario": "CurrentStatus=3 (GuildInactive) 且 CaseNumber为空",
            "sql": "SELECT id, access_level, is_active, case_reference FROM group_memberships WHERE is_active = 1 AND access_level = 'member';"
          },
          {
            "scenario": "CurrentStatus=1 (GuildActive) 且 CaseNumber不为空",
            "sql": "SELECT id, access_level, is_active, case_reference FROM group_memberships WHERE is_active = 1 AND access_level = 'admin' AND case_reference = ?;"
          },
          {
            "scenario": "CurrentStatus=2 (GuildPending) 且 CaseNumber不为空",
            "sql": "SELECT id, access_level, is_active, case_reference FROM group_memberships WHERE is_active = 1 AND access_level = 'moderator' AND case_reference = ?;"
          },
          {
            "scenario": "CurrentStatus=3 (GuildInactive) 且 CaseNumber不为空",
            "sql": "SELECT id, access_level, is_active, case_reference FROM group_memberships WHERE is_active = 1 AND access_level = 'member' AND case_reference = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "DeliveryRepo",
        "code_value": "type DeliveryRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Delivery",
        "code_value": "type Delivery struct {\n\tDeliveryID   string `gorm:\"column:delivery_id\" json:\"delivery_id\"`\n\tQuantity     int    `gorm:\"column:quantity\" json:\"quantity\"`\n\tCity         string `gorm:\"column:city\" json:\"city\"`\n\tRefreshKey   string `gorm:\"column:refresh_key\" json:\"refresh_key\"`\n\tCreatedAt    int64  `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt    int64  `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "DeliveryTableName",
        "code_value": "const DeliveryTableName = \"delivery_orders\""
      },
      {
        "code_key": "DefaultRefreshKey",
        "code_value": "const DefaultRefreshKey = \"DEFAULT_KEY_123\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (d *Delivery) TableName() string {\n\treturn DeliveryTableName\n}"
      },
      {
        "code_key": "VerifyKey",
        "code_value": "const VerifyKey = \"VERIFY\""
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/pkg/utils"
      },
      {
        "code_key": "hints",
        "code_value": "gorm.io/hints"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CheckIntegrity",
    "orm_code": "func (repo *DeliveryRepo) CheckIntegrity(ctx context.Context, deliveryID string) (bool, error) {\n\tverifyClause := utils.SetSQLComment(ctx, utils.VerifyKey)\n\tdelivery := &Delivery{}\n\n\tif err := repo.db.Clauses(verifyClause).Table(model.DeliveryTableName).\n\t\tWhere(\"delivery_id = ?\", deliveryID).\n\t\tFirst(delivery).Error; err != nil {\n\t\treturn false, err\n\t}\n\n\tif delivery.Quantity <= 0 || delivery.City == \"\" {\n\t\treturn false, nil\n\t}\n\n\tif delivery.RefreshKey != model.DefaultRefreshKey {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "caller": "func VerifyDeliveryStatus(deliveryIdentifier string) error {\n\tdeliveryRepo := &DeliveryRepo{db: GetDatabaseConnection()}\n\tisValid, err := deliveryRepo.CheckIntegrity(context.Background(), deliveryIdentifier)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to verify delivery: %v\", err)\n\t}\n\tif !isValid {\n\t\treturn errors.New(\"delivery integrity check failed\")\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Query delivery order by ID with SQL comment",
            "sql": "SELECT delivery_id, quantity, city, refresh_key, created_at, updated_at FROM delivery_orders WHERE delivery_id = ? LIMIT 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "DeliveryRepo",
        "code_value": "type DeliveryRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Delivery",
        "code_value": "type Delivery struct {\n\tDeliveryID   string `gorm:\"column:delivery_id\" json:\"delivery_id\"`\n\tQuantity     int    `gorm:\"column:quantity\" json:\"quantity\"`\n\tCity         string `gorm:\"column:city\" json:\"city\"`\n\tRefreshKey   string `gorm:\"column:refresh_key\" json:\"refresh_key\"`\n\tCreatedAt    int64  `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt    int64  `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "DeliveryTableName",
        "code_value": "const DeliveryTableName = \"delivery_orders\""
      },
      {
        "code_key": "DefaultRefreshKey",
        "code_value": "const DefaultRefreshKey = \"DEFAULT_KEY_123\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (d *Delivery) TableName() string {\n\treturn DeliveryTableName\n}"
      },
      {
        "code_key": "VerifyKey",
        "code_value": "const VerifyKey = \"VERIFY\""
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/pkg/utils"
      },
      {
        "code_key": "hints",
        "code_value": "gorm.io/hints"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CheckIntegrity",
    "orm_code": "func (repo *DeliveryRepo) CheckIntegrity(ctx context.Context, deliveryID string) (bool, error) {\n\tverifyClause := utils.SetSQLComment(ctx, utils.VerifyKey)\n\tdelivery := &Delivery{}\n\n\tif err := repo.db.Clauses(verifyClause).Table(model.DeliveryTableName).\n\t\tWhere(\"delivery_id = ?\", deliveryID).\n\t\tFirst(delivery).Error; err != nil {\n\t\treturn false, err\n\t}\n\n\tif delivery.Quantity <= 0 || delivery.City == \"\" {\n\t\treturn false, nil\n\t}\n\n\tif delivery.RefreshKey != model.DefaultRefreshKey {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "caller": "func ProcessDeliveryBatch(deliveryIDs []string) ([]bool, error) {\n\trepo := NewDeliveryRepository()\n\tresults := make([]bool, len(deliveryIDs))\n\tfor idx, id := range deliveryIDs {\n\t\tstatus, err := repo.CheckIntegrity(context.TODO(), id)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"error checking delivery %s: %v\", id, err)\n\t\t}\n\t\tresults[idx] = status\n\t}\n\treturn results, nil\n}",
    "sql_statement_list": [
      "SELECT * FROM delivery_orders WHERE delivery_id = ? LIMIT 1;"
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "DeliveryRepo",
        "code_value": "type DeliveryRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Delivery",
        "code_value": "type Delivery struct {\n\tDeliveryID   string `gorm:\"column:delivery_id\" json:\"delivery_id\"`\n\tQuantity     int    `gorm:\"column:quantity\" json:\"quantity\"`\n\tCity         string `gorm:\"column:city\" json:\"city\"`\n\tRefreshKey   string `gorm:\"column:refresh_key\" json:\"refresh_key\"`\n\tCreatedAt    int64  `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt    int64  `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "DeliveryTableName",
        "code_value": "const DeliveryTableName = \"delivery_orders\""
      },
      {
        "code_key": "DefaultRefreshKey",
        "code_value": "const DefaultRefreshKey = \"DEFAULT_KEY_123\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (d *Delivery) TableName() string {\n\treturn DeliveryTableName\n}"
      },
      {
        "code_key": "VerifyKey",
        "code_value": "const VerifyKey = \"VERIFY\""
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/pkg/utils"
      },
      {
        "code_key": "hints",
        "code_value": "gorm.io/hints"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CheckIntegrity",
    "orm_code": "func (repo *DeliveryRepo) CheckIntegrity(ctx context.Context, deliveryID string) (bool, error) {\n\tverifyClause := utils.SetSQLComment(ctx, utils.VerifyKey)\n\tdelivery := &Delivery{}\n\n\tif err := repo.db.Clauses(verifyClause).Table(model.DeliveryTableName).\n\t\tWhere(\"delivery_id = ?\", deliveryID).\n\t\tFirst(delivery).Error; err != nil {\n\t\treturn false, err\n\t}\n\n\tif delivery.Quantity <= 0 || delivery.City == \"\" {\n\t\treturn false, nil\n\t}\n\n\tif delivery.RefreshKey != model.DefaultRefreshKey {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "caller": "func ValidateShipmentRequest(req *ShipmentRequest) (bool, error) {\n\tdbHandler := InitializeDeliveryRepo()\n\tvalid, err := dbHandler.CheckIntegrity(req.Ctx, req.DeliveryID)\n\tif err != nil {\n\t\tlog.Printf(\"Validation error for delivery %s: %v\", req.DeliveryID, err)\n\t\treturn false, err\n\t}\n\treturn valid, nil\n}",
    "sql_statement_list": [
      "SELECT delivery_id, quantity, city, refresh_key, created_at, updated_at FROM delivery_orders WHERE delivery_id = ? LIMIT 1;"
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "DeliveryRepo",
        "code_value": "type DeliveryRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Delivery",
        "code_value": "type Delivery struct {\n\tDeliveryID   string `gorm:\"column:delivery_id\" json:\"delivery_id\"`\n\tQuantity     int    `gorm:\"column:quantity\" json:\"quantity\"`\n\tCity         string `gorm:\"column:city\" json:\"city\"`\n\tRefreshKey   string `gorm:\"column:refresh_key\" json:\"refresh_key\"`\n\tCreatedAt    int64  `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt    int64  `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "DeliveryTableName",
        "code_value": "const DeliveryTableName = \"delivery_orders\""
      },
      {
        "code_key": "DefaultRefreshKey",
        "code_value": "const DefaultRefreshKey = \"DEFAULT_KEY_123\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (d *Delivery) TableName() string {\n\treturn DeliveryTableName\n}"
      },
      {
        "code_key": "VerifyKey",
        "code_value": "const VerifyKey = \"VERIFY\""
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/pkg/utils"
      },
      {
        "code_key": "hints",
        "code_value": "gorm.io/hints"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CheckIntegrity",
    "orm_code": "func (repo *DeliveryRepo) CheckIntegrity(ctx context.Context, deliveryID string) (bool, error) {\n\tverifyClause := utils.SetSQLComment(ctx, utils.VerifyKey)\n\tdelivery := &Delivery{}\n\n\tif err := repo.db.Clauses(verifyClause).Table(model.DeliveryTableName).\n\t\tWhere(\"delivery_id = ?\", deliveryID).\n\t\tFirst(delivery).Error; err != nil {\n\t\treturn false, err\n\t}\n\n\tif delivery.Quantity <= 0 || delivery.City == \"\" {\n\t\treturn false, nil\n\t}\n\n\tif delivery.RefreshKey != model.DefaultRefreshKey {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "caller": "func ValidateGuildPermissions() error {\n\tguildObj := &Guild{\n\t\tCurrentStatus: 2,\n\t\tCaseNumber:   \"CASE-2023-456\",\n\t}\n\n\tperms, err := guildObj.CheckIntegrity()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"permission check failed: %v\", err)\n\t}\n\n\tif len(perms) == 0 {\n\t\treturn errors.New(\"no valid permissions found\")\n\t}\n\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Status=2(Moderator) + 有CaseNumber",
            "sql": "SELECT id, access_level, is_active, case_reference FROM group_memberships WHERE is_active = true AND access_level = 'moderator' AND case_reference = 'CASE-2023-456';"
          },
          {
            "scenario": "Status=1(Admin) + 有CaseNumber",
            "sql": "SELECT id, access_level, is_active, case_reference FROM group_memberships WHERE is_active = true AND access_level = 'admin' AND case_reference = ?;"
          },
          {
            "scenario": "Status=3(Member) + 无CaseNumber",
            "sql": "SELECT id, access_level, is_active, case_reference FROM group_memberships WHERE is_active = true AND access_level = 'member';"
          },
          {
            "scenario": "Status=2(Moderator) + 无CaseNumber",
            "sql": "SELECT id, access_level, is_active, case_reference FROM group_memberships WHERE is_active = true AND access_level = 'moderator';"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "DeliveryRepo",
        "code_value": "type DeliveryRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Delivery",
        "code_value": "type Delivery struct {\n\tDeliveryID   string `gorm:\"column:delivery_id\" json:\"delivery_id\"`\n\tQuantity     int    `gorm:\"column:quantity\" json:\"quantity\"`\n\tCity         string `gorm:\"column:city\" json:\"city\"`\n\tRefreshKey   string `gorm:\"column:refresh_key\" json:\"refresh_key\"`\n\tCreatedAt    int64  `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt    int64  `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "DeliveryTableName",
        "code_value": "const DeliveryTableName = \"delivery_orders\""
      },
      {
        "code_key": "DefaultRefreshKey",
        "code_value": "const DefaultRefreshKey = \"DEFAULT_KEY_123\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (d *Delivery) TableName() string {\n\treturn DeliveryTableName\n}"
      },
      {
        "code_key": "VerifyKey",
        "code_value": "const VerifyKey = \"VERIFY\""
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/pkg/utils"
      },
      {
        "code_key": "hints",
        "code_value": "gorm.io/hints"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CheckIntegrity",
    "orm_code": "func (repo *DeliveryRepo) CheckIntegrity(ctx context.Context, deliveryID string) (bool, error) {\n\tverifyClause := utils.SetSQLComment(ctx, utils.VerifyKey)\n\tdelivery := &Delivery{}\n\n\tif err := repo.db.Clauses(verifyClause).Table(model.DeliveryTableName).\n\t\tWhere(\"delivery_id = ?\", deliveryID).\n\t\tFirst(delivery).Error; err != nil {\n\t\treturn false, err\n\t}\n\n\tif delivery.Quantity <= 0 || delivery.City == \"\" {\n\t\treturn false, nil\n\t}\n\n\tif delivery.RefreshKey != model.DefaultRefreshKey {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "caller": "func ProcessMemberAccess(statusCode int, caseRef string) ([]Permission, error) {\n\tmemberGuild := &Guild{\n\t\tCurrentStatus: statusCode,\n\t\tCaseNumber:   caseRef,\n\t}\n\n\taccessList, err := memberGuild.CheckIntegrity()\n\tif err != nil {\n\t\tlog.Printf(\"Access verification error: %v\", err)\n\t\treturn nil, err\n\t}\n\n\treturn accessList, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "CurrentStatus=1 (GuildActive), CaseNumber为空",
            "sql": "SELECT id, access_level, is_active, case_reference FROM group_memberships WHERE is_active = true AND access_level = 'admin';"
          },
          {
            "scenario": "CurrentStatus=1 (GuildActive), CaseNumber不为空",
            "sql": "SELECT id, access_level, is_active, case_reference FROM group_memberships WHERE is_active = true AND access_level = 'admin' AND case_reference = 'CASE123';"
          },
          {
            "scenario": "CurrentStatus=2 (GuildPending), CaseNumber为空",
            "sql": "SELECT id, access_level, is_active, case_reference FROM group_memberships WHERE is_active = true AND access_level = 'moderator';"
          },
          {
            "scenario": "CurrentStatus=2 (GuildPending), CaseNumber不为空",
            "sql": "SELECT id, access_level, is_active, case_reference FROM group_memberships WHERE is_active = true AND access_level = 'moderator' AND case_reference = 'CASE123';"
          },
          {
            "scenario": "CurrentStatus=3 (GuildInactive), CaseNumber为空",
            "sql": "SELECT id, access_level, is_active, case_reference FROM group_memberships WHERE is_active = true AND access_level = 'member';"
          },
          {
            "scenario": "CurrentStatus=3 (GuildInactive), CaseNumber不为空",
            "sql": "SELECT id, access_level, is_active, case_reference FROM group_memberships WHERE is_active = true AND access_level = 'member' AND case_reference = 'CASE123';"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "DeliveryRepo",
        "code_value": "type DeliveryRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Delivery",
        "code_value": "type Delivery struct {\n\tDeliveryID   string `gorm:\"column:delivery_id\" json:\"delivery_id\"`\n\tQuantity     int    `gorm:\"column:quantity\" json:\"quantity\"`\n\tCity         string `gorm:\"column:city\" json:\"city\"`\n\tRefreshKey   string `gorm:\"column:refresh_key\" json:\"refresh_key\"`\n\tCreatedAt    int64  `gorm:\"column:created_at\" json:\"created_at\"`\n\tUpdatedAt    int64  `gorm:\"column:updated_at\" json:\"updated_at\"`\n}"
      },
      {
        "code_key": "DeliveryTableName",
        "code_value": "const DeliveryTableName = \"delivery_orders\""
      },
      {
        "code_key": "DefaultRefreshKey",
        "code_value": "const DefaultRefreshKey = \"DEFAULT_KEY_123\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (d *Delivery) TableName() string {\n\treturn DeliveryTableName\n}"
      },
      {
        "code_key": "VerifyKey",
        "code_value": "const VerifyKey = \"VERIFY\""
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/pkg/utils"
      },
      {
        "code_key": "hints",
        "code_value": "gorm.io/hints"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "UpdateQuizStatistics",
    "orm_code": "func (repo *QuizRepo) UpdateQuizStatistics(ctx context.Context, quiz *model.QuizStat) error {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\toldStat := &model.QuizStat{}\n\n\tif err := repo.db.Clauses(selectClause).Table(model.QuizStatTableName).\n\t\tWhere(\"quiz_id = ?\", quiz.QuizId).\n\t\tFirst(oldStat).Error; err != nil {\n\t\t\treturn err\n\t}\n\n\tif oldStat.RegistrationTime != quiz.RegistrationTime || oldStat.Volume != quiz.Volume {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.QuizStatTableName).\n\t\t\tWhere(\"id = ?\", oldStat.Id).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"registration_time\": quiz.RegistrationTime,\n\t\t\t\t\"volume\":           quiz.Volume,\n\t\t\t}).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Select existing quiz statistics",
            "sql": "SELECT /* app=?,req=? */ id, quiz_id, registration_time, volume FROM t_quiz_statistics WHERE quiz_id = ? ORDER BY id LIMIT 1;"
          }
        ]
      },
      "Select existing quiz statistics\",\n        \"sql\": \"SELECT /* app=?,req=? */ id, quiz_id, registration_time, volume FROM t_quiz_statistics WHERE quiz_id = ? ORDER BY id LIMIT 1;",
      "Update statistics when registration_time or volume changes\",\n        \"sql\": \"UPDATE /* app=?,req=? */ t_quiz_statistics SET registration_time = ?, volume = ? WHERE id = ?;"
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "SELECT",
      "UPDATE"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "QuizStat",
        "code_value": "type QuizStat struct {\n\tId               int64  `gorm:\"column:id\" json:\"id\"`\n\tQuizId           string `gorm:\"column:quiz_id\" json:\"quiz_id\"`\n\tRegistrationTime int64  `gorm:\"column:registration_time\" json:\"registration_time\"`\n\tVolume           int    `gorm:\"column:volume\" json:\"volume\"`\n}"
      },
      {
        "code_key": "QuizStatTableName",
        "code_value": "const QuizStatTableName = \"t_quiz_statistics\""
      },
      {
        "code_key": "QuizRepo",
        "code_value": "type QuizRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "selectClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SelectKey)"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/quiz-platform/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clauser.Clause {\n\tcommentInfo := contextx.GetCommentInfo(ctx)\n\tif commentInfo == nil {\n\t\tcommentInfo = &contextx.CommentInfo{RequestID: uuid.NewString()}\n\t}\n\tcomment := fmt.Sprintf(\"app=%s,req=%s\", commentInfo.AppName, commentInfo.RequestID)\n\treturn clauser.Comment(clause, comment)\n}"
      },
      {
        "code_key": "contextx",
        "code_value": "git.woa.com/IVC/common/contextx"
      },
      {
        "code_key": "clauser",
        "code_value": "git.woa.com/IVC/gorm/clauser"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "UpdateQuizStatistics",
    "orm_code": "func (repo *QuizRepo) UpdateQuizStatistics(ctx context.Context, quiz *model.QuizStat) error {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\toldStat := &model.QuizStat{}\n\n\tif err := repo.db.Clauses(selectClause).Table(model.QuizStatTableName).\n\t\tWhere(\"quiz_id = ?\", quiz.QuizId).\n\t\tFirst(oldStat).Error; err != nil {\n\t\t\treturn err\n\t}\n\n\tif oldStat.RegistrationTime != quiz.RegistrationTime || oldStat.Volume != quiz.Volume {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.QuizStatTableName).\n\t\t\tWhere(\"id = ?\", oldStat.Id).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"registration_time\": quiz.RegistrationTime,\n\t\t\t\t\"volume\":           quiz.Volume,\n\t\t\t}).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func HandleQuizStatusUpdate(ctx context.Context, quizID string, newRegTime int64, newVolume int) error {\n\tquizRepo, err := NewQuizRepo()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to initialize quiz repo: %v\", err)\n\t}\n\n\tquizStat := &model.QuizStat{\n\t\tQuizId:           quizID,\n\t\tRegistrationTime: newRegTime,\n\t\tVolume:           newVolume,\n\t}\n\n\tif err := quizRepo.UpdateQuizStatistics(ctx, quizStat); err != nil {\n\t\treturn fmt.Errorf(\"failed to update quiz statistics: %v\", err)\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "首次更新（需要执行两条SQL）",
            "sql": "SELECT id, quiz_id, registration_time, volume FROM t_quiz_statistics WHERE quiz_id = 'quiz123' LIMIT 1;"
          },
          {
            "scenario": "首次更新（需要执行两条SQL）",
            "sql": "UPDATE t_quiz_statistics SET registration_time = 1630000000, volume = 100 WHERE id = 1;"
          },
          {
            "scenario": "无变化（只执行一条SQL）",
            "sql": "SELECT id, quiz_id, registration_time, volume FROM t_quiz_statistics WHERE quiz_id = 'quiz123' LIMIT 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "QuizStat",
        "code_value": "type QuizStat struct {\n\tId               int64  `gorm:\"column:id\" json:\"id\"`\n\tQuizId           string `gorm:\"column:quiz_id\" json:\"quiz_id\"`\n\tRegistrationTime int64  `gorm:\"column:registration_time\" json:\"registration_time\"`\n\tVolume           int    `gorm:\"column:volume\" json:\"volume\"`\n}"
      },
      {
        "code_key": "QuizStatTableName",
        "code_value": "const QuizStatTableName = \"t_quiz_statistics\""
      },
      {
        "code_key": "QuizRepo",
        "code_value": "type QuizRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "selectClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SelectKey)"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/quiz-platform/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clauser.Clause {\n\tcommentInfo := contextx.GetCommentInfo(ctx)\n\tif commentInfo == nil {\n\t\tcommentInfo = &contextx.CommentInfo{RequestID: uuid.NewString()}\n\t}\n\tcomment := fmt.Sprintf(\"app=%s,req=%s\", commentInfo.AppName, commentInfo.RequestID)\n\treturn clauser.Comment(clause, comment)\n}"
      },
      {
        "code_key": "contextx",
        "code_value": "git.woa.com/IVC/common/contextx"
      },
      {
        "code_key": "clauser",
        "code_value": "git.woa.com/IVC/gorm/clauser"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "UpdateQuizStatistics",
    "orm_code": "func (repo *QuizRepo) UpdateQuizStatistics(ctx context.Context, quiz *model.QuizStat) error {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\toldStat := &model.QuizStat{}\n\n\tif err := repo.db.Clauses(selectClause).Table(model.QuizStatTableName).\n\t\tWhere(\"quiz_id = ?\", quiz.QuizId).\n\t\tFirst(oldStat).Error; err != nil {\n\t\t\treturn err\n\t}\n\n\tif oldStat.RegistrationTime != quiz.RegistrationTime || oldStat.Volume != quiz.Volume {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.QuizStatTableName).\n\t\t\tWhere(\"id = ?\", oldStat.Id).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"registration_time\": quiz.RegistrationTime,\n\t\t\t\t\"volume\":           quiz.Volume,\n\t\t\t}).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func ProcessTrainingResult(ctx context.Context, trainingData *model.TrainingSession) error {\n\trepo, err := data.NewQuizRepository()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tquizStat := &model.QuizStat{\n\t\tQuizId:           trainingData.QuizID,\n\t\tRegistrationTime: trainingData.CompletionTime,\n\t\tVolume:           trainingData.QuestionsAttempted,\n\t}\n\n\tif err := repo.UpdateQuizStatistics(ctx, quizStat); err != nil {\n\t\tlog.Printf(\"Failed to process training result: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "SELECT existing quiz statistics record",
            "sql": "SELECT id, quiz_id, registration_time, volume FROM t_quiz_statistics WHERE quiz_id = 'quiz123' LIMIT 1;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "UPDATE quiz statistics when registration_time or volume changes",
            "sql": "UPDATE t_quiz_statistics SET registration_time = 1672531200, volume = 10 WHERE id = 42;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "QuizStat",
        "code_value": "type QuizStat struct {\n\tId               int64  `gorm:\"column:id\" json:\"id\"`\n\tQuizId           string `gorm:\"column:quiz_id\" json:\"quiz_id\"`\n\tRegistrationTime int64  `gorm:\"column:registration_time\" json:\"registration_time\"`\n\tVolume           int    `gorm:\"column:volume\" json:\"volume\"`\n}"
      },
      {
        "code_key": "QuizStatTableName",
        "code_value": "const QuizStatTableName = \"t_quiz_statistics\""
      },
      {
        "code_key": "QuizRepo",
        "code_value": "type QuizRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "selectClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SelectKey)"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/quiz-platform/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clauser.Clause {\n\tcommentInfo := contextx.GetCommentInfo(ctx)\n\tif commentInfo == nil {\n\t\tcommentInfo = &contextx.CommentInfo{RequestID: uuid.NewString()}\n\t}\n\tcomment := fmt.Sprintf(\"app=%s,req=%s\", commentInfo.AppName, commentInfo.RequestID)\n\treturn clauser.Comment(clause, comment)\n}"
      },
      {
        "code_key": "contextx",
        "code_value": "git.woa.com/IVC/common/contextx"
      },
      {
        "code_key": "clauser",
        "code_value": "git.woa.com/IVC/gorm/clauser"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "TrackInventoryMovement",
    "orm_code": "func (repo *InventoryRepo) TrackInventoryMovement(ctx context.Context, widget *model.Widget) error {\n    selectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n    updateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n    \n    existing := &model.Widget{}\n    if err := repo.db.Clauses(selectClause).Table(model.InventoryItemsTableName).\n        Where(\"tracking_id = ?\", widget.TrackingId).\n        First(existing).Error; err != nil {\n        if errors.Is(err, gorm.ErrRecordNotFound) {\n            return repo.db.Table(model.InventoryItemsTableName).Create(widget).Error\n        }\n        return err\n    }\n\n    if existing.Points != widget.Points || existing.Weight != widget.Weight {\n        return repo.db.Clauses(updateClause).Table(model.InventoryItemsTableName).\n            Where(\"id = ?\", existing.Id).\n            Updates(map[string]interface{}{\n                \"points\": widget.Points,\n                \"weight\": widget.Weight,\n            }).Error\n    }\n    return nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Record does not exist (initial create)",
            "sql": "SELECT id, tracking_id, points, weight FROM inventory_items WHERE tracking_id = ? ORDER BY id LIMIT 1;"
          },
          {
            "scenario": "Record does not exist (initial create)",
            "sql": "INSERT INTO inventory_items (id, tracking_id, points, weight) VALUES (?, ?, ?, ?);"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Record exists with points/weight changes",
            "sql": "SELECT id, tracking_id, points, weight FROM inventory_items WHERE tracking_id = ? ORDER BY id LIMIT 1;"
          },
          {
            "scenario": "Record exists with points/weight changes",
            "sql": "UPDATE inventory_items SET points = ?, weight = ? WHERE id = ?;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Record exists without changes",
            "sql": "SELECT id, tracking_id, points, weight FROM inventory_items WHERE tracking_id = ? ORDER BY id LIMIT 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "InventoryRepo",
        "code_value": "type InventoryRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Widget",
        "code_value": "type Widget struct {\n\tId        int64   `gorm:\"column:id\" json:\"id\"`\n\tTrackingId string  `gorm:\"column:tracking_id\" json:\"tracking_id\"`\n\tPoints    float64 `gorm:\"column:points\" json:\"points\"`\n\tWeight    float64 `gorm:\"column:weight\" json:\"weight\"`\n}"
      },
      {
        "code_key": "InventoryItemsTableName",
        "code_value": "const InventoryItemsTableName = \"inventory_items\""
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "SQLCommentInfo",
        "code_value": "type SQLCommentInfo struct {\n\tReqId   string\n\tAppId   string\n\tOwnerUin string\n\tSubUin  string\n\tAction  string\n}"
      },
      {
        "code_key": "hints",
        "code_value": "import \"gorm.io/hints\""
      },
      {
        "code_key": "GetSQLCommentFromContext",
        "code_value": "func GetSQLCommentFromContext(ctx context.Context) SQLCommentInfo {\n\t// implementation details\n\treturn SQLCommentInfo{}\n}"
      },
      {
        "code_key": "icontext",
        "code_value": "import \"git.woa.com/IVC/ivc-event-alarm/pkg/icontext\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (w *Widget) TableName() string {\n\treturn InventoryItemsTableName\n}"
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "TrackInventoryMovement",
    "orm_code": "func (repo *InventoryRepo) TrackInventoryMovement(ctx context.Context, widget *model.Widget) error {\n    selectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n    updateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n    \n    existing := &model.Widget{}\n    if err := repo.db.Clauses(selectClause).Table(model.InventoryItemsTableName).\n        Where(\"tracking_id = ?\", widget.TrackingId).\n        First(existing).Error; err != nil {\n        if errors.Is(err, gorm.ErrRecordNotFound) {\n            return repo.db.Table(model.InventoryItemsTableName).Create(widget).Error\n        }\n        return err\n    }\n\n    if existing.Points != widget.Points || existing.Weight != widget.Weight {\n        return repo.db.Clauses(updateClause).Table(model.InventoryItemsTableName).\n            Where(\"id = ?\", existing.Id).\n            Updates(map[string]interface{}{\n                \"points\": widget.Points,\n                \"weight\": widget.Weight,\n            }).Error\n    }\n    return nil\n}",
    "caller": "func HandleInventoryUpdates(ctx context.Context, db *gorm.DB, items []*model.Widget) error {\n    repo := &InventoryRepo{db: db}\n    for _, item := range items {\n        if err := repo.TrackInventoryMovement(ctx, item); err != nil {\n            return fmt.Errorf(\"failed to track inventory for item %s: %v\", item.TrackingId, err)\n        }\n    }\n    return nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Record does not exist, perform insert",
            "sql": "SELECT id, tracking_id, points, weight FROM inventory_items WHERE tracking_id = ? ORDER BY id LIMIT 1; INSERT INTO inventory_items (id, tracking_id, points, weight) VALUES (?, ?, ?, ?);"
          },
          {
            "scenario": "Record exists and needs update",
            "sql": "SELECT id, tracking_id, points, weight FROM inventory_items WHERE tracking_id = ? ORDER BY id LIMIT 1; UPDATE inventory_items SET points = ?, weight = ? WHERE id = ?;"
          },
          {
            "scenario": "Record exists but no update needed",
            "sql": "SELECT id, tracking_id, points, weight FROM inventory_items WHERE tracking_id = ? ORDER BY id LIMIT 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "InventoryRepo",
        "code_value": "type InventoryRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Widget",
        "code_value": "type Widget struct {\n\tId        int64   `gorm:\"column:id\" json:\"id\"`\n\tTrackingId string  `gorm:\"column:tracking_id\" json:\"tracking_id\"`\n\tPoints    float64 `gorm:\"column:points\" json:\"points\"`\n\tWeight    float64 `gorm:\"column:weight\" json:\"weight\"`\n}"
      },
      {
        "code_key": "InventoryItemsTableName",
        "code_value": "const InventoryItemsTableName = \"inventory_items\""
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "SQLCommentInfo",
        "code_value": "type SQLCommentInfo struct {\n\tReqId   string\n\tAppId   string\n\tOwnerUin string\n\tSubUin  string\n\tAction  string\n}"
      },
      {
        "code_key": "hints",
        "code_value": "import \"gorm.io/hints\""
      },
      {
        "code_key": "GetSQLCommentFromContext",
        "code_value": "func GetSQLCommentFromContext(ctx context.Context) SQLCommentInfo {\n\t// implementation details\n\treturn SQLCommentInfo{}\n}"
      },
      {
        "code_key": "icontext",
        "code_value": "import \"git.woa.com/IVC/ivc-event-alarm/pkg/icontext\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (w *Widget) TableName() string {\n\treturn InventoryItemsTableName\n}"
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "TrackInventoryMovement",
    "orm_code": "func (repo *InventoryRepo) TrackInventoryMovement(ctx context.Context, widget *model.Widget) error {\n    selectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n    updateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n    \n    existing := &model.Widget{}\n    if err := repo.db.Clauses(selectClause).Table(model.InventoryItemsTableName).\n        Where(\"tracking_id = ?\", widget.TrackingId).\n        First(existing).Error; err != nil {\n        if errors.Is(err, gorm.ErrRecordNotFound) {\n            return repo.db.Table(model.InventoryItemsTableName).Create(widget).Error\n        }\n        return err\n    }\n\n    if existing.Points != widget.Points || existing.Weight != widget.Weight {\n        return repo.db.Clauses(updateClause).Table(model.InventoryItemsTableName).\n            Where(\"id = ?\", existing.Id).\n            Updates(map[string]interface{}{\n                \"points\": widget.Points,\n                \"weight\": widget.Weight,\n            }).Error\n    }\n    return nil\n}",
    "caller": "func ProcessWarehouseTransfer(ctx context.Context, db *gorm.DB, sourceItem, destItem *model.Widget) error {\n    repo := &InventoryRepo{db: db}\n    \n    if err := repo.TrackInventoryMovement(ctx, sourceItem); err != nil {\n        return fmt.Errorf(\"source item update failed: %v\", err)\n    }\n    \n    if err := repo.TrackInventoryMovement(ctx, destItem); err != nil {\n        return fmt.Errorf(\"destination item update failed: %v\", err)\n    }\n    \n    return nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "查询记录是否存在",
            "sql": "SELECT * FROM inventory_items WHERE tracking_id = ? LIMIT 1;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "记录不存在时执行插入",
            "sql": "INSERT INTO inventory_items (tracking_id, points, weight) VALUES (?, ?, ?);"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "记录存在且points或weight不同时执行更新",
            "sql": "UPDATE inventory_items SET points = ?, weight = ? WHERE id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "InventoryRepo",
        "code_value": "type InventoryRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Widget",
        "code_value": "type Widget struct {\n\tId        int64   `gorm:\"column:id\" json:\"id\"`\n\tTrackingId string  `gorm:\"column:tracking_id\" json:\"tracking_id\"`\n\tPoints    float64 `gorm:\"column:points\" json:\"points\"`\n\tWeight    float64 `gorm:\"column:weight\" json:\"weight\"`\n}"
      },
      {
        "code_key": "InventoryItemsTableName",
        "code_value": "const InventoryItemsTableName = \"inventory_items\""
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "SQLCommentInfo",
        "code_value": "type SQLCommentInfo struct {\n\tReqId   string\n\tAppId   string\n\tOwnerUin string\n\tSubUin  string\n\tAction  string\n}"
      },
      {
        "code_key": "hints",
        "code_value": "import \"gorm.io/hints\""
      },
      {
        "code_key": "GetSQLCommentFromContext",
        "code_value": "func GetSQLCommentFromContext(ctx context.Context) SQLCommentInfo {\n\t// implementation details\n\treturn SQLCommentInfo{}\n}"
      },
      {
        "code_key": "icontext",
        "code_value": "import \"git.woa.com/IVC/ivc-event-alarm/pkg/icontext\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (w *Widget) TableName() string {\n\treturn InventoryItemsTableName\n}"
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "UpdateEntity",
    "orm_code": "func (r *VendorRepo) UpdateEntity(ctx context.Context, entity *model.Layout) error {\n    selectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n    updateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n    oldEntity := &model.Layout{}\n\n    if err := r.db.Clauses(selectClause).Table(model.LayoutTableName).\n        Where(\"namespace_name = ?\", entity.NamespaceName).\n        First(oldEntity).Error; err != nil {\n        return err\n    }\n\n    if oldEntity.Genre != entity.Genre {\n        if err := r.db.Clauses(updateClause).Table(model.LayoutTableName).\n            Where(\"id = ?\", oldEntity.ID).\n            Update(\"genre\", entity.Genre).Error; err != nil {\n            return err\n        }\n    }\n\n    return nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "更新location_code、first_name和author字段，且status为'active'",
            "sql": "UPDATE skill_trees SET location_code = ?, first_name = ?, author = ?, is_active = true WHERE id = ?;"
          },
          {
            "scenario": "只更新location_code，且status为'inactive'",
            "sql": "UPDATE skill_trees SET location_code = ?, is_active = false WHERE id = ?;"
          },
          {
            "scenario": "更新first_name和author，且status为'archived'",
            "sql": "UPDATE skill_trees SET first_name = ?, author = ?, is_archived = true WHERE id = ?;"
          },
          {
            "scenario": "只更新status为'active'（不更新其他字段）",
            "sql": "UPDATE skill_trees SET is_active = true WHERE id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PublicationRepo",
        "code_value": "type PublicationRepo struct {\n    db *gorm.DB\n}"
      },
      {
        "code_key": "QuestTableName",
        "code_value": "const QuestTableName = \"quest_publications\""
      },
      {
        "code_key": "Quest",
        "code_value": "type Quest struct {\n    ID           int64  `gorm:\"column:id\"`\n    Title        string `gorm:\"column:title\"`\n    Status       int    `gorm:\"column:status\"`\n    PublisherID  int64  `gorm:\"column:publisher_id\"`\n}"
      },
      {
        "code_key": "selectClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SelectKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/core/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) hints.Hints {\n    commentInfo := icontext.GetSQLCommentFromContext(ctx)\n    if commentInfo.RequestID == \"\" {\n        commentInfo.RequestID = uuid.New().String()\n    }\n    comment := fmt.Sprintf(\"app=%s,req=%s\", commentInfo.AppName, commentInfo.RequestID)\n    return hints.CommentBefore(clause, comment)\n}"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      },
      {
        "code_key": "PublicationStatus",
        "code_value": "const (\n    Draft = iota\n    Published\n    Archived\n)"
      },
      {
        "code_key": "oldQuest",
        "code_value": "&model.Quest{}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (q *Quest) TableName() string {\n    return QuestTableName\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "UpdateEntity",
    "orm_code": "func (r *VendorRepo) UpdateEntity(ctx context.Context, entity *model.Layout) error {\n    selectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n    updateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n    oldEntity := &model.Layout{}\n\n    if err := r.db.Clauses(selectClause).Table(model.LayoutTableName).\n        Where(\"namespace_name = ?\", entity.NamespaceName).\n        First(oldEntity).Error; err != nil {\n        return err\n    }\n\n    if oldEntity.Genre != entity.Genre {\n        if err := r.db.Clauses(updateClause).Table(model.LayoutTableName).\n            Where(\"id = ?\", oldEntity.ID).\n            Update(\"genre\", entity.Genre).Error; err != nil {\n            return err\n        }\n    }\n\n    return nil\n}",
    "caller": "func HandleEventLayoutUpdate(ctx context.Context, db *gorm.DB, namespace string, genre int) error {\n    repo := &VendorRepo{db: db}\n    layout := &model.Layout{\n        NamespaceName: namespace,\n        Genre:        genre,\n    }\n    \n    if err := repo.UpdateEntity(ctx, layout); err != nil {\n        log.Printf(\"Failed to update layout: %v\", err)\n        return fmt.Errorf(\"update layout failed: %w\", err)\n    }\n    \n    return nil\n}",
    "sql_statement_list": [
      "{\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\n        \"scenario\": \"当genre值有变化时\",\n        \"sql\": [\n          \"SELECT id, namespace_name, genre FROM layouts WHERE namespace_name = ? LIMIT 1;\",\n          \"UPDATE layouts SET genre = ? WHERE id = ?;\"\n        ]\n      }",
      "SELECT id, namespace_name, genre FROM layouts WHERE namespace_name = ? LIMIT 1;",
      "UPDATE layouts SET genre = ? WHERE id = ?;",
      "SELECT id, namespace_name, genre FROM layouts WHERE namespace_name = ? LIMIT 1;"
    ],
    "sql_types": [
      "OTHER",
      "SELECT",
      "UPDATE",
      "SELECT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "PublicationRepo",
        "code_value": "type PublicationRepo struct {\n    db *gorm.DB\n}"
      },
      {
        "code_key": "QuestTableName",
        "code_value": "const QuestTableName = \"quest_publications\""
      },
      {
        "code_key": "Quest",
        "code_value": "type Quest struct {\n    ID           int64  `gorm:\"column:id\"`\n    Title        string `gorm:\"column:title\"`\n    Status       int    `gorm:\"column:status\"`\n    PublisherID  int64  `gorm:\"column:publisher_id\"`\n}"
      },
      {
        "code_key": "selectClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SelectKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/core/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) hints.Hints {\n    commentInfo := icontext.GetSQLCommentFromContext(ctx)\n    if commentInfo.RequestID == \"\" {\n        commentInfo.RequestID = uuid.New().String()\n    }\n    comment := fmt.Sprintf(\"app=%s,req=%s\", commentInfo.AppName, commentInfo.RequestID)\n    return hints.CommentBefore(clause, comment)\n}"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      },
      {
        "code_key": "PublicationStatus",
        "code_value": "const (\n    Draft = iota\n    Published\n    Archived\n)"
      },
      {
        "code_key": "oldQuest",
        "code_value": "&model.Quest{}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (q *Quest) TableName() string {\n    return QuestTableName\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "UpdateEntity",
    "orm_code": "func (r *VendorRepo) UpdateEntity(ctx context.Context, entity *model.Layout) error {\n    selectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n    updateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n    oldEntity := &model.Layout{}\n\n    if err := r.db.Clauses(selectClause).Table(model.LayoutTableName).\n        Where(\"namespace_name = ?\", entity.NamespaceName).\n        First(oldEntity).Error; err != nil {\n        return err\n    }\n\n    if oldEntity.Genre != entity.Genre {\n        if err := r.db.Clauses(updateClause).Table(model.LayoutTableName).\n            Where(\"id = ?\", oldEntity.ID).\n            Update(\"genre\", entity.Genre).Error; err != nil {\n            return err\n        }\n    }\n\n    return nil\n}",
    "caller": "func HandleBrandUpdate(brandID uint, location, firstName string) error {\n\tbrand := &Brand{\n\t\tID:          brandID,\n\t\tLocationCode: location,\n\t\tFirstName:    firstName,\n\t\tStatus:      \"active\",\n\t}\n\tif err := brand.UpdateEntity(); err != nil {\n\t\tlog.Printf(\"Failed to update brand: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "更新 location_code 和 first_name，状态为 active",
            "sql": "UPDATE skill_trees SET location_code = ?, first_name = ?, is_active = true WHERE id = ?;"
          },
          {
            "scenario": "只更新 author，状态为 inactive",
            "sql": "UPDATE skill_trees SET author = ?, is_active = false WHERE id = ?;"
          },
          {
            "scenario": "更新所有字段，状态为 archived",
            "sql": "UPDATE skill_trees SET location_code = ?, first_name = ?, author = ?, is_archived = true WHERE id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PublicationRepo",
        "code_value": "type PublicationRepo struct {\n    db *gorm.DB\n}"
      },
      {
        "code_key": "QuestTableName",
        "code_value": "const QuestTableName = \"quest_publications\""
      },
      {
        "code_key": "Quest",
        "code_value": "type Quest struct {\n    ID           int64  `gorm:\"column:id\"`\n    Title        string `gorm:\"column:title\"`\n    Status       int    `gorm:\"column:status\"`\n    PublisherID  int64  `gorm:\"column:publisher_id\"`\n}"
      },
      {
        "code_key": "selectClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SelectKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/core/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) hints.Hints {\n    commentInfo := icontext.GetSQLCommentFromContext(ctx)\n    if commentInfo.RequestID == \"\" {\n        commentInfo.RequestID = uuid.New().String()\n    }\n    comment := fmt.Sprintf(\"app=%s,req=%s\", commentInfo.AppName, commentInfo.RequestID)\n    return hints.CommentBefore(clause, comment)\n}"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      },
      {
        "code_key": "PublicationStatus",
        "code_value": "const (\n    Draft = iota\n    Published\n    Archived\n)"
      },
      {
        "code_key": "oldQuest",
        "code_value": "&model.Quest{}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (q *Quest) TableName() string {\n    return QuestTableName\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "UpdateEntity",
    "orm_code": "func (r *VendorRepo) UpdateEntity(ctx context.Context, entity *model.Layout) error {\n    selectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n    updateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n    oldEntity := &model.Layout{}\n\n    if err := r.db.Clauses(selectClause).Table(model.LayoutTableName).\n        Where(\"namespace_name = ?\", entity.NamespaceName).\n        First(oldEntity).Error; err != nil {\n        return err\n    }\n\n    if oldEntity.Genre != entity.Genre {\n        if err := r.db.Clauses(updateClause).Table(model.LayoutTableName).\n            Where(\"id = ?\", oldEntity.ID).\n            Update(\"genre\", entity.Genre).Error; err != nil {\n            return err\n        }\n    }\n\n    return nil\n}",
    "caller": "func ArchiveBrandRecord(recordID uint) error {\n\tarchivedBrand := &Brand{\n\t\tID:     recordID,\n\t\tStatus: \"archived\",\n\t}\n\terr := archivedBrand.UpdateEntity()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to archive brand ID %d: %v\", recordID, err)\n\t\treturn fmt.Errorf(\"archive operation failed\")\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Update brand with status 'archived'",
            "sql": "UPDATE skill_trees SET is_archived = TRUE WHERE id = ?;"
          },
          {
            "scenario": "Update brand with status 'active'",
            "sql": "UPDATE skill_trees SET is_active = TRUE WHERE id = ?;"
          },
          {
            "scenario": "Update brand with status 'inactive'",
            "sql": "UPDATE skill_trees SET is_active = FALSE WHERE id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PublicationRepo",
        "code_value": "type PublicationRepo struct {\n    db *gorm.DB\n}"
      },
      {
        "code_key": "QuestTableName",
        "code_value": "const QuestTableName = \"quest_publications\""
      },
      {
        "code_key": "Quest",
        "code_value": "type Quest struct {\n    ID           int64  `gorm:\"column:id\"`\n    Title        string `gorm:\"column:title\"`\n    Status       int    `gorm:\"column:status\"`\n    PublisherID  int64  `gorm:\"column:publisher_id\"`\n}"
      },
      {
        "code_key": "selectClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SelectKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/core/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) hints.Hints {\n    commentInfo := icontext.GetSQLCommentFromContext(ctx)\n    if commentInfo.RequestID == \"\" {\n        commentInfo.RequestID = uuid.New().String()\n    }\n    comment := fmt.Sprintf(\"app=%s,req=%s\", commentInfo.AppName, commentInfo.RequestID)\n    return hints.CommentBefore(clause, comment)\n}"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      },
      {
        "code_key": "PublicationStatus",
        "code_value": "const (\n    Draft = iota\n    Published\n    Archived\n)"
      },
      {
        "code_key": "oldQuest",
        "code_value": "&model.Quest{}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (q *Quest) TableName() string {\n    return QuestTableName\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "UpdateEntity",
    "orm_code": "func (r *VendorRepo) UpdateEntity(ctx context.Context, entity *model.Layout) error {\n    selectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n    updateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n    oldEntity := &model.Layout{}\n\n    if err := r.db.Clauses(selectClause).Table(model.LayoutTableName).\n        Where(\"namespace_name = ?\", entity.NamespaceName).\n        First(oldEntity).Error; err != nil {\n        return err\n    }\n\n    if oldEntity.Genre != entity.Genre {\n        if err := r.db.Clauses(updateClause).Table(model.LayoutTableName).\n            Where(\"id = ?\", oldEntity.ID).\n            Update(\"genre\", entity.Genre).Error; err != nil {\n            return err\n        }\n    }\n\n    return nil\n}",
    "caller": "func DeactivateBrandProfile(profileID uint, authorName string) error {\n\tprofile := &Brand{\n\t\tID:     profileID,\n\t\tAuthor: authorName,\n\t\tStatus: \"inactive\",\n\t}\n\tif updateErr := profile.UpdateEntity(); updateErr != nil {\n\t\treturn fmt.Errorf(\"deactivation failed: %w\", updateErr)\n\t}\n\tlog.Printf(\"Successfully deactivated brand profile %d\", profileID)\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Status is inactive, with author name provided",
            "sql": "UPDATE skill_trees SET author = ?, is_active = ? WHERE id = ?;"
          },
          {
            "scenario": "Status is active, with location_code and author provided",
            "sql": "UPDATE skill_trees SET location_code = ?, author = ?, is_active = ? WHERE id = ?;"
          },
          {
            "scenario": "Status is archived, with location_code and first_name provided",
            "sql": "UPDATE skill_trees SET location_code = ?, first_name = ?, is_archived = ? WHERE id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "PublicationRepo",
        "code_value": "type PublicationRepo struct {\n    db *gorm.DB\n}"
      },
      {
        "code_key": "QuestTableName",
        "code_value": "const QuestTableName = \"quest_publications\""
      },
      {
        "code_key": "Quest",
        "code_value": "type Quest struct {\n    ID           int64  `gorm:\"column:id\"`\n    Title        string `gorm:\"column:title\"`\n    Status       int    `gorm:\"column:status\"`\n    PublisherID  int64  `gorm:\"column:publisher_id\"`\n}"
      },
      {
        "code_key": "selectClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SelectKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/core/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) hints.Hints {\n    commentInfo := icontext.GetSQLCommentFromContext(ctx)\n    if commentInfo.RequestID == \"\" {\n        commentInfo.RequestID = uuid.New().String()\n    }\n    comment := fmt.Sprintf(\"app=%s,req=%s\", commentInfo.AppName, commentInfo.RequestID)\n    return hints.CommentBefore(clause, comment)\n}"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      },
      {
        "code_key": "PublicationStatus",
        "code_value": "const (\n    Draft = iota\n    Published\n    Archived\n)"
      },
      {
        "code_key": "oldQuest",
        "code_value": "&model.Quest{}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (q *Quest) TableName() string {\n    return QuestTableName\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "AuthorizeAccess",
    "orm_code": "func (repo *CreditRepo) AuthorizeAccess(ctx context.Context, credit *model.CreditDimension) error {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\texistingCredit := &model.CreditDimension{}\n\n\tif err := repo.db.Clauses(queryClause).Table(model.CreditDimensionTableName).\n\t\tWhere(\"end_date > ? AND dimension = ?\", time.Now().Unix(), credit.Dimension).\n\t\tFirst(existingCredit).Error; err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn errors.New(\"credit authorization failed: no valid record found\")\n\t\t}\n\t\treturn err\n\t}\n\n\tif existingCredit.FullName != credit.FullName {\n\t\treturn errors.New(\"credit authorization failed: name mismatch\")\n\t}\n\n\treturn nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "RoleCode = admin",
            "sql": "SELECT COUNT(1) > 0 FROM media_library WHERE status = 1 AND permission_type = 'full';"
          },
          {
            "scenario": "RoleCode = editor",
            "sql": "SELECT COUNT(1) > 0 FROM media_library WHERE status = 1 AND permission_type = 'edit';"
          },
          {
            "scenario": "RoleCode = viewer",
            "sql": "SELECT COUNT(1) > 0 FROM media_library WHERE status = 1 AND permission_type = 'read';"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "CreditRepo",
        "code_value": "type CreditRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "CreditDimensionTableName",
        "code_value": "const CreditDimensionTableName = \"credit_dimension\""
      },
      {
        "code_key": "CreditDimension",
        "code_value": "type CreditDimension struct {\n\tID        int64  `gorm:\"column:id\" json:\"id\"`\n\tFullName  string `gorm:\"column:full_name\" json:\"full_name\"`\n\tDimension string `gorm:\"column:dimension\" json:\"dimension\"`\n\tEndDate   int64  `gorm:\"column:end_date\" json:\"end_date\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (cd *CreditDimension) TableName() string {\n\treturn CreditDimensionTableName\n}"
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"query\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-credit/pkg/utils"
      },
      {
        "code_key": "existingCredit",
        "code_value": "&model.CreditDimension{}"
      },
      {
        "code_key": "TimeNow",
        "code_value": "time.Now().Unix()"
      },
      {
        "code_key": "ErrRecordNotFound",
        "code_value": "gorm.ErrRecordNotFound"
      },
      {
        "code_key": "AuthErrorMsg",
        "code_value": "const AuthErrorMsg = \"credit authorization failed\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "AuthorizeAccess",
    "orm_code": "func (repo *CreditRepo) AuthorizeAccess(ctx context.Context, credit *model.CreditDimension) error {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\texistingCredit := &model.CreditDimension{}\n\n\tif err := repo.db.Clauses(queryClause).Table(model.CreditDimensionTableName).\n\t\tWhere(\"end_date > ? AND dimension = ?\", time.Now().Unix(), credit.Dimension).\n\t\tFirst(existingCredit).Error; err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn errors.New(\"credit authorization failed: no valid record found\")\n\t\t}\n\t\treturn err\n\t}\n\n\tif existingCredit.FullName != credit.FullName {\n\t\treturn errors.New(\"credit authorization failed: name mismatch\")\n\t}\n\n\treturn nil\n}",
    "caller": "func HandleCreditValidation(ctx context.Context, userCred *model.CreditDimension, dbConn *gorm.DB) error {\n\tcreditRepo := &CreditRepo{db: dbConn}\n\tif err := creditRepo.AuthorizeAccess(ctx, userCred); err != nil {\n\t\tlog.Printf(\"credit validation failed: %v\", err)\n\t\treturn fmt.Errorf(\"cannot validate credit: %w\", err)\n\t}\n\tlog.Println(\"credit validation successful\")\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Standard query with time and dimension conditions",
            "sql": "SELECT id, full_name, dimension, end_date FROM credit_dimension WHERE end_date > ? AND dimension = ? LIMIT 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "CreditRepo",
        "code_value": "type CreditRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "CreditDimensionTableName",
        "code_value": "const CreditDimensionTableName = \"credit_dimension\""
      },
      {
        "code_key": "CreditDimension",
        "code_value": "type CreditDimension struct {\n\tID        int64  `gorm:\"column:id\" json:\"id\"`\n\tFullName  string `gorm:\"column:full_name\" json:\"full_name\"`\n\tDimension string `gorm:\"column:dimension\" json:\"dimension\"`\n\tEndDate   int64  `gorm:\"column:end_date\" json:\"end_date\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (cd *CreditDimension) TableName() string {\n\treturn CreditDimensionTableName\n}"
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"query\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-credit/pkg/utils"
      },
      {
        "code_key": "existingCredit",
        "code_value": "&model.CreditDimension{}"
      },
      {
        "code_key": "TimeNow",
        "code_value": "time.Now().Unix()"
      },
      {
        "code_key": "ErrRecordNotFound",
        "code_value": "gorm.ErrRecordNotFound"
      },
      {
        "code_key": "AuthErrorMsg",
        "code_value": "const AuthErrorMsg = \"credit authorization failed\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "AuthorizeAccess",
    "orm_code": "func (repo *CreditRepo) AuthorizeAccess(ctx context.Context, credit *model.CreditDimension) error {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\texistingCredit := &model.CreditDimension{}\n\n\tif err := repo.db.Clauses(queryClause).Table(model.CreditDimensionTableName).\n\t\tWhere(\"end_date > ? AND dimension = ?\", time.Now().Unix(), credit.Dimension).\n\t\tFirst(existingCredit).Error; err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn errors.New(\"credit authorization failed: no valid record found\")\n\t\t}\n\t\treturn err\n\t}\n\n\tif existingCredit.FullName != credit.FullName {\n\t\treturn errors.New(\"credit authorization failed: name mismatch\")\n\t}\n\n\treturn nil\n}",
    "caller": "func ProcessUserAccess(ctx context.Context, accessDetails *model.CreditDimension) (bool, error) {\n\tdbInstance := config.GetDatabase()\n\tif dbInstance == nil {\n\t\treturn false, errors.New(\"database connection not available\")\n\t}\n\n\tvalidator := CreditRepo{db: dbInstance}\n\terr := validator.AuthorizeAccess(ctx, accessDetails)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"access denied: %w\", err)\n\t}\n\treturn true, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Standard query with timestamp and dimension parameters",
            "sql": "SELECT * FROM credit_dimension WHERE end_date > ? AND dimension = ? ORDER BY id LIMIT 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "CreditRepo",
        "code_value": "type CreditRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "CreditDimensionTableName",
        "code_value": "const CreditDimensionTableName = \"credit_dimension\""
      },
      {
        "code_key": "CreditDimension",
        "code_value": "type CreditDimension struct {\n\tID        int64  `gorm:\"column:id\" json:\"id\"`\n\tFullName  string `gorm:\"column:full_name\" json:\"full_name\"`\n\tDimension string `gorm:\"column:dimension\" json:\"dimension\"`\n\tEndDate   int64  `gorm:\"column:end_date\" json:\"end_date\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (cd *CreditDimension) TableName() string {\n\treturn CreditDimensionTableName\n}"
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"query\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-credit/pkg/utils"
      },
      {
        "code_key": "existingCredit",
        "code_value": "&model.CreditDimension{}"
      },
      {
        "code_key": "TimeNow",
        "code_value": "time.Now().Unix()"
      },
      {
        "code_key": "ErrRecordNotFound",
        "code_value": "gorm.ErrRecordNotFound"
      },
      {
        "code_key": "AuthErrorMsg",
        "code_value": "const AuthErrorMsg = \"credit authorization failed\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "AuthorizeAccess",
    "orm_code": "func (repo *CreditRepo) AuthorizeAccess(ctx context.Context, credit *model.CreditDimension) error {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\texistingCredit := &model.CreditDimension{}\n\n\tif err := repo.db.Clauses(queryClause).Table(model.CreditDimensionTableName).\n\t\tWhere(\"end_date > ? AND dimension = ?\", time.Now().Unix(), credit.Dimension).\n\t\tFirst(existingCredit).Error; err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn errors.New(\"credit authorization failed: no valid record found\")\n\t\t}\n\t\treturn err\n\t}\n\n\tif existingCredit.FullName != credit.FullName {\n\t\treturn errors.New(\"credit authorization failed: name mismatch\")\n\t}\n\n\treturn nil\n}",
    "caller": "func HandleMediaAccess() {\n\tmediaAllergy := &Allergy{RoleCode: \"editor\"}\n\tmediaAllergy.CommentFunc = DefaultCommentFunc\n\n\tgranted, err := mediaAllergy.AuthorizeAccess()\n\tif err != nil {\n\t\tlog.Printf(\"Authorization failed: %v\", err)\n\t\treturn\n\t}\n\n\tif granted {\n\t\tfmt.Println(\"Access granted for editor role\")\n\t} else {\n\t\tfmt.Println(\"Access denied\")\n\t}\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "RoleCode is admin",
            "sql": "SELECT COUNT(1) > 0 FROM media_library WHERE status = 1 AND permission_type = 'full';"
          },
          {
            "scenario": "RoleCode is editor",
            "sql": "SELECT COUNT(1) > 0 FROM media_library WHERE status = 1 AND permission_type = 'edit';"
          },
          {
            "scenario": "RoleCode is viewer",
            "sql": "SELECT COUNT(1) > 0 FROM media_library WHERE status = 1 AND permission_type = 'read';"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "CreditRepo",
        "code_value": "type CreditRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "CreditDimensionTableName",
        "code_value": "const CreditDimensionTableName = \"credit_dimension\""
      },
      {
        "code_key": "CreditDimension",
        "code_value": "type CreditDimension struct {\n\tID        int64  `gorm:\"column:id\" json:\"id\"`\n\tFullName  string `gorm:\"column:full_name\" json:\"full_name\"`\n\tDimension string `gorm:\"column:dimension\" json:\"dimension\"`\n\tEndDate   int64  `gorm:\"column:end_date\" json:\"end_date\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (cd *CreditDimension) TableName() string {\n\treturn CreditDimensionTableName\n}"
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"query\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-credit/pkg/utils"
      },
      {
        "code_key": "existingCredit",
        "code_value": "&model.CreditDimension{}"
      },
      {
        "code_key": "TimeNow",
        "code_value": "time.Now().Unix()"
      },
      {
        "code_key": "ErrRecordNotFound",
        "code_value": "gorm.ErrRecordNotFound"
      },
      {
        "code_key": "AuthErrorMsg",
        "code_value": "const AuthErrorMsg = \"credit authorization failed\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "AuthorizeAccess",
    "orm_code": "func (repo *CreditRepo) AuthorizeAccess(ctx context.Context, credit *model.CreditDimension) error {\n\tqueryClause := utils.SetSQLComment(ctx, utils.QueryKey)\n\texistingCredit := &model.CreditDimension{}\n\n\tif err := repo.db.Clauses(queryClause).Table(model.CreditDimensionTableName).\n\t\tWhere(\"end_date > ? AND dimension = ?\", time.Now().Unix(), credit.Dimension).\n\t\tFirst(existingCredit).Error; err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn errors.New(\"credit authorization failed: no valid record found\")\n\t\t}\n\t\treturn err\n\t}\n\n\tif existingCredit.FullName != credit.FullName {\n\t\treturn errors.New(\"credit authorization failed: name mismatch\")\n\t}\n\n\treturn nil\n}",
    "caller": "func ValidateLibraryPermissions(role string) error {\n\tpermCheck := Allergy{RoleCode: role}\n\tpermCheck.CommentFunc = CustomCommentFunc\n\n\thasAccess, authErr := permCheck.AuthorizeAccess()\n\tif authErr != nil {\n\t\treturn fmt.Errorf(\"authorization error: %w\", authErr)\n\t}\n\n\tif !hasAccess {\n\t\treturn errors.New(\"insufficient permissions\")\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "RoleCode is admin",
            "sql": "SELECT COUNT(1) > 0 FROM media_library WHERE status = 1 AND permission_type = 'full';"
          },
          {
            "scenario": "RoleCode is editor",
            "sql": "SELECT COUNT(1) > 0 FROM media_library WHERE status = 1 AND permission_type = 'edit';"
          },
          {
            "scenario": "RoleCode is viewer",
            "sql": "SELECT COUNT(1) > 0 FROM media_library WHERE status = 1 AND permission_type = 'read';"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "CreditRepo",
        "code_value": "type CreditRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "CreditDimensionTableName",
        "code_value": "const CreditDimensionTableName = \"credit_dimension\""
      },
      {
        "code_key": "CreditDimension",
        "code_value": "type CreditDimension struct {\n\tID        int64  `gorm:\"column:id\" json:\"id\"`\n\tFullName  string `gorm:\"column:full_name\" json:\"full_name\"`\n\tDimension string `gorm:\"column:dimension\" json:\"dimension\"`\n\tEndDate   int64  `gorm:\"column:end_date\" json:\"end_date\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (cd *CreditDimension) TableName() string {\n\treturn CreditDimensionTableName\n}"
      },
      {
        "code_key": "QueryKey",
        "code_value": "const QueryKey = \"query\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-credit/pkg/utils"
      },
      {
        "code_key": "existingCredit",
        "code_value": "&model.CreditDimension{}"
      },
      {
        "code_key": "TimeNow",
        "code_value": "time.Now().Unix()"
      },
      {
        "code_key": "ErrRecordNotFound",
        "code_value": "gorm.ErrRecordNotFound"
      },
      {
        "code_key": "AuthErrorMsg",
        "code_value": "const AuthErrorMsg = \"credit authorization failed\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "MoveToArchive",
    "orm_code": "func (repo *TextbookRepo) MoveToArchive(ctx context.Context, textbook *model.Textbook) error {\n\tarchiveClause := utils.SetSQLComment(ctx, utils.ArchiveKey)\n\tactiveClause := utils.SetSQLComment(ctx, utils.ActiveKey)\n\n\t// Check if textbook exists in active table\n\tvar existingTextbook model.Textbook\n\tif err := repo.db.Clauses(activeClause).Table(model.TextbookActiveTableName).\n\t\tWhere(\"tracking_id = ?\", textbook.TrackingId).\n\t\tFirst(&existingTextbook).Error; err != nil {\n\t\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\t\treturn fmt.Errorf(\"textbook not found\")\n\t\t\t}\n\t\t\treturn err\n\t}\n\n\t// Move to archive\n\tif err := repo.db.Clauses(archiveClause).Table(model.TextbookArchiveTableName).\n\t\tCreate(textbook).Error; err != nil {\n\t\t\treturn err\n\t}\n\n\t// Delete from active\n\tif err := repo.db.Clauses(activeClause).Table(model.TextbookActiveTableName).\n\t\tWhere(\"tracking_id = ?\", textbook.TrackingId).\n\t\tDelete(&model.Textbook{}).Error; err != nil {\n\t\t\treturn err\n\t}\n\n\treturn nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "ApprovalLevel=1, SequenceNumber>0",
            "sql": "SELECT COUNT(*) FROM content_archive WHERE status = 1 AND priority = 'high' AND sequence_number = ?;"
          },
          {
            "scenario": "ApprovalLevel=1, SequenceNumber=0",
            "sql": "SELECT COUNT(*) FROM content_archive WHERE status = 1 AND priority = 'high';"
          },
          {
            "scenario": "ApprovalLevel=2, SequenceNumber>0",
            "sql": "SELECT COUNT(*) FROM content_archive WHERE status = 1 AND priority = 'medium' AND sequence_number = ?;"
          },
          {
            "scenario": "ApprovalLevel=2, SequenceNumber=0",
            "sql": "SELECT COUNT(*) FROM content_archive WHERE status = 1 AND priority = 'medium';"
          },
          {
            "scenario": "ApprovalLevel=3, SequenceNumber>0",
            "sql": "SELECT COUNT(*) FROM content_archive WHERE status = 1 AND priority = 'low' AND sequence_number = ?;"
          },
          {
            "scenario": "ApprovalLevel=3, SequenceNumber=0",
            "sql": "SELECT COUNT(*) FROM content_archive WHERE status = 1 AND priority = 'low';"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "TextbookRepo",
        "code_value": "type TextbookRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Textbook",
        "code_value": "type Textbook struct {\n\tTrackingId    string `gorm:\"column:tracking_id\" json:\"tracking_id\"`\n\tTitle         string `gorm:\"column:title\" json:\"title\"`\n\tAuthor        string `gorm:\"column:author\" json:\"author\"`\n\tPublisher     string `gorm:\"column:publisher\" json:\"publisher\"`\n\tPublishedYear int    `gorm:\"column:published_year\" json:\"published_year\"`\n}"
      },
      {
        "code_key": "TextbookActiveTableName",
        "code_value": "const TextbookActiveTableName = \"textbook_active\""
      },
      {
        "code_key": "TextbookArchiveTableName",
        "code_value": "const TextbookArchiveTableName = \"textbook_archive\""
      },
      {
        "code_key": "ArchiveKey",
        "code_value": "const ArchiveKey = \"archive\""
      },
      {
        "code_key": "ActiveKey",
        "code_value": "const ActiveKey = \"active\""
      },
      {
        "code_key": "hints",
        "code_value": "import \"gorm.io/hints\""
      },
      {
        "code_key": "icontext",
        "code_value": "import \"git.woa.com/common/icontext\""
      },
      {
        "code_key": "model",
        "code_value": "import \"git.woa.com/edu/model\""
      },
      {
        "code_key": "utils",
        "code_value": "import \"git.woa.com/common/utils\""
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "MoveToArchive",
    "orm_code": "func (repo *TextbookRepo) MoveToArchive(ctx context.Context, textbook *model.Textbook) error {\n\tarchiveClause := utils.SetSQLComment(ctx, utils.ArchiveKey)\n\tactiveClause := utils.SetSQLComment(ctx, utils.ActiveKey)\n\n\t// Check if textbook exists in active table\n\tvar existingTextbook model.Textbook\n\tif err := repo.db.Clauses(activeClause).Table(model.TextbookActiveTableName).\n\t\tWhere(\"tracking_id = ?\", textbook.TrackingId).\n\t\tFirst(&existingTextbook).Error; err != nil {\n\t\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\t\treturn fmt.Errorf(\"textbook not found\")\n\t\t\t}\n\t\t\treturn err\n\t}\n\n\t// Move to archive\n\tif err := repo.db.Clauses(archiveClause).Table(model.TextbookArchiveTableName).\n\t\tCreate(textbook).Error; err != nil {\n\t\t\treturn err\n\t}\n\n\t// Delete from active\n\tif err := repo.db.Clauses(activeClause).Table(model.TextbookActiveTableName).\n\t\tWhere(\"tracking_id = ?\", textbook.TrackingId).\n\t\tDelete(&model.Textbook{}).Error; err != nil {\n\t\t\treturn err\n\t}\n\n\treturn nil\n}",
    "caller": "func HandleTextbookRetirement(ctx context.Context, trackingID string) error {\n\trepo := &TextbookRepo{db: GetDBInstance()}\n\tbook := &model.Textbook{TrackingId: trackingID}\n\tif err := repo.MoveToArchive(ctx, book); err != nil {\n\t\tlog.Printf(\"Failed to retire textbook %s: %v\", trackingID, err)\n\t\treturn err\n\t}\n\tlog.Printf(\"Successfully retired textbook %s\", trackingID)\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "检查教材是否存在于活跃表",
            "sql": "SELECT tracking_id, title, author, publisher, published_year FROM textbook_active WHERE tracking_id = ? LIMIT 1;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "将教材插入归档表",
            "sql": "INSERT INTO textbook_archive (tracking_id, title, author, publisher, published_year) VALUES (?, ?, ?, ?, ?);"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "从活跃表删除教材",
            "sql": "DELETE FROM textbook_active WHERE tracking_id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "TextbookRepo",
        "code_value": "type TextbookRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Textbook",
        "code_value": "type Textbook struct {\n\tTrackingId    string `gorm:\"column:tracking_id\" json:\"tracking_id\"`\n\tTitle         string `gorm:\"column:title\" json:\"title\"`\n\tAuthor        string `gorm:\"column:author\" json:\"author\"`\n\tPublisher     string `gorm:\"column:publisher\" json:\"publisher\"`\n\tPublishedYear int    `gorm:\"column:published_year\" json:\"published_year\"`\n}"
      },
      {
        "code_key": "TextbookActiveTableName",
        "code_value": "const TextbookActiveTableName = \"textbook_active\""
      },
      {
        "code_key": "TextbookArchiveTableName",
        "code_value": "const TextbookArchiveTableName = \"textbook_archive\""
      },
      {
        "code_key": "ArchiveKey",
        "code_value": "const ArchiveKey = \"archive\""
      },
      {
        "code_key": "ActiveKey",
        "code_value": "const ActiveKey = \"active\""
      },
      {
        "code_key": "hints",
        "code_value": "import \"gorm.io/hints\""
      },
      {
        "code_key": "icontext",
        "code_value": "import \"git.woa.com/common/icontext\""
      },
      {
        "code_key": "model",
        "code_value": "import \"git.woa.com/edu/model\""
      },
      {
        "code_key": "utils",
        "code_value": "import \"git.woa.com/common/utils\""
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "MoveToArchive",
    "orm_code": "func (repo *TextbookRepo) MoveToArchive(ctx context.Context, textbook *model.Textbook) error {\n\tarchiveClause := utils.SetSQLComment(ctx, utils.ArchiveKey)\n\tactiveClause := utils.SetSQLComment(ctx, utils.ActiveKey)\n\n\t// Check if textbook exists in active table\n\tvar existingTextbook model.Textbook\n\tif err := repo.db.Clauses(activeClause).Table(model.TextbookActiveTableName).\n\t\tWhere(\"tracking_id = ?\", textbook.TrackingId).\n\t\tFirst(&existingTextbook).Error; err != nil {\n\t\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\t\treturn fmt.Errorf(\"textbook not found\")\n\t\t\t}\n\t\t\treturn err\n\t}\n\n\t// Move to archive\n\tif err := repo.db.Clauses(archiveClause).Table(model.TextbookArchiveTableName).\n\t\tCreate(textbook).Error; err != nil {\n\t\t\treturn err\n\t}\n\n\t// Delete from active\n\tif err := repo.db.Clauses(activeClause).Table(model.TextbookActiveTableName).\n\t\tWhere(\"tracking_id = ?\", textbook.TrackingId).\n\t\tDelete(&model.Textbook{}).Error; err != nil {\n\t\t\treturn err\n\t}\n\n\treturn nil\n}",
    "caller": "func ProcessExpiredTextbooks(ctx context.Context, bookList []*model.Textbook) error {\n\trepo := &TextbookRepo{db: InitDatabaseConnection()}\n\tfor _, item := range bookList {\n\t\tif item == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif err := repo.MoveToArchive(ctx, item); err != nil {\n\t\t\tlog.Printf(\"Failed to archive textbook %s: %v\", item.TrackingId, err)\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Check if textbook exists in active table",
            "sql": "SELECT tracking_id, title, author, publisher, published_year FROM textbook_active WHERE tracking_id = ? LIMIT 1;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Move textbook to archive",
            "sql": "INSERT INTO textbook_archive (tracking_id, title, author, publisher, published_year) VALUES (?, ?, ?, ?, ?);"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Delete textbook from active table",
            "sql": "DELETE FROM textbook_active WHERE tracking_id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "TextbookRepo",
        "code_value": "type TextbookRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Textbook",
        "code_value": "type Textbook struct {\n\tTrackingId    string `gorm:\"column:tracking_id\" json:\"tracking_id\"`\n\tTitle         string `gorm:\"column:title\" json:\"title\"`\n\tAuthor        string `gorm:\"column:author\" json:\"author\"`\n\tPublisher     string `gorm:\"column:publisher\" json:\"publisher\"`\n\tPublishedYear int    `gorm:\"column:published_year\" json:\"published_year\"`\n}"
      },
      {
        "code_key": "TextbookActiveTableName",
        "code_value": "const TextbookActiveTableName = \"textbook_active\""
      },
      {
        "code_key": "TextbookArchiveTableName",
        "code_value": "const TextbookArchiveTableName = \"textbook_archive\""
      },
      {
        "code_key": "ArchiveKey",
        "code_value": "const ArchiveKey = \"archive\""
      },
      {
        "code_key": "ActiveKey",
        "code_value": "const ActiveKey = \"active\""
      },
      {
        "code_key": "hints",
        "code_value": "import \"gorm.io/hints\""
      },
      {
        "code_key": "icontext",
        "code_value": "import \"git.woa.com/common/icontext\""
      },
      {
        "code_key": "model",
        "code_value": "import \"git.woa.com/edu/model\""
      },
      {
        "code_key": "utils",
        "code_value": "import \"git.woa.com/common/utils\""
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "MoveToArchive",
    "orm_code": "func (repo *TextbookRepo) MoveToArchive(ctx context.Context, textbook *model.Textbook) error {\n\tarchiveClause := utils.SetSQLComment(ctx, utils.ArchiveKey)\n\tactiveClause := utils.SetSQLComment(ctx, utils.ActiveKey)\n\n\t// Check if textbook exists in active table\n\tvar existingTextbook model.Textbook\n\tif err := repo.db.Clauses(activeClause).Table(model.TextbookActiveTableName).\n\t\tWhere(\"tracking_id = ?\", textbook.TrackingId).\n\t\tFirst(&existingTextbook).Error; err != nil {\n\t\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\t\treturn fmt.Errorf(\"textbook not found\")\n\t\t\t}\n\t\t\treturn err\n\t}\n\n\t// Move to archive\n\tif err := repo.db.Clauses(archiveClause).Table(model.TextbookArchiveTableName).\n\t\tCreate(textbook).Error; err != nil {\n\t\t\treturn err\n\t}\n\n\t// Delete from active\n\tif err := repo.db.Clauses(activeClause).Table(model.TextbookActiveTableName).\n\t\tWhere(\"tracking_id = ?\", textbook.TrackingId).\n\t\tDelete(&model.Textbook{}).Error; err != nil {\n\t\t\treturn err\n\t}\n\n\treturn nil\n}",
    "caller": "func HandleArchiveMigration() {\n\tarchiveForecast := &Forecast{\n\t\tApprovalLevel: 2,\n\t\tSequenceNumber: 1001,\n\t}\n\n\tcount, err := archiveForecast.MoveToArchive()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to migrate forecast: %v\", err)\n\t\treturn\n\t}\n\tlog.Printf(\"Successfully archived %d records\", count)\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "ApprovalLevel = 1 and SequenceNumber > 0",
            "sql": "SELECT COUNT(*) FROM content_archive WHERE status = 1 AND priority = 'high' AND sequence_number = ?;"
          },
          {
            "scenario": "ApprovalLevel = 2 and SequenceNumber > 0",
            "sql": "SELECT COUNT(*) FROM content_archive WHERE status = 1 AND priority = 'medium' AND sequence_number = ?;"
          },
          {
            "scenario": "ApprovalLevel = 3 and SequenceNumber > 0",
            "sql": "SELECT COUNT(*) FROM content_archive WHERE status = 1 AND priority = 'low' AND sequence_number = ?;"
          },
          {
            "scenario": "ApprovalLevel = 1 and SequenceNumber = 0",
            "sql": "SELECT COUNT(*) FROM content_archive WHERE status = 1 AND priority = 'high';"
          },
          {
            "scenario": "ApprovalLevel = 2 and SequenceNumber = 0",
            "sql": "SELECT COUNT(*) FROM content_archive WHERE status = 1 AND priority = 'medium';"
          },
          {
            "scenario": "ApprovalLevel = 3 and SequenceNumber = 0",
            "sql": "SELECT COUNT(*) FROM content_archive WHERE status = 1 AND priority = 'low';"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "TextbookRepo",
        "code_value": "type TextbookRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Textbook",
        "code_value": "type Textbook struct {\n\tTrackingId    string `gorm:\"column:tracking_id\" json:\"tracking_id\"`\n\tTitle         string `gorm:\"column:title\" json:\"title\"`\n\tAuthor        string `gorm:\"column:author\" json:\"author\"`\n\tPublisher     string `gorm:\"column:publisher\" json:\"publisher\"`\n\tPublishedYear int    `gorm:\"column:published_year\" json:\"published_year\"`\n}"
      },
      {
        "code_key": "TextbookActiveTableName",
        "code_value": "const TextbookActiveTableName = \"textbook_active\""
      },
      {
        "code_key": "TextbookArchiveTableName",
        "code_value": "const TextbookArchiveTableName = \"textbook_archive\""
      },
      {
        "code_key": "ArchiveKey",
        "code_value": "const ArchiveKey = \"archive\""
      },
      {
        "code_key": "ActiveKey",
        "code_value": "const ActiveKey = \"active\""
      },
      {
        "code_key": "hints",
        "code_value": "import \"gorm.io/hints\""
      },
      {
        "code_key": "icontext",
        "code_value": "import \"git.woa.com/common/icontext\""
      },
      {
        "code_key": "model",
        "code_value": "import \"git.woa.com/edu/model\""
      },
      {
        "code_key": "utils",
        "code_value": "import \"git.woa.com/common/utils\""
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "MoveToArchive",
    "orm_code": "func (repo *TextbookRepo) MoveToArchive(ctx context.Context, textbook *model.Textbook) error {\n\tarchiveClause := utils.SetSQLComment(ctx, utils.ArchiveKey)\n\tactiveClause := utils.SetSQLComment(ctx, utils.ActiveKey)\n\n\t// Check if textbook exists in active table\n\tvar existingTextbook model.Textbook\n\tif err := repo.db.Clauses(activeClause).Table(model.TextbookActiveTableName).\n\t\tWhere(\"tracking_id = ?\", textbook.TrackingId).\n\t\tFirst(&existingTextbook).Error; err != nil {\n\t\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\t\treturn fmt.Errorf(\"textbook not found\")\n\t\t\t}\n\t\t\treturn err\n\t}\n\n\t// Move to archive\n\tif err := repo.db.Clauses(archiveClause).Table(model.TextbookArchiveTableName).\n\t\tCreate(textbook).Error; err != nil {\n\t\t\treturn err\n\t}\n\n\t// Delete from active\n\tif err := repo.db.Clauses(activeClause).Table(model.TextbookActiveTableName).\n\t\tWhere(\"tracking_id = ?\", textbook.TrackingId).\n\t\tDelete(&model.Textbook{}).Error; err != nil {\n\t\t\treturn err\n\t}\n\n\treturn nil\n}",
    "caller": "func ProcessPriorityArchival() error {\n\thighPriorityRecord := Forecast{\n\t\tApprovalLevel: 1,\n\t\tSequenceNumber: 0, // Intentionally left blank\n\t}\n\n\tarchivedCount, archErr := highPriorityRecord.MoveToArchive()\n\tif archErr != nil {\n\t\treturn fmt.Errorf(\"archival failed: %w\", archErr)\n\t}\n\n\tif archivedCount == 0 {\n\t\treturn errors.New(\"no matching records found\")\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "ApprovalLevel=1, SequenceNumber=0",
            "sql": "SELECT COUNT(*) FROM content_archive WHERE status = 1 AND priority = 'high';"
          },
          {
            "scenario": "ApprovalLevel=1, SequenceNumber>0",
            "sql": "SELECT COUNT(*) FROM content_archive WHERE status = 1 AND priority = 'high' AND sequence_number = ?;"
          },
          {
            "scenario": "ApprovalLevel=2, SequenceNumber=0",
            "sql": "SELECT COUNT(*) FROM content_archive WHERE status = 1 AND priority = 'medium';"
          },
          {
            "scenario": "ApprovalLevel=2, SequenceNumber>0",
            "sql": "SELECT COUNT(*) FROM content_archive WHERE status = 1 AND priority = 'medium' AND sequence_number = ?;"
          },
          {
            "scenario": "ApprovalLevel=3, SequenceNumber=0",
            "sql": "SELECT COUNT(*) FROM content_archive WHERE status = 1 AND priority = 'low';"
          },
          {
            "scenario": "ApprovalLevel=3, SequenceNumber>0",
            "sql": "SELECT COUNT(*) FROM content_archive WHERE status = 1 AND priority = 'low' AND sequence_number = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "TextbookRepo",
        "code_value": "type TextbookRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Textbook",
        "code_value": "type Textbook struct {\n\tTrackingId    string `gorm:\"column:tracking_id\" json:\"tracking_id\"`\n\tTitle         string `gorm:\"column:title\" json:\"title\"`\n\tAuthor        string `gorm:\"column:author\" json:\"author\"`\n\tPublisher     string `gorm:\"column:publisher\" json:\"publisher\"`\n\tPublishedYear int    `gorm:\"column:published_year\" json:\"published_year\"`\n}"
      },
      {
        "code_key": "TextbookActiveTableName",
        "code_value": "const TextbookActiveTableName = \"textbook_active\""
      },
      {
        "code_key": "TextbookArchiveTableName",
        "code_value": "const TextbookArchiveTableName = \"textbook_archive\""
      },
      {
        "code_key": "ArchiveKey",
        "code_value": "const ArchiveKey = \"archive\""
      },
      {
        "code_key": "ActiveKey",
        "code_value": "const ActiveKey = \"active\""
      },
      {
        "code_key": "hints",
        "code_value": "import \"gorm.io/hints\""
      },
      {
        "code_key": "icontext",
        "code_value": "import \"git.woa.com/common/icontext\""
      },
      {
        "code_key": "model",
        "code_value": "import \"git.woa.com/edu/model\""
      },
      {
        "code_key": "utils",
        "code_value": "import \"git.woa.com/common/utils\""
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "MoveToArchive",
    "orm_code": "func (repo *TextbookRepo) MoveToArchive(ctx context.Context, textbook *model.Textbook) error {\n\tarchiveClause := utils.SetSQLComment(ctx, utils.ArchiveKey)\n\tactiveClause := utils.SetSQLComment(ctx, utils.ActiveKey)\n\n\t// Check if textbook exists in active table\n\tvar existingTextbook model.Textbook\n\tif err := repo.db.Clauses(activeClause).Table(model.TextbookActiveTableName).\n\t\tWhere(\"tracking_id = ?\", textbook.TrackingId).\n\t\tFirst(&existingTextbook).Error; err != nil {\n\t\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\t\treturn fmt.Errorf(\"textbook not found\")\n\t\t\t}\n\t\t\treturn err\n\t}\n\n\t// Move to archive\n\tif err := repo.db.Clauses(archiveClause).Table(model.TextbookArchiveTableName).\n\t\tCreate(textbook).Error; err != nil {\n\t\t\treturn err\n\t}\n\n\t// Delete from active\n\tif err := repo.db.Clauses(activeClause).Table(model.TextbookActiveTableName).\n\t\tWhere(\"tracking_id = ?\", textbook.TrackingId).\n\t\tDelete(&model.Textbook{}).Error; err != nil {\n\t\t\treturn err\n\t}\n\n\treturn nil\n}",
    "caller": "func BatchArchiveLowPriority(batchID int) (int64, error) {\n\tlowPriorityBatch := &Forecast{\n\t\tApprovalLevel: 3,\n\t\tSequenceNumber: int64(batchID),\n\t}\n\n\tresult, err := lowPriorityBatch.MoveToArchive()\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"batch archive failed for ID %d: %v\", batchID, err)\n\t}\n\n\tif result == 0 {\n\t\tlog.Printf(\"Warning: No records archived for batch %d\", batchID)\n\t}\n\treturn result, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "batchID > 0",
            "sql": "SELECT COUNT(*) FROM content_archive WHERE status = 1 AND priority = 'low' AND sequence_number = ?;"
          },
          {
            "scenario": "batchID <= 0",
            "sql": "SELECT COUNT(*) FROM content_archive WHERE status = 1 AND priority = 'low';"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "TextbookRepo",
        "code_value": "type TextbookRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Textbook",
        "code_value": "type Textbook struct {\n\tTrackingId    string `gorm:\"column:tracking_id\" json:\"tracking_id\"`\n\tTitle         string `gorm:\"column:title\" json:\"title\"`\n\tAuthor        string `gorm:\"column:author\" json:\"author\"`\n\tPublisher     string `gorm:\"column:publisher\" json:\"publisher\"`\n\tPublishedYear int    `gorm:\"column:published_year\" json:\"published_year\"`\n}"
      },
      {
        "code_key": "TextbookActiveTableName",
        "code_value": "const TextbookActiveTableName = \"textbook_active\""
      },
      {
        "code_key": "TextbookArchiveTableName",
        "code_value": "const TextbookArchiveTableName = \"textbook_archive\""
      },
      {
        "code_key": "ArchiveKey",
        "code_value": "const ArchiveKey = \"archive\""
      },
      {
        "code_key": "ActiveKey",
        "code_value": "const ActiveKey = \"active\""
      },
      {
        "code_key": "hints",
        "code_value": "import \"gorm.io/hints\""
      },
      {
        "code_key": "icontext",
        "code_value": "import \"git.woa.com/common/icontext\""
      },
      {
        "code_key": "model",
        "code_value": "import \"git.woa.com/edu/model\""
      },
      {
        "code_key": "utils",
        "code_value": "import \"git.woa.com/common/utils\""
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "UpdateThemeWeights",
    "orm_code": "func (repo *ThemeRepo) UpdateThemeWeights(ctx context.Context, theme *model.PortfolioTheme) error {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\texisting := &model.PortfolioTheme{}\n\n\tif err := repo.db.Clauses(selectClause).Table(model.ThemeTableName).\n\t\tWhere(\"theme_id = ? AND city = ?\", theme.ThemeId, theme.City).\n\t\tFirst(existing).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif existing.Weight != theme.Weight {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.ThemeTableName).\n\t\t\tWhere(\"id = ?\", existing.Id).\n\t\t\tUpdate(\"weight\", theme.Weight).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "SELECT查询",
            "sql": "SELECT * FROM portfolio_theme WHERE theme_id = ? AND city = ? LIMIT 1;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "UPDATE更新 (当existing.Weight != theme.Weight时)",
            "sql": "UPDATE portfolio_theme SET weight = ? WHERE id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ThemeRepo",
        "code_value": "type ThemeRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "PortfolioTheme",
        "code_value": "type PortfolioTheme struct {\n\tId      int64   `gorm:\"column:id\" json:\"id\"`\n\tThemeId string  `gorm:\"column:theme_id\" json:\"theme_id\"`\n\tCity    string  `gorm:\"column:city\" json:\"city\"`\n\tWeight  float64 `gorm:\"column:weight\" json:\"weight\"`\n}"
      },
      {
        "code_key": "ThemeTableName",
        "code_value": "const ThemeTableName = \"portfolio_theme\""
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (pt *PortfolioTheme) TableName() string {\n\treturn ThemeTableName\n}"
      },
      {
        "code_key": "existingTheme",
        "code_value": "&model.PortfolioTheme{}"
      },
      {
        "code_key": "WeightThreshold",
        "code_value": "const WeightThreshold = 0.01"
      },
      {
        "code_key": "DefaultCity",
        "code_value": "const DefaultCity = \"Shanghai\""
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "UpdateThemeWeights",
    "orm_code": "func (repo *ThemeRepo) UpdateThemeWeights(ctx context.Context, theme *model.PortfolioTheme) error {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\texisting := &model.PortfolioTheme{}\n\n\tif err := repo.db.Clauses(selectClause).Table(model.ThemeTableName).\n\t\tWhere(\"theme_id = ? AND city = ?\", theme.ThemeId, theme.City).\n\t\tFirst(existing).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif existing.Weight != theme.Weight {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.ThemeTableName).\n\t\t\tWhere(\"id = ?\", existing.Id).\n\t\t\tUpdate(\"weight\", theme.Weight).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func HandlePortfolioThemeUpdate(ctx context.Context, themeID string, city string, newWeight float64) error {\n\trepo, err := NewThemeRepo()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create theme repo: %v\", err)\n\t}\n\n\ttheme := &model.PortfolioTheme{\n\t\tThemeId: themeID,\n\t\tCity:    city,\n\t\tWeight:  newWeight,\n\t}\n\n\tif err := repo.UpdateThemeWeights(ctx, theme); err != nil {\n\t\treturn fmt.Errorf(\"failed to update theme weights: %v\", err)\n\t}\n\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "SELECT query to check existing theme",
            "sql": "SELECT * FROM portfolio_theme WHERE theme_id = ? AND city = ? LIMIT 1;"
          },
          {
            "scenario": "UPDATE query when weights differ",
            "sql": "UPDATE portfolio_theme SET weight = ? WHERE id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "ThemeRepo",
        "code_value": "type ThemeRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "PortfolioTheme",
        "code_value": "type PortfolioTheme struct {\n\tId      int64   `gorm:\"column:id\" json:\"id\"`\n\tThemeId string  `gorm:\"column:theme_id\" json:\"theme_id\"`\n\tCity    string  `gorm:\"column:city\" json:\"city\"`\n\tWeight  float64 `gorm:\"column:weight\" json:\"weight\"`\n}"
      },
      {
        "code_key": "ThemeTableName",
        "code_value": "const ThemeTableName = \"portfolio_theme\""
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (pt *PortfolioTheme) TableName() string {\n\treturn ThemeTableName\n}"
      },
      {
        "code_key": "existingTheme",
        "code_value": "&model.PortfolioTheme{}"
      },
      {
        "code_key": "WeightThreshold",
        "code_value": "const WeightThreshold = 0.01"
      },
      {
        "code_key": "DefaultCity",
        "code_value": "const DefaultCity = \"Shanghai\""
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "UpdateThemeWeights",
    "orm_code": "func (repo *ThemeRepo) UpdateThemeWeights(ctx context.Context, theme *model.PortfolioTheme) error {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\texisting := &model.PortfolioTheme{}\n\n\tif err := repo.db.Clauses(selectClause).Table(model.ThemeTableName).\n\t\tWhere(\"theme_id = ? AND city = ?\", theme.ThemeId, theme.City).\n\t\tFirst(existing).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif existing.Weight != theme.Weight {\n\t\tif err := repo.db.Clauses(updateClause).Table(model.ThemeTableName).\n\t\t\tWhere(\"id = ?\", existing.Id).\n\t\t\tUpdate(\"weight\", theme.Weight).Error; err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "caller": "func ProcessThemeAdjustment(ctx context.Context, adjustment *model.ThemeAdjustment) error {\n\tdb := conf.GetDBEngine()\n\tif db == nil {\n\t\treturn fmt.Errorf(\"database engine not available\")\n\t}\n\n\trepo := &ThemeRepo{db: db}\n\ttheme := &model.PortfolioTheme{\n\t\tThemeId: adjustment.ID,\n\t\tCity:    adjustment.Location,\n\t\tWeight:  adjustment.TargetWeight,\n\t}\n\n\tif err := repo.UpdateThemeWeights(ctx, theme); err != nil {\n\t\treturn fmt.Errorf(\"theme adjustment failed: %v\", err)\n\t}\n\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "权重未变化，仅执行查询SQL",
            "sql": "SELECT id, theme_id, city, weight FROM portfolio_theme WHERE theme_id = ? AND city = ? LIMIT 1;"
          },
          {
            "scenario": "权重变化，执行查询和更新SQL",
            "sql": "SELECT id, theme_id, city, weight FROM portfolio_theme WHERE theme_id = ? AND city = ? LIMIT 1; UPDATE portfolio_theme SET weight = ? WHERE id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "ThemeRepo",
        "code_value": "type ThemeRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "PortfolioTheme",
        "code_value": "type PortfolioTheme struct {\n\tId      int64   `gorm:\"column:id\" json:\"id\"`\n\tThemeId string  `gorm:\"column:theme_id\" json:\"theme_id\"`\n\tCity    string  `gorm:\"column:city\" json:\"city\"`\n\tWeight  float64 `gorm:\"column:weight\" json:\"weight\"`\n}"
      },
      {
        "code_key": "ThemeTableName",
        "code_value": "const ThemeTableName = \"portfolio_theme\""
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"SELECT\""
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "TableName",
        "code_value": "func (pt *PortfolioTheme) TableName() string {\n\treturn ThemeTableName\n}"
      },
      {
        "code_key": "existingTheme",
        "code_value": "&model.PortfolioTheme{}"
      },
      {
        "code_key": "WeightThreshold",
        "code_value": "const WeightThreshold = 0.01"
      },
      {
        "code_key": "DefaultCity",
        "code_value": "const DefaultCity = \"Shanghai\""
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "LogActivity",
    "orm_code": "func (repo *ActivityRepo) LogActivity(ctx context.Context, activity *model.Exam) error {\n    selectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n    insertClause := utils.SetSQLComment(ctx, utils.InsertKey)\n    \n    existing := &model.Exam{}\n    if err := repo.db.Clauses(selectClause).Table(model.ExamTableName).\n        Where(\"topic = ? AND function_name = ?\", activity.Topic, activity.FunctionName).\n        First(existing).Error; err != nil {\n        \n        if errors.Is(err, gorm.ErrRecordNotFound) {\n            return repo.db.Clauses(insertClause).Table(model.ExamTableName).\n                Create(activity).Error\n        }\n        return err\n    }\n    \n    if existing.DiscountRate != activity.DiscountRate {\n        return repo.db.Table(model.ExamTableName).\n            Where(\"id = ?\", existing.Id).\n            Update(\"discount_rate\", activity.DiscountRate).Error\n    }\n    return nil\n}",
    "caller": "",
    "sql_statement_list": [
      "{\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\n        \"scenario\": \"记录不存在时，执行SELECT查询后执行INSERT\",\n        \"sql\": [\n          \"SELECT id, topic, function_name, discount_rate FROM ivc_exam_records WHERE topic = ? AND function_name = ? LIMIT 1;\",\n          \"INSERT INTO ivc_exam_records (id, topic, function_name, discount_rate) VALUES (?, ?, ?, ?);\"\n        ]\n      }",
      "SELECT查询后执行INSERT\",\n        \"sql\": [\n          \"SELECT id, topic, function_name, discount_rate FROM ivc_exam_records WHERE topic = ? AND function_name = ? LIMIT 1;",
      "INSERT INTO ivc_exam_records (id, topic, function_name, discount_rate) VALUES (?, ?, ?, ?);",
      "SELECT查询后执行UPDATE\",\n        \"sql\": [\n          \"SELECT id, topic, function_name, discount_rate FROM ivc_exam_records WHERE topic = ? AND function_name = ? LIMIT 1;",
      "UPDATE ivc_exam_records SET discount_rate = ? WHERE id = ?;",
      "SELECT查询\",\n        \"sql\": \"SELECT id, topic, function_name, discount_rate FROM ivc_exam_records WHERE topic = ? AND function_name = ? LIMIT 1;"
    ],
    "sql_types": [
      "OTHER",
      "SELECT",
      "INSERT",
      "SELECT",
      "UPDATE",
      "SELECT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "ActivityRepo",
        "code_value": "type ActivityRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Exam",
        "code_value": "type Exam struct {\n\tId           int64   `gorm:\"column:id\" json:\"id\"`\n\tTopic        string  `gorm:\"column:topic\" json:\"topic\"`\n\tFunctionName string  `gorm:\"column:function_name\" json:\"function_name\"`\n\tDiscountRate float64 `gorm:\"column:discount_rate\" json:\"discount_rate\"`\n}"
      },
      {
        "code_key": "ExamTableName",
        "code_value": "const ExamTableName = \"ivc_exam_records\""
      },
      {
        "code_key": "selectClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SelectKey)"
      },
      {
        "code_key": "insertClause",
        "code_value": "utils.SetSQLComment(ctx, utils.InsertKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-exam-system/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) hints.Hints {\n\tcommentInfo := icontext.GetSQLCommentFromContext(ctx)\n\tif len(commentInfo.ReqId) < 16 {\n\t\tcommentInfo.ReqId = uuid.NewString()\n\t}\n\n\tcomment := fmt.Sprintf(\"system=exam,app=%v,uin=%v,action=%v,reqid=%v\", \n\t\tcommentInfo.AppId, commentInfo.OwnerUin, commentInfo.Action, commentInfo.ReqId)\n\treturn hints.CommentBefore(clause, comment)\n}"
      },
      {
        "code_key": "existingExam",
        "code_value": "&model.Exam{}"
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "LogActivity",
    "orm_code": "func (repo *ActivityRepo) LogActivity(ctx context.Context, activity *model.Exam) error {\n    selectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n    insertClause := utils.SetSQLComment(ctx, utils.InsertKey)\n    \n    existing := &model.Exam{}\n    if err := repo.db.Clauses(selectClause).Table(model.ExamTableName).\n        Where(\"topic = ? AND function_name = ?\", activity.Topic, activity.FunctionName).\n        First(existing).Error; err != nil {\n        \n        if errors.Is(err, gorm.ErrRecordNotFound) {\n            return repo.db.Clauses(insertClause).Table(model.ExamTableName).\n                Create(activity).Error\n        }\n        return err\n    }\n    \n    if existing.DiscountRate != activity.DiscountRate {\n        return repo.db.Table(model.ExamTableName).\n            Where(\"id = ?\", existing.Id).\n            Update(\"discount_rate\", activity.DiscountRate).Error\n    }\n    return nil\n}",
    "caller": "func HandleExamDiscount(ctx context.Context, topic string, fnName string, rate float64) error {\n    repo := &ActivityRepo{db: GetDB()}\n    exam := &model.Exam{\n        Topic:        topic,\n        FunctionName: fnName,\n        DiscountRate: rate,\n    }\n    return repo.LogActivity(ctx, exam)\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "SELECT query for existing record",
            "sql": "SELECT id, topic, function_name, discount_rate FROM ivc_exam_records WHERE topic = ? AND function_name = ? LIMIT 1;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "INSERT new record when not exists",
            "sql": "INSERT INTO ivc_exam_records (topic, function_name, discount_rate) VALUES (?, ?, ?);"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "UPDATE existing record when discount_rate differs",
            "sql": "UPDATE ivc_exam_records SET discount_rate = ? WHERE id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ActivityRepo",
        "code_value": "type ActivityRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Exam",
        "code_value": "type Exam struct {\n\tId           int64   `gorm:\"column:id\" json:\"id\"`\n\tTopic        string  `gorm:\"column:topic\" json:\"topic\"`\n\tFunctionName string  `gorm:\"column:function_name\" json:\"function_name\"`\n\tDiscountRate float64 `gorm:\"column:discount_rate\" json:\"discount_rate\"`\n}"
      },
      {
        "code_key": "ExamTableName",
        "code_value": "const ExamTableName = \"ivc_exam_records\""
      },
      {
        "code_key": "selectClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SelectKey)"
      },
      {
        "code_key": "insertClause",
        "code_value": "utils.SetSQLComment(ctx, utils.InsertKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-exam-system/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) hints.Hints {\n\tcommentInfo := icontext.GetSQLCommentFromContext(ctx)\n\tif len(commentInfo.ReqId) < 16 {\n\t\tcommentInfo.ReqId = uuid.NewString()\n\t}\n\n\tcomment := fmt.Sprintf(\"system=exam,app=%v,uin=%v,action=%v,reqid=%v\", \n\t\tcommentInfo.AppId, commentInfo.OwnerUin, commentInfo.Action, commentInfo.ReqId)\n\treturn hints.CommentBefore(clause, comment)\n}"
      },
      {
        "code_key": "existingExam",
        "code_value": "&model.Exam{}"
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "LogActivity",
    "orm_code": "func (repo *ActivityRepo) LogActivity(ctx context.Context, activity *model.Exam) error {\n    selectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n    insertClause := utils.SetSQLComment(ctx, utils.InsertKey)\n    \n    existing := &model.Exam{}\n    if err := repo.db.Clauses(selectClause).Table(model.ExamTableName).\n        Where(\"topic = ? AND function_name = ?\", activity.Topic, activity.FunctionName).\n        First(existing).Error; err != nil {\n        \n        if errors.Is(err, gorm.ErrRecordNotFound) {\n            return repo.db.Clauses(insertClause).Table(model.ExamTableName).\n                Create(activity).Error\n        }\n        return err\n    }\n    \n    if existing.DiscountRate != activity.DiscountRate {\n        return repo.db.Table(model.ExamTableName).\n            Where(\"id = ?\", existing.Id).\n            Update(\"discount_rate\", activity.DiscountRate).Error\n    }\n    return nil\n}",
    "caller": "func ProcessLearningActivity(ctx context.Context, learningData *model.LearningData) error {\n    activityRepo := NewActivityRepo(GetDB())\n    exam := &model.Exam{\n        Topic:        learningData.CourseID,\n        FunctionName: \"course_completion\",\n        DiscountRate: learningData.Discount,\n    }\n    if err := activityRepo.LogActivity(ctx, exam); err != nil {\n        log.Printf(\"Failed to log activity: %v\", err)\n        return err\n    }\n    return nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "SELECT查询检查记录是否存在",
            "sql": "SELECT /*+ system=exam,app=?,uin=?,action=?,reqid=? */ id, topic, function_name, discount_rate FROM ivc_exam_records WHERE topic = ? AND function_name = 'course_completion' LIMIT 1;"
          },
          {
            "scenario": "记录不存在时执行INSERT操作",
            "sql": "INSERT /*+ system=exam,app=?,uin=?,action=?,reqid=? */ INTO ivc_exam_records (topic, function_name, discount_rate) VALUES (?, 'course_completion', ?);"
          },
          {
            "scenario": "记录存在但discount_rate不同时执行UPDATE操作",
            "sql": "UPDATE ivc_exam_records SET discount_rate = ? WHERE id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "ActivityRepo",
        "code_value": "type ActivityRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Exam",
        "code_value": "type Exam struct {\n\tId           int64   `gorm:\"column:id\" json:\"id\"`\n\tTopic        string  `gorm:\"column:topic\" json:\"topic\"`\n\tFunctionName string  `gorm:\"column:function_name\" json:\"function_name\"`\n\tDiscountRate float64 `gorm:\"column:discount_rate\" json:\"discount_rate\"`\n}"
      },
      {
        "code_key": "ExamTableName",
        "code_value": "const ExamTableName = \"ivc_exam_records\""
      },
      {
        "code_key": "selectClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SelectKey)"
      },
      {
        "code_key": "insertClause",
        "code_value": "utils.SetSQLComment(ctx, utils.InsertKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/IVC/ivc-exam-system/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) hints.Hints {\n\tcommentInfo := icontext.GetSQLCommentFromContext(ctx)\n\tif len(commentInfo.ReqId) < 16 {\n\t\tcommentInfo.ReqId = uuid.NewString()\n\t}\n\n\tcomment := fmt.Sprintf(\"system=exam,app=%v,uin=%v,action=%v,reqid=%v\", \n\t\tcommentInfo.AppId, commentInfo.OwnerUin, commentInfo.Action, commentInfo.ReqId)\n\treturn hints.CommentBefore(clause, comment)\n}"
      },
      {
        "code_key": "existingExam",
        "code_value": "&model.Exam{}"
      }
    ],
    "sql_pattern_cnt": 3
  },
  {
    "function_name": "DetectFraud",
    "orm_code": "func (repo *FraudDetectionRepo) DetectFraud(ctx context.Context, invoice *model.Invoice) (bool, error) {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tthreshold := model.FraudDetectionThreshold\n\t\n\texistingInvoice := &model.Invoice{}\n\tif err := repo.db.Clauses(selectClause).Table(model.InvoiceTableName).\n\t\tWhere(\"reference_code = ?\", invoice.ReferenceCode).\n\t\tFirst(existingInvoice).Error; err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\t\n\tif existingInvoice.Amount > threshold && existingInvoice.Amount != invoice.Amount {\n\t\treturn true, nil\n\t}\n\t\n\treturn false, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "查询指定reference_code的发票记录",
            "sql": "SELECT id, reference_code, amount, status, created_at FROM finance_invoice WHERE reference_code = ? ORDER BY id LIMIT 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "FraudDetectionRepo",
        "code_value": "type FraudDetectionRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "InvoiceTableName",
        "code_value": "const InvoiceTableName = \"finance_invoice\""
      },
      {
        "code_key": "FraudDetectionThreshold",
        "code_value": "const FraudDetectionThreshold = 10000.00"
      },
      {
        "code_key": "Invoice",
        "code_value": "type Invoice struct {\n\tID           int64   `gorm:\"column:id\" json:\"id\"`\n\tReferenceCode string  `gorm:\"column:reference_code\" json:\"reference_code\"`\n\tAmount       float64 `gorm:\"column:amount\" json:\"amount\"`\n\tStatus       int     `gorm:\"column:status\" json:\"status\"`\n\tCreatedAt    int64   `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (i *Invoice) TableName() string {\n\treturn InvoiceTableName\n}"
      },
      {
        "code_key": "InvoiceStatus",
        "code_value": "const (\n\tInvoiceStatusPending = 1\n\tInvoiceStatusPaid = 2\n\tInvoiceStatusCancelled = 3\n)"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/Finance/fraud-detection/pkg/utils"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"select\""
      },
      {
        "code_key": "FraudDetectionConfig",
        "code_value": "type FraudDetectionConfig struct {\n\tThreshold float64 `json:\"threshold\"`\n\tEnabled   bool    `json:\"enabled\"`\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "DetectFraud",
    "orm_code": "func (repo *FraudDetectionRepo) DetectFraud(ctx context.Context, invoice *model.Invoice) (bool, error) {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tthreshold := model.FraudDetectionThreshold\n\t\n\texistingInvoice := &model.Invoice{}\n\tif err := repo.db.Clauses(selectClause).Table(model.InvoiceTableName).\n\t\tWhere(\"reference_code = ?\", invoice.ReferenceCode).\n\t\tFirst(existingInvoice).Error; err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\t\n\tif existingInvoice.Amount > threshold && existingInvoice.Amount != invoice.Amount {\n\t\treturn true, nil\n\t}\n\t\n\treturn false, nil\n}",
    "caller": "func ProcessInvoicePayment(ctx context.Context, paymentReq *model.PaymentRequest, logger *zap.Logger) (bool, error) {\n\tfraudRepo, err := data.NewFraudDetectionRepo()\n\tif err != nil {\n\t\tlogger.Error(\"failed to initialize fraud detection repo\", zap.Error(err))\n\t\treturn false, err\n\t}\n\n\tinvoice := &model.Invoice{\n\t\tReferenceCode: paymentReq.InvoiceID,\n\t\tAmount:       paymentReq.Amount,\n\t}\n\n\tisFraud, err := fraudRepo.DetectFraud(ctx, invoice)\n\tif err != nil {\n\t\tlogger.Error(\"fraud detection failed\", zap.Error(err))\n\t\treturn false, err\n\t}\n\treturn isFraud, nil\n}",
    "sql_statement_list": [
      "SELECT finance_invoice.id, finance_invoice.reference_code, finance_invoice.amount, finance_invoice.status, finance_invoice.created_at FROM finance_invoice WHERE finance_invoice.reference_code = ? ORDER BY finance_invoice.id LIMIT 1;"
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "FraudDetectionRepo",
        "code_value": "type FraudDetectionRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "InvoiceTableName",
        "code_value": "const InvoiceTableName = \"finance_invoice\""
      },
      {
        "code_key": "FraudDetectionThreshold",
        "code_value": "const FraudDetectionThreshold = 10000.00"
      },
      {
        "code_key": "Invoice",
        "code_value": "type Invoice struct {\n\tID           int64   `gorm:\"column:id\" json:\"id\"`\n\tReferenceCode string  `gorm:\"column:reference_code\" json:\"reference_code\"`\n\tAmount       float64 `gorm:\"column:amount\" json:\"amount\"`\n\tStatus       int     `gorm:\"column:status\" json:\"status\"`\n\tCreatedAt    int64   `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (i *Invoice) TableName() string {\n\treturn InvoiceTableName\n}"
      },
      {
        "code_key": "InvoiceStatus",
        "code_value": "const (\n\tInvoiceStatusPending = 1\n\tInvoiceStatusPaid = 2\n\tInvoiceStatusCancelled = 3\n)"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/Finance/fraud-detection/pkg/utils"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"select\""
      },
      {
        "code_key": "FraudDetectionConfig",
        "code_value": "type FraudDetectionConfig struct {\n\tThreshold float64 `json:\"threshold\"`\n\tEnabled   bool    `json:\"enabled\"`\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "DetectFraud",
    "orm_code": "func (repo *FraudDetectionRepo) DetectFraud(ctx context.Context, invoice *model.Invoice) (bool, error) {\n\tselectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n\tthreshold := model.FraudDetectionThreshold\n\t\n\texistingInvoice := &model.Invoice{}\n\tif err := repo.db.Clauses(selectClause).Table(model.InvoiceTableName).\n\t\tWhere(\"reference_code = ?\", invoice.ReferenceCode).\n\t\tFirst(existingInvoice).Error; err != nil {\n\t\tif err == gorm.ErrRecordNotFound {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\t\n\tif existingInvoice.Amount > threshold && existingInvoice.Amount != invoice.Amount {\n\t\treturn true, nil\n\t}\n\t\n\treturn false, nil\n}",
    "caller": "func VerifyInvoiceForRefund(ctx context.Context, refundDetail *model.RefundDetail) (bool, error) {\n\tdbEngine := conf.GetDBEngine()\n\tif dbEngine == nil {\n\t\treturn false, errors.New(\"database engine not initialized\")\n\t}\n\n\tfraudRepo := &data.FraudDetectionRepo{db: dbEngine}\n\tinvoice := &model.Invoice{\n\t\tReferenceCode: refundDetail.OriginalInvoiceID,\n\t\tAmount:       refundDetail.RefundAmount,\n\t}\n\n\treturn fraudRepo.DetectFraud(ctx, invoice)",
    "sql_statement_list": [
      "SELECT id, reference_code, amount, status, created_at FROM finance_invoice WHERE reference_code = ? LIMIT 1;"
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "FraudDetectionRepo",
        "code_value": "type FraudDetectionRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "InvoiceTableName",
        "code_value": "const InvoiceTableName = \"finance_invoice\""
      },
      {
        "code_key": "FraudDetectionThreshold",
        "code_value": "const FraudDetectionThreshold = 10000.00"
      },
      {
        "code_key": "Invoice",
        "code_value": "type Invoice struct {\n\tID           int64   `gorm:\"column:id\" json:\"id\"`\n\tReferenceCode string  `gorm:\"column:reference_code\" json:\"reference_code\"`\n\tAmount       float64 `gorm:\"column:amount\" json:\"amount\"`\n\tStatus       int     `gorm:\"column:status\" json:\"status\"`\n\tCreatedAt    int64   `gorm:\"column:created_at\" json:\"created_at\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (i *Invoice) TableName() string {\n\treturn InvoiceTableName\n}"
      },
      {
        "code_key": "InvoiceStatus",
        "code_value": "const (\n\tInvoiceStatusPending = 1\n\tInvoiceStatusPaid = 2\n\tInvoiceStatusCancelled = 3\n)"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/Finance/fraud-detection/pkg/utils"
      },
      {
        "code_key": "SelectKey",
        "code_value": "const SelectKey = \"select\""
      },
      {
        "code_key": "FraudDetectionConfig",
        "code_value": "type FraudDetectionConfig struct {\n\tThreshold float64 `json:\"threshold\"`\n\tEnabled   bool    `json:\"enabled\"`\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ValidateByRules",
    "orm_code": "func (repo *CertificationRepo) ValidateByRules(ctx context.Context, cert *model.CertificationRecord) (bool, error) {\n\tvalidationClause := utils.SetSQLComment(ctx, utils.ValidationKey)\n\tvar existingCert model.CertificationRecord\n\n\tif err := repo.db.Clauses(validationClause).Table(model.CertificationTableName).\n\t\tWhere(\"license_key = ?\", cert.LicenseKey).\n\t\tFirst(&existingCert).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif existingCert.ExpiryDate < time.Now().Unix() {\n\t\treturn false, nil\n\t}\n\n\tif existingCert.LocationCode != cert.LocationCode {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "RuleType = 'privacy'",
            "sql": "SELECT id, status, is_private, is_secure, is_legal, deadline_date FROM compliance_records WHERE status = 1 AND is_private = 1 AND deadline_date >= ?;"
          },
          {
            "scenario": "RuleType = 'security'",
            "sql": "SELECT id, status, is_private, is_secure, is_legal, deadline_date FROM compliance_records WHERE status = 1 AND is_secure = 1 AND deadline_date >= ?;"
          },
          {
            "scenario": "RuleType = 'legal'",
            "sql": "SELECT id, status, is_private, is_secure, is_legal, deadline_date FROM compliance_records WHERE status = 1 AND is_legal = 1 AND deadline_date >= ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "CertificationRepo",
        "code_value": "type CertificationRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "CertificationRecord",
        "code_value": "type CertificationRecord struct {\n\tID           int64  `gorm:\"column:id\" json:\"id\"`\n\tLicenseKey   string `gorm:\"column:license_key\" json:\"license_key\"`\n\tExpiryDate   int64  `gorm:\"column:expiry_date\" json:\"expiry_date\"`\n\tLocationCode string `gorm:\"column:location_code\" json:\"location_code\"`\n}"
      },
      {
        "code_key": "CertificationTableName",
        "code_value": "const CertificationTableName = \"certification_records\""
      },
      {
        "code_key": "ValidationKey",
        "code_value": "const ValidationKey = \"VALIDATION\""
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/common/pkg/utils"
      },
      {
        "code_key": "ValidationResult",
        "code_value": "type ValidationResult struct {\n\tIsValid bool\n\tError   error\n}"
      },
      {
        "code_key": "TimeUtils",
        "code_value": "var TimeUtils = struct {\n\tNow func() time.Time\n}{\n\tNow: time.Now,\n}"
      },
      {
        "code_key": "ErrorMessages",
        "code_value": "var ErrorMessages = map[string]string{\n\t\"INVALID_LICENSE\": \"License key is invalid\",\n\t\"EXPIRED\":        \"License has expired\",\n\t\"LOCATION_MISMATCH\": \"Location code does not match\"\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ValidateByRules",
    "orm_code": "func (repo *CertificationRepo) ValidateByRules(ctx context.Context, cert *model.CertificationRecord) (bool, error) {\n\tvalidationClause := utils.SetSQLComment(ctx, utils.ValidationKey)\n\tvar existingCert model.CertificationRecord\n\n\tif err := repo.db.Clauses(validationClause).Table(model.CertificationTableName).\n\t\tWhere(\"license_key = ?\", cert.LicenseKey).\n\t\tFirst(&existingCert).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif existingCert.ExpiryDate < time.Now().Unix() {\n\t\treturn false, nil\n\t}\n\n\tif existingCert.LocationCode != cert.LocationCode {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "caller": "func HandleLicenseVerification(ctx context.Context, licenseKey string, locCode string) (bool, error) {\n\trepo, err := NewCertificationRepo()\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"failed to init repo: %v\", err)\n\t}\n\n\tcertRecord := &model.CertificationRecord{\n\t\tLicenseKey:   licenseKey,\n\t\tLocationCode: locCode,\n\t}\n\n\tisValid, err := repo.ValidateByRules(ctx, certRecord)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"validation failed: %v\", err)\n\t}\n\n\treturn isValid, nil\n}",
    "sql_statement_list": [
      "SELECT id, license_key, expiry_date, location_code FROM certification_records WHERE license_key = ? LIMIT 1;"
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "CertificationRepo",
        "code_value": "type CertificationRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "CertificationRecord",
        "code_value": "type CertificationRecord struct {\n\tID           int64  `gorm:\"column:id\" json:\"id\"`\n\tLicenseKey   string `gorm:\"column:license_key\" json:\"license_key\"`\n\tExpiryDate   int64  `gorm:\"column:expiry_date\" json:\"expiry_date\"`\n\tLocationCode string `gorm:\"column:location_code\" json:\"location_code\"`\n}"
      },
      {
        "code_key": "CertificationTableName",
        "code_value": "const CertificationTableName = \"certification_records\""
      },
      {
        "code_key": "ValidationKey",
        "code_value": "const ValidationKey = \"VALIDATION\""
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/common/pkg/utils"
      },
      {
        "code_key": "ValidationResult",
        "code_value": "type ValidationResult struct {\n\tIsValid bool\n\tError   error\n}"
      },
      {
        "code_key": "TimeUtils",
        "code_value": "var TimeUtils = struct {\n\tNow func() time.Time\n}{\n\tNow: time.Now,\n}"
      },
      {
        "code_key": "ErrorMessages",
        "code_value": "var ErrorMessages = map[string]string{\n\t\"INVALID_LICENSE\": \"License key is invalid\",\n\t\"EXPIRED\":        \"License has expired\",\n\t\"LOCATION_MISMATCH\": \"Location code does not match\"\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ValidateByRules",
    "orm_code": "func (repo *CertificationRepo) ValidateByRules(ctx context.Context, cert *model.CertificationRecord) (bool, error) {\n\tvalidationClause := utils.SetSQLComment(ctx, utils.ValidationKey)\n\tvar existingCert model.CertificationRecord\n\n\tif err := repo.db.Clauses(validationClause).Table(model.CertificationTableName).\n\t\tWhere(\"license_key = ?\", cert.LicenseKey).\n\t\tFirst(&existingCert).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif existingCert.ExpiryDate < time.Now().Unix() {\n\t\treturn false, nil\n\t}\n\n\tif existingCert.LocationCode != cert.LocationCode {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "caller": "func BatchCheckCertifications(ctx context.Context, certs []*model.CertificationRecord) ([]bool, error) {\n\trepo, err := NewCertificationRepo()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresults := make([]bool, len(certs))\n\tfor i, cert := range certs {\n\t\tvalid, err := repo.ValidateByRules(ctx, cert)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresults[i] = valid\n\t}\n\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "根据license_key查询certification_records表",
            "sql": "SELECT * FROM certification_records WHERE license_key = ? LIMIT 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "CertificationRepo",
        "code_value": "type CertificationRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "CertificationRecord",
        "code_value": "type CertificationRecord struct {\n\tID           int64  `gorm:\"column:id\" json:\"id\"`\n\tLicenseKey   string `gorm:\"column:license_key\" json:\"license_key\"`\n\tExpiryDate   int64  `gorm:\"column:expiry_date\" json:\"expiry_date\"`\n\tLocationCode string `gorm:\"column:location_code\" json:\"location_code\"`\n}"
      },
      {
        "code_key": "CertificationTableName",
        "code_value": "const CertificationTableName = \"certification_records\""
      },
      {
        "code_key": "ValidationKey",
        "code_value": "const ValidationKey = \"VALIDATION\""
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/common/pkg/utils"
      },
      {
        "code_key": "ValidationResult",
        "code_value": "type ValidationResult struct {\n\tIsValid bool\n\tError   error\n}"
      },
      {
        "code_key": "TimeUtils",
        "code_value": "var TimeUtils = struct {\n\tNow func() time.Time\n}{\n\tNow: time.Now,\n}"
      },
      {
        "code_key": "ErrorMessages",
        "code_value": "var ErrorMessages = map[string]string{\n\t\"INVALID_LICENSE\": \"License key is invalid\",\n\t\"EXPIRED\":        \"License has expired\",\n\t\"LOCATION_MISMATCH\": \"Location code does not match\"\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ValidateByRules",
    "orm_code": "func (repo *CertificationRepo) ValidateByRules(ctx context.Context, cert *model.CertificationRecord) (bool, error) {\n\tvalidationClause := utils.SetSQLComment(ctx, utils.ValidationKey)\n\tvar existingCert model.CertificationRecord\n\n\tif err := repo.db.Clauses(validationClause).Table(model.CertificationTableName).\n\t\tWhere(\"license_key = ?\", cert.LicenseKey).\n\t\tFirst(&existingCert).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif existingCert.ExpiryDate < time.Now().Unix() {\n\t\treturn false, nil\n\t}\n\n\tif existingCert.LocationCode != cert.LocationCode {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "caller": "func HandlePrivacyCompliance() (bool, error) {\n\tchecker := &Scanner{RuleType: \"privacy\"}\n\tisValid, err := checker.ValidateByRules()\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"privacy validation failed: %v\", err)\n\t}\n\treturn isValid, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "RuleType is privacy",
            "sql": "SELECT id, status, is_private, is_secure, is_legal, deadline_date FROM compliance_records WHERE status = 1 AND is_private = 1 AND deadline_date >= '2023-11-15 10:00:00';"
          },
          {
            "scenario": "RuleType is security",
            "sql": "SELECT id, status, is_private, is_secure, is_legal, deadline_date FROM compliance_records WHERE status = 1 AND is_secure = 1 AND deadline_date >= '2023-11-15 10:00:00';"
          },
          {
            "scenario": "RuleType is legal",
            "sql": "SELECT id, status, is_private, is_secure, is_legal, deadline_date FROM compliance_records WHERE status = 1 AND is_legal = 1 AND deadline_date >= '2023-11-15 10:00:00';"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "CertificationRepo",
        "code_value": "type CertificationRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "CertificationRecord",
        "code_value": "type CertificationRecord struct {\n\tID           int64  `gorm:\"column:id\" json:\"id\"`\n\tLicenseKey   string `gorm:\"column:license_key\" json:\"license_key\"`\n\tExpiryDate   int64  `gorm:\"column:expiry_date\" json:\"expiry_date\"`\n\tLocationCode string `gorm:\"column:location_code\" json:\"location_code\"`\n}"
      },
      {
        "code_key": "CertificationTableName",
        "code_value": "const CertificationTableName = \"certification_records\""
      },
      {
        "code_key": "ValidationKey",
        "code_value": "const ValidationKey = \"VALIDATION\""
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/common/pkg/utils"
      },
      {
        "code_key": "ValidationResult",
        "code_value": "type ValidationResult struct {\n\tIsValid bool\n\tError   error\n}"
      },
      {
        "code_key": "TimeUtils",
        "code_value": "var TimeUtils = struct {\n\tNow func() time.Time\n}{\n\tNow: time.Now,\n}"
      },
      {
        "code_key": "ErrorMessages",
        "code_value": "var ErrorMessages = map[string]string{\n\t\"INVALID_LICENSE\": \"License key is invalid\",\n\t\"EXPIRED\":        \"License has expired\",\n\t\"LOCATION_MISMATCH\": \"Location code does not match\"\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ValidateByRules",
    "orm_code": "func (repo *CertificationRepo) ValidateByRules(ctx context.Context, cert *model.CertificationRecord) (bool, error) {\n\tvalidationClause := utils.SetSQLComment(ctx, utils.ValidationKey)\n\tvar existingCert model.CertificationRecord\n\n\tif err := repo.db.Clauses(validationClause).Table(model.CertificationTableName).\n\t\tWhere(\"license_key = ?\", cert.LicenseKey).\n\t\tFirst(&existingCert).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif existingCert.ExpiryDate < time.Now().Unix() {\n\t\treturn false, nil\n\t}\n\n\tif existingCert.LocationCode != cert.LocationCode {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "caller": "func HandleSecurityAudit() {\n\tauditor := &Scanner{RuleType: \"security\"}\n\tpassed, err := auditor.ValidateByRules()\n\tif err != nil {\n\t\tlog.Printf(\"Security audit error: %v\\n\", err)\n\t\treturn\n\t}\n\tif passed {\n\t\tfmt.Println(\"Security requirements met\")\n\t} else {\n\t\tfmt.Println(\"Security requirements not satisfied\")\n\t}\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "privacy rule type",
            "sql": "SELECT id, status, is_private, is_secure, is_legal, deadline_date FROM compliance_records WHERE status = 1 AND is_private = 1 AND deadline_date >= ?;"
          },
          {
            "scenario": "security rule type",
            "sql": "SELECT id, status, is_private, is_secure, is_legal, deadline_date FROM compliance_records WHERE status = 1 AND is_secure = 1 AND deadline_date >= ?;"
          },
          {
            "scenario": "legal rule type",
            "sql": "SELECT id, status, is_private, is_secure, is_legal, deadline_date FROM compliance_records WHERE status = 1 AND is_legal = 1 AND deadline_date >= ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "CertificationRepo",
        "code_value": "type CertificationRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "CertificationRecord",
        "code_value": "type CertificationRecord struct {\n\tID           int64  `gorm:\"column:id\" json:\"id\"`\n\tLicenseKey   string `gorm:\"column:license_key\" json:\"license_key\"`\n\tExpiryDate   int64  `gorm:\"column:expiry_date\" json:\"expiry_date\"`\n\tLocationCode string `gorm:\"column:location_code\" json:\"location_code\"`\n}"
      },
      {
        "code_key": "CertificationTableName",
        "code_value": "const CertificationTableName = \"certification_records\""
      },
      {
        "code_key": "ValidationKey",
        "code_value": "const ValidationKey = \"VALIDATION\""
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/common/pkg/utils"
      },
      {
        "code_key": "ValidationResult",
        "code_value": "type ValidationResult struct {\n\tIsValid bool\n\tError   error\n}"
      },
      {
        "code_key": "TimeUtils",
        "code_value": "var TimeUtils = struct {\n\tNow func() time.Time\n}{\n\tNow: time.Now,\n}"
      },
      {
        "code_key": "ErrorMessages",
        "code_value": "var ErrorMessages = map[string]string{\n\t\"INVALID_LICENSE\": \"License key is invalid\",\n\t\"EXPIRED\":        \"License has expired\",\n\t\"LOCATION_MISMATCH\": \"Location code does not match\"\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ValidateByRules",
    "orm_code": "func (repo *CertificationRepo) ValidateByRules(ctx context.Context, cert *model.CertificationRecord) (bool, error) {\n\tvalidationClause := utils.SetSQLComment(ctx, utils.ValidationKey)\n\tvar existingCert model.CertificationRecord\n\n\tif err := repo.db.Clauses(validationClause).Table(model.CertificationTableName).\n\t\tWhere(\"license_key = ?\", cert.LicenseKey).\n\t\tFirst(&existingCert).Error; err != nil {\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\tif existingCert.ExpiryDate < time.Now().Unix() {\n\t\treturn false, nil\n\t}\n\n\tif existingCert.LocationCode != cert.LocationCode {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}",
    "caller": "func CheckLegalDocuments() bool {\n\tvalidator := &Scanner{RuleType: \"legal\"}\n\tvalid, err := validator.ValidateByRules()\n\tif err != nil {\n\t\tlog.Println(\"Legal document check failed:\", err)\n\t\treturn false\n\t}\n\treturn valid\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "RuleType is legal",
            "sql": "SELECT id, status, is_private, is_secure, is_legal, deadline_date FROM compliance_records WHERE status = 1 AND is_legal = 1 AND deadline_date >= ?;"
          },
          {
            "scenario": "RuleType is privacy",
            "sql": "SELECT id, status, is_private, is_secure, is_legal, deadline_date FROM compliance_records WHERE status = 1 AND is_private = 1 AND deadline_date >= ?;"
          },
          {
            "scenario": "RuleType is security",
            "sql": "SELECT id, status, is_private, is_secure, is_legal, deadline_date FROM compliance_records WHERE status = 1 AND is_secure = 1 AND deadline_date >= ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "CertificationRepo",
        "code_value": "type CertificationRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "CertificationRecord",
        "code_value": "type CertificationRecord struct {\n\tID           int64  `gorm:\"column:id\" json:\"id\"`\n\tLicenseKey   string `gorm:\"column:license_key\" json:\"license_key\"`\n\tExpiryDate   int64  `gorm:\"column:expiry_date\" json:\"expiry_date\"`\n\tLocationCode string `gorm:\"column:location_code\" json:\"location_code\"`\n}"
      },
      {
        "code_key": "CertificationTableName",
        "code_value": "const CertificationTableName = \"certification_records\""
      },
      {
        "code_key": "ValidationKey",
        "code_value": "const ValidationKey = \"VALIDATION\""
      },
      {
        "code_key": "utils",
        "code_value": "git.example.com/common/pkg/utils"
      },
      {
        "code_key": "ValidationResult",
        "code_value": "type ValidationResult struct {\n\tIsValid bool\n\tError   error\n}"
      },
      {
        "code_key": "TimeUtils",
        "code_value": "var TimeUtils = struct {\n\tNow func() time.Time\n}{\n\tNow: time.Now,\n}"
      },
      {
        "code_key": "ErrorMessages",
        "code_value": "var ErrorMessages = map[string]string{\n\t\"INVALID_LICENSE\": \"License key is invalid\",\n\t\"EXPIRED\":        \"License has expired\",\n\t\"LOCATION_MISMATCH\": \"Location code does not match\"\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "SoftDelete",
    "orm_code": "func (repo *SurgeryRepo) SoftDelete(ctx context.Context, scheduleID string) error {\n    selectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n    updateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n    const SurgeryScheduleTableName = \"surgery_schedules\"\n\n    existing := &model.Layout{}\n    if err := repo.db.Clauses(selectClause).Table(SurgeryScheduleTableName).\n        Where(\"unique_key = ?\", scheduleID).\n        First(existing).Error; err != nil {\n        return err\n    }\n\n    if existing.DiscountRate > 0 {\n        return errors.New(\"discounted schedules cannot be deleted\")\n    }\n\n    return repo.db.Clauses(updateClause).Table(SurgeryScheduleTableName).\n        Where(\"unique_key = ?\", scheduleID).\n        Update(\"is_deleted\", true).Error\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "SELECT query to check existing record",
            "sql": "SELECT `unique_key`, `discount_rate`, `is_deleted` FROM `surgery_schedules` WHERE `unique_key` = ? LIMIT 1;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "UPDATE operation to soft delete record",
            "sql": "UPDATE `surgery_schedules` SET `is_deleted` = TRUE WHERE `unique_key` = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "SurgeryRepo",
        "code_value": "type SurgeryRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Layout",
        "code_value": "type Layout struct {\n\tUniqueKey     string  `gorm:\"column:unique_key\"`\n\tDiscountRate  float64 `gorm:\"column:discount_rate\"`\n\tIsDeleted     bool    `gorm:\"column:is_deleted\"`\n}"
      },
      {
        "code_key": "SurgeryScheduleTableName",
        "code_value": "const SurgeryScheduleTableName = \"surgery_schedules\""
      },
      {
        "code_key": "selectClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SelectKey)"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/medical/surgery/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Expression {\n\tcommentInfo := ctx.Value(\"sql_comment\").(utils.SQLComment)\n\tcomment := fmt.Sprintf(\"/* app=%s,req=%s */\", commentInfo.AppID, commentInfo.RequestID)\n\treturn clause.Expr{SQL: comment + \" \" + clause}\n}"
      },
      {
        "code_key": "SQLComment",
        "code_value": "type SQLComment struct {\n\tAppID     string\n\tRequestID string\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "SoftDelete",
    "orm_code": "func (repo *SurgeryRepo) SoftDelete(ctx context.Context, scheduleID string) error {\n    selectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n    updateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n    const SurgeryScheduleTableName = \"surgery_schedules\"\n\n    existing := &model.Layout{}\n    if err := repo.db.Clauses(selectClause).Table(SurgeryScheduleTableName).\n        Where(\"unique_key = ?\", scheduleID).\n        First(existing).Error; err != nil {\n        return err\n    }\n\n    if existing.DiscountRate > 0 {\n        return errors.New(\"discounted schedules cannot be deleted\")\n    }\n\n    return repo.db.Clauses(updateClause).Table(SurgeryScheduleTableName).\n        Where(\"unique_key = ?\", scheduleID).\n        Update(\"is_deleted\", true).Error\n}",
    "caller": "func HandleScheduleCleanup(ctx context.Context, scheduleIDs []string, logger *zap.Logger) error {\n\trepo := &SurgeryRepo{db: GetDBInstance()}\n\tfor _, id := range scheduleIDs {\n\t\tif err := repo.SoftDelete(ctx, id); err != nil {\n\t\t\tlogger.Error(\"failed to soft delete schedule\", zap.String(\"id\", id), zap.Error(err))\n\t\t\tif err.Error() == \"discounted schedules cannot be deleted\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "检查折扣率并执行软删除（discount_rate <= 0）",
            "sql": "SELECT unique_key, discount_rate, is_deleted FROM surgery_schedules WHERE unique_key = 'sched-001' LIMIT 1;"
          },
          {
            "scenario": "检查折扣率但不执行软删除（discount_rate > 0）",
            "sql": "SELECT unique_key, discount_rate, is_deleted FROM surgery_schedules WHERE unique_key = 'sched-002' LIMIT 1;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "执行软删除操作",
            "sql": "UPDATE surgery_schedules SET is_deleted = true WHERE unique_key = 'sched-001';"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "SurgeryRepo",
        "code_value": "type SurgeryRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Layout",
        "code_value": "type Layout struct {\n\tUniqueKey     string  `gorm:\"column:unique_key\"`\n\tDiscountRate  float64 `gorm:\"column:discount_rate\"`\n\tIsDeleted     bool    `gorm:\"column:is_deleted\"`\n}"
      },
      {
        "code_key": "SurgeryScheduleTableName",
        "code_value": "const SurgeryScheduleTableName = \"surgery_schedules\""
      },
      {
        "code_key": "selectClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SelectKey)"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/medical/surgery/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Expression {\n\tcommentInfo := ctx.Value(\"sql_comment\").(utils.SQLComment)\n\tcomment := fmt.Sprintf(\"/* app=%s,req=%s */\", commentInfo.AppID, commentInfo.RequestID)\n\treturn clause.Expr{SQL: comment + \" \" + clause}\n}"
      },
      {
        "code_key": "SQLComment",
        "code_value": "type SQLComment struct {\n\tAppID     string\n\tRequestID string\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "SoftDelete",
    "orm_code": "func (repo *SurgeryRepo) SoftDelete(ctx context.Context, scheduleID string) error {\n    selectClause := utils.SetSQLComment(ctx, utils.SelectKey)\n    updateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n    const SurgeryScheduleTableName = \"surgery_schedules\"\n\n    existing := &model.Layout{}\n    if err := repo.db.Clauses(selectClause).Table(SurgeryScheduleTableName).\n        Where(\"unique_key = ?\", scheduleID).\n        First(existing).Error; err != nil {\n        return err\n    }\n\n    if existing.DiscountRate > 0 {\n        return errors.New(\"discounted schedules cannot be deleted\")\n    }\n\n    return repo.db.Clauses(updateClause).Table(SurgeryScheduleTableName).\n        Where(\"unique_key = ?\", scheduleID).\n        Update(\"is_deleted\", true).Error\n}",
    "caller": "func RemoveExpiredSchedules(ctx context.Context) (int, error) {\n\trepo := &SurgeryRepo{db: global.DB}\n\texpiredIDs := fetchExpiredScheduleIDs(ctx)\n\tcount := 0\n\tfor _, id := range expiredIDs {\n\t\tif err := repo.SoftDelete(ctx, id); err == nil {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "SELECT查询语句（检查折扣率）",
            "sql": "SELECT unique_key, discount_rate, is_deleted FROM surgery_schedules WHERE unique_key = ? LIMIT 1;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "UPDATE更新语句（软删除）",
            "sql": "UPDATE surgery_schedules SET is_deleted = true WHERE unique_key = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "SurgeryRepo",
        "code_value": "type SurgeryRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "Layout",
        "code_value": "type Layout struct {\n\tUniqueKey     string  `gorm:\"column:unique_key\"`\n\tDiscountRate  float64 `gorm:\"column:discount_rate\"`\n\tIsDeleted     bool    `gorm:\"column:is_deleted\"`\n}"
      },
      {
        "code_key": "SurgeryScheduleTableName",
        "code_value": "const SurgeryScheduleTableName = \"surgery_schedules\""
      },
      {
        "code_key": "selectClause",
        "code_value": "utils.SetSQLComment(ctx, utils.SelectKey)"
      },
      {
        "code_key": "updateClause",
        "code_value": "utils.SetSQLComment(ctx, utils.UpdateKey)"
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/medical/surgery/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Expression {\n\tcommentInfo := ctx.Value(\"sql_comment\").(utils.SQLComment)\n\tcomment := fmt.Sprintf(\"/* app=%s,req=%s */\", commentInfo.AppID, commentInfo.RequestID)\n\treturn clause.Expr{SQL: comment + \" \" + clause}\n}"
      },
      {
        "code_key": "SQLComment",
        "code_value": "type SQLComment struct {\n\tAppID     string\n\tRequestID string\n}"
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "UpdateInventory",
    "orm_code": "func (repo *MedicationRepo) UpdateInventory(ctx context.Context, profile *model.MedicationProfile) error {\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\tcurrent := &model.MedicationProfile{}\n\n\tif err := repo.db.Table(model.MedicationInventoryTableName).\n\t\tWhere(\"region_code = ? AND room = ?\", profile.RegionCode, profile.Room).\n\t\tFirst(current).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif current.CurrentStatus != profile.CurrentStatus {\n\t\treturn repo.db.Clauses(updateClause).Table(model.MedicationInventoryTableName).\n\t\t\tWhere(\"id = ?\", current.Id).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"current_status\": profile.CurrentStatus,\n\t\t\t\t\"last_update\":   time.Now().Unix(),\n\t\t\t}).Error\n\t}\n\n\treturn nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "CurrentStatus = 'pending'",
            "sql": "UPDATE attendance_logs SET quantity = ? WHERE contract_id = ? AND locale = ?;"
          },
          {
            "scenario": "CurrentStatus = 'approved'",
            "sql": "UPDATE attendance_logs SET quantity = ? * 2 WHERE contract_id = ? AND phone_number = ?;"
          },
          {
            "scenario": "CurrentStatus = 'rejected'",
            "sql": "UPDATE attendance_logs SET quantity = 0 WHERE contract_id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "MedicationRepo",
        "code_value": "type MedicationRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "MedicationInventoryTableName",
        "code_value": "const MedicationInventoryTableName = \"medication_inventory\""
      },
      {
        "code_key": "MedicationProfile",
        "code_value": "type MedicationProfile struct {\n\tId           int64  `gorm:\"column:id\" json:\"id\"`\n\tRegionCode   string `gorm:\"column:region_code\" json:\"region_code\"`\n\tRoom         string `gorm:\"column:room\" json:\"room\"`\n\tCurrentStatus int    `gorm:\"column:current_status\" json:\"current_status\"`\n\tLastUpdate   int64  `gorm:\"column:last_update\" json:\"last_update\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (mp *MedicationProfile) TableName() string {\n\treturn MedicationInventoryTableName\n}"
      },
      {
        "code_key": "InventoryStatus",
        "code_value": "const (\n\tStatusInStock = iota + 1\n\tStatusOutOfStock\n\tStatusExpired\n)"
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/MedicalSystem/medication/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Expression {\n\tcommentInfo := context.GetCommentInfo(ctx)\n\tif commentInfo == nil {\n\t\tcommentInfo = &CommentInfo{RequestID: uuid.NewString()}\n\t}\n\treturn clause.Expr{SQL: fmt.Sprintf(\"%s /* %s */\", clause, commentInfo.String())}\n}"
      },
      {
        "code_key": "time",
        "code_value": "import \"time\""
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "UpdateInventory",
    "orm_code": "func (repo *MedicationRepo) UpdateInventory(ctx context.Context, profile *model.MedicationProfile) error {\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\tcurrent := &model.MedicationProfile{}\n\n\tif err := repo.db.Table(model.MedicationInventoryTableName).\n\t\tWhere(\"region_code = ? AND room = ?\", profile.RegionCode, profile.Room).\n\t\tFirst(current).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif current.CurrentStatus != profile.CurrentStatus {\n\t\treturn repo.db.Clauses(updateClause).Table(model.MedicationInventoryTableName).\n\t\t\tWhere(\"id = ?\", current.Id).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"current_status\": profile.CurrentStatus,\n\t\t\t\t\"last_update\":   time.Now().Unix(),\n\t\t\t}).Error\n\t}\n\n\treturn nil\n}",
    "caller": "func HandleMedicationStatusUpdate(ctx context.Context, region string, room string, newStatus int) error {\n\trepo := &MedicationRepo{db: GetDBInstance()}\n\tprofile := &model.MedicationProfile{\n\t\tRegionCode:    region,\n\t\tRoom:          room,\n\t\tCurrentStatus: newStatus,\n\t}\n\n\tif err := repo.UpdateInventory(ctx, profile); err != nil {\n\t\tlog.Printf(\"Failed to update medication status: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "First query to check current status",
            "sql": "SELECT id, region_code, room, current_status, last_update FROM medication_inventory WHERE region_code = ? AND room = ? LIMIT 1;"
          }
        ]
      },
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Update when status changes",
            "sql": "UPDATE medication_inventory SET current_status = ?, last_update = ? WHERE id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "MedicationRepo",
        "code_value": "type MedicationRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "MedicationInventoryTableName",
        "code_value": "const MedicationInventoryTableName = \"medication_inventory\""
      },
      {
        "code_key": "MedicationProfile",
        "code_value": "type MedicationProfile struct {\n\tId           int64  `gorm:\"column:id\" json:\"id\"`\n\tRegionCode   string `gorm:\"column:region_code\" json:\"region_code\"`\n\tRoom         string `gorm:\"column:room\" json:\"room\"`\n\tCurrentStatus int    `gorm:\"column:current_status\" json:\"current_status\"`\n\tLastUpdate   int64  `gorm:\"column:last_update\" json:\"last_update\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (mp *MedicationProfile) TableName() string {\n\treturn MedicationInventoryTableName\n}"
      },
      {
        "code_key": "InventoryStatus",
        "code_value": "const (\n\tStatusInStock = iota + 1\n\tStatusOutOfStock\n\tStatusExpired\n)"
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/MedicalSystem/medication/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Expression {\n\tcommentInfo := context.GetCommentInfo(ctx)\n\tif commentInfo == nil {\n\t\tcommentInfo = &CommentInfo{RequestID: uuid.NewString()}\n\t}\n\treturn clause.Expr{SQL: fmt.Sprintf(\"%s /* %s */\", clause, commentInfo.String())}\n}"
      },
      {
        "code_key": "time",
        "code_value": "import \"time\""
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "UpdateInventory",
    "orm_code": "func (repo *MedicationRepo) UpdateInventory(ctx context.Context, profile *model.MedicationProfile) error {\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\tcurrent := &model.MedicationProfile{}\n\n\tif err := repo.db.Table(model.MedicationInventoryTableName).\n\t\tWhere(\"region_code = ? AND room = ?\", profile.RegionCode, profile.Room).\n\t\tFirst(current).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif current.CurrentStatus != profile.CurrentStatus {\n\t\treturn repo.db.Clauses(updateClause).Table(model.MedicationInventoryTableName).\n\t\t\tWhere(\"id = ?\", current.Id).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"current_status\": profile.CurrentStatus,\n\t\t\t\t\"last_update\":   time.Now().Unix(),\n\t\t\t}).Error\n\t}\n\n\treturn nil\n}",
    "caller": "func ProcessInventoryChange(ctx context.Context, facilityID string, location string) error {\n\tmedRepo := NewMedicationRepository()\n\tcurrentProfile := &model.MedicationProfile{\n\t\tRegionCode:    facilityID,\n\t\tRoom:          location,\n\t\tCurrentStatus: model.StatusInStock,\n\t}\n\n\terr := medRepo.UpdateInventory(ctx, currentProfile)\n\tif err != nil {\n\t\tmetrics.RecordInventoryError(facilityID)\n\t\treturn fmt.Errorf(\"inventory update failed: %w\", err)\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "SELECT查询当前库存记录",
            "sql": "SELECT id, region_code, room, current_status, last_update FROM medication_inventory WHERE region_code = ? AND room = ? LIMIT 1;"
          },
          {
            "scenario": "UPDATE更新库存状态（仅在状态变化时执行）",
            "sql": "UPDATE medication_inventory SET current_status = ?, last_update = ? WHERE id = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "MedicationRepo",
        "code_value": "type MedicationRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "MedicationInventoryTableName",
        "code_value": "const MedicationInventoryTableName = \"medication_inventory\""
      },
      {
        "code_key": "MedicationProfile",
        "code_value": "type MedicationProfile struct {\n\tId           int64  `gorm:\"column:id\" json:\"id\"`\n\tRegionCode   string `gorm:\"column:region_code\" json:\"region_code\"`\n\tRoom         string `gorm:\"column:room\" json:\"room\"`\n\tCurrentStatus int    `gorm:\"column:current_status\" json:\"current_status\"`\n\tLastUpdate   int64  `gorm:\"column:last_update\" json:\"last_update\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (mp *MedicationProfile) TableName() string {\n\treturn MedicationInventoryTableName\n}"
      },
      {
        "code_key": "InventoryStatus",
        "code_value": "const (\n\tStatusInStock = iota + 1\n\tStatusOutOfStock\n\tStatusExpired\n)"
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/MedicalSystem/medication/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Expression {\n\tcommentInfo := context.GetCommentInfo(ctx)\n\tif commentInfo == nil {\n\t\tcommentInfo = &CommentInfo{RequestID: uuid.NewString()}\n\t}\n\treturn clause.Expr{SQL: fmt.Sprintf(\"%s /* %s */\", clause, commentInfo.String())}\n}"
      },
      {
        "code_key": "time",
        "code_value": "import \"time\""
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "UpdateInventory",
    "orm_code": "func (repo *MedicationRepo) UpdateInventory(ctx context.Context, profile *model.MedicationProfile) error {\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\tcurrent := &model.MedicationProfile{}\n\n\tif err := repo.db.Table(model.MedicationInventoryTableName).\n\t\tWhere(\"region_code = ? AND room = ?\", profile.RegionCode, profile.Room).\n\t\tFirst(current).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif current.CurrentStatus != profile.CurrentStatus {\n\t\treturn repo.db.Clauses(updateClause).Table(model.MedicationInventoryTableName).\n\t\t\tWhere(\"id = ?\", current.Id).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"current_status\": profile.CurrentStatus,\n\t\t\t\t\"last_update\":   time.Now().Unix(),\n\t\t\t}).Error\n\t}\n\n\treturn nil\n}",
    "caller": "func HandleWarehouseUpdate() error {\n\twarehouseContract := &Contract{\n\t\tID:           \"WH-12345\",\n\t\tCurrentStatus: \"approved\",\n\t\tLocale:       \"US\",\n\t\tPhoneNumber:  \"+15551234567\",\n\t\tQuantity:     100,\n\t}\n\tif err := warehouseContract.UpdateInventory(); err != nil {\n\t\tlog.Printf(\"Failed to update warehouse inventory: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "CurrentStatus is 'pending'",
            "sql": "UPDATE attendance_logs SET quantity = 100 WHERE contract_id = 'WH-12345' AND locale = 'US';"
          },
          {
            "scenario": "CurrentStatus is 'approved'",
            "sql": "UPDATE attendance_logs SET quantity = 200 WHERE contract_id = 'WH-12345' AND phone_number = '+15551234567';"
          },
          {
            "scenario": "CurrentStatus is 'rejected'",
            "sql": "UPDATE attendance_logs SET quantity = 0 WHERE contract_id = 'WH-12345';"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "MedicationRepo",
        "code_value": "type MedicationRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "MedicationInventoryTableName",
        "code_value": "const MedicationInventoryTableName = \"medication_inventory\""
      },
      {
        "code_key": "MedicationProfile",
        "code_value": "type MedicationProfile struct {\n\tId           int64  `gorm:\"column:id\" json:\"id\"`\n\tRegionCode   string `gorm:\"column:region_code\" json:\"region_code\"`\n\tRoom         string `gorm:\"column:room\" json:\"room\"`\n\tCurrentStatus int    `gorm:\"column:current_status\" json:\"current_status\"`\n\tLastUpdate   int64  `gorm:\"column:last_update\" json:\"last_update\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (mp *MedicationProfile) TableName() string {\n\treturn MedicationInventoryTableName\n}"
      },
      {
        "code_key": "InventoryStatus",
        "code_value": "const (\n\tStatusInStock = iota + 1\n\tStatusOutOfStock\n\tStatusExpired\n)"
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/MedicalSystem/medication/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Expression {\n\tcommentInfo := context.GetCommentInfo(ctx)\n\tif commentInfo == nil {\n\t\tcommentInfo = &CommentInfo{RequestID: uuid.NewString()}\n\t}\n\treturn clause.Expr{SQL: fmt.Sprintf(\"%s /* %s */\", clause, commentInfo.String())}\n}"
      },
      {
        "code_key": "time",
        "code_value": "import \"time\""
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "UpdateInventory",
    "orm_code": "func (repo *MedicationRepo) UpdateInventory(ctx context.Context, profile *model.MedicationProfile) error {\n\tupdateClause := utils.SetSQLComment(ctx, utils.UpdateKey)\n\tcurrent := &model.MedicationProfile{}\n\n\tif err := repo.db.Table(model.MedicationInventoryTableName).\n\t\tWhere(\"region_code = ? AND room = ?\", profile.RegionCode, profile.Room).\n\t\tFirst(current).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif current.CurrentStatus != profile.CurrentStatus {\n\t\treturn repo.db.Clauses(updateClause).Table(model.MedicationInventoryTableName).\n\t\t\tWhere(\"id = ?\", current.Id).\n\t\t\tUpdates(map[string]interface{}{\n\t\t\t\t\"current_status\": profile.CurrentStatus,\n\t\t\t\t\"last_update\":   time.Now().Unix(),\n\t\t\t}).Error\n\t}\n\n\treturn nil\n}",
    "caller": "func ProcessInventoryAdjustment(contractID string, status string) error {\n\tinventoryRecord := &Contract{\n\t\tID:           contractID,\n\t\tCurrentStatus: status,\n\t\tLocale:       \"JP\",\n\t\tPhoneNumber:  \"+819012345678\",\n\t\tQuantity:     50,\n\t}\n\terr := inventoryRecord.UpdateInventory()\n\tif err != nil && status == \"rejected\" {\n\t\tlog.Println(\"Inventory cleared for rejected contract\")\n\t\treturn nil\n\t}\n\treturn err\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "status = pending",
            "sql": "UPDATE attendance_logs SET quantity = 50 WHERE contract_id = '[contractID]' AND locale = 'JP';"
          },
          {
            "scenario": "status = approved",
            "sql": "UPDATE attendance_logs SET quantity = 100 WHERE contract_id = '[contractID]' AND phone_number = '+819012345678';"
          },
          {
            "scenario": "status = rejected",
            "sql": "UPDATE attendance_logs SET quantity = 0 WHERE contract_id = '[contractID]';"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "MedicationRepo",
        "code_value": "type MedicationRepo struct {\n\tdb *gorm.DB\n}"
      },
      {
        "code_key": "MedicationInventoryTableName",
        "code_value": "const MedicationInventoryTableName = \"medication_inventory\""
      },
      {
        "code_key": "MedicationProfile",
        "code_value": "type MedicationProfile struct {\n\tId           int64  `gorm:\"column:id\" json:\"id\"`\n\tRegionCode   string `gorm:\"column:region_code\" json:\"region_code\"`\n\tRoom         string `gorm:\"column:room\" json:\"room\"`\n\tCurrentStatus int    `gorm:\"column:current_status\" json:\"current_status\"`\n\tLastUpdate   int64  `gorm:\"column:last_update\" json:\"last_update\"`\n}"
      },
      {
        "code_key": "TableName",
        "code_value": "func (mp *MedicationProfile) TableName() string {\n\treturn MedicationInventoryTableName\n}"
      },
      {
        "code_key": "InventoryStatus",
        "code_value": "const (\n\tStatusInStock = iota + 1\n\tStatusOutOfStock\n\tStatusExpired\n)"
      },
      {
        "code_key": "UpdateKey",
        "code_value": "const UpdateKey = \"UPDATE\""
      },
      {
        "code_key": "utils",
        "code_value": "git.woa.com/MedicalSystem/medication/pkg/utils"
      },
      {
        "code_key": "SetSQLComment",
        "code_value": "func SetSQLComment(ctx context.Context, clause string) clause.Expression {\n\tcommentInfo := context.GetCommentInfo(ctx)\n\tif commentInfo == nil {\n\t\tcommentInfo = &CommentInfo{RequestID: uuid.NewString()}\n\t}\n\treturn clause.Expr{SQL: fmt.Sprintf(\"%s /* %s */\", clause, commentInfo.String())}\n}"
      },
      {
        "code_key": "time",
        "code_value": "import \"time\""
      }
    ],
    "sql_pattern_cnt": 2
  },
  {
    "function_name": "ScaleCapacity",
    "orm_code": "func (b *Budget) ScaleCapacity(threshold int) ([]types.ResourceInfo, error) {\n\tresources := make([]types.ResourceInfo, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tswitch {\n\tcase b.Edition == \"premium\":\n\t\tfilter[\"tier\"] = 3\n\tcase b.Edition == \"standard\" && threshold > 1000:\n\t\tfilter[\"tier\"] = 2\n\tcase b.Edition == \"basic\" || threshold <= 500:\n\t\tfilter[\"tier\"] = 1\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported edition or threshold\")\n\t}\n\n\tif b.ProductCode != \"\" {\n\t\tfilter[\"product_code\"] = b.ProductCode\n\t}\n\n\terr := base.GetInstance().ResourceDriver().Table(\"resource_allocation\").\n\t\tWhere(filter).Find(&resources).Error\n\n\treturn resources, err\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "premium edition",
            "sql": "SELECT id, name, tier, product_code, status FROM resource_allocation WHERE status = 1 AND tier = 3;"
          },
          {
            "scenario": "premium edition with product code",
            "sql": "SELECT id, name, tier, product_code, status FROM resource_allocation WHERE status = 1 AND tier = 3 AND product_code = ?;"
          },
          {
            "scenario": "standard edition with threshold > 1000",
            "sql": "SELECT id, name, tier, product_code, status FROM resource_allocation WHERE status = 1 AND tier = 2;"
          },
          {
            "scenario": "standard edition with threshold > 1000 and product code",
            "sql": "SELECT id, name, tier, product_code, status FROM resource_allocation WHERE status = 1 AND tier = 2 AND product_code = ?;"
          },
          {
            "scenario": "basic edition or threshold ≤ 500",
            "sql": "SELECT id, name, tier, product_code, status FROM resource_allocation WHERE status = 1 AND tier = 1;"
          },
          {
            "scenario": "basic edition or threshold ≤ 500 with product code",
            "sql": "SELECT id, name, tier, product_code, status FROM resource_allocation WHERE status = 1 AND tier = 1 AND product_code = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ResourceInfo",
        "code_value": "type ResourceInfo struct {\n\tID          int    `gorm:\"column:id\"`\n\tName        string `gorm:\"column:name\"`\n\tTier        int    `gorm:\"column:tier\"`\n\tProductCode string `gorm:\"column:product_code\"`\n\tStatus      int    `gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "Budget",
        "code_value": "type Budget struct {\n\tEdition     string\n\tProductCode string\n}"
      },
      {
        "code_key": "ResourceStatus",
        "code_value": "const (\n\tResourceActive = 1\n\tResourceInactive = 0\n)"
      },
      {
        "code_key": "ResourceTable",
        "code_value": "const ResourceTable = \"resource_allocation\""
      },
      {
        "code_key": "TierLevels",
        "code_value": "const (\n\tTierBasic = 1\n\tTierStandard = 2\n\tTierPremium = 3\n)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ScaleCapacity",
    "orm_code": "func (b *Budget) ScaleCapacity(threshold int) ([]types.ResourceInfo, error) {\n\tresources := make([]types.ResourceInfo, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tswitch {\n\tcase b.Edition == \"premium\":\n\t\tfilter[\"tier\"] = 3\n\tcase b.Edition == \"standard\" && threshold > 1000:\n\t\tfilter[\"tier\"] = 2\n\tcase b.Edition == \"basic\" || threshold <= 500:\n\t\tfilter[\"tier\"] = 1\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported edition or threshold\")\n\t}\n\n\tif b.ProductCode != \"\" {\n\t\tfilter[\"product_code\"] = b.ProductCode\n\t}\n\n\terr := base.GetInstance().ResourceDriver().Table(\"resource_allocation\").\n\t\tWhere(filter).Find(&resources).Error\n\n\treturn resources, err\n}",
    "caller": "func HandlePremiumResources() ([]types.ResourceInfo, error) {\n\tpremiumBudget := &Budget{\n\t\tEdition:    \"premium\",\n\t\tProductCode: \"PRM123\",\n\t}\n\treturn premiumBudget.ScaleCapacity(2000)\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "premium edition with product code",
            "sql": "SELECT id, name, tier, product_code, status FROM resource_allocation WHERE status = 1 AND tier = 3 AND product_code = 'PRM123';"
          },
          {
            "scenario": "standard edition with threshold > 1000 and product code",
            "sql": "SELECT id, name, tier, product_code, status FROM resource_allocation WHERE status = 1 AND tier = 2 AND product_code = ?;"
          },
          {
            "scenario": "basic edition or threshold <= 500 with product code",
            "sql": "SELECT id, name, tier, product_code, status FROM resource_allocation WHERE status = 1 AND tier = 1 AND product_code = ?;"
          },
          {
            "scenario": "unsupported edition or threshold combination",
            "sql": ""
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ResourceInfo",
        "code_value": "type ResourceInfo struct {\n\tID          int    `gorm:\"column:id\"`\n\tName        string `gorm:\"column:name\"`\n\tTier        int    `gorm:\"column:tier\"`\n\tProductCode string `gorm:\"column:product_code\"`\n\tStatus      int    `gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "Budget",
        "code_value": "type Budget struct {\n\tEdition     string\n\tProductCode string\n}"
      },
      {
        "code_key": "ResourceStatus",
        "code_value": "const (\n\tResourceActive = 1\n\tResourceInactive = 0\n)"
      },
      {
        "code_key": "ResourceTable",
        "code_value": "const ResourceTable = \"resource_allocation\""
      },
      {
        "code_key": "TierLevels",
        "code_value": "const (\n\tTierBasic = 1\n\tTierStandard = 2\n\tTierPremium = 3\n)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ScaleCapacity",
    "orm_code": "func (b *Budget) ScaleCapacity(threshold int) ([]types.ResourceInfo, error) {\n\tresources := make([]types.ResourceInfo, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tswitch {\n\tcase b.Edition == \"premium\":\n\t\tfilter[\"tier\"] = 3\n\tcase b.Edition == \"standard\" && threshold > 1000:\n\t\tfilter[\"tier\"] = 2\n\tcase b.Edition == \"basic\" || threshold <= 500:\n\t\tfilter[\"tier\"] = 1\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported edition or threshold\")\n\t}\n\n\tif b.ProductCode != \"\" {\n\t\tfilter[\"product_code\"] = b.ProductCode\n\t}\n\n\terr := base.GetInstance().ResourceDriver().Table(\"resource_allocation\").\n\t\tWhere(filter).Find(&resources).Error\n\n\treturn resources, err\n}",
    "caller": "func HandleBasicScaling() error {\n\tbasicConfig := &Budget{\n\t\tEdition: \"basic\",\n\t}\n\tresources, err := basicConfig.ScaleCapacity(300)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"scaling failed: %v\", err)\n\t}\n\tlog.Printf(\"Allocated %d basic resources\", len(resources))\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Edition = 'basic' with threshold <= 500 and empty ProductCode",
            "sql": "SELECT id, name, tier, product_code, status FROM resource_allocation WHERE status = 1 AND tier = 1;"
          },
          {
            "scenario": "Edition = 'premium' with ProductCode",
            "sql": "SELECT id, name, tier, product_code, status FROM resource_allocation WHERE status = 1 AND tier = 3 AND product_code = ?;"
          },
          {
            "scenario": "Edition = 'standard' with threshold > 1000 and ProductCode",
            "sql": "SELECT id, name, tier, product_code, status FROM resource_allocation WHERE status = 1 AND tier = 2 AND product_code = ?;"
          },
          {
            "scenario": "With ProductCode condition",
            "sql": "SELECT id, name, tier, product_code, status FROM resource_allocation WHERE status = 1 AND tier = ? AND product_code = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ResourceInfo",
        "code_value": "type ResourceInfo struct {\n\tID          int    `gorm:\"column:id\"`\n\tName        string `gorm:\"column:name\"`\n\tTier        int    `gorm:\"column:tier\"`\n\tProductCode string `gorm:\"column:product_code\"`\n\tStatus      int    `gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "Budget",
        "code_value": "type Budget struct {\n\tEdition     string\n\tProductCode string\n}"
      },
      {
        "code_key": "ResourceStatus",
        "code_value": "const (\n\tResourceActive = 1\n\tResourceInactive = 0\n)"
      },
      {
        "code_key": "ResourceTable",
        "code_value": "const ResourceTable = \"resource_allocation\""
      },
      {
        "code_key": "TierLevels",
        "code_value": "const (\n\tTierBasic = 1\n\tTierStandard = 2\n\tTierPremium = 3\n)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ScaleCapacity",
    "orm_code": "func (b *Budget) ScaleCapacity(threshold int) ([]types.ResourceInfo, error) {\n\tresources := make([]types.ResourceInfo, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tswitch {\n\tcase b.Edition == \"premium\":\n\t\tfilter[\"tier\"] = 3\n\tcase b.Edition == \"standard\" && threshold > 1000:\n\t\tfilter[\"tier\"] = 2\n\tcase b.Edition == \"basic\" || threshold <= 500:\n\t\tfilter[\"tier\"] = 1\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported edition or threshold\")\n\t}\n\n\tif b.ProductCode != \"\" {\n\t\tfilter[\"product_code\"] = b.ProductCode\n\t}\n\n\terr := base.GetInstance().ResourceDriver().Table(\"resource_allocation\").\n\t\tWhere(filter).Find(&resources).Error\n\n\treturn resources, err\n}",
    "caller": "func HandleStandardUpgrade() ([]types.ResourceInfo, error) {\n\tserviceBudget := &Budget{\n\t\tEdition:    \"standard\",\n\t\tProductCode: \"STD456\",\n\t}\n\treturn serviceBudget.ScaleCapacity(1500)\n}",
    "sql_statement_list": [
      "SELECT id, name, tier, product_code, status FROM resource_allocation WHERE status = 1 AND tier = 2 AND product_code = 'STD456';"
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "ResourceInfo",
        "code_value": "type ResourceInfo struct {\n\tID          int    `gorm:\"column:id\"`\n\tName        string `gorm:\"column:name\"`\n\tTier        int    `gorm:\"column:tier\"`\n\tProductCode string `gorm:\"column:product_code\"`\n\tStatus      int    `gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "Budget",
        "code_value": "type Budget struct {\n\tEdition     string\n\tProductCode string\n}"
      },
      {
        "code_key": "ResourceStatus",
        "code_value": "const (\n\tResourceActive = 1\n\tResourceInactive = 0\n)"
      },
      {
        "code_key": "ResourceTable",
        "code_value": "const ResourceTable = \"resource_allocation\""
      },
      {
        "code_key": "TierLevels",
        "code_value": "const (\n\tTierBasic = 1\n\tTierStandard = 2\n\tTierPremium = 3\n)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ValidatePackageStatus",
    "orm_code": "func (m *Manager) ValidatePackageStatus() ([]Package, error) {\n\tpackages := make([]Package, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"active\"] = true\n\n\tswitch m.ModuleName {\n\tcase \"delivery\":\n\t\tfilter[\"route_type\"] = \"express\"\n\tcase \"storage\":\n\t\tfilter[\"storage_required\"] = true\n\tcase \"premium\":\n\t\tfilter[\"credits\"] = m.Credits\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported module\")\n\t}\n\n\terr := base.GetInstance().PackageDriver().Table(\"medication_inventory\").\n\t\tWhere(filter).Find(&packages).Error\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn packages, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "ModuleName = 'delivery'",
            "sql": "SELECT id, name, active, route_type, storage_required, credits FROM medication_inventory WHERE active = true AND route_type = 'express';"
          },
          {
            "scenario": "ModuleName = 'storage'",
            "sql": "SELECT id, name, active, route_type, storage_required, credits FROM medication_inventory WHERE active = true AND storage_required = true;"
          },
          {
            "scenario": "ModuleName = 'premium'",
            "sql": "SELECT id, name, active, route_type, storage_required, credits FROM medication_inventory WHERE active = true AND credits = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Package",
        "code_value": "type Package struct {\n\tID              int    `gorm:\"column:id;primaryKey\"`\n\tName            string `gorm:\"column:name\"`\n\tActive          bool   `gorm:\"column:active\"`\n\tRouteType       string `gorm:\"column:route_type\"`\n\tStorageRequired bool   `gorm:\"column:storage_required\"`\n\tCredits         int    `gorm:\"column:credits\"`\n}"
      },
      {
        "code_key": "Manager",
        "code_value": "type Manager struct {\n\tModuleName string\n\tCredits    int\n}"
      },
      {
        "code_key": "MedicationInventoryTable",
        "code_value": "const MedicationInventoryTable = \"medication_inventory\""
      },
      {
        "code_key": "ModuleDelimiter",
        "code_value": "const (\n\tModuleDelivery = \"delivery\"\n\tModuleStorage  = \"storage\"\n\tModulePremium  = \"premium\"\n)"
      },
      {
        "code_key": "RouteTypeExpress",
        "code_value": "const RouteTypeExpress = \"express\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ValidatePackageStatus",
    "orm_code": "func (m *Manager) ValidatePackageStatus() ([]Package, error) {\n\tpackages := make([]Package, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"active\"] = true\n\n\tswitch m.ModuleName {\n\tcase \"delivery\":\n\t\tfilter[\"route_type\"] = \"express\"\n\tcase \"storage\":\n\t\tfilter[\"storage_required\"] = true\n\tcase \"premium\":\n\t\tfilter[\"credits\"] = m.Credits\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported module\")\n\t}\n\n\terr := base.GetInstance().PackageDriver().Table(\"medication_inventory\").\n\t\tWhere(filter).Find(&packages).Error\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn packages, nil\n}",
    "caller": "func HandleExpressDeliveries() ([]Package, error) {\n\tmanager := &Manager{\n\t\tModuleName: \"delivery\",\n\t}\n\tdeliveries, err := manager.ValidatePackageStatus()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to fetch express deliveries: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn deliveries, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "ModuleName为delivery时",
            "sql": "SELECT id, name, active, route_type, storage_required, credits FROM medication_inventory WHERE active = true AND route_type = 'express';"
          },
          {
            "scenario": "ModuleName为storage时",
            "sql": "SELECT id, name, active, route_type, storage_required, credits FROM medication_inventory WHERE active = true AND storage_required = true;"
          },
          {
            "scenario": "ModuleName为premium时",
            "sql": "SELECT id, name, active, route_type, storage_required, credits FROM medication_inventory WHERE active = true AND credits = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Package",
        "code_value": "type Package struct {\n\tID              int    `gorm:\"column:id;primaryKey\"`\n\tName            string `gorm:\"column:name\"`\n\tActive          bool   `gorm:\"column:active\"`\n\tRouteType       string `gorm:\"column:route_type\"`\n\tStorageRequired bool   `gorm:\"column:storage_required\"`\n\tCredits         int    `gorm:\"column:credits\"`\n}"
      },
      {
        "code_key": "Manager",
        "code_value": "type Manager struct {\n\tModuleName string\n\tCredits    int\n}"
      },
      {
        "code_key": "MedicationInventoryTable",
        "code_value": "const MedicationInventoryTable = \"medication_inventory\""
      },
      {
        "code_key": "ModuleDelimiter",
        "code_value": "const (\n\tModuleDelivery = \"delivery\"\n\tModuleStorage  = \"storage\"\n\tModulePremium  = \"premium\"\n)"
      },
      {
        "code_key": "RouteTypeExpress",
        "code_value": "const RouteTypeExpress = \"express\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ValidatePackageStatus",
    "orm_code": "func (m *Manager) ValidatePackageStatus() ([]Package, error) {\n\tpackages := make([]Package, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"active\"] = true\n\n\tswitch m.ModuleName {\n\tcase \"delivery\":\n\t\tfilter[\"route_type\"] = \"express\"\n\tcase \"storage\":\n\t\tfilter[\"storage_required\"] = true\n\tcase \"premium\":\n\t\tfilter[\"credits\"] = m.Credits\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported module\")\n\t}\n\n\terr := base.GetInstance().PackageDriver().Table(\"medication_inventory\").\n\t\tWhere(filter).Find(&packages).Error\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn packages, nil\n}",
    "caller": "func ProcessStorageRequests() error {\n\tstorageManager := &Manager{\n\t\tModuleName: \"storage\",\n\t}\n\titems, err := storageManager.ValidatePackageStatus()\n\tif err != nil {\n\t\tlog.Printf(\"Storage validation failed: %v\", err)\n\t\treturn err\n\t}\n\t// Process storage items...\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "ModuleName is 'storage'",
            "sql": "SELECT id, name, active, route_type, storage_required, credits FROM medication_inventory WHERE active = true AND storage_required = true;"
          },
          {
            "scenario": "ModuleName is 'delivery'",
            "sql": "SELECT id, name, active, route_type, storage_required, credits FROM medication_inventory WHERE active = true AND route_type = 'express';"
          },
          {
            "scenario": "ModuleName is 'premium' with Credits value",
            "sql": "SELECT id, name, active, route_type, storage_required, credits FROM medication_inventory WHERE active = true AND credits = ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Package",
        "code_value": "type Package struct {\n\tID              int    `gorm:\"column:id;primaryKey\"`\n\tName            string `gorm:\"column:name\"`\n\tActive          bool   `gorm:\"column:active\"`\n\tRouteType       string `gorm:\"column:route_type\"`\n\tStorageRequired bool   `gorm:\"column:storage_required\"`\n\tCredits         int    `gorm:\"column:credits\"`\n}"
      },
      {
        "code_key": "Manager",
        "code_value": "type Manager struct {\n\tModuleName string\n\tCredits    int\n}"
      },
      {
        "code_key": "MedicationInventoryTable",
        "code_value": "const MedicationInventoryTable = \"medication_inventory\""
      },
      {
        "code_key": "ModuleDelimiter",
        "code_value": "const (\n\tModuleDelivery = \"delivery\"\n\tModuleStorage  = \"storage\"\n\tModulePremium  = \"premium\"\n)"
      },
      {
        "code_key": "RouteTypeExpress",
        "code_value": "const RouteTypeExpress = \"express\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ValidatePackageStatus",
    "orm_code": "func (m *Manager) ValidatePackageStatus() ([]Package, error) {\n\tpackages := make([]Package, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"active\"] = true\n\n\tswitch m.ModuleName {\n\tcase \"delivery\":\n\t\tfilter[\"route_type\"] = \"express\"\n\tcase \"storage\":\n\t\tfilter[\"storage_required\"] = true\n\tcase \"premium\":\n\t\tfilter[\"credits\"] = m.Credits\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported module\")\n\t}\n\n\terr := base.GetInstance().PackageDriver().Table(\"medication_inventory\").\n\t\tWhere(filter).Find(&packages).Error\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn packages, nil\n}",
    "caller": "func CheckPremiumSubscriptions(userCredits int) ([]Package, error) {\n\tpremiumManager := &Manager{\n\t\tModuleName: \"premium\",\n\t\tCredits:   userCredits,\n\t}\n\tsubscriptions, err := premiumManager.ValidatePackageStatus()\n\tif err != nil {\n\t\tlog.Printf(\"Premium package check failed: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn subscriptions, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "premium模块路径，使用credits参数",
            "sql": "SELECT id, name, active, route_type, storage_required, credits FROM medication_inventory WHERE active = true AND credits = ?;"
          },
          {
            "scenario": "delivery模块路径（未被当前调用者触发）",
            "sql": "SELECT id, name, active, route_type, storage_required, credits FROM medication_inventory WHERE active = true AND route_type = 'express';"
          },
          {
            "scenario": "storage模块路径（未被当前调用者触发）",
            "sql": "SELECT id, name, active, route_type, storage_required, credits FROM medication_inventory WHERE active = true AND storage_required = true;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Package",
        "code_value": "type Package struct {\n\tID              int    `gorm:\"column:id;primaryKey\"`\n\tName            string `gorm:\"column:name\"`\n\tActive          bool   `gorm:\"column:active\"`\n\tRouteType       string `gorm:\"column:route_type\"`\n\tStorageRequired bool   `gorm:\"column:storage_required\"`\n\tCredits         int    `gorm:\"column:credits\"`\n}"
      },
      {
        "code_key": "Manager",
        "code_value": "type Manager struct {\n\tModuleName string\n\tCredits    int\n}"
      },
      {
        "code_key": "MedicationInventoryTable",
        "code_value": "const MedicationInventoryTable = \"medication_inventory\""
      },
      {
        "code_key": "ModuleDelimiter",
        "code_value": "const (\n\tModuleDelivery = \"delivery\"\n\tModuleStorage  = \"storage\"\n\tModulePremium  = \"premium\"\n)"
      },
      {
        "code_key": "RouteTypeExpress",
        "code_value": "const RouteTypeExpress = \"express\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "LoadBalance",
    "orm_code": "func (r *Route) LoadBalance() ([]Author, error) {\n\tauthors := make([]Author, 0)\n\tfilter := map[string]interface{}{\"status\": 1}\n\tswitch r.City {\n\tcase \"Beijing\":\n\t\tfilter[\"region\"] = \"north\"\n\tcase \"Shanghai\":\n\t\tfilter[\"region\"] = \"east\"\n\tcase \"Guangzhou\":\n\t\tfilter[\"region\"] = \"south\"\n\tcase \"Chengdu\":\n\t\tfilter[\"region\"] = \"west\"\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported city\")\n\t}\n\tif r.DatabaseName != \"\" {\n\t\tfilter[\"db_name\"] = r.DatabaseName\n\t}\n\terr := base.GetInstance().RouteDriver().Table(\"grade_records\").\n\t\tWhere(filter).Order(\"score DESC\").Limit(10).Find(&authors).Error\n\treturn authors, err\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "City is Beijing and DatabaseName is not empty",
            "sql": "SELECT id, name, region, score, status FROM grade_records WHERE status = 1 AND region = 'north' AND db_name = ? ORDER BY score DESC LIMIT 10;"
          },
          {
            "scenario": "City is Shanghai and DatabaseName is not empty",
            "sql": "SELECT id, name, region, score, status FROM grade_records WHERE status = 1 AND region = 'east' AND db_name = ? ORDER BY score DESC LIMIT 10;"
          },
          {
            "scenario": "City is Guangzhou and DatabaseName is not empty",
            "sql": "SELECT id, name, region, score, status FROM grade_records WHERE status = 1 AND region = 'south' AND db_name = ? ORDER BY score DESC LIMIT 10;"
          },
          {
            "scenario": "City is Chengdu and DatabaseName is not empty",
            "sql": "SELECT id, name, region, score, status FROM grade_records WHERE status = 1 AND region = 'west' AND db_name = ? ORDER BY score DESC LIMIT 10;"
          },
          {
            "scenario": "City is Beijing and DatabaseName is empty",
            "sql": "SELECT id, name, region, score, status FROM grade_records WHERE status = 1 AND region = 'north' ORDER BY score DESC LIMIT 10;"
          },
          {
            "scenario": "City is Shanghai and DatabaseName is empty",
            "sql": "SELECT id, name, region, score, status FROM grade_records WHERE status = 1 AND region = 'east' ORDER BY score DESC LIMIT 10;"
          },
          {
            "scenario": "City is Guangzhou and DatabaseName is empty",
            "sql": "SELECT id, name, region, score, status FROM grade_records WHERE status = 1 AND region = 'south' ORDER BY score DESC LIMIT 10;"
          },
          {
            "scenario": "City is Chengdu and DatabaseName is empty",
            "sql": "SELECT id, name, region, score, status FROM grade_records WHERE status = 1 AND region = 'west' ORDER BY score DESC LIMIT 10;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Route",
        "code_value": "type Route struct {\n\tCity         string\n\tDatabaseName string\n}"
      },
      {
        "code_key": "Author",
        "code_value": "type Author struct {\n\tID     int    `gorm:\"column:id\"`\n\tName   string `gorm:\"column:name\"`\n\tRegion string `gorm:\"column:region\"`\n\tScore  int    `gorm:\"column:score\"`\n\tStatus int    `gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "RegionType",
        "code_value": "const (\n\tRegionNorth = \"north\"\n\tRegionEast  = \"east\"\n\tRegionSouth = \"south\"\n\tRegionWest  = \"west\"\n)"
      },
      {
        "code_key": "GradeRecordsTable",
        "code_value": "const GradeRecordsTable = \"grade_records\""
      },
      {
        "code_key": "AuthorStatus",
        "code_value": "const (\n\tAuthorActive = 1\n\tAuthorInactive = 0\n)"
      },
      {
        "code_key": "ErrorMessages",
        "code_value": "var (\n\tErrUnsupportedCity = errors.New(\"unsupported city\")\n\tErrNoRecordsFound = errors.New(\"no records found\")\n)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "LoadBalance",
    "orm_code": "func (r *Route) LoadBalance() ([]Author, error) {\n\tauthors := make([]Author, 0)\n\tfilter := map[string]interface{}{\"status\": 1}\n\tswitch r.City {\n\tcase \"Beijing\":\n\t\tfilter[\"region\"] = \"north\"\n\tcase \"Shanghai\":\n\t\tfilter[\"region\"] = \"east\"\n\tcase \"Guangzhou\":\n\t\tfilter[\"region\"] = \"south\"\n\tcase \"Chengdu\":\n\t\tfilter[\"region\"] = \"west\"\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported city\")\n\t}\n\tif r.DatabaseName != \"\" {\n\t\tfilter[\"db_name\"] = r.DatabaseName\n\t}\n\terr := base.GetInstance().RouteDriver().Table(\"grade_records\").\n\t\tWhere(filter).Order(\"score DESC\").Limit(10).Find(&authors).Error\n\treturn authors, err\n}",
    "caller": "func HandleAuthorList() ([]Author, error) {\n\trouteCfg := &Route{City: \"Beijing\", DatabaseName: \"author_db\"}\n\tauthors, err := routeCfg.LoadBalance()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to load authors: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn authors, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "City is Beijing and DatabaseName is provided",
            "sql": "SELECT id, name, region, score, status FROM grade_records WHERE status = 1 AND region = 'north' AND db_name = 'author_db' ORDER BY score DESC LIMIT 10;"
          },
          {
            "scenario": "City is Shanghai and DatabaseName is provided",
            "sql": "SELECT id, name, region, score, status FROM grade_records WHERE status = 1 AND region = 'east' AND db_name = 'author_db' ORDER BY score DESC LIMIT 10;"
          },
          {
            "scenario": "City is Guangzhou and DatabaseName is provided",
            "sql": "SELECT id, name, region, score, status FROM grade_records WHERE status = 1 AND region = 'south' AND db_name = 'author_db' ORDER BY score DESC LIMIT 10;"
          },
          {
            "scenario": "City is Chengdu and DatabaseName is provided",
            "sql": "SELECT id, name, region, score, status FROM grade_records WHERE status = 1 AND region = 'west' AND db_name = 'author_db' ORDER BY score DESC LIMIT 10;"
          },
          {
            "scenario": "DatabaseName is not provided",
            "sql": "SELECT id, name, region, score, status FROM grade_records WHERE status = 1 AND region = 'north' ORDER BY score DESC LIMIT 10;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Route",
        "code_value": "type Route struct {\n\tCity         string\n\tDatabaseName string\n}"
      },
      {
        "code_key": "Author",
        "code_value": "type Author struct {\n\tID     int    `gorm:\"column:id\"`\n\tName   string `gorm:\"column:name\"`\n\tRegion string `gorm:\"column:region\"`\n\tScore  int    `gorm:\"column:score\"`\n\tStatus int    `gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "RegionType",
        "code_value": "const (\n\tRegionNorth = \"north\"\n\tRegionEast  = \"east\"\n\tRegionSouth = \"south\"\n\tRegionWest  = \"west\"\n)"
      },
      {
        "code_key": "GradeRecordsTable",
        "code_value": "const GradeRecordsTable = \"grade_records\""
      },
      {
        "code_key": "AuthorStatus",
        "code_value": "const (\n\tAuthorActive = 1\n\tAuthorInactive = 0\n)"
      },
      {
        "code_key": "ErrorMessages",
        "code_value": "var (\n\tErrUnsupportedCity = errors.New(\"unsupported city\")\n\tErrNoRecordsFound = errors.New(\"no records found\")\n)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "LoadBalance",
    "orm_code": "func (r *Route) LoadBalance() ([]Author, error) {\n\tauthors := make([]Author, 0)\n\tfilter := map[string]interface{}{\"status\": 1}\n\tswitch r.City {\n\tcase \"Beijing\":\n\t\tfilter[\"region\"] = \"north\"\n\tcase \"Shanghai\":\n\t\tfilter[\"region\"] = \"east\"\n\tcase \"Guangzhou\":\n\t\tfilter[\"region\"] = \"south\"\n\tcase \"Chengdu\":\n\t\tfilter[\"region\"] = \"west\"\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported city\")\n\t}\n\tif r.DatabaseName != \"\" {\n\t\tfilter[\"db_name\"] = r.DatabaseName\n\t}\n\terr := base.GetInstance().RouteDriver().Table(\"grade_records\").\n\t\tWhere(filter).Order(\"score DESC\").Limit(10).Find(&authors).Error\n\treturn authors, err\n}",
    "caller": "func ProcessTopWriters(regionCity string) ([]Author, error) {\n\tif regionCity == \"\" {\n\t\treturn nil, fmt.Errorf(\"city cannot be empty\")\n\t}\n\tr := &Route{City: regionCity}\n\tresult, err := r.LoadBalance()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"load balance failed: %w\", err)\n\t}\n\treturn result, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "北京地区查询",
            "sql": "SELECT id, name, region, score, status FROM grade_records WHERE status = 1 AND region = 'north' ORDER BY score DESC LIMIT 10;"
          },
          {
            "scenario": "上海地区查询",
            "sql": "SELECT id, name, region, score, status FROM grade_records WHERE status = 1 AND region = 'east' ORDER BY score DESC LIMIT 10;"
          },
          {
            "scenario": "广州地区查询",
            "sql": "SELECT id, name, region, score, status FROM grade_records WHERE status = 1 AND region = 'south' ORDER BY score DESC LIMIT 10;"
          },
          {
            "scenario": "成都地区查询",
            "sql": "SELECT id, name, region, score, status FROM grade_records WHERE status = 1 AND region = 'west' ORDER BY score DESC LIMIT 10;"
          },
          {
            "scenario": "带数据库名过滤条件",
            "sql": "SELECT id, name, region, score, status FROM grade_records WHERE status = 1 AND region = 'north' AND db_name = ? ORDER BY score DESC LIMIT 10;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Route",
        "code_value": "type Route struct {\n\tCity         string\n\tDatabaseName string\n}"
      },
      {
        "code_key": "Author",
        "code_value": "type Author struct {\n\tID     int    `gorm:\"column:id\"`\n\tName   string `gorm:\"column:name\"`\n\tRegion string `gorm:\"column:region\"`\n\tScore  int    `gorm:\"column:score\"`\n\tStatus int    `gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "RegionType",
        "code_value": "const (\n\tRegionNorth = \"north\"\n\tRegionEast  = \"east\"\n\tRegionSouth = \"south\"\n\tRegionWest  = \"west\"\n)"
      },
      {
        "code_key": "GradeRecordsTable",
        "code_value": "const GradeRecordsTable = \"grade_records\""
      },
      {
        "code_key": "AuthorStatus",
        "code_value": "const (\n\tAuthorActive = 1\n\tAuthorInactive = 0\n)"
      },
      {
        "code_key": "ErrorMessages",
        "code_value": "var (\n\tErrUnsupportedCity = errors.New(\"unsupported city\")\n\tErrNoRecordsFound = errors.New(\"no records found\")\n)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "LoadBalance",
    "orm_code": "func (r *Route) LoadBalance() ([]Author, error) {\n\tauthors := make([]Author, 0)\n\tfilter := map[string]interface{}{\"status\": 1}\n\tswitch r.City {\n\tcase \"Beijing\":\n\t\tfilter[\"region\"] = \"north\"\n\tcase \"Shanghai\":\n\t\tfilter[\"region\"] = \"east\"\n\tcase \"Guangzhou\":\n\t\tfilter[\"region\"] = \"south\"\n\tcase \"Chengdu\":\n\t\tfilter[\"region\"] = \"west\"\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported city\")\n\t}\n\tif r.DatabaseName != \"\" {\n\t\tfilter[\"db_name\"] = r.DatabaseName\n\t}\n\terr := base.GetInstance().RouteDriver().Table(\"grade_records\").\n\t\tWhere(filter).Order(\"score DESC\").Limit(10).Find(&authors).Error\n\treturn authors, err\n}",
    "caller": "func FetchRegionalAuthors() error {\n\tr := &Route{City: \"Shanghai\"}\n\tauthorList, err := r.LoadBalance()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to fetch authors: %v\", err)\n\t}\n\tfmt.Printf(\"Fetched %d authors\\n\", len(authorList))\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "City is Shanghai and DatabaseName is empty",
            "sql": "SELECT id, name, region, score, status FROM grade_records WHERE status = 1 AND region = 'east' ORDER BY score DESC LIMIT 10;"
          },
          {
            "scenario": "City is Beijing and DatabaseName is empty",
            "sql": "SELECT id, name, region, score, status FROM grade_records WHERE status = 1 AND region = 'north' ORDER BY score DESC LIMIT 10;"
          },
          {
            "scenario": "City is Guangzhou and DatabaseName is empty",
            "sql": "SELECT id, name, region, score, status FROM grade_records WHERE status = 1 AND region = 'south' ORDER BY score DESC LIMIT 10;"
          },
          {
            "scenario": "City is Chengdu and DatabaseName is empty",
            "sql": "SELECT id, name, region, score, status FROM grade_records WHERE status = 1 AND region = 'west' ORDER BY score DESC LIMIT 10;"
          },
          {
            "scenario": "City is Shanghai and DatabaseName is provided",
            "sql": "SELECT id, name, region, score, status FROM grade_records WHERE status = 1 AND region = 'east' AND db_name = 'mydb' ORDER BY score DESC LIMIT 10;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Route",
        "code_value": "type Route struct {\n\tCity         string\n\tDatabaseName string\n}"
      },
      {
        "code_key": "Author",
        "code_value": "type Author struct {\n\tID     int    `gorm:\"column:id\"`\n\tName   string `gorm:\"column:name\"`\n\tRegion string `gorm:\"column:region\"`\n\tScore  int    `gorm:\"column:score\"`\n\tStatus int    `gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "RegionType",
        "code_value": "const (\n\tRegionNorth = \"north\"\n\tRegionEast  = \"east\"\n\tRegionSouth = \"south\"\n\tRegionWest  = \"west\"\n)"
      },
      {
        "code_key": "GradeRecordsTable",
        "code_value": "const GradeRecordsTable = \"grade_records\""
      },
      {
        "code_key": "AuthorStatus",
        "code_value": "const (\n\tAuthorActive = 1\n\tAuthorInactive = 0\n)"
      },
      {
        "code_key": "ErrorMessages",
        "code_value": "var (\n\tErrUnsupportedCity = errors.New(\"unsupported city\")\n\tErrNoRecordsFound = errors.New(\"no records found\")\n)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ProcessPayment",
    "orm_code": "func (w *Wallet) ProcessPayment() ([]PaymentRecord, error) {\n\trecords := make([]PaymentRecord, 0)\n\tfilter := map[string]interface{}{\n\t\t\"status\": 1,\n\t}\n\n\tswitch w.PaymentType {\n\tcase 1:\n\t\tfilter[\"method\"] = \"credit_card\"\n\tcase 2:\n\t\tfilter[\"method\"] = \"wallet_balance\"\n\tcase 3:\n\t\tfilter[\"method\"] = \"bank_transfer\"\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported payment type\")\n\t}\n\n\tif w.CertificateId != \"\" {\n\t\tfilter[\"certificate_id\"] = w.CertificateId\n\t}\n\n\terr := base.GetInstance().BillingDriver().\n\t\tTable(\"payment_records\").\n\t\tWhere(filter).\n\t\tOrder(\"created_at DESC\").\n\t\tFind(&records).Error\n\n\treturn records, err\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "PaymentType=1(CreditCard), CertificateId为空",
            "sql": "SELECT * FROM payment_records WHERE status = 1 AND method = 'credit_card' ORDER BY created_at DESC;"
          },
          {
            "scenario": "PaymentType=1(CreditCard), CertificateId不为空",
            "sql": "SELECT * FROM payment_records WHERE status = 1 AND method = 'credit_card' AND certificate_id = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "PaymentType=2(WalletBalance), CertificateId为空",
            "sql": "SELECT * FROM payment_records WHERE status = 1 AND method = 'wallet_balance' ORDER BY created_at DESC;"
          },
          {
            "scenario": "PaymentType=2(WalletBalance), CertificateId不为空",
            "sql": "SELECT * FROM payment_records WHERE status = 1 AND method = 'wallet_balance' AND certificate_id = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "PaymentType=3(BankTransfer), CertificateId为空",
            "sql": "SELECT * FROM payment_records WHERE status = 1 AND method = 'bank_transfer' ORDER BY created_at DESC;"
          },
          {
            "scenario": "PaymentType=3(BankTransfer), CertificateId不为空",
            "sql": "SELECT * FROM payment_records WHERE status = 1 AND method = 'bank_transfer' AND certificate_id = ? ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Wallet",
        "code_value": "type Wallet struct {\n\tPaymentType    int\n\tCertificateId  string\n}"
      },
      {
        "code_key": "PaymentRecord",
        "code_value": "type PaymentRecord struct {\n\tID           uint   `gorm:\"primaryKey\"`\n\tMethod       string `gorm:\"column:method\"`\n\tStatus       int    `gorm:\"column:status\"`\n\tCertificateId string `gorm:\"column:certificate_id\"`\n\tCreatedAt    time.Time `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "PaymentStatus",
        "code_value": "const (\n\tPaymentPending = 0\n\tPaymentSuccess = 1\n\tPaymentFailed  = 2\n)"
      },
      {
        "code_key": "PaymentMethod",
        "code_value": "const (\n\tCreditCard    = 1\n\tWalletBalance = 2\n\tBankTransfer  = 3\n)"
      },
      {
        "code_key": "BillingTable",
        "code_value": "const BillingTable = \"payment_records\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ProcessPayment",
    "orm_code": "func (w *Wallet) ProcessPayment() ([]PaymentRecord, error) {\n\trecords := make([]PaymentRecord, 0)\n\tfilter := map[string]interface{}{\n\t\t\"status\": 1,\n\t}\n\n\tswitch w.PaymentType {\n\tcase 1:\n\t\tfilter[\"method\"] = \"credit_card\"\n\tcase 2:\n\t\tfilter[\"method\"] = \"wallet_balance\"\n\tcase 3:\n\t\tfilter[\"method\"] = \"bank_transfer\"\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported payment type\")\n\t}\n\n\tif w.CertificateId != \"\" {\n\t\tfilter[\"certificate_id\"] = w.CertificateId\n\t}\n\n\terr := base.GetInstance().BillingDriver().\n\t\tTable(\"payment_records\").\n\t\tWhere(filter).\n\t\tOrder(\"created_at DESC\").\n\t\tFind(&records).Error\n\n\treturn records, err\n}",
    "caller": "func HandleUserWalletPayment(userID string) ([]PaymentRecord, error) {\n\twallet := &Wallet{\n\t\tPaymentType:    2,\n\t\tCertificateId:  userID,\n\t}\n\n\tpayments, err := wallet.ProcessPayment()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to process wallet payment: %v\", err)\n\t}\n\n\tif len(payments) == 0 {\n\t\treturn nil, errors.New(\"no payment records found\")\n\t}\n\n\treturn payments, nil\n}",
    "sql_statement_list": [
      "SELECT * FROM payment_records WHERE status = 1 AND method = 'wallet_balance' AND certificate_id = ? ORDER BY created_at DESC;"
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Wallet",
        "code_value": "type Wallet struct {\n\tPaymentType    int\n\tCertificateId  string\n}"
      },
      {
        "code_key": "PaymentRecord",
        "code_value": "type PaymentRecord struct {\n\tID           uint   `gorm:\"primaryKey\"`\n\tMethod       string `gorm:\"column:method\"`\n\tStatus       int    `gorm:\"column:status\"`\n\tCertificateId string `gorm:\"column:certificate_id\"`\n\tCreatedAt    time.Time `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "PaymentStatus",
        "code_value": "const (\n\tPaymentPending = 0\n\tPaymentSuccess = 1\n\tPaymentFailed  = 2\n)"
      },
      {
        "code_key": "PaymentMethod",
        "code_value": "const (\n\tCreditCard    = 1\n\tWalletBalance = 2\n\tBankTransfer  = 3\n)"
      },
      {
        "code_key": "BillingTable",
        "code_value": "const BillingTable = \"payment_records\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ProcessPayment",
    "orm_code": "func (w *Wallet) ProcessPayment() ([]PaymentRecord, error) {\n\trecords := make([]PaymentRecord, 0)\n\tfilter := map[string]interface{}{\n\t\t\"status\": 1,\n\t}\n\n\tswitch w.PaymentType {\n\tcase 1:\n\t\tfilter[\"method\"] = \"credit_card\"\n\tcase 2:\n\t\tfilter[\"method\"] = \"wallet_balance\"\n\tcase 3:\n\t\tfilter[\"method\"] = \"bank_transfer\"\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported payment type\")\n\t}\n\n\tif w.CertificateId != \"\" {\n\t\tfilter[\"certificate_id\"] = w.CertificateId\n\t}\n\n\terr := base.GetInstance().BillingDriver().\n\t\tTable(\"payment_records\").\n\t\tWhere(filter).\n\t\tOrder(\"created_at DESC\").\n\t\tFind(&records).Error\n\n\treturn records, err\n}",
    "caller": "func ProcessCreditCardTransactions(orderNum string) ([]PaymentRecord, error) {\n\tcreditWallet := &Wallet{\n\t\tPaymentType:   1,\n\t\tCertificateId: orderNum,\n\t}\n\n\ttransactions, err := creditWallet.ProcessPayment()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"credit card payment failed: %v\", err)\n\t}\n\n\treturn transactions, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "PaymentType=1 (CreditCard) with CertificateId",
            "sql": "SELECT * FROM payment_records WHERE status = 1 AND method = 'credit_card' AND certificate_id = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "PaymentType=2 (WalletBalance) with CertificateId",
            "sql": "SELECT * FROM payment_records WHERE status = 1 AND method = 'wallet_balance' AND certificate_id = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "PaymentType=3 (BankTransfer) with CertificateId",
            "sql": "SELECT * FROM payment_records WHERE status = 1 AND method = 'bank_transfer' AND certificate_id = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "PaymentType=1 (CreditCard) without CertificateId",
            "sql": "SELECT * FROM payment_records WHERE status = 1 AND method = 'credit_card' ORDER BY created_at DESC;"
          },
          {
            "scenario": "PaymentType=2 (WalletBalance) without CertificateId",
            "sql": "SELECT * FROM payment_records WHERE status = 1 AND method = 'wallet_balance' ORDER BY created_at DESC;"
          },
          {
            "scenario": "PaymentType=3 (BankTransfer) without CertificateId",
            "sql": "SELECT * FROM payment_records WHERE status = 1 AND method = 'bank_transfer' ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Wallet",
        "code_value": "type Wallet struct {\n\tPaymentType    int\n\tCertificateId  string\n}"
      },
      {
        "code_key": "PaymentRecord",
        "code_value": "type PaymentRecord struct {\n\tID           uint   `gorm:\"primaryKey\"`\n\tMethod       string `gorm:\"column:method\"`\n\tStatus       int    `gorm:\"column:status\"`\n\tCertificateId string `gorm:\"column:certificate_id\"`\n\tCreatedAt    time.Time `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "PaymentStatus",
        "code_value": "const (\n\tPaymentPending = 0\n\tPaymentSuccess = 1\n\tPaymentFailed  = 2\n)"
      },
      {
        "code_key": "PaymentMethod",
        "code_value": "const (\n\tCreditCard    = 1\n\tWalletBalance = 2\n\tBankTransfer  = 3\n)"
      },
      {
        "code_key": "BillingTable",
        "code_value": "const BillingTable = \"payment_records\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ProcessPayment",
    "orm_code": "func (w *Wallet) ProcessPayment() ([]PaymentRecord, error) {\n\trecords := make([]PaymentRecord, 0)\n\tfilter := map[string]interface{}{\n\t\t\"status\": 1,\n\t}\n\n\tswitch w.PaymentType {\n\tcase 1:\n\t\tfilter[\"method\"] = \"credit_card\"\n\tcase 2:\n\t\tfilter[\"method\"] = \"wallet_balance\"\n\tcase 3:\n\t\tfilter[\"method\"] = \"bank_transfer\"\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported payment type\")\n\t}\n\n\tif w.CertificateId != \"\" {\n\t\tfilter[\"certificate_id\"] = w.CertificateId\n\t}\n\n\terr := base.GetInstance().BillingDriver().\n\t\tTable(\"payment_records\").\n\t\tWhere(filter).\n\t\tOrder(\"created_at DESC\").\n\t\tFind(&records).Error\n\n\treturn records, err\n}",
    "caller": "func RetrieveBankTransferHistory(reference string) ([]PaymentRecord, error) {\n\tbankWallet := &Wallet{\n\t\tPaymentType:   3,\n\t\tCertificateId: reference,\n\t}\n\n\thistory, err := bankWallet.ProcessPayment()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to retrieve bank transfers: %v\", err)\n\t}\n\n\treturn history, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "CertificateId is not empty",
            "sql": "SELECT * FROM payment_records WHERE status = 1 AND method = 'bank_transfer' AND certificate_id = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "CertificateId is empty",
            "sql": "SELECT * FROM payment_records WHERE status = 1 AND method = 'bank_transfer' ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Wallet",
        "code_value": "type Wallet struct {\n\tPaymentType    int\n\tCertificateId  string\n}"
      },
      {
        "code_key": "PaymentRecord",
        "code_value": "type PaymentRecord struct {\n\tID           uint   `gorm:\"primaryKey\"`\n\tMethod       string `gorm:\"column:method\"`\n\tStatus       int    `gorm:\"column:status\"`\n\tCertificateId string `gorm:\"column:certificate_id\"`\n\tCreatedAt    time.Time `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "PaymentStatus",
        "code_value": "const (\n\tPaymentPending = 0\n\tPaymentSuccess = 1\n\tPaymentFailed  = 2\n)"
      },
      {
        "code_key": "PaymentMethod",
        "code_value": "const (\n\tCreditCard    = 1\n\tWalletBalance = 2\n\tBankTransfer  = 3\n)"
      },
      {
        "code_key": "BillingTable",
        "code_value": "const BillingTable = \"payment_records\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "AssignTask",
    "orm_code": "func (s *Shipment) AssignTask() ([]types.TaskInfo, error) {\n\ttasks := make([]types.TaskInfo, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tswitch s.Priority {\n\tcase 1:\n\t\tfilter[\"urgent\"] = true\n\tcase 2:\n\t\tfilter[\"normal\"] = true\n\tcase 3:\n\t\tfilter[\"low\"] = true\n\tdefault:\n\t\treturn nil, errors.New(\"invalid priority level\")\n\t}\n\n\tif s.LocationCode != \"\" {\n\t\tfilter[\"location_code\"] = s.LocationCode\n\t}\n\n\terr := base.GetInstance().LogisticsDriver().Table(\"brand_info\").\n\t\tWhere(filter).Order(\"created_at DESC\").Find(&tasks).Error\n\t\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn tasks, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Priority=1(Urgent) with LocationCode",
            "sql": "SELECT id, urgent, normal, low, location_code, created_at FROM brand_info WHERE status = 1 AND urgent = true AND location_code = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "Priority=1(Urgent) without LocationCode",
            "sql": "SELECT id, urgent, normal, low, location_code, created_at FROM brand_info WHERE status = 1 AND urgent = true ORDER BY created_at DESC;"
          },
          {
            "scenario": "Priority=2(Normal) with LocationCode",
            "sql": "SELECT id, urgent, normal, low, location_code, created_at FROM brand_info WHERE status = 1 AND normal = true AND location_code = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "Priority=2(Normal) without LocationCode",
            "sql": "SELECT id, urgent, normal, low, location_code, created_at FROM brand_info WHERE status = 1 AND normal = true ORDER BY created_at DESC;"
          },
          {
            "scenario": "Priority=3(Low) with LocationCode",
            "sql": "SELECT id, urgent, normal, low, location_code, created_at FROM brand_info WHERE status = 1 AND low = true AND location_code = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "Priority=3(Low) without LocationCode",
            "sql": "SELECT id, urgent, normal, low, location_code, created_at FROM brand_info WHERE status = 1 AND low = true ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "TaskInfo",
        "code_value": "type TaskInfo struct {\n\tID          int       `json:\"id\" gorm:\"column:id\"`\n\tUrgent      bool      `json:\"urgent\" gorm:\"column:urgent\"`\n\tNormal      bool      `json:\"normal\" gorm:\"column:normal\"`\n\tLow         bool      `json:\"low\" gorm:\"column:low\"`\n\tLocationCode string    `json:\"location_code\" gorm:\"column:location_code\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "Shipment",
        "code_value": "type Shipment struct {\n\tPriority     int\n\tLocationCode string\n}"
      },
      {
        "code_key": "TaskStatus",
        "code_value": "const TaskStatusActive = 1"
      },
      {
        "code_key": "PriorityLevel",
        "code_value": "const (\n\tPriorityUrgent = 1\n\tPriorityNormal = 2\n\tPriorityLow    = 3\n)"
      },
      {
        "code_key": "BrandTable",
        "code_value": "const BrandTable = \"brand_info\""
      },
      {
        "code_key": "TaskAssignment",
        "code_value": "type TaskAssignment struct {\n\tTaskID   int\n\tDriverID int\n\tStatus   int\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "AssignTask",
    "orm_code": "func (s *Shipment) AssignTask() ([]types.TaskInfo, error) {\n\ttasks := make([]types.TaskInfo, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tswitch s.Priority {\n\tcase 1:\n\t\tfilter[\"urgent\"] = true\n\tcase 2:\n\t\tfilter[\"normal\"] = true\n\tcase 3:\n\t\tfilter[\"low\"] = true\n\tdefault:\n\t\treturn nil, errors.New(\"invalid priority level\")\n\t}\n\n\tif s.LocationCode != \"\" {\n\t\tfilter[\"location_code\"] = s.LocationCode\n\t}\n\n\terr := base.GetInstance().LogisticsDriver().Table(\"brand_info\").\n\t\tWhere(filter).Order(\"created_at DESC\").Find(&tasks).Error\n\t\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn tasks, nil\n}",
    "caller": "func HandleUrgentShipment() ([]types.TaskInfo, error) {\n\texpressShipment := &Shipment{\n\t\tPriority:     1,\n\t\tLocationCode: \"NYC123\",\n\t}\n\ttasks, err := expressShipment.AssignTask()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to assign urgent tasks: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn tasks, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Priority=Urgent(1) with LocationCode",
            "sql": "SELECT id, urgent, normal, low, location_code, created_at FROM brand_info WHERE status = 1 AND urgent = true AND location_code = 'NYC123' ORDER BY created_at DESC;"
          },
          {
            "scenario": "Priority=Normal(2) with LocationCode",
            "sql": "SELECT id, urgent, normal, low, location_code, created_at FROM brand_info WHERE status = 1 AND normal = true AND location_code = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "Priority=Low(3) with LocationCode",
            "sql": "SELECT id, urgent, normal, low, location_code, created_at FROM brand_info WHERE status = 1 AND low = true AND location_code = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "Priority=Urgent(1) without LocationCode",
            "sql": "SELECT id, urgent, normal, low, location_code, created_at FROM brand_info WHERE status = 1 AND urgent = true ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "TaskInfo",
        "code_value": "type TaskInfo struct {\n\tID          int       `json:\"id\" gorm:\"column:id\"`\n\tUrgent      bool      `json:\"urgent\" gorm:\"column:urgent\"`\n\tNormal      bool      `json:\"normal\" gorm:\"column:normal\"`\n\tLow         bool      `json:\"low\" gorm:\"column:low\"`\n\tLocationCode string    `json:\"location_code\" gorm:\"column:location_code\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "Shipment",
        "code_value": "type Shipment struct {\n\tPriority     int\n\tLocationCode string\n}"
      },
      {
        "code_key": "TaskStatus",
        "code_value": "const TaskStatusActive = 1"
      },
      {
        "code_key": "PriorityLevel",
        "code_value": "const (\n\tPriorityUrgent = 1\n\tPriorityNormal = 2\n\tPriorityLow    = 3\n)"
      },
      {
        "code_key": "BrandTable",
        "code_value": "const BrandTable = \"brand_info\""
      },
      {
        "code_key": "TaskAssignment",
        "code_value": "type TaskAssignment struct {\n\tTaskID   int\n\tDriverID int\n\tStatus   int\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "AssignTask",
    "orm_code": "func (s *Shipment) AssignTask() ([]types.TaskInfo, error) {\n\ttasks := make([]types.TaskInfo, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tswitch s.Priority {\n\tcase 1:\n\t\tfilter[\"urgent\"] = true\n\tcase 2:\n\t\tfilter[\"normal\"] = true\n\tcase 3:\n\t\tfilter[\"low\"] = true\n\tdefault:\n\t\treturn nil, errors.New(\"invalid priority level\")\n\t}\n\n\tif s.LocationCode != \"\" {\n\t\tfilter[\"location_code\"] = s.LocationCode\n\t}\n\n\terr := base.GetInstance().LogisticsDriver().Table(\"brand_info\").\n\t\tWhere(filter).Order(\"created_at DESC\").Find(&tasks).Error\n\t\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn tasks, nil\n}",
    "caller": "func ProcessRegionalTasks(region string) ([]types.TaskInfo, error) {\n\tregionalDelivery := Shipment{\n\t\tPriority:     2,\n\t\tLocationCode: region,\n\t}\n\n\tavailableTasks, err := regionalDelivery.AssignTask()\n\tif err != nil {\n\t\tlog.Printf(\"Error fetching regional tasks for %s: %v\", region, err)\n\t\treturn nil, fmt.Errorf(\"region processing error: %w\", err)\n\t}\n\treturn availableTasks, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "LocationCode not empty",
            "sql": "SELECT id, urgent, normal, low, location_code, created_at FROM brand_info WHERE status = 1 AND normal = true AND location_code = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "LocationCode empty",
            "sql": "SELECT id, urgent, normal, low, location_code, created_at FROM brand_info WHERE status = 1 AND normal = true ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "TaskInfo",
        "code_value": "type TaskInfo struct {\n\tID          int       `json:\"id\" gorm:\"column:id\"`\n\tUrgent      bool      `json:\"urgent\" gorm:\"column:urgent\"`\n\tNormal      bool      `json:\"normal\" gorm:\"column:normal\"`\n\tLow         bool      `json:\"low\" gorm:\"column:low\"`\n\tLocationCode string    `json:\"location_code\" gorm:\"column:location_code\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "Shipment",
        "code_value": "type Shipment struct {\n\tPriority     int\n\tLocationCode string\n}"
      },
      {
        "code_key": "TaskStatus",
        "code_value": "const TaskStatusActive = 1"
      },
      {
        "code_key": "PriorityLevel",
        "code_value": "const (\n\tPriorityUrgent = 1\n\tPriorityNormal = 2\n\tPriorityLow    = 3\n)"
      },
      {
        "code_key": "BrandTable",
        "code_value": "const BrandTable = \"brand_info\""
      },
      {
        "code_key": "TaskAssignment",
        "code_value": "type TaskAssignment struct {\n\tTaskID   int\n\tDriverID int\n\tStatus   int\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "AssignTask",
    "orm_code": "func (s *Shipment) AssignTask() ([]types.TaskInfo, error) {\n\ttasks := make([]types.TaskInfo, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tswitch s.Priority {\n\tcase 1:\n\t\tfilter[\"urgent\"] = true\n\tcase 2:\n\t\tfilter[\"normal\"] = true\n\tcase 3:\n\t\tfilter[\"low\"] = true\n\tdefault:\n\t\treturn nil, errors.New(\"invalid priority level\")\n\t}\n\n\tif s.LocationCode != \"\" {\n\t\tfilter[\"location_code\"] = s.LocationCode\n\t}\n\n\terr := base.GetInstance().LogisticsDriver().Table(\"brand_info\").\n\t\tWhere(filter).Order(\"created_at DESC\").Find(&tasks).Error\n\t\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn tasks, nil\n}",
    "caller": "func GetLowPriorityTasks() []types.TaskInfo {\n\tbacklogShipment := Shipment{Priority: 3}\n\ttasks, err := backlogShipment.AssignTask()\n\tif err != nil {\n\t\tlog.Println(\"Non-critical error fetching low-priority tasks:\", err)\n\t\treturn []types.TaskInfo{}\n\t}\n\treturn tasks\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "高优先级任务(Priority=1)",
            "sql": "SELECT id, urgent, normal, low, location_code, created_at FROM brand_info WHERE status = 1 AND urgent = true ORDER BY created_at DESC;"
          },
          {
            "scenario": "中优先级任务(Priority=2)",
            "sql": "SELECT id, urgent, normal, low, location_code, created_at FROM brand_info WHERE status = 1 AND normal = true ORDER BY created_at DESC;"
          },
          {
            "scenario": "低优先级任务(Priority=3) - 无LocationCode",
            "sql": "SELECT id, urgent, normal, low, location_code, created_at FROM brand_info WHERE status = 1 AND low = true ORDER BY created_at DESC;"
          },
          {
            "scenario": "带LocationCode的低优先级任务",
            "sql": "SELECT id, urgent, normal, low, location_code, created_at FROM brand_info WHERE status = 1 AND low = true AND location_code = ? ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "TaskInfo",
        "code_value": "type TaskInfo struct {\n\tID          int       `json:\"id\" gorm:\"column:id\"`\n\tUrgent      bool      `json:\"urgent\" gorm:\"column:urgent\"`\n\tNormal      bool      `json:\"normal\" gorm:\"column:normal\"`\n\tLow         bool      `json:\"low\" gorm:\"column:low\"`\n\tLocationCode string    `json:\"location_code\" gorm:\"column:location_code\"`\n\tCreatedAt   time.Time `json:\"created_at\" gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "Shipment",
        "code_value": "type Shipment struct {\n\tPriority     int\n\tLocationCode string\n}"
      },
      {
        "code_key": "TaskStatus",
        "code_value": "const TaskStatusActive = 1"
      },
      {
        "code_key": "PriorityLevel",
        "code_value": "const (\n\tPriorityUrgent = 1\n\tPriorityNormal = 2\n\tPriorityLow    = 3\n)"
      },
      {
        "code_key": "BrandTable",
        "code_value": "const BrandTable = \"brand_info\""
      },
      {
        "code_key": "TaskAssignment",
        "code_value": "type TaskAssignment struct {\n\tTaskID   int\n\tDriverID int\n\tStatus   int\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "SendNotification",
    "orm_code": "func (g *Guild) SendNotification(threshold int) ([]NotificationTarget, error) {\n\ttargets := make([]NotificationTarget, 0)\n\tfilter := map[string]interface{}{\"status\": 1}\n\t\n\tswitch g.CategoryType {\n\tcase 1:\n\t\tfilter[\"high_priority\"] = true\n\tcase 2:\n\t\tfilter[\"medium_priority\"] = true\n\tcase 3:\n\t\tfilter[\"low_priority\"] = true\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported category type\")\n\t}\n\t\n\tif threshold > 0 {\n\t\tfilter[\"score\"] = gorm.Expr(\"score > ?\", threshold)\n\t}\n\t\n\terr := base.GetInstance().NotifyDriver().Table(\"notification_targets\").\n\t\tWhere(filter).Find(&targets).Error\n\t\t\n\treturn targets, err\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "CategoryType=1 (高优先级)且threshold=0",
            "sql": "SELECT id, target_name, email, high_priority, medium_priority, low_priority, score, status FROM notification_targets WHERE status = 1 AND high_priority = true;"
          },
          {
            "scenario": "CategoryType=1 (高优先级)且threshold>0",
            "sql": "SELECT id, target_name, email, high_priority, medium_priority, low_priority, score, status FROM notification_targets WHERE status = 1 AND high_priority = true AND score > ?;"
          },
          {
            "scenario": "CategoryType=2 (中优先级)且threshold=0",
            "sql": "SELECT id, target_name, email, high_priority, medium_priority, low_priority, score, status FROM notification_targets WHERE status = 1 AND medium_priority = true;"
          },
          {
            "scenario": "CategoryType=2 (中优先级)且threshold>0",
            "sql": "SELECT id, target_name, email, high_priority, medium_priority, low_priority, score, status FROM notification_targets WHERE status = 1 AND medium_priority = true AND score > ?;"
          },
          {
            "scenario": "CategoryType=3 (低优先级)且threshold=0",
            "sql": "SELECT id, target_name, email, high_priority, medium_priority, low_priority, score, status FROM notification_targets WHERE status = 1 AND low_priority = true;"
          },
          {
            "scenario": "CategoryType=3 (低优先级)且threshold>0",
            "sql": "SELECT id, target_name, email, high_priority, medium_priority, low_priority, score, status FROM notification_targets WHERE status = 1 AND low_priority = true AND score > ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Guild",
        "code_value": "type Guild struct {\n\tCategoryType int\n}"
      },
      {
        "code_key": "NotificationTarget",
        "code_value": "type NotificationTarget struct {\n\tID           int    `gorm:\"column:id\"`\n\tTargetName   string `gorm:\"column:target_name\"`\n\tEmail        string `gorm:\"column:email\"`\n\tHighPriority bool   `gorm:\"column:high_priority\"`\n\tMediumPriority bool `gorm:\"column:medium_priority\"`\n\tLowPriority  bool   `gorm:\"column:low_priority\"`\n\tScore        int    `gorm:\"column:score\"`\n\tStatus       int    `gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "NotificationTargetsTable",
        "code_value": "const NotificationTargetsTable = \"notification_targets\""
      },
      {
        "code_key": "NotificationStatus",
        "code_value": "const (\n\tActiveStatus = 1\n\tInactiveStatus = 0\n)"
      },
      {
        "code_key": "CategoryType",
        "code_value": "const (\n\tHighPriorityCategory = 1\n\tMediumPriorityCategory = 2\n\tLowPriorityCategory = 3\n)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "SendNotification",
    "orm_code": "func (g *Guild) SendNotification(threshold int) ([]NotificationTarget, error) {\n\ttargets := make([]NotificationTarget, 0)\n\tfilter := map[string]interface{}{\"status\": 1}\n\t\n\tswitch g.CategoryType {\n\tcase 1:\n\t\tfilter[\"high_priority\"] = true\n\tcase 2:\n\t\tfilter[\"medium_priority\"] = true\n\tcase 3:\n\t\tfilter[\"low_priority\"] = true\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported category type\")\n\t}\n\t\n\tif threshold > 0 {\n\t\tfilter[\"score\"] = gorm.Expr(\"score > ?\", threshold)\n\t}\n\t\n\terr := base.GetInstance().NotifyDriver().Table(\"notification_targets\").\n\t\tWhere(filter).Find(&targets).Error\n\t\t\n\treturn targets, err\n}",
    "caller": "func HandleGuildAlerts() error {\n\tguild := &Guild{CategoryType: 2} // Medium priority guild\n\talerts, err := guild.SendNotification(75)\n\tif err != nil {\n\t\tlog.Printf(\"Failed to send alerts: %v\", err)\n\t\treturn err\n\t}\n\tlog.Printf(\"Sent %d medium priority alerts\", len(alerts))\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "CategoryType=1 (HighPriority) with no threshold",
            "sql": "SELECT id, target_name, email, high_priority, medium_priority, low_priority, score, status FROM notification_targets WHERE status = 1 AND high_priority = true;"
          },
          {
            "scenario": "CategoryType=2 (MediumPriority) with threshold=75",
            "sql": "SELECT id, target_name, email, high_priority, medium_priority, low_priority, score, status FROM notification_targets WHERE status = 1 AND medium_priority = true AND score > 75;"
          },
          {
            "scenario": "CategoryType=3 (LowPriority) with threshold=50",
            "sql": "SELECT id, target_name, email, high_priority, medium_priority, low_priority, score, status FROM notification_targets WHERE status = 1 AND low_priority = true AND score > 50;"
          },
          {
            "scenario": "Invalid CategoryType (no SQL generated)",
            "sql": ""
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Guild",
        "code_value": "type Guild struct {\n\tCategoryType int\n}"
      },
      {
        "code_key": "NotificationTarget",
        "code_value": "type NotificationTarget struct {\n\tID           int    `gorm:\"column:id\"`\n\tTargetName   string `gorm:\"column:target_name\"`\n\tEmail        string `gorm:\"column:email\"`\n\tHighPriority bool   `gorm:\"column:high_priority\"`\n\tMediumPriority bool `gorm:\"column:medium_priority\"`\n\tLowPriority  bool   `gorm:\"column:low_priority\"`\n\tScore        int    `gorm:\"column:score\"`\n\tStatus       int    `gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "NotificationTargetsTable",
        "code_value": "const NotificationTargetsTable = \"notification_targets\""
      },
      {
        "code_key": "NotificationStatus",
        "code_value": "const (\n\tActiveStatus = 1\n\tInactiveStatus = 0\n)"
      },
      {
        "code_key": "CategoryType",
        "code_value": "const (\n\tHighPriorityCategory = 1\n\tMediumPriorityCategory = 2\n\tLowPriorityCategory = 3\n)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "SendNotification",
    "orm_code": "func (g *Guild) SendNotification(threshold int) ([]NotificationTarget, error) {\n\ttargets := make([]NotificationTarget, 0)\n\tfilter := map[string]interface{}{\"status\": 1}\n\t\n\tswitch g.CategoryType {\n\tcase 1:\n\t\tfilter[\"high_priority\"] = true\n\tcase 2:\n\t\tfilter[\"medium_priority\"] = true\n\tcase 3:\n\t\tfilter[\"low_priority\"] = true\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported category type\")\n\t}\n\t\n\tif threshold > 0 {\n\t\tfilter[\"score\"] = gorm.Expr(\"score > ?\", threshold)\n\t}\n\t\n\terr := base.GetInstance().NotifyDriver().Table(\"notification_targets\").\n\t\tWhere(filter).Find(&targets).Error\n\t\t\n\treturn targets, err\n}",
    "caller": "func ProcessVIPNotifications() (int, error) {\n\tvipGuild := &Guild{CategoryType: 1} // High priority VIP guild\n\ttargets, err := vipGuild.SendNotification(90)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"VIP notification failed: %w\", err)\n\t}\n\treturn len(targets), nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "高优先级场景（当前调用者场景）",
            "sql": "SELECT id, target_name, email, high_priority, medium_priority, low_priority, score, status FROM notification_targets WHERE status = 1 AND high_priority = true AND score > 90;"
          },
          {
            "scenario": "中优先级场景",
            "sql": "SELECT id, target_name, email, high_priority, medium_priority, low_priority, score, status FROM notification_targets WHERE status = 1 AND medium_priority = true AND score > 50;"
          },
          {
            "scenario": "低优先级场景",
            "sql": "SELECT id, target_name, email, high_priority, medium_priority, low_priority, score, status FROM notification_targets WHERE status = 1 AND low_priority = true;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Guild",
        "code_value": "type Guild struct {\n\tCategoryType int\n}"
      },
      {
        "code_key": "NotificationTarget",
        "code_value": "type NotificationTarget struct {\n\tID           int    `gorm:\"column:id\"`\n\tTargetName   string `gorm:\"column:target_name\"`\n\tEmail        string `gorm:\"column:email\"`\n\tHighPriority bool   `gorm:\"column:high_priority\"`\n\tMediumPriority bool `gorm:\"column:medium_priority\"`\n\tLowPriority  bool   `gorm:\"column:low_priority\"`\n\tScore        int    `gorm:\"column:score\"`\n\tStatus       int    `gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "NotificationTargetsTable",
        "code_value": "const NotificationTargetsTable = \"notification_targets\""
      },
      {
        "code_key": "NotificationStatus",
        "code_value": "const (\n\tActiveStatus = 1\n\tInactiveStatus = 0\n)"
      },
      {
        "code_key": "CategoryType",
        "code_value": "const (\n\tHighPriorityCategory = 1\n\tMediumPriorityCategory = 2\n\tLowPriorityCategory = 3\n)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "SendNotification",
    "orm_code": "func (g *Guild) SendNotification(threshold int) ([]NotificationTarget, error) {\n\ttargets := make([]NotificationTarget, 0)\n\tfilter := map[string]interface{}{\"status\": 1}\n\t\n\tswitch g.CategoryType {\n\tcase 1:\n\t\tfilter[\"high_priority\"] = true\n\tcase 2:\n\t\tfilter[\"medium_priority\"] = true\n\tcase 3:\n\t\tfilter[\"low_priority\"] = true\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported category type\")\n\t}\n\t\n\tif threshold > 0 {\n\t\tfilter[\"score\"] = gorm.Expr(\"score > ?\", threshold)\n\t}\n\t\n\terr := base.GetInstance().NotifyDriver().Table(\"notification_targets\").\n\t\tWhere(filter).Find(&targets).Error\n\t\t\n\treturn targets, err\n}",
    "caller": "func MonitorLowPriorityEvents() {\n\tcasualGuild := &Guild{CategoryType: 3} // Low priority guild\n\trecipients, _ := casualGuild.SendNotification(0) // No threshold\n\tif len(recipients) > 0 {\n\t\tfmt.Println(\"Broadcasted to\", len(recipients), \"casual members\")\n\t}\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "CategoryType = 3 (low priority) and threshold = 0",
            "sql": "SELECT id, target_name, email, high_priority, medium_priority, low_priority, score, status FROM notification_targets WHERE status = 1 AND low_priority = true;"
          },
          {
            "scenario": "CategoryType = 1 (high priority) and threshold > 0",
            "sql": "SELECT id, target_name, email, high_priority, medium_priority, low_priority, score, status FROM notification_targets WHERE status = 1 AND high_priority = true AND score > ?;"
          },
          {
            "scenario": "CategoryType = 2 (medium priority) and threshold = 0",
            "sql": "SELECT id, target_name, email, high_priority, medium_priority, low_priority, score, status FROM notification_targets WHERE status = 1 AND medium_priority = true;"
          },
          {
            "scenario": "CategoryType = 3 (low priority) and threshold > 0",
            "sql": "SELECT id, target_name, email, high_priority, medium_priority, low_priority, score, status FROM notification_targets WHERE status = 1 AND low_priority = true AND score > ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Guild",
        "code_value": "type Guild struct {\n\tCategoryType int\n}"
      },
      {
        "code_key": "NotificationTarget",
        "code_value": "type NotificationTarget struct {\n\tID           int    `gorm:\"column:id\"`\n\tTargetName   string `gorm:\"column:target_name\"`\n\tEmail        string `gorm:\"column:email\"`\n\tHighPriority bool   `gorm:\"column:high_priority\"`\n\tMediumPriority bool `gorm:\"column:medium_priority\"`\n\tLowPriority  bool   `gorm:\"column:low_priority\"`\n\tScore        int    `gorm:\"column:score\"`\n\tStatus       int    `gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "NotificationTargetsTable",
        "code_value": "const NotificationTargetsTable = \"notification_targets\""
      },
      {
        "code_key": "NotificationStatus",
        "code_value": "const (\n\tActiveStatus = 1\n\tInactiveStatus = 0\n)"
      },
      {
        "code_key": "CategoryType",
        "code_value": "const (\n\tHighPriorityCategory = 1\n\tMediumPriorityCategory = 2\n\tLowPriorityCategory = 3\n)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "FindByCategory",
    "orm_code": "func (w *Weapon) FindByCategory() ([]WeaponInfo, error) {\n\tweapons := make([]WeaponInfo, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\tif w.Editor != \"\" {\n\t\tfilter[\"editor\"] = w.Editor\n\t}\n\tswitch w.Category {\n\tcase \"melee\":\n\t\tfilter[\"range_type\"] = \"close\"\n\tcase \"ranged\":\n\t\tfilter[\"range_type\"] = \"far\"\n\tcase \"explosive\":\n\t\tfilter[\"damage_type\"] = \"aoe\"\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported weapon category\")\n\t}\n\terr := base.GetInstance().ArmoryDriver().Table(\"warehouse_stock\").\n\t\tWhere(filter).Find(&weapons).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn weapons, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Category='melee'且Editor有值",
            "sql": "SELECT id, name, range_type, damage_type, editor, status FROM warehouse_stock WHERE status = 1 AND editor = ? AND range_type = 'close';"
          },
          {
            "scenario": "Category='ranged'且Editor为空",
            "sql": "SELECT id, name, range_type, damage_type, editor, status FROM warehouse_stock WHERE status = 1 AND range_type = 'far';"
          },
          {
            "scenario": "Category='explosive'且Editor有值",
            "sql": "SELECT id, name, range_type, damage_type, editor, status FROM warehouse_stock WHERE status = 1 AND editor = ? AND damage_type = 'aoe';"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Weapon",
        "code_value": "type Weapon struct {\n\tCategory string\n\tEditor   string\n\tStatus   int\n}"
      },
      {
        "code_key": "WeaponInfo",
        "code_value": "type WeaponInfo struct {\n\tID         int    `gorm:\"column:id\"`\n\tName       string `gorm:\"column:name\"`\n\tRangeType  string `gorm:\"column:range_type\"`\n\tDamageType string `gorm:\"column:damage_type\"`\n\tEditor     string `gorm:\"column:editor\"`\n\tStatus     int    `gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "WarehouseStockTable",
        "code_value": "const WarehouseStockTable = \"warehouse_stock\""
      },
      {
        "code_key": "WeaponStatusActive",
        "code_value": "const WeaponStatusActive = 1"
      },
      {
        "code_key": "RangeTypeClose",
        "code_value": "const RangeTypeClose = \"close\""
      },
      {
        "code_key": "RangeTypeFar",
        "code_value": "const RangeTypeFar = \"far\""
      },
      {
        "code_key": "DamageTypeAOE",
        "code_value": "const DamageTypeAOE = \"aoe\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "FindByCategory",
    "orm_code": "func (w *Weapon) FindByCategory() ([]WeaponInfo, error) {\n\tweapons := make([]WeaponInfo, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\tif w.Editor != \"\" {\n\t\tfilter[\"editor\"] = w.Editor\n\t}\n\tswitch w.Category {\n\tcase \"melee\":\n\t\tfilter[\"range_type\"] = \"close\"\n\tcase \"ranged\":\n\t\tfilter[\"range_type\"] = \"far\"\n\tcase \"explosive\":\n\t\tfilter[\"damage_type\"] = \"aoe\"\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported weapon category\")\n\t}\n\terr := base.GetInstance().ArmoryDriver().Table(\"warehouse_stock\").\n\t\tWhere(filter).Find(&weapons).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn weapons, nil\n}",
    "caller": "func HandleArmoryRequest(category string, editor string) ([]WeaponInfo, error) {\n\tarmoryItem := Weapon{\n\t\tCategory: category,\n\t\tEditor:   editor,\n\t}\n\tresult, err := armoryItem.FindByCategory()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to fetch armory items: %v\", err)\n\t\treturn nil, fmt.Errorf(\"armory request failed\")\n\t}\n\treturn result, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Category is 'melee' and Editor is not empty",
            "sql": "SELECT id, name, range_type, damage_type, editor, status FROM warehouse_stock WHERE status = 1 AND editor = ? AND range_type = 'close';"
          },
          {
            "scenario": "Category is 'melee' and Editor is empty",
            "sql": "SELECT id, name, range_type, damage_type, editor, status FROM warehouse_stock WHERE status = 1 AND range_type = 'close';"
          },
          {
            "scenario": "Category is 'ranged' and Editor is not empty",
            "sql": "SELECT id, name, range_type, damage_type, editor, status FROM warehouse_stock WHERE status = 1 AND editor = ? AND range_type = 'far';"
          },
          {
            "scenario": "Category is 'ranged' and Editor is empty",
            "sql": "SELECT id, name, range_type, damage_type, editor, status FROM warehouse_stock WHERE status = 1 AND range_type = 'far';"
          },
          {
            "scenario": "Category is 'explosive' and Editor is not empty",
            "sql": "SELECT id, name, range_type, damage_type, editor, status FROM warehouse_stock WHERE status = 1 AND editor = ? AND damage_type = 'aoe';"
          },
          {
            "scenario": "Category is 'explosive' and Editor is empty",
            "sql": "SELECT id, name, range_type, damage_type, editor, status FROM warehouse_stock WHERE status = 1 AND damage_type = 'aoe';"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Weapon",
        "code_value": "type Weapon struct {\n\tCategory string\n\tEditor   string\n\tStatus   int\n}"
      },
      {
        "code_key": "WeaponInfo",
        "code_value": "type WeaponInfo struct {\n\tID         int    `gorm:\"column:id\"`\n\tName       string `gorm:\"column:name\"`\n\tRangeType  string `gorm:\"column:range_type\"`\n\tDamageType string `gorm:\"column:damage_type\"`\n\tEditor     string `gorm:\"column:editor\"`\n\tStatus     int    `gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "WarehouseStockTable",
        "code_value": "const WarehouseStockTable = \"warehouse_stock\""
      },
      {
        "code_key": "WeaponStatusActive",
        "code_value": "const WeaponStatusActive = 1"
      },
      {
        "code_key": "RangeTypeClose",
        "code_value": "const RangeTypeClose = \"close\""
      },
      {
        "code_key": "RangeTypeFar",
        "code_value": "const RangeTypeFar = \"far\""
      },
      {
        "code_key": "DamageTypeAOE",
        "code_value": "const DamageTypeAOE = \"aoe\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "FindByCategory",
    "orm_code": "func (w *Weapon) FindByCategory() ([]WeaponInfo, error) {\n\tweapons := make([]WeaponInfo, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\tif w.Editor != \"\" {\n\t\tfilter[\"editor\"] = w.Editor\n\t}\n\tswitch w.Category {\n\tcase \"melee\":\n\t\tfilter[\"range_type\"] = \"close\"\n\tcase \"ranged\":\n\t\tfilter[\"range_type\"] = \"far\"\n\tcase \"explosive\":\n\t\tfilter[\"damage_type\"] = \"aoe\"\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported weapon category\")\n\t}\n\terr := base.GetInstance().ArmoryDriver().Table(\"warehouse_stock\").\n\t\tWhere(filter).Find(&weapons).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn weapons, nil\n}",
    "caller": "func ProcessCombatGear() {\n\tcombatTools := Weapon{Category: \"ranged\", Editor: \"john_doe\"}\n\tgearList, err := combatTools.FindByCategory()\n\tif err != nil {\n\t\tlog.Fatal(\"Combat gear processing failed: \", err)\n\t}\n\tfmt.Printf(\"Retrieved %d combat gear items\\n\", len(gearList))\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Category=\"melee\", Editor=\"user1\"",
            "sql": "SELECT id, name, range_type, damage_type, editor, status FROM warehouse_stock WHERE status = 1 AND editor = 'user1' AND range_type = 'close';"
          },
          {
            "scenario": "Category=\"explosive\", Editor=\"\"",
            "sql": "SELECT id, name, range_type, damage_type, editor, status FROM warehouse_stock WHERE status = 1 AND damage_type = 'aoe';"
          },
          {
            "scenario": "Category=\"ranged\", Editor=\"\"",
            "sql": "SELECT id, name, range_type, damage_type, editor, status FROM warehouse_stock WHERE status = 1 AND range_type = 'far';"
          },
          {
            "scenario": "Category=\"melee\", Editor=\"\"",
            "sql": "SELECT id, name, range_type, damage_type, editor, status FROM warehouse_stock WHERE status = 1 AND range_type = 'close';"
          },
          {
            "scenario": "Category=\"ranged\", Editor=\"john_doe\"",
            "sql": "SELECT id, name, range_type, damage_type, editor, status FROM warehouse_stock WHERE status = 1 AND editor = 'john_doe' AND range_type = 'far';"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Weapon",
        "code_value": "type Weapon struct {\n\tCategory string\n\tEditor   string\n\tStatus   int\n}"
      },
      {
        "code_key": "WeaponInfo",
        "code_value": "type WeaponInfo struct {\n\tID         int    `gorm:\"column:id\"`\n\tName       string `gorm:\"column:name\"`\n\tRangeType  string `gorm:\"column:range_type\"`\n\tDamageType string `gorm:\"column:damage_type\"`\n\tEditor     string `gorm:\"column:editor\"`\n\tStatus     int    `gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "WarehouseStockTable",
        "code_value": "const WarehouseStockTable = \"warehouse_stock\""
      },
      {
        "code_key": "WeaponStatusActive",
        "code_value": "const WeaponStatusActive = 1"
      },
      {
        "code_key": "RangeTypeClose",
        "code_value": "const RangeTypeClose = \"close\""
      },
      {
        "code_key": "RangeTypeFar",
        "code_value": "const RangeTypeFar = \"far\""
      },
      {
        "code_key": "DamageTypeAOE",
        "code_value": "const DamageTypeAOE = \"aoe\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "FindByCategory",
    "orm_code": "func (w *Weapon) FindByCategory() ([]WeaponInfo, error) {\n\tweapons := make([]WeaponInfo, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\tif w.Editor != \"\" {\n\t\tfilter[\"editor\"] = w.Editor\n\t}\n\tswitch w.Category {\n\tcase \"melee\":\n\t\tfilter[\"range_type\"] = \"close\"\n\tcase \"ranged\":\n\t\tfilter[\"range_type\"] = \"far\"\n\tcase \"explosive\":\n\t\tfilter[\"damage_type\"] = \"aoe\"\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported weapon category\")\n\t}\n\terr := base.GetInstance().ArmoryDriver().Table(\"warehouse_stock\").\n\t\tWhere(filter).Find(&weapons).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn weapons, nil\n}",
    "caller": "func AnalyzeExplosives(analyst string) error {\n\texplosiveWeapons := Weapon{\n\t\tCategory: \"explosive\",\n\t\tEditor:   analyst,\n\t}\n\tdata, err := explosiveWeapons.FindByCategory()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"explosive analysis failed: %w\", err)\n\t}\n\tfmt.Println(\"Explosive weapons analysis complete.\")\n\treturn nil\n}",
    "sql_statement_list": [
      "SELECT id, name, range_type, damage_type, editor, status FROM warehouse_stock WHERE status = 1 AND editor = ? AND damage_type = 'aoe';"
    ],
    "sql_types": [
      "SELECT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Weapon",
        "code_value": "type Weapon struct {\n\tCategory string\n\tEditor   string\n\tStatus   int\n}"
      },
      {
        "code_key": "WeaponInfo",
        "code_value": "type WeaponInfo struct {\n\tID         int    `gorm:\"column:id\"`\n\tName       string `gorm:\"column:name\"`\n\tRangeType  string `gorm:\"column:range_type\"`\n\tDamageType string `gorm:\"column:damage_type\"`\n\tEditor     string `gorm:\"column:editor\"`\n\tStatus     int    `gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "WarehouseStockTable",
        "code_value": "const WarehouseStockTable = \"warehouse_stock\""
      },
      {
        "code_key": "WeaponStatusActive",
        "code_value": "const WeaponStatusActive = 1"
      },
      {
        "code_key": "RangeTypeClose",
        "code_value": "const RangeTypeClose = \"close\""
      },
      {
        "code_key": "RangeTypeFar",
        "code_value": "const RangeTypeFar = \"far\""
      },
      {
        "code_key": "DamageTypeAOE",
        "code_value": "const DamageTypeAOE = \"aoe\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ProcessAssessmentByStatus",
    "orm_code": "func (a *Assessment) ProcessAssessmentByStatus() ([]Budget, error) {\n\tbudgets := make([]Budget, 0)\n\tquery := base.GetInstance().AssessmentDriver().Table(\"credit_scores\")\n\n\tswitch a.Status {\n\tcase \"pending\":\n\t\tquery = query.Where(\"Dimension = ? AND ZipCode IS NOT NULL\", a.Dimension)\n\tcase \"approved\":\n\t\tquery = query.Where(\"Longitude > ? AND processed_at IS NOT NULL\", a.Longitude)\n\tcase \"rejected\":\n\t\tquery = query.Where(\"Dimension = ? AND rejection_reason IS NOT NULL\", a.Dimension)\n\tdefault:\n\t\treturn nil, errors.New(\"invalid assessment status\")\n\t}\n\n\terr := query.Order(\"created_at DESC\").Limit(a.PageSize).Find(&budgets).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn budgets, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Status = pending",
            "sql": "SELECT id, dimension, zip_code, longitude, processed_at, rejection_reason, created_at FROM credit_scores WHERE Dimension = ? AND ZipCode IS NOT NULL ORDER BY created_at DESC LIMIT ?;"
          },
          {
            "scenario": "Status = approved",
            "sql": "SELECT id, dimension, zip_code, longitude, processed_at, rejection_reason, created_at FROM credit_scores WHERE Longitude > ? AND processed_at IS NOT NULL ORDER BY created_at DESC LIMIT ?;"
          },
          {
            "scenario": "Status = rejected",
            "sql": "SELECT id, dimension, zip_code, longitude, processed_at, rejection_reason, created_at FROM credit_scores WHERE Dimension = ? AND rejection_reason IS NOT NULL ORDER BY created_at DESC LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Assessment",
        "code_value": "type Assessment struct {\n\tStatus     string\n\tDimension  string\n\tLongitude  float64\n\tPageSize   int\n}"
      },
      {
        "code_key": "Budget",
        "code_value": "type Budget struct {\n\tID           int       `gorm:\"column:id\"`\n\tDimension    string    `gorm:\"column:dimension\"`\n\tZipCode      string    `gorm:\"column:zip_code\"`\n\tLongitude    float64   `gorm:\"column:longitude\"`\n\tProcessedAt  time.Time `gorm:\"column:processed_at\"`\n\tRejectionReason string  `gorm:\"column:rejection_reason\"`\n\tCreatedAt    time.Time `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "AssessmentStatus",
        "code_value": "const (\n\tPendingStatus  = \"pending\"\n\tApprovedStatus = \"approved\"\n\tRejectedStatus = \"rejected\"\n)"
      },
      {
        "code_key": "CreditScoresTable",
        "code_value": "const CreditScoresTable = \"credit_scores\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ProcessAssessmentByStatus",
    "orm_code": "func (a *Assessment) ProcessAssessmentByStatus() ([]Budget, error) {\n\tbudgets := make([]Budget, 0)\n\tquery := base.GetInstance().AssessmentDriver().Table(\"credit_scores\")\n\n\tswitch a.Status {\n\tcase \"pending\":\n\t\tquery = query.Where(\"Dimension = ? AND ZipCode IS NOT NULL\", a.Dimension)\n\tcase \"approved\":\n\t\tquery = query.Where(\"Longitude > ? AND processed_at IS NOT NULL\", a.Longitude)\n\tcase \"rejected\":\n\t\tquery = query.Where(\"Dimension = ? AND rejection_reason IS NOT NULL\", a.Dimension)\n\tdefault:\n\t\treturn nil, errors.New(\"invalid assessment status\")\n\t}\n\n\terr := query.Order(\"created_at DESC\").Limit(a.PageSize).Find(&budgets).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn budgets, nil\n}",
    "caller": "func HandlePendingAssessments(dimension string) ([]Budget, error) {\n\tassessment := &Assessment{\n\t\tStatus:    \"pending\",\n\t\tDimension: dimension,\n\t\tPageSize:  10,\n\t}\n\treturn assessment.ProcessAssessmentByStatus()\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "status is pending",
            "sql": "SELECT id, dimension, zip_code, longitude, processed_at, rejection_reason, created_at FROM credit_scores WHERE Dimension = ? AND ZipCode IS NOT NULL ORDER BY created_at DESC LIMIT 10;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Assessment",
        "code_value": "type Assessment struct {\n\tStatus     string\n\tDimension  string\n\tLongitude  float64\n\tPageSize   int\n}"
      },
      {
        "code_key": "Budget",
        "code_value": "type Budget struct {\n\tID           int       `gorm:\"column:id\"`\n\tDimension    string    `gorm:\"column:dimension\"`\n\tZipCode      string    `gorm:\"column:zip_code\"`\n\tLongitude    float64   `gorm:\"column:longitude\"`\n\tProcessedAt  time.Time `gorm:\"column:processed_at\"`\n\tRejectionReason string  `gorm:\"column:rejection_reason\"`\n\tCreatedAt    time.Time `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "AssessmentStatus",
        "code_value": "const (\n\tPendingStatus  = \"pending\"\n\tApprovedStatus = \"approved\"\n\tRejectedStatus = \"rejected\"\n)"
      },
      {
        "code_key": "CreditScoresTable",
        "code_value": "const CreditScoresTable = \"credit_scores\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ProcessAssessmentByStatus",
    "orm_code": "func (a *Assessment) ProcessAssessmentByStatus() ([]Budget, error) {\n\tbudgets := make([]Budget, 0)\n\tquery := base.GetInstance().AssessmentDriver().Table(\"credit_scores\")\n\n\tswitch a.Status {\n\tcase \"pending\":\n\t\tquery = query.Where(\"Dimension = ? AND ZipCode IS NOT NULL\", a.Dimension)\n\tcase \"approved\":\n\t\tquery = query.Where(\"Longitude > ? AND processed_at IS NOT NULL\", a.Longitude)\n\tcase \"rejected\":\n\t\tquery = query.Where(\"Dimension = ? AND rejection_reason IS NOT NULL\", a.Dimension)\n\tdefault:\n\t\treturn nil, errors.New(\"invalid assessment status\")\n\t}\n\n\terr := query.Order(\"created_at DESC\").Limit(a.PageSize).Find(&budgets).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn budgets, nil\n}",
    "caller": "func HandleApprovedAssessments(longitude float64) ([]Budget, error) {\n\tassessment := &Assessment{\n\t\tStatus:    \"approved\",\n\t\tLongitude: longitude,\n\t\tPageSize:  20,\n\t}\n\treturn assessment.ProcessAssessmentByStatus()\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "status is approved with given longitude and page size 20",
            "sql": "SELECT id, dimension, zip_code, longitude, processed_at, rejection_reason, created_at FROM credit_scores WHERE longitude > ? AND processed_at IS NOT NULL ORDER BY created_at DESC LIMIT 20;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Assessment",
        "code_value": "type Assessment struct {\n\tStatus     string\n\tDimension  string\n\tLongitude  float64\n\tPageSize   int\n}"
      },
      {
        "code_key": "Budget",
        "code_value": "type Budget struct {\n\tID           int       `gorm:\"column:id\"`\n\tDimension    string    `gorm:\"column:dimension\"`\n\tZipCode      string    `gorm:\"column:zip_code\"`\n\tLongitude    float64   `gorm:\"column:longitude\"`\n\tProcessedAt  time.Time `gorm:\"column:processed_at\"`\n\tRejectionReason string  `gorm:\"column:rejection_reason\"`\n\tCreatedAt    time.Time `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "AssessmentStatus",
        "code_value": "const (\n\tPendingStatus  = \"pending\"\n\tApprovedStatus = \"approved\"\n\tRejectedStatus = \"rejected\"\n)"
      },
      {
        "code_key": "CreditScoresTable",
        "code_value": "const CreditScoresTable = \"credit_scores\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ProcessAssessmentByStatus",
    "orm_code": "func (a *Assessment) ProcessAssessmentByStatus() ([]Budget, error) {\n\tbudgets := make([]Budget, 0)\n\tquery := base.GetInstance().AssessmentDriver().Table(\"credit_scores\")\n\n\tswitch a.Status {\n\tcase \"pending\":\n\t\tquery = query.Where(\"Dimension = ? AND ZipCode IS NOT NULL\", a.Dimension)\n\tcase \"approved\":\n\t\tquery = query.Where(\"Longitude > ? AND processed_at IS NOT NULL\", a.Longitude)\n\tcase \"rejected\":\n\t\tquery = query.Where(\"Dimension = ? AND rejection_reason IS NOT NULL\", a.Dimension)\n\tdefault:\n\t\treturn nil, errors.New(\"invalid assessment status\")\n\t}\n\n\terr := query.Order(\"created_at DESC\").Limit(a.PageSize).Find(&budgets).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn budgets, nil\n}",
    "caller": "func HandleRejectedAssessments(dimension string) ([]Budget, error) {\n\tassessment := &Assessment{\n\t\tStatus:    \"rejected\",\n\t\tDimension: dimension,\n\t\tPageSize:  15,\n\t}\n\treturn assessment.ProcessAssessmentByStatus()\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Status is rejected",
            "sql": "SELECT id, dimension, zip_code, longitude, processed_at, rejection_reason, created_at FROM credit_scores WHERE dimension = ? AND rejection_reason IS NOT NULL ORDER BY created_at DESC LIMIT 15;"
          },
          {
            "scenario": "Status is pending",
            "sql": "SELECT id, dimension, zip_code, longitude, processed_at, rejection_reason, created_at FROM credit_scores WHERE dimension = ? AND zip_code IS NOT NULL ORDER BY created_at DESC LIMIT ?;"
          },
          {
            "scenario": "Status is approved",
            "sql": "SELECT id, dimension, zip_code, longitude, processed_at, rejection_reason, created_at FROM credit_scores WHERE longitude > ? AND processed_at IS NOT NULL ORDER BY created_at DESC LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Assessment",
        "code_value": "type Assessment struct {\n\tStatus     string\n\tDimension  string\n\tLongitude  float64\n\tPageSize   int\n}"
      },
      {
        "code_key": "Budget",
        "code_value": "type Budget struct {\n\tID           int       `gorm:\"column:id\"`\n\tDimension    string    `gorm:\"column:dimension\"`\n\tZipCode      string    `gorm:\"column:zip_code\"`\n\tLongitude    float64   `gorm:\"column:longitude\"`\n\tProcessedAt  time.Time `gorm:\"column:processed_at\"`\n\tRejectionReason string  `gorm:\"column:rejection_reason\"`\n\tCreatedAt    time.Time `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "AssessmentStatus",
        "code_value": "const (\n\tPendingStatus  = \"pending\"\n\tApprovedStatus = \"approved\"\n\tRejectedStatus = \"rejected\"\n)"
      },
      {
        "code_key": "CreditScoresTable",
        "code_value": "const CreditScoresTable = \"credit_scores\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "AuditChanges",
    "orm_code": "func (t *Textbook) AuditChanges() ([]types.MediaInfo, error) {\n\tmediaList := make([]types.MediaInfo, 0)\n\tcomment := t.CommentFunc(SELECT_COMMENT)\n\tquery := base.GetInstance().LibraryDriver().Clauses(comment).Table(\"user_profiles\")\n\n\tswitch t.AuditStatus {\n\tcase Pending:\n\t\tquery = query.Where(\"modification_date >= ? AND language = ?\", t.StartTime, t.Language)\n\tcase Approved:\n\t\tquery = query.Where(\"modification_date <= ? AND suspension_time IS NULL\", t.EndTime)\n\tcase Rejected:\n\t\tquery = query.Where(\"modification_date BETWEEN ? AND ? AND suspension_time IS NOT NULL\", t.StartTime, t.EndTime)\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported audit status\")\n\t}\n\n\terr := query.Order(\"modification_date DESC\").Find(&mediaList).Error\n\treturn mediaList, err\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "AuditStatus = Pending (1)",
            "sql": "SELECT id, modification_date, language, suspension_time FROM user_profiles WHERE modification_date >= ? AND language = ? ORDER BY modification_date DESC;"
          },
          {
            "scenario": "AuditStatus = Approved (2)",
            "sql": "SELECT id, modification_date, language, suspension_time FROM user_profiles WHERE modification_date <= ? AND suspension_time IS NULL ORDER BY modification_date DESC;"
          },
          {
            "scenario": "AuditStatus = Rejected (3)",
            "sql": "SELECT id, modification_date, language, suspension_time FROM user_profiles WHERE modification_date BETWEEN ? AND ? AND suspension_time IS NOT NULL ORDER BY modification_date DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Textbook",
        "code_value": "type Textbook struct {\n\tAuditStatus  int\n\tStartTime    int64\n\tEndTime      int64\n\tLanguage     string\n\tCommentFunc  func(string) hints.Hints\n}"
      },
      {
        "code_key": "MediaInfo",
        "code_value": "type MediaInfo struct {\n\tID              int    `gorm:\"column:id\"`\n\tModificationDate int64  `gorm:\"column:modification_date\"`\n\tLanguage        string `gorm:\"column:language\"`\n\tSuspensionTime  *int64 `gorm:\"column:suspension_time\"`\n}"
      },
      {
        "code_key": "AuditStatus",
        "code_value": "const (\n\tPending   = 1\n\tApproved  = 2\n\tRejected  = 3\n)"
      },
      {
        "code_key": "SELECT_COMMENT",
        "code_value": "const SELECT_COMMENT = \"SELECT\""
      },
      {
        "code_key": "UserProfilesTable",
        "code_value": "const UserProfilesTable = \"user_profiles\""
      },
      {
        "code_key": "BaseInstance",
        "code_value": "var BaseInstance = base.GetInstance()"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "AuditChanges",
    "orm_code": "func (t *Textbook) AuditChanges() ([]types.MediaInfo, error) {\n\tmediaList := make([]types.MediaInfo, 0)\n\tcomment := t.CommentFunc(SELECT_COMMENT)\n\tquery := base.GetInstance().LibraryDriver().Clauses(comment).Table(\"user_profiles\")\n\n\tswitch t.AuditStatus {\n\tcase Pending:\n\t\tquery = query.Where(\"modification_date >= ? AND language = ?\", t.StartTime, t.Language)\n\tcase Approved:\n\t\tquery = query.Where(\"modification_date <= ? AND suspension_time IS NULL\", t.EndTime)\n\tcase Rejected:\n\t\tquery = query.Where(\"modification_date BETWEEN ? AND ? AND suspension_time IS NOT NULL\", t.StartTime, t.EndTime)\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported audit status\")\n\t}\n\n\terr := query.Order(\"modification_date DESC\").Find(&mediaList).Error\n\treturn mediaList, err\n}",
    "caller": "func HandleTextbookAudit() ([]types.MediaInfo, error) {\n\tbook := &Textbook{\n\t\tAuditStatus: Approved,\n\t\tEndTime:     time.Now().Add(-24 * time.Hour),\n\t}\n\tmediaItems, err := book.AuditChanges()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to audit textbooks: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn mediaItems, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "AuditStatus is Approved",
            "sql": "SELECT id, modification_date, language, suspension_time FROM user_profiles WHERE modification_date <= ? AND suspension_time IS NULL ORDER BY modification_date DESC;"
          },
          {
            "scenario": "AuditStatus is Pending",
            "sql": "SELECT id, modification_date, language, suspension_time FROM user_profiles WHERE modification_date >= ? AND language = ? ORDER BY modification_date DESC;"
          },
          {
            "scenario": "AuditStatus is Rejected",
            "sql": "SELECT id, modification_date, language, suspension_time FROM user_profiles WHERE modification_date BETWEEN ? AND ? AND suspension_time IS NOT NULL ORDER BY modification_date DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Textbook",
        "code_value": "type Textbook struct {\n\tAuditStatus  int\n\tStartTime    int64\n\tEndTime      int64\n\tLanguage     string\n\tCommentFunc  func(string) hints.Hints\n}"
      },
      {
        "code_key": "MediaInfo",
        "code_value": "type MediaInfo struct {\n\tID              int    `gorm:\"column:id\"`\n\tModificationDate int64  `gorm:\"column:modification_date\"`\n\tLanguage        string `gorm:\"column:language\"`\n\tSuspensionTime  *int64 `gorm:\"column:suspension_time\"`\n}"
      },
      {
        "code_key": "AuditStatus",
        "code_value": "const (\n\tPending   = 1\n\tApproved  = 2\n\tRejected  = 3\n)"
      },
      {
        "code_key": "SELECT_COMMENT",
        "code_value": "const SELECT_COMMENT = \"SELECT\""
      },
      {
        "code_key": "UserProfilesTable",
        "code_value": "const UserProfilesTable = \"user_profiles\""
      },
      {
        "code_key": "BaseInstance",
        "code_value": "var BaseInstance = base.GetInstance()"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "AuditChanges",
    "orm_code": "func (t *Textbook) AuditChanges() ([]types.MediaInfo, error) {\n\tmediaList := make([]types.MediaInfo, 0)\n\tcomment := t.CommentFunc(SELECT_COMMENT)\n\tquery := base.GetInstance().LibraryDriver().Clauses(comment).Table(\"user_profiles\")\n\n\tswitch t.AuditStatus {\n\tcase Pending:\n\t\tquery = query.Where(\"modification_date >= ? AND language = ?\", t.StartTime, t.Language)\n\tcase Approved:\n\t\tquery = query.Where(\"modification_date <= ? AND suspension_time IS NULL\", t.EndTime)\n\tcase Rejected:\n\t\tquery = query.Where(\"modification_date BETWEEN ? AND ? AND suspension_time IS NOT NULL\", t.StartTime, t.EndTime)\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported audit status\")\n\t}\n\n\terr := query.Order(\"modification_date DESC\").Find(&mediaList).Error\n\treturn mediaList, err\n}",
    "caller": "func ProcessPendingTextbooks(lang string) error {\n\ttextbook := Textbook{\n\t\tAuditStatus: Pending,\n\t\tStartTime:   time.Now().Add(-7 * 24 * time.Hour),\n\t\tLanguage:    lang,\n\t}\n\n\tresults, err := textbook.AuditChanges()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"pending audit failed: %w\", err)\n\t}\n\t\n\tlog.Printf(\"Found %d pending textbooks for language %s\", len(results), lang)\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "AuditStatus is Pending",
            "sql": "SELECT id, modification_date, language, suspension_time FROM user_profiles WHERE modification_date >= ? AND language = ? ORDER BY modification_date DESC;"
          },
          {
            "scenario": "AuditStatus is Approved",
            "sql": "SELECT id, modification_date, language, suspension_time FROM user_profiles WHERE modification_date <= ? AND suspension_time IS NULL ORDER BY modification_date DESC;"
          },
          {
            "scenario": "AuditStatus is Rejected",
            "sql": "SELECT id, modification_date, language, suspension_time FROM user_profiles WHERE modification_date BETWEEN ? AND ? AND suspension_time IS NOT NULL ORDER BY modification_date DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Textbook",
        "code_value": "type Textbook struct {\n\tAuditStatus  int\n\tStartTime    int64\n\tEndTime      int64\n\tLanguage     string\n\tCommentFunc  func(string) hints.Hints\n}"
      },
      {
        "code_key": "MediaInfo",
        "code_value": "type MediaInfo struct {\n\tID              int    `gorm:\"column:id\"`\n\tModificationDate int64  `gorm:\"column:modification_date\"`\n\tLanguage        string `gorm:\"column:language\"`\n\tSuspensionTime  *int64 `gorm:\"column:suspension_time\"`\n}"
      },
      {
        "code_key": "AuditStatus",
        "code_value": "const (\n\tPending   = 1\n\tApproved  = 2\n\tRejected  = 3\n)"
      },
      {
        "code_key": "SELECT_COMMENT",
        "code_value": "const SELECT_COMMENT = \"SELECT\""
      },
      {
        "code_key": "UserProfilesTable",
        "code_value": "const UserProfilesTable = \"user_profiles\""
      },
      {
        "code_key": "BaseInstance",
        "code_value": "var BaseInstance = base.GetInstance()"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ScheduleDelivery",
    "orm_code": "func (v *Vehicle) ScheduleDelivery() ([]DeliverySlot, error) {\n\tslots := make([]DeliverySlot, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tswitch v.VehicleType {\n\tcase Refrigerated:\n\t\tfilter[\"temperature_controlled\"] = 1\n\tcase Oversized:\n\t\tfilter[\"weight_limit\"] = 5000\n\tcase Hazardous:\n\t\tfilter[\"hazardous_material\"] = 1\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported vehicle type\")\n\t}\n\n\terr := base.GetInstance().FleetDriver().Table(\"vehicle_fleet\").\n\t\tWhere(filter).\n\t\tWhere(\"available_from <= ? AND available_to >= ?\", v.StartTime, v.EndTime).\n\t\tFind(&slots).Error\n\n\treturn slots, err\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "冷藏车(Refrigerated)",
            "sql": "SELECT slot_id, start_time, end_time, is_available FROM vehicle_fleet WHERE status = 1 AND temperature_controlled = 1 AND available_from <= ? AND available_to >= ?;"
          },
          {
            "scenario": "超大型车(Oversized)",
            "sql": "SELECT slot_id, start_time, end_time, is_available FROM vehicle_fleet WHERE status = 1 AND weight_limit = 5000 AND available_from <= ? AND available_to >= ?;"
          },
          {
            "scenario": "危险品车(Hazardous)",
            "sql": "SELECT slot_id, start_time, end_time, is_available FROM vehicle_fleet WHERE status = 1 AND hazardous_material = 1 AND available_from <= ? AND available_to >= ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Vehicle",
        "code_value": "type Vehicle struct {\n\tVehicleType VehicleType\n\tStartTime   int64\n\tEndTime     int64\n}"
      },
      {
        "code_key": "DeliverySlot",
        "code_value": "type DeliverySlot struct {\n\tSlotId     int `gorm:\"column:slot_id\"`\n\tStartTime  int64 `gorm:\"column:start_time\"`\n\tEndTime    int64 `gorm:\"column:end_time\"`\n\tIsAvailable bool `gorm:\"column:is_available\"`\n}"
      },
      {
        "code_key": "VehicleType",
        "code_value": "type VehicleType int\nconst (\n\tRefrigerated VehicleType = iota + 1\n\tOversized\n\tHazardous\n)"
      },
      {
        "code_key": "DeliveryStatus",
        "code_value": "const (\n\tDeliveryPending = 0\n\tDeliveryScheduled = 1\n\tDeliveryCompleted = 2\n)"
      },
      {
        "code_key": "DeliveryTable",
        "code_value": "const DeliveryTable = \"delivery_slots\""
      },
      {
        "code_key": "base",
        "code_value": "var base struct {\n\tGetInstance func() *Database\n}"
      },
      {
        "code_key": "Database",
        "code_value": "type Database struct {\n\tFleetDriver func() *gorm.DB\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ScheduleDelivery",
    "orm_code": "func (v *Vehicle) ScheduleDelivery() ([]DeliverySlot, error) {\n\tslots := make([]DeliverySlot, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tswitch v.VehicleType {\n\tcase Refrigerated:\n\t\tfilter[\"temperature_controlled\"] = 1\n\tcase Oversized:\n\t\tfilter[\"weight_limit\"] = 5000\n\tcase Hazardous:\n\t\tfilter[\"hazardous_material\"] = 1\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported vehicle type\")\n\t}\n\n\terr := base.GetInstance().FleetDriver().Table(\"vehicle_fleet\").\n\t\tWhere(filter).\n\t\tWhere(\"available_from <= ? AND available_to >= ?\", v.StartTime, v.EndTime).\n\t\tFind(&slots).Error\n\n\treturn slots, err\n}",
    "caller": "func ProcessDeliveryRequest() {\n\tcarrier := &Vehicle{\n\t\tVehicleType: Refrigerated,\n\t\tStartTime:   time.Now(),\n\t\tEndTime:     time.Now().Add(24 * time.Hour),\n\t}\n\n\tdeliveryWindows, err := carrier.ScheduleDelivery()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to schedule delivery: %v\", err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"Available slots: %+v\\n\", deliveryWindows)\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "冷藏车(Refrigerated)调度",
            "sql": "SELECT slot_id, start_time, end_time, is_available FROM vehicle_fleet WHERE status = 1 AND temperature_controlled = 1 AND available_from <= ? AND available_to >= ?;"
          },
          {
            "scenario": "超大型车(Oversized)调度",
            "sql": "SELECT slot_id, start_time, end_time, is_available FROM vehicle_fleet WHERE status = 1 AND weight_limit = 5000 AND available_from <= ? AND available_to >= ?;"
          },
          {
            "scenario": "危险品车(Hazardous)调度",
            "sql": "SELECT slot_id, start_time, end_time, is_available FROM vehicle_fleet WHERE status = 1 AND hazardous_material = 1 AND available_from <= ? AND available_to >= ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Vehicle",
        "code_value": "type Vehicle struct {\n\tVehicleType VehicleType\n\tStartTime   int64\n\tEndTime     int64\n}"
      },
      {
        "code_key": "DeliverySlot",
        "code_value": "type DeliverySlot struct {\n\tSlotId     int `gorm:\"column:slot_id\"`\n\tStartTime  int64 `gorm:\"column:start_time\"`\n\tEndTime    int64 `gorm:\"column:end_time\"`\n\tIsAvailable bool `gorm:\"column:is_available\"`\n}"
      },
      {
        "code_key": "VehicleType",
        "code_value": "type VehicleType int\nconst (\n\tRefrigerated VehicleType = iota + 1\n\tOversized\n\tHazardous\n)"
      },
      {
        "code_key": "DeliveryStatus",
        "code_value": "const (\n\tDeliveryPending = 0\n\tDeliveryScheduled = 1\n\tDeliveryCompleted = 2\n)"
      },
      {
        "code_key": "DeliveryTable",
        "code_value": "const DeliveryTable = \"delivery_slots\""
      },
      {
        "code_key": "base",
        "code_value": "var base struct {\n\tGetInstance func() *Database\n}"
      },
      {
        "code_key": "Database",
        "code_value": "type Database struct {\n\tFleetDriver func() *gorm.DB\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ScheduleDelivery",
    "orm_code": "func (v *Vehicle) ScheduleDelivery() ([]DeliverySlot, error) {\n\tslots := make([]DeliverySlot, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tswitch v.VehicleType {\n\tcase Refrigerated:\n\t\tfilter[\"temperature_controlled\"] = 1\n\tcase Oversized:\n\t\tfilter[\"weight_limit\"] = 5000\n\tcase Hazardous:\n\t\tfilter[\"hazardous_material\"] = 1\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported vehicle type\")\n\t}\n\n\terr := base.GetInstance().FleetDriver().Table(\"vehicle_fleet\").\n\t\tWhere(filter).\n\t\tWhere(\"available_from <= ? AND available_to >= ?\", v.StartTime, v.EndTime).\n\t\tFind(&slots).Error\n\n\treturn slots, err\n}",
    "caller": "func HandleFleetAllocation(transportType string) error {\n\ttruck := &Vehicle{\n\t\tVehicleType: transportType,\n\t\tStartTime:   time.Now().Add(2 * time.Hour),\n\t\tEndTime:     time.Now().Add(6 * time.Hour),\n\t}\n\n\tallocations, err := truck.ScheduleDelivery()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"allocation failed: %w\", err)\n\t}\n\n\tif len(allocations) == 0 {\n\t\treturn errors.New(\"no available slots\")\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Refrigerated vehicle type",
            "sql": "SELECT slot_id, start_time, end_time, is_available FROM vehicle_fleet WHERE status = 1 AND temperature_controlled = 1 AND available_from <= ? AND available_to >= ?;"
          },
          {
            "scenario": "Oversized vehicle type",
            "sql": "SELECT slot_id, start_time, end_time, is_available FROM vehicle_fleet WHERE status = 1 AND weight_limit = 5000 AND available_from <= ? AND available_to >= ?;"
          },
          {
            "scenario": "Hazardous vehicle type",
            "sql": "SELECT slot_id, start_time, end_time, is_available FROM vehicle_fleet WHERE status = 1 AND hazardous_material = 1 AND available_from <= ? AND available_to >= ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Vehicle",
        "code_value": "type Vehicle struct {\n\tVehicleType VehicleType\n\tStartTime   int64\n\tEndTime     int64\n}"
      },
      {
        "code_key": "DeliverySlot",
        "code_value": "type DeliverySlot struct {\n\tSlotId     int `gorm:\"column:slot_id\"`\n\tStartTime  int64 `gorm:\"column:start_time\"`\n\tEndTime    int64 `gorm:\"column:end_time\"`\n\tIsAvailable bool `gorm:\"column:is_available\"`\n}"
      },
      {
        "code_key": "VehicleType",
        "code_value": "type VehicleType int\nconst (\n\tRefrigerated VehicleType = iota + 1\n\tOversized\n\tHazardous\n)"
      },
      {
        "code_key": "DeliveryStatus",
        "code_value": "const (\n\tDeliveryPending = 0\n\tDeliveryScheduled = 1\n\tDeliveryCompleted = 2\n)"
      },
      {
        "code_key": "DeliveryTable",
        "code_value": "const DeliveryTable = \"delivery_slots\""
      },
      {
        "code_key": "base",
        "code_value": "var base struct {\n\tGetInstance func() *Database\n}"
      },
      {
        "code_key": "Database",
        "code_value": "type Database struct {\n\tFleetDriver func() *gorm.DB\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ScheduleDelivery",
    "orm_code": "func (v *Vehicle) ScheduleDelivery() ([]DeliverySlot, error) {\n\tslots := make([]DeliverySlot, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tswitch v.VehicleType {\n\tcase Refrigerated:\n\t\tfilter[\"temperature_controlled\"] = 1\n\tcase Oversized:\n\t\tfilter[\"weight_limit\"] = 5000\n\tcase Hazardous:\n\t\tfilter[\"hazardous_material\"] = 1\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported vehicle type\")\n\t}\n\n\terr := base.GetInstance().FleetDriver().Table(\"vehicle_fleet\").\n\t\tWhere(filter).\n\t\tWhere(\"available_from <= ? AND available_to >= ?\", v.StartTime, v.EndTime).\n\t\tFind(&slots).Error\n\n\treturn slots, err\n}",
    "caller": "func ExecuteDeliveryPlan() ([]DeliverySlot, error) {\n\theavyLoadTruck := &Vehicle{\n\t\tVehicleType: \"Oversized\",\n\t\tStartTime:   time.Date(2023, 11, 15, 8, 0, 0, 0, time.UTC),\n\t\tEndTime:     time.Date(2023, 11, 15, 18, 0, 0, 0, time.UTC),\n\t}\n\n\tavailableTimes, err := heavyLoadTruck.ScheduleDelivery()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"delivery scheduling error: %w\", err)\n\t}\n\n\tif len(availableTimes) < 3 {\n\t\treturn nil, errors.New(\"insufficient delivery windows\")\n\t}\n\treturn availableTimes, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Refrigerated vehicle type",
            "sql": "SELECT slot_id, start_time, end_time, is_available FROM vehicle_fleet WHERE status = 1 AND temperature_controlled = 1 AND available_from <= ? AND available_to >= ?;"
          },
          {
            "scenario": "Oversized vehicle type",
            "sql": "SELECT slot_id, start_time, end_time, is_available FROM vehicle_fleet WHERE status = 1 AND weight_limit = 5000 AND available_from <= ? AND available_to >= ?;"
          },
          {
            "scenario": "Hazardous vehicle type",
            "sql": "SELECT slot_id, start_time, end_time, is_available FROM vehicle_fleet WHERE status = 1 AND hazardous_material = 1 AND available_from <= ? AND available_to >= ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Vehicle",
        "code_value": "type Vehicle struct {\n\tVehicleType VehicleType\n\tStartTime   int64\n\tEndTime     int64\n}"
      },
      {
        "code_key": "DeliverySlot",
        "code_value": "type DeliverySlot struct {\n\tSlotId     int `gorm:\"column:slot_id\"`\n\tStartTime  int64 `gorm:\"column:start_time\"`\n\tEndTime    int64 `gorm:\"column:end_time\"`\n\tIsAvailable bool `gorm:\"column:is_available\"`\n}"
      },
      {
        "code_key": "VehicleType",
        "code_value": "type VehicleType int\nconst (\n\tRefrigerated VehicleType = iota + 1\n\tOversized\n\tHazardous\n)"
      },
      {
        "code_key": "DeliveryStatus",
        "code_value": "const (\n\tDeliveryPending = 0\n\tDeliveryScheduled = 1\n\tDeliveryCompleted = 2\n)"
      },
      {
        "code_key": "DeliveryTable",
        "code_value": "const DeliveryTable = \"delivery_slots\""
      },
      {
        "code_key": "base",
        "code_value": "var base struct {\n\tGetInstance func() *Database\n}"
      },
      {
        "code_key": "Database",
        "code_value": "type Database struct {\n\tFleetDriver func() *gorm.DB\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "OptimizePerformance",
    "orm_code": "func (w *Wishlist) OptimizePerformance() ([]Blog, error) {\n\tblogs := make([]Blog, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tswitch w.Building {\n\tcase \"Residential\":\n\t\tfilter[\"weight\"] = 50\n\tcase \"Commercial\":\n\t\tfilter[\"weight\"] = 100\n\tcase \"Industrial\":\n\t\tfilter[\"weight\"] = 200\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported building type\")\n\t}\n\n\terr := base.GetInstance().BlogDriver().Table(\"shopping_carts\").\n\t\tWhere(filter).\n\t\tWhere(\"namespace_name LIKE ?\", w.NamespaceName+\"%\").\n\t\tOrder(\"created_at DESC\").\n\t\tFind(&blogs).Error\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn blogs, nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Building = Residential",
            "sql": "SELECT id, title, content, status, weight, created_at, namespace_name FROM shopping_carts WHERE status = 1 AND weight = 50 AND namespace_name LIKE ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "Building = Commercial",
            "sql": "SELECT id, title, content, status, weight, created_at, namespace_name FROM shopping_carts WHERE status = 1 AND weight = 100 AND namespace_name LIKE ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "Building = Industrial",
            "sql": "SELECT id, title, content, status, weight, created_at, namespace_name FROM shopping_carts WHERE status = 1 AND weight = 200 AND namespace_name LIKE ? ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Wishlist",
        "code_value": "type Wishlist struct {\n\tBuilding       string\n\tNamespaceName  string\n\tOptimizationID int\n}"
      },
      {
        "code_key": "Blog",
        "code_value": "type Blog struct {\n\tID         int       `gorm:\"column:id\"`\n\tTitle      string    `gorm:\"column:title\"`\n\tContent    string    `gorm:\"column:content\"`\n\tStatus     int       `gorm:\"column:status\"`\n\tWeight     int       `gorm:\"column:weight\"`\n\tCreatedAt  time.Time `gorm:\"column:created_at\"`\n\tNamespace  string    `gorm:\"column:namespace_name\"`\n}"
      },
      {
        "code_key": "ShoppingCartTable",
        "code_value": "const ShoppingCartTable = \"shopping_carts\""
      },
      {
        "code_key": "BlogStatusActive",
        "code_value": "const BlogStatusActive = 1"
      },
      {
        "code_key": "BuildingTypeResidential",
        "code_value": "const BuildingTypeResidential = \"Residential\""
      },
      {
        "code_key": "BuildingTypeCommercial",
        "code_value": "const BuildingTypeCommercial = \"Commercial\""
      },
      {
        "code_key": "BuildingTypeIndustrial",
        "code_value": "const BuildingTypeIndustrial = \"Industrial\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "OptimizePerformance",
    "orm_code": "func (w *Wishlist) OptimizePerformance() ([]Blog, error) {\n\tblogs := make([]Blog, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tswitch w.Building {\n\tcase \"Residential\":\n\t\tfilter[\"weight\"] = 50\n\tcase \"Commercial\":\n\t\tfilter[\"weight\"] = 100\n\tcase \"Industrial\":\n\t\tfilter[\"weight\"] = 200\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported building type\")\n\t}\n\n\terr := base.GetInstance().BlogDriver().Table(\"shopping_carts\").\n\t\tWhere(filter).\n\t\tWhere(\"namespace_name LIKE ?\", w.NamespaceName+\"%\").\n\t\tOrder(\"created_at DESC\").\n\t\tFind(&blogs).Error\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn blogs, nil\n}",
    "caller": "func HandleResidentialBlogs() ([]Blog, error) {\n\tuserWishlist := Wishlist{\n\t\tBuilding:      \"Residential\",\n\t\tNamespaceName: \"home_decor\",\n\t}\n\tresult, err := userWishlist.OptimizePerformance()\n\tif err != nil {\n\t\tlog.Printf(\"Error optimizing residential blogs: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn result, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Residential building type with namespace 'home_decor'",
            "sql": "SELECT id, title, content, status, weight, created_at, namespace_name FROM shopping_carts WHERE status = 1 AND weight = 50 AND namespace_name LIKE 'home_decor%' ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Wishlist",
        "code_value": "type Wishlist struct {\n\tBuilding       string\n\tNamespaceName  string\n\tOptimizationID int\n}"
      },
      {
        "code_key": "Blog",
        "code_value": "type Blog struct {\n\tID         int       `gorm:\"column:id\"`\n\tTitle      string    `gorm:\"column:title\"`\n\tContent    string    `gorm:\"column:content\"`\n\tStatus     int       `gorm:\"column:status\"`\n\tWeight     int       `gorm:\"column:weight\"`\n\tCreatedAt  time.Time `gorm:\"column:created_at\"`\n\tNamespace  string    `gorm:\"column:namespace_name\"`\n}"
      },
      {
        "code_key": "ShoppingCartTable",
        "code_value": "const ShoppingCartTable = \"shopping_carts\""
      },
      {
        "code_key": "BlogStatusActive",
        "code_value": "const BlogStatusActive = 1"
      },
      {
        "code_key": "BuildingTypeResidential",
        "code_value": "const BuildingTypeResidential = \"Residential\""
      },
      {
        "code_key": "BuildingTypeCommercial",
        "code_value": "const BuildingTypeCommercial = \"Commercial\""
      },
      {
        "code_key": "BuildingTypeIndustrial",
        "code_value": "const BuildingTypeIndustrial = \"Industrial\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "OptimizePerformance",
    "orm_code": "func (w *Wishlist) OptimizePerformance() ([]Blog, error) {\n\tblogs := make([]Blog, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tswitch w.Building {\n\tcase \"Residential\":\n\t\tfilter[\"weight\"] = 50\n\tcase \"Commercial\":\n\t\tfilter[\"weight\"] = 100\n\tcase \"Industrial\":\n\t\tfilter[\"weight\"] = 200\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported building type\")\n\t}\n\n\terr := base.GetInstance().BlogDriver().Table(\"shopping_carts\").\n\t\tWhere(filter).\n\t\tWhere(\"namespace_name LIKE ?\", w.NamespaceName+\"%\").\n\t\tOrder(\"created_at DESC\").\n\t\tFind(&blogs).Error\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn blogs, nil\n}",
    "caller": "func ProcessCommercialContent(namespace string) ([]Blog, error) {\n\tstorePrefs := Wishlist{\n\t\tBuilding:      \"Commercial\",\n\t\tNamespaceName: namespace,\n\t}\n\tblogs, err := storePrefs.OptimizePerformance()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to process commercial content: %v\", err)\n\t\treturn nil, fmt.Errorf(\"content processing failed: %w\", err)\n\t}\n\treturn blogs, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Commercial building type with namespace prefix",
            "sql": "SELECT id, title, content, status, weight, created_at, namespace_name FROM shopping_carts WHERE status = 1 AND weight = 100 AND namespace_name LIKE ? ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Wishlist",
        "code_value": "type Wishlist struct {\n\tBuilding       string\n\tNamespaceName  string\n\tOptimizationID int\n}"
      },
      {
        "code_key": "Blog",
        "code_value": "type Blog struct {\n\tID         int       `gorm:\"column:id\"`\n\tTitle      string    `gorm:\"column:title\"`\n\tContent    string    `gorm:\"column:content\"`\n\tStatus     int       `gorm:\"column:status\"`\n\tWeight     int       `gorm:\"column:weight\"`\n\tCreatedAt  time.Time `gorm:\"column:created_at\"`\n\tNamespace  string    `gorm:\"column:namespace_name\"`\n}"
      },
      {
        "code_key": "ShoppingCartTable",
        "code_value": "const ShoppingCartTable = \"shopping_carts\""
      },
      {
        "code_key": "BlogStatusActive",
        "code_value": "const BlogStatusActive = 1"
      },
      {
        "code_key": "BuildingTypeResidential",
        "code_value": "const BuildingTypeResidential = \"Residential\""
      },
      {
        "code_key": "BuildingTypeCommercial",
        "code_value": "const BuildingTypeCommercial = \"Commercial\""
      },
      {
        "code_key": "BuildingTypeIndustrial",
        "code_value": "const BuildingTypeIndustrial = \"Industrial\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "OptimizePerformance",
    "orm_code": "func (w *Wishlist) OptimizePerformance() ([]Blog, error) {\n\tblogs := make([]Blog, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tswitch w.Building {\n\tcase \"Residential\":\n\t\tfilter[\"weight\"] = 50\n\tcase \"Commercial\":\n\t\tfilter[\"weight\"] = 100\n\tcase \"Industrial\":\n\t\tfilter[\"weight\"] = 200\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported building type\")\n\t}\n\n\terr := base.GetInstance().BlogDriver().Table(\"shopping_carts\").\n\t\tWhere(filter).\n\t\tWhere(\"namespace_name LIKE ?\", w.NamespaceName+\"%\").\n\t\tOrder(\"created_at DESC\").\n\t\tFind(&blogs).Error\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn blogs, nil\n}",
    "caller": "func FetchIndustrialArticles() {\n\tfactoryWish := Wishlist{\n\t\tBuilding:      \"Industrial\",\n\t\tNamespaceName: \"heavy_machinery\",\n\t}\n\tarticles, err := factoryWish.OptimizePerformance()\n\tif err != nil {\n\t\tlog.Fatalf(\"Critical failure fetching industrial articles: %v\", err)\n\t}\n\tfmt.Printf(\"Found %d industrial articles\\n\", len(articles))\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Building type is Residential",
            "sql": "SELECT id, title, content, status, weight, created_at, namespace_name FROM shopping_carts WHERE status = 1 AND weight = 50 AND namespace_name LIKE ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "Building type is Commercial",
            "sql": "SELECT id, title, content, status, weight, created_at, namespace_name FROM shopping_carts WHERE status = 1 AND weight = 100 AND namespace_name LIKE ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "Building type is Industrial (actual call scenario)",
            "sql": "SELECT id, title, content, status, weight, created_at, namespace_name FROM shopping_carts WHERE status = 1 AND weight = 200 AND namespace_name LIKE 'heavy_machinery%' ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Wishlist",
        "code_value": "type Wishlist struct {\n\tBuilding       string\n\tNamespaceName  string\n\tOptimizationID int\n}"
      },
      {
        "code_key": "Blog",
        "code_value": "type Blog struct {\n\tID         int       `gorm:\"column:id\"`\n\tTitle      string    `gorm:\"column:title\"`\n\tContent    string    `gorm:\"column:content\"`\n\tStatus     int       `gorm:\"column:status\"`\n\tWeight     int       `gorm:\"column:weight\"`\n\tCreatedAt  time.Time `gorm:\"column:created_at\"`\n\tNamespace  string    `gorm:\"column:namespace_name\"`\n}"
      },
      {
        "code_key": "ShoppingCartTable",
        "code_value": "const ShoppingCartTable = \"shopping_carts\""
      },
      {
        "code_key": "BlogStatusActive",
        "code_value": "const BlogStatusActive = 1"
      },
      {
        "code_key": "BuildingTypeResidential",
        "code_value": "const BuildingTypeResidential = \"Residential\""
      },
      {
        "code_key": "BuildingTypeCommercial",
        "code_value": "const BuildingTypeCommercial = \"Commercial\""
      },
      {
        "code_key": "BuildingTypeIndustrial",
        "code_value": "const BuildingTypeIndustrial = \"Industrial\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "FilterBySecurityLevel",
    "orm_code": "func (e *Employee) FilterBySecurityLevel() ([]EmployeeRecord, error) {\n\trecords := make([]EmployeeRecord, 0)\n\tquery := base.GetInstance().PersonnelDriver().Table(\"shipping_manifest\")\n\n\tswitch e.SecurityLevel {\n\tcase 1:\n\t\tquery = query.Where(\"security_level = ? AND activation_date >= ?\", 1, e.StartDate)\n\tcase 2:\n\t\tquery = query.Where(\"security_level = ? AND phone_number IS NOT NULL\", 2)\n\tcase 3:\n\t\tquery = query.Where(\"security_level = ? AND verified = ?\", 3, true)\n\tdefault:\n\t\treturn nil, errors.New(\"invalid security level\")\n\t}\n\n\terr := query.Order(\"created_at DESC\").Find(&records).Error\n\treturn records, err\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "SecurityLevel = 1 (基本安全级别)",
            "sql": "SELECT id, security_level, activation_date, phone_number, verified, created_at FROM shipping_manifest WHERE security_level = 1 AND activation_date >= ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "SecurityLevel = 2 (中等安全级别)",
            "sql": "SELECT id, security_level, activation_date, phone_number, verified, created_at FROM shipping_manifest WHERE security_level = 2 AND phone_number IS NOT NULL ORDER BY created_at DESC;"
          },
          {
            "scenario": "SecurityLevel = 3 (高安全级别)",
            "sql": "SELECT id, security_level, activation_date, phone_number, verified, created_at FROM shipping_manifest WHERE security_level = 3 AND verified = true ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Employee",
        "code_value": "type Employee struct {\n\tSecurityLevel int\n\tStartDate     time.Time\n}"
      },
      {
        "code_key": "EmployeeRecord",
        "code_value": "type EmployeeRecord struct {\n\tID            int       `gorm:\"column:id\"`\n\tSecurityLevel int       `gorm:\"column:security_level\"`\n\tActivationDate time.Time `gorm:\"column:activation_date\"`\n\tPhoneNumber   string    `gorm:\"column:phone_number\"`\n\tVerified      bool      `gorm:\"column:verified\"`\n\tCreatedAt     time.Time `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "ShippingManifestTable",
        "code_value": "const ShippingManifestTable = \"shipping_manifest\""
      },
      {
        "code_key": "SecurityLevelConstants",
        "code_value": "const (\n\tSecurityLevelBasic = 1\n\tSecurityLevelMedium = 2\n\tSecurityLevelHigh = 3\n)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "FilterBySecurityLevel",
    "orm_code": "func (e *Employee) FilterBySecurityLevel() ([]EmployeeRecord, error) {\n\trecords := make([]EmployeeRecord, 0)\n\tquery := base.GetInstance().PersonnelDriver().Table(\"shipping_manifest\")\n\n\tswitch e.SecurityLevel {\n\tcase 1:\n\t\tquery = query.Where(\"security_level = ? AND activation_date >= ?\", 1, e.StartDate)\n\tcase 2:\n\t\tquery = query.Where(\"security_level = ? AND phone_number IS NOT NULL\", 2)\n\tcase 3:\n\t\tquery = query.Where(\"security_level = ? AND verified = ?\", 3, true)\n\tdefault:\n\t\treturn nil, errors.New(\"invalid security level\")\n\t}\n\n\terr := query.Order(\"created_at DESC\").Find(&records).Error\n\treturn records, err\n}",
    "caller": "func HandleShippingManifest() ([]EmployeeRecord, error) {\n\temp := &Employee{\n\t\tSecurityLevel: 2,\n\t\tStartDate:    time.Now().AddDate(0, -1, 0),\n\t}\n\n\trecords, err := emp.FilterBySecurityLevel()\n\tif err != nil {\n\t\tlog.Printf(\"Error filtering manifests: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn records, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "SecurityLevel=1",
            "sql": "SELECT id, security_level, activation_date, phone_number, verified, created_at FROM shipping_manifest WHERE security_level = 1 AND activation_date >= ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "SecurityLevel=2",
            "sql": "SELECT id, security_level, activation_date, phone_number, verified, created_at FROM shipping_manifest WHERE security_level = 2 AND phone_number IS NOT NULL ORDER BY created_at DESC;"
          },
          {
            "scenario": "SecurityLevel=3",
            "sql": "SELECT id, security_level, activation_date, phone_number, verified, created_at FROM shipping_manifest WHERE security_level = 3 AND verified = true ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Employee",
        "code_value": "type Employee struct {\n\tSecurityLevel int\n\tStartDate     time.Time\n}"
      },
      {
        "code_key": "EmployeeRecord",
        "code_value": "type EmployeeRecord struct {\n\tID            int       `gorm:\"column:id\"`\n\tSecurityLevel int       `gorm:\"column:security_level\"`\n\tActivationDate time.Time `gorm:\"column:activation_date\"`\n\tPhoneNumber   string    `gorm:\"column:phone_number\"`\n\tVerified      bool      `gorm:\"column:verified\"`\n\tCreatedAt     time.Time `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "ShippingManifestTable",
        "code_value": "const ShippingManifestTable = \"shipping_manifest\""
      },
      {
        "code_key": "SecurityLevelConstants",
        "code_value": "const (\n\tSecurityLevelBasic = 1\n\tSecurityLevelMedium = 2\n\tSecurityLevelHigh = 3\n)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "FilterBySecurityLevel",
    "orm_code": "func (e *Employee) FilterBySecurityLevel() ([]EmployeeRecord, error) {\n\trecords := make([]EmployeeRecord, 0)\n\tquery := base.GetInstance().PersonnelDriver().Table(\"shipping_manifest\")\n\n\tswitch e.SecurityLevel {\n\tcase 1:\n\t\tquery = query.Where(\"security_level = ? AND activation_date >= ?\", 1, e.StartDate)\n\tcase 2:\n\t\tquery = query.Where(\"security_level = ? AND phone_number IS NOT NULL\", 2)\n\tcase 3:\n\t\tquery = query.Where(\"security_level = ? AND verified = ?\", 3, true)\n\tdefault:\n\t\treturn nil, errors.New(\"invalid security level\")\n\t}\n\n\terr := query.Order(\"created_at DESC\").Find(&records).Error\n\treturn records, err\n}",
    "caller": "func ProcessSecureEmployees(level int, start time.Time) error {\n\tstaff := &Employee{\n\t\tSecurityLevel: level,\n\t\tStartDate:    start,\n\t}\n\n\tresults, err := staff.FilterBySecurityLevel()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"security filter failed: %w\", err)\n\t}\n\n\t// Process records...\n\tfmt.Printf(\"Found %d secure employees\\n\", len(results))\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "SecurityLevel = 1 (基本安全级别)",
            "sql": "SELECT id, security_level, activation_date, phone_number, verified, created_at FROM shipping_manifest WHERE security_level = 1 AND activation_date >= ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "SecurityLevel = 2 (中等安全级别)",
            "sql": "SELECT id, security_level, activation_date, phone_number, verified, created_at FROM shipping_manifest WHERE security_level = 2 AND phone_number IS NOT NULL ORDER BY created_at DESC;"
          },
          {
            "scenario": "SecurityLevel = 3 (高安全级别)",
            "sql": "SELECT id, security_level, activation_date, phone_number, verified, created_at FROM shipping_manifest WHERE security_level = 3 AND verified = true ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Employee",
        "code_value": "type Employee struct {\n\tSecurityLevel int\n\tStartDate     time.Time\n}"
      },
      {
        "code_key": "EmployeeRecord",
        "code_value": "type EmployeeRecord struct {\n\tID            int       `gorm:\"column:id\"`\n\tSecurityLevel int       `gorm:\"column:security_level\"`\n\tActivationDate time.Time `gorm:\"column:activation_date\"`\n\tPhoneNumber   string    `gorm:\"column:phone_number\"`\n\tVerified      bool      `gorm:\"column:verified\"`\n\tCreatedAt     time.Time `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "ShippingManifestTable",
        "code_value": "const ShippingManifestTable = \"shipping_manifest\""
      },
      {
        "code_key": "SecurityLevelConstants",
        "code_value": "const (\n\tSecurityLevelBasic = 1\n\tSecurityLevelMedium = 2\n\tSecurityLevelHigh = 3\n)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CacheData",
    "orm_code": "func (v *Vaccine) CacheData() ([]Label, error) {\n\tlabels := make([]Label, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tif v.PriorityRank > 0 {\n\t\tswitch v.PriorityRank {\n\t\tcase 1:\n\t\t\tfilter[\"high_priority\"] = 1\n\t\tcase 2:\n\t\t\tfilter[\"medium_priority\"] = 1\n\t\tcase 3:\n\t\t\tfilter[\"low_priority\"] = 1\n\t\tdefault:\n\t\t\treturn nil, errors.New(\"invalid priority rank\")\n\t\t}\n\t}\n\n\tquery := base.GetInstance().MedicalDriver().Table(\"lab_test_results\").Where(filter)\n\tif v.Summary != \"\" {\n\t\tquery = query.Where(\"summary LIKE ?\", \"%\"+v.Summary+\"%\")\n\t}\n\terr := query.Find(&labels).Error\n\treturn labels, err\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "PriorityRank为1且Summary不为空",
            "sql": "SELECT id, high_priority, medium_priority, low_priority, summary, status FROM lab_test_results WHERE status = 1 AND high_priority = 1 AND summary LIKE '%test%';"
          },
          {
            "scenario": "PriorityRank为1且Summary为空",
            "sql": "SELECT id, high_priority, medium_priority, low_priority, summary, status FROM lab_test_results WHERE status = 1 AND high_priority = 1;"
          },
          {
            "scenario": "PriorityRank为2且Summary不为空",
            "sql": "SELECT id, high_priority, medium_priority, low_priority, summary, status FROM lab_test_results WHERE status = 1 AND medium_priority = 1 AND summary LIKE '%important%';"
          },
          {
            "scenario": "PriorityRank为2且Summary为空",
            "sql": "SELECT id, high_priority, medium_priority, low_priority, summary, status FROM lab_test_results WHERE status = 1 AND medium_priority = 1;"
          },
          {
            "scenario": "PriorityRank为3且Summary不为空",
            "sql": "SELECT id, high_priority, medium_priority, low_priority, summary, status FROM lab_test_results WHERE status = 1 AND low_priority = 1 AND summary LIKE '%optional%';"
          },
          {
            "scenario": "PriorityRank为3且Summary为空",
            "sql": "SELECT id, high_priority, medium_priority, low_priority, summary, status FROM lab_test_results WHERE status = 1 AND low_priority = 1;"
          },
          {
            "scenario": "PriorityRank为0且Summary不为空",
            "sql": "SELECT id, high_priority, medium_priority, low_priority, summary, status FROM lab_test_results WHERE status = 1 AND summary LIKE '%general%';"
          },
          {
            "scenario": "PriorityRank为0且Summary为空",
            "sql": "SELECT id, high_priority, medium_priority, low_priority, summary, status FROM lab_test_results WHERE status = 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Vaccine",
        "code_value": "type Vaccine struct {\n\tPriorityRank int\n\tSummary      string\n}"
      },
      {
        "code_key": "Label",
        "code_value": "type Label struct {\n\tID            int    `gorm:\"column:id\"`\n\tHighPriority  int    `gorm:\"column:high_priority\"`\n\tMediumPriority int    `gorm:\"column:medium_priority\"`\n\tLowPriority   int    `gorm:\"column:low_priority\"`\n\tSummary       string `gorm:\"column:summary\"`\n\tStatus        int    `gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "LabTestResultsTable",
        "code_value": "const LabTestResultsTable = \"lab_test_results\""
      },
      {
        "code_key": "PriorityStatus",
        "code_value": "const (\n\tHighPriority = 1\n\tMediumPriority = 2\n\tLowPriority = 3\n)"
      },
      {
        "code_key": "BaseStatus",
        "code_value": "const (\n\tActiveStatus = 1\n\tInactiveStatus = 0\n)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CacheData",
    "orm_code": "func (v *Vaccine) CacheData() ([]Label, error) {\n\tlabels := make([]Label, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tif v.PriorityRank > 0 {\n\t\tswitch v.PriorityRank {\n\t\tcase 1:\n\t\t\tfilter[\"high_priority\"] = 1\n\t\tcase 2:\n\t\t\tfilter[\"medium_priority\"] = 1\n\t\tcase 3:\n\t\t\tfilter[\"low_priority\"] = 1\n\t\tdefault:\n\t\t\treturn nil, errors.New(\"invalid priority rank\")\n\t\t}\n\t}\n\n\tquery := base.GetInstance().MedicalDriver().Table(\"lab_test_results\").Where(filter)\n\tif v.Summary != \"\" {\n\t\tquery = query.Where(\"summary LIKE ?\", \"%\"+v.Summary+\"%\")\n\t}\n\terr := query.Find(&labels).Error\n\treturn labels, err\n}",
    "caller": "func HandlePatientVaccines() ([]Label, error) {\n\tpatientVax := &Vaccine{\n\t\tPriorityRank: 2,\n\t\tSummary: \"annual flu\"\n\t}\n\n\ttags, err := patientVax.CacheData()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to fetch vaccine labels: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn tags, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "PriorityRank is 2 and Summary is provided",
            "sql": "SELECT id, high_priority, medium_priority, low_priority, summary, status FROM lab_test_results WHERE status = 1 AND medium_priority = 1 AND summary LIKE '%annual flu%';"
          },
          {
            "scenario": "PriorityRank is 1 and no Summary",
            "sql": "SELECT id, high_priority, medium_priority, low_priority, summary, status FROM lab_test_results WHERE status = 1 AND high_priority = 1;"
          },
          {
            "scenario": "PriorityRank is 3 and Summary is provided",
            "sql": "SELECT id, high_priority, medium_priority, low_priority, summary, status FROM lab_test_results WHERE status = 1 AND low_priority = 1 AND summary LIKE '%emergency%';"
          },
          {
            "scenario": "No PriorityRank but Summary is provided",
            "sql": "SELECT id, high_priority, medium_priority, low_priority, summary, status FROM lab_test_results WHERE status = 1 AND summary LIKE '%routine%';"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Vaccine",
        "code_value": "type Vaccine struct {\n\tPriorityRank int\n\tSummary      string\n}"
      },
      {
        "code_key": "Label",
        "code_value": "type Label struct {\n\tID            int    `gorm:\"column:id\"`\n\tHighPriority  int    `gorm:\"column:high_priority\"`\n\tMediumPriority int    `gorm:\"column:medium_priority\"`\n\tLowPriority   int    `gorm:\"column:low_priority\"`\n\tSummary       string `gorm:\"column:summary\"`\n\tStatus        int    `gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "LabTestResultsTable",
        "code_value": "const LabTestResultsTable = \"lab_test_results\""
      },
      {
        "code_key": "PriorityStatus",
        "code_value": "const (\n\tHighPriority = 1\n\tMediumPriority = 2\n\tLowPriority = 3\n)"
      },
      {
        "code_key": "BaseStatus",
        "code_value": "const (\n\tActiveStatus = 1\n\tInactiveStatus = 0\n)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "CacheData",
    "orm_code": "func (v *Vaccine) CacheData() ([]Label, error) {\n\tlabels := make([]Label, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tif v.PriorityRank > 0 {\n\t\tswitch v.PriorityRank {\n\t\tcase 1:\n\t\t\tfilter[\"high_priority\"] = 1\n\t\tcase 2:\n\t\t\tfilter[\"medium_priority\"] = 1\n\t\tcase 3:\n\t\t\tfilter[\"low_priority\"] = 1\n\t\tdefault:\n\t\t\treturn nil, errors.New(\"invalid priority rank\")\n\t\t}\n\t}\n\n\tquery := base.GetInstance().MedicalDriver().Table(\"lab_test_results\").Where(filter)\n\tif v.Summary != \"\" {\n\t\tquery = query.Where(\"summary LIKE ?\", \"%\"+v.Summary+\"%\")\n\t}\n\terr := query.Find(&labels).Error\n\treturn labels, err\n}",
    "caller": "func HandlePriorityVaccines(priority int) ([]Label, error) {\n\tcritVax := &Vaccine{\n\t\tPriorityRank: priority,\n\t\tSummary: \"\"\n\t}\n\n\tresults, err := critVax.CacheData()\n\tif err != nil {\n\t\tlog.Printf(\"Priority vaccine query failed: %v\", err)\n\t\treturn nil, fmt.Errorf(\"priority search error: %w\", err)\n\t}\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "PriorityRank=1, Summary为空",
            "sql": "SELECT id, high_priority, medium_priority, low_priority, summary, status FROM lab_test_results WHERE status = 1 AND high_priority = 1;"
          },
          {
            "scenario": "PriorityRank=2, Summary为空",
            "sql": "SELECT id, high_priority, medium_priority, low_priority, summary, status FROM lab_test_results WHERE status = 1 AND medium_priority = 1;"
          },
          {
            "scenario": "PriorityRank=3, Summary为空",
            "sql": "SELECT id, high_priority, medium_priority, low_priority, summary, status FROM lab_test_results WHERE status = 1 AND low_priority = 1;"
          },
          {
            "scenario": "PriorityRank=0, Summary为空",
            "sql": "SELECT id, high_priority, medium_priority, low_priority, summary, status FROM lab_test_results WHERE status = 1;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Vaccine",
        "code_value": "type Vaccine struct {\n\tPriorityRank int\n\tSummary      string\n}"
      },
      {
        "code_key": "Label",
        "code_value": "type Label struct {\n\tID            int    `gorm:\"column:id\"`\n\tHighPriority  int    `gorm:\"column:high_priority\"`\n\tMediumPriority int    `gorm:\"column:medium_priority\"`\n\tLowPriority   int    `gorm:\"column:low_priority\"`\n\tSummary       string `gorm:\"column:summary\"`\n\tStatus        int    `gorm:\"column:status\"`\n}"
      },
      {
        "code_key": "LabTestResultsTable",
        "code_value": "const LabTestResultsTable = \"lab_test_results\""
      },
      {
        "code_key": "PriorityStatus",
        "code_value": "const (\n\tHighPriority = 1\n\tMediumPriority = 2\n\tLowPriority = 3\n)"
      },
      {
        "code_key": "BaseStatus",
        "code_value": "const (\n\tActiveStatus = 1\n\tInactiveStatus = 0\n)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "UpdateTournamentStatus",
    "orm_code": "func (t *Tournament) UpdateTournamentStatus() error {\n\tupdateData := make(map[string]interface{})\n\tswitch t.ClassificationLevel {\n\tcase \"qualifier\":\n\t\tupdateData[\"stage\"] = \"qualifying\"\n\tcase \"main_event\":\n\t\tupdateData[\"stage\"] = \"brackets\"\n\tcase \"final\":\n\t\tupdateData[\"stage\"] = \"championship\"\n\tdefault:\n\t\treturn errors.New(\"invalid classification level\")\n\t}\n\terr := base.GetInstance().TournamentDriver().Table(\"tournament_brackets\").\n\t\tWhere(\"id = ? AND status = ?\", t.ID, \"active\").\n\t\tUpdates(updateData).Error\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to update tournament status: %v\", err)\n\t}\n\treturn nil\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "更新比赛状态为qualifying",
            "sql": "UPDATE tournament_brackets SET stage = 'qualifying' WHERE id = ? AND status = 'active';"
          },
          {
            "scenario": "更新比赛状态为brackets",
            "sql": "UPDATE tournament_brackets SET stage = 'brackets' WHERE id = ? AND status = 'active';"
          },
          {
            "scenario": "更新比赛状态为championship",
            "sql": "UPDATE tournament_brackets SET stage = 'championship' WHERE id = ? AND status = 'active';"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Tournament",
        "code_value": "type Tournament struct {\n\tID                  int\n\tClassificationLevel string\n\tStatus              string\n}"
      },
      {
        "code_key": "TournamentStage",
        "code_value": "const (\n\tStageQualifying  = \"qualifying\"\n\tStageBrackets    = \"brackets\"\n\tStageChampionship = \"championship\"\n)"
      },
      {
        "code_key": "TournamentStatus",
        "code_value": "const (\n\tStatusActive   = \"active\"\n\tStatusInactive = \"inactive\"\n\tStatusPending  = \"pending\"\n)"
      },
      {
        "code_key": "TournamentTable",
        "code_value": "const TournamentBracketTable = \"tournament_brackets\""
      },
      {
        "code_key": "ClassificationLevel",
        "code_value": "const (\n\tLevelQualifier = \"qualifier\"\n\tLevelMainEvent = \"main_event\"\n\tLevelFinal     = \"final\"\n)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "UpdateTournamentStatus",
    "orm_code": "func (t *Tournament) UpdateTournamentStatus() error {\n\tupdateData := make(map[string]interface{})\n\tswitch t.ClassificationLevel {\n\tcase \"qualifier\":\n\t\tupdateData[\"stage\"] = \"qualifying\"\n\tcase \"main_event\":\n\t\tupdateData[\"stage\"] = \"brackets\"\n\tcase \"final\":\n\t\tupdateData[\"stage\"] = \"championship\"\n\tdefault:\n\t\treturn errors.New(\"invalid classification level\")\n\t}\n\terr := base.GetInstance().TournamentDriver().Table(\"tournament_brackets\").\n\t\tWhere(\"id = ? AND status = ?\", t.ID, \"active\").\n\t\tUpdates(updateData).Error\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to update tournament status: %v\", err)\n\t}\n\treturn nil\n}",
    "caller": "func HandleTournamentProgress(eventID uint) error {\n\tcompEvent := &Tournament{\n\t\tID:                  eventID,\n\t\tClassificationLevel: \"main_event\",\n\t}\n\terr := compEvent.UpdateTournamentStatus()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not advance tournament: %v\", err)\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "ClassificationLevel is 'qualifier'",
            "sql": "UPDATE tournament_brackets SET stage = 'qualifying' WHERE id = ? AND status = 'active';"
          },
          {
            "scenario": "ClassificationLevel is 'main_event'",
            "sql": "UPDATE tournament_brackets SET stage = 'brackets' WHERE id = ? AND status = 'active';"
          },
          {
            "scenario": "ClassificationLevel is 'final'",
            "sql": "UPDATE tournament_brackets SET stage = 'championship' WHERE id = ? AND status = 'active';"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Tournament",
        "code_value": "type Tournament struct {\n\tID                  int\n\tClassificationLevel string\n\tStatus              string\n}"
      },
      {
        "code_key": "TournamentStage",
        "code_value": "const (\n\tStageQualifying  = \"qualifying\"\n\tStageBrackets    = \"brackets\"\n\tStageChampionship = \"championship\"\n)"
      },
      {
        "code_key": "TournamentStatus",
        "code_value": "const (\n\tStatusActive   = \"active\"\n\tStatusInactive = \"inactive\"\n\tStatusPending  = \"pending\"\n)"
      },
      {
        "code_key": "TournamentTable",
        "code_value": "const TournamentBracketTable = \"tournament_brackets\""
      },
      {
        "code_key": "ClassificationLevel",
        "code_value": "const (\n\tLevelQualifier = \"qualifier\"\n\tLevelMainEvent = \"main_event\"\n\tLevelFinal     = \"final\"\n)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "UpdateTournamentStatus",
    "orm_code": "func (t *Tournament) UpdateTournamentStatus() error {\n\tupdateData := make(map[string]interface{})\n\tswitch t.ClassificationLevel {\n\tcase \"qualifier\":\n\t\tupdateData[\"stage\"] = \"qualifying\"\n\tcase \"main_event\":\n\t\tupdateData[\"stage\"] = \"brackets\"\n\tcase \"final\":\n\t\tupdateData[\"stage\"] = \"championship\"\n\tdefault:\n\t\treturn errors.New(\"invalid classification level\")\n\t}\n\terr := base.GetInstance().TournamentDriver().Table(\"tournament_brackets\").\n\t\tWhere(\"id = ? AND status = ?\", t.ID, \"active\").\n\t\tUpdates(updateData).Error\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to update tournament status: %v\", err)\n\t}\n\treturn nil\n}",
    "caller": "func ProcessQualifierRound(championshipID uint) error {\n\tqualifier := Tournament{\n\t\tID:                  championshipID,\n\t\tClassificationLevel: \"qualifier\",\n\t}\n\tif updateErr := qualifier.UpdateTournamentStatus(); updateErr != nil {\n\t\treturn fmt.Errorf(\"qualifier stage update failed: %v\", updateErr)\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "ClassificationLevel is 'qualifier'",
            "sql": "UPDATE tournament_brackets SET stage = 'qualifying' WHERE id = ? AND status = 'active';"
          },
          {
            "scenario": "ClassificationLevel is 'main_event'",
            "sql": "UPDATE tournament_brackets SET stage = 'brackets' WHERE id = ? AND status = 'active';"
          },
          {
            "scenario": "ClassificationLevel is 'final'",
            "sql": "UPDATE tournament_brackets SET stage = 'championship' WHERE id = ? AND status = 'active';"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Tournament",
        "code_value": "type Tournament struct {\n\tID                  int\n\tClassificationLevel string\n\tStatus              string\n}"
      },
      {
        "code_key": "TournamentStage",
        "code_value": "const (\n\tStageQualifying  = \"qualifying\"\n\tStageBrackets    = \"brackets\"\n\tStageChampionship = \"championship\"\n)"
      },
      {
        "code_key": "TournamentStatus",
        "code_value": "const (\n\tStatusActive   = \"active\"\n\tStatusInactive = \"inactive\"\n\tStatusPending  = \"pending\"\n)"
      },
      {
        "code_key": "TournamentTable",
        "code_value": "const TournamentBracketTable = \"tournament_brackets\""
      },
      {
        "code_key": "ClassificationLevel",
        "code_value": "const (\n\tLevelQualifier = \"qualifier\"\n\tLevelMainEvent = \"main_event\"\n\tLevelFinal     = \"final\"\n)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "UpdateTournamentStatus",
    "orm_code": "func (t *Tournament) UpdateTournamentStatus() error {\n\tupdateData := make(map[string]interface{})\n\tswitch t.ClassificationLevel {\n\tcase \"qualifier\":\n\t\tupdateData[\"stage\"] = \"qualifying\"\n\tcase \"main_event\":\n\t\tupdateData[\"stage\"] = \"brackets\"\n\tcase \"final\":\n\t\tupdateData[\"stage\"] = \"championship\"\n\tdefault:\n\t\treturn errors.New(\"invalid classification level\")\n\t}\n\terr := base.GetInstance().TournamentDriver().Table(\"tournament_brackets\").\n\t\tWhere(\"id = ? AND status = ?\", t.ID, \"active\").\n\t\tUpdates(updateData).Error\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to update tournament status: %v\", err)\n\t}\n\treturn nil\n}",
    "caller": "func FinalizeChampionshipEvent(finalMatchID uint) error {\n\tfinalEvent := &Tournament{\n\t\tID:                  finalMatchID,\n\t\tClassificationLevel: \"final\",\n\t}\n\tif err := finalEvent.UpdateTournamentStatus(); err != nil {\n\t\treturn fmt.Errorf(\"championship finalization error: %v\", err)\n\t}\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Update tournament status to championship for active tournament with given ID",
            "sql": "UPDATE tournament_brackets SET stage = 'championship' WHERE id = ? AND status = 'active';"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Tournament",
        "code_value": "type Tournament struct {\n\tID                  int\n\tClassificationLevel string\n\tStatus              string\n}"
      },
      {
        "code_key": "TournamentStage",
        "code_value": "const (\n\tStageQualifying  = \"qualifying\"\n\tStageBrackets    = \"brackets\"\n\tStageChampionship = \"championship\"\n)"
      },
      {
        "code_key": "TournamentStatus",
        "code_value": "const (\n\tStatusActive   = \"active\"\n\tStatusInactive = \"inactive\"\n\tStatusPending  = \"pending\"\n)"
      },
      {
        "code_key": "TournamentTable",
        "code_value": "const TournamentBracketTable = \"tournament_brackets\""
      },
      {
        "code_key": "ClassificationLevel",
        "code_value": "const (\n\tLevelQualifier = \"qualifier\"\n\tLevelMainEvent = \"main_event\"\n\tLevelFinal     = \"final\"\n)"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ScanByPattern",
    "orm_code": "func (m *Media) ScanByPattern() ([]MediaInfo, error) {\n\tmediaList := make([]MediaInfo, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tswitch m.Pattern {\n\tcase \"video\":\n\t\tfilter[\"sector\"] = \"video\"\n\tcase \"audio\":\n\t\tfilter[\"sector\"] = \"audio\"\n\tcase \"image\":\n\t\tfilter[\"sector\"] = \"image\"\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported media pattern\")\n\t}\n\n\tif m.RefreshKey != \"\" {\n\t\tfilter[\"refresh_key\"] = m.RefreshKey\n\t}\n\n\terr := base.GetInstance().MediaDriver().Table(\"media_resources\").\n\t\tWhere(filter).Order(\"created_at DESC\").Find(&mediaList).Error\n\n\treturn mediaList, err\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Pattern为video且RefreshKey为空",
            "sql": "SELECT id, sector, status, refresh_key, created_at FROM media_resources WHERE status = 1 AND sector = 'video' ORDER BY created_at DESC;"
          },
          {
            "scenario": "Pattern为audio且RefreshKey为空",
            "sql": "SELECT id, sector, status, refresh_key, created_at FROM media_resources WHERE status = 1 AND sector = 'audio' ORDER BY created_at DESC;"
          },
          {
            "scenario": "Pattern为image且RefreshKey为空",
            "sql": "SELECT id, sector, status, refresh_key, created_at FROM media_resources WHERE status = 1 AND sector = 'image' ORDER BY created_at DESC;"
          },
          {
            "scenario": "Pattern为video且RefreshKey不为空",
            "sql": "SELECT id, sector, status, refresh_key, created_at FROM media_resources WHERE status = 1 AND sector = 'video' AND refresh_key = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "Pattern为audio且RefreshKey不为空",
            "sql": "SELECT id, sector, status, refresh_key, created_at FROM media_resources WHERE status = 1 AND sector = 'audio' AND refresh_key = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "Pattern为image且RefreshKey不为空",
            "sql": "SELECT id, sector, status, refresh_key, created_at FROM media_resources WHERE status = 1 AND sector = 'image' AND refresh_key = ? ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Media",
        "code_value": "type Media struct {\n\tPattern     string\n\tRefreshKey string\n}"
      },
      {
        "code_key": "MediaInfo",
        "code_value": "type MediaInfo struct {\n\tID         int    `gorm:\"column:id\"`\n\tSector     string `gorm:\"column:sector\"`\n\tStatus     int    `gorm:\"column:status\"`\n\tRefreshKey string `gorm:\"column:refresh_key\"`\n\tCreatedAt  string `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "MediaResourceTable",
        "code_value": "const MediaResourceTable = \"media_resources\""
      },
      {
        "code_key": "DefaultMediaStatus",
        "code_value": "const DefaultMediaStatus = 1"
      },
      {
        "code_key": "VideoPattern",
        "code_value": "const VideoPattern = \"video\""
      },
      {
        "code_key": "AudioPattern",
        "code_value": "const AudioPattern = \"audio\""
      },
      {
        "code_key": "ImagePattern",
        "code_value": "const ImagePattern = \"image\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ScanByPattern",
    "orm_code": "func (m *Media) ScanByPattern() ([]MediaInfo, error) {\n\tmediaList := make([]MediaInfo, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tswitch m.Pattern {\n\tcase \"video\":\n\t\tfilter[\"sector\"] = \"video\"\n\tcase \"audio\":\n\t\tfilter[\"sector\"] = \"audio\"\n\tcase \"image\":\n\t\tfilter[\"sector\"] = \"image\"\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported media pattern\")\n\t}\n\n\tif m.RefreshKey != \"\" {\n\t\tfilter[\"refresh_key\"] = m.RefreshKey\n\t}\n\n\terr := base.GetInstance().MediaDriver().Table(\"media_resources\").\n\t\tWhere(filter).Order(\"created_at DESC\").Find(&mediaList).Error\n\n\treturn mediaList, err\n}",
    "caller": "func HandleVideoResources(refreshToken string) ([]MediaInfo, error) {\n\tvideoMedia := &Media{\n\t\tPattern:     \"video\",\n\t\tRefreshKey: refreshToken,\n\t}\n\n\tresources, err := videoMedia.ScanByPattern()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to fetch video resources: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn resources, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "with refresh_key condition",
            "sql": "SELECT id, sector, status, refresh_key, created_at FROM media_resources WHERE status = 1 AND sector = 'video' AND refresh_key = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "without refresh_key condition",
            "sql": "SELECT id, sector, status, refresh_key, created_at FROM media_resources WHERE status = 1 AND sector = 'video' ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Media",
        "code_value": "type Media struct {\n\tPattern     string\n\tRefreshKey string\n}"
      },
      {
        "code_key": "MediaInfo",
        "code_value": "type MediaInfo struct {\n\tID         int    `gorm:\"column:id\"`\n\tSector     string `gorm:\"column:sector\"`\n\tStatus     int    `gorm:\"column:status\"`\n\tRefreshKey string `gorm:\"column:refresh_key\"`\n\tCreatedAt  string `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "MediaResourceTable",
        "code_value": "const MediaResourceTable = \"media_resources\""
      },
      {
        "code_key": "DefaultMediaStatus",
        "code_value": "const DefaultMediaStatus = 1"
      },
      {
        "code_key": "VideoPattern",
        "code_value": "const VideoPattern = \"video\""
      },
      {
        "code_key": "AudioPattern",
        "code_value": "const AudioPattern = \"audio\""
      },
      {
        "code_key": "ImagePattern",
        "code_value": "const ImagePattern = \"image\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ScanByPattern",
    "orm_code": "func (m *Media) ScanByPattern() ([]MediaInfo, error) {\n\tmediaList := make([]MediaInfo, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tswitch m.Pattern {\n\tcase \"video\":\n\t\tfilter[\"sector\"] = \"video\"\n\tcase \"audio\":\n\t\tfilter[\"sector\"] = \"audio\"\n\tcase \"image\":\n\t\tfilter[\"sector\"] = \"image\"\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported media pattern\")\n\t}\n\n\tif m.RefreshKey != \"\" {\n\t\tfilter[\"refresh_key\"] = m.RefreshKey\n\t}\n\n\terr := base.GetInstance().MediaDriver().Table(\"media_resources\").\n\t\tWhere(filter).Order(\"created_at DESC\").Find(&mediaList).Error\n\n\treturn mediaList, err\n}",
    "caller": "func HandleAudioCollection() ([]MediaInfo, error) {\n\taudioData := &Media{Pattern: \"audio\"}\n\n\tcollection, err := audioData.ScanByPattern()\n\tif err != nil {\n\t\tlog.Printf(\"Error retrieving audio collection: %v\", err)\n\t\treturn nil, fmt.Errorf(\"audio query failed: %w\", err)\n\t}\n\treturn collection, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Pattern is 'audio' and no RefreshKey provided",
            "sql": "SELECT id, sector, status, refresh_key, created_at FROM media_resources WHERE status = 1 AND sector = 'audio' ORDER BY created_at DESC;"
          },
          {
            "scenario": "Pattern is 'video' and no RefreshKey provided",
            "sql": "SELECT id, sector, status, refresh_key, created_at FROM media_resources WHERE status = 1 AND sector = 'video' ORDER BY created_at DESC;"
          },
          {
            "scenario": "Pattern is 'image' and no RefreshKey provided",
            "sql": "SELECT id, sector, status, refresh_key, created_at FROM media_resources WHERE status = 1 AND sector = 'image' ORDER BY created_at DESC;"
          },
          {
            "scenario": "Pattern is 'audio' and RefreshKey provided",
            "sql": "SELECT id, sector, status, refresh_key, created_at FROM media_resources WHERE status = 1 AND sector = 'audio' AND refresh_key = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "Pattern is 'video' and RefreshKey provided",
            "sql": "SELECT id, sector, status, refresh_key, created_at FROM media_resources WHERE status = 1 AND sector = 'video' AND refresh_key = ? ORDER BY created_at DESC;"
          },
          {
            "scenario": "Pattern is 'image' and RefreshKey provided",
            "sql": "SELECT id, sector, status, refresh_key, created_at FROM media_resources WHERE status = 1 AND sector = 'image' AND refresh_key = ? ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Media",
        "code_value": "type Media struct {\n\tPattern     string\n\tRefreshKey string\n}"
      },
      {
        "code_key": "MediaInfo",
        "code_value": "type MediaInfo struct {\n\tID         int    `gorm:\"column:id\"`\n\tSector     string `gorm:\"column:sector\"`\n\tStatus     int    `gorm:\"column:status\"`\n\tRefreshKey string `gorm:\"column:refresh_key\"`\n\tCreatedAt  string `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "MediaResourceTable",
        "code_value": "const MediaResourceTable = \"media_resources\""
      },
      {
        "code_key": "DefaultMediaStatus",
        "code_value": "const DefaultMediaStatus = 1"
      },
      {
        "code_key": "VideoPattern",
        "code_value": "const VideoPattern = \"video\""
      },
      {
        "code_key": "AudioPattern",
        "code_value": "const AudioPattern = \"audio\""
      },
      {
        "code_key": "ImagePattern",
        "code_value": "const ImagePattern = \"image\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "ScanByPattern",
    "orm_code": "func (m *Media) ScanByPattern() ([]MediaInfo, error) {\n\tmediaList := make([]MediaInfo, 0)\n\tfilter := make(map[string]interface{})\n\tfilter[\"status\"] = 1\n\n\tswitch m.Pattern {\n\tcase \"video\":\n\t\tfilter[\"sector\"] = \"video\"\n\tcase \"audio\":\n\t\tfilter[\"sector\"] = \"audio\"\n\tcase \"image\":\n\t\tfilter[\"sector\"] = \"image\"\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported media pattern\")\n\t}\n\n\tif m.RefreshKey != \"\" {\n\t\tfilter[\"refresh_key\"] = m.RefreshKey\n\t}\n\n\terr := base.GetInstance().MediaDriver().Table(\"media_resources\").\n\t\tWhere(filter).Order(\"created_at DESC\").Find(&mediaList).Error\n\n\treturn mediaList, err\n}",
    "caller": "func ProcessGalleryImages() {\n\tgallery := &Media{Pattern: \"image\"}\n\n\timages, err := gallery.ScanByPattern()\n\tif err != nil {\n\t\tlog.Printf(\"Gallery processing error: %v\", err)\n\t\treturn\n\t}\n\t// Process images...\n\tfmt.Printf(\"Processed %d gallery images\\n\", len(images))\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "Pattern = 'image', RefreshKey为空",
            "sql": "SELECT id, sector, status, refresh_key, created_at FROM media_resources WHERE status = 1 AND sector = 'image' ORDER BY created_at DESC;"
          },
          {
            "scenario": "Pattern = 'video', RefreshKey为空",
            "sql": "SELECT id, sector, status, refresh_key, created_at FROM media_resources WHERE status = 1 AND sector = 'video' ORDER BY created_at DESC;"
          },
          {
            "scenario": "Pattern = 'audio', RefreshKey为空",
            "sql": "SELECT id, sector, status, refresh_key, created_at FROM media_resources WHERE status = 1 AND sector = 'audio' ORDER BY created_at DESC;"
          },
          {
            "scenario": "Pattern = 'image', RefreshKey非空",
            "sql": "SELECT id, sector, status, refresh_key, created_at FROM media_resources WHERE status = 1 AND sector = 'image' AND refresh_key = ? ORDER BY created_at DESC;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Media",
        "code_value": "type Media struct {\n\tPattern     string\n\tRefreshKey string\n}"
      },
      {
        "code_key": "MediaInfo",
        "code_value": "type MediaInfo struct {\n\tID         int    `gorm:\"column:id\"`\n\tSector     string `gorm:\"column:sector\"`\n\tStatus     int    `gorm:\"column:status\"`\n\tRefreshKey string `gorm:\"column:refresh_key\"`\n\tCreatedAt  string `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "MediaResourceTable",
        "code_value": "const MediaResourceTable = \"media_resources\""
      },
      {
        "code_key": "DefaultMediaStatus",
        "code_value": "const DefaultMediaStatus = 1"
      },
      {
        "code_key": "VideoPattern",
        "code_value": "const VideoPattern = \"video\""
      },
      {
        "code_key": "AudioPattern",
        "code_value": "const AudioPattern = \"audio\""
      },
      {
        "code_key": "ImagePattern",
        "code_value": "const ImagePattern = \"image\""
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "EvaluateResults",
    "orm_code": "func (t *Test) EvaluateResults() ([]types.ChapterScore, error) {\n\tscores := make([]types.ChapterScore, 0)\n\tquery := base.GetInstance().ResultDriver().Table(\"price_history\")\n\n\tswitch t.Content {\n\tcase \"basic\":\n\t\tquery = query.Where(\"score >= ? AND secret_hash IS NOT NULL\", 60)\n\tcase \"advanced\":\n\t\tquery = query.Where(\"score >= ? AND created_at > ?\", 80, t.StartTime)\n\tcase \"premium\":\n\t\tquery = query.Where(\"score >= ? AND created_at BETWEEN ? AND ?\", 90, t.StartTime, t.EndTime)\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported test type\")\n\t}\n\n\terr := query.Order(\"score DESC\").Limit(t.PageSize).Find(&scores).Error\n\treturn scores, err\n}",
    "caller": "",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "basic test scenario (score >= 60 AND secret_hash IS NOT NULL)",
            "sql": "SELECT id, score, secret_hash, created_at FROM price_history WHERE score >= 60 AND secret_hash IS NOT NULL ORDER BY score DESC LIMIT 10;"
          },
          {
            "scenario": "advanced test scenario (score >= 80 AND created_at > start time)",
            "sql": "SELECT id, score, secret_hash, created_at FROM price_history WHERE score >= 80 AND created_at > '2023-01-01 00:00:00' ORDER BY score DESC LIMIT 20;"
          },
          {
            "scenario": "premium test scenario (score >= 90 AND created_at BETWEEN start and end time)",
            "sql": "SELECT id, score, secret_hash, created_at FROM price_history WHERE score >= 90 AND created_at BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' ORDER BY score DESC LIMIT 5;"
          }
        ]
      },
      {
        "type": "NO_SQL_GENERATE",
        "variants": [
          {
            "scenario": "unsupported test type (default case)",
            "sql": ""
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT",
      "OTHER"
    ],
    "sql_length_match": false,
    "code_meta_data": [
      {
        "code_key": "Test",
        "code_value": "type Test struct {\n\tContent   string\n\tStartTime time.Time\n\tEndTime   time.Time\n\tPageSize  int\n}"
      },
      {
        "code_key": "ChapterScore",
        "code_value": "type ChapterScore struct {\n\tID         int       `gorm:\"column:id\"`\n\tScore      int       `gorm:\"column:score\"`\n\tSecretHash string    `gorm:\"column:secret_hash\"`\n\tCreatedAt  time.Time `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "TestType",
        "code_value": "const (\n\tBasicTest    = \"basic\"\n\tAdvancedTest = \"advanced\"\n\tPremiumTest  = \"premium\"\n)"
      },
      {
        "code_key": "PriceHistoryTable",
        "code_value": "const PriceHistoryTable = \"price_history\""
      },
      {
        "code_key": "ScoreThresholds",
        "code_value": "var ScoreThresholds = map[string]int{\n\tBasicTest:    60,\n\tAdvancedTest: 80,\n\tPremiumTest:  90\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "EvaluateResults",
    "orm_code": "func (t *Test) EvaluateResults() ([]types.ChapterScore, error) {\n\tscores := make([]types.ChapterScore, 0)\n\tquery := base.GetInstance().ResultDriver().Table(\"price_history\")\n\n\tswitch t.Content {\n\tcase \"basic\":\n\t\tquery = query.Where(\"score >= ? AND secret_hash IS NOT NULL\", 60)\n\tcase \"advanced\":\n\t\tquery = query.Where(\"score >= ? AND created_at > ?\", 80, t.StartTime)\n\tcase \"premium\":\n\t\tquery = query.Where(\"score >= ? AND created_at BETWEEN ? AND ?\", 90, t.StartTime, t.EndTime)\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported test type\")\n\t}\n\n\terr := query.Order(\"score DESC\").Limit(t.PageSize).Find(&scores).Error\n\treturn scores, err\n}",
    "caller": "func HandleTestScores() ([]types.ChapterScore, error) {\n\tassessment := &Test{\n\t\tContent:  \"premium\",\n\t\tStartTime: time.Now().AddDate(0, -1, 0),\n\t\tEndTime:   time.Now(),\n\t\tPageSize:  50,\n\t}\n\tresults, err := assessment.EvaluateResults()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to evaluate: %v\", err)\n\t}\n\treturn results, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "premium test type",
            "sql": "SELECT id, score, secret_hash, created_at FROM price_history WHERE score >= 90 AND created_at BETWEEN '2023-05-15 12:00:00' AND '2024-05-15 12:00:00' ORDER BY score DESC LIMIT 50;"
          },
          {
            "scenario": "basic test type",
            "sql": "SELECT id, score, secret_hash, created_at FROM price_history WHERE score >= 60 AND secret_hash IS NOT NULL ORDER BY score DESC LIMIT 50;"
          },
          {
            "scenario": "advanced test type",
            "sql": "SELECT id, score, secret_hash, created_at FROM price_history WHERE score >= 80 AND created_at > '2023-05-15 12:00:00' ORDER BY score DESC LIMIT 50;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Test",
        "code_value": "type Test struct {\n\tContent   string\n\tStartTime time.Time\n\tEndTime   time.Time\n\tPageSize  int\n}"
      },
      {
        "code_key": "ChapterScore",
        "code_value": "type ChapterScore struct {\n\tID         int       `gorm:\"column:id\"`\n\tScore      int       `gorm:\"column:score\"`\n\tSecretHash string    `gorm:\"column:secret_hash\"`\n\tCreatedAt  time.Time `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "TestType",
        "code_value": "const (\n\tBasicTest    = \"basic\"\n\tAdvancedTest = \"advanced\"\n\tPremiumTest  = \"premium\"\n)"
      },
      {
        "code_key": "PriceHistoryTable",
        "code_value": "const PriceHistoryTable = \"price_history\""
      },
      {
        "code_key": "ScoreThresholds",
        "code_value": "var ScoreThresholds = map[string]int{\n\tBasicTest:    60,\n\tAdvancedTest: 80,\n\tPremiumTest:  90\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "EvaluateResults",
    "orm_code": "func (t *Test) EvaluateResults() ([]types.ChapterScore, error) {\n\tscores := make([]types.ChapterScore, 0)\n\tquery := base.GetInstance().ResultDriver().Table(\"price_history\")\n\n\tswitch t.Content {\n\tcase \"basic\":\n\t\tquery = query.Where(\"score >= ? AND secret_hash IS NOT NULL\", 60)\n\tcase \"advanced\":\n\t\tquery = query.Where(\"score >= ? AND created_at > ?\", 80, t.StartTime)\n\tcase \"premium\":\n\t\tquery = query.Where(\"score >= ? AND created_at BETWEEN ? AND ?\", 90, t.StartTime, t.EndTime)\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported test type\")\n\t}\n\n\terr := query.Order(\"score DESC\").Limit(t.PageSize).Find(&scores).Error\n\treturn scores, err\n}",
    "caller": "func ProcessBasicEvaluations() error {\n\texamData := &Test{\n\t\tContent: \"basic\",\n\t\tPageSize: 100,\n\t}\n\tgrades, err := examData.EvaluateResults()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"evaluation error: %v\", err)\n\t}\n\tlog.Printf(\"Retrieved %d passing scores\", len(grades))\n\treturn nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "basic test content",
            "sql": "SELECT id, score, secret_hash, created_at FROM price_history WHERE score >= 60 AND secret_hash IS NOT NULL ORDER BY score DESC LIMIT 100;"
          },
          {
            "scenario": "advanced test content",
            "sql": "SELECT id, score, secret_hash, created_at FROM price_history WHERE score >= 80 AND created_at > ? ORDER BY score DESC LIMIT ?;"
          },
          {
            "scenario": "premium test content",
            "sql": "SELECT id, score, secret_hash, created_at FROM price_history WHERE score >= 90 AND created_at BETWEEN ? AND ? ORDER BY score DESC LIMIT ?;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Test",
        "code_value": "type Test struct {\n\tContent   string\n\tStartTime time.Time\n\tEndTime   time.Time\n\tPageSize  int\n}"
      },
      {
        "code_key": "ChapterScore",
        "code_value": "type ChapterScore struct {\n\tID         int       `gorm:\"column:id\"`\n\tScore      int       `gorm:\"column:score\"`\n\tSecretHash string    `gorm:\"column:secret_hash\"`\n\tCreatedAt  time.Time `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "TestType",
        "code_value": "const (\n\tBasicTest    = \"basic\"\n\tAdvancedTest = \"advanced\"\n\tPremiumTest  = \"premium\"\n)"
      },
      {
        "code_key": "PriceHistoryTable",
        "code_value": "const PriceHistoryTable = \"price_history\""
      },
      {
        "code_key": "ScoreThresholds",
        "code_value": "var ScoreThresholds = map[string]int{\n\tBasicTest:    60,\n\tAdvancedTest: 80,\n\tPremiumTest:  90\n}"
      }
    ],
    "sql_pattern_cnt": 1
  },
  {
    "function_name": "EvaluateResults",
    "orm_code": "func (t *Test) EvaluateResults() ([]types.ChapterScore, error) {\n\tscores := make([]types.ChapterScore, 0)\n\tquery := base.GetInstance().ResultDriver().Table(\"price_history\")\n\n\tswitch t.Content {\n\tcase \"basic\":\n\t\tquery = query.Where(\"score >= ? AND secret_hash IS NOT NULL\", 60)\n\tcase \"advanced\":\n\t\tquery = query.Where(\"score >= ? AND created_at > ?\", 80, t.StartTime)\n\tcase \"premium\":\n\t\tquery = query.Where(\"score >= ? AND created_at BETWEEN ? AND ?\", 90, t.StartTime, t.EndTime)\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported test type\")\n\t}\n\n\terr := query.Order(\"score DESC\").Limit(t.PageSize).Find(&scores).Error\n\treturn scores, err\n}",
    "caller": "func AnalyzeAdvancedResults(startDate time.Time) ([]types.ChapterScore, error) {\n\texam := &Test{\n\t\tContent:  \"advanced\",\n\t\tStartTime: startDate,\n\t\tPageSize:  20,\n\t}\n\toutcomes, err := exam.EvaluateResults()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"analysis failed: %v\", err)\n\t}\n\treturn outcomes, nil\n}",
    "sql_statement_list": [
      {
        "type": "param_dependent",
        "variants": [
          {
            "scenario": "advanced test type with start time parameter and page size 20",
            "sql": "SELECT id, score, secret_hash, created_at FROM price_history WHERE score >= 80 AND created_at > ? ORDER BY score DESC LIMIT 20;"
          }
        ]
      }
    ],
    "sql_types": [
      "PARAM_DEPENDENT"
    ],
    "sql_length_match": true,
    "code_meta_data": [
      {
        "code_key": "Test",
        "code_value": "type Test struct {\n\tContent   string\n\tStartTime time.Time\n\tEndTime   time.Time\n\tPageSize  int\n}"
      },
      {
        "code_key": "ChapterScore",
        "code_value": "type ChapterScore struct {\n\tID         int       `gorm:\"column:id\"`\n\tScore      int       `gorm:\"column:score\"`\n\tSecretHash string    `gorm:\"column:secret_hash\"`\n\tCreatedAt  time.Time `gorm:\"column:created_at\"`\n}"
      },
      {
        "code_key": "TestType",
        "code_value": "const (\n\tBasicTest    = \"basic\"\n\tAdvancedTest = \"advanced\"\n\tPremiumTest  = \"premium\"\n)"
      },
      {
        "code_key": "PriceHistoryTable",
        "code_value": "const PriceHistoryTable = \"price_history\""
      },
      {
        "code_key": "ScoreThresholds",
        "code_value": "var ScoreThresholds = map[string]int{\n\tBasicTest:    60,\n\tAdvancedTest: 80,\n\tPremiumTest:  90\n}"
      }
    ],
    "sql_pattern_cnt": 1
  }
]