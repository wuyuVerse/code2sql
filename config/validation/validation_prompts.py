"""
三阶段代码转SQL分析的提示词模板
"""

# 第一阶段：分析ORM代码，生成SQL分析结果
ANALYSIS_PROMPT_TEMPLATE = """
这是一段基于gorm框架的ORM代码。gorm是Go语言的优秀ORM库，支持模型关联、事务处理、钩子方法、自动迁移、自定义类型等多种功能。
请注意，这是一个ORM代码块，该ORM代码是一个函数，函数名为{function_name}，它一定会转换并生成SQL语句，请务必分析出所有可能的SQL语句。

**重要原则：**
**只分析目标代码块**：只能从{function_name}函数的代码中生成SQL语句，code_meta_data仅作为理解上下文的辅助信息
**禁止推测或添加**：严禁推测、臆想或添加目标代码中不存在的SQL操作（如从DELETE代码推测INSERT操作）
**不自动添加软删除条件**：不要自动添加deleted_at IS NULL等软删除相关的WHERE条件，除非代码中明确使用了Unscoped()或显式包含此类条件
**区分Go方法和SQL函数**：Go代码中的字符串方法（如.Lower()、.ToUpper()等）不应该出现在生成的SQL中，除非是通过gorm的SQL函数明确调用
**识别GORM特殊方法**：
   - First()方法会自动添加LIMIT 1
   - Take()方法会自动添加LIMIT 1
   - Last()方法会自动添加LIMIT 1和ORDER BY主键DESC
   - Find()方法不添加LIMIT
   - Count()方法生成SELECT COUNT(*)

在分析前，请先确定ORM代码操作的表名：
1. 在gorm中，表名可以通过多种方式确定：
   - 请优先查看元数据(code_meta_data)中是否包含TableName()函数，该函数或者该函数对应的某个嵌套函数会显式返回表名
   - 检查code_meta_data或相关上下文中是否存在config文件或配置项，这些配置可能包含表名映射关系
   - 配置可能出现在类似'conf'、'config'、'setting'等文件或变量中，通常包含'TableName'、'table_name'或特定表名的映射
   - **重要提示：仔细区分表名映射的来源：**
     * **映射定义类型**：通过const常量、type类型定义、映射配置文件等方式预先定义的表名映射
     * **直接显式类型**：在ORM代码中直接写出的表名或字段名，如Where("id = ? and versionId=?", f.ID, f.VersionId)中的"id"和"versionId"
     * 映射定义类型的表名映射具有更高优先级，应该优先使用
     * 直接显式类型的表名/字段名应该按原样保留，不进行格式转换
   - 如果找到配置文件中的表名映射，应优先使用这些映射而非默认规则
   - **表名命名规则**：如果没有TableName()函数和配置映射，则按以下规则处理：
     * 将结构体名称按照驼峰命名法拆解：AaaaaBbbbb -> aaaaa_bbbbb
     * **注意：不要私自添加s后缀进行复数化**
     * 例如：UserInfo -> user_info（不是user_infos），OrderDetail -> order_detail（不是order_details）
     * 只有在元数据中明确指定了复数表名时才使用复数形式
   - 也可能在代码中通过Table()方法显式指定表名
2. **字段名映射规则**：
   - **优先级1：映射定义**：检查结构体tag中的column标签，如`gorm:"column:user_name"`
   - **优先级2：配置映射**：检查代码元数据中是否有字段名映射配置（const、type、配置文件等）
   - **优先级3：直接显式**：代码中直接写出的字段名，如Where("user_id = ?")中的"user_id"，应按原样保留
   - **优先级4：默认转换**：如果以上都没有，将Go字段名按驼峰拆解：UserName -> user_name
   - **重要：直接在SQL字符串中写出的字段名（如Where子句中的字段）应该按原样使用，不进行任何转换**

**重要：undefined_column处理规则**
当生成SQL语句时，如果遇到以下情况，**必须强制使用`undefined_column`替代无法确定的列名**：
1. **INSERT语句列名无法确定**：
- 当使用Create()、CreateInBatches()等方法直接传入结构体，且无法从元数据确定结构体字段到数据库列的映射时
- 当INSERT语句的列名依赖于未知的结构体定义时
- **强制要求**：必须生成完整的INSERT语法，不能使用省略号(...)或任何省略形式
- 示例：`INSERT INTO table_name (undefined_column) VALUES (?)`
- 批量插入示例：`INSERT INTO table_name (undefined_column) VALUES (?), (?), (...)`
2. **具体适用场景**：
- 函数参数中的字段名参数：`Where(fieldName + " = ?", value)` 其中fieldName是变量
- 动态构建的条件：通过map遍历或条件判断动态添加的字段，但无法确定具体字段名
- 结构体反射：通过反射获取字段但无法确定数据库映射关系
- 配置驱动：字段名来自外部配置但配置内容未知
- **ORM方法传入结构体**：当Create()、Update()等方法直接传入结构体，且无结构体定义时
3. **强制性要求**：
- **绝对禁止使用省略号(...)、省略符号或任何形式的省略表示**
- **必须生成语法完整的SQL语句**，即使列名不确定
- **保持SQL语法的完整性和可读性**
- **明确标识无法确定的列**，便于后续处理和调试
- **确保生成的SQL在语法上是有效的**，只是列名用占位符替代
4. **不适用情况**：
- 当字段名可以通过代码静态分析确定时，即使需要转换格式，也不使用undefined_column
- 当字段名在代码中直接以字符串形式写出时，应按原样保留
- 当可以从结构体tag、配置映射等方式确定字段名时
**重要提醒**：无论在任何情况下，都不允许在SQL语句中使用省略号(...)、"..."或任何省略形式。必须使用undefined_column来保持SQL的完整性。

**重要：WHERE条件列组合分析**
在分析WHERE条件时，请特别注意以下几点，确保覆盖所有可能的条件组合：
1. **条件字段识别**：仔细识别代码中所有可能作为WHERE条件的字段，包括：
   - 直接通过Where()方法添加的条件字段
   - 通过结构体字段动态构建的条件（如非零值字段）
   - 通过循环或条件判断动态添加的字段
   - 通过函数参数传入的可选条件字段
   - 通过map或slice遍历添加的条件字段
2. **条件组合枚举**：对于每个可能的条件字段，分析其在不同场景下的组合情况：
   - 单个条件：每个字段单独作为WHERE条件
   - 两个条件组合：任意两个字段的AND组合
   - 三个及以上条件组合：多个字段的AND组合
   - OR条件组合：如果代码中存在OR逻辑
   - 嵌套条件：如果存在括号分组的复杂条件
3. **动态条件分析**：特别关注以下动态条件构建模式：
   - `if condition != nil/empty {{ query = query.Where("field = ?", condition) }}`
   - `for key, value := range conditions {{ query = query.Where(key+" = ?", value) }}`
   - `switch/case`语句中的不同条件分支
   - 结构体字段的非零值检查：`if obj.Field != "" {{ query = query.Where("field = ?", obj.Field) }}`
4. **条件变体生成**：为每种可能的条件组合生成对应的SQL变体：
   - 场景1：只有字段A的条件 -> `WHERE field_a = ?`
   - 场景2：只有字段B的条件 -> `WHERE field_b = ?`
   - 场景3：字段A和B都有条件 -> `WHERE field_a = ? AND field_b = ?`
   - 场景4：字段A、B、C都有条件 -> `WHERE field_a = ? AND field_b = ? AND field_c = ?`
   - 等等...
5. **条件操作符识别**：注意不同的条件操作符会产生不同的SQL结构：
   - 等值条件：`= ?`
   - 范围条件：`> ?`, `< ?`, `>= ?`, `<= ?`
   - 模糊匹配：`LIKE ?`
   - 包含条件：`IN (?)`
   - 空值检查：`IS NULL`, `IS NOT NULL`
   - 存在性检查：`EXISTS`
6. **示例分析模式**：
   假设代码中有三个可选条件字段：name, age, status
   则应该生成以下所有可能的WHERE条件组合：
   - 无条件：`SELECT * FROM table`
   - 单条件：`WHERE name = ?`, `WHERE age = ?`, `WHERE status = ?`
   - 双条件：`WHERE name = ? AND age = ?`, `WHERE name = ? AND status = ?`, `WHERE age = ? AND status = ?`
   - 三条件：`WHERE name = ? AND age = ? AND status = ?`
请确保在分析时不要遗漏任何可能的条件组合，特别是那些通过动态逻辑构建的条件。

**重要：调用者上下文约束**
当提供了调用者信息时，请严格遵循以下约束：
1. **执行路径限定**：只分析和生成由当前调用者调用该ORM函数时会产生的SQL语句
   - 分析调用者的参数传递方式和调用条件
   - 只考虑在当前调用上下文中可能执行的代码分支
   - 排除调用者不会触发的条件分支和执行路径
2. **排除调用者自身SQL**：不要包含调用者本身可能生成的SQL语句
   - 调用者代码中的其他数据库操作不属于分析范围
   - 只关注通过调用当前ORM函数产生的SQL
3. **排除独立执行路径**：不要包含ORM代码在没有调用者情况下的独立执行路径
   - 如果ORM函数有多种调用方式，只考虑当前调用者的调用方式
   - 排除其他潜在调用者可能触发的执行路径
4. **参数上下文分析**：
   - 分析调用者传递的具体参数类型和值范围
   - 根据调用者的参数确定ORM代码中的条件分支
   - 只生成在当前参数上下文下会执行的SQL语句
5. **调用链追踪**：
   - 追踪从调用者到ORM函数的完整调用链
   - 确保SQL生成路径与实际调用路径一致
   - 考虑调用者的业务逻辑对ORM执行的影响
**注意**：如果没有提供调用者信息，则按原有方式分析所有可能的SQL执行路径。

**重要：忽略注释代码约束**
在分析ORM代码时，请严格遵循以下原则：
1. **完全忽略注释代码**：
   - 忽略所有以//开头的单行注释中的代码
   - 忽略所有/* */包围的多行注释中的代码
   - 注释掉的代码不会在实际执行中生效，不应影响SQL生成
2. **注释代码识别**：
   - 被//注释的整行代码应完全忽略
   - 被/* */注释块包围的代码段应完全忽略
   - 行末的//注释内容应忽略，但该行其他有效代码仍需分析
3. **避免注释干扰**：
   - 注释中的SQL相关代码（如Where条件、Join操作等）不应被纳入分析
   - 注释中的变量赋值、条件判断等逻辑不应影响执行路径分析
   - 注释中的数据库操作不应生成对应的SQL语句
4. **焦点在有效代码**：
   - 只分析和处理实际会执行的、未被注释的代码行
   - 基于有效代码的逻辑流程生成SQL语句
   - 确保生成的SQL完全对应实际执行的代码路径
5. **示例说明**：
   ```go
   db.Where("status = ?", status)  // 这行有效，需要分析
   // db.Where("deleted = ?", false)  // 这行被注释，完全忽略
   /* 
   db.Joins("User").Where("user.active = ?", true)  // 多行注释，完全忽略
   */
   db.Find(&result)  // 这行有效，需要分析
   ```
   在上述例子中，只应该分析第1行和最后1行的代码，生成对应的SQL。

**重要：JOIN操作和表别名处理规则**
当ORM代码涉及JOIN操作时（包括Joins()、Preload()、Association()等），生成的SQL语句必须遵循以下规则：
1. **表别名规则**：
   - 主表使用简短别名（通常是表名的第一个字母或缩写）
   - 关联表使用有意义的别名（如关联字段名或表名缩写）
   - 别名应该保持一致性，同一个表在整个查询中使用相同别名
2. **列名前缀要求**：
   - SELECT子句中的所有列名必须带表别名前缀：`table_alias.column_name`
   - WHERE子句中的所有列名必须带表别名前缀：`table_alias.column_name = ?`
   - ORDER BY子句中的所有列名必须带表别名前缀：`ORDER BY table_alias.column_name`
   - GROUP BY子句中的所有列名必须带表别名前缀：`GROUP BY table_alias.column_name`
   - HAVING子句中的所有列名必须带表别名前缀：`HAVING table_alias.column_name > ?`
3. **JOIN类型识别**：
   - INNER JOIN：显式关联条件，通常通过Joins()方法
   - LEFT JOIN：可选关联，常用于Preload()或左连接场景
   - 子查询JOIN：复杂关联可能产生子查询形式的JOIN
4. **关联条件处理**：
   - ON条件必须使用完整的表别名.列名格式：`ON t1.foreign_key = t2.primary_key`
   - 外键关联条件要准确映射Go结构体中的关联关系
   - 多对多关联可能涉及中间表的JOIN
5. **示例格式**：
   ```sql
   SELECT u.id, u.name, p.title FROM users u 
   LEFT JOIN posts p ON u.id = p.user_id 
   WHERE u.status = ? AND p.published = ?
   ```
   而不是：
   ```sql
   SELECT id, name, title FROM users 
   LEFT JOIN posts ON id = user_id 
   WHERE status = ? AND published = ?
   ```
6. **避免歧义**：
   - 当多个表有相同列名时，必须使用表别名区分
   - 即使只有一个表有某列名，为了保持一致性也应该使用表别名
   - 确保生成的SQL可以被标准SQL解析器正确解析，没有列名歧义

**关键：SQL生成有效性判断**
在开始分析之前，请首先判断给定的ORM代码是否真的会生成SQL语句：
1. **严格的SQL生成条件**：
   - 代码必须包含实际的数据库操作方法（如Find、Create、Update、Delete、Count、First等）
   - 仅有查询构建方法（如Where、Select、Join等）而没有执行方法的代码不会生成SQL
   - 仅有模型定义、结构体声明、连接设置等不会生成SQL
2. **无SQL生成的情况**：
   - 只是数据库连接初始化或配置
   - 只是结构体定义或模型声明
   - 只是变量赋值或条件判断，没有实际数据库操作
   - 只是查询构建但没有执行（如只有Where、Select但没有Find等执行方法）
   - 工具函数、辅助方法等非直接数据库操作代码
3. **返回策略**：
   - **如果代码不会生成任何SQL**：返回空字符串""或明确说明"该代码不生成SQL语句"
   - **绝对不要**：为了凑数而创造虚假的SQL语句
   - **绝对不要**：返回类似"SELECT ..."这样的模板或占位符
   - **绝对不要**：基于可能性或猜测生成SQL语句
4. **执行方法识别**：
   - 查询执行：Find()、First()、Last()、Take()、Count()、Pluck()等
   - 创建操作：Create()、CreateInBatches()等
   - 更新操作：Update()、Updates()、UpdateColumn()等
   - 删除操作：Delete()、Unscoped().Delete()等
   - 其他执行：Scan()、Raw()、Exec()等
5. **重要提醒**：
   - 宁可返回空结果也不要生成不准确的SQL
   - 第三轮格式化会自动处理真正的SQL，不需要主动填充
   - 确保返回的每个SQL都对应真实的数据库执行操作

请注意以下gorm特性可能会影响生成的SQL：
- 表名前缀/后缀：检查是否通过TablePrefix或TableSuffix设置了前缀或后缀
- 关联查询：Preload、Joins、Association等方法会生成不同的关联查询SQL
- 作用域(Scopes)：可能应用了通用查询条件
- 事务处理：可能包含多条相关的SQL语句
- Delete操作：当使用`.Where().Delete(structInstance)`时，GORM会：
  * 应用手动添加的WHERE条件
  * 自动根据传入结构体的主键字段添加额外的WHERE条件
  * 这意味着最终的DELETE语句会包含多个AND连接的WHERE条件
- **软删除注意事项**：
  * 只有在结构体明确包含gorm.DeletedAt字段且未使用Unscoped()时，才会自动添加deleted_at IS NULL条件
  * 如果代码中没有明确的软删除字段定义，不要自动添加此类条件
  * 使用Unscoped()的操作不会添加软删除条件

**GORM方法特殊处理**：
- **First()方法**：无论在何种上下文中使用，都会在生成的SQL中添加LIMIT 1
- **Take()方法**：添加LIMIT 1，但不会添加ORDER BY
- **Last()方法**：添加LIMIT 1和ORDER BY主键字段DESC
- **Find()方法**：不添加LIMIT，返回所有匹配的记录
- **Count()方法**：生成SELECT COUNT(*)语句
- **Raw()方法**：执行原生SQL，保持原样

请仔细分析代码中的表结构、字段映射、查询条件和操作类型，并完成以下任务：
1) 分析代码可能的执行路径，并根据以下情况进行详细说明：
 A. 如果代码会根据不同入参生成结构不同的SQL语句（不能只是sql条件列的参数值不同，一定需要是SQL结构、条件、连接方式等不同）：
- 请设计多种典型的入参场景（如不同条件组合、特殊标志位等）
- 对每个场景，给出具体的入参值
- 对每个场景，单独列出对应生成的完整SQL语句（包括参数绑定后的最终执行语句）
- 清晰说明每个场景下SQL结构的差异（如WHERE条件不同、JOIN方式不同、是否有GROUP BY等）
- **特别注意**：对于WHERE条件的不同组合，每种组合都应该被视为不同的SQL结构变体
- 如果仅是参数值不同但SQL结构完全相同，请归为同一类SQL模板
B. 如果代码本身会执行多条SQL语句（与入参无关）：
- 将这些SQL语句与上述场景分开列出
- 按执行顺序列出所有SQL语句
- 说明这些SQL语句之间的关系和执行逻辑
- 对每条SQL语句解释其目的和作用
C. 如果上述两种情况同时存在（既有结构不同的SQL，又有多条SQL）：
- 请先按入参场景分类
- 在每个入参场景下，按顺序列出该场景会执行的所有SQL语句
- 清晰区分不同场景和不同SQL语句
根据代码分析，该函数应该生成 3 条SQL语句。请确保你的分析包含正确数量的SQL语句（或SQL变体组）。
- 如果一个SQL语句有多个变体（因参数不同而结构不同），这仍然算作一条SQL语句
- 请仔细检查是否遗漏了某些SQL语句或错误地添加了不应该存在的SQL语句
请确保分析全面，考虑代码中的条件判断、循环、动态拼接等可能影响SQL结构生成的因素，输出所有可能的sql语句。特别注意区分"仅参数值不同"和"SQL结构不同"这两种情况。

相关全局变量的定义，可以帮助你获取到正确的表名，若代码中用到了这些全局变量，请严格使用全局变量的取值作为表名：

元数据：
{code_meta_data_str}

函数名称：
{function_name}

ORM代码：
{code_value}
"""


# 第二阶段：验证第一阶段的分析结果
VERIFICATION_PROMPT_TEMPLATE = """
这是一段基于gorm框架的ORM代码。gorm是Go语言的优秀ORM库，支持模型关联、事务处理、钩子方法、自动迁移、自定义类型等多种功能。
请检查以下从ORM代码生成的SQL语句分析是否准确，并将所有SQL语句以JSON格式返回。该ORM代码是一个函数，函数名为{function_name}。请记住，这是一个ORM代码块，它一定会生成SQL语句，不要遗漏任何可能的SQL。

**验证重要原则：**
**严格验证范围**：只验证从目标函数代码生成的SQL
**禁止额外推测**：不能添加原始分析中没有的SQL操作或字段条件
**调用者上下文验证**：如果提供了调用者信息，请验证以下内容：
   - 确认生成的SQL只包含由当前调用者触发的执行路径
   - 验证是否错误包含了调用者自身的SQL操作
   - 检查是否包含了与当前调用上下文无关的独立执行路径
   - 确认参数传递和调用条件与实际调用场景一致
   - 如果发现不符合调用者上下文的SQL，请将其移除
**注释代码验证**：请验证分析是否正确忽略了注释代码：
   - 检查是否错误地将注释中的代码纳入了SQL生成分析
   - 验证是否因注释代码而生成了不应存在的SQL语句
   - 确认所有生成的SQL都基于实际会执行的代码（非注释代码）
   - 检查是否被注释中的Where条件、Join操作等误导
   - 如果发现基于注释代码生成的SQL，请将其移除
**软删除条件验证**：检查是否错误添加了deleted_at IS NULL条件，只有明确包含gorm.DeletedAt字段的结构体才需要此条件
**Go方法过滤**：确保SQL中没有包含Go字符串方法（如LOWER()、UPPER()等），除非是显式的SQL函数调用
**GORM方法验证**：
   - 验证First()方法是否正确添加了LIMIT 1
   - 验证Take()方法是否正确添加了LIMIT 1
   - 验证Last()方法是否添加了LIMIT 1和ORDER BY
   - 验证Find()方法没有错误添加LIMIT
请先验证SQL语句中的表名是否正确：
1. 表名应该按以下优先级确定：
   - 检查元数据(code_meta_data)中的TableName()函数返回值，该函数或者该函数对应的某个嵌套函数会显式返回表名
   - 其次查找config文件或配置项中的表名映射
   - 配置通常存在于'conf'、'config'、'setting'等文件或变量中
   - **重要：区分表名映射信息的来源类型：**
     * **映射定义类型**：通过const常量、type类型定义、映射配置文件等方式预先定义的表名映射
     * **直接显式类型**：在ORM代码中直接写出的表名或字段名（如Where("id = ? and versionId=?")中的"id"和"versionId"）
     * 映射定义类型的信息具有最高优先级，应该优先使用
     * 直接显式类型的表名/字段名应该按原样保留，不进行任何格式转换
   - 如果配置中定义了表名映射，这应优先于默认命名规则使用
   - **表名命名规则**：如果没有找到明确的表名定义，则按以下规则处理：
     * 将结构体名称按照驼峰命名法拆解：AaaaaBbbbb -> aaaaa_bbbbb
     * **严格要求：不要私自添加s后缀进行复数化**
     * 例如：UserInfo -> user_info（绝不是user_infos），OrderDetail -> order_detail（绝不是order_details）
     * 只有在元数据中明确指定了复数表名时才使用复数形式
   - 最后检查代码中是否通过Table()方法显式指定了表名
2. 检查是否应用了表名前缀或后缀配置
3. 对于Delete操作，确认是否正确处理了以下情况：
   - 当使用`.Where().Delete(structInstance)`时，GORM会同时应用手动WHERE条件和结构体主键条件
   - 最终的DELETE语句应包含多个AND连接的WHERE条件
   - 验证是否遗漏了结构体主键字段的自动WHERE条件
4. **JOIN操作和表别名验证**：
   - 检查所有涉及JOIN的SQL语句是否正确使用了表别名
   - 验证SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的列名是否都带有表别名前缀
   - 确认ON条件使用了完整的表别名.列名格式（如：`ON t1.foreign_key = t2.primary_key`）
   - 检查表别名是否在整个查询中保持一致
   - 验证是否存在列名歧义（多个表有相同列名但没有表别名区分）
   - 确保生成的SQL可以被标准SQL解析器正确解析
5. **软删除验证重点**：
   - 检查是否错误地自动添加了deleted_at IS NULL或类似的软删除条件
   - 只有当目标代码涉及的结构体明确包含gorm.DeletedAt字段，且未使用Unscoped()时，才应该包含软删除条件
   - 如果原始代码中没有软删除相关的字段定义，必须移除这些条件
确认字段映射是否正确：
1. **字段名映射验证优先级**：
   - **最高优先级：映射定义**：结构体tag中的column标签，如`gorm:"column:user_name"`
   - **次高优先级：配置映射**：代码元数据中的字段名映射配置（const、type、配置文件等）
   - **中等优先级：直接显式**：代码中直接写出的字段名，如Where("user_id = ?")中的"user_id"，必须按原样保留
   - **最低优先级：默认转换**：如果以上都没有，将Go字段名按驼峰拆解：UserName -> user_name
2. **重要原则：直接在SQL字符串中写出的字段名应该完全按原样使用，不进行任何转换**
3. **字段名验证要点**：
   - 检查是否错误地对显式写出的字段名进行了格式转换
   - 验证映射定义类型的字段名是否正确应用
   - 确认默认转换规则是否正确应用（仅在没有其他定义时）
4. **Go方法检查**：
   - 检查SQL中是否错误包含了Go字符串方法，如LOWER()、UPPER()、TRIM()等
   - 这些方法应该在Go代码中处理，而不是出现在最终的SQL语句中
   - 只有通过gorm.Expr()或Raw()明确调用的SQL函数才应该保留

具体输出要求如下：
1. 输出应该是一个SQL语句数组，其中每个元素可以是：
- 一个字符串：表示单一固定的SQL语句
- 一个对象：表示因参数不同而产生结构变化的SQL语句，包含多个场景
注意，每一个SQL语句本身应该是完整可以执行的，不能包含省略号等无关内容。
2. 请确保输出是有效的JSON格式，结构如下：
[
 "固定的SQL语句1",
 {{
  "type": "param_dependent",
  "variants": [
     {{"scenario": "场景1描述", "sql": "变体SQL语句1"}},
     {{"scenario": "场景2描述", "sql": "变体SQL语句2"}}
   ]
 }},
 "固定的SQL语句2"
]
3. 这种格式能够表示：
- 单一SQL语句：直接作为数组元素
- 参数依赖的SQL变体：作为带有variants字段的对象
- 多条SQL语句：按执行顺序排列在数组中
- 混合情况：数组中可以同时包含固定SQL和参数依赖的SQL
4. 严格要求：
- SQL语句必须是完整可执行的，不能包含省略号或[其他字段]等占位符
- 所有表的列名必须完整列出，不能省略
- 所有的参数必须明确指出，不能使用"...[其他值]"等形式
- 所有SQL语句必须以分号结尾
- 如果SQL语句中有占位符参数，应使用问号(?)或具体的示例值代替
- 移除任何Go代码中的字符串方法调用，如.Lower()、.Upper()等
5. 对于SQL变体的重要说明：
- 只有当SQL语句的结构发生实质性变化时，才应被视为不同的变体
- 结构性变化包括：不同的查询类型(SELECT/INSERT/UPDATE/DELETE)、不同的表连接方式、不同的WHERE条件列、不同的GROUP BY/ORDER BY字段等
- 仅仅是参数值不同但SQL结构相同的情况，应该只列出一个代表性变体
- 示例：'WHERE id = 1' 和 'WHERE id = 2' 不是不同的变体，而是同一变体的不同参数
- 示例：'WHERE id = ?' 和 'WHERE name = ?' 是结构不同的变体，因为条件列不同
6. 根据ORM代码分析，该函数应该生成 2 条SQL语句。请确保你的输出包含正确数量的SQL语句（或SQL变体组）。
- 如果一个SQL语句有多个变体（因参数不同而结构不同），这仍然算作一条SQL语句
- 请仔细检查是否遗漏了某些SQL语句或错误地添加了不应该存在的SQL语句
- **重要**：如果原始分析包含了不应该存在的SQL，请将其移除
7. 请确保返回的是纯JSON格式，不要添加任何解释性文本。
8. 如果发现原始分析中的SQL语句有错误或不完整（如含有省略号、[其他字段]等占位符），请修正并补全完整的字段列表和参数。
9. 请确保返回的是纯JSON格式，不要添加任何解释性文本。

以下是需要检查的SQL语句分析：
{analysis_result}

相关全局变量的定义，可以帮助你获取到正确的表名，若代码中用到了这些全局变量，请严格使用全局变量的取值作为表名：

元数据：
{code_meta_data_str}

函数名称：
{function_name}

函数定义：
{code_value}
"""

# 第三阶段：格式化最终结果为JSON
FORMATTING_PROMPT_TEMPLATE = """
请将以下SQL语句分析结果格式化为标准JSON格式。

输出要求：
1. 输出应该是一个SQL语句数组，其中每个元素可以是：
   - 一个字符串：表示单一固定的SQL语句
   - 一个对象：表示因参数不同而变化的SQL语句，包含多个场景

2. JSON格式结构如下：
[
 "固定的SQL语句1",
 {{
  "type": "param_dependent",
  "variants": [
     {{"scenario": "场景1描述", "sql": "变体SQL语句1"}},
     {{"scenario": "场景2描述", "sql": "变体SQL语句2"}}
   ]
 }},
 "固定的SQL语句2"
]

3. 格式化规则：
   - 移除所有非SQL内容（如注释、解释或描述，以及...这类占位符）
   - 保持SQL语句的完整性
   - 所有SQL语句以分号结尾
   - 返回纯JSON格式，不要添加任何解释性文本或代码块标记

需要格式化的内容：
{analysis_to_format}
""" 