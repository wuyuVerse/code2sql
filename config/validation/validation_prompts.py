CODE_ORM_MYSQL_SQL_EXTRACT = \
    "这是一段基于gorm框架的ORM代码。gorm是Go语言的优秀ORM库，支持模型关联、事务处理、钩子方法、自动迁移、自定义类型等多种功能。" \
    "\n\n**第一步：边界条件判断**\n" \
    "在开始分析之前，请首先判断以下边界条件：\n\n" \
    "1. **SQL生成能力检查**：\n" \
    "   - 检查代码是否包含实际的数据库执行操作（Find、Create、Update、Delete、Count、First等）\n" \
    "   - 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n" \
    "   - 仅有模型定义、结构体声明、连接设置、工具函数等不会生成SQL\n" \
    "   - 被完全注释掉的代码不会生成SQL\n" \
    "   - **如果代码不会生成任何SQL**，请返回：`<NO SQL GENERATE>: 具体不能生成SQL的原因`\n\n" \
    "2. **信息完整性检查**：\n" \
    "   - 即使缺少一些具体的映射信息，也应该尝试基于常见的命名规范推测SQL\n" \
    "   - 只有在完全无法推测SQL结构的极端情况下，才标记为信息缺失\n" \
    "   - **如果能够推测出SQL但信息不完整**，请返回：`<LACK INFORMATION>: 缺失信息描述 | 推测的SQL语句`\n" \
    "   - **如果完全无法推测SQL结构**，请返回：`<LACK INFORMATION>: 缺失信息描述 | 无法推测`\n\n" \
    "3. **推测规则**：\n" \
    "   - 表名推测：根据结构体名称按驼峰转下划线规则推测（如UserInfo -> user_info）\n" \
    "   - 字段推测：根据Go结构体字段名按驼峰转下划线规则推测\n" \
    "   - 操作推测：根据GORM方法名推测操作类型（Create -> INSERT, Find -> SELECT等）\n" \
    "   - 即使表名通过函数生成，也要根据上下文和结构体名称推测可能的表名\n\n" \
    "4. **边界情况示例**：\n" \
    "   - 缺失但可推测：`<LACK INFORMATION>: 缺少GenerateTableName函数实现，根据SpaceRouter结构体推测表名 | INSERT INTO space_router (id, name) VALUES (?, ?);`\n" \
    "   - 无法生成SQL：`<NO SQL GENERATE>: 代码只包含数据库连接初始化，没有实际的数据库操作方法`\n" \
    "   - 完全无法推测：`<LACK INFORMATION>: 代码结构过于复杂，无法确定任何表名或操作类型 | 无法推测`\n\n" \
    "**只有在无法生成SQL的情况下，才直接返回边界条件标记。对于信息缺失但可以推测的情况，应该继续进行SQL分析，并在最终结果中标明信息缺失和推测的SQL。**\n\n" \
    "**第二步：SQL分析**\n" \
    "请注意，这是一个ORM代码块，它一定会转换并生成SQL语句，请务必分析出所有可能的SQL语句。\n" \
    "在分析前，请先确定ORM代码操作的表名：\n" \
    "1. 在gorm中，表名可以通过多种方式确定：\n" \
    "   - 请优先查看元数据(code_meta_data)中是否包含TableName()函数，该函数或者该函数对应的某个嵌套函数会显式返回表名\n" \
    "   - 检查code_meta_data或相关上下文中是否存在config文件或配置项，这些配置可能包含表名映射关系\n" \
    "   - 配置可能出现在类似'conf'、'config'、'setting'等文件或变量中，通常包含'TableName'、'table_name'或特定表名的映射\n" \
    "   - **重要提示：仔细区分表名映射的来源：**\n" \
    "     * **映射定义类型**：通过const常量、type类型定义、映射配置文件等方式预先定义的表名映射\n" \
    "     * **直接显式类型**：在ORM代码中直接写出的表名或字段名，如Where(\"id = ? and versionId=?\", f.ID, f.VersionId)中的\"id\"和\"versionId\"\n" \
    "     * 映射定义类型的表名映射具有更高优先级，应该优先使用\n" \
    "     * 直接显式类型的表名/字段名应该按原样保留，不进行格式转换\n" \
    "   - 如果找到配置文件中的表名映射，应优先使用这些映射而非默认规则\n" \
    "   - **表名推测规则**：如果没有明确的表名定义，则按以下规则推测：\n" \
    "     * 将结构体名称按照驼峰命名法拆解：AaaaaBbbbb -> aaaaa_bbbbb\n" \
    "     * **注意：不要私自添加s后缀进行复数化**\n" \
    "     * 例如：UserInfo -> user_info（不是user_infos），OrderDetail -> order_detail（不是order_details）\n" \
    "     * 只有在元数据中明确指定了复数表名时才使用复数形式\n" \
    "   - 也可能在代码中通过Table()方法显式指定表名\n" \
    "2. **字段名映射规则**：\n" \
    "   - **优先级1：映射定义**：检查结构体tag中的column标签，如`gorm:\"column:user_name\"`\n" \
    "   - **优先级2：配置映射**：检查代码元数据中是否有字段名映射配置（const、type、配置文件等）\n" \
    "   - **优先级3：直接显式**：代码中直接写出的字段名，如Where(\"user_id = ?\")中的\"user_id\"，应按原样保留\n" \
    "   - **优先级4：推测转换**：如果以上都没有，将Go字段名按驼峰拆解推测：UserName -> user_name\n" \
    "   - **重要：直接在SQL字符串中写出的字段名（如Where子句中的字段）应该按原样使用，不进行任何转换**\n\n" \
    "请注意以下gorm特性可能会影响生成的SQL：\n" \
    "- 表名前缀/后缀：检查是否通过TablePrefix或TableSuffix设置了前缀或后缀\n" \
    "- 关联查询：Preload、Joins、Association等方法会生成不同的关联查询SQL\n" \
    "- 作用域(Scopes)：可能应用了通用查询条件\n" \
    "- 事务处理：可能包含多条相关的SQL语句\n" \
    "- Delete操作：当使用`.Where().Delete(structInstance)`时，GORM会：\n" \
    "  * 应用手动添加的WHERE条件\n" \
    "  * 自动根据传入结构体的主键字段添加额外的WHERE条件\n" \
    "  * 这意味着最终的DELETE语句会包含多个AND连接的WHERE条件\n\n" \
    "**重要：JOIN操作和表别名处理规则**\n" \
    "当ORM代码涉及JOIN操作时（包括Joins()、Preload()、Association()等），生成的SQL语句必须遵循以下规则：\n" \
    "1. **表别名规则**：\n" \
    "   - 主表使用简短别名（通常是表名的第一个字母或缩写）\n" \
    "   - 关联表使用有意义的别名（如关联字段名或表名缩写）\n" \
    "   - 别名应该保持一致性，同一个表在整个查询中使用相同别名\n" \
    "2. **列名前缀要求**：\n" \
    "   - SELECT子句中的所有列名必须带表别名前缀：`table_alias.column_name`\n" \
    "   - WHERE子句中的所有列名必须带表别名前缀：`table_alias.column_name = ?`\n" \
    "   - ORDER BY子句中的所有列名必须带表别名前缀：`ORDER BY table_alias.column_name`\n" \
    "   - GROUP BY子句中的所有列名必须带表别名前缀：`GROUP BY table_alias.column_name`\n" \
    "   - HAVING子句中的所有列名必须带表别名前缀：`HAVING table_alias.column_name > ?`\n" \
    "3. **JOIN类型识别**：\n" \
    "   - INNER JOIN：显式关联条件，通常通过Joins()方法\n" \
    "   - LEFT JOIN：可选关联，常用于Preload()或左连接场景\n" \
    "   - 子查询JOIN：复杂关联可能产生子查询形式的JOIN\n" \
    "4. **关联条件处理**：\n" \
    "   - ON条件必须使用完整的表别名.列名格式：`ON t1.foreign_key = t2.primary_key`\n" \
    "   - 外键关联条件要准确映射Go结构体中的关联关系\n" \
    "   - 多对多关联可能涉及中间表的JOIN\n" \
    "5. **示例格式**：\n" \
    "   ```sql\n" \
    "   SELECT u.id, u.name, p.title FROM users u \n" \
    "   LEFT JOIN posts p ON u.id = p.user_id \n" \
    "   WHERE u.status = ? AND p.published = ?\n" \
    "   ```\n" \
    "   而不是：\n" \
    "   ```sql\n" \
    "   SELECT id, name, title FROM users \n" \
    "   LEFT JOIN posts ON id = user_id \n" \
    "   WHERE status = ? AND published = ?\n" \
    "   ```\n" \
    "6. **避免歧义**：\n" \
    "   - 当多个表有相同列名时，必须使用表别名区分\n" \
    "   - 即使只有一个表有某列名，为了保持一致性也应该使用表别名\n" \
    "   - 确保生成的SQL可以被标准SQL解析器正确解析，没有列名歧义\n\n" \
    "**重要：WHERE条件列组合分析**\n" \
    "在分析WHERE条件时，请特别注意以下几点，确保覆盖所有可能的条件组合：\n" \
    "1. **条件字段识别**：仔细识别代码中所有可能作为WHERE条件的字段，包括：\n" \
    "   - 直接通过Where()方法添加的条件字段\n" \
    "   - 通过结构体字段动态构建的条件（如非零值字段）\n" \
    "   - 通过循环或条件判断动态添加的字段\n" \
    "   - 通过函数参数传入的可选条件字段\n" \
    "   - 通过map或slice遍历添加的条件字段\n" \
    "2. **条件组合枚举**：对于每个可能的条件字段，分析其在不同场景下的组合情况：\n" \
    "   - 单个条件：每个字段单独作为WHERE条件\n" \
    "   - 两个条件组合：任意两个字段的AND组合\n" \
    "   - 三个及以上条件组合：多个字段的AND组合\n" \
    "   - OR条件组合：如果代码中存在OR逻辑\n" \
    "   - 嵌套条件：如果存在括号分组的复杂条件\n" \
    "3. **动态条件分析**：特别关注以下动态条件构建模式：\n" \
    "   - `if condition != nil/empty {{ query = query.Where(\"field = ?\", condition) }}`\n" \
    "   - `for key, value := range conditions {{ query = query.Where(key+\" = ?\", value) }}`\n" \
    "   - `switch/case`语句中的不同条件分支\n" \
    "   - 结构体字段的非零值检查：`if obj.Field != \"\" {{ query = query.Where(\"field = ?\", obj.Field) }}`\n" \
    "4. **条件变体生成**：为每种可能的条件组合生成对应的SQL变体：\n" \
    "   - 场景1：只有字段A的条件 -> `WHERE field_a = ?`\n" \
    "   - 场景2：只有字段B的条件 -> `WHERE field_b = ?`\n" \
    "   - 场景3：字段A和B都有条件 -> `WHERE field_a = ? AND field_b = ?`\n" \
    "   - 场景4：字段A、B、C都有条件 -> `WHERE field_a = ? AND field_b = ? AND field_c = ?`\n" \
    "   - 等等...\n" \
    "5. **条件操作符识别**：注意不同的条件操作符会产生不同的SQL结构：\n" \
    "   - 等值条件：`= ?`\n" \
    "   - 范围条件：`> ?`, `< ?`, `>= ?`, `<= ?`\n" \
    "   - 模糊匹配：`LIKE ?`\n" \
    "   - 包含条件：`IN (?)`\n" \
    "   - 空值检查：`IS NULL`, `IS NOT NULL`\n" \
    "   - 存在性检查：`EXISTS`\n" \
    "6. **示例分析模式**：\n" \
    "   假设代码中有三个可选条件字段：name, age, status\n" \
    "   则应该生成以下所有可能的WHERE条件组合：\n" \
    "   - 无条件：`SELECT * FROM table`\n" \
    "   - 单条件：`WHERE name = ?`, `WHERE age = ?`, `WHERE status = ?`\n" \
    "   - 双条件：`WHERE name = ? AND age = ?`, `WHERE name = ? AND status = ?`, `WHERE age = ? AND status = ?`\n" \
    "   - 三条件：`WHERE name = ? AND age = ? AND status = ?`\n" \
    "请确保在分析时不要遗漏任何可能的条件组合，特别是那些通过动态逻辑构建的条件。\n\n" \
    "请仔细分析代码中的表结构、字段映射、查询条件和操作类型，并完成以下任务：\n" \
    "1) 分析代码可能的执行路径，并根据以下情况进行详细说明：\n" \
    " A. 如果代码会根据不同入参生成结构不同的SQL语句（不能只是sql条件列的参数值不同，一定需要是SQL结构、条件、连接方式等不同）：\n" \
    "- 请设计多种典型的入参场景（如不同条件组合、特殊标志位等）\n" \
    "- 对每个场景，给出具体的入参值\n" \
    "- 对每个场景，单独列出对应生成的完整SQL语句（包括参数绑定后的最终执行语句）\n" \
    "- 清晰说明每个场景下SQL结构的差异（如WHERE条件不同、JOIN方式不同、是否有GROUP BY等）\n" \
    "- **特别注意**：对于WHERE条件的不同组合，每种组合都应该被视为不同的SQL结构变体\n" \
    "- 如果仅是参数值不同但SQL结构完全相同，请归为同一类SQL模板\n" \
    "B. 如果代码本身会执行多条SQL语句（与入参无关）：\n" \
    "- 将这些SQL语句与上述场景分开列出\n" \
    "- 按执行顺序列出所有SQL语句\n" \
    "- 说明这些SQL语句之间的关系和执行逻辑\n" \
    "- 对每条SQL语句解释其目的和作用\n" \
    "C. 如果上述两种情况同时存在（既有结构不同的SQL，又有多条SQL）：\n" \
    "- 请先按入参场景分类\n" \
    "- 在每个入参场景下，按顺序列出该场景会执行的所有SQL语句\n" \
    "- 清晰区分不同场景和不同SQL语句\n" \
    "根据代码分析，该函数应该生成 {sql_pattern_cnt} 条SQL语句。请确保你的分析包含正确数量的SQL语句（或SQL变体组）。\n" \
    "- 如果一个SQL语句有多个变体（因参数不同而结构不同），这仍然算作一条SQL语句\n" \
    "- 请仔细检查是否遗漏了某些SQL语句或错误地添加了不应该存在的SQL语句\n" \
    "请确保分析全面，考虑代码中的条件判断、循环、动态拼接等可能影响SQL结构生成的因素，输出所有可能的sql语句。" \
    "特别注意区分\"仅参数值不同\"和\"SQL结构不同\"这两种情况。\n\n" \
    "**重要：调用者上下文约束**\n" \
    "当提供了调用者信息时，请严格遵循以下约束：\n" \
    "1. **执行路径限定**：只分析和生成由当前调用者调用该ORM函数时会产生的SQL语句\n" \
    "   - 分析调用者的参数传递方式和调用条件\n" \
    "   - 只考虑在当前调用上下文中可能执行的代码分支\n" \
    "   - 排除调用者不会触发的条件分支和执行路径\n" \
    "2. **排除调用者自身SQL**：不要包含调用者本身可能生成的SQL语句\n" \
    "   - 调用者代码中的其他数据库操作不属于分析范围\n" \
    "   - 只关注通过调用当前ORM函数产生的SQL\n" \
    "3. **排除独立执行路径**：不要包含ORM代码在没有调用者情况下的独立执行路径\n" \
    "   - 如果ORM函数有多种调用方式，只考虑当前调用者的调用方式\n" \
    "   - 排除其他潜在调用者可能触发的执行路径\n" \
    "4. **参数上下文分析**：\n" \
    "   - 分析调用者传递的具体参数类型和值范围\n" \
    "   - 根据调用者的参数确定ORM代码中的条件分支\n" \
    "   - 只生成在当前参数上下文下会执行的SQL语句\n" \
    "5. **调用链追踪**：\n" \
    "   - 追踪从调用者到ORM函数的完整调用链\n" \
    "   - 确保SQL生成路径与实际调用路径一致\n" \
    "   - 考虑调用者的业务逻辑对ORM执行的影响\n" \
    "**注意**：如果没有提供调用者信息，则按原有方式分析所有可能的SQL执行路径。\n\n" \
    "**重要：忽略注释代码约束**\n" \
    "在分析ORM代码时，请严格遵循以下原则：\n" \
    "1. **完全忽略注释代码**：\n" \
    "   - 忽略所有以//开头的单行注释中的代码\n" \
    "   - 忽略所有/* */包围的多行注释中的代码\n" \
    "   - 注释掉的代码不会在实际执行中生效，不应影响SQL生成\n" \
    "2. **注释代码识别**：\n" \
    "   - 被//注释的整行代码应完全忽略\n" \
    "   - 被/* */注释块包围的代码段应完全忽略\n" \
    "   - 行末的//注释内容应忽略，但该行其他有效代码仍需分析\n" \
    "3. **避免注释干扰**：\n" \
    "   - 注释中的SQL相关代码（如Where条件、Join操作等）不应被纳入分析\n" \
    "   - 注释中的变量赋值、条件判断等逻辑不应影响执行路径分析\n" \
    "   - 注释中的数据库操作不应生成对应的SQL语句\n" \
    "4. **焦点在有效代码**：\n" \
    "   - 只分析和处理实际会执行的、未被注释的代码行\n" \
    "   - 基于有效代码的逻辑流程生成SQL语句\n" \
    "   - 确保生成的SQL完全对应实际执行的代码路径\n" \
    "5. **示例说明**：\n" \
    "   ```go\n" \
    "   db.Where(\"status = ?\", status)  // 这行有效，需要分析\n" \
    "   // db.Where(\"deleted = ?\", false)  // 这行被注释，完全忽略\n" \
    "   /* \n" \
    "   db.Joins(\"User\").Where(\"user.active = ?\", true)  // 多行注释，完全忽略\n" \
    "   */\n" \
    "   db.Find(&result)  // 这行有效，需要分析\n" \
    "   ```\n" \
    "   在上述例子中，只应该分析第1行和最后1行的代码，生成对应的SQL。\n\n" \
    "函数名称：{function_name}\n\n" \
    "ORM代码：{code_value}\n\n" \
    "调用者：{caller}\n\n" \
    "元数据：\n{code_meta_data_str}"

CODE_ORM_MYSQL_SQL_VERIFY = \
    "请检查以下从gorm ORM代码生成的SQL语句分析是否准确，并将所有SQL语句以JSON格式返回。\n\n" \
    "**第一步：边界条件检查**\n" \
    "首先检查输入的分析结果是否包含边界条件标记：\n\n" \
    "1. **信息缺失标记处理**：\n" \
    "   - 如果分析结果包含`<LACK INFORMATION>:`标记，说明原始代码缺少某些信息但可能有推测的SQL\n" \
    "   - 检查标记格式：`<LACK INFORMATION>: 缺失信息描述 | 推测的SQL语句`\n" \
    "   - 如果包含推测的SQL，请验证推测是否合理\n" \
    "   - 检查元数据中是否确实缺少相关的表名映射、字段映射或上下文信息\n" \
    "   - 如果推测合理且信息确实缺失，返回标准格式：\n" \
    "   ```json\n" \
    "   [{{\n" \
    "     \"type\": \"LACK_INFORMATION\",\n" \
    "     \"variants\": [{{\n" \
    "       \"scenario\": \"具体缺失的信息描述\",\n" \
    "       \"sql\": \"推测的SQL语句\"\n" \
    "     }}]\n" \
    "   }}]\n" \
    "   ```\n" \
    "   - 如果标记为无法推测（`| 无法推测`），返回格式：\n" \
    "   ```json\n" \
    "   [{{\n" \
    "     \"type\": \"LACK_INFORMATION\",\n" \
    "     \"variants\": [{{\n" \
    "       \"scenario\": \"具体缺失的信息描述\",\n" \
    "       \"sql\": \"\"\n" \
    "     }}]\n" \
    "   }}]\n" \
    "   ```\n\n" \
    "2. **无SQL生成标记处理**：\n" \
    "   - 如果分析结果包含`<NO SQL GENERATE>:`标记，说明代码不会生成SQL\n" \
    "   - 请验证不生成SQL的判断是否准确\n" \
    "   - 重新检查代码是否真的没有数据库执行操作（Find、Create、Update、Delete等）\n" \
    "   - 检查是否只有查询构建方法而没有执行方法\n" \
    "   - 检查是否所有数据库操作都被注释掉了\n" \
    "   - 如果确认不生成SQL，返回标准格式：\n" \
    "   ```json\n" \
    "   [{{\n" \
    "     \"type\": \"NO_SQL_GENERATE\",\n" \
    "     \"variants\": [{{\n" \
    "       \"scenario\": \"不能生成SQL的具体原因\",\n" \
    "       \"sql\": \"\"\n" \
    "     }}]\n" \
    "   }}]\n" \
    "   ```\n\n" \
    "3. **边界条件验证规则**：\n" \
    "   - 对于信息缺失：确认是否真的缺少表名映射、字段映射或必要的上下文\n" \
    "   - 对于推测SQL：验证推测的表名、字段名和操作类型是否合理\n" \
    "   - 对于无SQL生成：确认代码是否真的没有执行方法或所有操作都被注释\n" \
    "   - 如果原始判断有误，应该重新分析并生成正确的SQL语句\n" \
    "   - 如果原始判断正确，必须按照上述标准格式返回\n\n" \
    "**第二步：正常SQL验证（仅在没有边界条件或有推测SQL时执行）**\n" \
    "如果分析结果不包含边界条件标记，或者包含LACK_INFORMATION但有推测SQL，请按以下步骤验证：\n\n" \
    "请记住，这是一个ORM代码块，它一定会生成SQL语句，不要遗漏任何可能的SQL。\n\n" \
    "请先验证SQL语句中的表名是否正确：\n" \
    "1. 表名应该按以下优先级确定：\n" \
    "   - 检查元数据(code_meta_data)中的TableName()函数返回值，该函数或者该函数对应的某个嵌套函数会显式返回表名\n" \
    "   - 其次查找config文件或配置项中的表名映射\n" \
    "   - 配置通常存在于'conf'、'config'、'setting'等文件或变量中\n" \
    "   - **重要：区分表名映射信息的来源类型：**\n" \
    "     * **映射定义类型**：通过const常量、type类型定义、映射配置文件等方式预先定义的表名映射\n" \
    "     * **直接显式类型**：在ORM代码中直接写出的表名或字段名（如Where(\"id = ? and versionId=?\")中的\"id\"和\"versionId\"）\n" \
    "     * 映射定义类型的信息具有最高优先级，应该优先使用\n" \
    "     * 直接显式类型的表名/字段名应该按原样保留，不进行任何格式转换\n" \
    "   - 如果配置中定义了表名映射，这应优先于默认命名规则使用\n" \
    "   - **表名推测规则**：如果没有找到明确的表名定义，则按以下规则推测：\n" \
    "     * 将结构体名称按照驼峰命名法拆解：AaaaaBbbbb -> aaaaa_bbbbb\n" \
    "     * **严格要求：不要私自添加s后缀进行复数化**\n" \
    "     * 例如：UserInfo -> user_info（绝不是user_infos），OrderDetail -> order_detail（绝不是order_details）\n" \
    "     * 只有在元数据中明确指定了复数表名时才使用复数形式\n" \
    "   - 最后检查代码中是否通过Table()方法显式指定了表名\n" \
    "2. 检查是否应用了表名前缀或后缀配置\n" \
    "3. 对于Delete操作，确认是否正确处理了以下情况：\n" \
    "   - 当使用`.Where().Delete(structInstance)`时，GORM会同时应用手动WHERE条件和结构体主键条件\n" \
    "   - 最终的DELETE语句应包含多个AND连接的WHERE条件\n" \
    "   - 验证是否遗漏了结构体主键字段的自动WHERE条件\n" \
    "4. **JOIN操作和表别名验证**：\n" \
    "   - 检查所有涉及JOIN的SQL语句是否正确使用了表别名\n" \
    "   - 验证SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的列名是否都带有表别名前缀\n" \
    "   - 确认ON条件使用了完整的表别名.列名格式（如：`ON t1.foreign_key = t2.primary_key`）\n" \
    "   - 检查表别名是否在整个查询中保持一致\n" \
    "   - 验证是否存在列名歧义（多个表有相同列名但没有表别名区分）\n" \
    "   - 确保生成的SQL可以被标准SQL解析器正确解析\n\n" \
    "同时，确认字段映射是否正确：\n" \
    "1. **字段名映射验证优先级**：\n" \
    "   - **最高优先级：映射定义**：结构体tag中的column标签，如`gorm:\"column:user_name\"`\n" \
    "   - **次高优先级：配置映射**：代码元数据中的字段名映射配置（const、type、配置文件等）\n" \
    "   - **中等优先级：直接显式**：代码中直接写出的字段名，如Where(\"user_id = ?\")中的\"user_id\"，必须按原样保留\n" \
    "   - **最低优先级：推测转换**：如果以上都没有，将Go字段名按驼峰拆解推测：UserName -> user_name\n" \
    "2. **重要原则：直接在SQL字符串中写出的字段名应该完全按原样使用，不进行任何转换**\n" \
    "3. **字段名验证要点**：\n" \
    "   - 检查是否错误地对显式写出的字段名进行了格式转换\n" \
    "   - 验证映射定义类型的字段名是否正确应用\n" \
    "   - 确认推测转换规则是否正确应用（仅在没有其他定义时）\n\n" \
    "具体输出要求如下：" \
    "1. 输出应该是一个SQL语句数组，其中每个元素可以是：\n" \
    "- 一个字符串：表示单一固定的SQL语句\n" \
    "- 一个对象：表示因参数不同而产生结构变化的SQL语句，包含多个场景\n" \
    "- 边界条件对象：表示信息缺失或无法生成SQL的情况\n" \
    "注意，每一个SQL语句本身应该是完整可以执行的，不能包含省略号等无关内容。\n" \
    "2. 请确保输出是有效的JSON格式，结构如下：\n" \
    "[\n" \
    " \"固定的SQL语句1\",\n" \
    " {{\n" \
    "  \"type\": \"param_dependent\",\n" \
    "  \"variants\": [\n" \
    "     {{\"scenario\": \"场景1描述\", \"sql\": \"变体SQL语句1\"}},\n" \
    "     {{\"scenario\": \"场景2描述\", \"sql\": \"变体SQL语句2\"}}\n" \
    "   ]\n" \
    " }},\n" \
    " \"固定的SQL语句2\"\n" \
    "]\n" \
    "或者对于边界条件：\n" \
    "[{{\n" \
    " \"type\": \"LACK_INFORMATION\",\n" \
    " \"variants\": [{{\"scenario\": \"缺失信息的具体描述\", \"sql\": \"推测的SQL语句\"}}]\n" \
    "}}]\n" \
    "或者：\n" \
    "[{{\n" \
    " \"type\": \"NO_SQL_GENERATE\",\n" \
    " \"variants\": [{{\"scenario\": \"不能生成SQL的具体原因\", \"sql\": \"\"}}]\n" \
    "}}]\n" \
    "3. 这种格式能够表示：\n" \
    "- 单一SQL语句：直接作为数组元素\n" \
    "- 参数依赖的SQL变体：作为带有variants字段的对象\n" \
    "- 多条SQL语句：按执行顺序排列在数组中\n" \
    "- 混合情况：数组中可以同时包含固定SQL和参数依赖的SQL\n" \
    "- 边界条件：专门的类型标记、原因说明和推测SQL\n" \
    "4. 严格要求：\n" \
    "- SQL语句必须是完整可执行的，不能包含省略号或[其他字段]等占位符\n" \
    "- 所有表的列名必须完整列出，不能省略\n" \
    "- 所有的参数必须明确指出，不能使用\"...[其他值]\"等形式\n" \
    "- 所有SQL语句必须以分号结尾\n" \
    "- 如果SQL语句中有占位符参数，应使用问号(?)或具体的示例值代替\n" \
    "5. 对于SQL变体的重要说明：\n" \
    "- 只有当SQL语句的结构发生实质性变化时，才应被视为不同的变体\n" \
    "- 结构性变化包括：不同的查询类型(SELECT/INSERT/UPDATE/DELETE)、不同的表连接方式、不同的WHERE条件列、不同的GROUP BY/ORDER BY字段等\n" \
    "- 仅仅是参数值不同但SQL结构相同的情况，应该只列出一个代表性变体\n" \
    "- 示例：'WHERE id = 1' 和 'WHERE id = 2' 不是不同的变体，而是同一变体的不同参数\n" \
    "- 示例：'WHERE id = ?' 和 'WHERE name = ?' 是结构不同的变体，因为条件列不同\n" \
    "6. 根据ORM代码分析，该函数应该生成 {sql_pattern_cnt} 条SQL语句。请确保你的输出包含正确数量的SQL语句（或SQL变体组）。\n" \
    "- 如果一个SQL语句有多个变体（因参数不同而结构不同），这仍然算作一条SQL语句\n" \
    "- 请仔细检查是否遗漏了某些SQL语句或错误地添加了不应该存在的SQL语句\n" \
    "- **注意：如果是边界条件（LACK_INFORMATION或NO_SQL_GENERATE），不需要满足sql_pattern_cnt的数量要求**\n" \
    "7. **调用者上下文验证**：如果提供了调用者信息，请验证以下内容：\n" \
    "   - 确认生成的SQL只包含由当前调用者触发的执行路径\n" \
    "   - 验证是否错误包含了调用者自身的SQL操作\n" \
    "   - 检查是否包含了与当前调用上下文无关的独立执行路径\n" \
    "   - 确认参数传递和调用条件与实际调用场景一致\n" \
    "   - 如果发现不符合调用者上下文的SQL，请将其移除\n" \
    "8. **注释代码验证**：请验证分析是否正确忽略了注释代码：\n" \
    "   - 检查是否错误地将注释中的代码纳入了SQL生成分析\n" \
    "   - 验证是否因注释代码而生成了不应存在的SQL语句\n" \
    "   - 确认所有生成的SQL都基于实际会执行的代码（非注释代码）\n" \
    "   - 检查是否被注释中的Where条件、Join操作等误导\n" \
    "   - 如果发现基于注释代码生成的SQL，请将其移除\n" \
    "9. 请确保返回的是纯JSON格式，不要添加任何解释性文本。\n" \
    "10. 如果发现原始分析中的SQL语句有错误或不完整（如含有省略号、[其他字段]等占位符），请修正并补全完整的字段列表和参数。\n\n" \
    "以下是需要检查的SQL语句分析：\n" \
    "函数定义：{function_definition}\n\n" \
    "调用者信息：{caller}\n\n" \
    "相关代码上下文：{code_chain}\n\n" \
    "SQL语句相关描述：{sql_statement}"

CODE_ORM_MYSQL_SQL_FORMAT = \
    "请将以下SQL语句分析结果格式化为标准JSON格式。\n\n" \
    "**第一步：边界条件检查**\n" \
    "首先检查输入内容是否包含边界条件标记：\n\n" \
    "1. **边界条件类型识别**：\n" \
    "   - 如果内容包含`<LACK INFORMATION>:`标记，说明信息缺失但可能有推测SQL\n" \
    "   - 检查标记格式：`<LACK INFORMATION>: 缺失信息描述 | 推测的SQL语句`\n" \
    "   - 如果内容包含`<NO SQL GENERATE>:`标记，说明无法生成SQL\n" \
    "   - 如果内容已经是标准JSON格式的边界条件，直接保持原格式\n\n" \
    "2. **边界条件格式化**：\n" \
    "   - 对于信息缺失情况（包含推测SQL），统一格式化为：\n" \
    "   ```json\n" \
    "   [{{\n" \
    "     \"type\": \"LACK_INFORMATION\",\n" \
    "     \"variants\": [{{\n" \
    "       \"scenario\": \"从原文提取的缺失信息描述\",\n" \
    "       \"sql\": \"从原文提取的推测SQL语句\"\n" \
    "     }}]\n" \
    "   }}]\n" \
    "   ```\n" \
    "   - 对于信息缺失情况（无法推测），格式化为：\n" \
    "   ```json\n" \
    "   [{{\n" \
    "     \"type\": \"LACK_INFORMATION\",\n" \
    "     \"variants\": [{{\n" \
    "       \"scenario\": \"从原文提取的缺失信息描述\",\n" \
    "       \"sql\": \"\"\n" \
    "     }}]\n" \
    "   }}]\n" \
    "   ```\n" \
    "   - 对于无法生成SQL情况，统一格式化为：\n" \
    "   ```json\n" \
    "   [{{\n" \
    "     \"type\": \"NO_SQL_GENERATE\",\n" \
    "     \"variants\": [{{\n" \
    "       \"scenario\": \"从原文提取的无法生成SQL的原因\",\n" \
    "       \"sql\": \"\"\n" \
    "     }}]\n" \
    "   }}]\n" \
    "   ```\n\n" \
    "**第二步：正常SQL格式化（仅在非边界条件时执行）**\n" \
    "如果输入内容不包含边界条件标记，按以下规则进行正常的SQL格式化：\n\n" \
    "输出要求：\n" \
    "1. 输出应该是一个SQL语句数组，其中每个元素可以是：\n" \
    "   - 一个字符串：表示单一固定的SQL语句\n" \
    "   - 一个对象：表示因参数不同而变化的SQL语句，包含多个场景\n" \
    "   - 边界条件对象：表示信息缺失或无法生成SQL的情况\n" \
    "注意，每一个SQL语句本身应该是完整可以执行的，不能包含省略号等无关内容。\n" \
    "2. JSON格式结构如下：\n" \
    "[\n" \
    " \"固定的SQL语句1\",\n" \
    " {{\n" \
    "  \"type\": \"param_dependent\",\n" \
    "  \"variants\": [\n" \
    "     {{\"scenario\": \"场景1描述\", \"sql\": \"变体SQL语句1\"}},\n" \
    "     {{\"scenario\": \"场景2描述\", \"sql\": \"变体SQL语句2\"}}\n" \
    "   ]\n" \
    " }},\n" \
    " \"固定的SQL语句2\"\n" \
    "]\n" \
    "或者对于边界条件：\n" \
    "[{{\n" \
    " \"type\": \"LACK_INFORMATION\",\n" \
    " \"variants\": [{{\"scenario\": \"缺失信息的具体描述\", \"sql\": \"推测的SQL语句\"}}]\n" \
    "}}]\n\n" \
    "或者：\n" \
    "[{{\n" \
    " \"type\": \"NO_SQL_GENERATE\",\n" \
    " \"variants\": [{{\"scenario\": \"不能生成SQL的具体原因\", \"sql\": \"\"}}]\n" \
    "}}]\n\n" \
    "3. 格式化规则：\n" \
    "   - 移除所有非SQL内容（如注释、解释或描述，以及...这种占位符）\n" \
    "   - 保持SQL语句的完整性\n" \
    "   - 所有SQL语句以分号结尾\n" \
    "   - 对于边界条件，保留原因描述和推测SQL，不要当作普通SQL处理\n" \
    "   - 返回纯JSON格式，不要添加任何解释性文本或代码块标记\n\n" \
    "4. **特殊处理规则**：\n" \
    "   - 如果输入已经是完整的JSON格式，检查格式正确性后直接返回\n" \
    "   - 如果输入混合了边界条件标记和正常SQL，按边界条件处理\n" \
    "   - 确保LACK_INFORMATION的scenario字段包含清晰的描述\n" \
    "   - 确保LACK_INFORMATION的sql字段包含推测的SQL语句（如果有）\n" \
    "   - 确保NO_SQL_GENERATE的sql字段为空字符串\n" \
    "   - 确保正常SQL不包含边界条件的标记文本\n\n" \
    "需要格式化的内容：{sql_statement}"

ANALYSIS_PROMPT_TEMPLATE = CODE_ORM_MYSQL_SQL_EXTRACT
VERIFICATION_PROMPT_TEMPLATE = CODE_ORM_MYSQL_SQL_VERIFY
FORMATTING_PROMPT_TEMPLATE = CODE_ORM_MYSQL_SQL_FORMAT
