{
  "config": {
    "data_config": {
      "dataset_dir": "model/evaluation/fingerprint_eval/temp",
      "eval_data_path": "model/evaluation/fingerprint_eval/data/eval_data.json",
      "fingerprint_cache_path": "model/evaluation/fingerprint_eval/data/cbs_528_final.pkl",
      "max_samples": null
    },
    "debug_config": {
      "save_intermediate_results": false,
      "test_mode": false,
      "test_samples": 10,
      "validate_config": true,
      "verbose_logging": true
    },
    "environment_config": {
      "bf16": true,
      "cuda_visible_devices": "0",
      "llamafactory_path": "model/training/LLaMA-Factory",
      "trust_remote_code": true
    },
    "inference_config": {
      "batch_size": 1,
      "cutoff_len": 2048,
      "generate_config": {
        "do_sample": false,
        "max_new_tokens": 512,
        "temperature": 0.1,
        "top_p": 0.9
      },
      "per_device_eval_batch_size": 1,
      "timeout": 3600
    },
    "metrics_config": {
      "detailed_metrics": [
        "sql_validity_rate",
        "sql_match_rate",
        "parse_error_rate",
        "inference_error_rate"
      ],
      "primary_metrics": [
        "inference_success_rate",
        "valid_sql_rate",
        "fingerprint_match_rate"
      ],
      "sql_type_analysis": {
        "enabled": true,
        "types": [
          "SELECT",
          "INSERT",
          "UPDATE",
          "DELETE",
          "OTHER"
        ]
      }
    },
    "model_config": {
      "finetuning_type": "full",
      "model_path": "/home/wuyu/code2sql/saves/qwen3-14b-ft-20250709_171410",
      "template": "qwen"
    },
    "output_config": {
      "keep_temp_files": false,
      "output_dir": "model/evaluation/fingerprint_eval/results",
      "result_prefix": "qwen3_evaluation",
      "save_detailed_results": true
    },
    "validation_config": {
      "enable_fingerprint_validation": true,
      "enable_syntax_validation": true,
      "excluded_sql_types": [
        "transaction_begin",
        "transaction_end",
        "session_setting",
        "show_command",
        "ddl_command",
        "empty_sql",
        "not_sql",
        "invalid_sql"
      ],
      "fingerprint_threshold": 0.8
    }
  },
  "statistics": {
    "total_samples": 114,
    "successful_inference": 114,
    "valid_sql_generated": 99,
    "fingerprint_matched": 12,
    "parse_errors": 0,
    "inference_errors": 0,
    "inference_success_rate": 1.0,
    "valid_sql_rate": 0.868421052631579,
    "fingerprint_match_rate": 0.10526315789473684,
    "parse_error_rate": 0.0,
    "inference_error_rate": 0.0,
    "total_sql_generated": 195,
    "total_valid_sql": 167,
    "total_matched_sql": 26,
    "sql_validity_rate": 0.8564102564102564,
    "sql_match_rate": 0.13333333333333333
  },
  "detailed_results": [
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/infra/event_bus/bus.go:47:59:RollbackEvents",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：RollbackEvents\nfunc (eb *EventBusDriver) RollbackEvents(ctx context.Context) *response.Result {\n\tfor _, event := range eb.BlockEventQueue {\n\t\tif event.GetState(ctx) == Executed {\n\t\t\t//result := EventHandlerMap[event.GetType(ctx)].Rollback(ctx)\n\t\t\tresult := event.GetHandler(ctx).Rollback(ctx)\n\t\t\tif result.IsFailed() {\n\t\t\t\tlogs.Info(ctx).Err(result).Int(\"EventType\", int(event.GetType(ctx))).Msg(\"rollback event failed\")\n\t\t\t\treturn result\n\t\t\t}\n\t\t}\n\t}\n\treturn response.DefaultResult()\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/infra/event_bus/bus.go\", \"code_start_line\": 61, \"code_end_line\": 79, \"code_key\": \"Execute\", \"code_value\": \"func (eb *EventBusDriver) Execute(ctx context.Context) (result *response.Result) {\\n\\tresult = response.DefaultResult()\\n\\tdefer utils.HandlePanic(ctx, &result)\\n\\n\\tfor _, event := range eb.BlockEventQueue {\\n\\t\\tresult = eb.ExecuteOne(ctx, event)\\n\\t\\tif result.IsSuccess() {\\n\\t\\t\\tevent.UpdateState(ctx, Executed)\\n\\t\\t} else {\\n\\t\\t\\tlogs.Warn(ctx).Err(result).Int(\\\"EventType\\\", int(event.GetType(ctx))).\\n\\t\\t\\t\\tMsg(\\\"event execute failed, start rollback event bus\\\")\\n\\t\\t\\tif err := eb.RollbackEvents(ctx); err != nil {\\n\\t\\t\\t\\tlogs.Error(ctx).Err(err).Int(\\\"EventType\\\", int(event.GetType(ctx))).Msg(\\\"rollback event bus failed\\\")\\n\\t\\t\\t}\\n\\t\\t\\treturn result\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/infra/event_bus/bus.go\",\n    \"code_start_line\": 47,\n    \"code_end_line\": 59,\n    \"code_key\": \"RollbackEvents\",\n    \"code_value\": \"func (eb *EventBusDriver) RollbackEvents(ctx context.Context) *response.Result {\\n\\tfor _, event := range eb.BlockEventQueue {\\n\\t\\tif event.GetState(ctx) == Executed {\\n\\t\\t\\t//result := EventHandlerMap[event.GetType(ctx)].Rollback(ctx)\\n\\t\\t\\tresult := event.GetHandler(ctx).Rollback(ctx)\\n\\t\\t\\tif result.IsFailed() {\\n\\t\\t\\t\\tlogs.Info(ctx).Err(result).Int(\\\"EventType\\\", int(event.GetType(ctx))).Msg(\\\"rollback event failed\\\")\\n\\t\\t\\t\\treturn result\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn response.DefaultResult()\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"event.GetState(ctx) == Executed时执行回滚操作\", \"sql\": \"SELECT * FROM events WHERE state = ?;\"}]}]",
      "parsed_sql": [
        "SELECT * FROM events WHERE state = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM events WHERE state = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "9cf7df546fa8f5430ba971721b9d661f",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/desdb/repos/impl/shm.go:17:28:ListRecordByStatus",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：ListRecordByStatus\nfunc (s ShmRepository) ListRecordByStatus(ctx context.Context, status repos.ShmStatus) ([]*models.Shm, error) {\n\tvar records []*models.Shm\n\ttx := s.DB.Where(\"status = ?\", status).Find(&records)\n\tif tx.Error != nil {\n\t\treturn nil, tx.Error\n\t}\n\n\tif tx.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\treturn records, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/schedule/shm.go\", \"code_start_line\": 20, \"code_end_line\": 38, \"code_key\": \"refreshShmRound\", \"code_value\": \"func (r *RefreshShmTask) refreshShmRound(ctx context.Context) error {\\n\\tshmRecords, err := app.GlobalRegistry.Repository.ShmRepo.ListRecordByStatus(ctx, repos.VALID)\\n\\tif err != nil {\\n\\t\\tlogs.Error(ctx).Err(err).Msg(\\\"FETCH_SHM_CONF_FAILED\\\")\\n\\t\\treturn err\\n\\t}\\n\\tshmCacheManager := cache.GetCacheManager(cache.ShmCache)\\n\\n\\tfor _, record := range shmRecords {\\n\\t\\terr = shmCacheManager.Set(ctx, &managers.ShmCacheKeyResolver{CacheKey: record.ConfKey}, record.ConfValue)\\n\\t\\tif err != nil {\\n\\t\\t\\tlogs.Error(ctx).Err(err).\\n\\t\\t\\t\\tStr(\\\"conf_key\\\", record.ConfKey).\\n\\t\\t\\t\\tStr(\\\"conf_value\\\", record.ConfValue).\\n\\t\\t\\t\\tMsg(\\\"REFRESH_SHM_CACHE_FAILED\\\")\\n\\t\\t}\\n\\t}\\n\\treturn err\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/desdb/repos/impl/shm.go\",\n    \"code_start_line\": 17,\n    \"code_end_line\": 28,\n    \"code_key\": \"ListRecordByStatus\",\n    \"code_value\": \"func (s ShmRepository) ListRecordByStatus(ctx context.Context, status repos.ShmStatus) ([]*models.Shm, error) {\\n\\tvar records []*models.Shm\\n\\ttx := s.DB.Where(\\\"status = ?\\\", status).Find(&records)\\n\\tif tx.Error != nil {\\n\\t\\treturn nil, tx.Error\\n\\t}\\n\\n\\tif tx.RowsAffected == 0 {\\n\\t\\treturn nil, nil\\n\\t}\\n\\treturn records, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM shm WHERE status = ?;\"]",
      "parsed_sql": [
        "SELECT * FROM shm WHERE status = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM shm WHERE status = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "e1ab489f6f5d9e41a08e158210028ffb",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/repo/impl/dmg.go:29:37:ListRecordByStatus",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：ListRecordByStatus\nfunc (d *DiskBindAffinityRepository) ListRecordByStatus(ctx context.Context, status string) []*models.DmDrgroupMembers {\n\tvar records []*models.DmDrgroupMembers\n\ttx := d.DB.Find(&records)\n\tif tx.Error != nil {\n\t\tlogs.Error(ctx).Err(tx.Error).Str(\"status\", status).Msg(\"LIST_DM_GROUP_MEMBER_FAILED\")\n\t\treturn nil\n\t}\n\treturn records\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/schedule/shm.go\", \"code_start_line\": 20, \"code_end_line\": 38, \"code_key\": \"refreshShmRound\", \"code_value\": \"func (r *RefreshShmTask) refreshShmRound(ctx context.Context) error {\\n\\tshmRecords, err := app.GlobalRegistry.Repository.ShmRepo.ListRecordByStatus(ctx, repos.VALID)\\n\\tif err != nil {\\n\\t\\tlogs.Error(ctx).Err(err).Msg(\\\"FETCH_SHM_CONF_FAILED\\\")\\n\\t\\treturn err\\n\\t}\\n\\tshmCacheManager := cache.GetCacheManager(cache.ShmCache)\\n\\n\\tfor _, record := range shmRecords {\\n\\t\\terr = shmCacheManager.Set(ctx, &managers.ShmCacheKeyResolver{CacheKey: record.ConfKey}, record.ConfValue)\\n\\t\\tif err != nil {\\n\\t\\t\\tlogs.Error(ctx).Err(err).\\n\\t\\t\\t\\tStr(\\\"conf_key\\\", record.ConfKey).\\n\\t\\t\\t\\tStr(\\\"conf_value\\\", record.ConfValue).\\n\\t\\t\\t\\tMsg(\\\"REFRESH_SHM_CACHE_FAILED\\\")\\n\\t\\t}\\n\\t}\\n\\treturn err\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/repo/impl/dmg.go\",\n    \"code_start_line\": 29,\n    \"code_end_line\": 37,\n    \"code_key\": \"ListRecordByStatus\",\n    \"code_value\": \"func (d *DiskBindAffinityRepository) ListRecordByStatus(ctx context.Context, status string) []*models.DmDrgroupMembers {\\n\\tvar records []*models.DmDrgroupMembers\\n\\ttx := d.DB.Find(&records)\\n\\tif tx.Error != nil {\\n\\t\\tlogs.Error(ctx).Err(tx.Error).Str(\\\"status\\\", status).Msg(\\\"LIST_DM_GROUP_MEMBER_FAILED\\\")\\n\\t\\treturn nil\\n\\t}\\n\\treturn records\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT id, confKey, confValue, status, createTime, updateTime, creator, modifier FROM dm_drgroup_members WHERE status = ?;\"]",
      "parsed_sql": [
        "SELECT id, confKey, confValue, status, createTime, updateTime, creator, modifier FROM dm_drgroup_members WHERE status = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT id, confKey, confValue, status, createTime, updateTime, creator, modifier FROM dm_drgroup_members WHERE status = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "bd3544f8fc585aecf5bbd0ba367b4816",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/desdb/repos/impl/rule.go:37:55:GetRulesByZone",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：GetRulesByZone\nfunc (r RuleRepository) GetRulesByZone(ctx context.Context, ruleType string, zoneId int) ([]*rule.SetRuleEntity, error) {\n\tvar records []*models.DmRule\n\tresult := r.DB.Where(\"status = ? and ruleType = ? and (zoneId IS NULL or zoneId = ?)\", rule.StatusNormal, ruleType, zoneId).Order(\"priority desc\").Find(&records)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tvar entities []*rule.SetRuleEntity\n\tfor _, record := range records {\n\t\tentity, err := r.convertModelToEntity(record, ruleType)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tentities = append(entities, entity)\n\t}\n\treturn entities, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/rule/handler/rule_filter.go\", \"code_start_line\": 15, \"code_end_line\": 18, \"code_key\": \"PackingByRule\", \"code_value\": \"func (r RuleFilterHandler) PackingByRule(ctx context.Context, setList []*set.DiskSetEntity) *rule.SetRulePackingResult {\\n\\t//TODO implement me\\n\\tpanic(\\\"implement me\\\")\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/desdb/repos/impl/rule.go\",\n    \"code_start_line\": 37,\n    \"code_end_line\": 55,\n    \"code_key\": \"GetRulesByZone\",\n    \"code_value\": \"func (r RuleRepository) GetRulesByZone(ctx context.Context, ruleType string, zoneId int) ([]*rule.SetRuleEntity, error) {\\n\\tvar records []*models.DmRule\\n\\tresult := r.DB.Where(\\\"status = ? and ruleType = ? and (zoneId IS NULL or zoneId = ?)\\\", rule.StatusNormal, ruleType, zoneId).Order(\\\"priority desc\\\").Find(&records)\\n\\tif result.Error != nil {\\n\\t\\treturn nil, result.Error\\n\\t}\\n\\tif result.RowsAffected == 0 {\\n\\t\\treturn nil, nil\\n\\t}\\n\\tvar entities []*rule.SetRuleEntity\\n\\tfor _, record := range records {\\n\\t\\tentity, err := r.convertModelToEntity(record, ruleType)\\n\\t\\tif err != nil {\\n\\t\\t\\treturn nil, err\\n\\t\\t}\\n\\t\\tentities = append(entities, entity)\\n\\t}\\n\\treturn entities, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM dm_rule WHERE status = ? AND ruleType = ? AND (zoneId IS NULL OR zoneId = ?) ORDER BY priority DESC;\"]",
      "parsed_sql": [
        "SELECT * FROM dm_rule WHERE status = ? AND ruleType = ? AND (zoneId IS NULL OR zoneId = ?) ORDER BY priority DESC;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM dm_rule WHERE status = ? AND ruleType = ? AND (zoneId IS NULL OR zoneId = ?) ORDER BY priority DESC;",
            "match_result": {
              "matched": false,
              "fingerprint": "a80e71fdb185ab199dd2176e3ac1a6cc",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/desdb/repos/impl/set.go:35:54:ListRecordsByUuid",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：ListRecordsByUuid\nfunc (setRepoImpl *SetRepository) ListRecordsByUuid(ctx context.Context, setUuids []string) ([]*set.DiskSetEntity, error) {\n\tvar records []*models.DmSet\n\tresult := setRepoImpl.DB.Where(\"setUuid in ?\", setUuids).Find(&records)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\n\tvar entities []*set.DiskSetEntity\n\tfor _, record := range records {\n\t\tentity, err := setRepoImpl.convertModelToEntity(record)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tentities = append(entities, entity)\n\t}\n\treturn entities, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/desdb/repos/impl/set.go\",\n    \"code_start_line\": 35,\n    \"code_end_line\": 54,\n    \"code_key\": \"ListRecordsByUuid\",\n    \"code_value\": \"func (setRepoImpl *SetRepository) ListRecordsByUuid(ctx context.Context, setUuids []string) ([]*set.DiskSetEntity, error) {\\n\\tvar records []*models.DmSet\\n\\tresult := setRepoImpl.DB.Where(\\\"setUuid in ?\\\", setUuids).Find(&records)\\n\\tif result.Error != nil {\\n\\t\\treturn nil, result.Error\\n\\t}\\n\\tif result.RowsAffected == 0 {\\n\\t\\treturn nil, nil\\n\\t}\\n\\n\\tvar entities []*set.DiskSetEntity\\n\\tfor _, record := range records {\\n\\t\\tentity, err := setRepoImpl.convertModelToEntity(record)\\n\\t\\tif err != nil {\\n\\t\\t\\treturn nil, err\\n\\t\\t}\\n\\t\\tentities = append(entities, entity)\\n\\t}\\n\\treturn entities, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM dm_set WHERE setUuid IN (?);\"]",
      "parsed_sql": [
        "SELECT * FROM dm_set WHERE setUuid IN (?);"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM dm_set WHERE setUuid IN (?);",
            "match_result": {
              "matched": false,
              "fingerprint": "0a7740d5a7d86525b57e84ed3e373d9d",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/desdb/repos/impl/set.go:56:75:ListNormalRecords",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：ListNormalRecords\nfunc (setRepoImpl *SetRepository) ListNormalRecords(ctx context.Context) ([]*set.DiskSetEntity, error) {\n\t// TODO: t_cbs_set_select没有对status建立索引，这里的sql会全表扫描。但是目前北上广记录都不超过2千条，所以暂时先这样\n\tvar records []*models.DmSet\n\tresult := setRepoImpl.DB.Where(\"status = ? and (forceStatus IS NULL or forceStatus != ?)\", models.SetNormal, models.SetDisable).Find(&records)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tvar entities []*set.DiskSetEntity\n\tfor _, record := range records {\n\t\tentity, err := setRepoImpl.convertModelToEntity(record)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tentities = append(entities, entity)\n\t}\n\treturn entities, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/tracker.go\", \"code_start_line\": 37, \"code_end_line\": 42, \"code_key\": \"Track\", \"code_value\": \"func (rdp *PhyDiskTracker) Track(ctx context.Context) {\\n\\t// TODO:分页查询\\n\\trdp.OriPhyDisks = app.GlobalRegistry.Repository.RDPhyRepo.ListRecordByState(ctx, int(models.PVSOnline))\\n\\trdp.DrgroupMembers = app.GlobalRegistry.Repository.DiskAffinityRepo.ListRecordByStatus(ctx, string(models.NORMAL))\\n\\tlogs.Info(ctx).Int(\\\"disk_num\\\", len(rdp.OriPhyDisks)).Msg(\\\"TRACK_PHY_DISK_FROM_META_DB\\\")\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/desdb/repos/impl/set.go\",\n    \"code_start_line\": 56,\n    \"code_end_line\": 75,\n    \"code_key\": \"ListNormalRecords\",\n    \"code_value\": \"func (setRepoImpl *SetRepository) ListNormalRecords(ctx context.Context) ([]*set.DiskSetEntity, error) {\\n\\t// TODO: t_cbs_set_select没有对status建立索引，这里的sql会全表扫描。但是目前北上广记录都不超过2千条，所以暂时先这样\\n\\tvar records []*models.DmSet\\n\\tresult := setRepoImpl.DB.Where(\\\"status = ? and (forceStatus IS NULL or forceStatus != ?)\\\", models.SetNormal, models.SetDisable).Find(&records)\\n\\tif result.Error != nil {\\n\\t\\treturn nil, result.Error\\n\\t}\\n\\tif result.RowsAffected == 0 {\\n\\t\\treturn nil, nil\\n\\t}\\n\\tvar entities []*set.DiskSetEntity\\n\\tfor _, record := range records {\\n\\t\\tentity, err := setRepoImpl.convertModelToEntity(record)\\n\\t\\tif err != nil {\\n\\t\\t\\treturn nil, err\\n\\t\\t}\\n\\t\\tentities = append(entities, entity)\\n\\t}\\n\\treturn entities, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM t_cbs_set_select WHERE status = ? AND (forceStatus IS NULL OR forceStatus != ?);\"]",
      "parsed_sql": [
        "SELECT * FROM t_cbs_set_select WHERE status = ? AND (forceStatus IS NULL OR forceStatus != ?);"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM t_cbs_set_select WHERE status = ? AND (forceStatus IS NULL OR forceStatus != ?);",
            "match_result": {
              "matched": false,
              "fingerprint": "5d513a2d6e0281e754642309c1dadcf5",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/repo/impl/phy.go:20:28:ListRecordByState",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：ListRecordByState\nfunc (phyImpl *PhysicalVolumeRepository) ListRecordByState(ctx context.Context, state int) []*models.DmPhydisk {\n\tvar records []*models.DmPhydisk\n\ttx := phyImpl.DB.Where(\"status = ?\", state).Find(&records)\n\tif tx.Error != nil {\n\t\tlogs.Error(ctx).Err(tx.Error).Int(\"state\", state).Msg(\"LIST_RECORD_BY_STATE_ERROR\")\n\t\treturn nil\n\t}\n\treturn records\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/tracker.go\", \"code_start_line\": 37, \"code_end_line\": 42, \"code_key\": \"Track\", \"code_value\": \"func (rdp *PhyDiskTracker) Track(ctx context.Context) {\\n\\t// TODO:分页查询\\n\\trdp.OriPhyDisks = app.GlobalRegistry.Repository.RDPhyRepo.ListRecordByState(ctx, int(models.PVSOnline))\\n\\trdp.DrgroupMembers = app.GlobalRegistry.Repository.DiskAffinityRepo.ListRecordByStatus(ctx, string(models.NORMAL))\\n\\tlogs.Info(ctx).Int(\\\"disk_num\\\", len(rdp.OriPhyDisks)).Msg(\\\"TRACK_PHY_DISK_FROM_META_DB\\\")\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/repo/impl/phy.go\",\n    \"code_start_line\": 20,\n    \"code_end_line\": 28,\n    \"code_key\": \"ListRecordByState\",\n    \"code_value\": \"func (phyImpl *PhysicalVolumeRepository) ListRecordByState(ctx context.Context, state int) []*models.DmPhydisk {\\n\\tvar records []*models.DmPhydisk\\n\\ttx := phyImpl.DB.Where(\\\"status = ?\\\", state).Find(&records)\\n\\tif tx.Error != nil {\\n\\t\\tlogs.Error(ctx).Err(tx.Error).Int(\\\"state\\\", state).Msg(\\\"LIST_RECORD_BY_STATE_ERROR\\\")\\n\\t\\treturn nil\\n\\t}\\n\\treturn records\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM dm_phydisk WHERE status = ?;\"]",
      "parsed_sql": [
        "SELECT * FROM dm_phydisk WHERE status = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 1,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM dm_phydisk WHERE status = ?;",
            "match_result": {
              "matched": true,
              "fingerprint": "45c56aa3ac4b336dc151a67be35ce9d6",
              "example_sql": "SELECT * FROM `dm_phydisk` WHERE 1 = 1 AND status in (1) LIMIT 10",
              "example_count": 100
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/repo/impl/phy.go:30:38:FindById",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：FindById\nfunc (phyImpl *PhysicalVolumeRepository) FindById(ctx context.Context, id common.ID) *models.DmPhydisk {\n\tvar record = models.DmPhydisk{}\n\ttx := phyImpl.DB.Find(&record, id)\n\tif tx.Error != nil {\n\t\tlogs.Error(ctx).Err(tx.Error).Uint64(\"id\", uint64(id)).Msg(\"FIND_DM_PHY_RECORD_BY_ID_ERROR\")\n\t\treturn nil\n\t}\n\treturn &record\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/repo/impl/phy.go\",\n    \"code_start_line\": 30,\n    \"code_end_line\": 38,\n    \"code_key\": \"FindById\",\n    \"code_value\": \"func (phyImpl *PhysicalVolumeRepository) FindById(ctx context.Context, id common.ID) *models.DmPhydisk {\\n\\tvar record = models.DmPhydisk{}\\n\\ttx := phyImpl.DB.Find(&record, id)\\n\\tif tx.Error != nil {\\n\\t\\tlogs.Error(ctx).Err(tx.Error).Uint64(\\\"id\\\", uint64(id)).Msg(\\\"FIND_DM_PHY_RECORD_BY_ID_ERROR\\\")\\n\\t\\treturn nil\\n\\t}\\n\\treturn &record\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM dm_phydisk WHERE id = ?;\"]",
      "parsed_sql": [
        "SELECT * FROM dm_phydisk WHERE id = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM dm_phydisk WHERE id = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "59af9384e1b10cca50a03543170f5dd0",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/repo/impl/dmg.go:19:27:FindById",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：FindById\nfunc (d *DiskBindAffinityRepository) FindById(ctx context.Context, id uint64) *models.DmDrgroupMembers {\n\trecord := models.DmDrgroupMembers{}\n\ttx := d.DB.First(&record, id)\n\tif tx.Error != nil {\n\t\tlogs.Error(ctx).Err(tx.Error).Uint64(\"id\", id).Msg(\"GET_DM_GROUP_MEMBER_FAILED\")\n\t\treturn nil\n\t}\n\treturn &record\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/repo/impl/dmg.go\",\n    \"code_start_line\": 19,\n    \"code_end_line\": 27,\n    \"code_key\": \"FindById\",\n    \"code_value\": \"func (d *DiskBindAffinityRepository) FindById(ctx context.Context, id uint64) *models.DmDrgroupMembers {\\n\\trecord := models.DmDrgroupMembers{}\\n\\ttx := d.DB.First(&record, id)\\n\\tif tx.Error != nil {\\n\\t\\tlogs.Error(ctx).Err(tx.Error).Uint64(\\\"id\\\", id).Msg(\\\"GET_DM_GROUP_MEMBER_FAILED\\\")\\n\\t\\treturn nil\\n\\t}\\n\\treturn &record\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM dm_drgroup_members WHERE id = ? LIMIT 1;\"]",
      "parsed_sql": [
        "SELECT * FROM dm_drgroup_members WHERE id = ? LIMIT 1;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM dm_drgroup_members WHERE id = ? LIMIT 1;",
            "match_result": {
              "matched": false,
              "fingerprint": "3f154ed6030a729971108c58b0d2dd7a",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/benchmark.go:32:39:Delete",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：Delete\nfunc (repo *rdiskBenchmarkRepositoryImpl) Delete(ctx context.Context, bench *benchmark.Benchmark) error {\n\tuow := getUow(ctx)\n\tresult := uow.tx.Delete(&metadb.DmRdiskBenchmark{}, \"id = ?\", bench.ID)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/expiremap.go\", \"code_start_line\": 91, \"code_end_line\": 96, \"code_key\": \"Delete\", \"code_value\": \"func (e *ExpiredMap) Delete(key interface{}) {\\n\\te.lck.Lock()\\n\\tdelete(e.m, key)\\n\\te.deleteTimeMap(key)\\n\\te.lck.Unlock()\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/benchmark.go\",\n    \"code_start_line\": 32,\n    \"code_end_line\": 39,\n    \"code_key\": \"Delete\",\n    \"code_value\": \"func (repo *rdiskBenchmarkRepositoryImpl) Delete(ctx context.Context, bench *benchmark.Benchmark) error {\\n\\tuow := getUow(ctx)\\n\\tresult := uow.tx.Delete(&metadb.DmRdiskBenchmark{}, \\\"id = ?\\\", bench.ID)\\n\\tif result.Error != nil {\\n\\t\\treturn result.Error\\n\\t}\\n\\treturn nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"DELETE FROM dm_rdisk_benchmark WHERE id = ?;\"]",
      "parsed_sql": [
        "DELETE FROM dm_rdisk_benchmark WHERE id = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "DELETE FROM dm_rdisk_benchmark WHERE id = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "caac7966ca0dcc8787203193b76ed35b",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/backup.go:34:41:Delete",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：Delete\nfunc (*rdiskBackupRepositoryImpl) Delete(ctx context.Context, backup *backupPkg.Backup) error {\n\tuow := getUow(ctx)\n\tresult := uow.tx.Delete(&metadb.DmRdiskBackup{}, \"id = ?\", backup.ID)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/expiremap.go\", \"code_start_line\": 91, \"code_end_line\": 96, \"code_key\": \"Delete\", \"code_value\": \"func (e *ExpiredMap) Delete(key interface{}) {\\n\\te.lck.Lock()\\n\\tdelete(e.m, key)\\n\\te.deleteTimeMap(key)\\n\\te.lck.Unlock()\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/backup.go\",\n    \"code_start_line\": 34,\n    \"code_end_line\": 41,\n    \"code_key\": \"Delete\",\n    \"code_value\": \"func (*rdiskBackupRepositoryImpl) Delete(ctx context.Context, backup *backupPkg.Backup) error {\\n\\tuow := getUow(ctx)\\n\\tresult := uow.tx.Delete(&metadb.DmRdiskBackup{}, \\\"id = ?\\\", backup.ID)\\n\\tif result.Error != nil {\\n\\t\\treturn result.Error\\n\\t}\\n\\treturn nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"DELETE FROM dm_rdisk_backup WHERE id = ?;\"]",
      "parsed_sql": [
        "DELETE FROM dm_rdisk_backup WHERE id = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "DELETE FROM dm_rdisk_backup WHERE id = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "d10b3bc4048ae34d2dc86461120bffe5",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go:73:81:Delete",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：Delete\nfunc (p *physicalVolumeRepositoryImpl) Delete(ctx context.Context, pv *rdiskDomain.PhysicalVolume) error {\n\tuow := getUow(ctx)\n\tidt := pv.GetID()\n\tresult := uow.tx.Where(\"id = ?\", idt).Delete(&metadb.DmPhydisk{})\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/expiremap.go\", \"code_start_line\": 91, \"code_end_line\": 96, \"code_key\": \"Delete\", \"code_value\": \"func (e *ExpiredMap) Delete(key interface{}) {\\n\\te.lck.Lock()\\n\\tdelete(e.m, key)\\n\\te.deleteTimeMap(key)\\n\\te.lck.Unlock()\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go\",\n    \"code_start_line\": 73,\n    \"code_end_line\": 81,\n    \"code_key\": \"Delete\",\n    \"code_value\": \"func (p *physicalVolumeRepositoryImpl) Delete(ctx context.Context, pv *rdiskDomain.PhysicalVolume) error {\\n\\tuow := getUow(ctx)\\n\\tidt := pv.GetID()\\n\\tresult := uow.tx.Where(\\\"id = ?\\\", idt).Delete(&metadb.DmPhydisk{})\\n\\tif result.Error != nil {\\n\\t\\treturn result.Error\\n\\t}\\n\\treturn nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"DELETE FROM dm_phydisk WHERE id = ?;\"]",
      "parsed_sql": [
        "DELETE FROM dm_phydisk WHERE id = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "DELETE FROM dm_phydisk WHERE id = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "a7b9b4041d62209320d8c161b16af42b",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go:111:122:Delete",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：Delete\nfunc (d drgroupRepositoryImpl) Delete(ctx context.Context, group *drgroup.DRGroup) error {\n\tuow := getUow(ctx)\n\tresult := uow.tx.Delete(&metadb.DmDrgroup{}, \"id = ?\", group.ID)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tresult = uow.tx.Delete(&metadb.DmDrgroupMembers{}, \"app_id = ? and group_name = ?\", group.AppID, group.Name)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/expiremap.go\", \"code_start_line\": 91, \"code_end_line\": 96, \"code_key\": \"Delete\", \"code_value\": \"func (e *ExpiredMap) Delete(key interface{}) {\\n\\te.lck.Lock()\\n\\tdelete(e.m, key)\\n\\te.deleteTimeMap(key)\\n\\te.lck.Unlock()\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go\",\n    \"code_start_line\": 111,\n    \"code_end_line\": 122,\n    \"code_key\": \"Delete\",\n    \"code_value\": \"func (d drgroupRepositoryImpl) Delete(ctx context.Context, group *drgroup.DRGroup) error {\\n\\tuow := getUow(ctx)\\n\\tresult := uow.tx.Delete(&metadb.DmDrgroup{}, \\\"id = ?\\\", group.ID)\\n\\tif result.Error != nil {\\n\\t\\treturn result.Error\\n\\t}\\n\\tresult = uow.tx.Delete(&metadb.DmDrgroupMembers{}, \\\"app_id = ? and group_name = ?\\\", group.AppID, group.Name)\\n\\tif result.Error != nil {\\n\\t\\treturn result.Error\\n\\t}\\n\\treturn nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"DELETE FROM dm_drgroup WHERE id = ?;\", \"DELETE FROM dm_drgroup_members WHERE app_id = ? AND group_name = ?;\"]",
      "parsed_sql": [
        "DELETE FROM dm_drgroup WHERE id = ?;",
        "DELETE FROM dm_drgroup_members WHERE app_id = ? AND group_name = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 2,
        "valid_sql": 2,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "DELETE FROM dm_drgroup WHERE id = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "7fbf615020bc554bc723188c1326685a",
              "excluded": false
            }
          },
          {
            "sql": "DELETE FROM dm_drgroup_members WHERE app_id = ? AND group_name = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "b8047912a3cd89f0d4c85bc7f56ae7bb",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/expiremap.go:98:100:Remove",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：Remove\nfunc (e *ExpiredMap) Remove(key interface{}) {\n\te.Delete(key)\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/schedule/subgroup.go\", \"code_start_line\": 92, \"code_end_line\": 116, \"code_key\": \"tryCleanExpiredDisks\", \"code_value\": \"func (s SubGroupCleanTask) tryCleanExpiredDisks(ctx context.Context) error {\\n\\tstart := time.Now()\\n\\tfor _, key := range s.cacheManager.ListExpiredKeys(ctx) {\\n\\t\\tlogs.Info(ctx).Str(\\\"sub_group\\\", key.(string)).Msg(\\\"FIND_EXPIRED_SUB_GROUP_POOL\\\")\\n\\t\\tresolver := cache.SubGroupCacheKeyResolver{}.WithKey(ctx, key.(string))\\n\\t\\tdisks, err := s.cacheManager.Acquire(ctx, resolver)\\n\\t\\tif err != nil {\\n\\t\\t\\treturn err\\n\\t\\t}\\n\\t\\tif disks == nil {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\ts.RecycleDisk(ctx, disks.([]*disk.Disk))\\n\\t\\terr = s.cacheManager.Remove(ctx, resolver)\\n\\t\\tif err != nil {\\n\\t\\t\\treturn err\\n\\t\\t}\\n\\t}\\n\\n\\tcost := time.Since(start)\\n\\n\\tlogs.Info(ctx).Int(\\\"cost\\\", int(cost)).Msg(\\\"RUN_TASK_ONE_ROUND_COST\\\")\\n\\n\\treturn nil\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/expiremap.go\",\n    \"code_start_line\": 98,\n    \"code_end_line\": 100,\n    \"code_key\": \"Remove\",\n    \"code_value\": \"func (e *ExpiredMap) Remove(key interface{}) {\\n\\te.Delete(key)\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"DELETE FROM expired_map WHERE key = ?;\"]",
      "parsed_sql": [
        "DELETE FROM expired_map WHERE key = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 0,
        "matched_sql": 0,
        "excluded_sql": 1,
        "fingerprint_results": [
          {
            "sql": "DELETE FROM expired_map WHERE key = ?;",
            "match_result": {
              "matched": false,
              "excluded": true,
              "fingerprint": "invalid_sql",
              "excluded_reason": "排除的SQL类型"
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/managers/shm.go:51:54:Remove",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：Remove\nfunc (s *ShmCacheManager) Remove(ctx context.Context, keyResolver cache.GeneralCacheKeyResolverInf) error {\n\ts.m.Delete(keyResolver.GenerateKey(ctx))\n\treturn nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/schedule/subgroup.go\", \"code_start_line\": 92, \"code_end_line\": 116, \"code_key\": \"tryCleanExpiredDisks\", \"code_value\": \"func (s SubGroupCleanTask) tryCleanExpiredDisks(ctx context.Context) error {\\n\\tstart := time.Now()\\n\\tfor _, key := range s.cacheManager.ListExpiredKeys(ctx) {\\n\\t\\tlogs.Info(ctx).Str(\\\"sub_group\\\", key.(string)).Msg(\\\"FIND_EXPIRED_SUB_GROUP_POOL\\\")\\n\\t\\tresolver := cache.SubGroupCacheKeyResolver{}.WithKey(ctx, key.(string))\\n\\t\\tdisks, err := s.cacheManager.Acquire(ctx, resolver)\\n\\t\\tif err != nil {\\n\\t\\t\\treturn err\\n\\t\\t}\\n\\t\\tif disks == nil {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\ts.RecycleDisk(ctx, disks.([]*disk.Disk))\\n\\t\\terr = s.cacheManager.Remove(ctx, resolver)\\n\\t\\tif err != nil {\\n\\t\\t\\treturn err\\n\\t\\t}\\n\\t}\\n\\n\\tcost := time.Since(start)\\n\\n\\tlogs.Info(ctx).Int(\\\"cost\\\", int(cost)).Msg(\\\"RUN_TASK_ONE_ROUND_COST\\\")\\n\\n\\treturn nil\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/managers/shm.go\",\n    \"code_start_line\": 51,\n    \"code_end_line\": 54,\n    \"code_key\": \"Remove\",\n    \"code_value\": \"func (s *ShmCacheManager) Remove(ctx context.Context, keyResolver cache.GeneralCacheKeyResolverInf) error {\\n\\ts.m.Delete(keyResolver.GenerateKey(ctx))\\n\\treturn nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"DELETE FROM cache WHERE key = ?;\"]",
      "parsed_sql": [
        "DELETE FROM cache WHERE key = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 0,
        "matched_sql": 0,
        "excluded_sql": 1,
        "fingerprint_results": [
          {
            "sql": "DELETE FROM cache WHERE key = ?;",
            "match_result": {
              "matched": false,
              "excluded": true,
              "fingerprint": "invalid_sql",
              "excluded_reason": "排除的SQL类型"
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/subgroup.go:78:82:Remove",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：Remove\nfunc (s *SubGroupCacheManager) Remove(ctx context.Context, keyResolver cache.GeneralCacheKeyResolverInf) error {\n\tcacheKey := keyResolver.GenerateKey(ctx)\n\ts.cacheMap.Delete(cacheKey)\n\treturn nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/schedule/subgroup.go\", \"code_start_line\": 92, \"code_end_line\": 116, \"code_key\": \"tryCleanExpiredDisks\", \"code_value\": \"func (s SubGroupCleanTask) tryCleanExpiredDisks(ctx context.Context) error {\\n\\tstart := time.Now()\\n\\tfor _, key := range s.cacheManager.ListExpiredKeys(ctx) {\\n\\t\\tlogs.Info(ctx).Str(\\\"sub_group\\\", key.(string)).Msg(\\\"FIND_EXPIRED_SUB_GROUP_POOL\\\")\\n\\t\\tresolver := cache.SubGroupCacheKeyResolver{}.WithKey(ctx, key.(string))\\n\\t\\tdisks, err := s.cacheManager.Acquire(ctx, resolver)\\n\\t\\tif err != nil {\\n\\t\\t\\treturn err\\n\\t\\t}\\n\\t\\tif disks == nil {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\ts.RecycleDisk(ctx, disks.([]*disk.Disk))\\n\\t\\terr = s.cacheManager.Remove(ctx, resolver)\\n\\t\\tif err != nil {\\n\\t\\t\\treturn err\\n\\t\\t}\\n\\t}\\n\\n\\tcost := time.Since(start)\\n\\n\\tlogs.Info(ctx).Int(\\\"cost\\\", int(cost)).Msg(\\\"RUN_TASK_ONE_ROUND_COST\\\")\\n\\n\\treturn nil\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/subgroup.go\",\n    \"code_start_line\": 78,\n    \"code_end_line\": 82,\n    \"code_key\": \"Remove\",\n    \"code_value\": \"func (s *SubGroupCacheManager) Remove(ctx context.Context, keyResolver cache.GeneralCacheKeyResolverInf) error {\\n\\tcacheKey := keyResolver.GenerateKey(ctx)\\n\\ts.cacheMap.Delete(cacheKey)\\n\\treturn nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM users WHERE status = 'active';\", {\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"按用户ID查询\", \"sql\": \"SELECT * FROM users WHERE id = ?;\"}, {\"scenario\": \"按用户名查询\", \"sql\": \"SELECT * FROM users WHERE username = ?;\"}]}]",
      "parsed_sql": [
        "SELECT * FROM users WHERE status = 'active';",
        "SELECT * FROM users WHERE id = ?;",
        "SELECT * FROM users WHERE username = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 3,
        "valid_sql": 3,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM users WHERE status = 'active';",
            "match_result": {
              "matched": false,
              "fingerprint": "330325e915b95eba361b58db8d26741c",
              "excluded": false
            }
          },
          {
            "sql": "SELECT * FROM users WHERE id = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "de9db2d948496f93e45a219c374dbe6d",
              "excluded": false
            }
          },
          {
            "sql": "SELECT * FROM users WHERE username = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "04e7be3825a0e67a84996a7303d69f06",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/subgroup.go:104:117:Pop",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：Pop\nfunc (s *SubGroupCacheManager) Pop(ctx context.Context, keyResolver cache.GeneralCacheKeyResolverInf) (interface{}, error) {\n\tcacheKey := keyResolver.GenerateKey(ctx)\n\tif ok, disks := s.cacheMap.Get(cacheKey); ok {\n\t\tniceDisks := disks.([]*disk.Disk)\n\t\toneDisk := niceDisks[0]\n\t\tif len(niceDisks) > 1 {\n\t\t\ts.cacheMap.Set(cacheKey, niceDisks[1:], s.expiredSeconds)\n\t\t} else {\n\t\t\ts.cacheMap.Delete(cacheKey)\n\t\t}\n\t\treturn oneDisk, nil\n\t}\n\treturn nil, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/managers/shm.go\", \"code_start_line\": 82, \"code_end_line\": 84, \"code_key\": \"Pop\", \"code_value\": \"func (s *ShmCacheManager) Pop(ctx context.Context, keyResolver cache.GeneralCacheKeyResolverInf) (interface{}, error) {\\n\\tpanic(\\\"implement me\\\")\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/subgroup.go\",\n    \"code_start_line\": 104,\n    \"code_end_line\": 117,\n    \"code_key\": \"Pop\",\n    \"code_value\": \"func (s *SubGroupCacheManager) Pop(ctx context.Context, keyResolver cache.GeneralCacheKeyResolverInf) (interface{}, error) {\\n\\tcacheKey := keyResolver.GenerateKey(ctx)\\n\\tif ok, disks := s.cacheMap.Get(cacheKey); ok {\\n\\t\\tniceDisks := disks.([]*disk.Disk)\\n\\t\\toneDisk := niceDisks[0]\\n\\t\\tif len(niceDisks) > 1 {\\n\\t\\t\\ts.cacheMap.Set(cacheKey, niceDisks[1:], s.expiredSeconds)\\n\\t\\t} else {\\n\\t\\t\\ts.cacheMap.Delete(cacheKey)\\n\\t\\t}\\n\\t\\treturn oneDisk, nil\\n\\t}\\n\\treturn nil, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"当cacheMap中存在指定cacheKey且disks切片长度大于1时\", \"sql\": \"SELECT * FROM disk WHERE id = ?;\"}, {\"scenario\": \"当cacheMap中存在指定cacheKey且disks切片长度等于1时\", \"sql\": \"SELECT * FROM disk WHERE id = ?;\"}]}]",
      "parsed_sql": [
        "SELECT * FROM disk WHERE id = ?;",
        "SELECT * FROM disk WHERE id = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 2,
        "valid_sql": 2,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM disk WHERE id = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "a2bb6550a5009f996543b9795e1f2b52",
              "excluded": false
            }
          },
          {
            "sql": "SELECT * FROM disk WHERE id = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "a2bb6550a5009f996543b9795e1f2b52",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go:644:674:Refresh",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：Refresh\nfunc (l *mysqlLock) Refresh(ctx context.Context, ttl time.Duration) error {\n\n\ttx := l.locker.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\n\n\tkeysKey := dlock.LockKeySlice(l.keys).GetKeys()\n\t// NOCA:QCloudAkCheck(误报)\n\texistingLocks, err := l.locker.fetchExistingLocksByKeysAndTokens(tx, keysKey, l.tokens)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn err\n\t}\n\n\t// Compare existing locks with the keys.\n\tif !checkStrSetEqual(existingLocks, keysKey) {\n\t\t_ = tx.Rollback()\n\t\treturn errors.Wrap(dlock.ErrLockNotHeld, \"lock is not held\")\n\t}\n\n\t// Update the expiration time.\n\tif err := l.locker.updateLocksTTLByKeysAndTokens(tx, keysKey, l.tokens, ttl); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn err\n\t}\n\n\tif result := tx.Commit(); result.Error != nil {\n\t\treturn errors.Wrap(result.Error, \"failed to commit refresh locks\")\n\t}\n\n\tl.expiration = time.Now().Add(ttl)\n\treturn nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/schedule/subgroup.go\", \"code_start_line\": 118, \"code_end_line\": 131, \"code_key\": \"Run\", \"code_value\": \"func (s SubGroupCleanTask) Run(ctx context.Context) error {\\n\\ts.cacheManager = app.GlobalRegistry.CacheContainer.GetCacheManager(CacheDomain.SubGroupCache)\\n\\tfor {\\n\\t\\tselect {\\n\\t\\tcase <-ctx.Done():\\n\\t\\t\\treturn nil\\n\\t\\tcase <-time.After(time.Duration(s.intervalSeconds) * time.Second):\\n\\t\\t\\terr := s.tryCleanExpiredDisks(ctx)\\n\\t\\t\\tif err != nil {\\n\\t\\t\\t\\treturn err\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go\",\n    \"code_start_line\": 644,\n    \"code_end_line\": 674,\n    \"code_key\": \"Refresh\",\n    \"code_value\": \"func (l *mysqlLock) Refresh(ctx context.Context, ttl time.Duration) error {\\n\\n\\ttx := l.locker.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\\n\\n\\tkeysKey := dlock.LockKeySlice(l.keys).GetKeys()\\n\\t// NOCA:QCloudAkCheck(误报)\\n\\texistingLocks, err := l.locker.fetchExistingLocksByKeysAndTokens(tx, keysKey, l.tokens)\\n\\tif err != nil {\\n\\t\\t_ = tx.Rollback()\\n\\t\\treturn err\\n\\t}\\n\\n\\t// Compare existing locks with the keys.\\n\\tif !checkStrSetEqual(existingLocks, keysKey) {\\n\\t\\t_ = tx.Rollback()\\n\\t\\treturn errors.Wrap(dlock.ErrLockNotHeld, \\\"lock is not held\\\")\\n\\t}\\n\\n\\t// Update the expiration time.\\n\\tif err := l.locker.updateLocksTTLByKeysAndTokens(tx, keysKey, l.tokens, ttl); err != nil {\\n\\t\\t_ = tx.Rollback()\\n\\t\\treturn err\\n\\t}\\n\\n\\tif result := tx.Commit(); result.Error != nil {\\n\\t\\treturn errors.Wrap(result.Error, \\\"failed to commit refresh locks\\\")\\n\\t}\\n\\n\\tl.expiration = time.Now().Add(ttl)\\n\\treturn nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"正常执行路径（所有检查都通过）\", \"sql\": \"COMMIT;\"}, {\"scenario\": \"fetchExistingLocksByKeysAndTokens失败\", \"sql\": \"ROLLBACK;\"}, {\"scenario\": \"锁检查失败（checkStrSetEqual返回false）\", \"sql\": \"ROLLBACK;\"}, {\"scenario\": \"更新锁TTL失败\", \"sql\": \"ROLLBACK;\"}]}]",
      "parsed_sql": [
        "COMMIT;",
        "ROLLBACK;",
        "ROLLBACK;",
        "ROLLBACK;"
      ],
      "sql_evaluation": {
        "total_sql": 4,
        "valid_sql": 0,
        "matched_sql": 0,
        "excluded_sql": 4,
        "fingerprint_results": [
          {
            "sql": "COMMIT;",
            "match_result": {
              "matched": false,
              "excluded": true,
              "fingerprint": "transaction_end",
              "excluded_reason": "排除的SQL类型"
            }
          },
          {
            "sql": "ROLLBACK;",
            "match_result": {
              "matched": false,
              "excluded": true,
              "fingerprint": "transaction_end",
              "excluded_reason": "排除的SQL类型"
            }
          },
          {
            "sql": "ROLLBACK;",
            "match_result": {
              "matched": false,
              "excluded": true,
              "fingerprint": "transaction_end",
              "excluded_reason": "排除的SQL类型"
            }
          },
          {
            "sql": "ROLLBACK;",
            "match_result": {
              "matched": false,
              "excluded": true,
              "fingerprint": "transaction_end",
              "excluded_reason": "排除的SQL类型"
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/uow.go:83:90:Rollback",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：Rollback\nfunc (u *unitOfWork) Rollback(ctx context.Context) error {\n\tu.trackedPhyVolumes.items = make(map[uint64]*rdiskDomain.PhysicalVolume)\n\tu.trackedLogicalVolumes.items = make(map[uint64]*rdiskDomain.LogicalVolume)\n\tu.trackedDRGroups.items = make(map[uint64]*drgroup.DRGroup)\n\tu.trackedBackups.items = make(map[uint64]*backup.Backup)\n\tu.trackedBenchmarks.items = make(map[uint64]*benchmark.Benchmark)\n\treturn u.tx.Rollback().Error\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/infra/event_bus/bus.go\", \"code_start_line\": 47, \"code_end_line\": 59, \"code_key\": \"RollbackEvents\", \"code_value\": \"func (eb *EventBusDriver) RollbackEvents(ctx context.Context) *response.Result {\\n\\tfor _, event := range eb.BlockEventQueue {\\n\\t\\tif event.GetState(ctx) == Executed {\\n\\t\\t\\t//result := EventHandlerMap[event.GetType(ctx)].Rollback(ctx)\\n\\t\\t\\tresult := event.GetHandler(ctx).Rollback(ctx)\\n\\t\\t\\tif result.IsFailed() {\\n\\t\\t\\t\\tlogs.Info(ctx).Err(result).Int(\\\"EventType\\\", int(event.GetType(ctx))).Msg(\\\"rollback event failed\\\")\\n\\t\\t\\t\\treturn result\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn response.DefaultResult()\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/uow.go\",\n    \"code_start_line\": 83,\n    \"code_end_line\": 90,\n    \"code_key\": \"Rollback\",\n    \"code_value\": \"func (u *unitOfWork) Rollback(ctx context.Context) error {\\n\\tu.trackedPhyVolumes.items = make(map[uint64]*rdiskDomain.PhysicalVolume)\\n\\tu.trackedLogicalVolumes.items = make(map[uint64]*rdiskDomain.LogicalVolume)\\n\\tu.trackedDRGroups.items = make(map[uint64]*drgroup.DRGroup)\\n\\tu.trackedBackups.items = make(map[uint64]*backup.Backup)\\n\\tu.trackedBenchmarks.items = make(map[uint64]*benchmark.Benchmark)\\n\\treturn u.tx.Rollback().Error\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"ROLLBACK;\"]",
      "parsed_sql": [
        "ROLLBACK;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 0,
        "matched_sql": 0,
        "excluded_sql": 1,
        "fingerprint_results": [
          {
            "sql": "ROLLBACK;",
            "match_result": {
              "matched": false,
              "excluded": true,
              "fingerprint": "transaction_end",
              "excluded_reason": "排除的SQL类型"
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_benchmark_task.go:32:57:Handle",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：Handle\nfunc (c *DeleteBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\terr       error\n\t)\n\n\tbench, err := benchRepo.FindByUUID(ctx, c.BenchmarkUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif bench.DiskInfo.Serial != c.Serial {\n\t\treturn errors.Newf(benchmark.ErrTaskNotFound, \"benchmark serial not match %s, want %s\", c.Serial, bench.DiskInfo.Serial)\n\t}\n\n\t_, err = benchSm.Fire(ctx, bench.Status, benchmark.EventDeleteBench, benchmark.Data{Benchmark: bench, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := benchRepo.Delete(ctx, bench); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/cmd/run.go\", \"code_start_line\": 84, \"code_end_line\": 109, \"code_key\": \"initApiServer\", \"code_value\": \"func initApiServer() {\\n\\tglobalCfg := registry.GlobalRegistry.AppConfig.Global\\n\\n\\trouter := mux.NewRouter()\\n\\tserver := &http.Server{\\n\\t\\tAddr:    fmt.Sprintf(\\\"0.0.0.0:%d\\\", globalCfg.PprofPort),\\n\\t\\tHandler: router,\\n\\t}\\n\\t// Prometheus\\n\\trouter.Handle(\\\"/metrics\\\", promhttp.Handler())\\n\\n\\t// pprof\\n\\trouter.HandleFunc(\\\"/debug/pprof/\\\", pprof.Index)\\n\\trouter.HandleFunc(\\\"/debug/pprof/cmdline\\\", pprof.Cmdline)\\n\\trouter.HandleFunc(\\\"/debug/pprof/profile\\\", pprof.Profile)\\n\\trouter.HandleFunc(\\\"/debug/pprof/symbol\\\", pprof.Symbol)\\n\\trouter.HandleFunc(\\\"/debug/pprof/trace\\\", pprof.Trace)\\n\\n\\t// init k8s liveness readness probe\\n\\trouter.HandleFunc(\\\"/live\\\", k8sProbe)\\n\\trouter.HandleFunc(\\\"/ready\\\", k8sProbe)\\n\\n\\tgo func() {\\n\\t\\tfmt.Println(server.ListenAndServe())\\n\\t}()\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_benchmark_task.go\",\n    \"code_start_line\": 32,\n    \"code_end_line\": 57,\n    \"code_key\": \"Handle\",\n    \"code_value\": \"func (c *DeleteBenchmarkCommand) Handle(ctx context.Context) error {\\n\\tvar (\\n\\t\\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\\n\\t\\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\\n\\t\\terr       error\\n\\t)\\n\\n\\tbench, err := benchRepo.FindByUUID(ctx, c.BenchmarkUUID)\\n\\tif err != nil {\\n\\t\\treturn err\\n\\t}\\n\\tif bench.DiskInfo.Serial != c.Serial {\\n\\t\\treturn errors.Newf(benchmark.ErrTaskNotFound, \\\"benchmark serial not match %s, want %s\\\", c.Serial, bench.DiskInfo.Serial)\\n\\t}\\n\\n\\t_, err = benchSm.Fire(ctx, bench.Status, benchmark.EventDeleteBench, benchmark.Data{Benchmark: bench, Delegate: &benchmarkDelegate{cmd: c}})\\n\\tif err != nil {\\n\\t\\treturn err\\n\\t}\\n\\n\\tif err := benchRepo.Delete(ctx, bench); err != nil {\\n\\t\\treturn err\\n\\t}\\n\\n\\treturn nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM benchmark WHERE uuid = ?;\", \"DELETE FROM benchmark WHERE id = ?;\"]",
      "parsed_sql": [
        "SELECT * FROM benchmark WHERE uuid = ?;",
        "DELETE FROM benchmark WHERE id = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 2,
        "valid_sql": 2,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM benchmark WHERE uuid = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "82623360cfca68b05830dc56403bc018",
              "excluded": false
            }
          },
          {
            "sql": "DELETE FROM benchmark WHERE id = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "758e0486c1cdc22102d55e90c4dff1e5",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/user/repo.go:18:29:GetUserCtlRecord",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：GetUserCtlRecord\nfunc (repo *UserRepo) GetUserCtlRecord(ctx context.Context, appId int64) (*des.TCbsUserControl, error) {\n\tvar userCtl des.TCbsUserControl\n\tresult := repo.DB.Where(\"appId = ?\", appId).First(&userCtl)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\n\treturn &userCtl, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/entity.go\", \"code_start_line\": 35, \"code_end_line\": 37, \"code_key\": \"GetUser\", \"code_value\": \"func (a *AffinityEntity) GetUser(ctx context.Context) *account.User {\\n\\treturn a.user\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/consumer_srv/domain/user/repo.go\",\n    \"code_start_line\": 18,\n    \"code_end_line\": 29,\n    \"code_key\": \"GetUserCtlRecord\",\n    \"code_value\": \"func (repo *UserRepo) GetUserCtlRecord(ctx context.Context, appId int64) (*des.TCbsUserControl, error) {\\n\\tvar userCtl des.TCbsUserControl\\n\\tresult := repo.DB.Where(\\\"appId = ?\\\", appId).First(&userCtl)\\n\\tif result.Error != nil {\\n\\t\\treturn nil, result.Error\\n\\t}\\n\\tif result.RowsAffected == 0 {\\n\\t\\treturn nil, nil\\n\\t}\\n\\n\\treturn &userCtl, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM tCbsUserControl WHERE appId = ? LIMIT 1;\"]",
      "parsed_sql": [
        "SELECT * FROM tCbsUserControl WHERE appId = ? LIMIT 1;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM tCbsUserControl WHERE appId = ? LIMIT 1;",
            "match_result": {
              "matched": false,
              "fingerprint": "d4c1fc1858b778bc8c1276b00c547a3b",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/user.go:15:31:GetUserCtlRecord",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：GetUserCtlRecord\nfunc (repo *UserRepo) GetUserCtlRecord(ctx context.Context, appId int64) (*des.TCbsUserControl, error) {\n\tdb, err := repo.getDesDb(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar userCtl des.TCbsUserControl\n\tresult := db.Where(\"appId = ?\", appId).First(&userCtl)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\n\treturn &userCtl, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/entity.go\", \"code_start_line\": 35, \"code_end_line\": 37, \"code_key\": \"GetUser\", \"code_value\": \"func (a *AffinityEntity) GetUser(ctx context.Context) *account.User {\\n\\treturn a.user\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/user.go\",\n    \"code_start_line\": 15,\n    \"code_end_line\": 31,\n    \"code_key\": \"GetUserCtlRecord\",\n    \"code_value\": \"func (repo *UserRepo) GetUserCtlRecord(ctx context.Context, appId int64) (*des.TCbsUserControl, error) {\\n\\tdb, err := repo.getDesDb(ctx)\\n\\tif err != nil {\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\tvar userCtl des.TCbsUserControl\\n\\tresult := db.Where(\\\"appId = ?\\\", appId).First(&userCtl)\\n\\tif result.Error != nil {\\n\\t\\treturn nil, result.Error\\n\\t}\\n\\tif result.RowsAffected == 0 {\\n\\t\\treturn nil, nil\\n\\t}\\n\\n\\treturn &userCtl, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM tCbsUserControl WHERE appId = ? LIMIT 1;\"]",
      "parsed_sql": [
        "SELECT * FROM tCbsUserControl WHERE appId = ? LIMIT 1;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM tCbsUserControl WHERE appId = ? LIMIT 1;",
            "match_result": {
              "matched": false,
              "fingerprint": "d4c1fc1858b778bc8c1276b00c547a3b",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/user/repo.go:31:41:GetUserArea",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：GetUserArea\nfunc (repo *UserRepo) GetUserArea(ctx context.Context, appId int64) (string, error) {\n\tvar userCtl des.TCbsUserControl\n\tresult := repo.DB.Select(\"area\").Where(\"appId = ?\", appId).First(&userCtl)\n\tif result.Error != nil {\n\t\treturn \"\", result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn \"\", nil\n\t}\n\treturn userCtl.Area, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/consumer_srv/domain/user/repo.go\",\n    \"code_start_line\": 31,\n    \"code_end_line\": 41,\n    \"code_key\": \"GetUserArea\",\n    \"code_value\": \"func (repo *UserRepo) GetUserArea(ctx context.Context, appId int64) (string, error) {\\n\\tvar userCtl des.TCbsUserControl\\n\\tresult := repo.DB.Select(\\\"area\\\").Where(\\\"appId = ?\\\", appId).First(&userCtl)\\n\\tif result.Error != nil {\\n\\t\\treturn \\\"\\\", result.Error\\n\\t}\\n\\tif result.RowsAffected == 0 {\\n\\t\\treturn \\\"\\\", nil\\n\\t}\\n\\treturn userCtl.Area, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT area FROM t_cbs_user_control WHERE appId = ? LIMIT 1;\"]",
      "parsed_sql": [
        "SELECT area FROM t_cbs_user_control WHERE appId = ? LIMIT 1;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT area FROM t_cbs_user_control WHERE appId = ? LIMIT 1;",
            "match_result": {
              "matched": false,
              "fingerprint": "e935d0bc1ce77a72e7cfb54eb55f5b75",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/user.go:33:48:GetUserArea",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：GetUserArea\nfunc (repo *UserRepo) GetUserArea(ctx context.Context, appId int64) (string, error) {\n\tdb, err := repo.getDesDb(ctx)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tvar userCtl des.TCbsUserControl\n\tresult := db.Select(\"area\").Where(\"appId = ?\", appId).First(&userCtl)\n\tif result.Error != nil {\n\t\treturn \"\", result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn \"\", nil\n\t}\n\treturn userCtl.Area, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/user.go\",\n    \"code_start_line\": 33,\n    \"code_end_line\": 48,\n    \"code_key\": \"GetUserArea\",\n    \"code_value\": \"func (repo *UserRepo) GetUserArea(ctx context.Context, appId int64) (string, error) {\\n\\tdb, err := repo.getDesDb(ctx)\\n\\tif err != nil {\\n\\t\\treturn \\\"\\\", err\\n\\t}\\n\\n\\tvar userCtl des.TCbsUserControl\\n\\tresult := db.Select(\\\"area\\\").Where(\\\"appId = ?\\\", appId).First(&userCtl)\\n\\tif result.Error != nil {\\n\\t\\treturn \\\"\\\", result.Error\\n\\t}\\n\\tif result.RowsAffected == 0 {\\n\\t\\treturn \\\"\\\", nil\\n\\t}\\n\\treturn userCtl.Area, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT area FROM t_cbs_user_control WHERE appId = ? LIMIT 1;\"]",
      "parsed_sql": [
        "SELECT area FROM t_cbs_user_control WHERE appId = ? LIMIT 1;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT area FROM t_cbs_user_control WHERE appId = ? LIMIT 1;",
            "match_result": {
              "matched": false,
              "fingerprint": "e935d0bc1ce77a72e7cfb54eb55f5b75",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/repositories/cbs.go:22:32:QueryDiskInfoById",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：QueryDiskInfoById\nfunc (cbsRepo *CbsBalanceRepo) QueryDiskInfoById(ctx context.Context, id string) (*ccdb.CCbs, error) {\n\tvar disk ccdb.CCbs\n\n\tresult := cbsRepo.DB.Where(\"cbsInstanceId = ?\", id).Find(&disk)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t} else if result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\treturn &disk, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/service.go\", \"code_start_line\": 369, \"code_end_line\": 434, \"code_key\": \"processSingleBalanceRecords\", \"code_value\": \"func (cbsSrv *CbsSrv) processSingleBalanceRecords(chargeItem *ChargeItem, beginBalanceRecord *ccdb.CCbsBalance, endBalanceRecord *ccdb.CCbsBalance, user *user.User, resourceId ResourceId) (stopCharge bool) {\\n\\tstopCharge = false\\n\\t// 资源欠费，不收取费用\\n\\tif beginBalanceRecord.OperationType == int(CbsOpArrearage) {\\n\\t\\tlogs.Info(cbsSrv.ctx).Uint64(\\\"appId\\\", uint64(user.AppId)).Str(\\\"resourceId\\\", string(resourceId)).Msg(\\\"RESOURCE_ARREARAGE\\\")\\n\\t\\treturn\\n\\t}\\n\\t// 资源退还。判断是否为预付费的性能突发场景\\n\\tif beginBalanceRecord.OperationType == int(CbsOpReturn) || beginBalanceRecord.OperationType == int(CbsOpConvert) {\\n\\t\\t// 判断是否为预付费的性能突发场景.\\n\\t\\t// 获取云盘信息。这里在循环中进行查询，但命中的应该不会很多，放在外层反而会导致每个云盘都被查询\\n\\t\\tdisk, err := cbsSrv.diskRepo.QueryDiskInfoById(cbsSrv.ctx, string(resourceId))\\n\\t\\tif err != nil || disk == nil {\\n\\t\\t\\tlogs.Error(cbsSrv.ctx).Err(err).Str(\\\"resourceId\\\", string(resourceId)).Msg(\\\"QUERY_CBS_RECORD_FAILED\\\")\\n\\t\\t\\t// TODO 这里先不返回资源的推量？\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\t// TODO 走diskLogical\\n\\t\\tif disk.PayMode == \\\"prepay\\\" {\\n\\t\\t\\t// 性能突发场景，预付费用户退盘，退盘费用不计\\n\\t\\t\\tlogs.Info(cbsSrv.ctx).Uint64(\\\"appId\\\", uint64(user.AppId)).Str(\\\"resourceId\\\", string(resourceId)).Msg(\\\"MAYBE_CBS_WITH_BURST_PERFORMANCE\\\")\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tlogs.Info(cbsSrv.ctx).Uint64(\\\"appId\\\", uint64(user.AppId)).Str(\\\"resourceId\\\", string(resourceId)).Msg(\\\"CBS_HAS_RETURNED\\\")\\n\\t\\treturn true\\n\\t}\\n\\n\\t// 资源正常\\n\\tstartTime := beginBalanceRecord.LastBalanceTime\\n\\tendTime := endBalanceRecord.LastBalanceTime\\n\\tcurTime := startTime\\n\\tfor endTime.After(curTime) {\\n\\t\\tcurHourEnd := time.Date(curTime.Year(), curTime.Month(), curTime.Day(), curTime.Hour(), 59, 59, 0, curTime.Location())\\n\\n\\t\\tvar config CCbsBalanceConfig\\n\\t\\terr := json.Unmarshal([]byte(beginBalanceRecord.Config), &config)\\n\\t\\tif err != nil {\\n\\t\\t\\tlogs.Error(cbsSrv.ctx).Err(err).Msg(\\\"PARSE_CONFIG_ERROR\\\")\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tcurEndTime := endTime\\n\\t\\tcurStarTime := curTime\\n\\t\\tif !endTime.After(curHourEnd) {\\n\\t\\t\\t// 同一周期\\n\\t\\t\\tcurTime = endTime.Add(time.Second)\\n\\t\\t} else {\\n\\t\\t\\tcurEndTime = curHourEnd\\n\\t\\t\\tcurTime = curHourEnd.Add(time.Second)\\n\\t\\t}\\n\\t\\tsubItem := &SubItem{\\n\\t\\t\\tPid:       beginBalanceRecord.Pid,\\n\\t\\t\\tStartTime: curStarTime,\\n\\t\\t\\tEndTime:   curEndTime,\\n\\t\\t\\tProjectId: beginBalanceRecord.ProjectID,\\n\\t\\t\\tParams:    beginBalanceRecord.ResourceInfo,\\n\\t\\t\\tSubValueDetail: map[string]interface{}{\\n\\t\\t\\t\\t// FIXME 性能突发场景待实现\\n\\t\\t\\t\\t\\\"Size\\\":             config.Size,\\n\\t\\t\\t\\t\\\"BackupPointQuota\\\": config.BackupPointQuota,\\n\\t\\t\\t},\\n\\t\\t}\\n\\t\\tchargeItem.Items = append(chargeItem.Items, subItem)\\n\\t}\\n\\treturn\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/repositories/cbs.go\",\n    \"code_start_line\": 22,\n    \"code_end_line\": 32,\n    \"code_key\": \"QueryDiskInfoById\",\n    \"code_value\": \"func (cbsRepo *CbsBalanceRepo) QueryDiskInfoById(ctx context.Context, id string) (*ccdb.CCbs, error) {\\n\\tvar disk ccdb.CCbs\\n\\n\\tresult := cbsRepo.DB.Where(\\\"cbsInstanceId = ?\\\", id).Find(&disk)\\n\\tif result.Error != nil {\\n\\t\\treturn nil, result.Error\\n\\t} else if result.RowsAffected == 0 {\\n\\t\\treturn nil, nil\\n\\t}\\n\\treturn &disk, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM cCbs WHERE cbsInstanceId = ?;\"]",
      "parsed_sql": [
        "SELECT * FROM cCbs WHERE cbsInstanceId = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM cCbs WHERE cbsInstanceId = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "3f3755e631c2fa2f1a9553984da2bab4",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/disk.go:15:29:QueryDiskInfoById",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：QueryDiskInfoById\nfunc (d *DiskRepo) QueryDiskInfoById(ctx context.Context, id string) (*ccdb.CCbs, error) {\n\tvar disk ccdb.CCbs\n\n\tdb, err := d.getCCDBDb(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresult := db.Where(\"cbsInstanceId = ?\", id).Find(&disk)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t} else if result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\treturn &disk, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/service.go\", \"code_start_line\": 369, \"code_end_line\": 434, \"code_key\": \"processSingleBalanceRecords\", \"code_value\": \"func (cbsSrv *CbsSrv) processSingleBalanceRecords(chargeItem *ChargeItem, beginBalanceRecord *ccdb.CCbsBalance, endBalanceRecord *ccdb.CCbsBalance, user *user.User, resourceId ResourceId) (stopCharge bool) {\\n\\tstopCharge = false\\n\\t// 资源欠费，不收取费用\\n\\tif beginBalanceRecord.OperationType == int(CbsOpArrearage) {\\n\\t\\tlogs.Info(cbsSrv.ctx).Uint64(\\\"appId\\\", uint64(user.AppId)).Str(\\\"resourceId\\\", string(resourceId)).Msg(\\\"RESOURCE_ARREARAGE\\\")\\n\\t\\treturn\\n\\t}\\n\\t// 资源退还。判断是否为预付费的性能突发场景\\n\\tif beginBalanceRecord.OperationType == int(CbsOpReturn) || beginBalanceRecord.OperationType == int(CbsOpConvert) {\\n\\t\\t// 判断是否为预付费的性能突发场景.\\n\\t\\t// 获取云盘信息。这里在循环中进行查询，但命中的应该不会很多，放在外层反而会导致每个云盘都被查询\\n\\t\\tdisk, err := cbsSrv.diskRepo.QueryDiskInfoById(cbsSrv.ctx, string(resourceId))\\n\\t\\tif err != nil || disk == nil {\\n\\t\\t\\tlogs.Error(cbsSrv.ctx).Err(err).Str(\\\"resourceId\\\", string(resourceId)).Msg(\\\"QUERY_CBS_RECORD_FAILED\\\")\\n\\t\\t\\t// TODO 这里先不返回资源的推量？\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\t// TODO 走diskLogical\\n\\t\\tif disk.PayMode == \\\"prepay\\\" {\\n\\t\\t\\t// 性能突发场景，预付费用户退盘，退盘费用不计\\n\\t\\t\\tlogs.Info(cbsSrv.ctx).Uint64(\\\"appId\\\", uint64(user.AppId)).Str(\\\"resourceId\\\", string(resourceId)).Msg(\\\"MAYBE_CBS_WITH_BURST_PERFORMANCE\\\")\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tlogs.Info(cbsSrv.ctx).Uint64(\\\"appId\\\", uint64(user.AppId)).Str(\\\"resourceId\\\", string(resourceId)).Msg(\\\"CBS_HAS_RETURNED\\\")\\n\\t\\treturn true\\n\\t}\\n\\n\\t// 资源正常\\n\\tstartTime := beginBalanceRecord.LastBalanceTime\\n\\tendTime := endBalanceRecord.LastBalanceTime\\n\\tcurTime := startTime\\n\\tfor endTime.After(curTime) {\\n\\t\\tcurHourEnd := time.Date(curTime.Year(), curTime.Month(), curTime.Day(), curTime.Hour(), 59, 59, 0, curTime.Location())\\n\\n\\t\\tvar config CCbsBalanceConfig\\n\\t\\terr := json.Unmarshal([]byte(beginBalanceRecord.Config), &config)\\n\\t\\tif err != nil {\\n\\t\\t\\tlogs.Error(cbsSrv.ctx).Err(err).Msg(\\\"PARSE_CONFIG_ERROR\\\")\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tcurEndTime := endTime\\n\\t\\tcurStarTime := curTime\\n\\t\\tif !endTime.After(curHourEnd) {\\n\\t\\t\\t// 同一周期\\n\\t\\t\\tcurTime = endTime.Add(time.Second)\\n\\t\\t} else {\\n\\t\\t\\tcurEndTime = curHourEnd\\n\\t\\t\\tcurTime = curHourEnd.Add(time.Second)\\n\\t\\t}\\n\\t\\tsubItem := &SubItem{\\n\\t\\t\\tPid:       beginBalanceRecord.Pid,\\n\\t\\t\\tStartTime: curStarTime,\\n\\t\\t\\tEndTime:   curEndTime,\\n\\t\\t\\tProjectId: beginBalanceRecord.ProjectID,\\n\\t\\t\\tParams:    beginBalanceRecord.ResourceInfo,\\n\\t\\t\\tSubValueDetail: map[string]interface{}{\\n\\t\\t\\t\\t// FIXME 性能突发场景待实现\\n\\t\\t\\t\\t\\\"Size\\\":             config.Size,\\n\\t\\t\\t\\t\\\"BackupPointQuota\\\": config.BackupPointQuota,\\n\\t\\t\\t},\\n\\t\\t}\\n\\t\\tchargeItem.Items = append(chargeItem.Items, subItem)\\n\\t}\\n\\treturn\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/disk.go\",\n    \"code_start_line\": 15,\n    \"code_end_line\": 29,\n    \"code_key\": \"QueryDiskInfoById\",\n    \"code_value\": \"func (d *DiskRepo) QueryDiskInfoById(ctx context.Context, id string) (*ccdb.CCbs, error) {\\n\\tvar disk ccdb.CCbs\\n\\n\\tdb, err := d.getCCDBDb(ctx)\\n\\tif err != nil {\\n\\t\\treturn nil, err\\n\\t}\\n\\tresult := db.Where(\\\"cbsInstanceId = ?\\\", id).Find(&disk)\\n\\tif result.Error != nil {\\n\\t\\treturn nil, result.Error\\n\\t} else if result.RowsAffected == 0 {\\n\\t\\treturn nil, nil\\n\\t}\\n\\treturn &disk, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM cCbs WHERE cbsInstanceId = ?;\"]",
      "parsed_sql": [
        "SELECT * FROM cCbs WHERE cbsInstanceId = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM cCbs WHERE cbsInstanceId = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "3f3755e631c2fa2f1a9553984da2bab4",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/repositories/cbs.go:39:50:GetCbsBalanceRecords",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：GetCbsBalanceRecords\nfunc (cbsRepo *CbsBalanceRepo) GetCbsBalanceRecords(ctx context.Context, resourceId string, chargeTime time.Time, includeInvalidRecord bool) ([]*ccdb.CCbsBalance, error) {\n\n\tvar cCbsBalances []*ccdb.CCbsBalance\n\tvar query *gorm.DB\n\tif !includeInvalidRecord {\n\t\tquery = cbsRepo.DB.Where(\"resourceId = ? and lastBalanceTime < ? and status = 1\", resourceId, chargeTime)\n\t} else {\n\t\tquery = cbsRepo.DB.Where(\"resourceId = ?\", resourceId)\n\t}\n\tquery.Find(&cCbsBalances)\n\treturn cCbsBalances, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/service.go\", \"code_start_line\": 208, \"code_end_line\": 217, \"code_key\": \"BuildResChargeItem\", \"code_value\": \"func (cbsSrv *CbsSrv) BuildResChargeItem(u *user.User, resourceId ResourceId, chargeTime time.Time) *ChargeItem {\\n\\tcbsMeasureRepo := cbsSrv.balanceRepo.(repositories.CbsBalanceRepoIFace)\\n\\tbalanceRecords, _ := cbsMeasureRepo.GetCbsBalanceRecords(cbsSrv.ctx, string(resourceId), chargeTime, false)\\n\\n\\tif len(balanceRecords) == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\n\\treturn cbsSrv.convertToChargeItem(u, resourceId, balanceRecords, chargeTime)\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/repositories/cbs.go\",\n    \"code_start_line\": 39,\n    \"code_end_line\": 50,\n    \"code_key\": \"GetCbsBalanceRecords\",\n    \"code_value\": \"func (cbsRepo *CbsBalanceRepo) GetCbsBalanceRecords(ctx context.Context, resourceId string, chargeTime time.Time, includeInvalidRecord bool) ([]*ccdb.CCbsBalance, error) {\\n\\n\\tvar cCbsBalances []*ccdb.CCbsBalance\\n\\tvar query *gorm.DB\\n\\tif !includeInvalidRecord {\\n\\t\\tquery = cbsRepo.DB.Where(\\\"resourceId = ? and lastBalanceTime < ? and status = 1\\\", resourceId, chargeTime)\\n\\t} else {\\n\\t\\tquery = cbsRepo.DB.Where(\\\"resourceId = ?\\\", resourceId)\\n\\t}\\n\\tquery.Find(&cCbsBalances)\\n\\treturn cCbsBalances, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM cCbsBalance WHERE resourceId = ? AND lastBalanceTime < ? AND status = 1;\"]",
      "parsed_sql": [
        "SELECT * FROM cCbsBalance WHERE resourceId = ? AND lastBalanceTime < ? AND status = 1;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM cCbsBalance WHERE resourceId = ? AND lastBalanceTime < ? AND status = 1;",
            "match_result": {
              "matched": false,
              "fingerprint": "123f420705df985d089ce96310d0469a",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/measure.go:188:203:GetCbsBalanceRecords",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：GetCbsBalanceRecords\nfunc (cbsRepo *CbsMeasureRepo) GetCbsBalanceRecords(ctx context.Context, resourceId string, chargeTime time.Time, includeInvalidRecord bool) ([]*ccdb.CCbsBalance, error) {\n\tdb, err := cbsRepo.getCCDBDb(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar cCbsBalances []*ccdb.CCbsBalance\n\tvar query *gorm.DB\n\tif !includeInvalidRecord {\n\t\tquery = db.Where(\"resourceId = ? and lastBalanceTime < ? and status = 1\", resourceId, chargeTime)\n\t} else {\n\t\tquery = db.Where(\"resourceId = ?\", resourceId)\n\t}\n\tquery.Find(&cCbsBalances)\n\treturn cCbsBalances, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/service.go\", \"code_start_line\": 208, \"code_end_line\": 217, \"code_key\": \"BuildResChargeItem\", \"code_value\": \"func (cbsSrv *CbsSrv) BuildResChargeItem(u *user.User, resourceId ResourceId, chargeTime time.Time) *ChargeItem {\\n\\tcbsMeasureRepo := cbsSrv.balanceRepo.(repositories.CbsBalanceRepoIFace)\\n\\tbalanceRecords, _ := cbsMeasureRepo.GetCbsBalanceRecords(cbsSrv.ctx, string(resourceId), chargeTime, false)\\n\\n\\tif len(balanceRecords) == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\n\\treturn cbsSrv.convertToChargeItem(u, resourceId, balanceRecords, chargeTime)\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/measure.go\",\n    \"code_start_line\": 188,\n    \"code_end_line\": 203,\n    \"code_key\": \"GetCbsBalanceRecords\",\n    \"code_value\": \"func (cbsRepo *CbsMeasureRepo) GetCbsBalanceRecords(ctx context.Context, resourceId string, chargeTime time.Time, includeInvalidRecord bool) ([]*ccdb.CCbsBalance, error) {\\n\\tdb, err := cbsRepo.getCCDBDb(ctx)\\n\\tif err != nil {\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\tvar cCbsBalances []*ccdb.CCbsBalance\\n\\tvar query *gorm.DB\\n\\tif !includeInvalidRecord {\\n\\t\\tquery = db.Where(\\\"resourceId = ? and lastBalanceTime < ? and status = 1\\\", resourceId, chargeTime)\\n\\t} else {\\n\\t\\tquery = db.Where(\\\"resourceId = ?\\\", resourceId)\\n\\t}\\n\\tquery.Find(&cCbsBalances)\\n\\treturn cCbsBalances, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM cCbsBalance WHERE resourceId = ? AND lastBalanceTime < ? AND status = 1;\"]",
      "parsed_sql": [
        "SELECT * FROM cCbsBalance WHERE resourceId = ? AND lastBalanceTime < ? AND status = 1;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM cCbsBalance WHERE resourceId = ? AND lastBalanceTime < ? AND status = 1;",
            "match_result": {
              "matched": false,
              "fingerprint": "123f420705df985d089ce96310d0469a",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/repositories/base.go:33:46:GetResourceIdsByAppId",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：GetResourceIdsByAppId\nfunc (repo *BalanceRepo) GetResourceIdsByAppId(ctx context.Context, appId int64, chargeTime time.Time, includeInvalidRes bool, tableName string) ([]string, error) {\n\t// includeInvalidRes为true时，返回所有资源, 目前用在补量场景\n\tvar resourceIds []string\n\t// FIXME 这里是获取到已经被python更新过的balance，临时兼容使用\n\tquery := repo.DB.Table(tableName).Distinct(\"resourceId\")\n\tif !includeInvalidRes {\n\t\tquery = query.Where(\"appId = ? and status = 1 and lastBalanceTime <= ? \", appId, chargeTime)\n\t} else {\n\t\tquery = query.Where(\"appId = ?\", appId)\n\t}\n\tquery.Pluck(\"resourceId\", &resourceIds)\n\n\treturn resourceIds, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/service.go\", \"code_start_line\": 71, \"code_end_line\": 78, \"code_key\": \"GetValidResourceIdsByAppId\", \"code_value\": \"func (srv *BaseResSrv) GetValidResourceIdsByAppId(appId user.AppId, chargeTime time.Time) []ResourceId {\\n\\tids, _ := srv.balanceRepo.GetResourceIdsByAppId(srv.ctx, int64(appId), chargeTime, false, srv.balanceRepo.GetBalanceTableName())\\n\\tredIds := make([]ResourceId, len(ids))\\n\\tfor i, resId := range ids {\\n\\t\\tredIds[i] = ResourceId(resId)\\n\\t}\\n\\treturn redIds\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/repositories/base.go\",\n    \"code_start_line\": 33,\n    \"code_end_line\": 46,\n    \"code_key\": \"GetResourceIdsByAppId\",\n    \"code_value\": \"func (repo *BalanceRepo) GetResourceIdsByAppId(ctx context.Context, appId int64, chargeTime time.Time, includeInvalidRes bool, tableName string) ([]string, error) {\\n\\t// includeInvalidRes为true时，返回所有资源, 目前用在补量场景\\n\\tvar resourceIds []string\\n\\t// FIXME 这里是获取到已经被python更新过的balance，临时兼容使用\\n\\tquery := repo.DB.Table(tableName).Distinct(\\\"resourceId\\\")\\n\\tif !includeInvalidRes {\\n\\t\\tquery = query.Where(\\\"appId = ? and status = 1 and lastBalanceTime <= ? \\\", appId, chargeTime)\\n\\t} else {\\n\\t\\tquery = query.Where(\\\"appId = ?\\\", appId)\\n\\t}\\n\\tquery.Pluck(\\\"resourceId\\\", &resourceIds)\\n\\n\\treturn resourceIds, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"includeInvalidRes is false\", \"sql\": \"SELECT DISTINCT resourceId FROM ? WHERE appId = ? and status = 1 and lastBalanceTime <= ?;\"}, {\"scenario\": \"includeInvalidRes is true\", \"sql\": \"SELECT DISTINCT resourceId FROM ? WHERE appId = ?;\"}]}]",
      "parsed_sql": [
        "SELECT DISTINCT resourceId FROM ? WHERE appId = ? and status = 1 and lastBalanceTime <= ?;",
        "SELECT DISTINCT resourceId FROM ? WHERE appId = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 2,
        "valid_sql": 2,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT DISTINCT resourceId FROM ? WHERE appId = ? and status = 1 and lastBalanceTime <= ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "35fc57712e806a1dd6587753f74bb89b",
              "excluded": false
            }
          },
          {
            "sql": "SELECT DISTINCT resourceId FROM ? WHERE appId = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "3e65459f1cdb5835daf313c0b45bcc2e",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/measure.go:46:64:GetResourceIdsByAppId",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：GetResourceIdsByAppId\nfunc (repo *MeasureRepo) GetResourceIdsByAppId(ctx context.Context, appId int64, chargeTime time.Time, includeInvalidRes bool, tableName string) ([]string, error) {\n\t// includeInvalidRes为true时，返回所有资源, 目前用在补量场景\n\tdb, err := repo.getCCDBDb(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar resourceIds []string\n\t// FIXME 这里是获取到已经被python更新过的balance，临时兼容使用\n\tquery := db.Table(tableName).Distinct(\"resourceId\")\n\tif !includeInvalidRes {\n\t\tquery = query.Where(\"appId = ? and status = 1 and lastBalanceTime <= ? \", appId, chargeTime)\n\t} else {\n\t\tquery = query.Where(\"appId = ?\", appId)\n\t}\n\tquery.Pluck(\"resourceId\", &resourceIds)\n\n\treturn resourceIds, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/service.go\", \"code_start_line\": 71, \"code_end_line\": 78, \"code_key\": \"GetValidResourceIdsByAppId\", \"code_value\": \"func (srv *BaseResSrv) GetValidResourceIdsByAppId(appId user.AppId, chargeTime time.Time) []ResourceId {\\n\\tids, _ := srv.balanceRepo.GetResourceIdsByAppId(srv.ctx, int64(appId), chargeTime, false, srv.balanceRepo.GetBalanceTableName())\\n\\tredIds := make([]ResourceId, len(ids))\\n\\tfor i, resId := range ids {\\n\\t\\tredIds[i] = ResourceId(resId)\\n\\t}\\n\\treturn redIds\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/measure.go\",\n    \"code_start_line\": 46,\n    \"code_end_line\": 64,\n    \"code_key\": \"GetResourceIdsByAppId\",\n    \"code_value\": \"func (repo *MeasureRepo) GetResourceIdsByAppId(ctx context.Context, appId int64, chargeTime time.Time, includeInvalidRes bool, tableName string) ([]string, error) {\\n\\t// includeInvalidRes为true时，返回所有资源, 目前用在补量场景\\n\\tdb, err := repo.getCCDBDb(ctx)\\n\\tif err != nil {\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\tvar resourceIds []string\\n\\t// FIXME 这里是获取到已经被python更新过的balance，临时兼容使用\\n\\tquery := db.Table(tableName).Distinct(\\\"resourceId\\\")\\n\\tif !includeInvalidRes {\\n\\t\\tquery = query.Where(\\\"appId = ? and status = 1 and lastBalanceTime <= ? \\\", appId, chargeTime)\\n\\t} else {\\n\\t\\tquery = query.Where(\\\"appId = ?\\\", appId)\\n\\t}\\n\\tquery.Pluck(\\\"resourceId\\\", &resourceIds)\\n\\n\\treturn resourceIds, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"includeInvalidRes is false\", \"sql\": \"SELECT DISTINCT resourceId FROM ? WHERE appId = ? and status = 1 and lastBalanceTime <= ?;\"}, {\"scenario\": \"includeInvalidRes is true\", \"sql\": \"SELECT DISTINCT resourceId FROM ? WHERE appId = ?;\"}]}]",
      "parsed_sql": [
        "SELECT DISTINCT resourceId FROM ? WHERE appId = ? and status = 1 and lastBalanceTime <= ?;",
        "SELECT DISTINCT resourceId FROM ? WHERE appId = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 2,
        "valid_sql": 2,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT DISTINCT resourceId FROM ? WHERE appId = ? and status = 1 and lastBalanceTime <= ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "35fc57712e806a1dd6587753f74bb89b",
              "excluded": false
            }
          },
          {
            "sql": "SELECT DISTINCT resourceId FROM ? WHERE appId = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "3e65459f1cdb5835daf313c0b45bcc2e",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/repositories/base.go:48:65:UpdateResBalanceRecord",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：UpdateResBalanceRecord\nfunc (repo *BalanceRepo) UpdateResBalanceRecord(ctx context.Context, appId int64, resourceId string, balanceUpdateDetails []*BalanceUpdateDetail, tableName string) error {\n\terr := repo.DB.Transaction(func(tx *gorm.DB) error {\n\t\tfor _, detail := range balanceUpdateDetails {\n\t\t\tupdateKVs := map[string]interface{}{\n\t\t\t\t\"status\":          detail.Status,\n\t\t\t\t\"lastBalanceTime\": detail.LastBalanceTime,\n\t\t\t}\n\t\t\tresult := tx.Table(tableName).\n\t\t\t\tWhere(\"appId = ? and resourceId = ? and id = ?\", appId, resourceId, detail.BalanceId).\n\t\t\t\tUpdates(updateKVs)\n\t\t\tif result.Error != nil {\n\t\t\t\treturn result.Error\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\treturn err\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/service.go\", \"code_start_line\": 436, \"code_end_line\": 466, \"code_key\": \"UpdateResBalanceRecords\", \"code_value\": \"func (cbsSrv *CbsSrv) UpdateResBalanceRecords(appId user.AppId, chargeItem *ChargeItem) error {\\n\\n\\tlogs.Info(cbsSrv.ctx).Uint64(\\\"appId\\\", uint64(appId)).\\n\\t\\tStr(\\\"resourceId\\\", string(chargeItem.ResourceId)).Msg(\\\"UPDATE_CBS_BALANCE_RECORD\\\")\\n\\n\\tvar err error\\n\\tdetails := make([]*repositories.BalanceUpdateDetail, 0)\\n\\tfor _, updateKV := range chargeItem.UpdateKVs {\\n\\t\\tdetails = append(details, &repositories.BalanceUpdateDetail{\\n\\t\\t\\tBalanceId:       updateKV.Id,\\n\\t\\t\\tStatus:          updateKV.Status,\\n\\t\\t\\tLastBalanceTime: updateKV.LastBalanceTime,\\n\\t\\t})\\n\\n\\t}\\n\\n\\terr = cbsSrv.balanceRepo.UpdateResBalanceRecord(\\n\\t\\tcbsSrv.ctx,\\n\\t\\tint64(appId),\\n\\t\\tstring(chargeItem.ResourceId),\\n\\t\\tdetails,\\n\\t\\tcbsSrv.balanceRepo.GetBalanceTableName(),\\n\\t)\\n\\n\\tif err != nil {\\n\\t\\tlogs.Error(cbsSrv.ctx).Err(err).Uint64(\\\"appId\\\", uint64(chargeItem.AppId)).\\n\\t\\t\\tStr(\\\"resourceId\\\", string(chargeItem.ResourceId)).Msg(\\\"UPDATE_CBS_BALANCE_RECORD_FAILED\\\")\\n\\t}\\n\\n\\treturn err\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/repositories/base.go\",\n    \"code_start_line\": 48,\n    \"code_end_line\": 65,\n    \"code_key\": \"UpdateResBalanceRecord\",\n    \"code_value\": \"func (repo *BalanceRepo) UpdateResBalanceRecord(ctx context.Context, appId int64, resourceId string, balanceUpdateDetails []*BalanceUpdateDetail, tableName string) error {\\n\\terr := repo.DB.Transaction(func(tx *gorm.DB) error {\\n\\t\\tfor _, detail := range balanceUpdateDetails {\\n\\t\\t\\tupdateKVs := map[string]interface{}{\\n\\t\\t\\t\\t\\\"status\\\":          detail.Status,\\n\\t\\t\\t\\t\\\"lastBalanceTime\\\": detail.LastBalanceTime,\\n\\t\\t\\t}\\n\\t\\t\\tresult := tx.Table(tableName).\\n\\t\\t\\t\\tWhere(\\\"appId = ? and resourceId = ? and id = ?\\\", appId, resourceId, detail.BalanceId).\\n\\t\\t\\t\\tUpdates(updateKVs)\\n\\t\\t\\tif result.Error != nil {\\n\\t\\t\\t\\treturn result.Error\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn nil\\n\\t})\\n\\treturn err\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"Update balance record in transaction\", \"sql\": \"BEGIN; UPDATE ? SET status = ?, lastBalanceTime = ? WHERE appId = ? AND resourceId = ? AND id = ?; COMMIT;\"}]}]",
      "parsed_sql": [
        "BEGIN; UPDATE ? SET status = ?, lastBalanceTime = ? WHERE appId = ? AND resourceId = ? AND id = ?; COMMIT;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "BEGIN; UPDATE ? SET status = ?, lastBalanceTime = ? WHERE appId = ? AND resourceId = ? AND id = ?; COMMIT;",
            "match_result": {
              "matched": false,
              "fingerprint": "ef1e57557dab0c6c086e72c8ffbf1dae",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/measure.go:82:104:UpdateResBalanceRecord",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：UpdateResBalanceRecord\nfunc (repo *MeasureRepo) UpdateResBalanceRecord(ctx context.Context, appId int64, resourceId string, balanceUpdateDetails []*measure.BalanceUpdateDetail, tableName string) error {\n\tdb, err := repo.getCCDBDb(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = db.Transaction(func(tx *gorm.DB) error {\n\t\tfor _, detail := range balanceUpdateDetails {\n\t\t\tupdateKVs := map[string]interface{}{\n\t\t\t\t\"status\":          detail.Status,\n\t\t\t\t\"lastBalanceTime\": detail.LastBalanceTime,\n\t\t\t}\n\t\t\tresult := tx.Table(tableName).\n\t\t\t\tWhere(\"appId = ? and resourceId = ? and id = ?\", appId, resourceId, detail.BalanceId).\n\t\t\t\tUpdates(updateKVs)\n\t\t\tif result.Error != nil {\n\t\t\t\treturn result.Error\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\treturn err\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/service.go\", \"code_start_line\": 436, \"code_end_line\": 466, \"code_key\": \"UpdateResBalanceRecords\", \"code_value\": \"func (cbsSrv *CbsSrv) UpdateResBalanceRecords(appId user.AppId, chargeItem *ChargeItem) error {\\n\\n\\tlogs.Info(cbsSrv.ctx).Uint64(\\\"appId\\\", uint64(appId)).\\n\\t\\tStr(\\\"resourceId\\\", string(chargeItem.ResourceId)).Msg(\\\"UPDATE_CBS_BALANCE_RECORD\\\")\\n\\n\\tvar err error\\n\\tdetails := make([]*repositories.BalanceUpdateDetail, 0)\\n\\tfor _, updateKV := range chargeItem.UpdateKVs {\\n\\t\\tdetails = append(details, &repositories.BalanceUpdateDetail{\\n\\t\\t\\tBalanceId:       updateKV.Id,\\n\\t\\t\\tStatus:          updateKV.Status,\\n\\t\\t\\tLastBalanceTime: updateKV.LastBalanceTime,\\n\\t\\t})\\n\\n\\t}\\n\\n\\terr = cbsSrv.balanceRepo.UpdateResBalanceRecord(\\n\\t\\tcbsSrv.ctx,\\n\\t\\tint64(appId),\\n\\t\\tstring(chargeItem.ResourceId),\\n\\t\\tdetails,\\n\\t\\tcbsSrv.balanceRepo.GetBalanceTableName(),\\n\\t)\\n\\n\\tif err != nil {\\n\\t\\tlogs.Error(cbsSrv.ctx).Err(err).Uint64(\\\"appId\\\", uint64(chargeItem.AppId)).\\n\\t\\t\\tStr(\\\"resourceId\\\", string(chargeItem.ResourceId)).Msg(\\\"UPDATE_CBS_BALANCE_RECORD_FAILED\\\")\\n\\t}\\n\\n\\treturn err\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/measure.go\",\n    \"code_start_line\": 82,\n    \"code_end_line\": 104,\n    \"code_key\": \"UpdateResBalanceRecord\",\n    \"code_value\": \"func (repo *MeasureRepo) UpdateResBalanceRecord(ctx context.Context, appId int64, resourceId string, balanceUpdateDetails []*measure.BalanceUpdateDetail, tableName string) error {\\n\\tdb, err := repo.getCCDBDb(ctx)\\n\\tif err != nil {\\n\\t\\treturn err\\n\\t}\\n\\n\\terr = db.Transaction(func(tx *gorm.DB) error {\\n\\t\\tfor _, detail := range balanceUpdateDetails {\\n\\t\\t\\tupdateKVs := map[string]interface{}{\\n\\t\\t\\t\\t\\\"status\\\":          detail.Status,\\n\\t\\t\\t\\t\\\"lastBalanceTime\\\": detail.LastBalanceTime,\\n\\t\\t\\t}\\n\\t\\t\\tresult := tx.Table(tableName).\\n\\t\\t\\t\\tWhere(\\\"appId = ? and resourceId = ? and id = ?\\\", appId, resourceId, detail.BalanceId).\\n\\t\\t\\t\\tUpdates(updateKVs)\\n\\t\\t\\tif result.Error != nil {\\n\\t\\t\\t\\treturn result.Error\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn nil\\n\\t})\\n\\treturn err\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"Update balance record in transaction\", \"sql\": \"BEGIN; UPDATE ? SET status = ?, lastBalanceTime = ? WHERE appId = ? AND resourceId = ? AND id = ?; COMMIT;\"}]}]",
      "parsed_sql": [
        "BEGIN; UPDATE ? SET status = ?, lastBalanceTime = ? WHERE appId = ? AND resourceId = ? AND id = ?; COMMIT;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "BEGIN; UPDATE ? SET status = ?, lastBalanceTime = ? WHERE appId = ? AND resourceId = ? AND id = ?; COMMIT;",
            "match_result": {
              "matched": false,
              "fingerprint": "ef1e57557dab0c6c086e72c8ffbf1dae",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go:677:710:Release",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：Release\nfunc (l *mysqlLock) Release(ctx context.Context) error {\n\tif atomic.LoadInt32(&l.released) == 1 {\n\t\t// fast path\n\t\treturn nil\n\t}\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\n\t// slow path\n\tif l.released == 1 {\n\t\treturn nil\n\t}\n\n\ttx := l.locker.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\n\n\treadLocks, writeLocks := l.locker.getReadLocksAndWriteLocks(tx, l.keys)\n\n\tif err := l.locker.deleteLocksByKeysAndToken(tx, dlock.LockKeySlice(writeLocks).GetKeys(), l.tokens); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn errors.Wrap(err, \"failed to release locks\")\n\t}\n\n\tif err := l.locker.releaseReadLocks(tx, dlock.LockKeySlice(readLocks).GetKeys(), l.tokens); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn errors.Wrap(err, \"failed to release locks\")\n\t}\n\n\tif result := tx.Commit(); result.Error != nil {\n\t\treturn errors.Wrap(result.Error, \"failed to commit release locks\")\n\t}\n\tl.expiration = time.Now()\n\tatomic.StoreInt32(&l.released, 1)\n\treturn nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/core/convertor.go\", \"code_start_line\": 28, \"code_end_line\": 38, \"code_key\": \"Start\", \"code_value\": \"func (a *Convertor) Start(ctx context.Context) error {\\n\\t// 启动转换器\\n\\tfor _, scanner := range a.scanners {\\n\\t\\tscanner := scanner\\n\\t\\tgo func() {\\n\\t\\t\\ta.convertToTask(ctx, scanner)\\n\\t\\t}()\\n\\t}\\n\\tlogs.Info(ctx).Msgf(\\\"Convertor Start Success\\\")\\n\\treturn nil\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go\",\n    \"code_start_line\": 677,\n    \"code_end_line\": 710,\n    \"code_key\": \"Release\",\n    \"code_value\": \"func (l *mysqlLock) Release(ctx context.Context) error {\\n\\tif atomic.LoadInt32(&l.released) == 1 {\\n\\t\\t// fast path\\n\\t\\treturn nil\\n\\t}\\n\\tl.mu.Lock()\\n\\tdefer l.mu.Unlock()\\n\\n\\t// slow path\\n\\tif l.released == 1 {\\n\\t\\treturn nil\\n\\t}\\n\\n\\ttx := l.locker.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\\n\\n\\treadLocks, writeLocks := l.locker.getReadLocksAndWriteLocks(tx, l.keys)\\n\\n\\tif err := l.locker.deleteLocksByKeysAndToken(tx, dlock.LockKeySlice(writeLocks).GetKeys(), l.tokens); err != nil {\\n\\t\\t_ = tx.Rollback()\\n\\t\\treturn errors.Wrap(err, \\\"failed to release locks\\\")\\n\\t}\\n\\n\\tif err := l.locker.releaseReadLocks(tx, dlock.LockKeySlice(readLocks).GetKeys(), l.tokens); err != nil {\\n\\t\\t_ = tx.Rollback()\\n\\t\\treturn errors.Wrap(err, \\\"failed to release locks\\\")\\n\\t}\\n\\n\\tif result := tx.Commit(); result.Error != nil {\\n\\t\\treturn errors.Wrap(result.Error, \\\"failed to commit release locks\\\")\\n\\t}\\n\\tl.expiration = time.Now()\\n\\tatomic.StoreInt32(&l.released, 1)\\n\\treturn nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"正常执行路径（所有检查都通过）\", \"sql\": \"BEGIN; COMMIT;\"}, {\"scenario\": \"删除锁失败时回滚\", \"sql\": \"BEGIN; ROLLBACK;\"}, {\"scenario\": \"释放读锁失败时回滚\", \"sql\": \"BEGIN; ROLLBACK;\"}]}]",
      "parsed_sql": [
        "BEGIN; COMMIT;",
        "BEGIN; ROLLBACK;",
        "BEGIN; ROLLBACK;"
      ],
      "sql_evaluation": {
        "total_sql": 3,
        "valid_sql": 0,
        "matched_sql": 0,
        "excluded_sql": 3,
        "fingerprint_results": [
          {
            "sql": "BEGIN; COMMIT;",
            "match_result": {
              "matched": false,
              "excluded": true,
              "fingerprint": "not_sql",
              "excluded_reason": "排除的SQL类型"
            }
          },
          {
            "sql": "BEGIN; ROLLBACK;",
            "match_result": {
              "matched": false,
              "excluded": true,
              "fingerprint": "not_sql",
              "excluded_reason": "排除的SQL类型"
            }
          },
          {
            "sql": "BEGIN; ROLLBACK;",
            "match_result": {
              "matched": false,
              "excluded": true,
              "fingerprint": "not_sql",
              "excluded_reason": "排除的SQL类型"
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/testutil/db.go:76:100:openMySQLConnection",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：openMySQLConnection\nfunc (dbInitializer) openMySQLConnection(t *testing.T, idx int) *gorm.DB {\n\t// Example docker commands to start a docker server\n\tmysqlUrl := os.Getenv(\"CBS_TEST_MYSQL_URL\")\n\tif mysqlUrl == \"\" {\n\t\t// 默认使用这个配置，用 DOCKER 启动一个 MySQL 服务:\n\t\t// docker run -d --rm -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7\n\t\tuser := \"root\"\n\t\tpasswd := \"123456\" // NOCA:PasswordLeak(误报)\n\t\thost := \"127.0.0.1\"\n\t\tport := 3306\n\t\tmysqlUrl = fmt.Sprintf(\"%s:%s@tcp(%s:%d)/?charset=utf8mb4&parseTime=True&loc=Local\",\n\t\t\tuser, passwd, host, port)\n\t}\n\tdatabase := os.Getenv(\"CBS_TEST_MYSQL_DATABASE\")\n\tif database == \"\" {\n\t\tdatabase = fmt.Sprintf(\"test-singularity-%d-%d\", os.Getpid(), idx)\n\t}\n\tdb, err := gorm.Open(mysql.Open(mysqlUrl), &gorm.Config{})\n\tif err != nil {\n\t\tt.Skipf(\"failed to connect to mysql server: %s\", err)\n\t}\n\tassert.NoError(t, db.Exec(fmt.Sprintf(\"DROP DATABASE IF EXISTS `%s`\", database)).Error, \"failed to drop database\")\n\tassert.NoError(t, db.Exec(fmt.Sprintf(\"CREATE DATABASE `%s`\", database)).Error, \"failed to create database\")\n\treturn db.Exec(fmt.Sprintf(\"USE `%s`\", database))\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/test_utils/initdb.go\", \"code_start_line\": 91, \"code_end_line\": 98, \"code_key\": \"SetupTestDatabase\", \"code_value\": \"func (i dbInitializer) SetupTestDatabase(t *testing.T, database string) (*gorm.DB, func()) {\\n\\tidx := pool.Get()\\n\\tdb := i.openMySQLConnection(t, database)\\n\\treturn db, func() {\\n\\t\\t_idx := idx\\n\\t\\tpool.Release(_idx)\\n\\t}\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/testutil/db.go\",\n    \"code_start_line\": 76,\n    \"code_end_line\": 100,\n    \"code_key\": \"openMySQLConnection\",\n    \"code_value\": \"func (dbInitializer) openMySQLConnection(t *testing.T, idx int) *gorm.DB {\\n\\t// Example docker commands to start a docker server\\n\\tmysqlUrl := os.Getenv(\\\"CBS_TEST_MYSQL_URL\\\")\\n\\tif mysqlUrl == \\\"\\\" {\\n\\t\\t// 默认使用这个配置，用 DOCKER 启动一个 MySQL 服务:\\n\\t\\t// docker run -d --rm -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7\\n\\t\\tuser := \\\"root\\\"\\n\\t\\tpasswd := \\\"123456\\\" // NOCA:PasswordLeak(误报)\\n\\t\\thost := \\\"127.0.0.1\\\"\\n\\t\\tport := 3306\\n\\t\\tmysqlUrl = fmt.Sprintf(\\\"%s:%s@tcp(%s:%d)/?charset=utf8mb4&parseTime=True&loc=Local\\\",\\n\\t\\t\\tuser, passwd, host, port)\\n\\t}\\n\\tdatabase := os.Getenv(\\\"CBS_TEST_MYSQL_DATABASE\\\")\\n\\tif database == \\\"\\\" {\\n\\t\\tdatabase = fmt.Sprintf(\\\"test-singularity-%d-%d\\\", os.Getpid(), idx)\\n\\t}\\n\\tdb, err := gorm.Open(mysql.Open(mysqlUrl), &gorm.Config{})\\n\\tif err != nil {\\n\\t\\tt.Skipf(\\\"failed to connect to mysql server: %s\\\", err)\\n\\t}\\n\\tassert.NoError(t, db.Exec(fmt.Sprintf(\\\"DROP DATABASE IF EXISTS `%s`\\\", database)).Error, \\\"failed to drop database\\\")\\n\\tassert.NoError(t, db.Exec(fmt.Sprintf(\\\"CREATE DATABASE `%s`\\\", database)).Error, \\\"failed to create database\\\")\\n\\treturn db.Exec(fmt.Sprintf(\\\"USE `%s`\\\", database))\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"DROP DATABASE IF EXISTS `test-singularity-12345-1`;\", \"CREATE DATABASE `test-singularity-12345-1`;\"]",
      "parsed_sql": [
        "DROP DATABASE IF EXISTS `test-singularity-12345-1`;",
        "CREATE DATABASE `test-singularity-12345-1`;"
      ],
      "sql_evaluation": {
        "total_sql": 2,
        "valid_sql": 0,
        "matched_sql": 0,
        "excluded_sql": 2,
        "fingerprint_results": [
          {
            "sql": "DROP DATABASE IF EXISTS `test-singularity-12345-1`;",
            "match_result": {
              "matched": false,
              "excluded": true,
              "fingerprint": "ddl_command",
              "excluded_reason": "排除的SQL类型"
            }
          },
          {
            "sql": "CREATE DATABASE `test-singularity-12345-1`;",
            "match_result": {
              "matched": false,
              "excluded": true,
              "fingerprint": "ddl_command",
              "excluded_reason": "排除的SQL类型"
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/measure.go:29:44:GetAppIdsWithResources",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：GetAppIdsWithResources\nfunc (repo *MeasureRepo) GetAppIdsWithResources(ctx context.Context, chargeTime time.Time, includeInvalidRes bool, tableName string) ([]int64, error) {\n\tdb, err := repo.getCCDBDb(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar appIdList []int64\n\t// FIXME 这里是获取到已经被python更新过的balance，临时兼容使用\n\tquery := db.Table(tableName).Distinct(\"appId\")\n\tif !includeInvalidRes {\n\t\tquery = query.Where(\"status = 1 and lastBalanceTime <= ?\", chargeTime)\n\t}\n\tquery.Pluck(\"appId\", &appIdList)\n\n\treturn appIdList, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/repush_user_billing_task.go\", \"code_start_line\": 103, \"code_end_line\": 172, \"code_key\": \"ProcessSingleRepushDetail\", \"code_value\": \"func (t *RepushUserBillingTask) ProcessSingleRepushDetail(detail *measure.RepushDetail) error {\\n\\tcbsMeasureRepo := registry.GetRegistry(t.ctx).AdapterRepos.CbsMeasureRepo.(measure.CbsMeasureRepoIFace)\\n\\tappIdResIdMaps := make(map[user.AppId][]measure.ResourceId)\\n\\tif detail.AppId > 0 {\\n\\t\\tif len(detail.ResIds) > 0 {\\n\\t\\t\\tappIdResIdMaps[detail.AppId] = detail.ResIds\\n\\t\\t} else {\\n\\t\\t\\tids, err := cbsMeasureRepo.GetResourceIdsByAppId(t.ctx, int64(detail.AppId), time.Time{}, true, cbsMeasureRepo.GetBalanceTableName())\\n\\t\\t\\tif err != nil {\\n\\t\\t\\t\\treturn err\\n\\t\\t\\t}\\n\\t\\t\\tresIds := make([]measure.ResourceId, 0, len(ids))\\n\\t\\t\\tfor _, resId := range ids {\\n\\t\\t\\t\\tresIds = append(resIds, measure.ResourceId(resId))\\n\\t\\t\\t}\\n\\t\\t\\tappIdResIdMaps[detail.AppId] = resIds\\n\\t\\t}\\n\\t} else {\\n\\t\\tif len(detail.ResIds) > 0 {\\n\\t\\t\\treturn fmt.Errorf(\\\"AppId is required when ResIds is set\\\")\\n\\t\\t}\\n\\t\\tlogs.Info(t.ctx).Msg(\\\"REPUSH_ALL_FOR_APPID_NOT_SET\\\")\\n\\t\\tappIds, _ := cbsMeasureRepo.GetAppIdsWithResources(t.ctx, time.Time{}, true, cbsMeasureRepo.GetBalanceTableName())\\n\\t\\tfor _, appId := range appIds {\\n\\t\\t\\t// 没有指定资源，则补量所有资源\\n\\t\\t\\tids, err := cbsMeasureRepo.GetResourceIdsByAppId(t.ctx, appId, time.Time{}, true, cbsMeasureRepo.GetBalanceTableName())\\n\\t\\t\\tif err != nil {\\n\\t\\t\\t\\treturn err\\n\\t\\t\\t}\\n\\t\\t\\tresIds := make([]measure.ResourceId, 0, len(ids))\\n\\t\\t\\tfor _, resId := range ids {\\n\\t\\t\\t\\tresIds = append(resIds, measure.ResourceId(resId))\\n\\t\\t\\t}\\n\\t\\t\\tappIdResIdMaps[user.AppId(appId)] = resIds\\n\\t\\t}\\n\\n\\t}\\n\\n\\tvar repushItems []*RepushItem\\n\\tfor appId, resIds := range appIdResIdMaps {\\n\\t\\tu, err := t.userSrv.GetUser(appId)\\n\\t\\tif err != nil {\\n\\t\\t\\t// 这里可能是新注册的用户，user表里没有用户数据，可能会丢失该用户的量\\n\\t\\t\\tlogs.Error(t.ctx).Err(err).Uint64(\\\"appId\\\", uint64(appId)).Msg(\\\"GET_USER_ERROR\\\")\\n\\t\\t\\tpanic(err)\\n\\t\\t}\\n\\t\\tfor _, resId := range resIds {\\n\\t\\t\\tvar repushItem RepushItem\\n\\t\\t\\trepushItem.user = u\\n\\t\\t\\trepushItem.cbsInstanceId = resId\\n\\t\\t\\trepushItem.startTime = detail.StartTime\\n\\t\\t\\trepushItem.endTime = detail.EndTime\\n\\t\\t\\trepushItems = append(repushItems, &repushItem)\\n\\t\\t}\\n\\t}\\n\\tlogs.Info(t.ctx).Int(\\\"count\\\", len(repushItems)).Msg(\\\"REPUSH_ITEMS_INFO\\\")\\n\\n\\tvar wg sync.WaitGroup\\n\\tfor _, repushItem := range repushItems {\\n\\t\\twg.Add(1)\\n\\t\\tt.semaphore <- struct{}{}\\n\\t\\tgo func(item *RepushItem) {\\n\\t\\t\\tdefer wg.Done()\\n\\t\\t\\tdefer func() { <-t.semaphore }()\\n\\t\\t\\tt.ProcessSingleRepushItem(item)\\n\\t\\t}(repushItem)\\n\\t}\\n\\twg.Wait()\\n\\treturn nil\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/measure.go\",\n    \"code_start_line\": 29,\n    \"code_end_line\": 44,\n    \"code_key\": \"GetAppIdsWithResources\",\n    \"code_value\": \"func (repo *MeasureRepo) GetAppIdsWithResources(ctx context.Context, chargeTime time.Time, includeInvalidRes bool, tableName string) ([]int64, error) {\\n\\tdb, err := repo.getCCDBDb(ctx)\\n\\tif err != nil {\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\tvar appIdList []int64\\n\\t// FIXME 这里是获取到已经被python更新过的balance，临时兼容使用\\n\\tquery := db.Table(tableName).Distinct(\\\"appId\\\")\\n\\tif !includeInvalidRes {\\n\\t\\tquery = query.Where(\\\"status = 1 and lastBalanceTime <= ?\\\", chargeTime)\\n\\t}\\n\\tquery.Pluck(\\\"appId\\\", &appIdList)\\n\\n\\treturn appIdList, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"includeInvalidRes is false\", \"sql\": \"SELECT DISTINCT appId FROM ? WHERE status = 1 and lastBalanceTime <= ?;\"}, {\"scenario\": \"includeInvalidRes is true\", \"sql\": \"SELECT DISTINCT appId FROM ?;\"}]}]",
      "parsed_sql": [
        "SELECT DISTINCT appId FROM ? WHERE status = 1 and lastBalanceTime <= ?;",
        "SELECT DISTINCT appId FROM ?;"
      ],
      "sql_evaluation": {
        "total_sql": 2,
        "valid_sql": 2,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT DISTINCT appId FROM ? WHERE status = 1 and lastBalanceTime <= ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "b3ad252d55433220bb3a8db43a28cadf",
              "excluded": false
            }
          },
          {
            "sql": "SELECT DISTINCT appId FROM ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "764a377e8c3593608757e7d2721044fa",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/measure.go:66:80:GetIdLastBalanceTimePairs",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：GetIdLastBalanceTimePairs\nfunc (repo *MeasureRepo) GetIdLastBalanceTimePairs(ctx context.Context, limit int, searchAfterId int, tableName string) ([]*measure.IdLastBalanceTimePair, error) {\n\tdb, err := repo.getCCDBDb(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// 此处是为了保证有序\n\tvar idLastBalanceTimePairs []*measure.IdLastBalanceTimePair\n\tdb.Table(tableName).\n\t\tSelect(\"id, lastBalanceTime\").Where(\"id > ? and status = 1\", searchAfterId).\n\t\tOrder(\"id\").\n\t\tLimit(limit).\n\t\tScan(&idLastBalanceTimePairs)\n\treturn idLastBalanceTimePairs, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go\", \"code_start_line\": 93, \"code_end_line\": 117, \"code_key\": \"BuildLastBalanceTimeCache\", \"code_value\": \"func (srv *BaseResSrv) BuildLastBalanceTimeCache() {\\n\\tsrv.lastBalanceTimeCache = make(map[int64]time.Time)\\n\\tlastID := -1\\n\\tstepSize := 10000 // 会产生慢查询。这里串行执行，风险还好\\n\\n\\tstartTime := time.Now()\\n\\tlogs.Info(srv.ctx).Msg(\\\"START_BUILD_LAST_BALANCE_TIME_CACHE\\\")\\n\\tfor {\\n\\t\\t// 查询100条记录，根据ID排序，使用ID进行偏移\\n\\t\\tidLastBalanceTimePairs, _ := srv.measureRepo.GetIdLastBalanceTimePairs(srv.ctx, stepSize, lastID, srv.measureRepo.GetBalanceTableName())\\n\\n\\t\\tif len(idLastBalanceTimePairs) == 0 {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\t// 将查询结果添加到缓存中\\n\\t\\tfor _, idLastBalanceTimePair := range idLastBalanceTimePairs {\\n\\t\\t\\tsrv.lastBalanceTimeCache[idLastBalanceTimePair.ID] = idLastBalanceTimePair.LastBalanceTime\\n\\t\\t}\\n\\t\\tlastID = int(idLastBalanceTimePairs[len(idLastBalanceTimePairs)-1].ID)\\n\\t}\\n\\n\\tcost := int(time.Now().Sub(startTime).Seconds())\\n\\tlogs.Info(srv.ctx).Int(\\\"count\\\", len(srv.lastBalanceTimeCache)).Int(\\\"cost\\\", cost).Msg(\\\"BUILD_LAST_BALANCE_TIME_CACHE_DONE\\\")\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/measure.go\",\n    \"code_start_line\": 66,\n    \"code_end_line\": 80,\n    \"code_key\": \"GetIdLastBalanceTimePairs\",\n    \"code_value\": \"func (repo *MeasureRepo) GetIdLastBalanceTimePairs(ctx context.Context, limit int, searchAfterId int, tableName string) ([]*measure.IdLastBalanceTimePair, error) {\\n\\tdb, err := repo.getCCDBDb(ctx)\\n\\tif err != nil {\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\t// 此处是为了保证有序\\n\\tvar idLastBalanceTimePairs []*measure.IdLastBalanceTimePair\\n\\tdb.Table(tableName).\\n\\t\\tSelect(\\\"id, lastBalanceTime\\\").Where(\\\"id > ? and status = 1\\\", searchAfterId).\\n\\t\\tOrder(\\\"id\\\").\\n\\t\\tLimit(limit).\\n\\t\\tScan(&idLastBalanceTimePairs)\\n\\treturn idLastBalanceTimePairs, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT id, lastBalanceTime FROM ? WHERE id > ? AND status = 1 ORDER BY id LIMIT ?;\"]",
      "parsed_sql": [
        "SELECT id, lastBalanceTime FROM ? WHERE id > ? AND status = 1 ORDER BY id LIMIT ?;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT id, lastBalanceTime FROM ? WHERE id > ? AND status = 1 ORDER BY id LIMIT ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "26ce4b8b77bb7d9d6f654d7f6523caa0",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/measure.go:170:177:BatchCreateMeasureRepo",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：BatchCreateMeasureRepo\nfunc (repo *MeasureRepo) BatchCreateMeasureRepo(ctx context.Context, measures interface{}, nums int) (bool, error) {\n\tdb, err := repo.getMeasureDb(ctx)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdb.CreateInBatches(measures, nums)\n\treturn true, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measureReconciliation/service.go\", \"code_start_line\": 119, \"code_end_line\": 124, \"code_key\": \"BatchSyncCbsMsgToDb\", \"code_value\": \"func (measureRecSrv *ReconciliationSrv) BatchSyncCbsMsgToDb(measures *measure.CbsMeasureDetails) error {\\n\\tcbsMeasures := measures.CbsMeasureDetail\\n\\tnums := len(cbsMeasures)\\n\\t_, err := measureRecSrv.repo.BatchCreateMeasureRepo(measureRecSrv.ctx, cbsMeasures, nums)\\n\\treturn err\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/measure.go\",\n    \"code_start_line\": 170,\n    \"code_end_line\": 177,\n    \"code_key\": \"BatchCreateMeasureRepo\",\n    \"code_value\": \"func (repo *MeasureRepo) BatchCreateMeasureRepo(ctx context.Context, measures interface{}, nums int) (bool, error) {\\n\\tdb, err := repo.getMeasureDb(ctx)\\n\\tif err != nil {\\n\\t\\treturn false, err\\n\\t}\\n\\tdb.CreateInBatches(measures, nums)\\n\\treturn true, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"批量插入CbsMeasureDetail记录\", \"sql\": \"INSERT INTO `cbs_measure_detail` (`id`, `created_at`, `updated_at`, `deleted_at`, `cbs_id`, `measure_type`, `measure_value`, `unit`, `description`) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?, ?, ?, ?);\"}]}]",
      "parsed_sql": [
        "INSERT INTO `cbs_measure_detail` (`id`, `created_at`, `updated_at`, `deleted_at`, `cbs_id`, `measure_type`, `measure_value`, `unit`, `description`) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?, ?, ?, ?);"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "INSERT INTO `cbs_measure_detail` (`id`, `created_at`, `updated_at`, `deleted_at`, `cbs_id`, `measure_type`, `measure_value`, `unit`, `description`) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?, ?, ?, ?);",
            "match_result": {
              "matched": false,
              "fingerprint": "f9a2b0a3b5ee5b74655f6d74483e6dc8",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/disk.go:31:49:QueryRollbackingDiskList",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：QueryRollbackingDiskList\nfunc (d *DiskRepo) QueryRollbackingDiskList(ctx context.Context) ([]*ccdb.CCbs, error) {\n\tvar diskList []*ccdb.CCbs\n\n\tdb, err := d.getCCDBDb(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcond1 := db.Where(\"lifeState IN ?\", []ccdb.DiskLifeState{ccdb.DiskLifeStateNormal, ccdb.DiskLifeStateIsolated})\n\tcond2 := db.Where(\"lifeState = ?\", ccdb.DiskLifeStateConcealed).\n\t\tWhere(\"status IN ?\", []ccdb.DiskStatus{ccdb.DiskAttached, ccdb.DiskInited})\n\tquery := db.Where(\"rollbacking IN ?\", []ccdb.DiskRollbackType{ccdb.SameDiskRb, ccdb.DiffDiskRb, ccdb.FastRb})\n\tresult := query.Where(cond1.Or(cond2)).Find(&diskList)\n\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\treturn diskList, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_rollback_task_scanner.go\", \"code_start_line\": 50, \"code_end_line\": 70, \"code_key\": \"getCCbsRollbackTask\", \"code_value\": \"func (s *UpdateRollbackTaskScanner) getCCbsRollbackTask(ctx context.Context) error {\\n\\t// cCbs表回滚进度更新\\n\\tdiskRepo := registry.GetRegistry(ctx).AdapterRepos.DiskRepo.(adapter_interfaces.DiskInterface)\\n\\tdiskRollbackList, err := diskRepo.QueryRollbackingDiskList(ctx)\\n\\tif err != nil {\\n\\t\\treturn err\\n\\t}\\n\\tfor _, diskRecord := range diskRollbackList {\\n\\t\\tentity := &diskLogical.DiskEntity{\\n\\t\\t\\tDiskRecord: diskRecord,\\n\\t\\t}\\n\\t\\tdiskRollbackAgg := &diskLogical.DiskRollbackingTaskAggregate{\\n\\t\\t\\tDiskEntity:        entity,\\n\\t\\t\\tRollbackingEntity: nil,\\n\\t\\t\\tTaskName:          core.UpdateCCbsNormalRBTask,\\n\\t\\t\\tSubTaskName:       core.UpdateCCbsNormalRBTask,\\n\\t\\t}\\n\\t\\ts.resultChan <- diskRollbackAgg\\n\\t}\\n\\treturn nil\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/disk.go\",\n    \"code_start_line\": 31,\n    \"code_end_line\": 49,\n    \"code_key\": \"QueryRollbackingDiskList\",\n    \"code_value\": \"func (d *DiskRepo) QueryRollbackingDiskList(ctx context.Context) ([]*ccdb.CCbs, error) {\\n\\tvar diskList []*ccdb.CCbs\\n\\n\\tdb, err := d.getCCDBDb(ctx)\\n\\tif err != nil {\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\tcond1 := db.Where(\\\"lifeState IN ?\\\", []ccdb.DiskLifeState{ccdb.DiskLifeStateNormal, ccdb.DiskLifeStateIsolated})\\n\\tcond2 := db.Where(\\\"lifeState = ?\\\", ccdb.DiskLifeStateConcealed).\\n\\t\\tWhere(\\\"status IN ?\\\", []ccdb.DiskStatus{ccdb.DiskAttached, ccdb.DiskInited})\\n\\tquery := db.Where(\\\"rollbacking IN ?\\\", []ccdb.DiskRollbackType{ccdb.SameDiskRb, ccdb.DiffDiskRb, ccdb.FastRb})\\n\\tresult := query.Where(cond1.Or(cond2)).Find(&diskList)\\n\\n\\tif result.Error != nil {\\n\\t\\treturn nil, result.Error\\n\\t}\\n\\treturn diskList, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM cCbs WHERE rollbacking IN (?, ?, ?) AND (lifeState IN (?, ?) OR (lifeState = ? AND status IN (?, ?)) );\"]",
      "parsed_sql": [
        "SELECT * FROM cCbs WHERE rollbacking IN (?, ?, ?) AND (lifeState IN (?, ?) OR (lifeState = ? AND status IN (?, ?)) );"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM cCbs WHERE rollbacking IN (?, ?, ?) AND (lifeState IN (?, ?) OR (lifeState = ? AND status IN (?, ?)) );",
            "match_result": {
              "matched": false,
              "fingerprint": "57e6fd5551e6cff1e0ca5438bc5dc70d",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/disk.go:51:65:UpdateRollbackingPercent",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：UpdateRollbackingPercent\nfunc (d *DiskRepo) UpdateRollbackingPercent(ctx context.Context, disk *ccdb.CCbs) error {\n\tdb, err := d.getCCDBDb(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tchanges := make(map[string]interface{})\n\tchanges[\"rollbackPercent\"] = disk.RollbackingPercent\n\tchanges[\"rollbacking\"] = disk.Rollbacking\n\tresult := db.Model(disk).Where(\"cbsInstanceId = ?\", disk.CbsInstanceId).Updates(changes)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/domain/diskLogical/service.go\", \"code_start_line\": 22, \"code_end_line\": 53, \"code_key\": \"UpdateCbsRollbackingPercent\", \"code_value\": \"func (s *DiskRollbackingServicesImpl) UpdateCbsRollbackingPercent(ctx context.Context, agg *DiskRollbackingTaskAggregate) (bool, error) {\\n\\tisFinish := false\\n\\n\\tsnapPhySrv := registry.GetRegistry(ctx).DomainServices.SnapPhyService.(snapPhysical.SnapPhyServiceInterface)\\n\\trsp, err := snapPhySrv.QueryDiskRollbackingPercent(ctx, agg.DiskRecord.AppId, agg.DiskRecord.CbsUuid, agg.DiskRecord.ArchType)\\n\\tif err != nil {\\n\\t\\treturn false, err\\n\\t}\\n\\n\\tpercent := rsp.Percent\\n\\tstatus := rsp.Status\\n\\tif status == 3 && agg.DiskRecord.RollbackingPercent > percent {\\n\\t\\t// 这种场景通常因为发起了多个快照回滚，此时的进度已经不是原来的进度了，直接忽略修改 cCbs\\n\\t\\tlogs.Info(ctx).Msg(\\\"CBS_ROLLBACK_EXPIRED_SKIP_UPDATE_CCBS\\\")\\n\\t} else {\\n\\t\\tif status == 1 {\\n\\t\\t\\t// 盘的状态为normal\\n\\t\\t\\tpercent = 100\\n\\t\\t} else if status == 2 {\\n\\t\\t\\t// preRollback\\n\\t\\t\\tpercent = 0\\n\\t\\t}\\n\\t\\terr = agg.UpdateCbsRollbackingPercent(ctx, percent)\\n\\t}\\n\\tif err != nil {\\n\\t\\treturn false, err\\n\\t}\\n\\tif percent >= 100 {\\n\\t\\tisFinish = true\\n\\t}\\n\\treturn isFinish, err\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/disk.go\",\n    \"code_start_line\": 51,\n    \"code_end_line\": 65,\n    \"code_key\": \"UpdateRollbackingPercent\",\n    \"code_value\": \"func (d *DiskRepo) UpdateRollbackingPercent(ctx context.Context, disk *ccdb.CCbs) error {\\n\\tdb, err := d.getCCDBDb(ctx)\\n\\tif err != nil {\\n\\t\\treturn err\\n\\t}\\n\\n\\tchanges := make(map[string]interface{})\\n\\tchanges[\\\"rollbackPercent\\\"] = disk.RollbackingPercent\\n\\tchanges[\\\"rollbacking\\\"] = disk.Rollbacking\\n\\tresult := db.Model(disk).Where(\\\"cbsInstanceId = ?\\\", disk.CbsInstanceId).Updates(changes)\\n\\tif result.Error != nil {\\n\\t\\treturn result.Error\\n\\t}\\n\\treturn nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"UPDATE c_cbs SET rollbackPercent = ?, rollbacking = ? WHERE cbsInstanceId = ?;\"]",
      "parsed_sql": [
        "UPDATE c_cbs SET rollbackPercent = ?, rollbacking = ? WHERE cbsInstanceId = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "UPDATE c_cbs SET rollbackPercent = ?, rollbacking = ? WHERE cbsInstanceId = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "a7f5febbdeb9f59d64c3940d9f82ae52",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/shm_conf.go:13:28:QueryValidShmConfByKey",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：QueryValidShmConfByKey\nfunc (r *ShmConfRepo) QueryValidShmConfByKey(ctx context.Context, key string) (*des.TCbsShmConf, error) {\n\tdb, err := r.getDesDb(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar conf des.TCbsShmConf\n\tresult := db.Where(\"confKey = ? AND status = ?\", key, des.ShmConfValid).Find(&conf)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, fmt.Errorf(\"shm config record not found\")\n\t}\n\treturn &conf, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/domain/common/service.go\", \"code_start_line\": 17, \"code_end_line\": 35, \"code_key\": \"CacheGetShmConf\", \"code_value\": \"func (s *ShmConfService) CacheGetShmConf(ctx context.Context, key string) (*des.TCbsShmConf, error) {\\n\\tregion, ok := ctx.Value(\\\"region\\\").(string)\\n\\tif !ok {\\n\\t\\treturn nil, fmt.Errorf(\\\"region not found in context\\\")\\n\\t}\\n\\tcacheKey := fmt.Sprintf(\\\"ShmConf-%s\\\", key)\\n\\tcache := registry.GetRegistry(ctx).Caches[region]\\n\\tconf, ok := cache.Get(cacheKey)\\n\\tif !ok {\\n\\t\\trepo := registry.GetRegistry(ctx).AdapterRepos.ShmConfigRepo.(adapter_interfaces.ShmConfigInterface)\\n\\t\\tconf, err := repo.QueryValidShmConfByKey(ctx, key)\\n\\t\\tif err != nil {\\n\\t\\t\\treturn nil, err\\n\\t\\t}\\n\\t\\tcache.Set(cacheKey, conf, time.Minute*10) // 10分钟过期\\n\\t\\treturn conf, nil\\n\\t}\\n\\treturn conf.(*des.TCbsShmConf), nil\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/shm_conf.go\",\n    \"code_start_line\": 13,\n    \"code_end_line\": 28,\n    \"code_key\": \"QueryValidShmConfByKey\",\n    \"code_value\": \"func (r *ShmConfRepo) QueryValidShmConfByKey(ctx context.Context, key string) (*des.TCbsShmConf, error) {\\n\\tdb, err := r.getDesDb(ctx)\\n\\tif err != nil {\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\tvar conf des.TCbsShmConf\\n\\tresult := db.Where(\\\"confKey = ? AND status = ?\\\", key, des.ShmConfValid).Find(&conf)\\n\\tif result.Error != nil {\\n\\t\\treturn nil, result.Error\\n\\t}\\n\\tif result.RowsAffected == 0 {\\n\\t\\treturn nil, fmt.Errorf(\\\"shm config record not found\\\")\\n\\t}\\n\\treturn &conf, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM tCbsShmConf WHERE confKey = ? AND status = ?;\"]",
      "parsed_sql": [
        "SELECT * FROM tCbsShmConf WHERE confKey = ? AND status = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM tCbsShmConf WHERE confKey = ? AND status = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "2933312e6435a1d20e0867e8688defa0",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/snap.go:16:30:QuerySnapInfoById",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：QuerySnapInfoById\nfunc (r *SnapRepo) QuerySnapInfoById(ctx context.Context, id string) (*ccdb.CSnap, error) {\n\tdb, err := r.getCCDBDb(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar cSnap ccdb.CSnap\n\tresult := db.First(&cSnap)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t} else if result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\treturn &cSnap, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/snap.go\",\n    \"code_start_line\": 16,\n    \"code_end_line\": 30,\n    \"code_key\": \"QuerySnapInfoById\",\n    \"code_value\": \"func (r *SnapRepo) QuerySnapInfoById(ctx context.Context, id string) (*ccdb.CSnap, error) {\\n\\tdb, err := r.getCCDBDb(ctx)\\n\\tif err != nil {\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\tvar cSnap ccdb.CSnap\\n\\tresult := db.First(&cSnap)\\n\\tif result.Error != nil {\\n\\t\\treturn nil, result.Error\\n\\t} else if result.RowsAffected == 0 {\\n\\t\\treturn nil, nil\\n\\t}\\n\\treturn &cSnap, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM c_snap LIMIT 1;\"]",
      "parsed_sql": [
        "SELECT * FROM c_snap LIMIT 1;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM c_snap LIMIT 1;",
            "match_result": {
              "matched": false,
              "fingerprint": "e3755c83f4a1e4efd408914bb89545f1",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/snap.go:32:44:QueryCreatingCopyingSnapList",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：QueryCreatingCopyingSnapList\nfunc (r *SnapRepo) QueryCreatingCopyingSnapList(ctx context.Context) ([]*ccdb.CSnap, error) {\n\tdb, err := r.getCCDBDb(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar snapList []*ccdb.CSnap\n\tresult := db.Where(\"status in ?\", []ccdb.SnapStatus{ccdb.SnapCreating, ccdb.SnapCopyingFromRemote, ccdb.SnapCheckingCopied}).Find(&snapList)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\treturn snapList, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_rec_task_scanner.go\", \"code_start_line\": 39, \"code_end_line\": 41, \"code_key\": \"FullScan\", \"code_value\": \"func (s *CbsMeasureReconciliationTaskScanner) FullScan(ctx context.Context) error {\\n\\treturn nil\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/snap.go\",\n    \"code_start_line\": 32,\n    \"code_end_line\": 44,\n    \"code_key\": \"QueryCreatingCopyingSnapList\",\n    \"code_value\": \"func (r *SnapRepo) QueryCreatingCopyingSnapList(ctx context.Context) ([]*ccdb.CSnap, error) {\\n\\tdb, err := r.getCCDBDb(ctx)\\n\\tif err != nil {\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\tvar snapList []*ccdb.CSnap\\n\\tresult := db.Where(\\\"status in ?\\\", []ccdb.SnapStatus{ccdb.SnapCreating, ccdb.SnapCopyingFromRemote, ccdb.SnapCheckingCopied}).Find(&snapList)\\n\\tif result.Error != nil {\\n\\t\\treturn nil, result.Error\\n\\t}\\n\\treturn snapList, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM c_snap WHERE status IN (?, ?, ?);\"]",
      "parsed_sql": [
        "SELECT * FROM c_snap WHERE status IN (?, ?, ?);"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM c_snap WHERE status IN (?, ?, ?);",
            "match_result": {
              "matched": false,
              "fingerprint": "33874239018fa1befbb497d0bb26b5b9",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/snap.go:46:61:UpdateCreatingPercent",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：UpdateCreatingPercent\nfunc (r *SnapRepo) UpdateCreatingPercent(ctx context.Context, snap *ccdb.CSnap) error {\n\tdb, err := r.getCCDBDb(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tchanges := make(map[string]interface{})\n\tchanges[\"percent\"] = snap.Percent\n\tchanges[\"status\"] = snap.Status\n\tchanges[\"snapSize\"] = snap.SnapSize\n\tresult := db.Model(snap).Where(\"snapInstanceId = ?\", snap.SnapInstanceId).Updates(changes)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/domain/snapLogical/service.go\", \"code_start_line\": 27, \"code_end_line\": 53, \"code_key\": \"UpdateSnapCreatingPercent\", \"code_value\": \"func (s *SnapCreatingServiceImpl) UpdateSnapCreatingPercent(ctx context.Context, agg *SnapCreateTaskAggregate) (bool, error) {\\n\\t// 调用OSS Domain查询进度\\n\\tisFinish := false\\n\\tsnapPhySrv := registry.GetRegistry(ctx).DomainServices.SnapPhyService.(snapPhysical.SnapPhyServiceInterface)\\n\\trsp, err := snapPhySrv.QuerySnapCreatingPercent(ctx, agg.SnapRecord.AppId, agg.SnapRecord.SnapUuid, agg.SnapRecord.CbsUuid, agg.SnapRecord.ArchType)\\n\\tif err != nil {\\n\\t\\treturn false, err\\n\\t}\\n\\tpercent := rsp.Percent\\n\\ttaskStatus := rsp.Status\\n\\tsnapSize := rsp.SnapSize\\n\\tsnapStatus, ok := snapOssStatusMap[taskStatus]\\n\\tif !ok {\\n\\t\\tlogs.Error(ctx).Str(\\\"SnapId\\\", agg.SnapRecord.SnapInstanceId).\\n\\t\\t\\tInt(\\\"OssStatus\\\", taskStatus).Msg(\\\"SNAP_STATUS_ERROR\\\")\\n\\t}\\n\\n\\tpercent = agg.GetSnapCreatePercent(ctx, percent, snapStatus)\\n\\terr = agg.UpdateSnapCreatingPercent(ctx, percent, snapStatus, snapSize)\\n\\tif err != nil {\\n\\t\\treturn false, err\\n\\t}\\n\\tif agg.SnapRecord.Status == ccdb.SnapNormal || taskStatus == snapPhysical.OssSnapStatusDeleted || taskStatus == snapPhysical.OssSnapStatusCanceled {\\n\\t\\tisFinish = true\\n\\t}\\n\\treturn isFinish, err\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/snap.go\",\n    \"code_start_line\": 46,\n    \"code_end_line\": 61,\n    \"code_key\": \"UpdateCreatingPercent\",\n    \"code_value\": \"func (r *SnapRepo) UpdateCreatingPercent(ctx context.Context, snap *ccdb.CSnap) error {\\n\\tdb, err := r.getCCDBDb(ctx)\\n\\tif err != nil {\\n\\t\\treturn err\\n\\t}\\n\\n\\tchanges := make(map[string]interface{})\\n\\tchanges[\\\"percent\\\"] = snap.Percent\\n\\tchanges[\\\"status\\\"] = snap.Status\\n\\tchanges[\\\"snapSize\\\"] = snap.SnapSize\\n\\tresult := db.Model(snap).Where(\\\"snapInstanceId = ?\\\", snap.SnapInstanceId).Updates(changes)\\n\\tif result.Error != nil {\\n\\t\\treturn result.Error\\n\\t}\\n\\treturn nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"UPDATE c_snap SET percent = ?, status = ?, snapSize = ? WHERE snapInstanceId = ?;\"]",
      "parsed_sql": [
        "UPDATE c_snap SET percent = ?, status = ?, snapSize = ? WHERE snapInstanceId = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "UPDATE c_snap SET percent = ?, status = ?, snapSize = ? WHERE snapInstanceId = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "5724049a71dd4d72ad7a676f284c009d",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/snap.go:64:75:GetExpiredSnapDeadlineInfo",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：GetExpiredSnapDeadlineInfo\nfunc (r *SnapRepo) GetExpiredSnapDeadlineInfo(ctx context.Context, appId int64, deadline time.Time) ([]*ccdb.CSnap, error) {\n\tdb, err := r.getCCDBDb(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar snapList []*ccdb.CSnap\n\tdb.Select(\"snapInstanceId\", \"deadline1\").\n\t\tWhere(\"appId = ? and lifeState = ? and deadline1 is not null and deadline1 < ?\", appId, \"normal\", deadline).\n\t\tFind(&snapList)\n\treturn snapList, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go\", \"code_start_line\": 123, \"code_end_line\": 131, \"code_key\": \"GetSnapRealChargeTimes\", \"code_value\": \"func (snapSrv *SnapSrv) GetSnapRealChargeTimes(appId user.AppId, chargeTime time.Time) map[ResourceId]time.Time {\\n\\tsnapList, _ := snapSrv.snapRepo.GetExpiredSnapDeadlineInfo(snapSrv.ctx, int64(appId), chargeTime)\\n\\n\\tsnapIdDeadlineMap := make(map[ResourceId]time.Time, len(snapList))\\n\\tfor _, snap := range snapList {\\n\\t\\tsnapIdDeadlineMap[ResourceId(snap.SnapInstanceId)] = snap.Deadline\\n\\t}\\n\\treturn snapIdDeadlineMap\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/snap.go\",\n    \"code_start_line\": 64,\n    \"code_end_line\": 75,\n    \"code_key\": \"GetExpiredSnapDeadlineInfo\",\n    \"code_value\": \"func (r *SnapRepo) GetExpiredSnapDeadlineInfo(ctx context.Context, appId int64, deadline time.Time) ([]*ccdb.CSnap, error) {\\n\\tdb, err := r.getCCDBDb(ctx)\\n\\tif err != nil {\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\tvar snapList []*ccdb.CSnap\\n\\tdb.Select(\\\"snapInstanceId\\\", \\\"deadline1\\\").\\n\\t\\tWhere(\\\"appId = ? and lifeState = ? and deadline1 is not null and deadline1 < ?\\\", appId, \\\"normal\\\", deadline).\\n\\t\\tFind(&snapList)\\n\\treturn snapList, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT snapInstanceId, deadline1 FROM cSnap WHERE appId = ? AND lifeState = ? AND deadline1 IS NOT NULL AND deadline1 < ?;\"]",
      "parsed_sql": [
        "SELECT snapInstanceId, deadline1 FROM cSnap WHERE appId = ? AND lifeState = ? AND deadline1 IS NOT NULL AND deadline1 < ?;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT snapInstanceId, deadline1 FROM cSnap WHERE appId = ? AND lifeState = ? AND deadline1 IS NOT NULL AND deadline1 < ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "13b7df716d8d61de9db98a4142f2f35d",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/snap.go:82:91:GetSnapBalanceRecords",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：GetSnapBalanceRecords\nfunc (r *SnapRepo) GetSnapBalanceRecords(ctx context.Context, resourceId string, chargeTime time.Time) ([]*ccdb.CSnapBalance, error) {\n\tdb, err := r.getCCDBDb(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar cSnapBalance []*ccdb.CSnapBalance\n\tdb.Where(\"resourceId = ? and lastBalanceTime < ? and status = 1\", resourceId, chargeTime).Find(&cSnapBalance)\n\treturn cSnapBalance, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/service.go\", \"code_start_line\": 208, \"code_end_line\": 217, \"code_key\": \"BuildResChargeItem\", \"code_value\": \"func (cbsSrv *CbsSrv) BuildResChargeItem(u *user.User, resourceId ResourceId, chargeTime time.Time) *ChargeItem {\\n\\tcbsMeasureRepo := cbsSrv.balanceRepo.(repositories.CbsBalanceRepoIFace)\\n\\tbalanceRecords, _ := cbsMeasureRepo.GetCbsBalanceRecords(cbsSrv.ctx, string(resourceId), chargeTime, false)\\n\\n\\tif len(balanceRecords) == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\n\\treturn cbsSrv.convertToChargeItem(u, resourceId, balanceRecords, chargeTime)\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/snap.go\",\n    \"code_start_line\": 82,\n    \"code_end_line\": 91,\n    \"code_key\": \"GetSnapBalanceRecords\",\n    \"code_value\": \"func (r *SnapRepo) GetSnapBalanceRecords(ctx context.Context, resourceId string, chargeTime time.Time) ([]*ccdb.CSnapBalance, error) {\\n\\tdb, err := r.getCCDBDb(ctx)\\n\\tif err != nil {\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\tvar cSnapBalance []*ccdb.CSnapBalance\\n\\tdb.Where(\\\"resourceId = ? and lastBalanceTime < ? and status = 1\\\", resourceId, chargeTime).Find(&cSnapBalance)\\n\\treturn cSnapBalance, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT id, resourceId, resourceInfo, planProductId, planProductName, serverProductId, serverProductName, module1Name, module2Name, module3Name, module1, module2, module3, cpu, memory, gpu, storage, snapshotSize, isRapidDeploy, isScale, isMigrateToHost, migrateToHostTime, lastBalanceTime, status, createTime, updateTime, desc FROM cSnapBalance WHERE resourceId = ? AND lastBalanceTime < ? AND status = 1;\"]",
      "parsed_sql": [
        "SELECT id, resourceId, resourceInfo, planProductId, planProductName, serverProductId, serverProductName, module1Name, module2Name, module3Name, module1, module2, module3, cpu, memory, gpu, storage, snapshotSize, isRapidDeploy, isScale, isMigrateToHost, migrateToHostTime, lastBalanceTime, status, createTime, updateTime, desc FROM cSnapBalance WHERE resourceId = ? AND lastBalanceTime < ? AND status = 1;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT id, resourceId, resourceInfo, planProductId, planProductName, serverProductId, serverProductName, module1Name, module2Name, module3Name, module1, module2, module3, cpu, memory, gpu, storage, snapshotSize, isRapidDeploy, isScale, isMigrateToHost, migrateToHostTime, lastBalanceTime, status, createTime, updateTime, desc FROM cSnapBalance WHERE resourceId = ? AND lastBalanceTime < ? AND status = 1;",
            "match_result": {
              "matched": false,
              "fingerprint": "70a5e6cc4a26fdf65c3746058737dd1c",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/image_snap_rollback.go:16:29:QueryImageSnapRollbackByStatus",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：QueryImageSnapRollbackByStatus\nfunc (r *ImageSnapRollbackRepo) QueryImageSnapRollbackByStatus(ctx context.Context, status string) ([]*des.TCbsImageSnapRollbackRecord, error) {\n\tdb, err := r.getDesDb(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar rollbackList []*des.TCbsImageSnapRollbackRecord\n\n\tresult := db.Where(\"status = ?\", status).Find(&rollbackList)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\treturn rollbackList, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_rollback_task_scanner.go\", \"code_start_line\": 72, \"code_end_line\": 101, \"code_key\": \"getImageSnapRollbackTask\", \"code_value\": \"func (s *UpdateRollbackTaskScanner) getImageSnapRollbackTask(ctx context.Context) error {\\n\\t// ImageSnapRecord表回滚进度更新任务\\n\\timageSnapRbRepo := registry.GetRegistry(ctx).AdapterRepos.ImageSnapRollbackRepo.(adapter_interfaces.ImageSnapRollbackInterface)\\n\\timageSnapRbList, err := imageSnapRbRepo.QueryImageSnapRollbackByStatus(ctx, des.ImageSnapRbMigrating)\\n\\tif err != nil {\\n\\t\\treturn err\\n\\t}\\n\\tfor _, imageSnapRbRecord := range imageSnapRbList {\\n\\t\\tentity := &diskLogical.RollbackingEntity{\\n\\t\\t\\tImageSnapRollbackRecord: imageSnapRbRecord,\\n\\t\\t}\\n\\t\\trollbackType := entity.GetRollbackType()\\n\\t\\tsubTaskName := core.UpdateOrderRBTask\\n\\t\\tif rollbackType == des.FastRollback {\\n\\t\\t\\tsubTaskName = core.UpdateFastRBTask\\n\\t\\t} else if rollbackType == des.ImageCache {\\n\\t\\t\\tsubTaskName = core.UpdateTriggerRBTask\\n\\t\\t} else {\\n\\t\\t\\tsubTaskName = core.UpdateOrderRBTask\\n\\t\\t}\\n\\t\\tdiskRollbackAgg := &diskLogical.DiskRollbackingTaskAggregate{\\n\\t\\t\\tDiskEntity:        nil,\\n\\t\\t\\tRollbackingEntity: entity,\\n\\t\\t\\tTaskName:          core.UpdateImageSnapRBTask,\\n\\t\\t\\tSubTaskName:       subTaskName,\\n\\t\\t}\\n\\t\\ts.resultChan <- diskRollbackAgg\\n\\t}\\n\\treturn nil\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/image_snap_rollback.go\",\n    \"code_start_line\": 16,\n    \"code_end_line\": 29,\n    \"code_key\": \"QueryImageSnapRollbackByStatus\",\n    \"code_value\": \"func (r *ImageSnapRollbackRepo) QueryImageSnapRollbackByStatus(ctx context.Context, status string) ([]*des.TCbsImageSnapRollbackRecord, error) {\\n\\tdb, err := r.getDesDb(ctx)\\n\\tif err != nil {\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\tvar rollbackList []*des.TCbsImageSnapRollbackRecord\\n\\n\\tresult := db.Where(\\\"status = ?\\\", status).Find(&rollbackList)\\n\\tif result.Error != nil {\\n\\t\\treturn nil, result.Error\\n\\t}\\n\\treturn rollbackList, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM t_cbs_image_snap_rollback_record WHERE status = ?;\"]",
      "parsed_sql": [
        "SELECT * FROM t_cbs_image_snap_rollback_record WHERE status = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM t_cbs_image_snap_rollback_record WHERE status = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "e42b2810806fe7751ab1356c066bc3b6",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/image_snap_rollback.go:31:49:UpdateImageSnapRollbackPercent",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：UpdateImageSnapRollbackPercent\nfunc (r *ImageSnapRollbackRepo) UpdateImageSnapRollbackPercent(ctx context.Context, imageSnapRbRecord *des.TCbsImageSnapRollbackRecord) error {\n\tdb, err := r.getDesDb(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tchanges := make(map[string]interface{})\n\tchanges[\"percent\"] = imageSnapRbRecord.Percent\n\tchanges[\"status\"] = imageSnapRbRecord.Status\n\tif imageSnapRbRecord.Status == des.ImageSnapRbDone {\n\t\timageSnapRbRecord.EndTime = time.Now()\n\t\tchanges[\"endTime\"] = imageSnapRbRecord.EndTime\n\t}\n\tresult := db.Model(imageSnapRbRecord).Where(\"id = ?\", imageSnapRbRecord.Id).Updates(changes)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/domain/diskLogical/service.go\", \"code_start_line\": 56, \"code_end_line\": 106, \"code_key\": \"UpdateImageSnapRollbackingPercent\", \"code_value\": \"func (s *DiskRollbackingServicesImpl) UpdateImageSnapRollbackingPercent(ctx context.Context, agg *DiskRollbackingTaskAggregate) (bool, error) {\\n\\tisFinish := false\\n\\n\\tpercent := -1 // -1不会更新表中的内容\\n\\trStatus := des.ImageSnapRbMigrating\\n\\n\\tshmSrv := common.ShmConfService{}\\n\\tlockTime := time.Now().Truncate(shmSrv.GetTriggerTaskLockTime(ctx))\\n\\n\\tif agg.SubTaskName == core.UpdateTriggerRBTask && agg.ImageSnapRollbackRecord.StartTime.Before(lockTime) {\\n\\t\\t// 长时间未完成的trigger任务直接置为done\\n\\t\\tlogs.Info(ctx).Interface(\\\"StartTime\\\", agg.ImageSnapRollbackRecord.StartTime).Msg(\\\"MARK_TRIGGER_ROLLBACK_FINISHED\\\")\\n\\t\\trStatus = des.ImageSnapRbDone\\n\\t} else {\\n\\t\\tsnapPhySrv := registry.GetRegistry(ctx).DomainServices.SnapPhyService.(snapPhysical.SnapPhyServiceInterface)\\n\\t\\trsp, err := snapPhySrv.QueryDiskRollbackingPercent(ctx, agg.ImageSnapRollbackRecord.AppId, agg.ImageSnapRollbackRecord.CbsUuid, agg.ImageSnapRollbackRecord.ArchType)\\n\\t\\tif err != nil {\\n\\t\\t\\treturn false, err\\n\\t\\t}\\n\\n\\t\\tpercent = rsp.Percent\\n\\t\\ttaskStatus := rsp.Status\\n\\t\\tif taskStatus == 1 {\\n\\t\\t\\t// 已完成回滚，盘的状态为正常\\n\\t\\t\\tpercent = 100\\n\\t\\t} else if taskStatus == 2 {\\n\\t\\t\\tpercent = 0\\n\\t\\t} else if taskStatus == 3 {\\n\\t\\t\\tif agg.ImageSnapRollbackRecord.Percent > percent {\\n\\t\\t\\t\\t// 如果更新的进度小于已经记录的进度，\\n\\t\\t\\t\\t// 说明用户可能发起了多次重装，当前的record已经被重置了，直接标记为已完成。\\n\\t\\t\\t\\tlogs.Info(ctx).Int(\\\"OldPercent\\\", agg.ImageSnapRollbackRecord.Percent).Int(\\\"NewPercent\\\", percent).Msg(\\\"IMAGE_SNAP_MIGR_REC_EXPIRED\\\")\\n\\t\\t\\t\\tpercent = 100\\n\\t\\t\\t}\\n\\t\\t} else if taskStatus == 5 {\\n\\t\\t\\t// 取消任务时直接标记为已完成\\n\\t\\t\\trStatus = des.ImageSnapRbDone\\n\\t\\t} else {\\n\\t\\t\\tpercent = 100\\n\\t\\t\\tlogs.Error(ctx).Int(\\\"TaskStatus\\\", taskStatus).Msg(\\\"UNKNOWN_STATUS\\\")\\n\\t\\t}\\n\\t}\\n\\terr := agg.UpdateImageSnapRollbackingPercent(ctx, percent, rStatus)\\n\\tif err != nil {\\n\\t\\treturn false, err\\n\\t}\\n\\tif percent >= 100 || rStatus == des.ImageSnapRbDone {\\n\\t\\tisFinish = true\\n\\t}\\n\\treturn isFinish, err\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/image_snap_rollback.go\",\n    \"code_start_line\": 31,\n    \"code_end_line\": 49,\n    \"code_key\": \"UpdateImageSnapRollbackPercent\",\n    \"code_value\": \"func (r *ImageSnapRollbackRepo) UpdateImageSnapRollbackPercent(ctx context.Context, imageSnapRbRecord *des.TCbsImageSnapRollbackRecord) error {\\n\\tdb, err := r.getDesDb(ctx)\\n\\tif err != nil {\\n\\t\\treturn err\\n\\t}\\n\\n\\tchanges := make(map[string]interface{})\\n\\tchanges[\\\"percent\\\"] = imageSnapRbRecord.Percent\\n\\tchanges[\\\"status\\\"] = imageSnapRbRecord.Status\\n\\tif imageSnapRbRecord.Status == des.ImageSnapRbDone {\\n\\t\\timageSnapRbRecord.EndTime = time.Now()\\n\\t\\tchanges[\\\"endTime\\\"] = imageSnapRbRecord.EndTime\\n\\t}\\n\\tresult := db.Model(imageSnapRbRecord).Where(\\\"id = ?\\\", imageSnapRbRecord.Id).Updates(changes)\\n\\tif result.Error != nil {\\n\\t\\treturn result.Error\\n\\t}\\n\\treturn nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"状态不是完成状态时\", \"sql\": \"UPDATE t_cbs_image_snap_rollback_record SET percent = ?, status = ? WHERE id = ?;\"}, {\"scenario\": \"状态是完成状态时\", \"sql\": \"UPDATE t_cbs_image_snap_rollback_record SET end_time = ?, percent = ?, status = ? WHERE id = ?;\"}]}]",
      "parsed_sql": [
        "UPDATE t_cbs_image_snap_rollback_record SET percent = ?, status = ? WHERE id = ?;",
        "UPDATE t_cbs_image_snap_rollback_record SET end_time = ?, percent = ?, status = ? WHERE id = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 2,
        "valid_sql": 2,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "UPDATE t_cbs_image_snap_rollback_record SET percent = ?, status = ? WHERE id = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "7b83eeb7f21aeb5d37612cf8ff487b16",
              "excluded": false
            }
          },
          {
            "sql": "UPDATE t_cbs_image_snap_rollback_record SET end_time = ?, percent = ?, status = ? WHERE id = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "7b83eeb7f21aeb5d37612cf8ff487b16",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/uow.go:96:106:New",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：New\nfunc (u unitOfWorkFactoryImpl) New() dddcore.UnitOfWork {\n\tuow := &unitOfWork{\n\t\ttx:                    u.db.Begin(),\n\t\ttrackedPhyVolumes:     newTracker[*rdiskDomain.PhysicalVolume](updatePhysicalVolume),\n\t\ttrackedLogicalVolumes: newTracker[*rdiskDomain.LogicalVolume](updateLogicalVolume),\n\t\ttrackedDRGroups:       newTracker[*drgroup.DRGroup](updateDRGroup),\n\t\ttrackedBackups:        newTracker[*backup.Backup](updateBackup),\n\t\ttrackedBenchmarks:     newTracker[*benchmark.Benchmark](updateBenchmark),\n\t}\n\treturn uow\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/cmd/main.go\", \"code_start_line\": 21, \"code_end_line\": 26, \"code_key\": \"main\", \"code_value\": \"func main() {\\n\\tif err := rootCmd.Execute(); err != nil {\\n\\t\\t_, _ = fmt.Fprintf(os.Stderr, \\\"cbs_packing_srv run failed %s\\\\n\\\", err)\\n\\t\\tos.Exit(-1)\\n\\t}\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/uow.go\",\n    \"code_start_line\": 96,\n    \"code_end_line\": 106,\n    \"code_key\": \"New\",\n    \"code_value\": \"func (u unitOfWorkFactoryImpl) New() dddcore.UnitOfWork {\\n\\tuow := &unitOfWork{\\n\\t\\ttx:                    u.db.Begin(),\\n\\t\\ttrackedPhyVolumes:     newTracker[*rdiskDomain.PhysicalVolume](updatePhysicalVolume),\\n\\t\\ttrackedLogicalVolumes: newTracker[*rdiskDomain.LogicalVolume](updateLogicalVolume),\\n\\t\\ttrackedDRGroups:       newTracker[*drgroup.DRGroup](updateDRGroup),\\n\\t\\ttrackedBackups:        newTracker[*backup.Backup](updateBackup),\\n\\t\\ttrackedBenchmarks:     newTracker[*benchmark.Benchmark](updateBenchmark),\\n\\t}\\n\\treturn uow\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"BEGIN;\"]",
      "parsed_sql": [
        "BEGIN;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 0,
        "matched_sql": 0,
        "excluded_sql": 1,
        "fingerprint_results": [
          {
            "sql": "BEGIN;",
            "match_result": {
              "matched": false,
              "excluded": true,
              "fingerprint": "transaction_begin",
              "excluded_reason": "排除的SQL类型"
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/backup/models.go:137:142:New",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：New\nfunc New(appId users.AppID, diskInfo DiskInfo) *Backup {\n\tif defaultFactory == nil {\n\t\tpanic(\"defaultFactory is nil\")\n\t}\n\treturn defaultFactory.Create(appId, diskInfo)\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/cmd/main.go\", \"code_start_line\": 21, \"code_end_line\": 26, \"code_key\": \"main\", \"code_value\": \"func main() {\\n\\tif err := rootCmd.Execute(); err != nil {\\n\\t\\t_, _ = fmt.Fprintf(os.Stderr, \\\"cbs_packing_srv run failed %s\\\\n\\\", err)\\n\\t\\tos.Exit(-1)\\n\\t}\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/domain/backup/models.go\",\n    \"code_start_line\": 137,\n    \"code_end_line\": 142,\n    \"code_key\": \"New\",\n    \"code_value\": \"func New(appId users.AppID, diskInfo DiskInfo) *Backup {\\n\\tif defaultFactory == nil {\\n\\t\\tpanic(\\\"defaultFactory is nil\\\")\\n\\t}\\n\\treturn defaultFactory.Create(appId, diskInfo)\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"defaultFactory is not nil\", \"sql\": \"\"}]}]",
      "parsed_sql": [],
      "sql_evaluation": {},
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/common/clients/cos/client.go:101:104:DeleteObject",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：DeleteObject\nfunc (c *clientImpl) DeleteObject(ctx context.Context, key string) error {\n\t_, err := c.c.Object.Delete(ctx, key)\n\treturn err\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/common/clients/cos/client.go\",\n    \"code_start_line\": 101,\n    \"code_end_line\": 104,\n    \"code_key\": \"DeleteObject\",\n    \"code_value\": \"func (c *clientImpl) DeleteObject(ctx context.Context, key string) error {\\n\\t_, err := c.c.Object.Delete(ctx, key)\\n\\treturn err\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"删除指定key的文件\", \"sql\": \"DELETE FROM file WHERE key = ?;\"}]}]",
      "parsed_sql": [
        "DELETE FROM file WHERE key = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 0,
        "matched_sql": 0,
        "excluded_sql": 1,
        "fingerprint_results": [
          {
            "sql": "DELETE FROM file WHERE key = ?;",
            "match_result": {
              "matched": false,
              "excluded": true,
              "fingerprint": "invalid_sql",
              "excluded_reason": "排除的SQL类型"
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go:208:215:deleteFinishTask",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：deleteFinishTask\nfunc (sc *Scheduler) deleteFinishTask(ctx context.Context, task interfaces.Task) {\n\tsubTaskName := task.GetSubTaskName()\n\tif _, ok := sc.metrics.taskExecuteCountMap[subTaskName]; !ok {\n\t\tsc.metrics.taskExecuteCountMap[subTaskName], _ = initHistogramVec(subTaskName).GetMetricWith(sc.metrics.labels)\n\t}\n\tsc.metrics.taskExecuteCountMap[subTaskName].Observe(float64(task.GetExecuteCounts()))\n\tsc.taskMap.Delete(task.GetTaskId())\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go\", \"code_start_line\": 240, \"code_end_line\": 261, \"code_key\": \"processTask\", \"code_value\": \"func (sc *Scheduler) processTask(ctx context.Context, task interfaces.Task) {\\n\\tif sc.checkTaskChange(ctx, task) {\\n\\t\\tsc.releaseWorker(ctx)\\n\\t\\treturn\\n\\t}\\n\\tisFinish, err := task.Execute(ctx)\\n\\tif err != nil {\\n\\t\\t// 执行出现异常时，等待下次重试\\n\\t\\tlogs.Error(ctx).Str(\\\"error\\\", err.Error()).Msg(\\\"EXECUTE_TASK_FAILED\\\")\\n\\t\\tisFinish = false\\n\\t}\\n\\tif isFinish {\\n\\t\\t// 任务已完成\\n\\t\\tsc.deleteFinishTask(ctx, task)\\n\\t} else {\\n\\t\\t// 未完成，更新下次执行时间\\n\\t\\ttask.UpdateExecuteTime(ctx)\\n\\t\\t// 重新放入队列\\n\\t\\tsc.rePushTask(ctx, task)\\n\\t}\\n\\tsc.releaseWorker(ctx)\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go\",\n    \"code_start_line\": 208,\n    \"code_end_line\": 215,\n    \"code_key\": \"deleteFinishTask\",\n    \"code_value\": \"func (sc *Scheduler) deleteFinishTask(ctx context.Context, task interfaces.Task) {\\n\\tsubTaskName := task.GetSubTaskName()\\n\\tif _, ok := sc.metrics.taskExecuteCountMap[subTaskName]; !ok {\\n\\t\\tsc.metrics.taskExecuteCountMap[subTaskName], _ = initHistogramVec(subTaskName).GetMetricWith(sc.metrics.labels)\\n\\t}\\n\\tsc.metrics.taskExecuteCountMap[subTaskName].Observe(float64(task.GetExecuteCounts()))\\n\\tsc.taskMap.Delete(task.GetTaskId())\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM users WHERE status = 'active';\", {\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"按用户ID查询\", \"sql\": \"SELECT * FROM users WHERE id = ?;\"}, {\"scenario\": \"按用户名查询\", \"sql\": \"SELECT * FROM users WHERE username = ?;\"}]}]",
      "parsed_sql": [
        "SELECT * FROM users WHERE status = 'active';",
        "SELECT * FROM users WHERE id = ?;",
        "SELECT * FROM users WHERE username = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 3,
        "valid_sql": 3,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM users WHERE status = 'active';",
            "match_result": {
              "matched": false,
              "fingerprint": "330325e915b95eba361b58db8d26741c",
              "excluded": false
            }
          },
          {
            "sql": "SELECT * FROM users WHERE id = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "de9db2d948496f93e45a219c374dbe6d",
              "excluded": false
            }
          },
          {
            "sql": "SELECT * FROM users WHERE username = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "04e7be3825a0e67a84996a7303d69f06",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/app/dispatcher/dispatcher.go:33:103:Dispatch",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：Dispatch\nfunc (d *dispatcherImpl) Dispatch(ctx context.Context, cmd app.Command) (err error) {\n\t// 为什么使用 backgroundCtx 而不是 ctx？\n\t// 因为 ctx 代表调用方的上下文，通常是 rpc 请求上下文。\n\t// 而执行命令的上下文，应该是一个独立的上下文，不应该受到调用方的影响\n\t// 即使由于网络抖动等原因，调用方的上下文已经超时，但是命令执行的上下文仍然应该继续执行。\n\tworkerCtx := context.WithValue(d.backgroundCtx, ctxKeyCommand, cmd)\n\tworkerCtx, cancelFunc := context.WithTimeout(workerCtx, d.workerTimeout)\n\tworkerCtx = logs.GetLogger(ctx).WithContext(workerCtx)\n\tlockKeys := cmd.LockKeys()\n\terrChan := make(chan error, 1)\n\tlockOption := &dlock.Option{\n\t\tRetryStrategy: dlock.ExponentialBackoff(100*time.Millisecond, 6*time.Second),\n\t}\n\td.wg.Add(1)\n\t// 最终打印错误\n\t// TODO: 并发控制最大能同时执行的命令数量\n\tgo func() {\n\t\tdefer d.wg.Done()\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\te, ok := err.(error)\n\t\t\t\tif !ok {\n\t\t\t\t\te = errors.Newf(ErrDispatchPanic, \"dispatcher panic: %v\", err)\n\t\t\t\t}\n\t\t\t\terrChan <- e\n\t\t\t\tlogs.Error(workerCtx).Err(e).Stack().Bytes(\"trace\", debug.Stack()).Msgf(\"command execution panic\")\n\t\t\t}\n\t\t}()\n\n\t\tdefer cancelFunc()\n\n\t\tif lockKeys != nil {\n\t\t\tlock, err := d.locker.ObtainMulti(workerCtx, lockKeys, d.workerTimeout, lockOption)\n\t\t\tif err != nil {\n\t\t\t\terrChan <- err\n\t\t\t\tlogs.Warn(workerCtx).Err(err).Msgf(\"command execution waiting locks timeout\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer lock.Release(workerCtx)\n\t\t}\n\n\t\tuow := app.GetRegistry(ctx).Repositories.UoWFactory.New()\n\t\tworkerCtx = app.GetRegistry(ctx).Repositories.UoWFactory.With(workerCtx, uow)\n\n\t\terr = cmd.Handle(workerCtx)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, errors.ErrDryRunSuccessExit) {\n\t\t\t\terr = nil\n\t\t\t} else {\n\t\t\t\tlogs.Warn(workerCtx).Err(err).Msgf(\"command execution failed\")\n\t\t\t}\n\t\t\t_err := uow.Rollback(workerCtx)\n\t\t\tif _err != nil {\n\t\t\t\tlogs.Error(workerCtx).Err(_err).Msgf(\"unit of work rollback failed\")\n\t\t\t}\n\t\t} else {\n\t\t\terr = uow.Commit(workerCtx)\n\t\t\tif err != nil {\n\t\t\t\tlogs.Error(workerCtx).Err(err).Msgf(\"unit of work commit failed\")\n\t\t\t}\n\t\t}\n\t\terrChan <- err\n\t\tclose(errChan)\n\t}()\n\tselect {\n\tcase err := <-errChan:\n\t\treturn err\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\t}\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go\", \"code_start_line\": 644, \"code_end_line\": 646, \"code_key\": \"CreateRDiskVol\", \"code_value\": \"func (s *UnimplementedMaster) CreateRDiskVol(ctx context.Context, req *CreateRDiskVolRequest) (*CreateRDiskVolResponse, error) {\\n\\treturn nil, errors.New(\\\"rpc CreateRDiskVol of service Master is not implemented\\\")\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/app/dispatcher/dispatcher.go\",\n    \"code_start_line\": 33,\n    \"code_end_line\": 103,\n    \"code_key\": \"Dispatch\",\n    \"code_value\": \"func (d *dispatcherImpl) Dispatch(ctx context.Context, cmd app.Command) (err error) {\\n\\t// 为什么使用 backgroundCtx 而不是 ctx？\\n\\t// 因为 ctx 代表调用方的上下文，通常是 rpc 请求上下文。\\n\\t// 而执行命令的上下文，应该是一个独立的上下文，不应该受到调用方的影响\\n\\t// 即使由于网络抖动等原因，调用方的上下文已经超时，但是命令执行的上下文仍然应该继续执行。\\n\\tworkerCtx := context.WithValue(d.backgroundCtx, ctxKeyCommand, cmd)\\n\\tworkerCtx, cancelFunc := context.WithTimeout(workerCtx, d.workerTimeout)\\n\\tworkerCtx = logs.GetLogger(ctx).WithContext(workerCtx)\\n\\tlockKeys := cmd.LockKeys()\\n\\terrChan := make(chan error, 1)\\n\\tlockOption := &dlock.Option{\\n\\t\\tRetryStrategy: dlock.ExponentialBackoff(100*time.Millisecond, 6*time.Second),\\n\\t}\\n\\td.wg.Add(1)\\n\\t// 最终打印错误\\n\\t// TODO: 并发控制最大能同时执行的命令数量\\n\\tgo func() {\\n\\t\\tdefer d.wg.Done()\\n\\t\\tdefer func() {\\n\\t\\t\\tif err := recover(); err != nil {\\n\\t\\t\\t\\te, ok := err.(error)\\n\\t\\t\\t\\tif !ok {\\n\\t\\t\\t\\t\\te = errors.Newf(ErrDispatchPanic, \\\"dispatcher panic: %v\\\", err)\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\terrChan <- e\\n\\t\\t\\t\\tlogs.Error(workerCtx).Err(e).Stack().Bytes(\\\"trace\\\", debug.Stack()).Msgf(\\\"command execution panic\\\")\\n\\t\\t\\t}\\n\\t\\t}()\\n\\n\\t\\tdefer cancelFunc()\\n\\n\\t\\tif lockKeys != nil {\\n\\t\\t\\tlock, err := d.locker.ObtainMulti(workerCtx, lockKeys, d.workerTimeout, lockOption)\\n\\t\\t\\tif err != nil {\\n\\t\\t\\t\\terrChan <- err\\n\\t\\t\\t\\tlogs.Warn(workerCtx).Err(err).Msgf(\\\"command execution waiting locks timeout\\\")\\n\\t\\t\\t\\treturn\\n\\t\\t\\t}\\n\\t\\t\\tdefer lock.Release(workerCtx)\\n\\t\\t}\\n\\n\\t\\tuow := app.GetRegistry(ctx).Repositories.UoWFactory.New()\\n\\t\\tworkerCtx = app.GetRegistry(ctx).Repositories.UoWFactory.With(workerCtx, uow)\\n\\n\\t\\terr = cmd.Handle(workerCtx)\\n\\t\\tif err != nil {\\n\\t\\t\\tif errors.IsCode(err, errors.ErrDryRunSuccessExit) {\\n\\t\\t\\t\\terr = nil\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlogs.Warn(workerCtx).Err(err).Msgf(\\\"command execution failed\\\")\\n\\t\\t\\t}\\n\\t\\t\\t_err := uow.Rollback(workerCtx)\\n\\t\\t\\tif _err != nil {\\n\\t\\t\\t\\tlogs.Error(workerCtx).Err(_err).Msgf(\\\"unit of work rollback failed\\\")\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\terr = uow.Commit(workerCtx)\\n\\t\\t\\tif err != nil {\\n\\t\\t\\t\\tlogs.Error(workerCtx).Err(err).Msgf(\\\"unit of work commit failed\\\")\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\terrChan <- err\\n\\t\\tclose(errChan)\\n\\t}()\\n\\tselect {\\n\\tcase err := <-errChan:\\n\\t\\treturn err\\n\\tcase <-ctx.Done():\\n\\t\\treturn ctx.Err()\\n\\t}\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"lockKeys为nil时\", \"sql\": \"SELECT * FROM table_name WHERE condition = ?;\"}, {\"scenario\": \"lockKeys不为nil时\", \"sql\": \"SELECT * FROM table_name WHERE condition = ? AND lock_key = ?;\"}]}]",
      "parsed_sql": [
        "SELECT * FROM table_name WHERE condition = ?;",
        "SELECT * FROM table_name WHERE condition = ? AND lock_key = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 2,
        "valid_sql": 2,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM table_name WHERE condition = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "bf51620caf683f35cda45f96c0b53b7b",
              "excluded": false
            }
          },
          {
            "sql": "SELECT * FROM table_name WHERE condition = ? AND lock_key = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "6e131b6b829c3301772e81d885084501",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/benchmark.go:17:29:Add",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：Add\nfunc (repo *rdiskBenchmarkRepositoryImpl) Add(ctx context.Context, bench *benchmark.Benchmark) error {\n\tdo := repo.fromModelToDO(bench)\n\tuow := getUow(ctx)\n\tdo.Created = uow.tx.NowFunc()\n\tdo.Updated = uow.tx.NowFunc()\n\tresult := uow.tx.Create(&do)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tbench.ID = do.ID\n\tuow.trackedBenchmarks.Add(bench)\n\treturn nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/infra/event_bus/bus.go\", \"code_start_line\": 61, \"code_end_line\": 79, \"code_key\": \"Execute\", \"code_value\": \"func (eb *EventBusDriver) Execute(ctx context.Context) (result *response.Result) {\\n\\tresult = response.DefaultResult()\\n\\tdefer utils.HandlePanic(ctx, &result)\\n\\n\\tfor _, event := range eb.BlockEventQueue {\\n\\t\\tresult = eb.ExecuteOne(ctx, event)\\n\\t\\tif result.IsSuccess() {\\n\\t\\t\\tevent.UpdateState(ctx, Executed)\\n\\t\\t} else {\\n\\t\\t\\tlogs.Warn(ctx).Err(result).Int(\\\"EventType\\\", int(event.GetType(ctx))).\\n\\t\\t\\t\\tMsg(\\\"event execute failed, start rollback event bus\\\")\\n\\t\\t\\tif err := eb.RollbackEvents(ctx); err != nil {\\n\\t\\t\\t\\tlogs.Error(ctx).Err(err).Int(\\\"EventType\\\", int(event.GetType(ctx))).Msg(\\\"rollback event bus failed\\\")\\n\\t\\t\\t}\\n\\t\\t\\treturn result\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/benchmark.go\",\n    \"code_start_line\": 17,\n    \"code_end_line\": 29,\n    \"code_key\": \"Add\",\n    \"code_value\": \"func (repo *rdiskBenchmarkRepositoryImpl) Add(ctx context.Context, bench *benchmark.Benchmark) error {\\n\\tdo := repo.fromModelToDO(bench)\\n\\tuow := getUow(ctx)\\n\\tdo.Created = uow.tx.NowFunc()\\n\\tdo.Updated = uow.tx.NowFunc()\\n\\tresult := uow.tx.Create(&do)\\n\\tif result.Error != nil {\\n\\t\\treturn result.Error\\n\\t}\\n\\tbench.ID = do.ID\\n\\tuow.trackedBenchmarks.Add(bench)\\n\\treturn nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"INSERT INTO benchmark (created, updated) VALUES (?, ?);\"]",
      "parsed_sql": [
        "INSERT INTO benchmark (created, updated) VALUES (?, ?);"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "INSERT INTO benchmark (created, updated) VALUES (?, ?);",
            "match_result": {
              "matched": false,
              "fingerprint": "8bb0b8bf141be0600fcc0db8685e988c",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/backup.go:19:31:Add",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：Add\nfunc (repo *rdiskBackupRepositoryImpl) Add(ctx context.Context, backup *backupPkg.Backup) error {\n\tuow := getUow(ctx)\n\tdo := repo.fromModelToDO(backup)\n\tdo.Created = uow.tx.NowFunc()\n\tdo.Updated = uow.tx.NowFunc()\n\tresult := uow.tx.Create(&do)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tbackup.ID = do.ID\n\tuow.trackedBackups.Add(backup)\n\treturn nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/infra/event_bus/bus.go\", \"code_start_line\": 61, \"code_end_line\": 79, \"code_key\": \"Execute\", \"code_value\": \"func (eb *EventBusDriver) Execute(ctx context.Context) (result *response.Result) {\\n\\tresult = response.DefaultResult()\\n\\tdefer utils.HandlePanic(ctx, &result)\\n\\n\\tfor _, event := range eb.BlockEventQueue {\\n\\t\\tresult = eb.ExecuteOne(ctx, event)\\n\\t\\tif result.IsSuccess() {\\n\\t\\t\\tevent.UpdateState(ctx, Executed)\\n\\t\\t} else {\\n\\t\\t\\tlogs.Warn(ctx).Err(result).Int(\\\"EventType\\\", int(event.GetType(ctx))).\\n\\t\\t\\t\\tMsg(\\\"event execute failed, start rollback event bus\\\")\\n\\t\\t\\tif err := eb.RollbackEvents(ctx); err != nil {\\n\\t\\t\\t\\tlogs.Error(ctx).Err(err).Int(\\\"EventType\\\", int(event.GetType(ctx))).Msg(\\\"rollback event bus failed\\\")\\n\\t\\t\\t}\\n\\t\\t\\treturn result\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/backup.go\",\n    \"code_start_line\": 19,\n    \"code_end_line\": 31,\n    \"code_key\": \"Add\",\n    \"code_value\": \"func (repo *rdiskBackupRepositoryImpl) Add(ctx context.Context, backup *backupPkg.Backup) error {\\n\\tuow := getUow(ctx)\\n\\tdo := repo.fromModelToDO(backup)\\n\\tdo.Created = uow.tx.NowFunc()\\n\\tdo.Updated = uow.tx.NowFunc()\\n\\tresult := uow.tx.Create(&do)\\n\\tif result.Error != nil {\\n\\t\\treturn result.Error\\n\\t}\\n\\tbackup.ID = do.ID\\n\\tuow.trackedBackups.Add(backup)\\n\\treturn nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"INSERT INTO backup (created, updated) VALUES (?, ?);\"]",
      "parsed_sql": [
        "INSERT INTO backup (created, updated) VALUES (?, ?);"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "INSERT INTO backup (created, updated) VALUES (?, ?);",
            "match_result": {
              "matched": false,
              "fingerprint": "52f04514fc924aac7ed50cbdc6cba8b2",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go:76:91:Add",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：Add\nfunc (l logicalVolumeRepositoryImpl) Add(ctx context.Context, lv *rdiskDomain.LogicalVolume) error {\n\tuow := getUow(ctx)\n\tvol := fromModelToDmRDisk(lv)\n\tvol.Created = uow.tx.NowFunc()\n\tvol.Updated = uow.tx.NowFunc()\n\tresult := uow.tx.Create(&vol)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tlv.ID = vol.ID\n\tlv = uow.trackedLogicalVolumes.Add(lv)\n\tif lv.PhysicalVolume != nil {\n\t\tlv.PhysicalVolume = uow.trackedPhyVolumes.Add(lv.PhysicalVolume)\n\t}\n\treturn nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/infra/event_bus/bus.go\", \"code_start_line\": 61, \"code_end_line\": 79, \"code_key\": \"Execute\", \"code_value\": \"func (eb *EventBusDriver) Execute(ctx context.Context) (result *response.Result) {\\n\\tresult = response.DefaultResult()\\n\\tdefer utils.HandlePanic(ctx, &result)\\n\\n\\tfor _, event := range eb.BlockEventQueue {\\n\\t\\tresult = eb.ExecuteOne(ctx, event)\\n\\t\\tif result.IsSuccess() {\\n\\t\\t\\tevent.UpdateState(ctx, Executed)\\n\\t\\t} else {\\n\\t\\t\\tlogs.Warn(ctx).Err(result).Int(\\\"EventType\\\", int(event.GetType(ctx))).\\n\\t\\t\\t\\tMsg(\\\"event execute failed, start rollback event bus\\\")\\n\\t\\t\\tif err := eb.RollbackEvents(ctx); err != nil {\\n\\t\\t\\t\\tlogs.Error(ctx).Err(err).Int(\\\"EventType\\\", int(event.GetType(ctx))).Msg(\\\"rollback event bus failed\\\")\\n\\t\\t\\t}\\n\\t\\t\\treturn result\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go\",\n    \"code_start_line\": 76,\n    \"code_end_line\": 91,\n    \"code_key\": \"Add\",\n    \"code_value\": \"func (l logicalVolumeRepositoryImpl) Add(ctx context.Context, lv *rdiskDomain.LogicalVolume) error {\\n\\tuow := getUow(ctx)\\n\\tvol := fromModelToDmRDisk(lv)\\n\\tvol.Created = uow.tx.NowFunc()\\n\\tvol.Updated = uow.tx.NowFunc()\\n\\tresult := uow.tx.Create(&vol)\\n\\tif result.Error != nil {\\n\\t\\treturn result.Error\\n\\t}\\n\\tlv.ID = vol.ID\\n\\tlv = uow.trackedLogicalVolumes.Add(lv)\\n\\tif lv.PhysicalVolume != nil {\\n\\t\\tlv.PhysicalVolume = uow.trackedPhyVolumes.Add(lv.PhysicalVolume)\\n\\t}\\n\\treturn nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"INSERT INTO logical_volume (created, updated) VALUES (?, ?);\"]",
      "parsed_sql": [
        "INSERT INTO logical_volume (created, updated) VALUES (?, ?);"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "INSERT INTO logical_volume (created, updated) VALUES (?, ?);",
            "match_result": {
              "matched": false,
              "fingerprint": "4e2f0e879916ae6e7669f8bf440f299f",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go:59:71:Add",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：Add\nfunc (p *physicalVolumeRepositoryImpl) Add(ctx context.Context, pv *rdiskDomain.PhysicalVolume) error {\n\tuow := getUow(ctx)\n\tvol := fromPhysicalVolumeToDmPhyDisk(ctx, pv)\n\tvol.Created = uow.tx.NowFunc()\n\tvol.Updated = uow.tx.NowFunc()\n\tresult := uow.tx.Create(&vol)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tpv.ID = vol.ID\n\tuow.trackedPhyVolumes.Add(pv)\n\treturn nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/infra/event_bus/bus.go\", \"code_start_line\": 61, \"code_end_line\": 79, \"code_key\": \"Execute\", \"code_value\": \"func (eb *EventBusDriver) Execute(ctx context.Context) (result *response.Result) {\\n\\tresult = response.DefaultResult()\\n\\tdefer utils.HandlePanic(ctx, &result)\\n\\n\\tfor _, event := range eb.BlockEventQueue {\\n\\t\\tresult = eb.ExecuteOne(ctx, event)\\n\\t\\tif result.IsSuccess() {\\n\\t\\t\\tevent.UpdateState(ctx, Executed)\\n\\t\\t} else {\\n\\t\\t\\tlogs.Warn(ctx).Err(result).Int(\\\"EventType\\\", int(event.GetType(ctx))).\\n\\t\\t\\t\\tMsg(\\\"event execute failed, start rollback event bus\\\")\\n\\t\\t\\tif err := eb.RollbackEvents(ctx); err != nil {\\n\\t\\t\\t\\tlogs.Error(ctx).Err(err).Int(\\\"EventType\\\", int(event.GetType(ctx))).Msg(\\\"rollback event bus failed\\\")\\n\\t\\t\\t}\\n\\t\\t\\treturn result\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go\",\n    \"code_start_line\": 59,\n    \"code_end_line\": 71,\n    \"code_key\": \"Add\",\n    \"code_value\": \"func (p *physicalVolumeRepositoryImpl) Add(ctx context.Context, pv *rdiskDomain.PhysicalVolume) error {\\n\\tuow := getUow(ctx)\\n\\tvol := fromPhysicalVolumeToDmPhyDisk(ctx, pv)\\n\\tvol.Created = uow.tx.NowFunc()\\n\\tvol.Updated = uow.tx.NowFunc()\\n\\tresult := uow.tx.Create(&vol)\\n\\tif result.Error != nil {\\n\\t\\treturn result.Error\\n\\t}\\n\\tpv.ID = vol.ID\\n\\tuow.trackedPhyVolumes.Add(pv)\\n\\treturn nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"INSERT INTO dm_phy_disk (created, updated) VALUES (?, ?);\"]",
      "parsed_sql": [
        "INSERT INTO dm_phy_disk (created, updated) VALUES (?, ?);"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "INSERT INTO dm_phy_disk (created, updated) VALUES (?, ?);",
            "match_result": {
              "matched": false,
              "fingerprint": "e63ca540744d7639e8e89d4b7692c786",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go:96:108:Add",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：Add\nfunc (d drgroupRepositoryImpl) Add(ctx context.Context, group *drgroup.DRGroup) error {\n\tuow := getUow(ctx)\n\tdo := fromModelToDmDRGroup(group)\n\tdo.Created = uow.tx.NowFunc()\n\tdo.Updated = uow.tx.NowFunc()\n\tresult := uow.tx.Clauses(clause.Insert{Modifier: \"IGNORE\"}).Create(&do)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tgroup.ID = do.ID\n\tuow.trackedDRGroups.Add(group)\n\treturn nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/infra/event_bus/bus.go\", \"code_start_line\": 61, \"code_end_line\": 79, \"code_key\": \"Execute\", \"code_value\": \"func (eb *EventBusDriver) Execute(ctx context.Context) (result *response.Result) {\\n\\tresult = response.DefaultResult()\\n\\tdefer utils.HandlePanic(ctx, &result)\\n\\n\\tfor _, event := range eb.BlockEventQueue {\\n\\t\\tresult = eb.ExecuteOne(ctx, event)\\n\\t\\tif result.IsSuccess() {\\n\\t\\t\\tevent.UpdateState(ctx, Executed)\\n\\t\\t} else {\\n\\t\\t\\tlogs.Warn(ctx).Err(result).Int(\\\"EventType\\\", int(event.GetType(ctx))).\\n\\t\\t\\t\\tMsg(\\\"event execute failed, start rollback event bus\\\")\\n\\t\\t\\tif err := eb.RollbackEvents(ctx); err != nil {\\n\\t\\t\\t\\tlogs.Error(ctx).Err(err).Int(\\\"EventType\\\", int(event.GetType(ctx))).Msg(\\\"rollback event bus failed\\\")\\n\\t\\t\\t}\\n\\t\\t\\treturn result\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go\",\n    \"code_start_line\": 96,\n    \"code_end_line\": 108,\n    \"code_key\": \"Add\",\n    \"code_value\": \"func (d drgroupRepositoryImpl) Add(ctx context.Context, group *drgroup.DRGroup) error {\\n\\tuow := getUow(ctx)\\n\\tdo := fromModelToDmDRGroup(group)\\n\\tdo.Created = uow.tx.NowFunc()\\n\\tdo.Updated = uow.tx.NowFunc()\\n\\tresult := uow.tx.Clauses(clause.Insert{Modifier: \\\"IGNORE\\\"}).Create(&do)\\n\\tif result.Error != nil {\\n\\t\\treturn result.Error\\n\\t}\\n\\tgroup.ID = do.ID\\n\\tuow.trackedDRGroups.Add(group)\\n\\treturn nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"INSERT IGNORE INTO dr_group (id, created, updated) VALUES (?, ?, ?);\"]",
      "parsed_sql": [
        "INSERT IGNORE INTO dr_group (id, created, updated) VALUES (?, ?, ?);"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "INSERT IGNORE INTO dr_group (id, created, updated) VALUES (?, ?, ?);",
            "match_result": {
              "matched": false,
              "fingerprint": "d5bb41c3085883c563e9ac8177f9ef24",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_physical_volume.go:113:131:checkExisting",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：checkExisting\nfunc (c *CreatePhysicalVolumeCommand) checkExisting(ctx context.Context, vol *domain.PhysicalVolume) (existed bool, err error) {\n\tif vol == nil {\n\t\treturn false, nil\n\t}\n\tif vol.Deleted() {\n\t\terr := app.GetRegistry(ctx).Repositories.PhysicalVolume.Delete(ctx, vol)\n\t\tif err != nil {\n\t\t\treturn false, errors.Newf(domain.ErrConflictVolume, \"failed to delete conflict physical volume: %v\", err)\n\t\t}\n\t\treturn false, nil\n\t}\n\tif string(vol.Serial) != c.Serial {\n\t\treturn false, errors.Newf(domain.ErrConflictVolume, \"host %s bdf %s has been taken by %s\", vol.IP, vol.BDF, vol.Serial)\n\t}\n\tif !vol.IP.Equal(c.Host) || string(vol.BDF) != c.BDF {\n\t\treturn false, errors.Newf(domain.ErrConflictVolume, \"volume %s has been assigned to host %s bdf %s\", vol.Serial, vol.IP, vol.BDF)\n\t}\n\treturn true, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go\", \"code_start_line\": 51, \"code_end_line\": 72, \"code_key\": \"Handle\", \"code_value\": \"func (c *CbsAppIdConsumer) Handle(ctx context.Context, delivery *rabbitmq.Delivery) error {\\n\\tu, chargeTime, err := c.ParseDelivery(ctx, delivery)\\n\\tif err != nil {\\n\\t\\treturn err\\n\\t}\\n\\tif u == nil {\\n\\t\\tlogs.Info(c.Ctx).\\n\\t\\t\\tTime(\\\"chargeTime\\\", chargeTime).\\n\\t\\t\\tMsg(\\\"USER_INFO_NOT_FOUND\\\")\\n\\t\\treturn nil\\n\\t}\\n\\n\\tchargeDetail := c.GetChargeDetailForSingleUser(u, chargeTime)\\n\\tif chargeDetail == nil {\\n\\t\\tlogs.Info(c.Ctx).\\n\\t\\t\\tUint64(\\\"appId\\\", uint64(u.AppId)).\\n\\t\\t\\tTime(\\\"chargeTime\\\", chargeTime).\\n\\t\\t\\tMsg(\\\"NO_RESOURCE_TO_CHARGE\\\")\\n\\t\\treturn nil\\n\\t}\\n\\treturn c.ProcessChargeDetail(chargeDetail)\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_physical_volume.go\",\n    \"code_start_line\": 113,\n    \"code_end_line\": 131,\n    \"code_key\": \"checkExisting\",\n    \"code_value\": \"func (c *CreatePhysicalVolumeCommand) checkExisting(ctx context.Context, vol *domain.PhysicalVolume) (existed bool, err error) {\\n\\tif vol == nil {\\n\\t\\treturn false, nil\\n\\t}\\n\\tif vol.Deleted() {\\n\\t\\terr := app.GetRegistry(ctx).Repositories.PhysicalVolume.Delete(ctx, vol)\\n\\t\\tif err != nil {\\n\\t\\t\\treturn false, errors.Newf(domain.ErrConflictVolume, \\\"failed to delete conflict physical volume: %v\\\", err)\\n\\t\\t}\\n\\t\\treturn false, nil\\n\\t}\\n\\tif string(vol.Serial) != c.Serial {\\n\\t\\treturn false, errors.Newf(domain.ErrConflictVolume, \\\"host %s bdf %s has been taken by %s\\\", vol.IP, vol.BDF, vol.Serial)\\n\\t}\\n\\tif !vol.IP.Equal(c.Host) || string(vol.BDF) != c.BDF {\\n\\t\\treturn false, errors.Newf(domain.ErrConflictVolume, \\\"volume %s has been assigned to host %s bdf %s\\\", vol.Serial, vol.IP, vol.BDF)\\n\\t}\\n\\treturn true, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"vol.Deleted()返回true时执行删除操作\", \"sql\": \"DELETE FROM physical_volume WHERE id = ?;\"}]}]",
      "parsed_sql": [
        "DELETE FROM physical_volume WHERE id = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "DELETE FROM physical_volume WHERE id = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "7a4993445e6a38839398227f45c2402d",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/create_logic_disk.go:61:63:InvokeDeleteLogicalVolume",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：InvokeDeleteLogicalVolume\nfunc InvokeDeleteLogicalVolume(ctx context.Context, source rdiskDomain.LogicalVolumeState, target rdiskDomain.LogicalVolumeState, stateCtx app.LogicalVolumeContext) (rdiskDomain.LogicalVolumeState, error) {\n\treturn target, stateCtx.GetLogicalVolume().Delete()\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/create_logic_disk.go\",\n    \"code_start_line\": 61,\n    \"code_end_line\": 63,\n    \"code_key\": \"InvokeDeleteLogicalVolume\",\n    \"code_value\": \"func InvokeDeleteLogicalVolume(ctx context.Context, source rdiskDomain.LogicalVolumeState, target rdiskDomain.LogicalVolumeState, stateCtx app.LogicalVolumeContext) (rdiskDomain.LogicalVolumeState, error) {\\n\\treturn target, stateCtx.GetLogicalVolume().Delete()\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"Delete logical volume with state context\", \"sql\": \"DELETE FROM logical_volume WHERE id = ?;\"}]}]",
      "parsed_sql": [
        "DELETE FROM logical_volume WHERE id = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "DELETE FROM logical_volume WHERE id = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "cf4707056c0d14c85946fc0eb718fe60",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go:48:132:StepGivenInitDB",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：StepGivenInitDB\nfunc StepGivenInitDB(t *testing.T) (*gorm.DB, string) {\n\tmysqlUrl := os.Getenv(\"CBS_TEST_MYSQL_URL\")\n\tif mysqlUrl == \"\" {\n\t\t// 默认使用这个配置，用 DOCKER 启动一个 MySQL 服务:\n\t\t// docker run -d --rm -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7\n\t\tuser := \"root\"\n\t\tpasswd := \"123456\"\n\t\thost := \"9.134.233.30\"\n\t\tport := 4567\n\t\tmysqlUrl = fmt.Sprintf(\"%s:%s@tcp(%s:%d)/?charset=utf8mb4&parseTime=True&loc=Local\",\n\t\t\tuser, passwd, host, port)\n\t}\n\tdatabase := os.Getenv(\"CBS_TEST_MYSQL_DATABASE\")\n\tif database == \"\" {\n\t\tdatabase = fmt.Sprintf(\"test-singularity-%d-%d\", 0, 0)\n\t}\n\n\tdb, err := gorm.Open(mysql.Open(mysqlUrl), &gorm.Config{})\n\tif err != nil {\n\t\tt.Skipf(\"failed to connect to mysql server: %s\", err)\n\t}\n\tassert.NoError(t, db.Exec(fmt.Sprintf(\"DROP DATABASE IF EXISTS `%s`\", database)).Error, \"failed to drop database\")\n\tassert.NoError(t, db.Exec(fmt.Sprintf(\"CREATE DATABASE `%s`\", database)).Error, \"failed to create database\")\n\n\t// 查找 `/?` 的位置\n\tindex := strings.Index(mysqlUrl, \"/?\")\n\tif index == -1 {\n\t\tfmt.Println(\"Invalid MySQL URL format\")\n\t}\n\t// 在 `/?` 之前插入数据库名称\n\tmysqlUrlWithDB := mysqlUrl[:index+1] + database + mysqlUrl[index+1:]\n\tdb, err = gorm.Open(mysql.Open(mysqlUrlWithDB), &gorm.Config{\n\t\tLogger: logger.Default.LogMode(logger.Silent),\n\t})\n\tif err != nil {\n\t\tt.Skipf(\"failed to connect to mysql server: %s\", err)\n\t}\n\tsqlDB, err := db.DB()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tsqlDB.SetMaxOpenConns(32)\n\n\tpath := \"../../../../changelog/db/metadb\"\n\tcontent := strings.Builder{}\n\terr = filepath.Walk(path, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !info.IsDir() {\n\t\t\tmatched, err := filepath.Match(\"*.sql\", info.Name())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif matched {\n\t\t\t\tsqlcontent, err := os.ReadFile(path)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tcontent.Write(sqlcontent)\n\t\t\t\tcontent.WriteString(\"\\n\")\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tpanic(fmt.Errorf(\"failed to read db file: %s\", err))\n\t}\n\tstmts := strings.Split(string(content.String()), \";\\n\")\n\tfor _, stmt := range stmts {\n\t\tstmt = strings.Trim(stmt, \" \\n\")\n\t\tif stmt == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tif strings.HasPrefix(stmt, \"USE \") {\n\t\t\t// Ignore USE statement\n\t\t\tcontinue\n\t\t}\n\t\terr = db.Exec(stmt).Error\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\treturn db, database\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go\",\n    \"code_start_line\": 48,\n    \"code_end_line\": 132,\n    \"code_key\": \"StepGivenInitDB\",\n    \"code_value\": \"func StepGivenInitDB(t *testing.T) (*gorm.DB, string) {\\n\\tmysqlUrl := os.Getenv(\\\"CBS_TEST_MYSQL_URL\\\")\\n\\tif mysqlUrl == \\\"\\\" {\\n\\t\\t// 默认使用这个配置，用 DOCKER 启动一个 MySQL 服务:\\n\\t\\t// docker run -d --rm -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7\\n\\t\\tuser := \\\"root\\\"\\n\\t\\tpasswd := \\\"123456\\\"\\n\\t\\thost := \\\"9.134.233.30\\\"\\n\\t\\tport := 4567\\n\\t\\tmysqlUrl = fmt.Sprintf(\\\"%s:%s@tcp(%s:%d)/?charset=utf8mb4&parseTime=True&loc=Local\\\",\\n\\t\\t\\tuser, passwd, host, port)\\n\\t}\\n\\tdatabase := os.Getenv(\\\"CBS_TEST_MYSQL_DATABASE\\\")\\n\\tif database == \\\"\\\" {\\n\\t\\tdatabase = fmt.Sprintf(\\\"test-singularity-%d-%d\\\", 0, 0)\\n\\t}\\n\\n\\tdb, err := gorm.Open(mysql.Open(mysqlUrl), &gorm.Config{})\\n\\tif err != nil {\\n\\t\\tt.Skipf(\\\"failed to connect to mysql server: %s\\\", err)\\n\\t}\\n\\tassert.NoError(t, db.Exec(fmt.Sprintf(\\\"DROP DATABASE IF EXISTS `%s`\\\", database)).Error, \\\"failed to drop database\\\")\\n\\tassert.NoError(t, db.Exec(fmt.Sprintf(\\\"CREATE DATABASE `%s`\\\", database)).Error, \\\"failed to create database\\\")\\n\\n\\t// 查找 `/?` 的位置\\n\\tindex := strings.Index(mysqlUrl, \\\"/?\\\")\\n\\tif index == -1 {\\n\\t\\tfmt.Println(\\\"Invalid MySQL URL format\\\")\\n\\t}\\n\\t// 在 `/?` 之前插入数据库名称\\n\\tmysqlUrlWithDB := mysqlUrl[:index+1] + database + mysqlUrl[index+1:]\\n\\tdb, err = gorm.Open(mysql.Open(mysqlUrlWithDB), &gorm.Config{\\n\\t\\tLogger: logger.Default.LogMode(logger.Silent),\\n\\t})\\n\\tif err != nil {\\n\\t\\tt.Skipf(\\\"failed to connect to mysql server: %s\\\", err)\\n\\t}\\n\\tsqlDB, err := db.DB()\\n\\tif err != nil {\\n\\t\\tpanic(err)\\n\\t}\\n\\tsqlDB.SetMaxOpenConns(32)\\n\\n\\tpath := \\\"../../../../changelog/db/metadb\\\"\\n\\tcontent := strings.Builder{}\\n\\terr = filepath.Walk(path, func(path string, info os.FileInfo, err error) error {\\n\\t\\tif err != nil {\\n\\t\\t\\treturn err\\n\\t\\t}\\n\\t\\tif !info.IsDir() {\\n\\t\\t\\tmatched, err := filepath.Match(\\\"*.sql\\\", info.Name())\\n\\t\\t\\tif err != nil {\\n\\t\\t\\t\\treturn err\\n\\t\\t\\t}\\n\\t\\t\\tif matched {\\n\\t\\t\\t\\tsqlcontent, err := os.ReadFile(path)\\n\\t\\t\\t\\tif err != nil {\\n\\t\\t\\t\\t\\treturn err\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcontent.Write(sqlcontent)\\n\\t\\t\\t\\tcontent.WriteString(\\\"\\\\n\\\")\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn nil\\n\\t})\\n\\tif err != nil {\\n\\t\\tpanic(fmt.Errorf(\\\"failed to read db file: %s\\\", err))\\n\\t}\\n\\tstmts := strings.Split(string(content.String()), \\\";\\\\n\\\")\\n\\tfor _, stmt := range stmts {\\n\\t\\tstmt = strings.Trim(stmt, \\\" \\\\n\\\")\\n\\t\\tif stmt == \\\"\\\" {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif strings.HasPrefix(stmt, \\\"USE \\\") {\\n\\t\\t\\t// Ignore USE statement\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\terr = db.Exec(stmt).Error\\n\\t\\tif err != nil {\\n\\t\\t\\tpanic(err)\\n\\t\\t}\\n\\t}\\n\\treturn db, database\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"DROP DATABASE IF EXISTS `test-singularity-0-0`;\", \"CREATE DATABASE `test-singularity-0-0`;\"]",
      "parsed_sql": [
        "DROP DATABASE IF EXISTS `test-singularity-0-0`;",
        "CREATE DATABASE `test-singularity-0-0`;"
      ],
      "sql_evaluation": {
        "total_sql": 2,
        "valid_sql": 0,
        "matched_sql": 0,
        "excluded_sql": 2,
        "fingerprint_results": [
          {
            "sql": "DROP DATABASE IF EXISTS `test-singularity-0-0`;",
            "match_result": {
              "matched": false,
              "excluded": true,
              "fingerprint": "ddl_command",
              "excluded_reason": "排除的SQL类型"
            }
          },
          {
            "sql": "CREATE DATABASE `test-singularity-0-0`;",
            "match_result": {
              "matched": false,
              "excluded": true,
              "fingerprint": "ddl_command",
              "excluded_reason": "排除的SQL类型"
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go:214:239:StepGivenAPhysicalVol",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：StepGivenAPhysicalVol\nfunc StepGivenAPhysicalVol(registry *app.Registry, value interface{}) *rdiskDomain.PhysicalVolume {\n\tphysicalVol := &rdiskDomain.PhysicalVolume{\n\t\tEntityMixin:  rdiskDomain.EntityMixin{ID: 1},\n\t\tSerial:       \"12345\",\n\t\tIP:           net.IP{127, 0, 0, 1},\n\t\tBDF:          \"bdf\",\n\t\tDiskID:       0,\n\t\tState:        rdiskDomain.PhysicalVolumeState(value.(int)),\n\t\tSize:         1,\n\t\tVolumeType:   \"NVME\",\n\t\tZoneID:       1,\n\t\tBlockSize:    512,\n\t\tRealSize:     5120,\n\t\tPort:         1,\n\t\tDataNodeType: \"unknown\",\n\t\tCuf:          \"清远-清新-C2\",\n\t}\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\terr := registry.Repositories.PhysicalVolume.Add(workerCtx, physicalVol)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn physicalVol\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go\",\n    \"code_start_line\": 214,\n    \"code_end_line\": 239,\n    \"code_key\": \"StepGivenAPhysicalVol\",\n    \"code_value\": \"func StepGivenAPhysicalVol(registry *app.Registry, value interface{}) *rdiskDomain.PhysicalVolume {\\n\\tphysicalVol := &rdiskDomain.PhysicalVolume{\\n\\t\\tEntityMixin:  rdiskDomain.EntityMixin{ID: 1},\\n\\t\\tSerial:       \\\"12345\\\",\\n\\t\\tIP:           net.IP{127, 0, 0, 1},\\n\\t\\tBDF:          \\\"bdf\\\",\\n\\t\\tDiskID:       0,\\n\\t\\tState:        rdiskDomain.PhysicalVolumeState(value.(int)),\\n\\t\\tSize:         1,\\n\\t\\tVolumeType:   \\\"NVME\\\",\\n\\t\\tZoneID:       1,\\n\\t\\tBlockSize:    512,\\n\\t\\tRealSize:     5120,\\n\\t\\tPort:         1,\\n\\t\\tDataNodeType: \\\"unknown\\\",\\n\\t\\tCuf:          \\\"清远-清新-C2\\\",\\n\\t}\\n\\tuow := registry.Repositories.UoWFactory.New()\\n\\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\\n\\terr := registry.Repositories.PhysicalVolume.Add(workerCtx, physicalVol)\\n\\terr = uow.Commit(workerCtx)\\n\\tif err != nil {\\n\\t\\tpanic(err)\\n\\t}\\n\\treturn physicalVol\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"INSERT INTO physical_volume (id, serial, ip, bdf, disk_id, state, size, volume_type, zone_id, block_size, real_size, port, data_node_type, cuf) VALUES (1, '12345', '127.0.0.1', 'bdf', 0, ?, 1, 'NVME', 1, 512, 5120, 1, 'unknown', '清远-清新-C2');\"]",
      "parsed_sql": [
        "INSERT INTO physical_volume (id, serial, ip, bdf, disk_id, state, size, volume_type, zone_id, block_size, real_size, port, data_node_type, cuf) VALUES (1, '12345', '127.0.0.1', 'bdf', 0, ?, 1, 'NVME', 1, 512, 5120, 1, 'unknown', '清远-清新-C2');"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "INSERT INTO physical_volume (id, serial, ip, bdf, disk_id, state, size, volume_type, zone_id, block_size, real_size, port, data_node_type, cuf) VALUES (1, '12345', '127.0.0.1', 'bdf', 0, ?, 1, 'NVME', 1, 512, 5120, 1, 'unknown', '清远-清新-C2');",
            "match_result": {
              "matched": false,
              "fingerprint": "f56774f1d734814599c3df1ff5836ddb",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go:244:277:StepGivenPhysicalVols",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：StepGivenPhysicalVols\nfunc StepGivenPhysicalVols(registry *app.Registry, value interface{}, num interface{}) []*rdiskDomain.PhysicalVolume {\n\tvar physicalVols []*rdiskDomain.PhysicalVolume\n\tfor i := 0; i < num.(int); i++ {\n\t\tphysicalVols = append(physicalVols, &rdiskDomain.PhysicalVolume{\n\t\t\tEntityMixin:  rdiskDomain.EntityMixin{},\n\t\t\tSerial:       rdiskDomain.Serial(\"111\" + strconv.Itoa(i)),\n\t\t\tIP:           net.IP{127, 0, byte(((i + 2) / 255) % 255), byte((i + 2) % 255)},\n\t\t\tBDF:          \"bdf\",\n\t\t\tDiskID:       0,\n\t\t\tState:        rdiskDomain.PhysicalVolumeState(value.(int)),\n\t\t\tSize:         1,\n\t\t\tVolumeType:   \"\",\n\t\t\tZoneID:       1,\n\t\t\tBlockSize:    512,\n\t\t\tRealSize:     5120,\n\t\t\tPort:         1,\n\t\t\tDataNodeType: \"\",\n\t\t\tCuf:          \"清远-清新-C2\",\n\t\t})\n\t}\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\tfor _, vol := range physicalVols {\n\t\terr := registry.Repositories.PhysicalVolume.Add(workerCtx, vol)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\terr := uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn physicalVols\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go\",\n    \"code_start_line\": 244,\n    \"code_end_line\": 277,\n    \"code_key\": \"StepGivenPhysicalVols\",\n    \"code_value\": \"func StepGivenPhysicalVols(registry *app.Registry, value interface{}, num interface{}) []*rdiskDomain.PhysicalVolume {\\n\\tvar physicalVols []*rdiskDomain.PhysicalVolume\\n\\tfor i := 0; i < num.(int); i++ {\\n\\t\\tphysicalVols = append(physicalVols, &rdiskDomain.PhysicalVolume{\\n\\t\\t\\tEntityMixin:  rdiskDomain.EntityMixin{},\\n\\t\\t\\tSerial:       rdiskDomain.Serial(\\\"111\\\" + strconv.Itoa(i)),\\n\\t\\t\\tIP:           net.IP{127, 0, byte(((i + 2) / 255) % 255), byte((i + 2) % 255)},\\n\\t\\t\\tBDF:          \\\"bdf\\\",\\n\\t\\t\\tDiskID:       0,\\n\\t\\t\\tState:        rdiskDomain.PhysicalVolumeState(value.(int)),\\n\\t\\t\\tSize:         1,\\n\\t\\t\\tVolumeType:   \\\"\\\",\\n\\t\\t\\tZoneID:       1,\\n\\t\\t\\tBlockSize:    512,\\n\\t\\t\\tRealSize:     5120,\\n\\t\\t\\tPort:         1,\\n\\t\\t\\tDataNodeType: \\\"\\\",\\n\\t\\t\\tCuf:          \\\"清远-清新-C2\\\",\\n\\t\\t})\\n\\t}\\n\\tuow := registry.Repositories.UoWFactory.New()\\n\\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\\n\\tfor _, vol := range physicalVols {\\n\\t\\terr := registry.Repositories.PhysicalVolume.Add(workerCtx, vol)\\n\\t\\tif err != nil {\\n\\t\\t\\tpanic(err)\\n\\t\\t}\\n\\t}\\n\\terr := uow.Commit(workerCtx)\\n\\tif err != nil {\\n\\t\\tpanic(err)\\n\\t}\\n\\treturn physicalVols\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"INSERT INTO physical_volume (serial, ip, bdf, disk_id, state, size, volume_type, zone_id, block_size, real_size, port, data_node_type, cuf) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);\"]",
      "parsed_sql": [
        "INSERT INTO physical_volume (serial, ip, bdf, disk_id, state, size, volume_type, zone_id, block_size, real_size, port, data_node_type, cuf) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "INSERT INTO physical_volume (serial, ip, bdf, disk_id, state, size, volume_type, zone_id, block_size, real_size, port, data_node_type, cuf) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);",
            "match_result": {
              "matched": false,
              "fingerprint": "f56774f1d734814599c3df1ff5836ddb",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go:282:304:StepGivenALogicalVol",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：StepGivenALogicalVol\nfunc StepGivenALogicalVol(registry *app.Registry, physicalVol *rdiskDomain.PhysicalVolume, value interface{}) *rdiskDomain.LogicalVolume {\n\tlogicalVol := &rdiskDomain.LogicalVolume{\n\t\tEntityMixin:     rdiskDomain.EntityMixin{ID: 1},\n\t\tUUID:            uuid.Must(uuid.NewRandom()),\n\t\tState:           rdiskDomain.LogicalVolumeState(value.(int)),\n\t\tSize:            1,\n\t\tAppID:           123,\n\t\tZoneID:          1,\n\t\tDiskType:        \"\",\n\t\tVolumeType:      \"\",\n\t\tFlowControlSpec: rdiskDomain.FlowControlSpec{},\n\t\tPhysicalVolume:  physicalVol,\n\t\tAttachments:     nil,\n\t}\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\terr := registry.Repositories.LogicalVolume.Add(workerCtx, logicalVol)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn logicalVol\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go\",\n    \"code_start_line\": 282,\n    \"code_end_line\": 304,\n    \"code_key\": \"StepGivenALogicalVol\",\n    \"code_value\": \"func StepGivenALogicalVol(registry *app.Registry, physicalVol *rdiskDomain.PhysicalVolume, value interface{}) *rdiskDomain.LogicalVolume {\\n\\tlogicalVol := &rdiskDomain.LogicalVolume{\\n\\t\\tEntityMixin:     rdiskDomain.EntityMixin{ID: 1},\\n\\t\\tUUID:            uuid.Must(uuid.NewRandom()),\\n\\t\\tState:           rdiskDomain.LogicalVolumeState(value.(int)),\\n\\t\\tSize:            1,\\n\\t\\tAppID:           123,\\n\\t\\tZoneID:          1,\\n\\t\\tDiskType:        \\\"\\\",\\n\\t\\tVolumeType:      \\\"\\\",\\n\\t\\tFlowControlSpec: rdiskDomain.FlowControlSpec{},\\n\\t\\tPhysicalVolume:  physicalVol,\\n\\t\\tAttachments:     nil,\\n\\t}\\n\\tuow := registry.Repositories.UoWFactory.New()\\n\\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\\n\\terr := registry.Repositories.LogicalVolume.Add(workerCtx, logicalVol)\\n\\terr = uow.Commit(workerCtx)\\n\\tif err != nil {\\n\\t\\tpanic(err)\\n\\t}\\n\\treturn logicalVol\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"INSERT INTO logical_volume (id, uuid, state, size, app_id, zone_id, disk_type, volume_type, physical_volume_id, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);\"]",
      "parsed_sql": [
        "INSERT INTO logical_volume (id, uuid, state, size, app_id, zone_id, disk_type, volume_type, physical_volume_id, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "INSERT INTO logical_volume (id, uuid, state, size, app_id, zone_id, disk_type, volume_type, physical_volume_id, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);",
            "match_result": {
              "matched": false,
              "fingerprint": "4e2f0e879916ae6e7669f8bf440f299f",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go:351:364:StepThenLogicalVolStateShouldBe",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：StepThenLogicalVolStateShouldBe\nfunc StepThenLogicalVolStateShouldBe(logicalVol *rdiskDomain.LogicalVolume, registry *app.Registry, db *gorm.DB, database string, value interface{}) *rdiskDomain.LogicalVolume {\n\tdb.Exec(fmt.Sprintf(\"USE `%s`\", database))\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\tnewLogicalVol, err := registry.Repositories.LogicalVolume.FindByAppIDAndUUID(workerCtx, logicalVol.AppID, logicalVol.UUID)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif newLogicalVol.State != rdiskDomain.LogicalVolumeState(value.(int)) {\n\t\tpanic(\"LogicalVol state error\")\n\t}\n\treturn newLogicalVol\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go\",\n    \"code_start_line\": 351,\n    \"code_end_line\": 364,\n    \"code_key\": \"StepThenLogicalVolStateShouldBe\",\n    \"code_value\": \"func StepThenLogicalVolStateShouldBe(logicalVol *rdiskDomain.LogicalVolume, registry *app.Registry, db *gorm.DB, database string, value interface{}) *rdiskDomain.LogicalVolume {\\n\\tdb.Exec(fmt.Sprintf(\\\"USE `%s`\\\", database))\\n\\tuow := registry.Repositories.UoWFactory.New()\\n\\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\\n\\tnewLogicalVol, err := registry.Repositories.LogicalVolume.FindByAppIDAndUUID(workerCtx, logicalVol.AppID, logicalVol.UUID)\\n\\terr = uow.Commit(workerCtx)\\n\\tif err != nil {\\n\\t\\tpanic(err)\\n\\t}\\n\\tif newLogicalVol.State != rdiskDomain.LogicalVolumeState(value.(int)) {\\n\\t\\tpanic(\\\"LogicalVol state error\\\")\\n\\t}\\n\\treturn newLogicalVol\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"USE `database_name`;\"]",
      "parsed_sql": [
        "USE `database_name`;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "USE `database_name`;",
            "match_result": {
              "matched": false,
              "fingerprint": "31de4a9a1e5ce2603653883bfc8a7138",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go:433:449:StepThenPhysicalVolShouldBe",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：StepThenPhysicalVolShouldBe\nfunc StepThenPhysicalVolShouldBe(physicalVol *rdiskDomain.PhysicalVolume, registry *app.Registry, db *gorm.DB, database string, field string, value interface{}) *rdiskDomain.PhysicalVolume {\n\tdb.Exec(fmt.Sprintf(\"USE `%s`\", database))\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\tnewPhysicalVol, err := registry.Repositories.PhysicalVolume.FindBySerial(workerCtx, physicalVol.Serial)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tswitch field {\n\tcase \"cuf\":\n\t\tif newPhysicalVol.Cuf != rdiskDomain.Cuf(value.(string)) {\n\t\t\tpanic(\"Result error\")\n\t\t}\n\t}\n\treturn newPhysicalVol\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go\",\n    \"code_start_line\": 433,\n    \"code_end_line\": 449,\n    \"code_key\": \"StepThenPhysicalVolShouldBe\",\n    \"code_value\": \"func StepThenPhysicalVolShouldBe(physicalVol *rdiskDomain.PhysicalVolume, registry *app.Registry, db *gorm.DB, database string, field string, value interface{}) *rdiskDomain.PhysicalVolume {\\n\\tdb.Exec(fmt.Sprintf(\\\"USE `%s`\\\", database))\\n\\tuow := registry.Repositories.UoWFactory.New()\\n\\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\\n\\tnewPhysicalVol, err := registry.Repositories.PhysicalVolume.FindBySerial(workerCtx, physicalVol.Serial)\\n\\terr = uow.Commit(workerCtx)\\n\\tif err != nil {\\n\\t\\tpanic(err)\\n\\t}\\n\\tswitch field {\\n\\tcase \\\"cuf\\\":\\n\\t\\tif newPhysicalVol.Cuf != rdiskDomain.Cuf(value.(string)) {\\n\\t\\t\\tpanic(\\\"Result error\\\")\\n\\t\\t}\\n\\t}\\n\\treturn newPhysicalVol\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"USE `database_name`;\"]",
      "parsed_sql": [
        "USE `database_name`;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "USE `database_name`;",
            "match_result": {
              "matched": false,
              "fingerprint": "31de4a9a1e5ce2603653883bfc8a7138",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go:618:630:StepThenPhysicalVolShouldBeRight",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：StepThenPhysicalVolShouldBeRight\nfunc StepThenPhysicalVolShouldBeRight(physicalVol *rdiskDomain.PhysicalVolume, registry *app.Registry, t *testing.T) {\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\tnewPhysicalVol, err := registry.Repositories.PhysicalVolume.FindBySerial(workerCtx, physicalVol.Serial)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif physicalVol.BDF != newPhysicalVol.BDF || physicalVol.Cuf != newPhysicalVol.Cuf || rdiskDomain.PVSInited != newPhysicalVol.State || physicalVol.DataNodeType != newPhysicalVol.DataNodeType ||\n\t\t!physicalVol.IP.Equal(newPhysicalVol.IP) || physicalVol.VolumeType != newPhysicalVol.VolumeType || physicalVol.Size != newPhysicalVol.Size {\n\t\tpanic(\"data error\")\n\t}\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go\",\n    \"code_start_line\": 618,\n    \"code_end_line\": 630,\n    \"code_key\": \"StepThenPhysicalVolShouldBeRight\",\n    \"code_value\": \"func StepThenPhysicalVolShouldBeRight(physicalVol *rdiskDomain.PhysicalVolume, registry *app.Registry, t *testing.T) {\\n\\tuow := registry.Repositories.UoWFactory.New()\\n\\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\\n\\tnewPhysicalVol, err := registry.Repositories.PhysicalVolume.FindBySerial(workerCtx, physicalVol.Serial)\\n\\terr = uow.Commit(workerCtx)\\n\\tif err != nil {\\n\\t\\tpanic(err)\\n\\t}\\n\\tif physicalVol.BDF != newPhysicalVol.BDF || physicalVol.Cuf != newPhysicalVol.Cuf || rdiskDomain.PVSInited != newPhysicalVol.State || physicalVol.DataNodeType != newPhysicalVol.DataNodeType ||\\n\\t\\t!physicalVol.IP.Equal(newPhysicalVol.IP) || physicalVol.VolumeType != newPhysicalVol.VolumeType || physicalVol.Size != newPhysicalVol.Size {\\n\\t\\tpanic(\\\"data error\\\")\\n\\t}\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM physical_volume WHERE serial = ?;\"]",
      "parsed_sql": [
        "SELECT * FROM physical_volume WHERE serial = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM physical_volume WHERE serial = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "5d439887054a0c6eebec99b9ce6fadeb",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/benchmark.go:42:50:FindByUUID",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：FindByUUID\nfunc (repo *rdiskBenchmarkRepositoryImpl) FindByUUID(ctx context.Context, uuid string) (*benchmark.Benchmark, error) {\n\tuow := getUow(ctx)\n\tb := &metadb.DmRdiskBenchmark{}\n\tresult := uow.tx.First(b, \"uuid = ?\", uuid)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\treturn uow.trackedBenchmarks.Add(repo.fromDoToModel(b)), nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go\", \"code_start_line\": 51, \"code_end_line\": 72, \"code_key\": \"Handle\", \"code_value\": \"func (c *CbsAppIdConsumer) Handle(ctx context.Context, delivery *rabbitmq.Delivery) error {\\n\\tu, chargeTime, err := c.ParseDelivery(ctx, delivery)\\n\\tif err != nil {\\n\\t\\treturn err\\n\\t}\\n\\tif u == nil {\\n\\t\\tlogs.Info(c.Ctx).\\n\\t\\t\\tTime(\\\"chargeTime\\\", chargeTime).\\n\\t\\t\\tMsg(\\\"USER_INFO_NOT_FOUND\\\")\\n\\t\\treturn nil\\n\\t}\\n\\n\\tchargeDetail := c.GetChargeDetailForSingleUser(u, chargeTime)\\n\\tif chargeDetail == nil {\\n\\t\\tlogs.Info(c.Ctx).\\n\\t\\t\\tUint64(\\\"appId\\\", uint64(u.AppId)).\\n\\t\\t\\tTime(\\\"chargeTime\\\", chargeTime).\\n\\t\\t\\tMsg(\\\"NO_RESOURCE_TO_CHARGE\\\")\\n\\t\\treturn nil\\n\\t}\\n\\treturn c.ProcessChargeDetail(chargeDetail)\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/benchmark.go\",\n    \"code_start_line\": 42,\n    \"code_end_line\": 50,\n    \"code_key\": \"FindByUUID\",\n    \"code_value\": \"func (repo *rdiskBenchmarkRepositoryImpl) FindByUUID(ctx context.Context, uuid string) (*benchmark.Benchmark, error) {\\n\\tuow := getUow(ctx)\\n\\tb := &metadb.DmRdiskBenchmark{}\\n\\tresult := uow.tx.First(b, \\\"uuid = ?\\\", uuid)\\n\\tif result.Error != nil {\\n\\t\\treturn nil, result.Error\\n\\t}\\n\\treturn uow.trackedBenchmarks.Add(repo.fromDoToModel(b)), nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM dm_rdisk_benchmark WHERE uuid = ? LIMIT 1;\"]",
      "parsed_sql": [
        "SELECT * FROM dm_rdisk_benchmark WHERE uuid = ? LIMIT 1;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM dm_rdisk_benchmark WHERE uuid = ? LIMIT 1;",
            "match_result": {
              "matched": false,
              "fingerprint": "7b7aefa3ea98e46d186368607285fab9",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/backup.go:44:53:FindByUUID",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：FindByUUID\nfunc (impl *rdiskBackupRepositoryImpl) FindByUUID(ctx context.Context, uuid string) (*backupPkg.Backup, error) {\n\tuow := getUow(ctx)\n\n\tb := &metadb.DmRdiskBackup{}\n\tresult := uow.tx.First(b, \"uuid = ?\", uuid)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\treturn uow.trackedBackups.Add(impl.fromDOToModel(b)), nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go\", \"code_start_line\": 51, \"code_end_line\": 72, \"code_key\": \"Handle\", \"code_value\": \"func (c *CbsAppIdConsumer) Handle(ctx context.Context, delivery *rabbitmq.Delivery) error {\\n\\tu, chargeTime, err := c.ParseDelivery(ctx, delivery)\\n\\tif err != nil {\\n\\t\\treturn err\\n\\t}\\n\\tif u == nil {\\n\\t\\tlogs.Info(c.Ctx).\\n\\t\\t\\tTime(\\\"chargeTime\\\", chargeTime).\\n\\t\\t\\tMsg(\\\"USER_INFO_NOT_FOUND\\\")\\n\\t\\treturn nil\\n\\t}\\n\\n\\tchargeDetail := c.GetChargeDetailForSingleUser(u, chargeTime)\\n\\tif chargeDetail == nil {\\n\\t\\tlogs.Info(c.Ctx).\\n\\t\\t\\tUint64(\\\"appId\\\", uint64(u.AppId)).\\n\\t\\t\\tTime(\\\"chargeTime\\\", chargeTime).\\n\\t\\t\\tMsg(\\\"NO_RESOURCE_TO_CHARGE\\\")\\n\\t\\treturn nil\\n\\t}\\n\\treturn c.ProcessChargeDetail(chargeDetail)\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/backup.go\",\n    \"code_start_line\": 44,\n    \"code_end_line\": 53,\n    \"code_key\": \"FindByUUID\",\n    \"code_value\": \"func (impl *rdiskBackupRepositoryImpl) FindByUUID(ctx context.Context, uuid string) (*backupPkg.Backup, error) {\\n\\tuow := getUow(ctx)\\n\\n\\tb := &metadb.DmRdiskBackup{}\\n\\tresult := uow.tx.First(b, \\\"uuid = ?\\\", uuid)\\n\\tif result.Error != nil {\\n\\t\\treturn nil, result.Error\\n\\t}\\n\\treturn uow.trackedBackups.Add(impl.fromDOToModel(b)), nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM dm_rdisk_backup WHERE uuid = ? LIMIT 1;\"]",
      "parsed_sql": [
        "SELECT * FROM dm_rdisk_backup WHERE uuid = ? LIMIT 1;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM dm_rdisk_backup WHERE uuid = ? LIMIT 1;",
            "match_result": {
              "matched": false,
              "fingerprint": "cb52b14d1ad1d2f3cabed75f96ed3867",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/benchmark.go:100:137:updateBenchmark",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：updateBenchmark\nfunc updateBenchmark(ctx context.Context, item, originalState *benchmark.Benchmark) error {\n\tuow := getUow(ctx)\n\timpl := rdiskBenchmarkRepositoryImpl{}\n\tcurDO := impl.fromModelToDO(item)\n\toriDO := impl.fromModelToDO(originalState)\n\tchanges := make(map[string]interface{})\n\tcheckChange := func(field string, cur interface{}, original interface{}) {\n\t\tif cur != original {\n\t\t\tchanges[field] = cur\n\t\t}\n\t}\n\n\tcheckChange(\"uuid\", curDO.UUID, oriDO.UUID)\n\tcheckChange(\"phy_id\", curDO.PhyID, oriDO.PhyID)\n\tcheckChange(\"host_bdf\", curDO.BDF, oriDO.BDF)\n\tcheckChange(\"host_ip\", curDO.HostIP, oriDO.HostIP)\n\tcheckChange(\"error\", curDO.Error, oriDO.Error)\n\tcheckChange(\"status\", curDO.Status, oriDO.Status)\n\tcheckChange(\"task_id\", curDO.TaskID, oriDO.TaskID)\n\tcheckChange(\"read_bandwidth\", curDO.ReadBandwidth, oriDO.ReadBandwidth)\n\tcheckChange(\"write_bandwidth\", curDO.WriteBandwidth, oriDO.WriteBandwidth)\n\tcheckChange(\"read_latency\", curDO.ReadLatency, oriDO.ReadLatency)\n\tcheckChange(\"write_latency\", curDO.WriteLatency, oriDO.WriteLatency)\n\tcheckChange(\"created\", curDO.Created, oriDO.Created)\n\tcheckChange(\"finished\", curDO.Finished, oriDO.Finished)\n\n\tif len(changes) == 0 {\n\t\treturn nil\n\t}\n\n\tchanges[\"updated\"] = uow.tx.NowFunc()\n\tresult := uow.tx.Model(curDO).Where(\"id = ?\", curDO.ID).Updates(changes)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\n\treturn nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/benchmark.go\",\n    \"code_start_line\": 100,\n    \"code_end_line\": 137,\n    \"code_key\": \"updateBenchmark\",\n    \"code_value\": \"func updateBenchmark(ctx context.Context, item, originalState *benchmark.Benchmark) error {\\n\\tuow := getUow(ctx)\\n\\timpl := rdiskBenchmarkRepositoryImpl{}\\n\\tcurDO := impl.fromModelToDO(item)\\n\\toriDO := impl.fromModelToDO(originalState)\\n\\tchanges := make(map[string]interface{})\\n\\tcheckChange := func(field string, cur interface{}, original interface{}) {\\n\\t\\tif cur != original {\\n\\t\\t\\tchanges[field] = cur\\n\\t\\t}\\n\\t}\\n\\n\\tcheckChange(\\\"uuid\\\", curDO.UUID, oriDO.UUID)\\n\\tcheckChange(\\\"phy_id\\\", curDO.PhyID, oriDO.PhyID)\\n\\tcheckChange(\\\"host_bdf\\\", curDO.BDF, oriDO.BDF)\\n\\tcheckChange(\\\"host_ip\\\", curDO.HostIP, oriDO.HostIP)\\n\\tcheckChange(\\\"error\\\", curDO.Error, oriDO.Error)\\n\\tcheckChange(\\\"status\\\", curDO.Status, oriDO.Status)\\n\\tcheckChange(\\\"task_id\\\", curDO.TaskID, oriDO.TaskID)\\n\\tcheckChange(\\\"read_bandwidth\\\", curDO.ReadBandwidth, oriDO.ReadBandwidth)\\n\\tcheckChange(\\\"write_bandwidth\\\", curDO.WriteBandwidth, oriDO.WriteBandwidth)\\n\\tcheckChange(\\\"read_latency\\\", curDO.ReadLatency, oriDO.ReadLatency)\\n\\tcheckChange(\\\"write_latency\\\", curDO.WriteLatency, oriDO.WriteLatency)\\n\\tcheckChange(\\\"created\\\", curDO.Created, oriDO.Created)\\n\\tcheckChange(\\\"finished\\\", curDO.Finished, oriDO.Finished)\\n\\n\\tif len(changes) == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tchanges[\\\"updated\\\"] = uow.tx.NowFunc()\\n\\tresult := uow.tx.Model(curDO).Where(\\\"id = ?\\\", curDO.ID).Updates(changes)\\n\\tif result.Error != nil {\\n\\t\\treturn result.Error\\n\\t}\\n\\n\\treturn nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"单个字段变化\", \"sql\": \"UPDATE benchmark SET uuid = ?, updated = ? WHERE id = ?;\"}, {\"scenario\": \"多个字段变化\", \"sql\": \"UPDATE benchmark SET uuid = ?, phy_id = ?, host_bdf = ?, host_ip = ?, error = ?, status = ?, task_id = ?, read_bandwidth = ?, write_bandwidth = ?, read_latency = ?, write_latency = ?, created = ?, finished = ?, updated = ? WHERE id = ?;\"}]}]",
      "parsed_sql": [
        "UPDATE benchmark SET uuid = ?, updated = ? WHERE id = ?;",
        "UPDATE benchmark SET uuid = ?, phy_id = ?, host_bdf = ?, host_ip = ?, error = ?, status = ?, task_id = ?, read_bandwidth = ?, write_bandwidth = ?, read_latency = ?, write_latency = ?, created = ?, finished = ?, updated = ? WHERE id = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 2,
        "valid_sql": 2,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "UPDATE benchmark SET uuid = ?, updated = ? WHERE id = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "74cbd8f2f278678a22214cd5fb3f5ec1",
              "excluded": false
            }
          },
          {
            "sql": "UPDATE benchmark SET uuid = ?, phy_id = ?, host_bdf = ?, host_ip = ?, error = ?, status = ?, task_id = ?, read_bandwidth = ?, write_bandwidth = ?, read_latency = ?, write_latency = ?, created = ?, finished = ?, updated = ? WHERE id = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "74cbd8f2f278678a22214cd5fb3f5ec1",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/backup.go:97:135:updateBackup",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：updateBackup\nfunc updateBackup(ctx context.Context, backup, originalState *backupPkg.Backup) error {\n\tuow := getUow(ctx)\n\timpl := rdiskBackupRepositoryImpl{}\n\tcurDO := impl.fromModelToDO(backup)\n\toriginDO := impl.fromModelToDO(originalState)\n\tchanges := make(map[string]interface{})\n\tcheckChange := func(field string, cur interface{}, original interface{}) {\n\t\tif cur != original {\n\t\t\tchanges[field] = cur\n\t\t}\n\t}\n\n\tcheckChange(\"app_id\", curDO.AppID, originDO.AppID)\n\tcheckChange(\"status\", curDO.Status, originDO.Status)\n\tcheckChange(\"size\", curDO.Size, originDO.Size)\n\tcheckChange(\"uuid\", curDO.UUID, originDO.UUID)\n\tcheckChange(\"rdisk_uuid\", curDO.DiskUUID, originDO.DiskUUID)\n\tcheckChange(\"phy_id\", curDO.PhyID, originDO.PhyID)\n\tcheckChange(\"host_ip\", curDO.HostIP, originDO.HostIP)\n\tcheckChange(\"host_bdf\", curDO.HostBDF, originDO.HostBDF)\n\tcheckChange(\"cos_appid\", curDO.CosAppId, originDO.CosAppId)\n\tcheckChange(\"cos_region\", curDO.CosRegion, originDO.CosRegion)\n\tcheckChange(\"cos_bucket\", curDO.CosBucket, originDO.CosBucket)\n\tcheckChange(\"cos_path\", curDO.CosPath, originDO.CosPath)\n\tcheckChange(\"percent\", curDO.Percent, originDO.Percent)\n\tcheckChange(\"extra\", curDO.Extra, originDO.Extra)\n\n\tif len(changes) == 0 {\n\t\treturn nil\n\t}\n\n\tchanges[\"updated\"] = uow.tx.NowFunc()\n\tresult := uow.tx.Model(curDO).Where(\"id = ?\", curDO.ID).Updates(changes)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\n\treturn nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/backup.go\",\n    \"code_start_line\": 97,\n    \"code_end_line\": 135,\n    \"code_key\": \"updateBackup\",\n    \"code_value\": \"func updateBackup(ctx context.Context, backup, originalState *backupPkg.Backup) error {\\n\\tuow := getUow(ctx)\\n\\timpl := rdiskBackupRepositoryImpl{}\\n\\tcurDO := impl.fromModelToDO(backup)\\n\\toriginDO := impl.fromModelToDO(originalState)\\n\\tchanges := make(map[string]interface{})\\n\\tcheckChange := func(field string, cur interface{}, original interface{}) {\\n\\t\\tif cur != original {\\n\\t\\t\\tchanges[field] = cur\\n\\t\\t}\\n\\t}\\n\\n\\tcheckChange(\\\"app_id\\\", curDO.AppID, originDO.AppID)\\n\\tcheckChange(\\\"status\\\", curDO.Status, originDO.Status)\\n\\tcheckChange(\\\"size\\\", curDO.Size, originDO.Size)\\n\\tcheckChange(\\\"uuid\\\", curDO.UUID, originDO.UUID)\\n\\tcheckChange(\\\"rdisk_uuid\\\", curDO.DiskUUID, originDO.DiskUUID)\\n\\tcheckChange(\\\"phy_id\\\", curDO.PhyID, originDO.PhyID)\\n\\tcheckChange(\\\"host_ip\\\", curDO.HostIP, originDO.HostIP)\\n\\tcheckChange(\\\"host_bdf\\\", curDO.HostBDF, originDO.HostBDF)\\n\\tcheckChange(\\\"cos_appid\\\", curDO.CosAppId, originDO.CosAppId)\\n\\tcheckChange(\\\"cos_region\\\", curDO.CosRegion, originDO.CosRegion)\\n\\tcheckChange(\\\"cos_bucket\\\", curDO.CosBucket, originDO.CosBucket)\\n\\tcheckChange(\\\"cos_path\\\", curDO.CosPath, originDO.CosPath)\\n\\tcheckChange(\\\"percent\\\", curDO.Percent, originDO.Percent)\\n\\tcheckChange(\\\"extra\\\", curDO.Extra, originDO.Extra)\\n\\n\\tif len(changes) == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tchanges[\\\"updated\\\"] = uow.tx.NowFunc()\\n\\tresult := uow.tx.Model(curDO).Where(\\\"id = ?\\\", curDO.ID).Updates(changes)\\n\\tif result.Error != nil {\\n\\t\\treturn result.Error\\n\\t}\\n\\n\\treturn nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"单个字段变化（如app_id）\", \"sql\": \"UPDATE backup SET app_id = ?, updated = ? WHERE id = ?;\"}, {\"scenario\": \"两个字段变化（如app_id和status）\", \"sql\": \"UPDATE backup SET app_id = ?, status = ?, updated = ? WHERE id = ?;\"}, {\"scenario\": \"多个字段变化（如app_id、status、size、uuid、rdisk_uuid、phy_id、host_ip、host_bdf、cos_appid、cos_region、cos_bucket、cos_path、percent、extra）\", \"sql\": \"UPDATE backup SET app_id = ?, status = ?, size = ?, uuid = ?, rdisk_uuid = ?, phy_id = ?, host_ip = ?, host_bdf = ?, cos_appid = ?, cos_region = ?, cos_bucket = ?, cos_path = ?, percent = ?, extra = ?, updated = ? WHERE id = ?;\"}]}]",
      "parsed_sql": [
        "UPDATE backup SET app_id = ?, updated = ? WHERE id = ?;",
        "UPDATE backup SET app_id = ?, status = ?, updated = ? WHERE id = ?;",
        "UPDATE backup SET app_id = ?, status = ?, size = ?, uuid = ?, rdisk_uuid = ?, phy_id = ?, host_ip = ?, host_bdf = ?, cos_appid = ?, cos_region = ?, cos_bucket = ?, cos_path = ?, percent = ?, extra = ?, updated = ? WHERE id = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 3,
        "valid_sql": 3,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "UPDATE backup SET app_id = ?, updated = ? WHERE id = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "ec775f9db4f42b7dcbdc5a3f6e6d2345",
              "excluded": false
            }
          },
          {
            "sql": "UPDATE backup SET app_id = ?, status = ?, updated = ? WHERE id = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "ec775f9db4f42b7dcbdc5a3f6e6d2345",
              "excluded": false
            }
          },
          {
            "sql": "UPDATE backup SET app_id = ?, status = ?, size = ?, uuid = ?, rdisk_uuid = ?, phy_id = ?, host_ip = ?, host_bdf = ?, cos_appid = ?, cos_region = ?, cos_bucket = ?, cos_path = ?, percent = ?, extra = ?, updated = ? WHERE id = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "ec775f9db4f42b7dcbdc5a3f6e6d2345",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go:22:47:FindByAppIDAndUUID",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：FindByAppIDAndUUID\nfunc (logicalVolumeRepositoryImpl) FindByAppIDAndUUID(ctx context.Context, appID users.AppID, id uuid.UUID) (*rdiskDomain.LogicalVolume, error) {\n\tuow := getUow(ctx)\n\tvol := metadb.DmRdisk{}\n\tresult := uow.tx.\n\t\tPreload(\"Attachments\").\n\t\tPreload(\"DmPhyDisk\").\n\t\tFirst(&vol, \"uuid = ? AND app_id = ?\", id.String(), appID)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tlv, err := fromDmRDiskToModel(ctx, &vol)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlv = uow.trackedLogicalVolumes.Add(lv)\n\tif lv.PhysicalVolume != nil {\n\t\tlv.PhysicalVolume = uow.trackedPhyVolumes.Add(lv.PhysicalVolume)\n\t}\n\treturn lv, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go\", \"code_start_line\": 51, \"code_end_line\": 72, \"code_key\": \"Handle\", \"code_value\": \"func (c *CbsAppIdConsumer) Handle(ctx context.Context, delivery *rabbitmq.Delivery) error {\\n\\tu, chargeTime, err := c.ParseDelivery(ctx, delivery)\\n\\tif err != nil {\\n\\t\\treturn err\\n\\t}\\n\\tif u == nil {\\n\\t\\tlogs.Info(c.Ctx).\\n\\t\\t\\tTime(\\\"chargeTime\\\", chargeTime).\\n\\t\\t\\tMsg(\\\"USER_INFO_NOT_FOUND\\\")\\n\\t\\treturn nil\\n\\t}\\n\\n\\tchargeDetail := c.GetChargeDetailForSingleUser(u, chargeTime)\\n\\tif chargeDetail == nil {\\n\\t\\tlogs.Info(c.Ctx).\\n\\t\\t\\tUint64(\\\"appId\\\", uint64(u.AppId)).\\n\\t\\t\\tTime(\\\"chargeTime\\\", chargeTime).\\n\\t\\t\\tMsg(\\\"NO_RESOURCE_TO_CHARGE\\\")\\n\\t\\treturn nil\\n\\t}\\n\\treturn c.ProcessChargeDetail(chargeDetail)\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go\",\n    \"code_start_line\": 22,\n    \"code_end_line\": 47,\n    \"code_key\": \"FindByAppIDAndUUID\",\n    \"code_value\": \"func (logicalVolumeRepositoryImpl) FindByAppIDAndUUID(ctx context.Context, appID users.AppID, id uuid.UUID) (*rdiskDomain.LogicalVolume, error) {\\n\\tuow := getUow(ctx)\\n\\tvol := metadb.DmRdisk{}\\n\\tresult := uow.tx.\\n\\t\\tPreload(\\\"Attachments\\\").\\n\\t\\tPreload(\\\"DmPhyDisk\\\").\\n\\t\\tFirst(&vol, \\\"uuid = ? AND app_id = ?\\\", id.String(), appID)\\n\\tif result.Error != nil {\\n\\t\\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\\n\\t\\t\\treturn nil, errors.New(rdiskDomain.ErrVolumeNotExists, \\\"volume not exists\\\")\\n\\t\\t}\\n\\t\\treturn nil, result.Error\\n\\t}\\n\\tif result.RowsAffected == 0 {\\n\\t\\treturn nil, nil\\n\\t}\\n\\tlv, err := fromDmRDiskToModel(ctx, &vol)\\n\\tif err != nil {\\n\\t\\treturn nil, err\\n\\t}\\n\\tlv = uow.trackedLogicalVolumes.Add(lv)\\n\\tif lv.PhysicalVolume != nil {\\n\\t\\tlv.PhysicalVolume = uow.trackedPhyVolumes.Add(lv.PhysicalVolume)\\n\\t}\\n\\treturn lv, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"Main query with preloads\", \"sql\": \"SELECT * FROM dm_rdisk WHERE uuid = ? AND app_id = ? LIMIT 1;\"}, {\"scenario\": \"Preload query for Attachments\", \"sql\": \"SELECT * FROM dm_rdisk_attachment WHERE uuid = ?;\"}, {\"scenario\": \"Preload query for DmPhyDisk\", \"sql\": \"SELECT * FROM dm_phydisk WHERE uuid = ?;\"}]}]",
      "parsed_sql": [
        "SELECT * FROM dm_rdisk WHERE uuid = ? AND app_id = ? LIMIT 1;",
        "SELECT * FROM dm_rdisk_attachment WHERE uuid = ?;",
        "SELECT * FROM dm_phydisk WHERE uuid = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 3,
        "valid_sql": 3,
        "matched_sql": 2,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM dm_rdisk WHERE uuid = ? AND app_id = ? LIMIT 1;",
            "match_result": {
              "matched": true,
              "fingerprint": "b0ca129db83e26402fb0dd198aa16698",
              "example_sql": "SELECT * FROM `dm_rdisk` WHERE uuid = '21b98301-fbba-4c0c-8731-65b9dc42941c' AND app_id = 1258344699 ORDER BY `dm_rdisk`.`id` LIMIT 1",
              "example_count": 8
            }
          },
          {
            "sql": "SELECT * FROM dm_rdisk_attachment WHERE uuid = ?;",
            "match_result": {
              "matched": true,
              "fingerprint": "e4b00a2ee33535674ea06c75b3a985c6",
              "example_sql": "SELECT * FROM `dm_rdisk_attachment` WHERE `dm_rdisk_attachment`.`uuid` = '25093a2e-d9c4-43b1-8bd9-c67d98c6cdae'",
              "example_count": 100
            }
          },
          {
            "sql": "SELECT * FROM dm_phydisk WHERE uuid = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "dc8a50bcdf7e6665c8015582abe04e92",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go:49:74:FindByID",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：FindByID\nfunc (l logicalVolumeRepositoryImpl) FindByID(ctx context.Context, id uuid.UUID) (*rdiskDomain.LogicalVolume, error) {\n\tuow := getUow(ctx)\n\tvol := metadb.DmRdisk{}\n\tresult := uow.tx.\n\t\tPreload(\"Attachments\").\n\t\tPreload(\"DmPhyDisk\").\n\t\tFirst(&vol, \"uuid = ?\", id.String())\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tlv, err := fromDmRDiskToModel(ctx, &vol)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlv = uow.trackedLogicalVolumes.Add(lv)\n\tif lv.PhysicalVolume != nil {\n\t\tlv.PhysicalVolume = uow.trackedPhyVolumes.Add(lv.PhysicalVolume)\n\t}\n\treturn lv, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go\", \"code_start_line\": 51, \"code_end_line\": 72, \"code_key\": \"Handle\", \"code_value\": \"func (c *CbsAppIdConsumer) Handle(ctx context.Context, delivery *rabbitmq.Delivery) error {\\n\\tu, chargeTime, err := c.ParseDelivery(ctx, delivery)\\n\\tif err != nil {\\n\\t\\treturn err\\n\\t}\\n\\tif u == nil {\\n\\t\\tlogs.Info(c.Ctx).\\n\\t\\t\\tTime(\\\"chargeTime\\\", chargeTime).\\n\\t\\t\\tMsg(\\\"USER_INFO_NOT_FOUND\\\")\\n\\t\\treturn nil\\n\\t}\\n\\n\\tchargeDetail := c.GetChargeDetailForSingleUser(u, chargeTime)\\n\\tif chargeDetail == nil {\\n\\t\\tlogs.Info(c.Ctx).\\n\\t\\t\\tUint64(\\\"appId\\\", uint64(u.AppId)).\\n\\t\\t\\tTime(\\\"chargeTime\\\", chargeTime).\\n\\t\\t\\tMsg(\\\"NO_RESOURCE_TO_CHARGE\\\")\\n\\t\\treturn nil\\n\\t}\\n\\treturn c.ProcessChargeDetail(chargeDetail)\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go\",\n    \"code_start_line\": 49,\n    \"code_end_line\": 74,\n    \"code_key\": \"FindByID\",\n    \"code_value\": \"func (l logicalVolumeRepositoryImpl) FindByID(ctx context.Context, id uuid.UUID) (*rdiskDomain.LogicalVolume, error) {\\n\\tuow := getUow(ctx)\\n\\tvol := metadb.DmRdisk{}\\n\\tresult := uow.tx.\\n\\t\\tPreload(\\\"Attachments\\\").\\n\\t\\tPreload(\\\"DmPhyDisk\\\").\\n\\t\\tFirst(&vol, \\\"uuid = ?\\\", id.String())\\n\\tif result.Error != nil {\\n\\t\\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\\n\\t\\t\\treturn nil, errors.New(rdiskDomain.ErrVolumeNotExists, \\\"volume not exists\\\")\\n\\t\\t}\\n\\t\\treturn nil, result.Error\\n\\t}\\n\\tif result.RowsAffected == 0 {\\n\\t\\treturn nil, nil\\n\\t}\\n\\tlv, err := fromDmRDiskToModel(ctx, &vol)\\n\\tif err != nil {\\n\\t\\treturn nil, err\\n\\t}\\n\\tlv = uow.trackedLogicalVolumes.Add(lv)\\n\\tif lv.PhysicalVolume != nil {\\n\\t\\tlv.PhysicalVolume = uow.trackedPhyVolumes.Add(lv.PhysicalVolume)\\n\\t}\\n\\treturn lv, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"Main query with preloads\", \"sql\": \"SELECT * FROM dm_rdisk WHERE uuid = ? LIMIT 1;\"}]}, {\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"Preload query for Attachments\", \"sql\": \"SELECT * FROM dm_rdisk_attachment WHERE uuid = ?;\"}]}, {\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"Preload query for DmPhyDisk\", \"sql\": \"SELECT * FROM dm_phydisk WHERE uuid = ?;\"}]}]",
      "parsed_sql": [
        "SELECT * FROM dm_rdisk WHERE uuid = ? LIMIT 1;",
        "SELECT * FROM dm_rdisk_attachment WHERE uuid = ?;",
        "SELECT * FROM dm_phydisk WHERE uuid = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 3,
        "valid_sql": 3,
        "matched_sql": 2,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM dm_rdisk WHERE uuid = ? LIMIT 1;",
            "match_result": {
              "matched": true,
              "fingerprint": "04cddcdf27d2555bdd3b6350fc6b5cb8",
              "example_sql": "SELECT * FROM `dm_rdisk` WHERE uuid = '25093a2e-d9c4-43b1-8bd9-c67d98c6cdae' ORDER BY `dm_rdisk`.`id` LIMIT 1",
              "example_count": 100
            }
          },
          {
            "sql": "SELECT * FROM dm_rdisk_attachment WHERE uuid = ?;",
            "match_result": {
              "matched": true,
              "fingerprint": "e4b00a2ee33535674ea06c75b3a985c6",
              "example_sql": "SELECT * FROM `dm_rdisk_attachment` WHERE `dm_rdisk_attachment`.`uuid` = '25093a2e-d9c4-43b1-8bd9-c67d98c6cdae'",
              "example_count": 100
            }
          },
          {
            "sql": "SELECT * FROM dm_phydisk WHERE uuid = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "dc8a50bcdf7e6665c8015582abe04e92",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go:199:305:updateLogicalVolume",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：updateLogicalVolume\nfunc updateLogicalVolume(ctx context.Context, item, originalState *rdiskDomain.LogicalVolume) error {\n\tuow := getUow(ctx)\n\tcurDO := fromModelToDmRDisk(item)\n\toriginalDO := fromModelToDmRDisk(originalState)\n\tchanges := make(map[string]interface{})\n\tcheckChange := func(field string, cur interface{}, original interface{}) {\n\t\tif cur != original {\n\t\t\tchanges[field] = cur\n\t\t}\n\t}\n\tcheckChange(\"uuid\", curDO.UUID, originalDO.UUID)\n\tcheckChange(\"status\", curDO.Status, originalDO.Status)\n\tcheckChange(\"app_id\", curDO.AppID, originalDO.AppID)\n\tcheckChange(\"size\", curDO.Size, originalDO.Size)\n\tcheckChange(\"phydisk_serial\", curDO.PhydiskSerial, originalDO.PhydiskSerial)\n\tcheckChange(\"zone_id\", curDO.ZoneID, originalDO.ZoneID)\n\tcheckChange(\"volume_type\", curDO.VolumeType, originalDO.VolumeType)\n\tcheckChange(\"disk_type\", curDO.DiskType, originalDO.DiskType)\n\tcheckChange(\"read_iops\", curDO.ReadIOPS, originalDO.ReadIOPS)\n\tcheckChange(\"write_iops\", curDO.WriteIOPS, originalDO.WriteIOPS)\n\tcheckChange(\"rw_iops\", curDO.ReadWriteIOPS, originalDO.ReadWriteIOPS)\n\tcheckChange(\"read_bandwidth\", curDO.ReadBandwidth, originalDO.ReadBandwidth)\n\tcheckChange(\"write_bandwidth\", curDO.WriteBandwidth, originalDO.WriteBandwidth)\n\tcheckChange(\"rw_bandwidth\", curDO.ReadWriteBandwidth, originalDO.ReadWriteBandwidth)\n\n\tif len(changes) != 0 {\n\t\tchanges[\"updated\"] = uow.tx.NowFunc()\n\n\t\tresult := uow.tx.Model(curDO).Where(\"id = ?\", curDO.ID).Updates(changes)\n\t\tif result.Error != nil {\n\t\t\treturn result.Error\n\t\t}\n\t}\n\n\t// 更新挂载信息\n\n\tallHosts := make(map[string]struct{})\n\toriginHosts := make(map[string]*rdiskDomain.VolumeAttachment)\n\tcurHosts := make(map[string]*rdiskDomain.VolumeAttachment)\n\tfor _, a := range item.Attachments {\n\t\tallHosts[a.IP.String()] = struct{}{}\n\t\tcurHosts[a.IP.String()] = a\n\t}\n\tfor _, a := range originalState.Attachments {\n\t\tallHosts[a.IP.String()] = struct{}{}\n\t\toriginHosts[a.IP.String()] = a\n\t}\n\n\tfor hostIp := range allHosts {\n\t\tcurAttachment, _ := curHosts[hostIp]\n\t\toriginAttachment, _ := originHosts[hostIp]\n\t\tif originAttachment == nil && curAttachment != nil {\n\t\t\t// 新增挂载\n\t\t\tdo := fromModelToDmRDiskAttachment(curAttachment)\n\t\t\tdo.UUID = curDO.UUID\n\t\t\tdo.Created = uow.tx.NowFunc()\n\t\t\tdo.Updated = uow.tx.NowFunc()\n\t\t\terr := uow.tx.Model(curDO).Association(\"Attachments\").Append(do)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else if originAttachment != nil && curAttachment == nil {\n\t\t\t// 删除挂载\n\t\t\tdo := fromModelToDmRDiskAttachment(originAttachment)\n\t\t\tdo.UUID = curDO.UUID\n\t\t\tresult := uow.tx.Where(\"host_ip = ? and uuid = ?\", do.IP, do.UUID).Delete(do)\n\t\t\tif result.Error != nil {\n\t\t\t\treturn result.Error\n\t\t\t}\n\t\t} else if originAttachment != nil && curAttachment != nil {\n\t\t\t// 更新挂载\n\t\t\tdo := fromModelToDmRDiskAttachment(curAttachment)\n\t\t\tdo.UUID = curDO.UUID\n\t\t\toriginDo := fromModelToDmRDiskAttachment(originAttachment)\n\t\t\toriginDo.UUID = curDO.UUID\n\t\t\tchanges := make(map[string]interface{})\n\t\t\tcheckChange := func(field string, cur interface{}, original interface{}) {\n\t\t\t\tif cur != original {\n\t\t\t\t\tchanges[field] = cur\n\t\t\t\t}\n\t\t\t}\n\t\t\tcheckChange(\"mode\", do.Mode, originDo.Mode)\n\t\t\tcheckChange(\"read_iops\", do.ReadIOPS, originDo.ReadIOPS)\n\t\t\tcheckChange(\"write_iops\", do.WriteIOPS, originDo.WriteIOPS)\n\t\t\tcheckChange(\"rw_iops\", do.ReadWriteIOPS, originDo.ReadWriteIOPS)\n\t\t\tcheckChange(\"read_bandwidth\", do.ReadBandwidth, originDo.ReadBandwidth)\n\t\t\tcheckChange(\"write_bandwidth\", do.WriteBandwidth, originDo.WriteBandwidth)\n\t\t\tcheckChange(\"rw_bandwidth\", do.ReadWriteBandwidth, originDo.ReadWriteBandwidth)\n\t\t\tcheckChange(\"num_queue\", do.NumQueue, originDo.NumQueue)\n\t\t\tcheckChange(\"serial\", do.Serial, originDo.Serial)\n\t\t\tcheckChange(\"vcpu\", do.VCPU, originDo.VCPU)\n\t\t\tcheckChange(\"spdk_driver\", do.SPDKDriver, originDo.SPDKDriver)\n\n\t\t\tif len(changes) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tchanges[\"updated\"] = uow.tx.NowFunc()\n\t\t\tresult := uow.tx.Model(do).Where(\"host_ip = ? and uuid = ?\", do.IP, do.UUID).Updates(changes)\n\t\t\tif result.Error != nil {\n\t\t\t\treturn result.Error\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go\",\n    \"code_start_line\": 199,\n    \"code_end_line\": 305,\n    \"code_key\": \"updateLogicalVolume\",\n    \"code_value\": \"func updateLogicalVolume(ctx context.Context, item, originalState *rdiskDomain.LogicalVolume) error {\\n\\tuow := getUow(ctx)\\n\\tcurDO := fromModelToDmRDisk(item)\\n\\toriginalDO := fromModelToDmRDisk(originalState)\\n\\tchanges := make(map[string]interface{})\\n\\tcheckChange := func(field string, cur interface{}, original interface{}) {\\n\\t\\tif cur != original {\\n\\t\\t\\tchanges[field] = cur\\n\\t\\t}\\n\\t}\\n\\tcheckChange(\\\"uuid\\\", curDO.UUID, originalDO.UUID)\\n\\tcheckChange(\\\"status\\\", curDO.Status, originalDO.Status)\\n\\tcheckChange(\\\"app_id\\\", curDO.AppID, originalDO.AppID)\\n\\tcheckChange(\\\"size\\\", curDO.Size, originalDO.Size)\\n\\tcheckChange(\\\"phydisk_serial\\\", curDO.PhydiskSerial, originalDO.PhydiskSerial)\\n\\tcheckChange(\\\"zone_id\\\", curDO.ZoneID, originalDO.ZoneID)\\n\\tcheckChange(\\\"volume_type\\\", curDO.VolumeType, originalDO.VolumeType)\\n\\tcheckChange(\\\"disk_type\\\", curDO.DiskType, originalDO.DiskType)\\n\\tcheckChange(\\\"read_iops\\\", curDO.ReadIOPS, originalDO.ReadIOPS)\\n\\tcheckChange(\\\"write_iops\\\", curDO.WriteIOPS, originalDO.WriteIOPS)\\n\\tcheckChange(\\\"rw_iops\\\", curDO.ReadWriteIOPS, originalDO.ReadWriteIOPS)\\n\\tcheckChange(\\\"read_bandwidth\\\", curDO.ReadBandwidth, originalDO.ReadBandwidth)\\n\\tcheckChange(\\\"write_bandwidth\\\", curDO.WriteBandwidth, originalDO.WriteBandwidth)\\n\\tcheckChange(\\\"rw_bandwidth\\\", curDO.ReadWriteBandwidth, originalDO.ReadWriteBandwidth)\\n\\n\\tif len(changes) != 0 {\\n\\t\\tchanges[\\\"updated\\\"] = uow.tx.NowFunc()\\n\\n\\t\\tresult := uow.tx.Model(curDO).Where(\\\"id = ?\\\", curDO.ID).Updates(changes)\\n\\t\\tif result.Error != nil {\\n\\t\\t\\treturn result.Error\\n\\t\\t}\\n\\t}\\n\\n\\t// 更新挂载信息\\n\\n\\tallHosts := make(map[string]struct{})\\n\\toriginHosts := make(map[string]*rdiskDomain.VolumeAttachment)\\n\\tcurHosts := make(map[string]*rdiskDomain.VolumeAttachment)\\n\\tfor _, a := range item.Attachments {\\n\\t\\tallHosts[a.IP.String()] = struct{}{}\\n\\t\\tcurHosts[a.IP.String()] = a\\n\\t}\\n\\tfor _, a := range originalState.Attachments {\\n\\t\\tallHosts[a.IP.String()] = struct{}{}\\n\\t\\toriginHosts[a.IP.String()] = a\\n\\t}\\n\\n\\tfor hostIp := range allHosts {\\n\\t\\tcurAttachment, _ := curHosts[hostIp]\\n\\t\\toriginAttachment, _ := originHosts[hostIp]\\n\\t\\tif originAttachment == nil && curAttachment != nil {\\n\\t\\t\\t// 新增挂载\\n\\t\\t\\tdo := fromModelToDmRDiskAttachment(curAttachment)\\n\\t\\t\\tdo.UUID = curDO.UUID\\n\\t\\t\\tdo.Created = uow.tx.NowFunc()\\n\\t\\t\\tdo.Updated = uow.tx.NowFunc()\\n\\t\\t\\terr := uow.tx.Model(curDO).Association(\\\"Attachments\\\").Append(do)\\n\\t\\t\\tif err != nil {\\n\\t\\t\\t\\treturn err\\n\\t\\t\\t}\\n\\t\\t} else if originAttachment != nil && curAttachment == nil {\\n\\t\\t\\t// 删除挂载\\n\\t\\t\\tdo := fromModelToDmRDiskAttachment(originAttachment)\\n\\t\\t\\tdo.UUID = curDO.UUID\\n\\t\\t\\tresult := uow.tx.Where(\\\"host_ip = ? and uuid = ?\\\", do.IP, do.UUID).Delete(do)\\n\\t\\t\\tif result.Error != nil {\\n\\t\\t\\t\\treturn result.Error\\n\\t\\t\\t}\\n\\t\\t} else if originAttachment != nil && curAttachment != nil {\\n\\t\\t\\t// 更新挂载\\n\\t\\t\\tdo := fromModelToDmRDiskAttachment(curAttachment)\\n\\t\\t\\tdo.UUID = curDO.UUID\\n\\t\\t\\toriginDo := fromModelToDmRDiskAttachment(originAttachment)\\n\\t\\t\\toriginDo.UUID = curDO.UUID\\n\\t\\t\\tchanges := make(map[string]interface{})\\n\\t\\t\\tcheckChange := func(field string, cur interface{}, original interface{}) {\\n\\t\\t\\t\\tif cur != original {\\n\\t\\t\\t\\t\\tchanges[field] = cur\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcheckChange(\\\"mode\\\", do.Mode, originDo.Mode)\\n\\t\\t\\tcheckChange(\\\"read_iops\\\", do.ReadIOPS, originDo.ReadIOPS)\\n\\t\\t\\tcheckChange(\\\"write_iops\\\", do.WriteIOPS, originDo.WriteIOPS)\\n\\t\\t\\tcheckChange(\\\"rw_iops\\\", do.ReadWriteIOPS, originDo.ReadWriteIOPS)\\n\\t\\t\\tcheckChange(\\\"read_bandwidth\\\", do.ReadBandwidth, originDo.ReadBandwidth)\\n\\t\\t\\tcheckChange(\\\"write_bandwidth\\\", do.WriteBandwidth, originDo.WriteBandwidth)\\n\\t\\t\\tcheckChange(\\\"rw_bandwidth\\\", do.ReadWriteBandwidth, originDo.ReadWriteBandwidth)\\n\\t\\t\\tcheckChange(\\\"num_queue\\\", do.NumQueue, originDo.NumQueue)\\n\\t\\t\\tcheckChange(\\\"serial\\\", do.Serial, originDo.Serial)\\n\\t\\t\\tcheckChange(\\\"vcpu\\\", do.VCPU, originDo.VCPU)\\n\\t\\t\\tcheckChange(\\\"spdk_driver\\\", do.SPDKDriver, originDo.SPDKDriver)\\n\\n\\t\\t\\tif len(changes) == 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\tchanges[\\\"updated\\\"] = uow.tx.NowFunc()\\n\\t\\t\\tresult := uow.tx.Model(do).Where(\\\"host_ip = ? and uuid = ?\\\", do.IP, do.UUID).Updates(changes)\\n\\t\\t\\tif result.Error != nil {\\n\\t\\t\\t\\treturn result.Error\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"Logical volume properties change\", \"sql\": \"UPDATE dm_rdisk SET uuid = ?, status = ?, app_id = ?, size = ?, phydisk_serial = ?, zone_id = ?, volume_type = ?, disk_type = ?, read_iops = ?, write_iops = ?, rw_iops = ?, read_bandwidth = ?, write_bandwidth = ?, rw_bandwidth = ?, updated = ? WHERE id = ?;\"}, {\"scenario\": \"New attachment added\", \"sql\": \"INSERT INTO dm_rdisk_attachments (uuid, host_ip, mode, read_iops, write_iops, rw_iops, read_bandwidth, write_bandwidth, rw_bandwidth, num_queue, serial, vcpu, spdk_driver, created, updated) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);\"}, {\"scenario\": \"Attachment removed\", \"sql\": \"DELETE FROM dm_rdisk_attachments WHERE host_ip = ? AND uuid = ?;\"}, {\"scenario\": \"Attachment updated\", \"sql\": \"UPDATE dm_rdisk_attachments SET mode = ?, read_iops = ?, write_iops = ?, rw_iops = ?, read_bandwidth = ?, write_bandwidth = ?, rw_bandwidth = ?, num_queue = ?, serial = ?, vcpu = ?, spdk_driver = ?, updated = ? WHERE host_ip = ? AND uuid = ?;\"}]}]",
      "parsed_sql": [
        "UPDATE dm_rdisk SET uuid = ?, status = ?, app_id = ?, size = ?, phydisk_serial = ?, zone_id = ?, volume_type = ?, disk_type = ?, read_iops = ?, write_iops = ?, rw_iops = ?, read_bandwidth = ?, write_bandwidth = ?, rw_bandwidth = ?, updated = ? WHERE id = ?;",
        "INSERT INTO dm_rdisk_attachments (uuid, host_ip, mode, read_iops, write_iops, rw_iops, read_bandwidth, write_bandwidth, rw_bandwidth, num_queue, serial, vcpu, spdk_driver, created, updated) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);",
        "DELETE FROM dm_rdisk_attachments WHERE host_ip = ? AND uuid = ?;",
        "UPDATE dm_rdisk_attachments SET mode = ?, read_iops = ?, write_iops = ?, rw_iops = ?, read_bandwidth = ?, write_bandwidth = ?, rw_bandwidth = ?, num_queue = ?, serial = ?, vcpu = ?, spdk_driver = ?, updated = ? WHERE host_ip = ? AND uuid = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 4,
        "valid_sql": 4,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "UPDATE dm_rdisk SET uuid = ?, status = ?, app_id = ?, size = ?, phydisk_serial = ?, zone_id = ?, volume_type = ?, disk_type = ?, read_iops = ?, write_iops = ?, rw_iops = ?, read_bandwidth = ?, write_bandwidth = ?, rw_bandwidth = ?, updated = ? WHERE id = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "37e3e831aced1a77a994a1cf1a28e89f",
              "excluded": false
            }
          },
          {
            "sql": "INSERT INTO dm_rdisk_attachments (uuid, host_ip, mode, read_iops, write_iops, rw_iops, read_bandwidth, write_bandwidth, rw_bandwidth, num_queue, serial, vcpu, spdk_driver, created, updated) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);",
            "match_result": {
              "matched": false,
              "fingerprint": "812b1ffff4ebab63a64de7d2699d034c",
              "excluded": false
            }
          },
          {
            "sql": "DELETE FROM dm_rdisk_attachments WHERE host_ip = ? AND uuid = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "22ab08fb7f1f4ef3f366fb190e8bd26a",
              "excluded": false
            }
          },
          {
            "sql": "UPDATE dm_rdisk_attachments SET mode = ?, read_iops = ?, write_iops = ?, rw_iops = ?, read_bandwidth = ?, write_bandwidth = ?, rw_bandwidth = ?, num_queue = ?, serial = ?, vcpu = ?, spdk_driver = ?, updated = ? WHERE host_ip = ? AND uuid = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "abe1f051d2a65ca996f4312cd47d395b",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/uow.go:59:81:Commit",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：Commit\nfunc (u *unitOfWork) Commit(ctx context.Context) error {\n\terr := u.trackedPhyVolumes.Update(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = u.trackedLogicalVolumes.Update(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = u.trackedDRGroups.Update(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = u.trackedBackups.Update(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = u.trackedBenchmarks.Update(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn u.tx.Commit().Error\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/tracker.go\", \"code_start_line\": 67, \"code_end_line\": 77, \"code_key\": \"Refresh\", \"code_value\": \"func (rdp *PhyDiskTracker) Refresh(ctx context.Context) {\\n\\trdp.Track(ctx)\\n\\tlock.RDPhyCacheGlobalLock.GetLocker(lock.RDPhyLockKeyGenerator{}).Lock()\\n\\trdp.Merge(ctx, rdp.OriPhyDisks)\\n\\tlogs.Info(ctx).\\n\\t\\tInt(\\\"disk_num\\\", len(rdp.ToCachedPhyDisks)).\\n\\t\\tInt(\\\"member_num\\\", len(rdp.DrgroupMembers)).\\n\\t\\tMsg(\\\"CACHE_AVAILABLE_PHY_DISK_AFTER_MERGE\\\")\\n\\trdp.CacheManager.RefreshCache(ctx, rdp.ToCachedPhyDisks, rdp.DrgroupMembers)\\n\\tlock.RDPhyCacheGlobalLock.GetLocker(lock.RDPhyLockKeyGenerator{}).Unlock()\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/uow.go\",\n    \"code_start_line\": 59,\n    \"code_end_line\": 81,\n    \"code_key\": \"Commit\",\n    \"code_value\": \"func (u *unitOfWork) Commit(ctx context.Context) error {\\n\\terr := u.trackedPhyVolumes.Update(ctx)\\n\\tif err != nil {\\n\\t\\treturn err\\n\\t}\\n\\terr = u.trackedLogicalVolumes.Update(ctx)\\n\\tif err != nil {\\n\\t\\treturn err\\n\\t}\\n\\terr = u.trackedDRGroups.Update(ctx)\\n\\tif err != nil {\\n\\t\\treturn err\\n\\t}\\n\\terr = u.trackedBackups.Update(ctx)\\n\\tif err != nil {\\n\\t\\treturn err\\n\\t}\\n\\terr = u.trackedBenchmarks.Update(ctx)\\n\\tif err != nil {\\n\\t\\treturn err\\n\\t}\\n\\treturn u.tx.Commit().Error\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"trackedPhyVolumes有更新操作\", \"sql\": \"UPDATE phy_volume SET status = ?, updated_at = ? WHERE id = ?;\"}, {\"scenario\": \"trackedLogicalVolumes有更新操作\", \"sql\": \"UPDATE logical_volume SET status = ?, updated_at = ? WHERE id = ?;\"}, {\"scenario\": \"trackedDRGroups有更新操作\", \"sql\": \"UPDATE dr_group SET status = ?, updated_at = ? WHERE id = ?;\"}, {\"scenario\": \"trackedBackups有更新操作\", \"sql\": \"UPDATE backup SET status = ?, updated_at = ? WHERE id = ?;\"}, {\"scenario\": \"trackedBenchmarks有更新操作\", \"sql\": \"UPDATE benchmark SET status = ?, updated_at = ? WHERE id = ?;\"}]}]",
      "parsed_sql": [
        "UPDATE phy_volume SET status = ?, updated_at = ? WHERE id = ?;",
        "UPDATE logical_volume SET status = ?, updated_at = ? WHERE id = ?;",
        "UPDATE dr_group SET status = ?, updated_at = ? WHERE id = ?;",
        "UPDATE backup SET status = ?, updated_at = ? WHERE id = ?;",
        "UPDATE benchmark SET status = ?, updated_at = ? WHERE id = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 5,
        "valid_sql": 5,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "UPDATE phy_volume SET status = ?, updated_at = ? WHERE id = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "8750ee0a412e3dd57bf360e670e49078",
              "excluded": false
            }
          },
          {
            "sql": "UPDATE logical_volume SET status = ?, updated_at = ? WHERE id = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "92f8eea06ccb6be85c626eeccaf490ed",
              "excluded": false
            }
          },
          {
            "sql": "UPDATE dr_group SET status = ?, updated_at = ? WHERE id = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "e722176481867086e1abe2c161f13816",
              "excluded": false
            }
          },
          {
            "sql": "UPDATE backup SET status = ?, updated_at = ? WHERE id = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "ec775f9db4f42b7dcbdc5a3f6e6d2345",
              "excluded": false
            }
          },
          {
            "sql": "UPDATE benchmark SET status = ?, updated_at = ? WHERE id = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "74cbd8f2f278678a22214cd5fb3f5ec1",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go:21:38:FindBySerial",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：FindBySerial\nfunc (p *physicalVolumeRepositoryImpl) FindBySerial(ctx context.Context, serial rdiskDomain.Serial) (*rdiskDomain.PhysicalVolume, error) {\n\tuow := getUow(ctx)\n\tvar vol metadb.DmPhydisk\n\tresult := uow.tx.Where(\"serial = ?\", string(serial)).First(&vol)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\t// 覆盖 gorm 的错误\n\t\t\treturn nil, errors.New(rdiskDomain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tpv := fromDmPhyDiskToPhysicalVolume(ctx, &vol)\n\tpv = uow.trackedPhyVolumes.Add(pv)\n\treturn pv, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go\", \"code_start_line\": 51, \"code_end_line\": 72, \"code_key\": \"Handle\", \"code_value\": \"func (c *CbsAppIdConsumer) Handle(ctx context.Context, delivery *rabbitmq.Delivery) error {\\n\\tu, chargeTime, err := c.ParseDelivery(ctx, delivery)\\n\\tif err != nil {\\n\\t\\treturn err\\n\\t}\\n\\tif u == nil {\\n\\t\\tlogs.Info(c.Ctx).\\n\\t\\t\\tTime(\\\"chargeTime\\\", chargeTime).\\n\\t\\t\\tMsg(\\\"USER_INFO_NOT_FOUND\\\")\\n\\t\\treturn nil\\n\\t}\\n\\n\\tchargeDetail := c.GetChargeDetailForSingleUser(u, chargeTime)\\n\\tif chargeDetail == nil {\\n\\t\\tlogs.Info(c.Ctx).\\n\\t\\t\\tUint64(\\\"appId\\\", uint64(u.AppId)).\\n\\t\\t\\tTime(\\\"chargeTime\\\", chargeTime).\\n\\t\\t\\tMsg(\\\"NO_RESOURCE_TO_CHARGE\\\")\\n\\t\\treturn nil\\n\\t}\\n\\treturn c.ProcessChargeDetail(chargeDetail)\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go\",\n    \"code_start_line\": 21,\n    \"code_end_line\": 38,\n    \"code_key\": \"FindBySerial\",\n    \"code_value\": \"func (p *physicalVolumeRepositoryImpl) FindBySerial(ctx context.Context, serial rdiskDomain.Serial) (*rdiskDomain.PhysicalVolume, error) {\\n\\tuow := getUow(ctx)\\n\\tvar vol metadb.DmPhydisk\\n\\tresult := uow.tx.Where(\\\"serial = ?\\\", string(serial)).First(&vol)\\n\\tif result.Error != nil {\\n\\t\\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\\n\\t\\t\\t// 覆盖 gorm 的错误\\n\\t\\t\\treturn nil, errors.New(rdiskDomain.ErrPhysicalVolumeNotExists, \\\"physical volume not exists\\\")\\n\\t\\t}\\n\\t\\treturn nil, result.Error\\n\\t}\\n\\tif result.RowsAffected == 0 {\\n\\t\\treturn nil, nil\\n\\t}\\n\\tpv := fromDmPhyDiskToPhysicalVolume(ctx, &vol)\\n\\tpv = uow.trackedPhyVolumes.Add(pv)\\n\\treturn pv, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM dm_phydisk WHERE serial = ? LIMIT 1;\"]",
      "parsed_sql": [
        "SELECT * FROM dm_phydisk WHERE serial = ? LIMIT 1;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 1,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM dm_phydisk WHERE serial = ? LIMIT 1;",
            "match_result": {
              "matched": true,
              "fingerprint": "0fdf2b4f4a53dfe58ca51876e84148aa",
              "example_sql": "SELECT * FROM `dm_phydisk` WHERE `dm_phydisk`.`serial` = 'S5G3NA0R104118'",
              "example_count": 100
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go:40:57:FindByIPAndBDF",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：FindByIPAndBDF\nfunc (p *physicalVolumeRepositoryImpl) FindByIPAndBDF(ctx context.Context, ip net.IP, bdf rdiskDomain.BDF) (*rdiskDomain.PhysicalVolume, error) {\n\tuow := getUow(ctx)\n\tvar vol metadb.DmPhydisk\n\tresult := uow.tx.Where(\"host_ip = ? AND bdf = ?\", ip.String(), string(bdf)).Find(&vol)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\t// 覆盖 gorm 的错误\n\t\t\treturn nil, errors.New(rdiskDomain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tpv := fromDmPhyDiskToPhysicalVolume(ctx, &vol)\n\tpv = uow.trackedPhyVolumes.Add(pv)\n\treturn pv, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go\", \"code_start_line\": 51, \"code_end_line\": 72, \"code_key\": \"Handle\", \"code_value\": \"func (c *CbsAppIdConsumer) Handle(ctx context.Context, delivery *rabbitmq.Delivery) error {\\n\\tu, chargeTime, err := c.ParseDelivery(ctx, delivery)\\n\\tif err != nil {\\n\\t\\treturn err\\n\\t}\\n\\tif u == nil {\\n\\t\\tlogs.Info(c.Ctx).\\n\\t\\t\\tTime(\\\"chargeTime\\\", chargeTime).\\n\\t\\t\\tMsg(\\\"USER_INFO_NOT_FOUND\\\")\\n\\t\\treturn nil\\n\\t}\\n\\n\\tchargeDetail := c.GetChargeDetailForSingleUser(u, chargeTime)\\n\\tif chargeDetail == nil {\\n\\t\\tlogs.Info(c.Ctx).\\n\\t\\t\\tUint64(\\\"appId\\\", uint64(u.AppId)).\\n\\t\\t\\tTime(\\\"chargeTime\\\", chargeTime).\\n\\t\\t\\tMsg(\\\"NO_RESOURCE_TO_CHARGE\\\")\\n\\t\\treturn nil\\n\\t}\\n\\treturn c.ProcessChargeDetail(chargeDetail)\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go\",\n    \"code_start_line\": 40,\n    \"code_end_line\": 57,\n    \"code_key\": \"FindByIPAndBDF\",\n    \"code_value\": \"func (p *physicalVolumeRepositoryImpl) FindByIPAndBDF(ctx context.Context, ip net.IP, bdf rdiskDomain.BDF) (*rdiskDomain.PhysicalVolume, error) {\\n\\tuow := getUow(ctx)\\n\\tvar vol metadb.DmPhydisk\\n\\tresult := uow.tx.Where(\\\"host_ip = ? AND bdf = ?\\\", ip.String(), string(bdf)).Find(&vol)\\n\\tif result.Error != nil {\\n\\t\\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\\n\\t\\t\\t// 覆盖 gorm 的错误\\n\\t\\t\\treturn nil, errors.New(rdiskDomain.ErrPhysicalVolumeNotExists, \\\"physical volume not exists\\\")\\n\\t\\t}\\n\\t\\treturn nil, result.Error\\n\\t}\\n\\tif result.RowsAffected == 0 {\\n\\t\\treturn nil, nil\\n\\t}\\n\\tpv := fromDmPhyDiskToPhysicalVolume(ctx, &vol)\\n\\tpv = uow.trackedPhyVolumes.Add(pv)\\n\\treturn pv, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM dm_phydisk WHERE host_ip = ? AND bdf = ?;\"]",
      "parsed_sql": [
        "SELECT * FROM dm_phydisk WHERE host_ip = ? AND bdf = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM dm_phydisk WHERE host_ip = ? AND bdf = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "c2389557e346d20672e1f8ad0ca61ca1",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go:150:191:updatePhysicalVolume",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：updatePhysicalVolume\nfunc updatePhysicalVolume(ctx context.Context, item, originalState *rdiskDomain.PhysicalVolume) error {\n\tuow := getUow(ctx)\n\tcurDO := fromPhysicalVolumeToDmPhyDisk(ctx, item)\n\toriginalDO := fromPhysicalVolumeToDmPhyDisk(ctx, originalState)\n\tchanges := make(map[string]interface{})\n\n\tcheckChange := func(field string, cur interface{}, original interface{}) {\n\t\tif cur != original {\n\t\t\tchanges[field] = cur\n\t\t}\n\t}\n\n\tcheckChange(\"serial\", curDO.Serial, originalDO.Serial)\n\tcheckChange(\"host_ip\", curDO.IP, originalDO.IP)\n\tcheckChange(\"bdf\", curDO.BDF, originalDO.BDF)\n\tcheckChange(\"disk_id\", curDO.DiskID, originalDO.DiskID)\n\tcheckChange(\"port\", curDO.Port, originalDO.Port)\n\tcheckChange(\"status\", curDO.Status, originalDO.Status)\n\tcheckChange(\"size\", curDO.Size, originalDO.Size)\n\tcheckChange(\"real_size\", curDO.RealSize, originalDO.RealSize)\n\tcheckChange(\"block_size\", curDO.BlockSize, originalDO.BlockSize)\n\tcheckChange(\"zone_id\", curDO.ZoneID, originalDO.ZoneID)\n\tcheckChange(\"volume_type\", curDO.VolumeType, originalDO.VolumeType)\n\tcheckChange(\"node_type\", curDO.NodeType, originalDO.NodeType)\n\tcheckChange(\"extra\", curDO.Extra, originalDO.Extra)\n\tcheckChange(\"perf_rank\", curDO.PerformanceRank, originalDO.PerformanceRank)\n\n\tif len(changes) == 0 {\n\t\treturn nil\n\t}\n\n\tchanges[\"updated\"] = uow.tx.NowFunc()\n\n\tresult := uow.tx.Model(curDO).Where(\"id = ?\", curDO.ID).Updates(changes)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\tlogs.Warn(ctx).Any(\"changes\", changes).Uint64(\"pid\", curDO.ID).Msg(\"no rows affected when updating physical volume\")\n\t}\n\treturn nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go\",\n    \"code_start_line\": 150,\n    \"code_end_line\": 191,\n    \"code_key\": \"updatePhysicalVolume\",\n    \"code_value\": \"func updatePhysicalVolume(ctx context.Context, item, originalState *rdiskDomain.PhysicalVolume) error {\\n\\tuow := getUow(ctx)\\n\\tcurDO := fromPhysicalVolumeToDmPhyDisk(ctx, item)\\n\\toriginalDO := fromPhysicalVolumeToDmPhyDisk(ctx, originalState)\\n\\tchanges := make(map[string]interface{})\\n\\n\\tcheckChange := func(field string, cur interface{}, original interface{}) {\\n\\t\\tif cur != original {\\n\\t\\t\\tchanges[field] = cur\\n\\t\\t}\\n\\t}\\n\\n\\tcheckChange(\\\"serial\\\", curDO.Serial, originalDO.Serial)\\n\\tcheckChange(\\\"host_ip\\\", curDO.IP, originalDO.IP)\\n\\tcheckChange(\\\"bdf\\\", curDO.BDF, originalDO.BDF)\\n\\tcheckChange(\\\"disk_id\\\", curDO.DiskID, originalDO.DiskID)\\n\\tcheckChange(\\\"port\\\", curDO.Port, originalDO.Port)\\n\\tcheckChange(\\\"status\\\", curDO.Status, originalDO.Status)\\n\\tcheckChange(\\\"size\\\", curDO.Size, originalDO.Size)\\n\\tcheckChange(\\\"real_size\\\", curDO.RealSize, originalDO.RealSize)\\n\\tcheckChange(\\\"block_size\\\", curDO.BlockSize, originalDO.BlockSize)\\n\\tcheckChange(\\\"zone_id\\\", curDO.ZoneID, originalDO.ZoneID)\\n\\tcheckChange(\\\"volume_type\\\", curDO.VolumeType, originalDO.VolumeType)\\n\\tcheckChange(\\\"node_type\\\", curDO.NodeType, originalDO.NodeType)\\n\\tcheckChange(\\\"extra\\\", curDO.Extra, originalDO.Extra)\\n\\tcheckChange(\\\"perf_rank\\\", curDO.PerformanceRank, originalDO.PerformanceRank)\\n\\n\\tif len(changes) == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tchanges[\\\"updated\\\"] = uow.tx.NowFunc()\\n\\n\\tresult := uow.tx.Model(curDO).Where(\\\"id = ?\\\", curDO.ID).Updates(changes)\\n\\tif result.Error != nil {\\n\\t\\treturn result.Error\\n\\t}\\n\\tif result.RowsAffected == 0 {\\n\\t\\tlogs.Warn(ctx).Any(\\\"changes\\\", changes).Uint64(\\\"pid\\\", curDO.ID).Msg(\\\"no rows affected when updating physical volume\\\")\\n\\t}\\n\\treturn nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"单个字段变化（如serial）\", \"sql\": \"UPDATE dm_phy_disk SET serial = ?, updated = ? WHERE id = ?;\"}, {\"scenario\": \"多个字段变化（如serial和host_ip）\", \"sql\": \"UPDATE dm_phy_disk SET serial = ?, host_ip = ?, updated = ? WHERE id = ?;\"}, {\"scenario\": \"所有字段都变化\", \"sql\": \"UPDATE dm_phy_disk SET serial = ?, host_ip = ?, bdf = ?, disk_id = ?, port = ?, status = ?, size = ?, real_size = ?, block_size = ?, zone_id = ?, volume_type = ?, node_type = ?, extra = ?, perf_rank = ?, updated = ? WHERE id = ?;\"}]}]",
      "parsed_sql": [
        "UPDATE dm_phy_disk SET serial = ?, updated = ? WHERE id = ?;",
        "UPDATE dm_phy_disk SET serial = ?, host_ip = ?, updated = ? WHERE id = ?;",
        "UPDATE dm_phy_disk SET serial = ?, host_ip = ?, bdf = ?, disk_id = ?, port = ?, status = ?, size = ?, real_size = ?, block_size = ?, zone_id = ?, volume_type = ?, node_type = ?, extra = ?, perf_rank = ?, updated = ? WHERE id = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 3,
        "valid_sql": 3,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "UPDATE dm_phy_disk SET serial = ?, updated = ? WHERE id = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "9edfcd688c223c8ae53d5fb607d9f622",
              "excluded": false
            }
          },
          {
            "sql": "UPDATE dm_phy_disk SET serial = ?, host_ip = ?, updated = ? WHERE id = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "9edfcd688c223c8ae53d5fb607d9f622",
              "excluded": false
            }
          },
          {
            "sql": "UPDATE dm_phy_disk SET serial = ?, host_ip = ?, bdf = ?, disk_id = ?, port = ?, status = ?, size = ?, real_size = ?, block_size = ?, zone_id = ?, volume_type = ?, node_type = ?, extra = ?, perf_rank = ?, updated = ? WHERE id = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "9edfcd688c223c8ae53d5fb607d9f622",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/drgroup.go:75:90:FindByName",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：FindByName\nfunc (d *drgroupViewerImpl) FindByName(ctx context.Context, appId users.AppID, name string) (*drgroup.View, error) {\n\tvar (\n\t\tresultView drgroup.View\n\t\tdataObject metadb.DmDrgroup\n\t)\n\n\tresult := d.db.WithContext(ctx).First(&dataObject, \"app_id = ? and name = ?\", appId, name)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"group not exist\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\td.translate(&dataObject, &resultView)\n\treturn &resultView, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go\", \"code_start_line\": 51, \"code_end_line\": 72, \"code_key\": \"Handle\", \"code_value\": \"func (c *CbsAppIdConsumer) Handle(ctx context.Context, delivery *rabbitmq.Delivery) error {\\n\\tu, chargeTime, err := c.ParseDelivery(ctx, delivery)\\n\\tif err != nil {\\n\\t\\treturn err\\n\\t}\\n\\tif u == nil {\\n\\t\\tlogs.Info(c.Ctx).\\n\\t\\t\\tTime(\\\"chargeTime\\\", chargeTime).\\n\\t\\t\\tMsg(\\\"USER_INFO_NOT_FOUND\\\")\\n\\t\\treturn nil\\n\\t}\\n\\n\\tchargeDetail := c.GetChargeDetailForSingleUser(u, chargeTime)\\n\\tif chargeDetail == nil {\\n\\t\\tlogs.Info(c.Ctx).\\n\\t\\t\\tUint64(\\\"appId\\\", uint64(u.AppId)).\\n\\t\\t\\tTime(\\\"chargeTime\\\", chargeTime).\\n\\t\\t\\tMsg(\\\"NO_RESOURCE_TO_CHARGE\\\")\\n\\t\\treturn nil\\n\\t}\\n\\treturn c.ProcessChargeDetail(chargeDetail)\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/drgroup.go\",\n    \"code_start_line\": 75,\n    \"code_end_line\": 90,\n    \"code_key\": \"FindByName\",\n    \"code_value\": \"func (d *drgroupViewerImpl) FindByName(ctx context.Context, appId users.AppID, name string) (*drgroup.View, error) {\\n\\tvar (\\n\\t\\tresultView drgroup.View\\n\\t\\tdataObject metadb.DmDrgroup\\n\\t)\\n\\n\\tresult := d.db.WithContext(ctx).First(&dataObject, \\\"app_id = ? and name = ?\\\", appId, name)\\n\\tif result.Error != nil {\\n\\t\\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\\n\\t\\t\\treturn nil, errors.New(drgroup.ErrGroupNotExist, \\\"group not exist\\\")\\n\\t\\t}\\n\\t\\treturn nil, result.Error\\n\\t}\\n\\td.translate(&dataObject, &resultView)\\n\\treturn &resultView, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM dm_drgroup WHERE app_id = ? AND name = ? ORDER BY id LIMIT 1;\"]",
      "parsed_sql": [
        "SELECT * FROM dm_drgroup WHERE app_id = ? AND name = ? ORDER BY id LIMIT 1;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM dm_drgroup WHERE app_id = ? AND name = ? ORDER BY id LIMIT 1;",
            "match_result": {
              "matched": false,
              "fingerprint": "0d16bb34bfd2beb2d69313e05071f1f7",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go:31:52:FindByNames",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：FindByNames\nfunc (d drgroupRepositoryImpl) FindByNames(ctx context.Context, appId users.AppID, names []string) ([]*drgroup.DRGroup, error) {\n\tuow := getUow(ctx)\n\tgroup := []metadb.DmDrgroup{}\n\tresult := uow.tx.\n\t\tPreload(\"Members\").\n\t\tFind(&group, \"app_id = ? and name in ?\", appId, names)\n\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"disaster recovery group not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tresults := make([]*drgroup.DRGroup, len(group))\n\tfor i := range group {\n\t\tresults[i] = uow.trackedDRGroups.Add(fromDmDRGroupToModel(&group[i]))\n\t}\n\treturn results, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go\", \"code_start_line\": 20, \"code_end_line\": 29, \"code_key\": \"FindByName\", \"code_value\": \"func (d drgroupRepositoryImpl) FindByName(ctx context.Context, appId users.AppID, name string) (*drgroup.DRGroup, error) {\\n\\tresults, err := d.FindByNames(ctx, appId, []string{name})\\n\\tif err != nil {\\n\\t\\treturn nil, err\\n\\t}\\n\\tif len(results) < 1 {\\n\\t\\treturn nil, errors.New(drgroup.ErrGroupNotExist, \\\"disaster recovery group not exists\\\")\\n\\t}\\n\\treturn results[0], nil\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go\",\n    \"code_start_line\": 31,\n    \"code_end_line\": 52,\n    \"code_key\": \"FindByNames\",\n    \"code_value\": \"func (d drgroupRepositoryImpl) FindByNames(ctx context.Context, appId users.AppID, names []string) ([]*drgroup.DRGroup, error) {\\n\\tuow := getUow(ctx)\\n\\tgroup := []metadb.DmDrgroup{}\\n\\tresult := uow.tx.\\n\\t\\tPreload(\\\"Members\\\").\\n\\t\\tFind(&group, \\\"app_id = ? and name in ?\\\", appId, names)\\n\\n\\tif result.Error != nil {\\n\\t\\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\\n\\t\\t\\treturn nil, errors.New(drgroup.ErrGroupNotExist, \\\"disaster recovery group not exists\\\")\\n\\t\\t}\\n\\t\\treturn nil, result.Error\\n\\t}\\n\\tif result.RowsAffected == 0 {\\n\\t\\treturn nil, nil\\n\\t}\\n\\tresults := make([]*drgroup.DRGroup, len(group))\\n\\tfor i := range group {\\n\\t\\tresults[i] = uow.trackedDRGroups.Add(fromDmDRGroupToModel(&group[i]))\\n\\t}\\n\\treturn results, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"Preload Members\", \"sql\": \"SELECT * FROM dm_drgroup WHERE app_id = ? AND name IN ?;\"}, {\"scenario\": \"Preload Members with association query\", \"sql\": \"SELECT * FROM dm_drgroup_members WHERE group_id IN (SELECT id FROM dm_drgroup WHERE app_id = ? AND name IN ?);\"}]}]",
      "parsed_sql": [
        "SELECT * FROM dm_drgroup WHERE app_id = ? AND name IN ?;",
        "SELECT * FROM dm_drgroup_members WHERE group_id IN (SELECT id FROM dm_drgroup WHERE app_id = ? AND name IN ?);"
      ],
      "sql_evaluation": {
        "total_sql": 2,
        "valid_sql": 2,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM dm_drgroup WHERE app_id = ? AND name IN ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "0d16bb34bfd2beb2d69313e05071f1f7",
              "excluded": false
            }
          },
          {
            "sql": "SELECT * FROM dm_drgroup_members WHERE group_id IN (SELECT id FROM dm_drgroup WHERE app_id = ? AND name IN ?);",
            "match_result": {
              "matched": false,
              "fingerprint": "d06115a74cd90724f651c873a9b46290",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go:58:94:FindByMembers",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：FindByMembers\nfunc (d drgroupRepositoryImpl) FindByMembers(ctx context.Context, appId users.AppID, members []string) ([]*drgroup.DRGroup, error) {\n\tuow := getUow(ctx)\n\tgroup := []metadb.DmDrgroup{}\n\n\tmembersResult := []metadb.DmDrgroupMembers{}\n\tresult := uow.tx.\n\t\tFind(&membersResult, \"app_id = ? and member_id in ?\", appId, members)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tnames := make([]string, 0, len(members))\n\tfor i := range membersResult {\n\t\tnames = append(names, membersResult[i].GroupName)\n\t}\n\tresult = uow.tx.\n\t\tPreload(\"Members\").\n\t\tFind(&group, \"app_id = ? and name in ?\", appId, names)\n\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"disaster recovery group not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tresults := make([]*drgroup.DRGroup, len(group))\n\tfor i := range group {\n\t\tresults[i] = fromDmDRGroupToModel(&group[i])\n\t\tresults[i] = uow.trackedDRGroups.Add(results[i])\n\t}\n\treturn results, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go\", \"code_start_line\": 51, \"code_end_line\": 72, \"code_key\": \"Handle\", \"code_value\": \"func (c *CbsAppIdConsumer) Handle(ctx context.Context, delivery *rabbitmq.Delivery) error {\\n\\tu, chargeTime, err := c.ParseDelivery(ctx, delivery)\\n\\tif err != nil {\\n\\t\\treturn err\\n\\t}\\n\\tif u == nil {\\n\\t\\tlogs.Info(c.Ctx).\\n\\t\\t\\tTime(\\\"chargeTime\\\", chargeTime).\\n\\t\\t\\tMsg(\\\"USER_INFO_NOT_FOUND\\\")\\n\\t\\treturn nil\\n\\t}\\n\\n\\tchargeDetail := c.GetChargeDetailForSingleUser(u, chargeTime)\\n\\tif chargeDetail == nil {\\n\\t\\tlogs.Info(c.Ctx).\\n\\t\\t\\tUint64(\\\"appId\\\", uint64(u.AppId)).\\n\\t\\t\\tTime(\\\"chargeTime\\\", chargeTime).\\n\\t\\t\\tMsg(\\\"NO_RESOURCE_TO_CHARGE\\\")\\n\\t\\treturn nil\\n\\t}\\n\\treturn c.ProcessChargeDetail(chargeDetail)\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go\",\n    \"code_start_line\": 58,\n    \"code_end_line\": 94,\n    \"code_key\": \"FindByMembers\",\n    \"code_value\": \"func (d drgroupRepositoryImpl) FindByMembers(ctx context.Context, appId users.AppID, members []string) ([]*drgroup.DRGroup, error) {\\n\\tuow := getUow(ctx)\\n\\tgroup := []metadb.DmDrgroup{}\\n\\n\\tmembersResult := []metadb.DmDrgroupMembers{}\\n\\tresult := uow.tx.\\n\\t\\tFind(&membersResult, \\\"app_id = ? and member_id in ?\\\", appId, members)\\n\\tif result.Error != nil {\\n\\t\\treturn nil, result.Error\\n\\t}\\n\\tif result.RowsAffected == 0 {\\n\\t\\treturn nil, nil\\n\\t}\\n\\tnames := make([]string, 0, len(members))\\n\\tfor i := range membersResult {\\n\\t\\tnames = append(names, membersResult[i].GroupName)\\n\\t}\\n\\tresult = uow.tx.\\n\\t\\tPreload(\\\"Members\\\").\\n\\t\\tFind(&group, \\\"app_id = ? and name in ?\\\", appId, names)\\n\\n\\tif result.Error != nil {\\n\\t\\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\\n\\t\\t\\treturn nil, errors.New(drgroup.ErrGroupNotExist, \\\"disaster recovery group not exists\\\")\\n\\t\\t}\\n\\t\\treturn nil, result.Error\\n\\t}\\n\\tif result.RowsAffected == 0 {\\n\\t\\treturn nil, nil\\n\\t}\\n\\tresults := make([]*drgroup.DRGroup, len(group))\\n\\tfor i := range group {\\n\\t\\tresults[i] = fromDmDRGroupToModel(&group[i])\\n\\t\\tresults[i] = uow.trackedDRGroups.Add(results[i])\\n\\t}\\n\\treturn results, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM dm_drgroup_members WHERE app_id = ? AND member_id IN (?);\", {\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"Preload Members\", \"sql\": \"SELECT * FROM dm_drgroup WHERE app_id = ? AND name IN (?);\"}]}, {\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"Preload Members with association query\", \"sql\": \"SELECT * FROM dm_drgroup_members WHERE (app_id, group_name) IN ((?, ?), ...);\"}]}]",
      "parsed_sql": [
        "SELECT * FROM dm_drgroup_members WHERE app_id = ? AND member_id IN (?);",
        "SELECT * FROM dm_drgroup WHERE app_id = ? AND name IN (?);",
        "SELECT * FROM dm_drgroup_members WHERE (app_id, group_name) IN ((?, ?), ...);"
      ],
      "sql_evaluation": {
        "total_sql": 3,
        "valid_sql": 2,
        "matched_sql": 0,
        "excluded_sql": 1,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM dm_drgroup_members WHERE app_id = ? AND member_id IN (?);",
            "match_result": {
              "matched": false,
              "fingerprint": "20d6fc3fbb303593536167d5775aeb4a",
              "excluded": false
            }
          },
          {
            "sql": "SELECT * FROM dm_drgroup WHERE app_id = ? AND name IN (?);",
            "match_result": {
              "matched": false,
              "fingerprint": "0d16bb34bfd2beb2d69313e05071f1f7",
              "excluded": false
            }
          },
          {
            "sql": "SELECT * FROM dm_drgroup_members WHERE (app_id, group_name) IN ((?, ?), ...);",
            "match_result": {
              "matched": false,
              "excluded": true,
              "fingerprint": "invalid_sql",
              "excluded_reason": "排除的SQL类型"
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/drgroup.go:92:124:FindByMembers",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：FindByMembers\nfunc (d *drgroupViewerImpl) FindByMembers(ctx context.Context, appId users.AppID, members []string) ([]*drgroup.View, error) {\n\tvar (\n\t\tresultViews       []drgroup.View\n\t\tresultViewRef     []*drgroup.View\n\t\tdataObjects       []*metadb.DmDrgroup\n\t\tdataObjectMembers []*metadb.DmDrgroupMembers\n\t)\n\tresult := d.db.WithContext(ctx).Find(&dataObjectMembers, \"app_id = ? and member_id in ?\", appId, members)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"group not exist\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tgroupNames := make([]string, len(dataObjectMembers))\n\tfor i := range dataObjectMembers {\n\t\tgroupNames[i] = dataObjectMembers[i].GroupName\n\t}\n\tresult = d.db.WithContext(ctx).Find(&dataObjects, \"app_id = ? and name in ?\", appId, groupNames)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"group not exist\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tresultViews = make([]drgroup.View, len(dataObjects))\n\tresultViewRef = make([]*drgroup.View, len(dataObjects))\n\tfor i := range dataObjects {\n\t\tresultViewRef[i] = &resultViews[i]\n\t\td.translate(dataObjects[i], resultViewRef[i])\n\t}\n\treturn resultViewRef, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go\", \"code_start_line\": 51, \"code_end_line\": 72, \"code_key\": \"Handle\", \"code_value\": \"func (c *CbsAppIdConsumer) Handle(ctx context.Context, delivery *rabbitmq.Delivery) error {\\n\\tu, chargeTime, err := c.ParseDelivery(ctx, delivery)\\n\\tif err != nil {\\n\\t\\treturn err\\n\\t}\\n\\tif u == nil {\\n\\t\\tlogs.Info(c.Ctx).\\n\\t\\t\\tTime(\\\"chargeTime\\\", chargeTime).\\n\\t\\t\\tMsg(\\\"USER_INFO_NOT_FOUND\\\")\\n\\t\\treturn nil\\n\\t}\\n\\n\\tchargeDetail := c.GetChargeDetailForSingleUser(u, chargeTime)\\n\\tif chargeDetail == nil {\\n\\t\\tlogs.Info(c.Ctx).\\n\\t\\t\\tUint64(\\\"appId\\\", uint64(u.AppId)).\\n\\t\\t\\tTime(\\\"chargeTime\\\", chargeTime).\\n\\t\\t\\tMsg(\\\"NO_RESOURCE_TO_CHARGE\\\")\\n\\t\\treturn nil\\n\\t}\\n\\treturn c.ProcessChargeDetail(chargeDetail)\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/drgroup.go\",\n    \"code_start_line\": 92,\n    \"code_end_line\": 124,\n    \"code_key\": \"FindByMembers\",\n    \"code_value\": \"func (d *drgroupViewerImpl) FindByMembers(ctx context.Context, appId users.AppID, members []string) ([]*drgroup.View, error) {\\n\\tvar (\\n\\t\\tresultViews       []drgroup.View\\n\\t\\tresultViewRef     []*drgroup.View\\n\\t\\tdataObjects       []*metadb.DmDrgroup\\n\\t\\tdataObjectMembers []*metadb.DmDrgroupMembers\\n\\t)\\n\\tresult := d.db.WithContext(ctx).Find(&dataObjectMembers, \\\"app_id = ? and member_id in ?\\\", appId, members)\\n\\tif result.Error != nil {\\n\\t\\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\\n\\t\\t\\treturn nil, errors.New(drgroup.ErrGroupNotExist, \\\"group not exist\\\")\\n\\t\\t}\\n\\t\\treturn nil, result.Error\\n\\t}\\n\\tgroupNames := make([]string, len(dataObjectMembers))\\n\\tfor i := range dataObjectMembers {\\n\\t\\tgroupNames[i] = dataObjectMembers[i].GroupName\\n\\t}\\n\\tresult = d.db.WithContext(ctx).Find(&dataObjects, \\\"app_id = ? and name in ?\\\", appId, groupNames)\\n\\tif result.Error != nil {\\n\\t\\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\\n\\t\\t\\treturn nil, errors.New(drgroup.ErrGroupNotExist, \\\"group not exist\\\")\\n\\t\\t}\\n\\t\\treturn nil, result.Error\\n\\t}\\n\\tresultViews = make([]drgroup.View, len(dataObjects))\\n\\tresultViewRef = make([]*drgroup.View, len(dataObjects))\\n\\tfor i := range dataObjects {\\n\\t\\tresultViewRef[i] = &resultViews[i]\\n\\t\\td.translate(dataObjects[i], resultViewRef[i])\\n\\t}\\n\\treturn resultViewRef, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM dm_drgroup_members WHERE app_id = ? AND member_id IN (?);\", \"SELECT * FROM dm_drgroup WHERE app_id = ? AND name IN (?);\"]",
      "parsed_sql": [
        "SELECT * FROM dm_drgroup_members WHERE app_id = ? AND member_id IN (?);",
        "SELECT * FROM dm_drgroup WHERE app_id = ? AND name IN (?);"
      ],
      "sql_evaluation": {
        "total_sql": 2,
        "valid_sql": 2,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM dm_drgroup_members WHERE app_id = ? AND member_id IN (?);",
            "match_result": {
              "matched": false,
              "fingerprint": "20d6fc3fbb303593536167d5775aeb4a",
              "excluded": false
            }
          },
          {
            "sql": "SELECT * FROM dm_drgroup WHERE app_id = ? AND name IN (?);",
            "match_result": {
              "matched": false,
              "fingerprint": "0d16bb34bfd2beb2d69313e05071f1f7",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go:165:277:updateDRGroup",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：updateDRGroup\nfunc updateDRGroup(ctx context.Context, item, originalState *drgroup.DRGroup) error {\n\tuow := getUow(ctx)\n\tcurDO := fromModelToDmDRGroup(item)\n\toriginalDO := fromModelToDmDRGroup(originalState)\n\tchanges := make(map[string]interface{})\n\tcheckChange := func(field string, cur interface{}, original interface{}) {\n\t\tif cur != original {\n\t\t\tif field == \"member_cnt\" || field == \"sub_group_cnt\" {\n\t\t\t\tdiff := cur.(int) - original.(int)\n\t\t\t\tif diff < 0 {\n\t\t\t\t\tchanges[field] = gorm.Expr(fmt.Sprintf(\"%s - %d\", field, -1*diff))\n\t\t\t\t} else {\n\t\t\t\t\tchanges[field] = gorm.Expr(fmt.Sprintf(\"%s + %d\", field, diff))\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tchanges[field] = cur\n\t\t\t}\n\t\t}\n\t}\n\tcheckChange(\"status\", curDO.Status, originalDO.Status)\n\tcheckChange(\"app_id\", curDO.AppID, originalDO.AppID)\n\tcheckChange(\"name\", curDO.Name, originalDO.Name)\n\tcheckChange(\"affinity\", curDO.Affinity, originalDO.Affinity)\n\tcheckChange(\"loc_type\", curDO.LocType, originalDO.LocType)\n\tcheckChange(\"satisfied\", curDO.Satisfied, originalDO.Satisfied)\n\tcheckChange(\"member_cnt\", curDO.MemberCnt, originalDO.MemberCnt)\n\tcheckChange(\"sub_group_cnt\", curDO.SubGroupCnt, originalDO.SubGroupCnt)\n\tcheckChange(\"extra\", curDO.Extra, originalDO.Extra)\n\n\tif len(changes) != 0 {\n\t\tchanges[\"updated\"] = uow.tx.NowFunc()\n\n\t\tresult := uow.tx.Model(curDO).Where(\"id = ?\", curDO.ID).Updates(changes)\n\t\tif result.Error != nil {\n\t\t\treturn result.Error\n\t\t}\n\t}\n\n\t// 更新成员信息\n\tallMembers := make(map[string]struct{})\n\ttype memberInfo struct {\n\t\tLoc      string\n\t\tSubGroup string\n\t}\n\toriginMembers := make(map[string]memberInfo)\n\tcurMembers := make(map[string]memberInfo)\n\tfor _, a := range item.GetMembers() {\n\t\tallMembers[a.ID] = struct{}{}\n\t\tcurMembers[a.ID] = memberInfo{\n\t\t\tLoc:      a.Location,\n\t\t\tSubGroup: a.SubGroup,\n\t\t}\n\t}\n\tfor _, a := range originalState.GetMembers() {\n\t\tallMembers[a.ID] = struct{}{}\n\t\toriginMembers[a.ID] = memberInfo{\n\t\t\tLoc:      a.Location,\n\t\t\tSubGroup: a.SubGroup,\n\t\t}\n\t}\n\n\tfor memberId := range allMembers {\n\t\tcurInfo, _ := curMembers[memberId]\n\t\toriginInfo, _ := originMembers[memberId]\n\t\tif originInfo.Loc == \"\" && curInfo.Loc != \"\" {\n\t\t\tdo := &metadb.DmDrgroupMembers{\n\t\t\t\tAppID:     int64(item.AppID),\n\t\t\t\tGroupName: item.Name,\n\t\t\t\tSubGroup:  curInfo.SubGroup,\n\t\t\t\tLoc:       curInfo.Loc,\n\t\t\t\tMemberID:  memberId,\n\t\t\t\tExtra:     \"{}\",\n\t\t\t\tCreated:   uow.tx.NowFunc(),\n\t\t\t\tUpdated:   uow.tx.NowFunc(),\n\t\t\t}\n\t\t\tresult := uow.tx.Create(do)\n\t\t\tif result.Error != nil {\n\t\t\t\treturn result.Error\n\t\t\t}\n\t\t} else if originInfo.Loc != \"\" && curInfo.Loc == \"\" {\n\t\t\tresult := uow.tx.Delete(&metadb.DmDrgroupMembers{},\n\t\t\t\t\"app_id = ? and group_name = ? and member_id = ?\",\n\t\t\t\toriginalState.AppID, originalState.Name, memberId)\n\t\t\tif result.Error != nil {\n\t\t\t\treturn result.Error\n\t\t\t}\n\t\t} else if originInfo.Loc != \"\" && curInfo.Loc != \"\" {\n\t\t\tchanges := make(map[string]interface{})\n\t\t\tcheckChange := func(field string, cur interface{}, original interface{}) {\n\t\t\t\tif cur != original {\n\t\t\t\t\tchanges[field] = cur\n\t\t\t\t}\n\t\t\t}\n\t\t\tcheckChange(\"loc\", curInfo.Loc, originInfo.Loc)\n\t\t\tcheckChange(\"app_id\", item.AppID, originalState.AppID)\n\t\t\tcheckChange(\"group_name\", item.Name, originalState.Name)\n\t\t\tcheckChange(\"sub_group\", curInfo.SubGroup, originInfo.SubGroup)\n\t\t\t//checkChange(\"extra\", \"{}\", \"{}\")\n\n\t\t\tif len(changes) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tchanges[\"updated\"] = uow.tx.NowFunc()\n\t\t\tresult := uow.tx.Model(&metadb.DmDrgroupMembers{}).Where(\n\t\t\t\t\"app_id = ? and group_name = ? and member_id = ?\",\n\t\t\t\toriginalState.AppID, originalState.Name, memberId).Updates(changes)\n\t\t\tif result.Error != nil {\n\t\t\t\treturn result.Error\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go\",\n    \"code_start_line\": 165,\n    \"code_end_line\": 277,\n    \"code_key\": \"updateDRGroup\",\n    \"code_value\": \"func updateDRGroup(ctx context.Context, item, originalState *drgroup.DRGroup) error {\\n\\tuow := getUow(ctx)\\n\\tcurDO := fromModelToDmDRGroup(item)\\n\\toriginalDO := fromModelToDmDRGroup(originalState)\\n\\tchanges := make(map[string]interface{})\\n\\tcheckChange := func(field string, cur interface{}, original interface{}) {\\n\\t\\tif cur != original {\\n\\t\\t\\tif field == \\\"member_cnt\\\" || field == \\\"sub_group_cnt\\\" {\\n\\t\\t\\t\\tdiff := cur.(int) - original.(int)\\n\\t\\t\\t\\tif diff < 0 {\\n\\t\\t\\t\\t\\tchanges[field] = gorm.Expr(fmt.Sprintf(\\\"%s - %d\\\", field, -1*diff))\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tchanges[field] = gorm.Expr(fmt.Sprintf(\\\"%s + %d\\\", field, diff))\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tchanges[field] = cur\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tcheckChange(\\\"status\\\", curDO.Status, originalDO.Status)\\n\\tcheckChange(\\\"app_id\\\", curDO.AppID, originalDO.AppID)\\n\\tcheckChange(\\\"name\\\", curDO.Name, originalDO.Name)\\n\\tcheckChange(\\\"affinity\\\", curDO.Affinity, originalDO.Affinity)\\n\\tcheckChange(\\\"loc_type\\\", curDO.LocType, originalDO.LocType)\\n\\tcheckChange(\\\"satisfied\\\", curDO.Satisfied, originalDO.Satisfied)\\n\\tcheckChange(\\\"member_cnt\\\", curDO.MemberCnt, originalDO.MemberCnt)\\n\\tcheckChange(\\\"sub_group_cnt\\\", curDO.SubGroupCnt, originalDO.SubGroupCnt)\\n\\tcheckChange(\\\"extra\\\", curDO.Extra, originalDO.Extra)\\n\\n\\tif len(changes) != 0 {\\n\\t\\tchanges[\\\"updated\\\"] = uow.tx.NowFunc()\\n\\n\\t\\tresult := uow.tx.Model(curDO).Where(\\\"id = ?\\\", curDO.ID).Updates(changes)\\n\\t\\tif result.Error != nil {\\n\\t\\t\\treturn result.Error\\n\\t\\t}\\n\\t}\\n\\n\\t// 更新成员信息\\n\\tallMembers := make(map[string]struct{})\\n\\ttype memberInfo struct {\\n\\t\\tLoc      string\\n\\t\\tSubGroup string\\n\\t}\\n\\toriginMembers := make(map[string]memberInfo)\\n\\tcurMembers := make(map[string]memberInfo)\\n\\tfor _, a := range item.GetMembers() {\\n\\t\\tallMembers[a.ID] = struct{}{}\\n\\t\\tcurMembers[a.ID] = memberInfo{\\n\\t\\t\\tLoc:      a.Location,\\n\\t\\t\\tSubGroup: a.SubGroup,\\n\\t\\t}\\n\\t}\\n\\tfor _, a := range originalState.GetMembers() {\\n\\t\\tallMembers[a.ID] = struct{}{}\\n\\t\\toriginMembers[a.ID] = memberInfo{\\n\\t\\t\\tLoc:      a.Location,\\n\\t\\t\\tSubGroup: a.SubGroup,\\n\\t\\t}\\n\\t}\\n\\n\\tfor memberId := range allMembers {\\n\\t\\tcurInfo, _ := curMembers[memberId]\\n\\t\\toriginInfo, _ := originMembers[memberId]\\n\\t\\tif originInfo.Loc == \\\"\\\" && curInfo.Loc != \\\"\\\" {\\n\\t\\t\\tdo := &metadb.DmDrgroupMembers{\\n\\t\\t\\t\\tAppID:     int64(item.AppID),\\n\\t\\t\\t\\tGroupName: item.Name,\\n\\t\\t\\t\\tSubGroup:  curInfo.SubGroup,\\n\\t\\t\\t\\tLoc:       curInfo.Loc,\\n\\t\\t\\t\\tMemberID:  memberId,\\n\\t\\t\\t\\tExtra:     \\\"{}\\\",\\n\\t\\t\\t\\tCreated:   uow.tx.NowFunc(),\\n\\t\\t\\t\\tUpdated:   uow.tx.NowFunc(),\\n\\t\\t\\t}\\n\\t\\t\\tresult := uow.tx.Create(do)\\n\\t\\t\\tif result.Error != nil {\\n\\t\\t\\t\\treturn result.Error\\n\\t\\t\\t}\\n\\t\\t} else if originInfo.Loc != \\\"\\\" && curInfo.Loc == \\\"\\\" {\\n\\t\\t\\tresult := uow.tx.Delete(&metadb.DmDrgroupMembers{},\\n\\t\\t\\t\\t\\\"app_id = ? and group_name = ? and member_id = ?\\\",\\n\\t\\t\\t\\toriginalState.AppID, originalState.Name, memberId)\\n\\t\\t\\tif result.Error != nil {\\n\\t\\t\\t\\treturn result.Error\\n\\t\\t\\t}\\n\\t\\t} else if originInfo.Loc != \\\"\\\" && curInfo.Loc != \\\"\\\" {\\n\\t\\t\\tchanges := make(map[string]interface{})\\n\\t\\t\\tcheckChange := func(field string, cur interface{}, original interface{}) {\\n\\t\\t\\t\\tif cur != original {\\n\\t\\t\\t\\t\\tchanges[field] = cur\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcheckChange(\\\"loc\\\", curInfo.Loc, originInfo.Loc)\\n\\t\\t\\tcheckChange(\\\"app_id\\\", item.AppID, originalState.AppID)\\n\\t\\t\\tcheckChange(\\\"group_name\\\", item.Name, originalState.Name)\\n\\t\\t\\tcheckChange(\\\"sub_group\\\", curInfo.SubGroup, originInfo.SubGroup)\\n\\t\\t\\t//checkChange(\\\"extra\\\", \\\"{}\\\", \\\"{}\\\")\\n\\n\\t\\t\\tif len(changes) == 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tchanges[\\\"updated\\\"] = uow.tx.NowFunc()\\n\\t\\t\\tresult := uow.tx.Model(&metadb.DmDrgroupMembers{}).Where(\\n\\t\\t\\t\\t\\\"app_id = ? and group_name = ? and member_id = ?\\\",\\n\\t\\t\\t\\toriginalState.AppID, originalState.Name, memberId).Updates(changes)\\n\\t\\t\\tif result.Error != nil {\\n\\t\\t\\t\\treturn result.Error\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"DRGroup属性有变化时\", \"sql\": \"UPDATE dm_drgroup SET status = ?, app_id = ?, name = ?, affinity = ?, loc_type = ?, satisfied = ?, member_cnt = ?, sub_group_cnt = ?, extra = ?, updated = ? WHERE id = ?;\"}]}, {\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"新增成员时\", \"sql\": \"INSERT INTO dm_drgroup_members (app_id, group_name, sub_group, loc, member_id, extra, created, updated) VALUES (?, ?, ?, ?, ?, ?, ?, ?);\"}, {\"scenario\": \"删除成员时\", \"sql\": \"DELETE FROM dm_drgroup_members WHERE app_id = ? AND group_name = ? AND member_id = ?;\"}, {\"scenario\": \"更新成员信息时\", \"sql\": \"UPDATE dm_drgroup_members SET loc = ?, app_id = ?, group_name = ?, sub_group = ?, updated = ? WHERE app_id = ? AND group_name = ? AND member_id = ?;\"}]}]",
      "parsed_sql": [
        "UPDATE dm_drgroup SET status = ?, app_id = ?, name = ?, affinity = ?, loc_type = ?, satisfied = ?, member_cnt = ?, sub_group_cnt = ?, extra = ?, updated = ? WHERE id = ?;",
        "INSERT INTO dm_drgroup_members (app_id, group_name, sub_group, loc, member_id, extra, created, updated) VALUES (?, ?, ?, ?, ?, ?, ?, ?);",
        "DELETE FROM dm_drgroup_members WHERE app_id = ? AND group_name = ? AND member_id = ?;",
        "UPDATE dm_drgroup_members SET loc = ?, app_id = ?, group_name = ?, sub_group = ?, updated = ? WHERE app_id = ? AND group_name = ? AND member_id = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 4,
        "valid_sql": 4,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "UPDATE dm_drgroup SET status = ?, app_id = ?, name = ?, affinity = ?, loc_type = ?, satisfied = ?, member_cnt = ?, sub_group_cnt = ?, extra = ?, updated = ? WHERE id = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "217961713c4ec0b7b66b559ba5cf9fff",
              "excluded": false
            }
          },
          {
            "sql": "INSERT INTO dm_drgroup_members (app_id, group_name, sub_group, loc, member_id, extra, created, updated) VALUES (?, ?, ?, ?, ?, ?, ?, ?);",
            "match_result": {
              "matched": false,
              "fingerprint": "67c9e90c3dfa54c7f3c9bb43570b1cd1",
              "excluded": false
            }
          },
          {
            "sql": "DELETE FROM dm_drgroup_members WHERE app_id = ? AND group_name = ? AND member_id = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "a38a4a9cad95da8b18fb8ddd232f8dee",
              "excluded": false
            }
          },
          {
            "sql": "UPDATE dm_drgroup_members SET loc = ?, app_id = ?, group_name = ?, sub_group = ?, updated = ? WHERE app_id = ? AND group_name = ? AND member_id = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "31ba966cbafe86e1d242d7de1bddbe38",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/benchmark.go:19:36:FindByDisk",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：FindByDisk\nfunc (v *benchmarkViewerImpl) FindByDisk(ctx context.Context, diskSerial string, bakUuids []string) ([]*benchmark.Benchmark, error) {\n\tvar (\n\t\tviews          []*benchmark.Benchmark\n\t\tdtos           []*metadb.DmRdiskBenchmark\n\t\tMaxResultCount = 20\n\t)\n\tquery := v.db.WithContext(ctx).Where(\"phy_id = ?\", diskSerial)\n\tif len(bakUuids) > 0 {\n\t\tquery = query.Where(\"uuid IN ?\", bakUuids)\n\t}\n\tquery = query.Order(\"created DESC\").Limit(MaxResultCount)\n\tresult := query.Find(&dtos)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\tviews = functools.MapTo(dtos, functools.MapRef(make([]benchmark.Benchmark, len(dtos))), v.translate)\n\treturn views, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go\", \"code_start_line\": 759, \"code_end_line\": 761, \"code_key\": \"QueryPhyRDiskBenchmark\", \"code_value\": \"func (s *UnimplementedMaster) QueryPhyRDiskBenchmark(ctx context.Context, req *QueryPhyRDiskBenchmarkRequest) (*QueryPhyRDiskBenchmarkResponse, error) {\\n\\treturn nil, errors.New(\\\"rpc QueryPhyRDiskBenchmark of service Master is not implemented\\\")\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/benchmark.go\",\n    \"code_start_line\": 19,\n    \"code_end_line\": 36,\n    \"code_key\": \"FindByDisk\",\n    \"code_value\": \"func (v *benchmarkViewerImpl) FindByDisk(ctx context.Context, diskSerial string, bakUuids []string) ([]*benchmark.Benchmark, error) {\\n\\tvar (\\n\\t\\tviews          []*benchmark.Benchmark\\n\\t\\tdtos           []*metadb.DmRdiskBenchmark\\n\\t\\tMaxResultCount = 20\\n\\t)\\n\\tquery := v.db.WithContext(ctx).Where(\\\"phy_id = ?\\\", diskSerial)\\n\\tif len(bakUuids) > 0 {\\n\\t\\tquery = query.Where(\\\"uuid IN ?\\\", bakUuids)\\n\\t}\\n\\tquery = query.Order(\\\"created DESC\\\").Limit(MaxResultCount)\\n\\tresult := query.Find(&dtos)\\n\\tif result.Error != nil {\\n\\t\\treturn nil, result.Error\\n\\t}\\n\\tviews = functools.MapTo(dtos, functools.MapRef(make([]benchmark.Benchmark, len(dtos))), v.translate)\\n\\treturn views, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"bakUuids为空或长度为0\", \"sql\": \"SELECT * FROM dm_phydisk_benchmark WHERE phy_id = ? ORDER BY created DESC LIMIT 20;\"}, {\"scenario\": \"bakUuids有值\", \"sql\": \"SELECT * FROM dm_phydisk_benchmark WHERE phy_id = ? AND uuid IN (?) ORDER BY created DESC LIMIT 20;\"}]}]",
      "parsed_sql": [
        "SELECT * FROM dm_phydisk_benchmark WHERE phy_id = ? ORDER BY created DESC LIMIT 20;",
        "SELECT * FROM dm_phydisk_benchmark WHERE phy_id = ? AND uuid IN (?) ORDER BY created DESC LIMIT 20;"
      ],
      "sql_evaluation": {
        "total_sql": 2,
        "valid_sql": 2,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM dm_phydisk_benchmark WHERE phy_id = ? ORDER BY created DESC LIMIT 20;",
            "match_result": {
              "matched": false,
              "fingerprint": "999b68ca90b9bbf436ab1037572986bc",
              "excluded": false
            }
          },
          {
            "sql": "SELECT * FROM dm_phydisk_benchmark WHERE phy_id = ? AND uuid IN (?) ORDER BY created DESC LIMIT 20;",
            "match_result": {
              "matched": false,
              "fingerprint": "3f703ec40bd9a864989bf7c022330eab",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/benchmark.go:39:50:FindByStatus",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：FindByStatus\nfunc (v *benchmarkViewerImpl) FindByStatus(ctx context.Context, status []benchmark.Status) ([]*benchmark.Benchmark, error) {\n\tvar (\n\t\tviews []*benchmark.Benchmark\n\t\tdtos  []*metadb.DmRdiskBenchmark\n\t)\n\tresult := v.db.WithContext(ctx).Where(\"status in ?\", status).Find(&dtos)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\tviews = functools.MapTo(dtos, functools.MapRef(make([]benchmark.Benchmark, len(dtos))), v.translate)\n\treturn views, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/tasks/update_benchmark.go\", \"code_start_line\": 25, \"code_end_line\": 52, \"code_key\": \"Work\", \"code_value\": \"func (*UpdateBenchmarkTask) Work(ctx context.Context) error {\\n\\tvar (\\n\\t\\tviewer     = app.GetRegistry(ctx).Viewers.Benchmark\\n\\t\\tdispatcher = app.GetRegistry(ctx).Dispatcher\\n\\t)\\n\\n\\t// 1. Find all running benchmarks\\n\\trunningStatus := []benchmark.Status{benchmark.StatusRunning}\\n\\tbenchs, err := viewer.FindByStatus(ctx, runningStatus)\\n\\tif err != nil {\\n\\t\\treturn err\\n\\t}\\n\\n\\t// 2. Fire events to update running benchmarks\\n\\tlogs.Info(ctx).Int(\\\"count\\\", len(benchs)).Msg(\\\"starts to update benchmark data\\\")\\n\\tfor _, b := range benchs {\\n\\t\\tcmd := &commands.UpdateBenchmarkTask{\\n\\t\\t\\tSerial:        b.DiskInfo.Serial,\\n\\t\\t\\tBenchmarkUUID: b.UUID,\\n\\t\\t}\\n\\t\\terr := dispatcher.Dispatch(ctx, cmd)\\n\\t\\tif err != nil {\\n\\t\\t\\tlogs.Warn(ctx).Err(err).Str(\\\"uuid\\\", b.UUID.String()).Msg(\\\"update benchmark task failed\\\")\\n\\t\\t}\\n\\t}\\n\\n\\treturn nil\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/benchmark.go\",\n    \"code_start_line\": 39,\n    \"code_end_line\": 50,\n    \"code_key\": \"FindByStatus\",\n    \"code_value\": \"func (v *benchmarkViewerImpl) FindByStatus(ctx context.Context, status []benchmark.Status) ([]*benchmark.Benchmark, error) {\\n\\tvar (\\n\\t\\tviews []*benchmark.Benchmark\\n\\t\\tdtos  []*metadb.DmRdiskBenchmark\\n\\t)\\n\\tresult := v.db.WithContext(ctx).Where(\\\"status in ?\\\", status).Find(&dtos)\\n\\tif result.Error != nil {\\n\\t\\treturn nil, result.Error\\n\\t}\\n\\tviews = functools.MapTo(dtos, functools.MapRef(make([]benchmark.Benchmark, len(dtos))), v.translate)\\n\\treturn views, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM dm_rdisk_benchmark WHERE status IN (?);\"]",
      "parsed_sql": [
        "SELECT * FROM dm_rdisk_benchmark WHERE status IN (?);"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM dm_rdisk_benchmark WHERE status IN (?);",
            "match_result": {
              "matched": false,
              "fingerprint": "13a6d3ea2c73e337ac75872d44054791",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/logi_vol.go:21:46:FindByStatus",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：FindByStatus\nfunc (v *logicalVolumeViewerImpl) FindByStatus(ctx context.Context, status []rdiskDomain.LogicalVolumeState, pagination rdiskDomain.Pagination) ([]*rdiskDomain.LogicalVolume, error) {\n\tif len(status) == 0 {\n\t\treturn nil, nil\n\t}\n\tvar volumes []*metadb.DmRdisk\n\tstmt := v.db.WithContext(ctx).Where(\"status in ?\",\n\t\tfunctools.Map(status, func(i rdiskDomain.LogicalVolumeState) int { return int(i) }))\n\tif pagination.Offset > 0 {\n\t\tstmt = stmt.Offset(int(pagination.Offset))\n\t}\n\tif pagination.Limit <= 0 {\n\t\tpagination.Limit = 10\n\t}\n\tresult := stmt.Preload(\"DmPhyDisk\").Limit(int(pagination.Limit)).Find(&volumes)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tresultViews := functools.MapRef(make([]rdiskDomain.LogicalVolume, len(volumes)))\n\tfor i := range volumes {\n\t\tv.translate(volumes[i], resultViews[i])\n\t}\n\treturn resultViews, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/tasks/update_benchmark.go\", \"code_start_line\": 25, \"code_end_line\": 52, \"code_key\": \"Work\", \"code_value\": \"func (*UpdateBenchmarkTask) Work(ctx context.Context) error {\\n\\tvar (\\n\\t\\tviewer     = app.GetRegistry(ctx).Viewers.Benchmark\\n\\t\\tdispatcher = app.GetRegistry(ctx).Dispatcher\\n\\t)\\n\\n\\t// 1. Find all running benchmarks\\n\\trunningStatus := []benchmark.Status{benchmark.StatusRunning}\\n\\tbenchs, err := viewer.FindByStatus(ctx, runningStatus)\\n\\tif err != nil {\\n\\t\\treturn err\\n\\t}\\n\\n\\t// 2. Fire events to update running benchmarks\\n\\tlogs.Info(ctx).Int(\\\"count\\\", len(benchs)).Msg(\\\"starts to update benchmark data\\\")\\n\\tfor _, b := range benchs {\\n\\t\\tcmd := &commands.UpdateBenchmarkTask{\\n\\t\\t\\tSerial:        b.DiskInfo.Serial,\\n\\t\\t\\tBenchmarkUUID: b.UUID,\\n\\t\\t}\\n\\t\\terr := dispatcher.Dispatch(ctx, cmd)\\n\\t\\tif err != nil {\\n\\t\\t\\tlogs.Warn(ctx).Err(err).Str(\\\"uuid\\\", b.UUID.String()).Msg(\\\"update benchmark task failed\\\")\\n\\t\\t}\\n\\t}\\n\\n\\treturn nil\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/logi_vol.go\",\n    \"code_start_line\": 21,\n    \"code_end_line\": 46,\n    \"code_key\": \"FindByStatus\",\n    \"code_value\": \"func (v *logicalVolumeViewerImpl) FindByStatus(ctx context.Context, status []rdiskDomain.LogicalVolumeState, pagination rdiskDomain.Pagination) ([]*rdiskDomain.LogicalVolume, error) {\\n\\tif len(status) == 0 {\\n\\t\\treturn nil, nil\\n\\t}\\n\\tvar volumes []*metadb.DmRdisk\\n\\tstmt := v.db.WithContext(ctx).Where(\\\"status in ?\\\",\\n\\t\\tfunctools.Map(status, func(i rdiskDomain.LogicalVolumeState) int { return int(i) }))\\n\\tif pagination.Offset > 0 {\\n\\t\\tstmt = stmt.Offset(int(pagination.Offset))\\n\\t}\\n\\tif pagination.Limit <= 0 {\\n\\t\\tpagination.Limit = 10\\n\\t}\\n\\tresult := stmt.Preload(\\\"DmPhyDisk\\\").Limit(int(pagination.Limit)).Find(&volumes)\\n\\tif result.Error != nil {\\n\\t\\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\\n\\t\\t\\treturn nil, nil\\n\\t\\t}\\n\\t\\treturn nil, result.Error\\n\\t}\\n\\tresultViews := functools.MapRef(make([]rdiskDomain.LogicalVolume, len(volumes)))\\n\\tfor i := range volumes {\\n\\t\\tv.translate(volumes[i], resultViews[i])\\n\\t}\\n\\treturn resultViews, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"status数组为空时\", \"sql\": \"\"}, {\"scenario\": \"status数组非空时\", \"sql\": \"SELECT * FROM dm_rdisk WHERE status IN (?);\"}]}, {\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"有分页偏移时\", \"sql\": \"SELECT * FROM dm_rdisk WHERE status IN (?) OFFSET ?;\"}, {\"scenario\": \"无分页偏移时\", \"sql\": \"SELECT * FROM dm_rdisk WHERE status IN (?);\"}]}, {\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"有分页限制时\", \"sql\": \"SELECT * FROM dm_rdisk WHERE status IN (?) LIMIT ?;\"}, {\"scenario\": \"无分页限制时\", \"sql\": \"SELECT * FROM dm_rdisk WHERE status IN (?);\"}]}, {\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"Preload关联查询\", \"sql\": \"SELECT * FROM dm_phydisk WHERE serial IN (SELECT serial FROM dm_rdisk WHERE status IN (?));\"}]}]",
      "parsed_sql": [
        "SELECT * FROM dm_rdisk WHERE status IN (?);",
        "SELECT * FROM dm_rdisk WHERE status IN (?) OFFSET ?;",
        "SELECT * FROM dm_rdisk WHERE status IN (?);",
        "SELECT * FROM dm_rdisk WHERE status IN (?) LIMIT ?;",
        "SELECT * FROM dm_rdisk WHERE status IN (?);",
        "SELECT * FROM dm_phydisk WHERE serial IN (SELECT serial FROM dm_rdisk WHERE status IN (?));"
      ],
      "sql_evaluation": {
        "total_sql": 6,
        "valid_sql": 6,
        "matched_sql": 6,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM dm_rdisk WHERE status IN (?);",
            "match_result": {
              "matched": true,
              "fingerprint": "ca399b5161d1459e1ddd896f0b5f1600",
              "example_sql": "SELECT * FROM `dm_rdisk` WHERE status in (90) LIMIT 1000",
              "example_count": 100
            }
          },
          {
            "sql": "SELECT * FROM dm_rdisk WHERE status IN (?) OFFSET ?;",
            "match_result": {
              "matched": true,
              "fingerprint": "ca399b5161d1459e1ddd896f0b5f1600",
              "example_sql": "SELECT * FROM `dm_rdisk` WHERE status in (90) LIMIT 1000",
              "example_count": 100
            }
          },
          {
            "sql": "SELECT * FROM dm_rdisk WHERE status IN (?);",
            "match_result": {
              "matched": true,
              "fingerprint": "ca399b5161d1459e1ddd896f0b5f1600",
              "example_sql": "SELECT * FROM `dm_rdisk` WHERE status in (90) LIMIT 1000",
              "example_count": 100
            }
          },
          {
            "sql": "SELECT * FROM dm_rdisk WHERE status IN (?) LIMIT ?;",
            "match_result": {
              "matched": true,
              "fingerprint": "ca399b5161d1459e1ddd896f0b5f1600",
              "example_sql": "SELECT * FROM `dm_rdisk` WHERE status in (90) LIMIT 1000",
              "example_count": 100
            }
          },
          {
            "sql": "SELECT * FROM dm_rdisk WHERE status IN (?);",
            "match_result": {
              "matched": true,
              "fingerprint": "ca399b5161d1459e1ddd896f0b5f1600",
              "example_sql": "SELECT * FROM `dm_rdisk` WHERE status in (90) LIMIT 1000",
              "example_count": 100
            }
          },
          {
            "sql": "SELECT * FROM dm_phydisk WHERE serial IN (SELECT serial FROM dm_rdisk WHERE status IN (?));",
            "match_result": {
              "matched": true,
              "fingerprint": "0fdf2b4f4a53dfe58ca51876e84148aa",
              "example_sql": "SELECT * FROM `dm_phydisk` WHERE `dm_phydisk`.`serial` = 'S5G3NA0R104118'",
              "example_count": 100
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/backup.go:64:78:FindByStatus",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：FindByStatus\nfunc (v *backupViewerImpl) FindByStatus(ctx context.Context, status []backup.BackupStatus) ([]*backup.View, error) {\n\tvar (\n\t\tviews []*backup.View\n\t\tdtos  []*metadb.DmRdiskBackup\n\t)\n\tresult := v.db.WithContext(ctx).Find(&dtos, \"status in ?\", status)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\tviews = functools.MapRef(make([]backup.View, len(dtos)))\n\tfor i := range dtos {\n\t\tv.translate(dtos[i], views[i])\n\t}\n\treturn views, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/tasks/update_benchmark.go\", \"code_start_line\": 25, \"code_end_line\": 52, \"code_key\": \"Work\", \"code_value\": \"func (*UpdateBenchmarkTask) Work(ctx context.Context) error {\\n\\tvar (\\n\\t\\tviewer     = app.GetRegistry(ctx).Viewers.Benchmark\\n\\t\\tdispatcher = app.GetRegistry(ctx).Dispatcher\\n\\t)\\n\\n\\t// 1. Find all running benchmarks\\n\\trunningStatus := []benchmark.Status{benchmark.StatusRunning}\\n\\tbenchs, err := viewer.FindByStatus(ctx, runningStatus)\\n\\tif err != nil {\\n\\t\\treturn err\\n\\t}\\n\\n\\t// 2. Fire events to update running benchmarks\\n\\tlogs.Info(ctx).Int(\\\"count\\\", len(benchs)).Msg(\\\"starts to update benchmark data\\\")\\n\\tfor _, b := range benchs {\\n\\t\\tcmd := &commands.UpdateBenchmarkTask{\\n\\t\\t\\tSerial:        b.DiskInfo.Serial,\\n\\t\\t\\tBenchmarkUUID: b.UUID,\\n\\t\\t}\\n\\t\\terr := dispatcher.Dispatch(ctx, cmd)\\n\\t\\tif err != nil {\\n\\t\\t\\tlogs.Warn(ctx).Err(err).Str(\\\"uuid\\\", b.UUID.String()).Msg(\\\"update benchmark task failed\\\")\\n\\t\\t}\\n\\t}\\n\\n\\treturn nil\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/backup.go\",\n    \"code_start_line\": 64,\n    \"code_end_line\": 78,\n    \"code_key\": \"FindByStatus\",\n    \"code_value\": \"func (v *backupViewerImpl) FindByStatus(ctx context.Context, status []backup.BackupStatus) ([]*backup.View, error) {\\n\\tvar (\\n\\t\\tviews []*backup.View\\n\\t\\tdtos  []*metadb.DmRdiskBackup\\n\\t)\\n\\tresult := v.db.WithContext(ctx).Find(&dtos, \\\"status in ?\\\", status)\\n\\tif result.Error != nil {\\n\\t\\treturn nil, result.Error\\n\\t}\\n\\tviews = functools.MapRef(make([]backup.View, len(dtos)))\\n\\tfor i := range dtos {\\n\\t\\tv.translate(dtos[i], views[i])\\n\\t}\\n\\treturn views, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM dm_rdisk_backup WHERE status IN (?);\"]",
      "parsed_sql": [
        "SELECT * FROM dm_rdisk_backup WHERE status IN (?);"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 1,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM dm_rdisk_backup WHERE status IN (?);",
            "match_result": {
              "matched": true,
              "fingerprint": "417b025e6acd524e0a27bc7a4e4ef3ec",
              "example_sql": "SELECT * FROM `dm_rdisk_backup` WHERE status in (1)",
              "example_count": 100
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/phy_vol.go:59:64:GetAll",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：GetAll\nfunc (impl *phyVolViewer) GetAll(ctx context.Context) ([]*rdiskDomain.PhysicalVolume, error) {\n\tvolumes := []*metadb.DmPhydisk{}\n\tresult := impl.db.WithContext(ctx).Find(&volumes)\n\tlogs.Info(ctx).Int64(\"count\", result.RowsAffected).Msg(\"query all physical volumes\")\n\treturn impl.dbToEntity(ctx, volumes), nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/phy_vol.go\",\n    \"code_start_line\": 59,\n    \"code_end_line\": 64,\n    \"code_key\": \"GetAll\",\n    \"code_value\": \"func (impl *phyVolViewer) GetAll(ctx context.Context) ([]*rdiskDomain.PhysicalVolume, error) {\\n\\tvolumes := []*metadb.DmPhydisk{}\\n\\tresult := impl.db.WithContext(ctx).Find(&volumes)\\n\\tlogs.Info(ctx).Int64(\\\"count\\\", result.RowsAffected).Msg(\\\"query all physical volumes\\\")\\n\\treturn impl.dbToEntity(ctx, volumes), nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT id, name, size, status, created_at, updated_at FROM dm_phydisk;\"]",
      "parsed_sql": [
        "SELECT id, name, size, status, created_at, updated_at FROM dm_phydisk;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT id, name, size, status, created_at, updated_at FROM dm_phydisk;",
            "match_result": {
              "matched": false,
              "fingerprint": "3cf1852b172f7a690dd2fce668dbbad1",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/phy_vol.go:66:71:GetAllAvailable",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：GetAllAvailable\nfunc (impl *phyVolViewer) GetAllAvailable(ctx context.Context) ([]*rdiskDomain.PhysicalVolume, error) {\n\tvolumes := []*metadb.DmPhydisk{}\n\tresult := impl.db.WithContext(ctx).Find(&volumes, \"status = ?\", rdiskDomain.PVSOnline)\n\tlogs.Info(ctx).Int64(\"count\", result.RowsAffected).Msg(\"query all available physical volumes\")\n\treturn impl.dbToEntity(ctx, volumes), nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/phy_vol.go\",\n    \"code_start_line\": 66,\n    \"code_end_line\": 71,\n    \"code_key\": \"GetAllAvailable\",\n    \"code_value\": \"func (impl *phyVolViewer) GetAllAvailable(ctx context.Context) ([]*rdiskDomain.PhysicalVolume, error) {\\n\\tvolumes := []*metadb.DmPhydisk{}\\n\\tresult := impl.db.WithContext(ctx).Find(&volumes, \\\"status = ?\\\", rdiskDomain.PVSOnline)\\n\\tlogs.Info(ctx).Int64(\\\"count\\\", result.RowsAffected).Msg(\\\"query all available physical volumes\\\")\\n\\treturn impl.dbToEntity(ctx, volumes), nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM dm_phydisk WHERE status = ?;\"]",
      "parsed_sql": [
        "SELECT * FROM dm_phydisk WHERE status = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 1,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM dm_phydisk WHERE status = ?;",
            "match_result": {
              "matched": true,
              "fingerprint": "45c56aa3ac4b336dc151a67be35ce9d6",
              "example_sql": "SELECT * FROM `dm_phydisk` WHERE 1 = 1 AND status in (1) LIMIT 10",
              "example_count": 100
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/phy_vol.go:74:79:QueryBySerial",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：QueryBySerial\nfunc (impl *phyVolViewer) QueryBySerial(ctx context.Context, serials []string) ([]*rdiskDomain.PhysicalVolume, error) {\n\tvolumes := []*metadb.DmPhydisk{}\n\tresult := impl.db.WithContext(ctx).Find(&volumes, \"serial in ?\", serials)\n\tlogs.Info(ctx).Int64(\"count\", result.RowsAffected).Msg(\"query physical volumes by serial\")\n\treturn impl.dbToEntity(ctx, volumes), nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go\", \"code_start_line\": 644, \"code_end_line\": 646, \"code_key\": \"CreateRDiskVol\", \"code_value\": \"func (s *UnimplementedMaster) CreateRDiskVol(ctx context.Context, req *CreateRDiskVolRequest) (*CreateRDiskVolResponse, error) {\\n\\treturn nil, errors.New(\\\"rpc CreateRDiskVol of service Master is not implemented\\\")\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/phy_vol.go\",\n    \"code_start_line\": 74,\n    \"code_end_line\": 79,\n    \"code_key\": \"QueryBySerial\",\n    \"code_value\": \"func (impl *phyVolViewer) QueryBySerial(ctx context.Context, serials []string) ([]*rdiskDomain.PhysicalVolume, error) {\\n\\tvolumes := []*metadb.DmPhydisk{}\\n\\tresult := impl.db.WithContext(ctx).Find(&volumes, \\\"serial in ?\\\", serials)\\n\\tlogs.Info(ctx).Int64(\\\"count\\\", result.RowsAffected).Msg(\\\"query physical volumes by serial\\\")\\n\\treturn impl.dbToEntity(ctx, volumes), nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM dm_phydisk WHERE serial IN (?);\", {\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"单个序列号查询\", \"sql\": \"SELECT * FROM dm_phydisk WHERE serial = ?;\"}, {\"scenario\": \"多个序列号查询\", \"sql\": \"SELECT * FROM dm_phydisk WHERE serial IN (?, ?, ?);\"}]}]",
      "parsed_sql": [
        "SELECT * FROM dm_phydisk WHERE serial IN (?);",
        "SELECT * FROM dm_phydisk WHERE serial = ?;",
        "SELECT * FROM dm_phydisk WHERE serial IN (?, ?, ?);"
      ],
      "sql_evaluation": {
        "total_sql": 3,
        "valid_sql": 3,
        "matched_sql": 3,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM dm_phydisk WHERE serial IN (?);",
            "match_result": {
              "matched": true,
              "fingerprint": "0fdf2b4f4a53dfe58ca51876e84148aa",
              "example_sql": "SELECT * FROM `dm_phydisk` WHERE `dm_phydisk`.`serial` = 'S5G3NA0R104118'",
              "example_count": 100
            }
          },
          {
            "sql": "SELECT * FROM dm_phydisk WHERE serial = ?;",
            "match_result": {
              "matched": true,
              "fingerprint": "0fdf2b4f4a53dfe58ca51876e84148aa",
              "example_sql": "SELECT * FROM `dm_phydisk` WHERE `dm_phydisk`.`serial` = 'S5G3NA0R104118'",
              "example_count": 100
            }
          },
          {
            "sql": "SELECT * FROM dm_phydisk WHERE serial IN (?, ?, ?);",
            "match_result": {
              "matched": true,
              "fingerprint": "0fdf2b4f4a53dfe58ca51876e84148aa",
              "example_sql": "SELECT * FROM `dm_phydisk` WHERE `dm_phydisk`.`serial` = 'S5G3NA0R104118'",
              "example_count": 100
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/phy_vol.go:81:86:QueryByHost",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：QueryByHost\nfunc (impl *phyVolViewer) QueryByHost(ctx context.Context, host net.IP) ([]*rdiskDomain.PhysicalVolume, error) {\n\tvolumes := []*metadb.DmPhydisk{}\n\tresult := impl.db.WithContext(ctx).Find(&volumes, \"host_ip = ?\", host.String())\n\tlogs.Info(ctx).Int64(\"count\", result.RowsAffected).Msg(\"query physical volumes by serial\")\n\treturn impl.dbToEntity(ctx, volumes), nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/phy_vol.go\",\n    \"code_start_line\": 81,\n    \"code_end_line\": 86,\n    \"code_key\": \"QueryByHost\",\n    \"code_value\": \"func (impl *phyVolViewer) QueryByHost(ctx context.Context, host net.IP) ([]*rdiskDomain.PhysicalVolume, error) {\\n\\tvolumes := []*metadb.DmPhydisk{}\\n\\tresult := impl.db.WithContext(ctx).Find(&volumes, \\\"host_ip = ?\\\", host.String())\\n\\tlogs.Info(ctx).Int64(\\\"count\\\", result.RowsAffected).Msg(\\\"query physical volumes by serial\\\")\\n\\treturn impl.dbToEntity(ctx, volumes), nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM dm_phydisk WHERE host_ip = ?;\"]",
      "parsed_sql": [
        "SELECT * FROM dm_phydisk WHERE host_ip = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM dm_phydisk WHERE host_ip = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "cebabfd9b9442a5290f2bfbc5a7c6ddf",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/phy_vol.go:88:118:Search",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：Search\nfunc (impl *phyVolViewer) Search(ctx context.Context, criteria rdiskDomain.PVSearchCriteria, pagination rdiskDomain.Pagination) ([]*rdiskDomain.PhysicalVolume, error) {\n\tvar volumes []*metadb.DmPhydisk\n\tstmt := impl.db.WithContext(ctx).Where(\"1 = 1\")\n\tif len(criteria.IPs) > 0 {\n\t\tstmt = stmt.Where(\"host_ip in ?\", functools.Map(criteria.IPs, func(ip net.IP) string { return ip.String() }))\n\t}\n\tif len(criteria.Serials) > 0 {\n\t\tstmt = stmt.Where(\"serial in ?\", functools.Map(criteria.Serials, func(serial rdiskDomain.Serial) string { return string(serial) }))\n\t}\n\tif len(criteria.BDFs) > 0 {\n\t\tstmt = stmt.Where(\"bdf in ?\", functools.Map(criteria.BDFs, func(bdf rdiskDomain.BDF) string { return string(bdf) }))\n\t}\n\tif len(criteria.ZoneIDs) > 0 {\n\t\tstmt = stmt.Where(\"zone_id in ?\", functools.Map(criteria.ZoneIDs, func(zoneID rdiskDomain.ZoneID) uint64 { return uint64(zoneID) }))\n\t}\n\tif criteria.AvailableOnly {\n\t\tstmt = stmt.Where(\"status = ?\", rdiskDomain.PVSOnline)\n\t}\n\tif len(criteria.States) > 0 {\n\t\tstmt = stmt.Where(\"status in ?\", functools.Map(criteria.States, func(state rdiskDomain.PhysicalVolumeState) int { return int(state) }))\n\t}\n\tif pagination.Offset > 0 {\n\t\tstmt = stmt.Offset(int(pagination.Offset))\n\t}\n\tif pagination.Limit <= 0 {\n\t\tpagination.Limit = 10\n\t}\n\tstmt = stmt.Limit(int(pagination.Limit))\n\tresult := stmt.Find(&volumes)\n\treturn impl.dbToEntity(ctx, volumes), result.Error\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go\", \"code_start_line\": 649, \"code_end_line\": 651, \"code_key\": \"QueryRDiskVol\", \"code_value\": \"func (s *UnimplementedMaster) QueryRDiskVol(ctx context.Context, req *QueryRDiskVolRequest) (*QueryRDiskVolResponse, error) {\\n\\treturn nil, errors.New(\\\"rpc QueryRDiskVol of service Master is not implemented\\\")\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/phy_vol.go\",\n    \"code_start_line\": 88,\n    \"code_end_line\": 118,\n    \"code_key\": \"Search\",\n    \"code_value\": \"func (impl *phyVolViewer) Search(ctx context.Context, criteria rdiskDomain.PVSearchCriteria, pagination rdiskDomain.Pagination) ([]*rdiskDomain.PhysicalVolume, error) {\\n\\tvar volumes []*metadb.DmPhydisk\\n\\tstmt := impl.db.WithContext(ctx).Where(\\\"1 = 1\\\")\\n\\tif len(criteria.IPs) > 0 {\\n\\t\\tstmt = stmt.Where(\\\"host_ip in ?\\\", functools.Map(criteria.IPs, func(ip net.IP) string { return ip.String() }))\\n\\t}\\n\\tif len(criteria.Serials) > 0 {\\n\\t\\tstmt = stmt.Where(\\\"serial in ?\\\", functools.Map(criteria.Serials, func(serial rdiskDomain.Serial) string { return string(serial) }))\\n\\t}\\n\\tif len(criteria.BDFs) > 0 {\\n\\t\\tstmt = stmt.Where(\\\"bdf in ?\\\", functools.Map(criteria.BDFs, func(bdf rdiskDomain.BDF) string { return string(bdf) }))\\n\\t}\\n\\tif len(criteria.ZoneIDs) > 0 {\\n\\t\\tstmt = stmt.Where(\\\"zone_id in ?\\\", functools.Map(criteria.ZoneIDs, func(zoneID rdiskDomain.ZoneID) uint64 { return uint64(zoneID) }))\\n\\t}\\n\\tif criteria.AvailableOnly {\\n\\t\\tstmt = stmt.Where(\\\"status = ?\\\", rdiskDomain.PVSOnline)\\n\\t}\\n\\tif len(criteria.States) > 0 {\\n\\t\\tstmt = stmt.Where(\\\"status in ?\\\", functools.Map(criteria.States, func(state rdiskDomain.PhysicalVolumeState) int { return int(state) }))\\n\\t}\\n\\tif pagination.Offset > 0 {\\n\\t\\tstmt = stmt.Offset(int(pagination.Offset))\\n\\t}\\n\\tif pagination.Limit <= 0 {\\n\\t\\tpagination.Limit = 10\\n\\t}\\n\\tstmt = stmt.Limit(int(pagination.Limit))\\n\\tresult := stmt.Find(&volumes)\\n\\treturn impl.dbToEntity(ctx, volumes), result.Error\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"无任何过滤条件\", \"sql\": \"SELECT * FROM dm_phydisk WHERE 1 = 1 LIMIT 10;\"}, {\"scenario\": \"仅IP过滤\", \"sql\": \"SELECT * FROM dm_phydisk WHERE 1 = 1 AND host_ip in (?) LIMIT 10;\"}, {\"scenario\": \"仅Serial过滤\", \"sql\": \"SELECT * FROM dm_phydisk WHERE 1 = 1 AND serial in (?) LIMIT 10;\"}, {\"scenario\": \"仅ZoneID过滤\", \"sql\": \"SELECT * FROM dm_phydisk WHERE 1 = 1 AND zone_id in (?) LIMIT 10;\"}, {\"scenario\": \"仅AvailableOnly过滤\", \"sql\": \"SELECT * FROM dm_phydisk WHERE 1 = 1 AND status = ? LIMIT 10;\"}, {\"scenario\": \"仅States过滤\", \"sql\": \"SELECT * FROM dm_phydisk WHERE 1 = 1 AND status in (?) LIMIT 10;\"}, {\"scenario\": \"包含Offset的查询\", \"sql\": \"SELECT * FROM dm_phydisk WHERE 1 = 1 OFFSET ? LIMIT ?;\"}, {\"scenario\": \"多条件组合示例\", \"sql\": \"SELECT * FROM dm_phydisk WHERE 1 = 1 AND host_ip in (?) AND serial in (?) AND zone_id in (?) AND status = ? OFFSET ? LIMIT ?;\"}]}]",
      "parsed_sql": [
        "SELECT * FROM dm_phydisk WHERE 1 = 1 LIMIT 10;",
        "SELECT * FROM dm_phydisk WHERE 1 = 1 AND host_ip in (?) LIMIT 10;",
        "SELECT * FROM dm_phydisk WHERE 1 = 1 AND serial in (?) LIMIT 10;",
        "SELECT * FROM dm_phydisk WHERE 1 = 1 AND zone_id in (?) LIMIT 10;",
        "SELECT * FROM dm_phydisk WHERE 1 = 1 AND status = ? LIMIT 10;",
        "SELECT * FROM dm_phydisk WHERE 1 = 1 AND status in (?) LIMIT 10;",
        "SELECT * FROM dm_phydisk WHERE 1 = 1 OFFSET ? LIMIT ?;",
        "SELECT * FROM dm_phydisk WHERE 1 = 1 AND host_ip in (?) AND serial in (?) AND zone_id in (?) AND status = ? OFFSET ? LIMIT ?;"
      ],
      "sql_evaluation": {
        "total_sql": 8,
        "valid_sql": 8,
        "matched_sql": 3,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM dm_phydisk WHERE 1 = 1 LIMIT 10;",
            "match_result": {
              "matched": false,
              "fingerprint": "3cf1852b172f7a690dd2fce668dbbad1",
              "excluded": false
            }
          },
          {
            "sql": "SELECT * FROM dm_phydisk WHERE 1 = 1 AND host_ip in (?) LIMIT 10;",
            "match_result": {
              "matched": false,
              "fingerprint": "cebabfd9b9442a5290f2bfbc5a7c6ddf",
              "excluded": false
            }
          },
          {
            "sql": "SELECT * FROM dm_phydisk WHERE 1 = 1 AND serial in (?) LIMIT 10;",
            "match_result": {
              "matched": true,
              "fingerprint": "0fdf2b4f4a53dfe58ca51876e84148aa",
              "example_sql": "SELECT * FROM `dm_phydisk` WHERE `dm_phydisk`.`serial` = 'S5G3NA0R104118'",
              "example_count": 100
            }
          },
          {
            "sql": "SELECT * FROM dm_phydisk WHERE 1 = 1 AND zone_id in (?) LIMIT 10;",
            "match_result": {
              "matched": false,
              "fingerprint": "c81088f5114634a6d0247540cfa9c8e0",
              "excluded": false
            }
          },
          {
            "sql": "SELECT * FROM dm_phydisk WHERE 1 = 1 AND status = ? LIMIT 10;",
            "match_result": {
              "matched": true,
              "fingerprint": "45c56aa3ac4b336dc151a67be35ce9d6",
              "example_sql": "SELECT * FROM `dm_phydisk` WHERE 1 = 1 AND status in (1) LIMIT 10",
              "example_count": 100
            }
          },
          {
            "sql": "SELECT * FROM dm_phydisk WHERE 1 = 1 AND status in (?) LIMIT 10;",
            "match_result": {
              "matched": true,
              "fingerprint": "45c56aa3ac4b336dc151a67be35ce9d6",
              "example_sql": "SELECT * FROM `dm_phydisk` WHERE 1 = 1 AND status in (1) LIMIT 10",
              "example_count": 100
            }
          },
          {
            "sql": "SELECT * FROM dm_phydisk WHERE 1 = 1 OFFSET ? LIMIT ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "3cf1852b172f7a690dd2fce668dbbad1",
              "excluded": false
            }
          },
          {
            "sql": "SELECT * FROM dm_phydisk WHERE 1 = 1 AND host_ip in (?) AND serial in (?) AND zone_id in (?) AND status = ? OFFSET ? LIMIT ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "27f86083ffce2cc785fe886dafcc6e12",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/logi_vol.go:49:77:Search",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：Search\nfunc (v *logicalVolumeViewerImpl) Search(ctx context.Context, appID users.AppID, criteria rdiskDomain.LVSearchCriteria, pagination rdiskDomain.Pagination) ([]*rdiskDomain.LogicalVolume, error) {\n\tvar volumes []*metadb.DmRdisk\n\tstmt := v.db.WithContext(ctx).Where(\"app_id = ?\", appID)\n\tif len(criteria.UUIDs) > 0 {\n\t\tstmt = stmt.Where(\"uuid in ?\", functools.Map(criteria.UUIDs, func(i uuid.UUID) string { return i.String() }))\n\t}\n\tif len(criteria.Serials) > 0 {\n\t\tstmt = stmt.Where(\"phydisk_serial in ?\", functools.Map(criteria.Serials, func(i rdiskDomain.Serial) string { return string(i) }))\n\t}\n\tif pagination.Offset > 0 {\n\t\tstmt = stmt.Offset(int(pagination.Offset))\n\t}\n\tif pagination.Limit <= 0 {\n\t\tpagination.Limit = 10\n\t}\n\tresult := stmt.Preload(\"DmPhyDisk\").Limit(int(pagination.Limit)).Find(&volumes)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\n\tresultViews := functools.MapRef(make([]rdiskDomain.LogicalVolume, len(volumes)))\n\tfor i := range volumes {\n\t\tv.translate(volumes[i], resultViews[i])\n\t}\n\treturn resultViews, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go\", \"code_start_line\": 649, \"code_end_line\": 651, \"code_key\": \"QueryRDiskVol\", \"code_value\": \"func (s *UnimplementedMaster) QueryRDiskVol(ctx context.Context, req *QueryRDiskVolRequest) (*QueryRDiskVolResponse, error) {\\n\\treturn nil, errors.New(\\\"rpc QueryRDiskVol of service Master is not implemented\\\")\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/logi_vol.go\",\n    \"code_start_line\": 49,\n    \"code_end_line\": 77,\n    \"code_key\": \"Search\",\n    \"code_value\": \"func (v *logicalVolumeViewerImpl) Search(ctx context.Context, appID users.AppID, criteria rdiskDomain.LVSearchCriteria, pagination rdiskDomain.Pagination) ([]*rdiskDomain.LogicalVolume, error) {\\n\\tvar volumes []*metadb.DmRdisk\\n\\tstmt := v.db.WithContext(ctx).Where(\\\"app_id = ?\\\", appID)\\n\\tif len(criteria.UUIDs) > 0 {\\n\\t\\tstmt = stmt.Where(\\\"uuid in ?\\\", functools.Map(criteria.UUIDs, func(i uuid.UUID) string { return i.String() }))\\n\\t}\\n\\tif len(criteria.Serials) > 0 {\\n\\t\\tstmt = stmt.Where(\\\"phydisk_serial in ?\\\", functools.Map(criteria.Serials, func(i rdiskDomain.Serial) string { return string(i) }))\\n\\t}\\n\\tif pagination.Offset > 0 {\\n\\t\\tstmt = stmt.Offset(int(pagination.Offset))\\n\\t}\\n\\tif pagination.Limit <= 0 {\\n\\t\\tpagination.Limit = 10\\n\\t}\\n\\tresult := stmt.Preload(\\\"DmPhyDisk\\\").Limit(int(pagination.Limit)).Find(&volumes)\\n\\tif result.Error != nil {\\n\\t\\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\\n\\t\\t\\treturn nil, nil\\n\\t\\t}\\n\\t\\treturn nil, result.Error\\n\\t}\\n\\n\\tresultViews := functools.MapRef(make([]rdiskDomain.LogicalVolume, len(volumes)))\\n\\tfor i := range volumes {\\n\\t\\tv.translate(volumes[i], resultViews[i])\\n\\t}\\n\\treturn resultViews, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"仅app_id条件\", \"sql\": \"SELECT * FROM dm_rdisk WHERE app_id = ? LIMIT 10;\"}, {\"scenario\": \"app_id + UUIDs条件\", \"sql\": \"SELECT * FROM dm_rdisk WHERE app_id = ? AND uuid IN (?) LIMIT 10;\"}, {\"scenario\": \"app_id + Serials条件\", \"sql\": \"SELECT * FROM dm_rdisk WHERE app_id = ? AND phydisk_serial IN (?) LIMIT 10;\"}, {\"scenario\": \"app_id + UUIDs + Serials条件\", \"sql\": \"SELECT * FROM dm_rdisk WHERE app_id = ? AND uuid IN (?) AND phydisk_serial IN (?) LIMIT 10;\"}, {\"scenario\": \"app_id + Offset条件\", \"sql\": \"SELECT * FROM dm_rdisk WHERE app_id = ? OFFSET ? LIMIT 10;\"}, {\"scenario\": \"app_id + UUIDs + Offset条件\", \"sql\": \"SELECT * FROM dm_rdisk WHERE app_id = ? AND uuid IN (?) OFFSET ? LIMIT 10;\"}, {\"scenario\": \"app_id + Serials + Offset条件\", \"sql\": \"SELECT * FROM dm_rdisk WHERE app_id = ? AND phydisk_serial IN (?) OFFSET ? LIMIT 10;\"}, {\"scenario\": \"app_id + UUIDs + Serials + Offset条件\", \"sql\": \"SELECT * FROM dm_rdisk WHERE app_id = ? AND uuid IN (?) AND phydisk_serial IN (?) OFFSET ? LIMIT 10;\"}]}, {\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"Preload DmPhyDisk\", \"sql\": \"SELECT * FROM dm_phydisk WHERE serial IN (SELECT phydisk_serial FROM dm_rdisk WHERE app_id = ?);\"}]}]",
      "parsed_sql": [
        "SELECT * FROM dm_rdisk WHERE app_id = ? LIMIT 10;",
        "SELECT * FROM dm_rdisk WHERE app_id = ? AND uuid IN (?) LIMIT 10;",
        "SELECT * FROM dm_rdisk WHERE app_id = ? AND phydisk_serial IN (?) LIMIT 10;",
        "SELECT * FROM dm_rdisk WHERE app_id = ? AND uuid IN (?) AND phydisk_serial IN (?) LIMIT 10;",
        "SELECT * FROM dm_rdisk WHERE app_id = ? OFFSET ? LIMIT 10;",
        "SELECT * FROM dm_rdisk WHERE app_id = ? AND uuid IN (?) OFFSET ? LIMIT 10;",
        "SELECT * FROM dm_rdisk WHERE app_id = ? AND phydisk_serial IN (?) OFFSET ? LIMIT 10;",
        "SELECT * FROM dm_rdisk WHERE app_id = ? AND uuid IN (?) AND phydisk_serial IN (?) OFFSET ? LIMIT 10;",
        "SELECT * FROM dm_phydisk WHERE serial IN (SELECT phydisk_serial FROM dm_rdisk WHERE app_id = ?);"
      ],
      "sql_evaluation": {
        "total_sql": 9,
        "valid_sql": 9,
        "matched_sql": 3,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM dm_rdisk WHERE app_id = ? LIMIT 10;",
            "match_result": {
              "matched": false,
              "fingerprint": "4d0c3045ca3ce2ab24cd895c3f21ff83",
              "excluded": false
            }
          },
          {
            "sql": "SELECT * FROM dm_rdisk WHERE app_id = ? AND uuid IN (?) LIMIT 10;",
            "match_result": {
              "matched": true,
              "fingerprint": "b0ca129db83e26402fb0dd198aa16698",
              "example_sql": "SELECT * FROM `dm_rdisk` WHERE uuid = '21b98301-fbba-4c0c-8731-65b9dc42941c' AND app_id = 1258344699 ORDER BY `dm_rdisk`.`id` LIMIT 1",
              "example_count": 8
            }
          },
          {
            "sql": "SELECT * FROM dm_rdisk WHERE app_id = ? AND phydisk_serial IN (?) LIMIT 10;",
            "match_result": {
              "matched": false,
              "fingerprint": "021b8e58047eec8ab293299ff25b80b2",
              "excluded": false
            }
          },
          {
            "sql": "SELECT * FROM dm_rdisk WHERE app_id = ? AND uuid IN (?) AND phydisk_serial IN (?) LIMIT 10;",
            "match_result": {
              "matched": false,
              "fingerprint": "d19a7e13dff50aa96dd802e8cbb5f665",
              "excluded": false
            }
          },
          {
            "sql": "SELECT * FROM dm_rdisk WHERE app_id = ? OFFSET ? LIMIT 10;",
            "match_result": {
              "matched": false,
              "fingerprint": "4d0c3045ca3ce2ab24cd895c3f21ff83",
              "excluded": false
            }
          },
          {
            "sql": "SELECT * FROM dm_rdisk WHERE app_id = ? AND uuid IN (?) OFFSET ? LIMIT 10;",
            "match_result": {
              "matched": true,
              "fingerprint": "b0ca129db83e26402fb0dd198aa16698",
              "example_sql": "SELECT * FROM `dm_rdisk` WHERE uuid = '21b98301-fbba-4c0c-8731-65b9dc42941c' AND app_id = 1258344699 ORDER BY `dm_rdisk`.`id` LIMIT 1",
              "example_count": 8
            }
          },
          {
            "sql": "SELECT * FROM dm_rdisk WHERE app_id = ? AND phydisk_serial IN (?) OFFSET ? LIMIT 10;",
            "match_result": {
              "matched": false,
              "fingerprint": "021b8e58047eec8ab293299ff25b80b2",
              "excluded": false
            }
          },
          {
            "sql": "SELECT * FROM dm_rdisk WHERE app_id = ? AND uuid IN (?) AND phydisk_serial IN (?) OFFSET ? LIMIT 10;",
            "match_result": {
              "matched": false,
              "fingerprint": "d19a7e13dff50aa96dd802e8cbb5f665",
              "excluded": false
            }
          },
          {
            "sql": "SELECT * FROM dm_phydisk WHERE serial IN (SELECT phydisk_serial FROM dm_rdisk WHERE app_id = ?);",
            "match_result": {
              "matched": true,
              "fingerprint": "0fdf2b4f4a53dfe58ca51876e84148aa",
              "example_sql": "SELECT * FROM `dm_phydisk` WHERE `dm_phydisk`.`serial` = 'S5G3NA0R104118'",
              "example_count": 100
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/logi_vol.go:80:102:ProbeAppID",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：ProbeAppID\nfunc (v *logicalVolumeViewerImpl) ProbeAppID(ctx context.Context, uuids []uuid.UUID, serial []rdiskDomain.Serial) (users.AppID, error) {\n\tvar (\n\t\tdataObjects *metadb.DmRdisk\n\t)\n\tstmt := v.db.WithContext(ctx).Where(\"1 = 1\")\n\tif len(uuids) > 0 {\n\t\tstmt = stmt.Where(\"uuid in ?\", functools.Map(uuids, func(i uuid.UUID) string { return i.String() }))\n\t}\n\tif len(serial) > 0 {\n\t\tstmt = stmt.Where(\"phydisk_serial in ?\", functools.Map(serial, func(i rdiskDomain.Serial) string { return string(i) }))\n\t}\n\tresult := stmt.Select(\"app_id\").Limit(1).Find(&dataObjects)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn users.AppID(0), nil\n\t\t}\n\t\treturn users.AppID(0), result.Error\n\t}\n\tif dataObjects.AppID == 0 {\n\t\treturn users.AppID(0), errors.New(rdiskDomain.ErrVolumeNotExists, \"logical volume not exist\")\n\t}\n\treturn users.AppID(dataObjects.AppID), nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go\", \"code_start_line\": 649, \"code_end_line\": 651, \"code_key\": \"QueryRDiskVol\", \"code_value\": \"func (s *UnimplementedMaster) QueryRDiskVol(ctx context.Context, req *QueryRDiskVolRequest) (*QueryRDiskVolResponse, error) {\\n\\treturn nil, errors.New(\\\"rpc QueryRDiskVol of service Master is not implemented\\\")\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/logi_vol.go\",\n    \"code_start_line\": 80,\n    \"code_end_line\": 102,\n    \"code_key\": \"ProbeAppID\",\n    \"code_value\": \"func (v *logicalVolumeViewerImpl) ProbeAppID(ctx context.Context, uuids []uuid.UUID, serial []rdiskDomain.Serial) (users.AppID, error) {\\n\\tvar (\\n\\t\\tdataObjects *metadb.DmRdisk\\n\\t)\\n\\tstmt := v.db.WithContext(ctx).Where(\\\"1 = 1\\\")\\n\\tif len(uuids) > 0 {\\n\\t\\tstmt = stmt.Where(\\\"uuid in ?\\\", functools.Map(uuids, func(i uuid.UUID) string { return i.String() }))\\n\\t}\\n\\tif len(serial) > 0 {\\n\\t\\tstmt = stmt.Where(\\\"phydisk_serial in ?\\\", functools.Map(serial, func(i rdiskDomain.Serial) string { return string(i) }))\\n\\t}\\n\\tresult := stmt.Select(\\\"app_id\\\").Limit(1).Find(&dataObjects)\\n\\tif result.Error != nil {\\n\\t\\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\\n\\t\\t\\treturn users.AppID(0), nil\\n\\t\\t}\\n\\t\\treturn users.AppID(0), result.Error\\n\\t}\\n\\tif dataObjects.AppID == 0 {\\n\\t\\treturn users.AppID(0), errors.New(rdiskDomain.ErrVolumeNotExists, \\\"logical volume not exist\\\")\\n\\t}\\n\\treturn users.AppID(dataObjects.AppID), nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"uuids和serial都为空\", \"sql\": \"SELECT app_id FROM dm_rdisk WHERE 1 = 1 LIMIT 1;\"}, {\"scenario\": \"只有uuids有值，serial为空\", \"sql\": \"SELECT app_id FROM dm_rdisk WHERE 1 = 1 AND uuid IN (?) LIMIT 1;\"}, {\"scenario\": \"只有serial有值，uuids为空\", \"sql\": \"SELECT app_id FROM dm_rdisk WHERE 1 = 1 AND phydisk_serial IN (?) LIMIT 1;\"}, {\"scenario\": \"uuids和serial都有值\", \"sql\": \"SELECT app_id FROM dm_rdisk WHERE 1 = 1 AND uuid IN (?) AND phydisk_serial IN (?) LIMIT 1;\"}]}]",
      "parsed_sql": [
        "SELECT app_id FROM dm_rdisk WHERE 1 = 1 LIMIT 1;",
        "SELECT app_id FROM dm_rdisk WHERE 1 = 1 AND uuid IN (?) LIMIT 1;",
        "SELECT app_id FROM dm_rdisk WHERE 1 = 1 AND phydisk_serial IN (?) LIMIT 1;",
        "SELECT app_id FROM dm_rdisk WHERE 1 = 1 AND uuid IN (?) AND phydisk_serial IN (?) LIMIT 1;"
      ],
      "sql_evaluation": {
        "total_sql": 4,
        "valid_sql": 4,
        "matched_sql": 2,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT app_id FROM dm_rdisk WHERE 1 = 1 LIMIT 1;",
            "match_result": {
              "matched": false,
              "fingerprint": "e780b6ed9cd9873a4c5f516d42f88df1",
              "excluded": false
            }
          },
          {
            "sql": "SELECT app_id FROM dm_rdisk WHERE 1 = 1 AND uuid IN (?) LIMIT 1;",
            "match_result": {
              "matched": true,
              "fingerprint": "04cddcdf27d2555bdd3b6350fc6b5cb8",
              "example_sql": "SELECT * FROM `dm_rdisk` WHERE uuid = '25093a2e-d9c4-43b1-8bd9-c67d98c6cdae' ORDER BY `dm_rdisk`.`id` LIMIT 1",
              "example_count": 100
            }
          },
          {
            "sql": "SELECT app_id FROM dm_rdisk WHERE 1 = 1 AND phydisk_serial IN (?) LIMIT 1;",
            "match_result": {
              "matched": true,
              "fingerprint": "176d7d4c2e1308a76340c2c430a68ffa",
              "example_sql": "SELECT `app_id` FROM `dm_rdisk` WHERE 1 = 1 AND phydisk_serial in ('BTLJ01820GXK4P0DGN') LIMIT 1",
              "example_count": 100
            }
          },
          {
            "sql": "SELECT app_id FROM dm_rdisk WHERE 1 = 1 AND uuid IN (?) AND phydisk_serial IN (?) LIMIT 1;",
            "match_result": {
              "matched": false,
              "fingerprint": "91c2d5123df2731d565053dc403ed584",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/logi_vol.go:109:132:FindByIDs",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：FindByIDs\nfunc (v *logicalVolumeViewerImpl) FindByIDs(ctx context.Context, appID users.AppID, id []uuid.UUID) ([]*rdiskDomain.LogicalVolume, error) {\n\tvar (\n\t\tresultViews   []rdiskDomain.LogicalVolume\n\t\tresultViewRef []*rdiskDomain.LogicalVolume\n\t\tdataObjects   []*metadb.DmRdisk\n\t)\n\n\tuuidStrSlice := functools.Map(id, func(i uuid.UUID) string { return i.String() })\n\tresult := v.db.WithContext(ctx).Preload(\"DmPhyDisk\").Find(&dataObjects, \"app_id = ? and uuid in ?\", appID, uuidStrSlice)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(rdiskDomain.ErrVolumeNotExists, \"logical volume not exist\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\n\tresultViews = make([]rdiskDomain.LogicalVolume, len(dataObjects))\n\tresultViewRef = make([]*rdiskDomain.LogicalVolume, len(dataObjects))\n\tfor i := range dataObjects {\n\t\tresultViewRef[i] = &resultViews[i]\n\t\tv.translate(dataObjects[i], resultViewRef[i])\n\t}\n\treturn resultViewRef, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go\", \"code_start_line\": 51, \"code_end_line\": 72, \"code_key\": \"Handle\", \"code_value\": \"func (c *CbsAppIdConsumer) Handle(ctx context.Context, delivery *rabbitmq.Delivery) error {\\n\\tu, chargeTime, err := c.ParseDelivery(ctx, delivery)\\n\\tif err != nil {\\n\\t\\treturn err\\n\\t}\\n\\tif u == nil {\\n\\t\\tlogs.Info(c.Ctx).\\n\\t\\t\\tTime(\\\"chargeTime\\\", chargeTime).\\n\\t\\t\\tMsg(\\\"USER_INFO_NOT_FOUND\\\")\\n\\t\\treturn nil\\n\\t}\\n\\n\\tchargeDetail := c.GetChargeDetailForSingleUser(u, chargeTime)\\n\\tif chargeDetail == nil {\\n\\t\\tlogs.Info(c.Ctx).\\n\\t\\t\\tUint64(\\\"appId\\\", uint64(u.AppId)).\\n\\t\\t\\tTime(\\\"chargeTime\\\", chargeTime).\\n\\t\\t\\tMsg(\\\"NO_RESOURCE_TO_CHARGE\\\")\\n\\t\\treturn nil\\n\\t}\\n\\treturn c.ProcessChargeDetail(chargeDetail)\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/logi_vol.go\",\n    \"code_start_line\": 109,\n    \"code_end_line\": 132,\n    \"code_key\": \"FindByIDs\",\n    \"code_value\": \"func (v *logicalVolumeViewerImpl) FindByIDs(ctx context.Context, appID users.AppID, id []uuid.UUID) ([]*rdiskDomain.LogicalVolume, error) {\\n\\tvar (\\n\\t\\tresultViews   []rdiskDomain.LogicalVolume\\n\\t\\tresultViewRef []*rdiskDomain.LogicalVolume\\n\\t\\tdataObjects   []*metadb.DmRdisk\\n\\t)\\n\\n\\tuuidStrSlice := functools.Map(id, func(i uuid.UUID) string { return i.String() })\\n\\tresult := v.db.WithContext(ctx).Preload(\\\"DmPhyDisk\\\").Find(&dataObjects, \\\"app_id = ? and uuid in ?\\\", appID, uuidStrSlice)\\n\\tif result.Error != nil {\\n\\t\\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\\n\\t\\t\\treturn nil, errors.New(rdiskDomain.ErrVolumeNotExists, \\\"logical volume not exist\\\")\\n\\t\\t}\\n\\t\\treturn nil, result.Error\\n\\t}\\n\\n\\tresultViews = make([]rdiskDomain.LogicalVolume, len(dataObjects))\\n\\tresultViewRef = make([]*rdiskDomain.LogicalVolume, len(dataObjects))\\n\\tfor i := range dataObjects {\\n\\t\\tresultViewRef[i] = &resultViews[i]\\n\\t\\tv.translate(dataObjects[i], resultViewRef[i])\\n\\t}\\n\\treturn resultViewRef, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"Preload DmPhyDisk\", \"sql\": \"SELECT * FROM dm_rdisk WHERE app_id = ? AND uuid IN ?;\"}, {\"scenario\": \"Preload DmPhyDisk with association query\", \"sql\": \"SELECT * FROM dm_phydisk WHERE uuid IN (SELECT uuid FROM dm_rdisk WHERE app_id = ? AND uuid IN ?);\"}]}]",
      "parsed_sql": [
        "SELECT * FROM dm_rdisk WHERE app_id = ? AND uuid IN ?;",
        "SELECT * FROM dm_phydisk WHERE uuid IN (SELECT uuid FROM dm_rdisk WHERE app_id = ? AND uuid IN ?);"
      ],
      "sql_evaluation": {
        "total_sql": 2,
        "valid_sql": 2,
        "matched_sql": 1,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM dm_rdisk WHERE app_id = ? AND uuid IN ?;",
            "match_result": {
              "matched": true,
              "fingerprint": "b0ca129db83e26402fb0dd198aa16698",
              "example_sql": "SELECT * FROM `dm_rdisk` WHERE uuid = '21b98301-fbba-4c0c-8731-65b9dc42941c' AND app_id = 1258344699 ORDER BY `dm_rdisk`.`id` LIMIT 1",
              "example_count": 8
            }
          },
          {
            "sql": "SELECT * FROM dm_phydisk WHERE uuid IN (SELECT uuid FROM dm_rdisk WHERE app_id = ? AND uuid IN ?);",
            "match_result": {
              "matched": false,
              "fingerprint": "dc8a50bcdf7e6665c8015582abe04e92",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/backup.go:19:41:FindByAppID",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：FindByAppID\nfunc (v *backupViewerImpl) FindByAppID(ctx context.Context, appID users.AppID, uuids, rdisks []string) ([]*backup.View, error) {\n\tvar (\n\t\tviews []*backup.View\n\t\tdtos  []*metadb.DmRdiskBackup\n\t)\n\tquery := v.db.WithContext(ctx).Where(\"app_id = ?\", appID)\n\tif len(uuids) > 0 {\n\t\tquery = query.Where(\"uuid in ?\", uuids)\n\t}\n\tif len(rdisks) > 0 {\n\t\tquery = query.Where(\"rdisk_uuid in ?\", rdisks)\n\t}\n\tresult := query.Find(&dtos)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\tviews = functools.MapRef(make([]backup.View, len(dtos)))\n\tfor i := range dtos {\n\t\tv.translate(dtos[i], views[i])\n\t}\n\n\treturn views, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go\", \"code_start_line\": 704, \"code_end_line\": 706, \"code_key\": \"QueryRDiskBackup\", \"code_value\": \"func (s *UnimplementedMaster) QueryRDiskBackup(ctx context.Context, req *QueryRDiskBackupRequest) (*QueryRDiskBackupResponse, error) {\\n\\treturn nil, errors.New(\\\"rpc QueryRDiskBackup of service Master is not implemented\\\")\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/backup.go\",\n    \"code_start_line\": 19,\n    \"code_end_line\": 41,\n    \"code_key\": \"FindByAppID\",\n    \"code_value\": \"func (v *backupViewerImpl) FindByAppID(ctx context.Context, appID users.AppID, uuids, rdisks []string) ([]*backup.View, error) {\\n\\tvar (\\n\\t\\tviews []*backup.View\\n\\t\\tdtos  []*metadb.DmRdiskBackup\\n\\t)\\n\\tquery := v.db.WithContext(ctx).Where(\\\"app_id = ?\\\", appID)\\n\\tif len(uuids) > 0 {\\n\\t\\tquery = query.Where(\\\"uuid in ?\\\", uuids)\\n\\t}\\n\\tif len(rdisks) > 0 {\\n\\t\\tquery = query.Where(\\\"rdisk_uuid in ?\\\", rdisks)\\n\\t}\\n\\tresult := query.Find(&dtos)\\n\\tif result.Error != nil {\\n\\t\\treturn nil, result.Error\\n\\t}\\n\\tviews = functools.MapRef(make([]backup.View, len(dtos)))\\n\\tfor i := range dtos {\\n\\t\\tv.translate(dtos[i], views[i])\\n\\t}\\n\\n\\treturn views, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"只有appID条件\", \"sql\": \"SELECT * FROM dm_rdisk_backup WHERE app_id = ?;\"}, {\"scenario\": \"appID + uuids条件\", \"sql\": \"SELECT * FROM dm_rdisk_backup WHERE app_id = ? AND uuid IN (?);\"}, {\"scenario\": \"appID + rdisks条件\", \"sql\": \"SELECT * FROM dm_rdisk_backup WHERE app_id = ? AND rdisk_uuid IN (?);\"}, {\"scenario\": \"appID + uuids + rdisks条件\", \"sql\": \"SELECT * FROM dm_rdisk_backup WHERE app_id = ? AND uuid IN (?) AND rdisk_uuid IN (?);\"}]}]",
      "parsed_sql": [
        "SELECT * FROM dm_rdisk_backup WHERE app_id = ?;",
        "SELECT * FROM dm_rdisk_backup WHERE app_id = ? AND uuid IN (?);",
        "SELECT * FROM dm_rdisk_backup WHERE app_id = ? AND rdisk_uuid IN (?);",
        "SELECT * FROM dm_rdisk_backup WHERE app_id = ? AND uuid IN (?) AND rdisk_uuid IN (?);"
      ],
      "sql_evaluation": {
        "total_sql": 4,
        "valid_sql": 4,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM dm_rdisk_backup WHERE app_id = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "2ef734ae88c2788bb2448577b648ea9f",
              "excluded": false
            }
          },
          {
            "sql": "SELECT * FROM dm_rdisk_backup WHERE app_id = ? AND uuid IN (?);",
            "match_result": {
              "matched": false,
              "fingerprint": "edee871df97029d94a0a4b3055e3948e",
              "excluded": false
            }
          },
          {
            "sql": "SELECT * FROM dm_rdisk_backup WHERE app_id = ? AND rdisk_uuid IN (?);",
            "match_result": {
              "matched": false,
              "fingerprint": "9ff86a36cfd493d69736bb112615c60c",
              "excluded": false
            }
          },
          {
            "sql": "SELECT * FROM dm_rdisk_backup WHERE app_id = ? AND uuid IN (?) AND rdisk_uuid IN (?);",
            "match_result": {
              "matched": false,
              "fingerprint": "d3565d87610308d03e7ebf3a19afff14",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/drgroup.go:126:147:FindByAppID",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：FindByAppID\nfunc (d *drgroupViewerImpl) FindByAppID(ctx context.Context, appId users.AppID) ([]*drgroup.View, error) {\n\tvar (\n\t\tresultViews       []drgroup.View\n\t\tresultViewRef     []*drgroup.View\n\t\tdataObjects       []*metadb.DmDrgroup\n\t\tdataObjectMembers []*metadb.DmDrgroupMembers\n\t)\n\tresult := d.db.WithContext(ctx).Find(&dataObjects).Where(\"app_id = ?\", appId, dataObjectMembers)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"group not exist\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tresultViews = make([]drgroup.View, len(dataObjects))\n\tresultViewRef = make([]*drgroup.View, len(dataObjects))\n\tfor i := range dataObjects {\n\t\tresultViewRef[i] = &resultViews[i]\n\t\td.translate(dataObjects[i], resultViewRef[i])\n\t}\n\treturn resultViewRef, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go\", \"code_start_line\": 704, \"code_end_line\": 706, \"code_key\": \"QueryRDiskBackup\", \"code_value\": \"func (s *UnimplementedMaster) QueryRDiskBackup(ctx context.Context, req *QueryRDiskBackupRequest) (*QueryRDiskBackupResponse, error) {\\n\\treturn nil, errors.New(\\\"rpc QueryRDiskBackup of service Master is not implemented\\\")\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/drgroup.go\",\n    \"code_start_line\": 126,\n    \"code_end_line\": 147,\n    \"code_key\": \"FindByAppID\",\n    \"code_value\": \"func (d *drgroupViewerImpl) FindByAppID(ctx context.Context, appId users.AppID) ([]*drgroup.View, error) {\\n\\tvar (\\n\\t\\tresultViews       []drgroup.View\\n\\t\\tresultViewRef     []*drgroup.View\\n\\t\\tdataObjects       []*metadb.DmDrgroup\\n\\t\\tdataObjectMembers []*metadb.DmDrgroupMembers\\n\\t)\\n\\tresult := d.db.WithContext(ctx).Find(&dataObjects).Where(\\\"app_id = ?\\\", appId, dataObjectMembers)\\n\\tif result.Error != nil {\\n\\t\\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\\n\\t\\t\\treturn nil, errors.New(drgroup.ErrGroupNotExist, \\\"group not exist\\\")\\n\\t\\t}\\n\\t\\treturn nil, result.Error\\n\\t}\\n\\tresultViews = make([]drgroup.View, len(dataObjects))\\n\\tresultViewRef = make([]*drgroup.View, len(dataObjects))\\n\\tfor i := range dataObjects {\\n\\t\\tresultViewRef[i] = &resultViews[i]\\n\\t\\td.translate(dataObjects[i], resultViewRef[i])\\n\\t}\\n\\treturn resultViewRef, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM dm_drgroup WHERE app_id = ?;\"]",
      "parsed_sql": [
        "SELECT * FROM dm_drgroup WHERE app_id = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM dm_drgroup WHERE app_id = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "6f14e5c2b0100a17a3016b5d9bcfbaa2",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/backup.go:44:61:FindByDiskUUIDs",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：FindByDiskUUIDs\nfunc (v *backupViewerImpl) FindByDiskUUIDs(ctx context.Context, uuids []string) ([]*backup.View, error) {\n\tvar (\n\t\tviews []*backup.View\n\t\tdtos  []*metadb.DmRdiskBackup\n\t)\n\n\tresult := v.db.WithContext(ctx).Find(&dtos, \"rdisk_uuid in ?\", uuids)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\n\tviews = functools.MapRef(make([]backup.View, len(dtos)))\n\tfor i := range dtos {\n\t\tv.translate(dtos[i], views[i])\n\t}\n\n\treturn views, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/defunct.go\", \"code_start_line\": 40, \"code_end_line\": 74, \"code_key\": \"FireCancelBackupEventForDefunct\", \"code_value\": \"func FireCancelBackupEventForDefunct(ctx context.Context, source rdiskDomain.LogicalVolumeState, target rdiskDomain.LogicalVolumeState, stateCtx app.LogicalVolumeContext) (rdiskDomain.LogicalVolumeState, error) {\\n\\tvar (\\n\\t\\terr          error\\n\\t\\tstateMachine = app.GetRegistry(ctx).StateMachines.Backup\\n\\t\\trepo         = app.GetRegistry(ctx).Repositories.Backup\\n\\t\\tview         = app.GetRegistry(ctx).Viewers.Backup\\n\\t\\tevent        = backup.EventForceSoftDeleteBackup\\n\\t)\\n\\n\\tbackupViews, err := view.FindByDiskUUIDs(ctx, []string{stateCtx.GetLogicalVolume().UUID.String()})\\n\\tif err != nil {\\n\\t\\treturn source, err\\n\\t}\\n\\trunningBackupUuid := lo.FilterMap(backupViews, func(backupView *backup.View, _ int) (string, bool) {\\n\\t\\tif backupView.Status == backup.StatusRunning {\\n\\t\\t\\treturn backupView.UUID.String(), true\\n\\t\\t}\\n\\t\\treturn \\\"\\\", false\\n\\t})\\n\\n\\tfor _, u := range runningBackupUuid {\\n\\t\\tb, err := repo.FindByUUID(ctx, u)\\n\\t\\tif err != nil {\\n\\t\\t\\tlogs.Warn(ctx).Str(\\\"uuid\\\", u).Msg(\\\"find backup by uuid failed\\\")\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\t_, err = stateMachine.Fire(ctx, b.Status, event, backup.Data{Backup: b, Delegate: &backupDelegate{}})\\n\\t\\tif err != nil {\\n\\t\\t\\tlogs.Warn(ctx).Err(err).Str(\\\"uuid\\\", u).Msg(\\\"fire cancel backup event failed\\\")\\n\\t\\t\\treturn source, err\\n\\t\\t}\\n\\t}\\n\\n\\treturn target, nil\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/backup.go\",\n    \"code_start_line\": 44,\n    \"code_end_line\": 61,\n    \"code_key\": \"FindByDiskUUIDs\",\n    \"code_value\": \"func (v *backupViewerImpl) FindByDiskUUIDs(ctx context.Context, uuids []string) ([]*backup.View, error) {\\n\\tvar (\\n\\t\\tviews []*backup.View\\n\\t\\tdtos  []*metadb.DmRdiskBackup\\n\\t)\\n\\n\\tresult := v.db.WithContext(ctx).Find(&dtos, \\\"rdisk_uuid in ?\\\", uuids)\\n\\tif result.Error != nil {\\n\\t\\treturn nil, result.Error\\n\\t}\\n\\n\\tviews = functools.MapRef(make([]backup.View, len(dtos)))\\n\\tfor i := range dtos {\\n\\t\\tv.translate(dtos[i], views[i])\\n\\t}\\n\\n\\treturn views, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM dm_rdisk_backup WHERE rdisk_uuid IN (?);\"]",
      "parsed_sql": [
        "SELECT * FROM dm_rdisk_backup WHERE rdisk_uuid IN (?);"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM dm_rdisk_backup WHERE rdisk_uuid IN (?);",
            "match_result": {
              "matched": false,
              "fingerprint": "7d8041cd9de89cfa2de921adabea6772",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/backup.go:81:95:FindByUUIDs",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：FindByUUIDs\nfunc (v *backupViewerImpl) FindByUUIDs(ctx context.Context, uuids []string) ([]*backup.View, error) {\n\tvar (\n\t\tviews []*backup.View\n\t\tdtos  []*metadb.DmRdiskBackup\n\t)\n\tresult := v.db.WithContext(ctx).Find(&dtos, \"uuid in ?\", uuids)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\tviews = functools.MapRef(make([]backup.View, len(dtos)))\n\tfor i := range dtos {\n\t\tv.translate(dtos[i], views[i])\n\t}\n\treturn views, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/backup.go\",\n    \"code_start_line\": 81,\n    \"code_end_line\": 95,\n    \"code_key\": \"FindByUUIDs\",\n    \"code_value\": \"func (v *backupViewerImpl) FindByUUIDs(ctx context.Context, uuids []string) ([]*backup.View, error) {\\n\\tvar (\\n\\t\\tviews []*backup.View\\n\\t\\tdtos  []*metadb.DmRdiskBackup\\n\\t)\\n\\tresult := v.db.WithContext(ctx).Find(&dtos, \\\"uuid in ?\\\", uuids)\\n\\tif result.Error != nil {\\n\\t\\treturn nil, result.Error\\n\\t}\\n\\tviews = functools.MapRef(make([]backup.View, len(dtos)))\\n\\tfor i := range dtos {\\n\\t\\tv.translate(dtos[i], views[i])\\n\\t}\\n\\treturn views, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM dm_rdisk_backup WHERE uuid IN (?);\"]",
      "parsed_sql": [
        "SELECT * FROM dm_rdisk_backup WHERE uuid IN (?);"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM dm_rdisk_backup WHERE uuid IN (?);",
            "match_result": {
              "matched": false,
              "fingerprint": "cb52b14d1ad1d2f3cabed75f96ed3867",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/drgroup.go:24:73:QueryRelationsMap",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：QueryRelationsMap\nfunc (d *drgroupViewerImpl) QueryRelationsMap(ctx context.Context, appId users.AppID, members []string) (map[string][]*drgroup.View, error) {\n\tmembersRec := make([]*struct {\n\t\tMemberID    string\n\t\tGroupName   string\n\t\tSubGroup    string\n\t\tLocType     string\n\t\tAffinity    int\n\t\tMemberCnt   int\n\t\tSatisfied   int\n\t\tSubGroupCnt int\n\t}, 0, 10)\n\tresult := d.db.WithContext(ctx).Table(\"dm_drgroup_members\").\n\t\tSelect(\"dm_drgroup_members.member_id, dm_drgroup_members.group_name, dm_drgroup_members.sub_group, dm_drgroup.loc_type, dm_drgroup.affinity, dm_drgroup.member_cnt, dm_drgroup.satisfied, dm_drgroup.sub_group_cnt\").\n\t\tJoins(\"left join dm_drgroup on dm_drgroup_members.app_id = dm_drgroup.app_id and dm_drgroup_members.group_name = dm_drgroup.name\").\n\t\tWhere(\"dm_drgroup_members.app_id = ? and dm_drgroup_members.member_id in ?\", appId, members).\n\t\tScan(&membersRec)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\n\tresultMap := make(map[string][]*drgroup.View)\n\tviewMap := make(map[string]*drgroup.View)\n\tfor i := range membersRec {\n\t\tmember := membersRec[i].MemberID\n\t\tgroup := membersRec[i].GroupName\n\t\tif _, ok := resultMap[member]; !ok {\n\t\t\tresultMap[member] = make([]*drgroup.View, 0, 10)\n\t\t}\n\t\tif ref, ok := viewMap[group]; ok {\n\t\t\tref.SubGroupMap[member] = membersRec[i].SubGroup\n\t\t\tresultMap[member] = append(resultMap[member], ref)\n\t\t} else {\n\t\t\tref = &drgroup.View{\n\t\t\t\tName:          group,\n\t\t\t\tAppID:         appId,\n\t\t\t\tType:          drgroup.LocType(membersRec[i].LocType),\n\t\t\t\tAffinity:      membersRec[i].Affinity,\n\t\t\t\tMemberCount:   membersRec[i].MemberCnt,\n\t\t\t\tSatisfied:     membersRec[i].Satisfied >= 1,\n\t\t\t\tSubGroupCount: membersRec[i].SubGroupCnt,\n\t\t\t\tSubGroupMap:   make(map[string]string),\n\t\t\t}\n\t\t\tviewMap[group] = ref\n\t\t\tref.SubGroupMap[member] = membersRec[i].SubGroup\n\t\t\tresultMap[member] = append(resultMap[member], ref)\n\t\t}\n\t}\n\n\treturn resultMap, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go\", \"code_start_line\": 649, \"code_end_line\": 651, \"code_key\": \"QueryRDiskVol\", \"code_value\": \"func (s *UnimplementedMaster) QueryRDiskVol(ctx context.Context, req *QueryRDiskVolRequest) (*QueryRDiskVolResponse, error) {\\n\\treturn nil, errors.New(\\\"rpc QueryRDiskVol of service Master is not implemented\\\")\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/drgroup.go\",\n    \"code_start_line\": 24,\n    \"code_end_line\": 73,\n    \"code_key\": \"QueryRelationsMap\",\n    \"code_value\": \"func (d *drgroupViewerImpl) QueryRelationsMap(ctx context.Context, appId users.AppID, members []string) (map[string][]*drgroup.View, error) {\\n\\tmembersRec := make([]*struct {\\n\\t\\tMemberID    string\\n\\t\\tGroupName   string\\n\\t\\tSubGroup    string\\n\\t\\tLocType     string\\n\\t\\tAffinity    int\\n\\t\\tMemberCnt   int\\n\\t\\tSatisfied   int\\n\\t\\tSubGroupCnt int\\n\\t}, 0, 10)\\n\\tresult := d.db.WithContext(ctx).Table(\\\"dm_drgroup_members\\\").\\n\\t\\tSelect(\\\"dm_drgroup_members.member_id, dm_drgroup_members.group_name, dm_drgroup_members.sub_group, dm_drgroup.loc_type, dm_drgroup.affinity, dm_drgroup.member_cnt, dm_drgroup.satisfied, dm_drgroup.sub_group_cnt\\\").\\n\\t\\tJoins(\\\"left join dm_drgroup on dm_drgroup_members.app_id = dm_drgroup.app_id and dm_drgroup_members.group_name = dm_drgroup.name\\\").\\n\\t\\tWhere(\\\"dm_drgroup_members.app_id = ? and dm_drgroup_members.member_id in ?\\\", appId, members).\\n\\t\\tScan(&membersRec)\\n\\tif result.Error != nil {\\n\\t\\treturn nil, result.Error\\n\\t}\\n\\n\\tresultMap := make(map[string][]*drgroup.View)\\n\\tviewMap := make(map[string]*drgroup.View)\\n\\tfor i := range membersRec {\\n\\t\\tmember := membersRec[i].MemberID\\n\\t\\tgroup := membersRec[i].GroupName\\n\\t\\tif _, ok := resultMap[member]; !ok {\\n\\t\\t\\tresultMap[member] = make([]*drgroup.View, 0, 10)\\n\\t\\t}\\n\\t\\tif ref, ok := viewMap[group]; ok {\\n\\t\\t\\tref.SubGroupMap[member] = membersRec[i].SubGroup\\n\\t\\t\\tresultMap[member] = append(resultMap[member], ref)\\n\\t\\t} else {\\n\\t\\t\\tref = &drgroup.View{\\n\\t\\t\\t\\tName:          group,\\n\\t\\t\\t\\tAppID:         appId,\\n\\t\\t\\t\\tType:          drgroup.LocType(membersRec[i].LocType),\\n\\t\\t\\t\\tAffinity:      membersRec[i].Affinity,\\n\\t\\t\\t\\tMemberCount:   membersRec[i].MemberCnt,\\n\\t\\t\\t\\tSatisfied:     membersRec[i].Satisfied >= 1,\\n\\t\\t\\t\\tSubGroupCount: membersRec[i].SubGroupCnt,\\n\\t\\t\\t\\tSubGroupMap:   make(map[string]string),\\n\\t\\t\\t}\\n\\t\\t\\tviewMap[group] = ref\\n\\t\\t\\tref.SubGroupMap[member] = membersRec[i].SubGroup\\n\\t\\t\\tresultMap[member] = append(resultMap[member], ref)\\n\\t\\t}\\n\\t}\\n\\n\\treturn resultMap, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT dm_drgroup_members.member_id, dm_drgroup_members.group_name, dm_drgroup_members.sub_group, dm_drgroup.loc_type, dm_drgroup.affinity, dm_drgroup.member_cnt, dm_drgroup.satisfied, dm_drgroup.sub_group_cnt FROM dm_drgroup_members LEFT JOIN dm_drgroup ON dm_drgroup_members.app_id = dm_drgroup.app_id AND dm_drgroup_members.group_name = dm_drgroup.name WHERE dm_drgroup_members.app_id = ? AND dm_drgroup_members.member_id IN (?);\"]",
      "parsed_sql": [
        "SELECT dm_drgroup_members.member_id, dm_drgroup_members.group_name, dm_drgroup_members.sub_group, dm_drgroup.loc_type, dm_drgroup.affinity, dm_drgroup.member_cnt, dm_drgroup.satisfied, dm_drgroup.sub_group_cnt FROM dm_drgroup_members LEFT JOIN dm_drgroup ON dm_drgroup_members.app_id = dm_drgroup.app_id AND dm_drgroup_members.group_name = dm_drgroup.name WHERE dm_drgroup_members.app_id = ? AND dm_drgroup_members.member_id IN (?);"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT dm_drgroup_members.member_id, dm_drgroup_members.group_name, dm_drgroup_members.sub_group, dm_drgroup.loc_type, dm_drgroup.affinity, dm_drgroup.member_cnt, dm_drgroup.satisfied, dm_drgroup.sub_group_cnt FROM dm_drgroup_members LEFT JOIN dm_drgroup ON dm_drgroup_members.app_id = dm_drgroup.app_id AND dm_drgroup_members.group_name = dm_drgroup.name WHERE dm_drgroup_members.app_id = ? AND dm_drgroup_members.member_id IN (?);",
            "match_result": {
              "matched": false,
              "fingerprint": "6047e218ee786d8ae3fb4e1fc00bbcad",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/testutil/db.go:112:132:createTables",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：createTables\nfunc (i dbInitializer) createTables(t *testing.T, db *gorm.DB) {\n\t// sqlContent, err := os.ReadFile(\"../../../../changelog/db/metadb/2309_0001_init_table.sql\")\n\tsqlContent, err := i.collectSqlInDir(t, \"../../../../changelog/db/metadb\")\n\n\trequire.NoError(t, err, \"failed to read db file\")\n\tstmts := strings.Split(sqlContent, \";\\n\")\n\tfor _, stmt := range stmts {\n\t\tstmt = strings.Trim(stmt, \" \\n\")\n\t\tif stmt == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tif strings.HasPrefix(stmt, \"USE \") {\n\t\t\t// Ignore USE statement\n\t\t\tcontinue\n\t\t}\n\t\terr = db.Exec(stmt).Error\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/test_utils/initdb.go\", \"code_start_line\": 91, \"code_end_line\": 98, \"code_key\": \"SetupTestDatabase\", \"code_value\": \"func (i dbInitializer) SetupTestDatabase(t *testing.T, database string) (*gorm.DB, func()) {\\n\\tidx := pool.Get()\\n\\tdb := i.openMySQLConnection(t, database)\\n\\treturn db, func() {\\n\\t\\t_idx := idx\\n\\t\\tpool.Release(_idx)\\n\\t}\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/internal/rdisk_master/adapters/testutil/db.go\",\n    \"code_start_line\": 112,\n    \"code_end_line\": 132,\n    \"code_key\": \"createTables\",\n    \"code_value\": \"func (i dbInitializer) createTables(t *testing.T, db *gorm.DB) {\\n\\t// sqlContent, err := os.ReadFile(\\\"../../../../changelog/db/metadb/2309_0001_init_table.sql\\\")\\n\\tsqlContent, err := i.collectSqlInDir(t, \\\"../../../../changelog/db/metadb\\\")\\n\\n\\trequire.NoError(t, err, \\\"failed to read db file\\\")\\n\\tstmts := strings.Split(sqlContent, \\\";\\\\n\\\")\\n\\tfor _, stmt := range stmts {\\n\\t\\tstmt = strings.Trim(stmt, \\\" \\\\n\\\")\\n\\t\\tif stmt == \\\"\\\" {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif strings.HasPrefix(stmt, \\\"USE \\\") {\\n\\t\\t\\t// Ignore USE statement\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\terr = db.Exec(stmt).Error\\n\\t\\tif err != nil {\\n\\t\\t\\tpanic(err)\\n\\t\\t}\\n\\t}\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"执行单个SQL语句\", \"sql\": \"CREATE TABLE example_table (id INT PRIMARY KEY, name VARCHAR(255));\"}, {\"scenario\": \"执行多个SQL语句\", \"sql\": \"CREATE TABLE table1 (id INT PRIMARY KEY); CREATE TABLE table2 (id INT PRIMARY KEY, name VARCHAR(255)); CREATE INDEX idx_table1_name ON table1(name);\"}, {\"scenario\": \"执行包含DDL和DML的混合语句\", \"sql\": \"CREATE TABLE users (id INT PRIMARY KEY, email VARCHAR(255), created_at DATETIME); INSERT INTO users (email, created_at) VALUES ('test@example.com', NOW()); CREATE INDEX idx_users_email ON users(email);\"}]}]",
      "parsed_sql": [
        "CREATE TABLE example_table (id INT PRIMARY KEY, name VARCHAR(255));",
        "CREATE TABLE table1 (id INT PRIMARY KEY); CREATE TABLE table2 (id INT PRIMARY KEY, name VARCHAR(255)); CREATE INDEX idx_table1_name ON table1(name);",
        "CREATE TABLE users (id INT PRIMARY KEY, email VARCHAR(255), created_at DATETIME); INSERT INTO users (email, created_at) VALUES ('test@example.com', NOW()); CREATE INDEX idx_users_email ON users(email);"
      ],
      "sql_evaluation": {
        "total_sql": 3,
        "valid_sql": 0,
        "matched_sql": 0,
        "excluded_sql": 3,
        "fingerprint_results": [
          {
            "sql": "CREATE TABLE example_table (id INT PRIMARY KEY, name VARCHAR(255));",
            "match_result": {
              "matched": false,
              "excluded": true,
              "fingerprint": "ddl_command",
              "excluded_reason": "排除的SQL类型"
            }
          },
          {
            "sql": "CREATE TABLE table1 (id INT PRIMARY KEY); CREATE TABLE table2 (id INT PRIMARY KEY, name VARCHAR(255)); CREATE INDEX idx_table1_name ON table1(name);",
            "match_result": {
              "matched": false,
              "excluded": true,
              "fingerprint": "ddl_command",
              "excluded_reason": "排除的SQL类型"
            }
          },
          {
            "sql": "CREATE TABLE users (id INT PRIMARY KEY, email VARCHAR(255), created_at DATETIME); INSERT INTO users (email, created_at) VALUES ('test@example.com', NOW()); CREATE INDEX idx_users_email ON users(email);",
            "match_result": {
              "matched": false,
              "excluded": true,
              "fingerprint": "ddl_command",
              "excluded_reason": "排除的SQL类型"
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go:101:143:fetchExistingLocks",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：fetchExistingLocks\nfunc (l *mysqlLocker) fetchExistingLocks(tx *gorm.DB, keys []*dlock.LockKey) ([]string, []string, []string, error) {\n\treadKeys := make(map[string]string)\n\tfor _, key := range keys {\n\t\tif key.Type == dlock.ReadLock {\n\t\t\treadKeys[key.Key] = \"\"\n\t\t}\n\t}\n\n\ttype Result struct {\n\t\tLock    string\n\t\tExpired bool\n\t\tType    int\n\t}\n\n\tvar Results []Result\n\tkeysKey := dlock.LockKeySlice.GetKeys(keys)\n\terr := tx.Raw(\"SELECT `\"+l.lockColumn+\"` AS `lock`, `\"+l.expireColumn+\"` < NOW() AS `expired`, `\"+l.lockTypeColumn+\"` AS `type` FROM \"+l.tableName+\" WHERE `\"+l.lockColumn+\"` IN (?)\", keysKey).Scan(&Results).Error\n\tif err != nil {\n\t\treturn nil, nil, nil, errors.Wrap(err, \"fail to query locks\")\n\t}\n\n\tvar existingReadKeys []string = nil\n\tvar existingWriteKeys []string = nil\n\tvar expiredKeys []string = nil\n\n\tfor _, r := range Results {\n\t\tif !r.Expired {\n\t\t\tif _, exist := readKeys[r.Lock]; exist {\n\t\t\t\tif dlock.LockType(r.Type) == dlock.WriteLock {\n\t\t\t\t\texistingWriteKeys = append(existingWriteKeys, r.Lock)\n\t\t\t\t} else {\n\t\t\t\t\texistingReadKeys = append(existingReadKeys, r.Lock)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\texistingWriteKeys = append(existingWriteKeys, r.Lock)\n\t\t\t}\n\t\t} else {\n\t\t\texpiredKeys = append(expiredKeys, r.Lock)\n\t\t}\n\t}\n\n\treturn existingReadKeys, existingWriteKeys, expiredKeys, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go\", \"code_start_line\": 417, \"code_end_line\": 470, \"code_key\": \"tryObtainMulti\", \"code_value\": \"func (l *mysqlLocker) tryObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, tokens []string, opts *dlock.Option) ([]string, error) {\\n\\t// Starts a new transaction.\\n\\ttx := l.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\\n\\n\\t// Fetch existing locks.\\n\\texistingReadKeys, existingWriteKeys, expiredKeys, err := l.fetchExistingLocks(tx, keys)\\n\\tif err != nil {\\n\\t\\t_ = tx.Rollback()\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\t// If there are existing valid locks, return an error.\\n\\tif len(existingWriteKeys) > 0 {\\n\\t\\t_ = tx.Rollback()\\n\\t\\treturn nil, errors.Wrap(dlock.ErrLockNotHeld, fmt.Sprintf(\\\"writeKeys %v are already locked\\\", existingWriteKeys))\\n\\t}\\n\\n\\t// Delete expired locks if exists.\\n\\tif err := l.deleteExpiredLocks(tx, expiredKeys); err != nil {\\n\\t\\t_ = tx.Rollback()\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\t// Remove existing readLocks from insert.\\n\\t// NOCA:QCloudAkCheck(误报)\\n\\tlockKeys, err := l.removeExistingReadLocksFromInsert(tx, keys, existingReadKeys)\\n\\tif err != nil {\\n\\t\\t_ = tx.Rollback()\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\t// Insert locks into database.\\n\\tneedInsertReadKeys, err := l.insertLocks(tx, lockKeys, ttl, tokens)\\n\\tif err != nil {\\n\\t\\t_ = tx.Rollback()\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\t// Update readLocks.\\n\\tvar needUpdateExpirationReadKeys []string = nil\\n\\tvar needUpdateCountReadKeys []string = nil\\n\\tif needUpdateExpirationReadKeys, needUpdateCountReadKeys, tokens, err = l.updateReadLocks(tx, ttl, existingReadKeys, tokens); err != nil {\\n\\t\\tl.rollback(needUpdateCountReadKeys, tokens)\\n\\t\\tl.rollback(needUpdateExpirationReadKeys, tokens)\\n\\t\\tl.rollback(needInsertReadKeys, tokens)\\n\\t\\t_ = tx.Rollback()\\n\\t\\treturn nil, err\\n\\t}\\n\\tif result := tx.Commit(); result.Error != nil {\\n\\t\\treturn nil, errors.Wrap(result.Error, \\\"failed to commit transaction\\\")\\n\\t}\\n\\n\\treturn tokens, nil\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go\",\n    \"code_start_line\": 101,\n    \"code_end_line\": 143,\n    \"code_key\": \"fetchExistingLocks\",\n    \"code_value\": \"func (l *mysqlLocker) fetchExistingLocks(tx *gorm.DB, keys []*dlock.LockKey) ([]string, []string, []string, error) {\\n\\treadKeys := make(map[string]string)\\n\\tfor _, key := range keys {\\n\\t\\tif key.Type == dlock.ReadLock {\\n\\t\\t\\treadKeys[key.Key] = \\\"\\\"\\n\\t\\t}\\n\\t}\\n\\n\\ttype Result struct {\\n\\t\\tLock    string\\n\\t\\tExpired bool\\n\\t\\tType    int\\n\\t}\\n\\n\\tvar Results []Result\\n\\tkeysKey := dlock.LockKeySlice.GetKeys(keys)\\n\\terr := tx.Raw(\\\"SELECT `\\\"+l.lockColumn+\\\"` AS `lock`, `\\\"+l.expireColumn+\\\"` < NOW() AS `expired`, `\\\"+l.lockTypeColumn+\\\"` AS `type` FROM \\\"+l.tableName+\\\" WHERE `\\\"+l.lockColumn+\\\"` IN (?)\\\", keysKey).Scan(&Results).Error\\n\\tif err != nil {\\n\\t\\treturn nil, nil, nil, errors.Wrap(err, \\\"fail to query locks\\\")\\n\\t}\\n\\n\\tvar existingReadKeys []string = nil\\n\\tvar existingWriteKeys []string = nil\\n\\tvar expiredKeys []string = nil\\n\\n\\tfor _, r := range Results {\\n\\t\\tif !r.Expired {\\n\\t\\t\\tif _, exist := readKeys[r.Lock]; exist {\\n\\t\\t\\t\\tif dlock.LockType(r.Type) == dlock.WriteLock {\\n\\t\\t\\t\\t\\texistingWriteKeys = append(existingWriteKeys, r.Lock)\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\texistingReadKeys = append(existingReadKeys, r.Lock)\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\texistingWriteKeys = append(existingWriteKeys, r.Lock)\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\texpiredKeys = append(expiredKeys, r.Lock)\\n\\t\\t}\\n\\t}\\n\\n\\treturn existingReadKeys, existingWriteKeys, expiredKeys, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT `lock_column` AS `lock`, `expire_column` < NOW() AS `expired`, `lock_type_column` AS `type` FROM table_name WHERE `lock_column` IN (?);\"]",
      "parsed_sql": [
        "SELECT `lock_column` AS `lock`, `expire_column` < NOW() AS `expired`, `lock_type_column` AS `type` FROM table_name WHERE `lock_column` IN (?);"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT `lock_column` AS `lock`, `expire_column` < NOW() AS `expired`, `lock_type_column` AS `type` FROM table_name WHERE `lock_column` IN (?);",
            "match_result": {
              "matched": false,
              "fingerprint": "e7e143a564d620172619045d86c21f1e",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go:148:162:fetchExistingLocksByKeysAndTokens",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：fetchExistingLocksByKeysAndTokens\nfunc (l *mysqlLocker) fetchExistingLocksByKeysAndTokens(tx *gorm.DB, keys []string, tokens []string) ([]string, error) {\n\ttype Result struct {\n\t\tLock string\n\t}\n\tvar results []Result\n\terr := tx.Raw(\"SELECT `\"+l.lockColumn+\"` AS `lock` FROM \"+l.tableName+\" WHERE `\"+l.lockColumn+\"` IN (?) AND `\"+l.tokenColumn+\"` IN (?) FOR UPDATE\", keys, tokens).Scan(&results).Error\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"fail to query locks\")\n\t}\n\tvar existingKeys []string = nil\n\tfor _, r := range results {\n\t\texistingKeys = append(existingKeys, r.Lock)\n\t}\n\treturn existingKeys, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/tracker.go\", \"code_start_line\": 67, \"code_end_line\": 77, \"code_key\": \"Refresh\", \"code_value\": \"func (rdp *PhyDiskTracker) Refresh(ctx context.Context) {\\n\\trdp.Track(ctx)\\n\\tlock.RDPhyCacheGlobalLock.GetLocker(lock.RDPhyLockKeyGenerator{}).Lock()\\n\\trdp.Merge(ctx, rdp.OriPhyDisks)\\n\\tlogs.Info(ctx).\\n\\t\\tInt(\\\"disk_num\\\", len(rdp.ToCachedPhyDisks)).\\n\\t\\tInt(\\\"member_num\\\", len(rdp.DrgroupMembers)).\\n\\t\\tMsg(\\\"CACHE_AVAILABLE_PHY_DISK_AFTER_MERGE\\\")\\n\\trdp.CacheManager.RefreshCache(ctx, rdp.ToCachedPhyDisks, rdp.DrgroupMembers)\\n\\tlock.RDPhyCacheGlobalLock.GetLocker(lock.RDPhyLockKeyGenerator{}).Unlock()\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go\",\n    \"code_start_line\": 148,\n    \"code_end_line\": 162,\n    \"code_key\": \"fetchExistingLocksByKeysAndTokens\",\n    \"code_value\": \"func (l *mysqlLocker) fetchExistingLocksByKeysAndTokens(tx *gorm.DB, keys []string, tokens []string) ([]string, error) {\\n\\ttype Result struct {\\n\\t\\tLock string\\n\\t}\\n\\tvar results []Result\\n\\terr := tx.Raw(\\\"SELECT `\\\"+l.lockColumn+\\\"` AS `lock` FROM \\\"+l.tableName+\\\" WHERE `\\\"+l.lockColumn+\\\"` IN (?) AND `\\\"+l.tokenColumn+\\\"` IN (?) FOR UPDATE\\\", keys, tokens).Scan(&results).Error\\n\\tif err != nil {\\n\\t\\treturn nil, errors.Wrap(err, \\\"fail to query locks\\\")\\n\\t}\\n\\tvar existingKeys []string = nil\\n\\tfor _, r := range results {\\n\\t\\texistingKeys = append(existingKeys, r.Lock)\\n\\t}\\n\\treturn existingKeys, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT `lock_column` AS `lock` FROM table_name WHERE `lock_column` IN (?) AND `token_column` IN (?) FOR UPDATE;\"]",
      "parsed_sql": [
        "SELECT `lock_column` AS `lock` FROM table_name WHERE `lock_column` IN (?) AND `token_column` IN (?) FOR UPDATE;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT `lock_column` AS `lock` FROM table_name WHERE `lock_column` IN (?) AND `token_column` IN (?) FOR UPDATE;",
            "match_result": {
              "matched": false,
              "fingerprint": "50e94664122cd5f34f1eba55e2d9d177",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go:165:176:deleteExpiredLocks",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：deleteExpiredLocks\nfunc (l *mysqlLocker) deleteExpiredLocks(tx *gorm.DB, keys []string) error {\n\tif len(keys) == 0 {\n\t\treturn nil\n\t}\n\n\tresult := tx.Exec(\"DELETE FROM \"+l.tableName+\" WHERE `\"+l.lockColumn+\"` IN (?) AND `\"+l.expireColumn+\"` < NOW()\", keys)\n\tif result.Error != nil {\n\t\treturn errors.Wrap(result.Error, \"failed to delete expired locks\")\n\t}\n\n\treturn nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go\", \"code_start_line\": 417, \"code_end_line\": 470, \"code_key\": \"tryObtainMulti\", \"code_value\": \"func (l *mysqlLocker) tryObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, tokens []string, opts *dlock.Option) ([]string, error) {\\n\\t// Starts a new transaction.\\n\\ttx := l.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\\n\\n\\t// Fetch existing locks.\\n\\texistingReadKeys, existingWriteKeys, expiredKeys, err := l.fetchExistingLocks(tx, keys)\\n\\tif err != nil {\\n\\t\\t_ = tx.Rollback()\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\t// If there are existing valid locks, return an error.\\n\\tif len(existingWriteKeys) > 0 {\\n\\t\\t_ = tx.Rollback()\\n\\t\\treturn nil, errors.Wrap(dlock.ErrLockNotHeld, fmt.Sprintf(\\\"writeKeys %v are already locked\\\", existingWriteKeys))\\n\\t}\\n\\n\\t// Delete expired locks if exists.\\n\\tif err := l.deleteExpiredLocks(tx, expiredKeys); err != nil {\\n\\t\\t_ = tx.Rollback()\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\t// Remove existing readLocks from insert.\\n\\t// NOCA:QCloudAkCheck(误报)\\n\\tlockKeys, err := l.removeExistingReadLocksFromInsert(tx, keys, existingReadKeys)\\n\\tif err != nil {\\n\\t\\t_ = tx.Rollback()\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\t// Insert locks into database.\\n\\tneedInsertReadKeys, err := l.insertLocks(tx, lockKeys, ttl, tokens)\\n\\tif err != nil {\\n\\t\\t_ = tx.Rollback()\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\t// Update readLocks.\\n\\tvar needUpdateExpirationReadKeys []string = nil\\n\\tvar needUpdateCountReadKeys []string = nil\\n\\tif needUpdateExpirationReadKeys, needUpdateCountReadKeys, tokens, err = l.updateReadLocks(tx, ttl, existingReadKeys, tokens); err != nil {\\n\\t\\tl.rollback(needUpdateCountReadKeys, tokens)\\n\\t\\tl.rollback(needUpdateExpirationReadKeys, tokens)\\n\\t\\tl.rollback(needInsertReadKeys, tokens)\\n\\t\\t_ = tx.Rollback()\\n\\t\\treturn nil, err\\n\\t}\\n\\tif result := tx.Commit(); result.Error != nil {\\n\\t\\treturn nil, errors.Wrap(result.Error, \\\"failed to commit transaction\\\")\\n\\t}\\n\\n\\treturn tokens, nil\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go\",\n    \"code_start_line\": 165,\n    \"code_end_line\": 176,\n    \"code_key\": \"deleteExpiredLocks\",\n    \"code_value\": \"func (l *mysqlLocker) deleteExpiredLocks(tx *gorm.DB, keys []string) error {\\n\\tif len(keys) == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tresult := tx.Exec(\\\"DELETE FROM \\\"+l.tableName+\\\" WHERE `\\\"+l.lockColumn+\\\"` IN (?) AND `\\\"+l.expireColumn+\\\"` < NOW()\\\", keys)\\n\\tif result.Error != nil {\\n\\t\\treturn errors.Wrap(result.Error, \\\"failed to delete expired locks\\\")\\n\\t}\\n\\n\\treturn nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"keys数组为空时\", \"sql\": \"\"}, {\"scenario\": \"keys数组不为空时\", \"sql\": \"DELETE FROM ? WHERE `?` IN (?) AND `?` < NOW();\"}]}]",
      "parsed_sql": [
        "DELETE FROM ? WHERE `?` IN (?) AND `?` < NOW();"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "DELETE FROM ? WHERE `?` IN (?) AND `?` < NOW();",
            "match_result": {
              "matched": false,
              "fingerprint": "42f3a84398349c97773d080d9a742a3c",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go:178:233:updateReadLocks",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：updateReadLocks\nfunc (l *mysqlLocker) updateReadLocks(tx *gorm.DB, ttl time.Duration, keys []string, lockTokens []string) ([]string, []string, []string, error) {\n\tif len(keys) == 0 {\n\t\treturn nil, nil, lockTokens, nil\n\t}\n\ttype Result struct {\n\t\tLock       string\n\t\tExpiration time.Time\n\t\tToken      string\n\t}\n\tvar Results []Result\n\terr := tx.Raw(\"SELECT `\"+l.lockColumn+\"` AS `lock`, `\"+l.expireColumn+\"` AS `expiration`, `\"+l.tokenColumn+\"` AS `token` FROM \"+l.tableName+\" WHERE `\"+l.lockColumn+\"` IN (?)\", keys).Scan(&Results).Error\n\tif err != nil {\n\t\treturn nil, nil, nil, errors.Wrap(err, \"fail to query locks\")\n\t}\n\n\tvar needUpdateExpirationReadKeys []string = nil\n\tvar needUpdateCountReadKeys []string = nil\n\tl.mutex.Lock()\n\tt := time.Now()\n\tfor _, r := range Results {\n\t\tif r.Token != lockTokens[0] {\n\t\t\tlockTokens = append(lockTokens, r.Token)\n\t\t}\n\t\tif readKey, exist := l.readKeysMemLock[r.Lock]; exist {\n\t\t\treadKey.count++\n\t\t\treadKey.expiration = r.Expiration\n\t\t} else {\n\t\t\tl.readKeysMemLock[r.Lock] = &readKeysMemLock{\n\t\t\t\tcount:      1,\n\t\t\t\texpiration: r.Expiration,\n\t\t\t\ttoken:      r.Token,\n\t\t\t}\n\t\t\tneedUpdateCountReadKeys = append(needUpdateCountReadKeys, r.Lock)\n\t\t}\n\t\tif l.readKeysMemLock[r.Lock].expiration.Sub(t) < ttl/3 {\n\t\t\tl.readKeysMemLock[r.Lock].expiration = t.Add(ttl)\n\t\t\tneedUpdateExpirationReadKeys = append(needUpdateExpirationReadKeys, r.Lock)\n\t\t}\n\t}\n\tl.mutex.Unlock()\n\tif len(needUpdateExpirationReadKeys) > 0 {\n\t\tresult := tx.Exec(\"UPDATE \"+l.tableName+\" SET \"+l.expireColumn+\" = NOW() + INTERVAL ? SECOND WHERE `\"+l.lockColumn+\"` IN (?)\", ttl.Seconds(), needUpdateExpirationReadKeys)\n\t\tif result.Error != nil {\n\t\t\treturn nil, needUpdateExpirationReadKeys, needUpdateCountReadKeys, errors.Wrap(result.Error, fmt.Sprintf(\"failed to update readLocks: %s\", keys))\n\t\t}\n\t}\n\n\tif len(needUpdateCountReadKeys) > 0 {\n\t\tresult := tx.Exec(\"UPDATE \"+l.tableName+\" SET \"+l.lockNumsColumn+\" = \"+l.lockNumsColumn+\" + 1 WHERE `\"+l.lockColumn+\"` IN (?)\", needUpdateCountReadKeys)\n\t\tif result.Error != nil {\n\t\t\treturn nil, needUpdateExpirationReadKeys, needUpdateCountReadKeys, errors.Wrap(result.Error, fmt.Sprintf(\"failed to update readLocks: %s\", keys))\n\t\t}\n\t}\n\n\treturn nil, nil, lockTokens, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go\", \"code_start_line\": 417, \"code_end_line\": 470, \"code_key\": \"tryObtainMulti\", \"code_value\": \"func (l *mysqlLocker) tryObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, tokens []string, opts *dlock.Option) ([]string, error) {\\n\\t// Starts a new transaction.\\n\\ttx := l.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\\n\\n\\t// Fetch existing locks.\\n\\texistingReadKeys, existingWriteKeys, expiredKeys, err := l.fetchExistingLocks(tx, keys)\\n\\tif err != nil {\\n\\t\\t_ = tx.Rollback()\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\t// If there are existing valid locks, return an error.\\n\\tif len(existingWriteKeys) > 0 {\\n\\t\\t_ = tx.Rollback()\\n\\t\\treturn nil, errors.Wrap(dlock.ErrLockNotHeld, fmt.Sprintf(\\\"writeKeys %v are already locked\\\", existingWriteKeys))\\n\\t}\\n\\n\\t// Delete expired locks if exists.\\n\\tif err := l.deleteExpiredLocks(tx, expiredKeys); err != nil {\\n\\t\\t_ = tx.Rollback()\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\t// Remove existing readLocks from insert.\\n\\t// NOCA:QCloudAkCheck(误报)\\n\\tlockKeys, err := l.removeExistingReadLocksFromInsert(tx, keys, existingReadKeys)\\n\\tif err != nil {\\n\\t\\t_ = tx.Rollback()\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\t// Insert locks into database.\\n\\tneedInsertReadKeys, err := l.insertLocks(tx, lockKeys, ttl, tokens)\\n\\tif err != nil {\\n\\t\\t_ = tx.Rollback()\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\t// Update readLocks.\\n\\tvar needUpdateExpirationReadKeys []string = nil\\n\\tvar needUpdateCountReadKeys []string = nil\\n\\tif needUpdateExpirationReadKeys, needUpdateCountReadKeys, tokens, err = l.updateReadLocks(tx, ttl, existingReadKeys, tokens); err != nil {\\n\\t\\tl.rollback(needUpdateCountReadKeys, tokens)\\n\\t\\tl.rollback(needUpdateExpirationReadKeys, tokens)\\n\\t\\tl.rollback(needInsertReadKeys, tokens)\\n\\t\\t_ = tx.Rollback()\\n\\t\\treturn nil, err\\n\\t}\\n\\tif result := tx.Commit(); result.Error != nil {\\n\\t\\treturn nil, errors.Wrap(result.Error, \\\"failed to commit transaction\\\")\\n\\t}\\n\\n\\treturn tokens, nil\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go\",\n    \"code_start_line\": 178,\n    \"code_end_line\": 233,\n    \"code_key\": \"updateReadLocks\",\n    \"code_value\": \"func (l *mysqlLocker) updateReadLocks(tx *gorm.DB, ttl time.Duration, keys []string, lockTokens []string) ([]string, []string, []string, error) {\\n\\tif len(keys) == 0 {\\n\\t\\treturn nil, nil, lockTokens, nil\\n\\t}\\n\\ttype Result struct {\\n\\t\\tLock       string\\n\\t\\tExpiration time.Time\\n\\t\\tToken      string\\n\\t}\\n\\tvar Results []Result\\n\\terr := tx.Raw(\\\"SELECT `\\\"+l.lockColumn+\\\"` AS `lock`, `\\\"+l.expireColumn+\\\"` AS `expiration`, `\\\"+l.tokenColumn+\\\"` AS `token` FROM \\\"+l.tableName+\\\" WHERE `\\\"+l.lockColumn+\\\"` IN (?)\\\", keys).Scan(&Results).Error\\n\\tif err != nil {\\n\\t\\treturn nil, nil, nil, errors.Wrap(err, \\\"fail to query locks\\\")\\n\\t}\\n\\n\\tvar needUpdateExpirationReadKeys []string = nil\\n\\tvar needUpdateCountReadKeys []string = nil\\n\\tl.mutex.Lock()\\n\\tt := time.Now()\\n\\tfor _, r := range Results {\\n\\t\\tif r.Token != lockTokens[0] {\\n\\t\\t\\tlockTokens = append(lockTokens, r.Token)\\n\\t\\t}\\n\\t\\tif readKey, exist := l.readKeysMemLock[r.Lock]; exist {\\n\\t\\t\\treadKey.count++\\n\\t\\t\\treadKey.expiration = r.Expiration\\n\\t\\t} else {\\n\\t\\t\\tl.readKeysMemLock[r.Lock] = &readKeysMemLock{\\n\\t\\t\\t\\tcount:      1,\\n\\t\\t\\t\\texpiration: r.Expiration,\\n\\t\\t\\t\\ttoken:      r.Token,\\n\\t\\t\\t}\\n\\t\\t\\tneedUpdateCountReadKeys = append(needUpdateCountReadKeys, r.Lock)\\n\\t\\t}\\n\\t\\tif l.readKeysMemLock[r.Lock].expiration.Sub(t) < ttl/3 {\\n\\t\\t\\tl.readKeysMemLock[r.Lock].expiration = t.Add(ttl)\\n\\t\\t\\tneedUpdateExpirationReadKeys = append(needUpdateExpirationReadKeys, r.Lock)\\n\\t\\t}\\n\\t}\\n\\tl.mutex.Unlock()\\n\\tif len(needUpdateExpirationReadKeys) > 0 {\\n\\t\\tresult := tx.Exec(\\\"UPDATE \\\"+l.tableName+\\\" SET \\\"+l.expireColumn+\\\" = NOW() + INTERVAL ? SECOND WHERE `\\\"+l.lockColumn+\\\"` IN (?)\\\", ttl.Seconds(), needUpdateExpirationReadKeys)\\n\\t\\tif result.Error != nil {\\n\\t\\t\\treturn nil, needUpdateExpirationReadKeys, needUpdateCountReadKeys, errors.Wrap(result.Error, fmt.Sprintf(\\\"failed to update readLocks: %s\\\", keys))\\n\\t\\t}\\n\\t}\\n\\n\\tif len(needUpdateCountReadKeys) > 0 {\\n\\t\\tresult := tx.Exec(\\\"UPDATE \\\"+l.tableName+\\\" SET \\\"+l.lockNumsColumn+\\\" = \\\"+l.lockNumsColumn+\\\" + 1 WHERE `\\\"+l.lockColumn+\\\"` IN (?)\\\", needUpdateCountReadKeys)\\n\\t\\tif result.Error != nil {\\n\\t\\t\\treturn nil, needUpdateExpirationReadKeys, needUpdateCountReadKeys, errors.Wrap(result.Error, fmt.Sprintf(\\\"failed to update readLocks: %s\\\", keys))\\n\\t\\t}\\n\\t}\\n\\n\\treturn nil, nil, lockTokens, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT `lock_column` AS `lock`, `expire_column` AS `expiration`, `token_column` AS `token` FROM table_name WHERE `lock_column` IN (?);\", {\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"需要更新过期时间的锁存在\", \"sql\": \"UPDATE table_name SET expire_column = NOW() + INTERVAL ? SECOND WHERE `lock_column` IN (?);\"}, {\"scenario\": \"不需要更新过期时间\", \"sql\": \"\"}]}, {\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"需要更新计数的锁存在\", \"sql\": \"UPDATE table_name SET lock_nums_column = lock_nums_column + 1 WHERE `lock_column` IN (?);\"}, {\"scenario\": \"不需要更新计数\", \"sql\": \"\"}]}]",
      "parsed_sql": [
        "SELECT `lock_column` AS `lock`, `expire_column` AS `expiration`, `token_column` AS `token` FROM table_name WHERE `lock_column` IN (?);",
        "UPDATE table_name SET expire_column = NOW() + INTERVAL ? SECOND WHERE `lock_column` IN (?);",
        "UPDATE table_name SET lock_nums_column = lock_nums_column + 1 WHERE `lock_column` IN (?);"
      ],
      "sql_evaluation": {
        "total_sql": 3,
        "valid_sql": 3,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT `lock_column` AS `lock`, `expire_column` AS `expiration`, `token_column` AS `token` FROM table_name WHERE `lock_column` IN (?);",
            "match_result": {
              "matched": false,
              "fingerprint": "e7e143a564d620172619045d86c21f1e",
              "excluded": false
            }
          },
          {
            "sql": "UPDATE table_name SET expire_column = NOW() + INTERVAL ? SECOND WHERE `lock_column` IN (?);",
            "match_result": {
              "matched": false,
              "fingerprint": "0493bafc6e00424b803e6824c5e38287",
              "excluded": false
            }
          },
          {
            "sql": "UPDATE table_name SET lock_nums_column = lock_nums_column + 1 WHERE `lock_column` IN (?);",
            "match_result": {
              "matched": false,
              "fingerprint": "0493bafc6e00424b803e6824c5e38287",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go:254:282:releaseReadLocks",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：releaseReadLocks\nfunc (l *mysqlLocker) releaseReadLocks(tx *gorm.DB, readLockKeys []string, tokens []string) error {\n\tvar needUpdateCountReadKeys []string = nil\n\tl.mutex.Lock()\n\tfor _, key := range readLockKeys {\n\t\tif readKey, exist := l.readKeysMemLock[key]; exist && containsString(tokens, readKey.token) {\n\t\t\treadKey.count--\n\t\t\tif readKey.count == 0 {\n\t\t\t\tdelete(l.readKeysMemLock, key)\n\t\t\t\tneedUpdateCountReadKeys = append(needUpdateCountReadKeys, key)\n\t\t\t}\n\t\t}\n\t}\n\tl.mutex.Unlock()\n\t// 批量更新\n\tif len(needUpdateCountReadKeys) > 0 {\n\t\tresult := tx.Exec(\"UPDATE \"+l.tableName+\" SET `\"+l.lockNumsColumn+\"` = `\"+l.lockNumsColumn+\"` - 1 WHERE `\"+l.lockColumn+\"` IN (?) AND `\"+l.tokenColumn+\"` IN (?)\", needUpdateCountReadKeys, tokens)\n\t\tif result.Error != nil {\n\t\t\treturn errors.Wrap(result.Error, fmt.Sprintf(\"failed to release readLocks: %s\", readLockKeys))\n\t\t}\n\n\t\t// 删除计数器为 0 的记录\n\t\tresult = tx.Exec(\"DELETE FROM \"+l.tableName+\" WHERE `\"+l.lockColumn+\"` IN (?) AND `\"+l.lockNumsColumn+\"` = 0\", needUpdateCountReadKeys)\n\t\tif result.Error != nil {\n\t\t\treturn errors.Wrap(result.Error, fmt.Sprintf(\"failed to release readLocks: %s\", readLockKeys))\n\t\t}\n\t}\n\n\treturn nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/test_utils/initdb.go\", \"code_start_line\": 53, \"code_end_line\": 58, \"code_key\": \"Release\", \"code_value\": \"func (p *dbPool) Release(idx int) {\\n\\tp.lock.Lock()\\n\\tdefer p.lock.Unlock()\\n\\tdelete(p.busyIdx, idx)\\n\\tp.freeIdx[idx] = struct{}{}\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go\",\n    \"code_start_line\": 254,\n    \"code_end_line\": 282,\n    \"code_key\": \"releaseReadLocks\",\n    \"code_value\": \"func (l *mysqlLocker) releaseReadLocks(tx *gorm.DB, readLockKeys []string, tokens []string) error {\\n\\tvar needUpdateCountReadKeys []string = nil\\n\\tl.mutex.Lock()\\n\\tfor _, key := range readLockKeys {\\n\\t\\tif readKey, exist := l.readKeysMemLock[key]; exist && containsString(tokens, readKey.token) {\\n\\t\\t\\treadKey.count--\\n\\t\\t\\tif readKey.count == 0 {\\n\\t\\t\\t\\tdelete(l.readKeysMemLock, key)\\n\\t\\t\\t\\tneedUpdateCountReadKeys = append(needUpdateCountReadKeys, key)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tl.mutex.Unlock()\\n\\t// 批量更新\\n\\tif len(needUpdateCountReadKeys) > 0 {\\n\\t\\tresult := tx.Exec(\\\"UPDATE \\\"+l.tableName+\\\" SET `\\\"+l.lockNumsColumn+\\\"` = `\\\"+l.lockNumsColumn+\\\"` - 1 WHERE `\\\"+l.lockColumn+\\\"` IN (?) AND `\\\"+l.tokenColumn+\\\"` IN (?)\\\", needUpdateCountReadKeys, tokens)\\n\\t\\tif result.Error != nil {\\n\\t\\t\\treturn errors.Wrap(result.Error, fmt.Sprintf(\\\"failed to release readLocks: %s\\\", readLockKeys))\\n\\t\\t}\\n\\n\\t\\t// 删除计数器为 0 的记录\\n\\t\\tresult = tx.Exec(\\\"DELETE FROM \\\"+l.tableName+\\\" WHERE `\\\"+l.lockColumn+\\\"` IN (?) AND `\\\"+l.lockNumsColumn+\\\"` = 0\\\", needUpdateCountReadKeys)\\n\\t\\tif result.Error != nil {\\n\\t\\t\\treturn errors.Wrap(result.Error, fmt.Sprintf(\\\"failed to release readLocks: %s\\\", readLockKeys))\\n\\t\\t}\\n\\t}\\n\\n\\treturn nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"needUpdateCountReadKeys为空时\", \"sql\": \"\"}, {\"scenario\": \"needUpdateCountReadKeys不为空时\", \"sql\": \"UPDATE ? SET `?` = `?` - 1 WHERE `?` IN (?) AND `?` IN (?); DELETE FROM ? WHERE `?` IN (?) AND `?` = 0;\"}]}]",
      "parsed_sql": [
        "UPDATE ? SET `?` = `?` - 1 WHERE `?` IN (?) AND `?` IN (?); DELETE FROM ? WHERE `?` IN (?) AND `?` = 0;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "UPDATE ? SET `?` = `?` - 1 WHERE `?` IN (?) AND `?` IN (?); DELETE FROM ? WHERE `?` IN (?) AND `?` = 0;",
            "match_result": {
              "matched": false,
              "fingerprint": "42f3a84398349c97773d080d9a742a3c",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go:295:306:deleteLocksByKeysAndToken",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：deleteLocksByKeysAndToken\nfunc (l *mysqlLocker) deleteLocksByKeysAndToken(tx *gorm.DB, keys []string, token []string) error {\n\tif len(keys) == 0 {\n\t\treturn nil\n\t}\n\n\tresult := tx.Exec(\"DELETE FROM \"+l.tableName+\" WHERE `\"+l.lockColumn+\"` IN (?) AND \"+l.tokenColumn+\" IN (?)\", keys, token)\n\tif result.Error != nil {\n\t\treturn errors.Wrap(result.Error, fmt.Sprintf(\"failed to delete specified locks: %s, token: %s\", keys, token))\n\t}\n\n\treturn nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/test_utils/initdb.go\", \"code_start_line\": 53, \"code_end_line\": 58, \"code_key\": \"Release\", \"code_value\": \"func (p *dbPool) Release(idx int) {\\n\\tp.lock.Lock()\\n\\tdefer p.lock.Unlock()\\n\\tdelete(p.busyIdx, idx)\\n\\tp.freeIdx[idx] = struct{}{}\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go\",\n    \"code_start_line\": 295,\n    \"code_end_line\": 306,\n    \"code_key\": \"deleteLocksByKeysAndToken\",\n    \"code_value\": \"func (l *mysqlLocker) deleteLocksByKeysAndToken(tx *gorm.DB, keys []string, token []string) error {\\n\\tif len(keys) == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tresult := tx.Exec(\\\"DELETE FROM \\\"+l.tableName+\\\" WHERE `\\\"+l.lockColumn+\\\"` IN (?) AND \\\"+l.tokenColumn+\\\" IN (?)\\\", keys, token)\\n\\tif result.Error != nil {\\n\\t\\treturn errors.Wrap(result.Error, fmt.Sprintf(\\\"failed to delete specified locks: %s, token: %s\\\", keys, token))\\n\\t}\\n\\n\\treturn nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"keys数组为空时\", \"sql\": \"\"}, {\"scenario\": \"keys数组非空时\", \"sql\": \"DELETE FROM {tableName} WHERE `{lockColumn}` IN (?) AND {tokenColumn} IN (?);\"}]}]",
      "parsed_sql": [
        "DELETE FROM {tableName} WHERE `{lockColumn}` IN (?) AND {tokenColumn} IN (?);"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 0,
        "matched_sql": 0,
        "excluded_sql": 1,
        "fingerprint_results": [
          {
            "sql": "DELETE FROM {tableName} WHERE `{lockColumn}` IN (?) AND {tokenColumn} IN (?);",
            "match_result": {
              "matched": false,
              "excluded": true,
              "fingerprint": "invalid_sql",
              "excluded_reason": "排除的SQL类型"
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go:309:332:updateLocksTTLByKeysAndTokens",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：updateLocksTTLByKeysAndTokens\nfunc (l *mysqlLocker) updateLocksTTLByKeysAndTokens(tx *gorm.DB, keys []string, tokens []string, ttl time.Duration) error {\n\tif len(keys) == 0 {\n\t\treturn nil\n\t}\n\n\tresult := tx.Exec(\"UPDATE \"+l.tableName+\" SET \"+l.expireColumn+\" = NOW() + INTERVAL ? SECOND WHERE `\"+l.lockColumn+\"` IN (?) AND \"+l.tokenColumn+\" IN (?)\", ttl.Seconds(), keys, tokens)\n\tif result.Error != nil {\n\t\treturn errors.Wrap(result.Error, fmt.Sprintf(\"failed to update locks ttl: %s, token: %s\", keys, tokens))\n\t}\n\n\tif result.RowsAffected != int64(len(keys)) {\n\t\t// If the number of rows affected is not equal to the number of keys, it means that the locks are not updated.\n\t\t// We should check if the locks are still held. If not, return an error.\n\t\t// NOCA:QCloudAkCheck(误报)\n\t\tif existingsKeys, err := l.fetchExistingLocksByKeysAndTokens(tx, keys, tokens); err != nil {\n\t\t\treturn err\n\t\t} else if checkStrSetEqual(existingsKeys, keys) {\n\t\t\treturn nil\n\t\t}\n\t\treturn errors.Wrap(dlock.ErrLockNotHeld, fmt.Sprintf(\"keys %v are not updated\", keys))\n\t}\n\n\treturn nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/tracker.go\", \"code_start_line\": 67, \"code_end_line\": 77, \"code_key\": \"Refresh\", \"code_value\": \"func (rdp *PhyDiskTracker) Refresh(ctx context.Context) {\\n\\trdp.Track(ctx)\\n\\tlock.RDPhyCacheGlobalLock.GetLocker(lock.RDPhyLockKeyGenerator{}).Lock()\\n\\trdp.Merge(ctx, rdp.OriPhyDisks)\\n\\tlogs.Info(ctx).\\n\\t\\tInt(\\\"disk_num\\\", len(rdp.ToCachedPhyDisks)).\\n\\t\\tInt(\\\"member_num\\\", len(rdp.DrgroupMembers)).\\n\\t\\tMsg(\\\"CACHE_AVAILABLE_PHY_DISK_AFTER_MERGE\\\")\\n\\trdp.CacheManager.RefreshCache(ctx, rdp.ToCachedPhyDisks, rdp.DrgroupMembers)\\n\\tlock.RDPhyCacheGlobalLock.GetLocker(lock.RDPhyLockKeyGenerator{}).Unlock()\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go\",\n    \"code_start_line\": 309,\n    \"code_end_line\": 332,\n    \"code_key\": \"updateLocksTTLByKeysAndTokens\",\n    \"code_value\": \"func (l *mysqlLocker) updateLocksTTLByKeysAndTokens(tx *gorm.DB, keys []string, tokens []string, ttl time.Duration) error {\\n\\tif len(keys) == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tresult := tx.Exec(\\\"UPDATE \\\"+l.tableName+\\\" SET \\\"+l.expireColumn+\\\" = NOW() + INTERVAL ? SECOND WHERE `\\\"+l.lockColumn+\\\"` IN (?) AND \\\"+l.tokenColumn+\\\" IN (?)\\\", ttl.Seconds(), keys, tokens)\\n\\tif result.Error != nil {\\n\\t\\treturn errors.Wrap(result.Error, fmt.Sprintf(\\\"failed to update locks ttl: %s, token: %s\\\", keys, tokens))\\n\\t}\\n\\n\\tif result.RowsAffected != int64(len(keys)) {\\n\\t\\t// If the number of rows affected is not equal to the number of keys, it means that the locks are not updated.\\n\\t\\t// We should check if the locks are still held. If not, return an error.\\n\\t\\t// NOCA:QCloudAkCheck(误报)\\n\\t\\tif existingsKeys, err := l.fetchExistingLocksByKeysAndTokens(tx, keys, tokens); err != nil {\\n\\t\\t\\treturn err\\n\\t\\t} else if checkStrSetEqual(existingsKeys, keys) {\\n\\t\\t\\treturn nil\\n\\t\\t}\\n\\t\\treturn errors.Wrap(dlock.ErrLockNotHeld, fmt.Sprintf(\\\"keys %v are not updated\\\", keys))\\n\\t}\\n\\n\\treturn nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"keys数组为空时\", \"sql\": \"\"}, {\"scenario\": \"keys数组非空时\", \"sql\": \"UPDATE {tableName} SET {expireColumn} = NOW() + INTERVAL ? SECOND WHERE `{lockColumn}` IN (?) AND {tokenColumn} IN (?);\"}]}]",
      "parsed_sql": [
        "UPDATE {tableName} SET {expireColumn} = NOW() + INTERVAL ? SECOND WHERE `{lockColumn}` IN (?) AND {tokenColumn} IN (?);"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 0,
        "matched_sql": 0,
        "excluded_sql": 1,
        "fingerprint_results": [
          {
            "sql": "UPDATE {tableName} SET {expireColumn} = NOW() + INTERVAL ? SECOND WHERE `{lockColumn}` IN (?) AND {tokenColumn} IN (?);",
            "match_result": {
              "matched": false,
              "excluded": true,
              "fingerprint": "invalid_sql",
              "excluded_reason": "排除的SQL类型"
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go:335:369:insertLocks",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：insertLocks\nfunc (l *mysqlLocker) insertLocks(tx *gorm.DB, lockKeys []*dlock.LockKey, ttl time.Duration, lockToken []string) ([]string, error) {\n\tif len(lockKeys) <= 0 {\n\t\treturn nil, nil\n\t}\n\tstmt := strings.Builder{}\n\targs := make([]interface{}, 0, len(lockKeys)*5)\n\tt := time.Now().Add(ttl)\n\tstmt.WriteString(fmt.Sprintf(\"INSERT INTO `%s` (`%s`, `%s`, `%s`, `%s`, `%s`) VALUES \", l.tableName, l.lockColumn, l.expireColumn, l.tokenColumn, l.lockTypeColumn, l.lockNumsColumn))\n\tfor i, key := range lockKeys {\n\t\tif i > 0 {\n\t\t\tstmt.WriteString(\", \")\n\t\t}\n\t\tstmt.WriteString(\"(?, NOW() + INTERVAL ? SECOND, ?, ?, ?)\")\n\t\targs = append(args, key.Key, ttl.Seconds(), lockToken[0], int(key.Type), 1)\n\t}\n\n\tresult := tx.Exec(stmt.String(), args...)\n\tif result.Error != nil {\n\t\treturn nil, errors.Wrap(result.Error, \"failed to insert locks\")\n\t}\n\tvar needInsertReadKeys []string = nil\n\tl.mutex.Lock()\n\tfor _, key := range lockKeys {\n\t\tif key.Type == dlock.ReadLock {\n\t\t\tl.readKeysMemLock[key.Key] = &readKeysMemLock{\n\t\t\t\tcount:      1,\n\t\t\t\texpiration: t,\n\t\t\t\ttoken:      lockToken[0],\n\t\t\t}\n\t\t\tneedInsertReadKeys = append(needInsertReadKeys, key.Key)\n\t\t}\n\t}\n\tl.mutex.Unlock()\n\treturn needInsertReadKeys, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go\", \"code_start_line\": 417, \"code_end_line\": 470, \"code_key\": \"tryObtainMulti\", \"code_value\": \"func (l *mysqlLocker) tryObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, tokens []string, opts *dlock.Option) ([]string, error) {\\n\\t// Starts a new transaction.\\n\\ttx := l.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\\n\\n\\t// Fetch existing locks.\\n\\texistingReadKeys, existingWriteKeys, expiredKeys, err := l.fetchExistingLocks(tx, keys)\\n\\tif err != nil {\\n\\t\\t_ = tx.Rollback()\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\t// If there are existing valid locks, return an error.\\n\\tif len(existingWriteKeys) > 0 {\\n\\t\\t_ = tx.Rollback()\\n\\t\\treturn nil, errors.Wrap(dlock.ErrLockNotHeld, fmt.Sprintf(\\\"writeKeys %v are already locked\\\", existingWriteKeys))\\n\\t}\\n\\n\\t// Delete expired locks if exists.\\n\\tif err := l.deleteExpiredLocks(tx, expiredKeys); err != nil {\\n\\t\\t_ = tx.Rollback()\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\t// Remove existing readLocks from insert.\\n\\t// NOCA:QCloudAkCheck(误报)\\n\\tlockKeys, err := l.removeExistingReadLocksFromInsert(tx, keys, existingReadKeys)\\n\\tif err != nil {\\n\\t\\t_ = tx.Rollback()\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\t// Insert locks into database.\\n\\tneedInsertReadKeys, err := l.insertLocks(tx, lockKeys, ttl, tokens)\\n\\tif err != nil {\\n\\t\\t_ = tx.Rollback()\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\t// Update readLocks.\\n\\tvar needUpdateExpirationReadKeys []string = nil\\n\\tvar needUpdateCountReadKeys []string = nil\\n\\tif needUpdateExpirationReadKeys, needUpdateCountReadKeys, tokens, err = l.updateReadLocks(tx, ttl, existingReadKeys, tokens); err != nil {\\n\\t\\tl.rollback(needUpdateCountReadKeys, tokens)\\n\\t\\tl.rollback(needUpdateExpirationReadKeys, tokens)\\n\\t\\tl.rollback(needInsertReadKeys, tokens)\\n\\t\\t_ = tx.Rollback()\\n\\t\\treturn nil, err\\n\\t}\\n\\tif result := tx.Commit(); result.Error != nil {\\n\\t\\treturn nil, errors.Wrap(result.Error, \\\"failed to commit transaction\\\")\\n\\t}\\n\\n\\treturn tokens, nil\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go\",\n    \"code_start_line\": 335,\n    \"code_end_line\": 369,\n    \"code_key\": \"insertLocks\",\n    \"code_value\": \"func (l *mysqlLocker) insertLocks(tx *gorm.DB, lockKeys []*dlock.LockKey, ttl time.Duration, lockToken []string) ([]string, error) {\\n\\tif len(lockKeys) <= 0 {\\n\\t\\treturn nil, nil\\n\\t}\\n\\tstmt := strings.Builder{}\\n\\targs := make([]interface{}, 0, len(lockKeys)*5)\\n\\tt := time.Now().Add(ttl)\\n\\tstmt.WriteString(fmt.Sprintf(\\\"INSERT INTO `%s` (`%s`, `%s`, `%s`, `%s`, `%s`) VALUES \\\", l.tableName, l.lockColumn, l.expireColumn, l.tokenColumn, l.lockTypeColumn, l.lockNumsColumn))\\n\\tfor i, key := range lockKeys {\\n\\t\\tif i > 0 {\\n\\t\\t\\tstmt.WriteString(\\\", \\\")\\n\\t\\t}\\n\\t\\tstmt.WriteString(\\\"(?, NOW() + INTERVAL ? SECOND, ?, ?, ?)\\\")\\n\\t\\targs = append(args, key.Key, ttl.Seconds(), lockToken[0], int(key.Type), 1)\\n\\t}\\n\\n\\tresult := tx.Exec(stmt.String(), args...)\\n\\tif result.Error != nil {\\n\\t\\treturn nil, errors.Wrap(result.Error, \\\"failed to insert locks\\\")\\n\\t}\\n\\tvar needInsertReadKeys []string = nil\\n\\tl.mutex.Lock()\\n\\tfor _, key := range lockKeys {\\n\\t\\tif key.Type == dlock.ReadLock {\\n\\t\\t\\tl.readKeysMemLock[key.Key] = &readKeysMemLock{\\n\\t\\t\\t\\tcount:      1,\\n\\t\\t\\t\\texpiration: t,\\n\\t\\t\\t\\ttoken:      lockToken[0],\\n\\t\\t\\t}\\n\\t\\t\\tneedInsertReadKeys = append(needInsertReadKeys, key.Key)\\n\\t\\t}\\n\\t}\\n\\tl.mutex.Unlock()\\n\\treturn needInsertReadKeys, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"lockKeys包含1个锁\", \"sql\": \"INSERT INTO `{tableName}` (`{lockColumn}`, `{expireColumn}`, `{tokenColumn}`, `{lockTypeColumn}`, `{lockNumsColumn}`) VALUES (?, NOW() + INTERVAL ? SECOND, ?, ?, ?);\"}, {\"scenario\": \"lockKeys包含2个锁\", \"sql\": \"INSERT INTO `{tableName}` (`{lockColumn}`, `{expireColumn}`, `{tokenColumn}`, `{lockTypeColumn}`, `{lockNumsColumn}`) VALUES (?, NOW() + INTERVAL ? SECOND, ?, ?, ?), (?, NOW() + INTERVAL ? SECOND, ?, ?, ?);\"}, {\"scenario\": \"lockKeys包含3个锁\", \"sql\": \"INSERT INTO `{tableName}` (`{lockColumn}`, `{expireColumn}`, `{tokenColumn}`, `{lockTypeColumn}`, `{lockNumsColumn}`) VALUES (?, NOW() + INTERVAL ? SECOND, ?, ?, ?), (?, NOW() + INTERVAL ? SECOND, ?, ?, ?), (?, NOW() + INTERVAL ? SECOND, ?, ?, ?);\"}]}]",
      "parsed_sql": [
        "INSERT INTO `{tableName}` (`{lockColumn}`, `{expireColumn}`, `{tokenColumn}`, `{lockTypeColumn}`, `{lockNumsColumn}`) VALUES (?, NOW() + INTERVAL ? SECOND, ?, ?, ?);",
        "INSERT INTO `{tableName}` (`{lockColumn}`, `{expireColumn}`, `{tokenColumn}`, `{lockTypeColumn}`, `{lockNumsColumn}`) VALUES (?, NOW() + INTERVAL ? SECOND, ?, ?, ?), (?, NOW() + INTERVAL ? SECOND, ?, ?, ?);",
        "INSERT INTO `{tableName}` (`{lockColumn}`, `{expireColumn}`, `{tokenColumn}`, `{lockTypeColumn}`, `{lockNumsColumn}`) VALUES (?, NOW() + INTERVAL ? SECOND, ?, ?, ?), (?, NOW() + INTERVAL ? SECOND, ?, ?, ?), (?, NOW() + INTERVAL ? SECOND, ?, ?, ?);"
      ],
      "sql_evaluation": {
        "total_sql": 3,
        "valid_sql": 3,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "INSERT INTO `{tableName}` (`{lockColumn}`, `{expireColumn}`, `{tokenColumn}`, `{lockTypeColumn}`, `{lockNumsColumn}`) VALUES (?, NOW() + INTERVAL ? SECOND, ?, ?, ?);",
            "match_result": {
              "matched": false,
              "fingerprint": "508c6c7cccc37e20902a81fe34c56cba",
              "excluded": false
            }
          },
          {
            "sql": "INSERT INTO `{tableName}` (`{lockColumn}`, `{expireColumn}`, `{tokenColumn}`, `{lockTypeColumn}`, `{lockNumsColumn}`) VALUES (?, NOW() + INTERVAL ? SECOND, ?, ?, ?), (?, NOW() + INTERVAL ? SECOND, ?, ?, ?);",
            "match_result": {
              "matched": false,
              "fingerprint": "508c6c7cccc37e20902a81fe34c56cba",
              "excluded": false
            }
          },
          {
            "sql": "INSERT INTO `{tableName}` (`{lockColumn}`, `{expireColumn}`, `{tokenColumn}`, `{lockTypeColumn}`, `{lockNumsColumn}`) VALUES (?, NOW() + INTERVAL ? SECOND, ?, ?, ?), (?, NOW() + INTERVAL ? SECOND, ?, ?, ?), (?, NOW() + INTERVAL ? SECOND, ?, ?, ?);",
            "match_result": {
              "matched": false,
              "fingerprint": "508c6c7cccc37e20902a81fe34c56cba",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go:417:470:tryObtainMulti",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：tryObtainMulti\nfunc (l *mysqlLocker) tryObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, tokens []string, opts *dlock.Option) ([]string, error) {\n\t// Starts a new transaction.\n\ttx := l.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\n\n\t// Fetch existing locks.\n\texistingReadKeys, existingWriteKeys, expiredKeys, err := l.fetchExistingLocks(tx, keys)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// If there are existing valid locks, return an error.\n\tif len(existingWriteKeys) > 0 {\n\t\t_ = tx.Rollback()\n\t\treturn nil, errors.Wrap(dlock.ErrLockNotHeld, fmt.Sprintf(\"writeKeys %v are already locked\", existingWriteKeys))\n\t}\n\n\t// Delete expired locks if exists.\n\tif err := l.deleteExpiredLocks(tx, expiredKeys); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Remove existing readLocks from insert.\n\t// NOCA:QCloudAkCheck(误报)\n\tlockKeys, err := l.removeExistingReadLocksFromInsert(tx, keys, existingReadKeys)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Insert locks into database.\n\tneedInsertReadKeys, err := l.insertLocks(tx, lockKeys, ttl, tokens)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Update readLocks.\n\tvar needUpdateExpirationReadKeys []string = nil\n\tvar needUpdateCountReadKeys []string = nil\n\tif needUpdateExpirationReadKeys, needUpdateCountReadKeys, tokens, err = l.updateReadLocks(tx, ttl, existingReadKeys, tokens); err != nil {\n\t\tl.rollback(needUpdateCountReadKeys, tokens)\n\t\tl.rollback(needUpdateExpirationReadKeys, tokens)\n\t\tl.rollback(needInsertReadKeys, tokens)\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\tif result := tx.Commit(); result.Error != nil {\n\t\treturn nil, errors.Wrap(result.Error, \"failed to commit transaction\")\n\t}\n\n\treturn tokens, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go\", \"code_start_line\": 473, \"code_end_line\": 520, \"code_key\": \"ObtainMulti\", \"code_value\": \"func (l *mysqlLocker) ObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, opts *dlock.Option) (dlock.Lock, error) {\\n\\tif len(keys) == 0 {\\n\\t\\treturn nil, errors.New(\\\"keys cannot be empty\\\")\\n\\t}\\n\\tkeys = dedupAndSort(keys)\\n\\n\\t// Get the lock token.\\n\\tlockToken, err := l.getOrCreateLockToken(opts)\\n\\tif err != nil {\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\tretryStrategy := dlock.NoRetry()\\n\\tif opts != nil && opts.RetryStrategy != nil {\\n\\t\\tretryStrategy = opts.RetryStrategy\\n\\t}\\n\\n\\tretries := 0\\n\\tlogger := logs.GetLogger(ctx).With().Strs(\\\"keys\\\", dlock.LockKeySlice(keys).GetKeys()).Strs(\\\"tokens\\\", lockToken).Logger()\\n\\n\\tfor {\\n\\t\\t// Try to obtain the locks.\\n\\t\\t// If the locks are not obtained, retry based on the retry strategy.\\n\\t\\tif tokens, err := l.tryObtainMulti(ctx, keys, ttl, lockToken, opts); err != nil {\\n\\t\\t\\t// If context is canceled, return immediately.\\n\\t\\t\\tif ctx.Err() != nil {\\n\\t\\t\\t\\treturn nil, errors.Wrap(dlock.ErrNotObtained, \\\"context is canceled\\\")\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If the lock is not obtained, retry.\\n\\t\\t\\twaitDuration := retryStrategy.NextBackoff()\\n\\t\\t\\tif waitDuration <= 0 {\\n\\t\\t\\t\\tlogger.Debug().Int(\\\"retry\\\", retries).Msg(\\\"stop retrying lock\\\")\\n\\t\\t\\t\\treturn nil, err\\n\\t\\t\\t}\\n\\t\\t\\tlogger.Debug().Int(\\\"retry\\\", retries).Msg(\\\"retry obtaining lock\\\")\\n\\t\\t\\ttime.Sleep(waitDuration)\\n\\t\\t} else {\\n\\t\\t\\tlockToken = tokens\\n\\t\\t\\tlogger.Debug().Msg(\\\"lock obtained\\\")\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\t// TODO xuanzeng: 这里采用内部记录 TTL 的方式，可能和底层的数据库时间不同步，后续应该从数据库中获取过期时间。\\n\\tlock := &mysqlLock{keys: keys, locker: l, tokens: lockToken, expiration: time.Now().Add(ttl)}\\n\\treturn lock, nil\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go\",\n    \"code_start_line\": 417,\n    \"code_end_line\": 470,\n    \"code_key\": \"tryObtainMulti\",\n    \"code_value\": \"func (l *mysqlLocker) tryObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, tokens []string, opts *dlock.Option) ([]string, error) {\\n\\t// Starts a new transaction.\\n\\ttx := l.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\\n\\n\\t// Fetch existing locks.\\n\\texistingReadKeys, existingWriteKeys, expiredKeys, err := l.fetchExistingLocks(tx, keys)\\n\\tif err != nil {\\n\\t\\t_ = tx.Rollback()\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\t// If there are existing valid locks, return an error.\\n\\tif len(existingWriteKeys) > 0 {\\n\\t\\t_ = tx.Rollback()\\n\\t\\treturn nil, errors.Wrap(dlock.ErrLockNotHeld, fmt.Sprintf(\\\"writeKeys %v are already locked\\\", existingWriteKeys))\\n\\t}\\n\\n\\t// Delete expired locks if exists.\\n\\tif err := l.deleteExpiredLocks(tx, expiredKeys); err != nil {\\n\\t\\t_ = tx.Rollback()\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\t// Remove existing readLocks from insert.\\n\\t// NOCA:QCloudAkCheck(误报)\\n\\tlockKeys, err := l.removeExistingReadLocksFromInsert(tx, keys, existingReadKeys)\\n\\tif err != nil {\\n\\t\\t_ = tx.Rollback()\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\t// Insert locks into database.\\n\\tneedInsertReadKeys, err := l.insertLocks(tx, lockKeys, ttl, tokens)\\n\\tif err != nil {\\n\\t\\t_ = tx.Rollback()\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\t// Update readLocks.\\n\\tvar needUpdateExpirationReadKeys []string = nil\\n\\tvar needUpdateCountReadKeys []string = nil\\n\\tif needUpdateExpirationReadKeys, needUpdateCountReadKeys, tokens, err = l.updateReadLocks(tx, ttl, existingReadKeys, tokens); err != nil {\\n\\t\\tl.rollback(needUpdateCountReadKeys, tokens)\\n\\t\\tl.rollback(needUpdateExpirationReadKeys, tokens)\\n\\t\\tl.rollback(needInsertReadKeys, tokens)\\n\\t\\t_ = tx.Rollback()\\n\\t\\treturn nil, err\\n\\t}\\n\\tif result := tx.Commit(); result.Error != nil {\\n\\t\\treturn nil, errors.Wrap(result.Error, \\\"failed to commit transaction\\\")\\n\\t}\\n\\n\\treturn tokens, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT * FROM lock_table WHERE key IN (?) AND status = ?;\", \"DELETE FROM lock_table WHERE key IN (?) AND status = ?;\", \"INSERT INTO lock_table (key, token, expiration, status) VALUES (?, ?, ?, ?);\", \"UPDATE lock_table SET token = ?, expiration = ? WHERE key IN (?) AND status = ?;\"]",
      "parsed_sql": [
        "SELECT * FROM lock_table WHERE key IN (?) AND status = ?;",
        "DELETE FROM lock_table WHERE key IN (?) AND status = ?;",
        "INSERT INTO lock_table (key, token, expiration, status) VALUES (?, ?, ?, ?);",
        "UPDATE lock_table SET token = ?, expiration = ? WHERE key IN (?) AND status = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 4,
        "valid_sql": 0,
        "matched_sql": 0,
        "excluded_sql": 4,
        "fingerprint_results": [
          {
            "sql": "SELECT * FROM lock_table WHERE key IN (?) AND status = ?;",
            "match_result": {
              "matched": false,
              "excluded": true,
              "fingerprint": "invalid_sql",
              "excluded_reason": "排除的SQL类型"
            }
          },
          {
            "sql": "DELETE FROM lock_table WHERE key IN (?) AND status = ?;",
            "match_result": {
              "matched": false,
              "excluded": true,
              "fingerprint": "invalid_sql",
              "excluded_reason": "排除的SQL类型"
            }
          },
          {
            "sql": "INSERT INTO lock_table (key, token, expiration, status) VALUES (?, ?, ?, ?);",
            "match_result": {
              "matched": false,
              "excluded": true,
              "fingerprint": "invalid_sql",
              "excluded_reason": "排除的SQL类型"
            }
          },
          {
            "sql": "UPDATE lock_table SET token = ?, expiration = ? WHERE key IN (?) AND status = ?;",
            "match_result": {
              "matched": false,
              "excluded": true,
              "fingerprint": "invalid_sql",
              "excluded_reason": "排除的SQL类型"
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go:528:552:Cleanup",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：Cleanup\nfunc (l *mysqlLocker) Cleanup(ctx context.Context, opts *dlock.CleanupOption) error {\n\t// Apply default options if not provided.\n\tif opts == nil {\n\t\topts = defaultCleanupOption\n\t} else {\n\t\tif opts.MaxCount <= 0 {\n\t\t\topts.MaxCount = defaultCleanupOption.MaxCount\n\t\t}\n\t\tif opts.TimeAfterExpire <= 0 {\n\t\t\topts.TimeAfterExpire = defaultCleanupOption.TimeAfterExpire\n\t\t}\n\t}\n\n\treturn l.db.Transaction(func(tx *gorm.DB) error {\n\t\t// The order is important, we need to make sure that delete order is the same as the obtain order.\n\t\t// Otherwise deadlock may happen.\n\t\tresult := tx.Exec(\"DELETE FROM \"+l.tableName+\" WHERE \"+l.lockNumsColumn+\" = 0 ORDER BY `\"+l.lockColumn+\"` ASC LIMIT ?\", opts.MaxCount)\n\t\tif result.Error != nil {\n\t\t\treturn result.Error\n\t\t}\n\t\tresult = tx.Exec(\"DELETE FROM \"+l.tableName+\" WHERE \"+l.expireColumn+\" < NOW() - INTERVAL ? SECOND ORDER BY `\"+l.lockColumn+\"` ASC LIMIT ?\", opts.TimeAfterExpire.Seconds(), opts.MaxCount)\n\t\treturn result.Error\n\n\t}, &sql.TxOptions{Isolation: sql.LevelRepeatableRead})\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go\",\n    \"code_start_line\": 528,\n    \"code_end_line\": 552,\n    \"code_key\": \"Cleanup\",\n    \"code_value\": \"func (l *mysqlLocker) Cleanup(ctx context.Context, opts *dlock.CleanupOption) error {\\n\\t// Apply default options if not provided.\\n\\tif opts == nil {\\n\\t\\topts = defaultCleanupOption\\n\\t} else {\\n\\t\\tif opts.MaxCount <= 0 {\\n\\t\\t\\topts.MaxCount = defaultCleanupOption.MaxCount\\n\\t\\t}\\n\\t\\tif opts.TimeAfterExpire <= 0 {\\n\\t\\t\\topts.TimeAfterExpire = defaultCleanupOption.TimeAfterExpire\\n\\t\\t}\\n\\t}\\n\\n\\treturn l.db.Transaction(func(tx *gorm.DB) error {\\n\\t\\t// The order is important, we need to make sure that delete order is the same as the obtain order.\\n\\t\\t// Otherwise deadlock may happen.\\n\\t\\tresult := tx.Exec(\\\"DELETE FROM \\\"+l.tableName+\\\" WHERE \\\"+l.lockNumsColumn+\\\" = 0 ORDER BY `\\\"+l.lockColumn+\\\"` ASC LIMIT ?\\\", opts.MaxCount)\\n\\t\\tif result.Error != nil {\\n\\t\\t\\treturn result.Error\\n\\t\\t}\\n\\t\\tresult = tx.Exec(\\\"DELETE FROM \\\"+l.tableName+\\\" WHERE \\\"+l.expireColumn+\\\" < NOW() - INTERVAL ? SECOND ORDER BY `\\\"+l.lockColumn+\\\"` ASC LIMIT ?\\\", opts.TimeAfterExpire.Seconds(), opts.MaxCount)\\n\\t\\treturn result.Error\\n\\n\\t}, &sql.TxOptions{Isolation: sql.LevelRepeatableRead})\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"删除锁数量为0的记录\", \"sql\": \"DELETE FROM {tableName} WHERE {lockNumsColumn} = 0 ORDER BY `{lockColumn}` ASC LIMIT ?;\"}, {\"scenario\": \"删除过期时间的记录\", \"sql\": \"DELETE FROM {tableName} WHERE {expireColumn} < NOW() - INTERVAL ? SECOND ORDER BY `{lockColumn}` ASC LIMIT ?;\"}]}]",
      "parsed_sql": [
        "DELETE FROM {tableName} WHERE {lockNumsColumn} = 0 ORDER BY `{lockColumn}` ASC LIMIT ?;",
        "DELETE FROM {tableName} WHERE {expireColumn} < NOW() - INTERVAL ? SECOND ORDER BY `{lockColumn}` ASC LIMIT ?;"
      ],
      "sql_evaluation": {
        "total_sql": 2,
        "valid_sql": 0,
        "matched_sql": 0,
        "excluded_sql": 2,
        "fingerprint_results": [
          {
            "sql": "DELETE FROM {tableName} WHERE {lockNumsColumn} = 0 ORDER BY `{lockColumn}` ASC LIMIT ?;",
            "match_result": {
              "matched": false,
              "excluded": true,
              "fingerprint": "invalid_sql",
              "excluded_reason": "排除的SQL类型"
            }
          },
          {
            "sql": "DELETE FROM {tableName} WHERE {expireColumn} < NOW() - INTERVAL ? SECOND ORDER BY `{lockColumn}` ASC LIMIT ?;",
            "match_result": {
              "matched": false,
              "excluded": true,
              "fingerprint": "invalid_sql",
              "excluded_reason": "排除的SQL类型"
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go:555:588:Observe",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：Observe\nfunc (l *mysqlLocker) Observe(ctx context.Context, key string) (*dlock.LockView, error) {\n\n\tvar view dlock.LockView\n\tvar result struct {\n\t\tName   string\n\t\tExpire time.Time\n\t\tToken  string\n\t\tNums   int\n\t\tType   int\n\t}\n\n\terr := l.db.Transaction(func(tx *gorm.DB) error {\n\t\top := tx.Raw(\"SELECT `\"+l.lockColumn+\"` AS name, `\"+l.expireColumn+\"` AS expire, `\"+l.tokenColumn+\"` AS token, `\"+l.lockTypeColumn+\"` AS type, `\"+l.lockNumsColumn+\"` AS nums FROM \"+l.tableName+\" WHERE `\"+l.lockColumn+\"` = ? AND `\"+l.expireColumn+\"` > NOW() LIMIT 1\", key).Scan(&result)\n\t\tif op.Error != nil {\n\t\t\treturn op.Error\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif result.Name == \"\" {\n\t\treturn nil, errors.Errorf(\"lock not found for key %s\", key)\n\t}\n\n\tview.Key = result.Name\n\tview.TTL = time.Until(result.Expire)\n\tview.Token = result.Token\n\tview.Nums = result.Nums\n\tview.Type = dlock.LockType(result.Type)\n\n\treturn &view, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：{\"code_file\": \"/Users/freedom/llms/singularity/internal/scheduler/internal/core/convertor.go\", \"code_start_line\": 28, \"code_end_line\": 38, \"code_key\": \"Start\", \"code_value\": \"func (a *Convertor) Start(ctx context.Context) error {\\n\\t// 启动转换器\\n\\tfor _, scanner := range a.scanners {\\n\\t\\tscanner := scanner\\n\\t\\tgo func() {\\n\\t\\t\\ta.convertToTask(ctx, scanner)\\n\\t\\t}()\\n\\t}\\n\\tlogs.Info(ctx).Msgf(\\\"Convertor Start Success\\\")\\n\\treturn nil\\n}\", \"code_label\": 4, \"code_type\": 2, \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"}\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go\",\n    \"code_start_line\": 555,\n    \"code_end_line\": 588,\n    \"code_key\": \"Observe\",\n    \"code_value\": \"func (l *mysqlLocker) Observe(ctx context.Context, key string) (*dlock.LockView, error) {\\n\\n\\tvar view dlock.LockView\\n\\tvar result struct {\\n\\t\\tName   string\\n\\t\\tExpire time.Time\\n\\t\\tToken  string\\n\\t\\tNums   int\\n\\t\\tType   int\\n\\t}\\n\\n\\terr := l.db.Transaction(func(tx *gorm.DB) error {\\n\\t\\top := tx.Raw(\\\"SELECT `\\\"+l.lockColumn+\\\"` AS name, `\\\"+l.expireColumn+\\\"` AS expire, `\\\"+l.tokenColumn+\\\"` AS token, `\\\"+l.lockTypeColumn+\\\"` AS type, `\\\"+l.lockNumsColumn+\\\"` AS nums FROM \\\"+l.tableName+\\\" WHERE `\\\"+l.lockColumn+\\\"` = ? AND `\\\"+l.expireColumn+\\\"` > NOW() LIMIT 1\\\", key).Scan(&result)\\n\\t\\tif op.Error != nil {\\n\\t\\t\\treturn op.Error\\n\\t\\t}\\n\\t\\treturn nil\\n\\t})\\n\\tif err != nil {\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\tif result.Name == \\\"\\\" {\\n\\t\\treturn nil, errors.Errorf(\\\"lock not found for key %s\\\", key)\\n\\t}\\n\\n\\tview.Key = result.Name\\n\\tview.TTL = time.Until(result.Expire)\\n\\tview.Token = result.Token\\n\\tview.Nums = result.Nums\\n\\tview.Type = dlock.LockType(result.Type)\\n\\n\\treturn &view, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[\"SELECT `lock_column` AS name, `expire_column` AS expire, `token_column` AS token, `lock_type_column` AS type, `lock_nums_column` AS nums FROM table_name WHERE `lock_column` = ? AND `expire_column` > NOW() LIMIT 1;\"]",
      "parsed_sql": [
        "SELECT `lock_column` AS name, `expire_column` AS expire, `token_column` AS token, `lock_type_column` AS type, `lock_nums_column` AS nums FROM table_name WHERE `lock_column` = ? AND `expire_column` > NOW() LIMIT 1;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT `lock_column` AS name, `expire_column` AS expire, `token_column` AS token, `lock_type_column` AS type, `lock_nums_column` AS nums FROM table_name WHERE `lock_column` = ? AND `expire_column` > NOW() LIMIT 1;",
            "match_result": {
              "matched": false,
              "fingerprint": "18bc90645a3ee78186882c84c757d69f",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go:719:737:TTLs",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：TTLs\nfunc (l *mysqlLock) TTLs(ctx context.Context) ([]time.Duration, error) {\n\tkeysKey := dlock.LockKeySlice(l.keys).GetKeys()\n\tvar expirations []time.Time\n\tvar results []time.Duration\n\terr := l.locker.db.Transaction(func(tx *gorm.DB) error {\n\t\top := tx.Raw(\"SELECT `\"+l.locker.expireColumn+\"` AS `expiration` FROM \"+l.locker.tableName+\" WHERE `\"+l.locker.lockColumn+\"` = ?\", keysKey).Scan(&expirations)\n\t\tif op.Error != nil {\n\t\t\treturn op.Error\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor _, expiration := range expirations {\n\t\tresults = append(results, time.Until(expiration))\n\t}\n\treturn results, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go\",\n    \"code_start_line\": 719,\n    \"code_end_line\": 737,\n    \"code_key\": \"TTLs\",\n    \"code_value\": \"func (l *mysqlLock) TTLs(ctx context.Context) ([]time.Duration, error) {\\n\\tkeysKey := dlock.LockKeySlice(l.keys).GetKeys()\\n\\tvar expirations []time.Time\\n\\tvar results []time.Duration\\n\\terr := l.locker.db.Transaction(func(tx *gorm.DB) error {\\n\\t\\top := tx.Raw(\\\"SELECT `\\\"+l.locker.expireColumn+\\\"` AS `expiration` FROM \\\"+l.locker.tableName+\\\" WHERE `\\\"+l.locker.lockColumn+\\\"` = ?\\\", keysKey).Scan(&expirations)\\n\\t\\tif op.Error != nil {\\n\\t\\t\\treturn op.Error\\n\\t\\t}\\n\\t\\treturn nil\\n\\t})\\n\\tif err != nil {\\n\\t\\treturn nil, err\\n\\t}\\n\\tfor _, expiration := range expirations {\\n\\t\\tresults = append(results, time.Until(expiration))\\n\\t}\\n\\treturn results, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"transaction with raw query\", \"sql\": \"SELECT `expire_column` AS `expiration` FROM table_name WHERE `lock_column` = ?;\"}]}]",
      "parsed_sql": [
        "SELECT `expire_column` AS `expiration` FROM table_name WHERE `lock_column` = ?;"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT `expire_column` AS `expiration` FROM table_name WHERE `lock_column` = ?;",
            "match_result": {
              "matched": false,
              "fingerprint": "e7e143a564d620172619045d86c21f1e",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go:740:753:Num",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：Num\nfunc (l *mysqlLock) Num(ctx context.Context) (int, error) {\n\tvar results int\n\terr := l.locker.db.Transaction(func(tx *gorm.DB) error {\n\t\top := tx.Raw(\"SELECT `\"+l.locker.lockNumsColumn+\"` AS `num` FROM \"+l.locker.tableName+\" WHERE `\"+l.locker.lockColumn+\"` IN (?)\", l.keys[0].Key).Scan(&results)\n\t\tif op.Error != nil {\n\t\t\treturn op.Error\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\treturn results, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go\",\n    \"code_start_line\": 740,\n    \"code_end_line\": 753,\n    \"code_key\": \"Num\",\n    \"code_value\": \"func (l *mysqlLock) Num(ctx context.Context) (int, error) {\\n\\tvar results int\\n\\terr := l.locker.db.Transaction(func(tx *gorm.DB) error {\\n\\t\\top := tx.Raw(\\\"SELECT `\\\"+l.locker.lockNumsColumn+\\\"` AS `num` FROM \\\"+l.locker.tableName+\\\" WHERE `\\\"+l.locker.lockColumn+\\\"` IN (?)\\\", l.keys[0].Key).Scan(&results)\\n\\t\\tif op.Error != nil {\\n\\t\\t\\treturn op.Error\\n\\t\\t}\\n\\t\\treturn nil\\n\\t})\\n\\tif err != nil {\\n\\t\\treturn -1, err\\n\\t}\\n\\treturn results, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"transaction with raw query\", \"sql\": \"SELECT `lock_nums_column` AS `num` FROM `tableName` WHERE `lockColumn` IN (?);\"}]}]",
      "parsed_sql": [
        "SELECT `lock_nums_column` AS `num` FROM `tableName` WHERE `lockColumn` IN (?);"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT `lock_nums_column` AS `num` FROM `tableName` WHERE `lockColumn` IN (?);",
            "match_result": {
              "matched": false,
              "fingerprint": "47b13dfdacc345d9bd9545bbbea4b512",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    },
    {
      "sample_id": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go:756:770:Nums",
      "prompt": "请基于以下分析要求，直接输出GORM代码对应的SQL语句JSON格式结果：\n\n**首要判断：SQL生成有效性**\n在开始分析前，请判断给定的ORM代码是否真的会生成SQL语句：\n- 代码必须包含实际的数据库操作方法（Find、Create、Update、Delete、Count、First等）\n- 仅有查询构建方法（Where、Select、Join等）而没有执行方法的代码不会生成SQL\n- 如果代码不会生成任何SQL，请返回空数组[]\n\n**分析步骤：**\n1. **识别表名和字段映射**：\n   **表名优先级：**\n   · 元数据中TableName()函数显式返回值（最高优先级）\n   · 配置文件中的表名映射（const常量、type定义等）\n   · 代码中直接写出的表名（如Table(\"user_info\")）- 必须原样保留\n   · 默认命名规则：驼峰转下划线，严禁自动复数化（UserInfo→user_info，不是user_infos）\n   \n   **字段名优先级：**\n   · 结构体tag中的column标签（如gorm:\"column:user_name\"）\n   · 配置文件中的字段映射\n   · 代码中直接写出的字段名（如Where(\"user_id = ?\")）- 必须原样保留\n   · 默认转换：驼峰转下划线（UserName→user_name）\n\n2. **处理JOIN操作和表别名**：\n   · 主表使用简短别名，关联表使用有意义的别名\n   · SELECT、WHERE、ORDER BY、GROUP BY、HAVING子句中的所有列名必须带表别名前缀\n   · ON条件必须使用完整格式：`ON t1.foreign_key = t2.primary_key`\n   · 确保避免列名歧义，保持表别名一致性\n\n3. **枚举所有可能的SQL结构**：\n   · **忽略注释代码**：完全忽略//和/* */注释中的所有代码\n   · 分析所有可能的WHERE条件字段组合（单条件、多条件AND、OR组合）\n   · 考虑动态条件构建（if判断、循环遍历、switch分支等）\n   · 识别GORM特性影响（关联查询、作用域、事务、软删/硬删等）\n   · DELETE操作需包含显式Where条件＋主键自动条件\n\n4. **上下文约束分析**（根据提供的信息进行）：\n   · 如果提供调用者信息：只分析当前调用者触发的执行路径，排除其他独立路径\n   · 如果提供被调用者信息：考虑内部调用可能产生的额外SQL操作\n   · 如果信息不完整：基于现有信息进行最佳推断，但不臆测缺失部分\n\n5. **生成标准SQL语句**：\n   · 确保SQL完整可执行，参数用?占位\n   · 不含省略号或[其他字段]等占位符\n   · 每条SQL以分号结尾\n   · 同结构SQL仅保留一条代表性模板\n\n**输出格式要求：**\n输出标准JSON数组，结构如下：\n[\n  \"固定SQL语句;\",\n  {\n    \"type\": \"param_dependent\",\n    \"variants\": [\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"},\n      {\"scenario\": \"条件描述\", \"sql\": \"完整SQL语句;\"}\n    ]\n  },\n  \"另一个固定SQL;\"\n]\n\n**严格要求：**\n- 仅输出纯JSON数组，无其他文字说明\n- SQL语句必须完整可执行，以分号结尾\n- 不含省略号、占位符或解释性文本\n- 参数使用问号(?)表示\n- 只有SQL结构不同才视为不同变体\n\n**分析目标代码：**\n函数名称：Nums\nfunc (l *mysqlLock) Nums(ctx context.Context) ([]int, error) {\n\tkeysKey := dlock.LockKeySlice(l.keys).GetKeys()\n\tvar results []int\n\terr := l.locker.db.Transaction(func(tx *gorm.DB) error {\n\t\top := tx.Raw(\"SELECT `\"+l.locker.lockNumsColumn+\"` AS `num` FROM \"+l.locker.tableName+\" WHERE `\"+l.locker.lockColumn+\"` IN (?)\", keysKey).Scan(&results)\n\t\tif op.Error != nil {\n\t\t\treturn op.Error\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}\n\n**元数据信息：**\n以下元数据信息可能包含表名和列名的关键信息，请根据实际提供的内容进行分析：\n\n· **表结构信息**（如提供）：数据库表的定义、字段标签、主键信息等，用于确定准确的表名和字段名\n· **调用者代码**（如提供）：上层函数的调用方式、传递参数、业务条件等，用于限定执行路径\n· **被调用者代码**（如提供）：内部调用的函数、嵌套查询、回调方法等，可能产生额外SQL\n\n**注意**：如果某类信息未提供，请基于ORM代码本身和已有信息进行分析，不要为缺失信息创造假设。\n\n调用者：\n元数据：[\n  {\n    \"code_file\": \"/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go\",\n    \"code_start_line\": 756,\n    \"code_end_line\": 770,\n    \"code_key\": \"Nums\",\n    \"code_value\": \"func (l *mysqlLock) Nums(ctx context.Context) ([]int, error) {\\n\\tkeysKey := dlock.LockKeySlice(l.keys).GetKeys()\\n\\tvar results []int\\n\\terr := l.locker.db.Transaction(func(tx *gorm.DB) error {\\n\\t\\top := tx.Raw(\\\"SELECT `\\\"+l.locker.lockNumsColumn+\\\"` AS `num` FROM \\\"+l.locker.tableName+\\\" WHERE `\\\"+l.locker.lockColumn+\\\"` IN (?)\\\", keysKey).Scan(&results)\\n\\t\\tif op.Error != nil {\\n\\t\\t\\treturn op.Error\\n\\t\\t}\\n\\t\\treturn nil\\n\\t})\\n\\tif err != nil {\\n\\t\\treturn nil, err\\n\\t}\\n\\treturn results, nil\\n}\",\n    \"code_label\": 2,\n    \"code_type\": 2,\n    \"code_version\": \"7a6ce9d47c30a5bf582db3b759442d236a89c6c6\"\n  }\n]\n被调用者：\n**最终要求：仅输出纯JSON数组，无其他文字说明。**",
      "response": "[{\"type\": \"param_dependent\", \"variants\": [{\"scenario\": \"transaction with raw query\", \"sql\": \"SELECT `lock_nums_column` AS `num` FROM `tableName` WHERE `lockColumn` IN (?);\"}]}]",
      "parsed_sql": [
        "SELECT `lock_nums_column` AS `num` FROM `tableName` WHERE `lockColumn` IN (?);"
      ],
      "sql_evaluation": {
        "total_sql": 1,
        "valid_sql": 1,
        "matched_sql": 0,
        "excluded_sql": 0,
        "fingerprint_results": [
          {
            "sql": "SELECT `lock_nums_column` AS `num` FROM `tableName` WHERE `lockColumn` IN (?);",
            "match_result": {
              "matched": false,
              "fingerprint": "47b13dfdacc345d9bd9545bbbea4b512",
              "excluded": false
            }
          }
        ]
      },
      "inference_success": true
    }
  ]
}