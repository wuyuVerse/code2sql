{
  "/Users/freedom/llms/singularity/internal/cbs_packing_srv/infra/event_bus/bus.go:47:59:RollbackEvents": {
    "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/infra/event_bus/bus.go",
    "code_start_line": 47,
    "code_end_line": 59,
    "code_start_column": 27,
    "code_key": "RollbackEvents",
    "code_value": "func (eb *EventBusDriver) RollbackEvents(ctx context.Context) *response.Result {\n\tfor _, event := range eb.BlockEventQueue {\n\t\tif event.GetState(ctx) == Executed {\n\t\t\t//result := EventHandlerMap[event.GetType(ctx)].Rollback(ctx)\n\t\t\tresult := event.GetHandler(ctx).Rollback(ctx)\n\t\t\tif result.IsFailed() {\n\t\t\t\tlogs.Info(ctx).Err(result).Int(\"EventType\", int(event.GetType(ctx))).Msg(\"rollback event failed\")\n\t\t\t\treturn result\n\t\t\t}\n\t\t}\n\t}\n\treturn response.DefaultResult()\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/infra/event_bus/bus.go",
        "code_start_line": 61,
        "code_end_line": 79,
        "code_key": "Execute",
        "code_value": "func (eb *EventBusDriver) Execute(ctx context.Context) (result *response.Result) {\n\tresult = response.DefaultResult()\n\tdefer utils.HandlePanic(ctx, &result)\n\n\tfor _, event := range eb.BlockEventQueue {\n\t\tresult = eb.ExecuteOne(ctx, event)\n\t\tif result.IsSuccess() {\n\t\t\tevent.UpdateState(ctx, Executed)\n\t\t} else {\n\t\t\tlogs.Warn(ctx).Err(result).Int(\"EventType\", int(event.GetType(ctx))).\n\t\t\t\tMsg(\"event execute failed, start rollback event bus\")\n\t\t\tif err := eb.RollbackEvents(ctx); err != nil {\n\t\t\t\tlogs.Error(ctx).Err(err).Int(\"EventType\", int(event.GetType(ctx))).Msg(\"rollback event bus failed\")\n\t\t\t}\n\t\t\treturn result\n\t\t}\n\t}\n\treturn result\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/filters/filter.go",
        "code_start_line": 26,
        "code_end_line": 46,
        "code_key": "Execute",
        "code_value": "func (f FilterChain) Execute(ctx context.Context, disks []*disk.Disk, user *account.User,\n\tcacheMap cache.RDCacheManagerInf, affinityConfig *dto.AffinityConfig) ([]*disk.Disk, response.Result) {\n\tlogs.Info(ctx).Int(\"disk_count\", len(disks)).Msg(\"DISK_COUNT_BEFORE_FILTER\")\n\tfor _, filter := range f.filters {\n\t\tdisks, result := filter.\n\t\t\tWithUser(ctx, user).\n\t\t\tWithRdCacheManager(ctx, cacheMap).\n\t\t\tWithAffinityConfig(ctx, affinityConfig).\n\t\t\tFilter(ctx, disks)\n\t\tdisks = disk.SortByScore(ctx, disks)\n\t\tlogs.Info(ctx).\n\t\t\tInt(\"disk_count\", len(disks)).\n\t\t\tStr(\"filter\", reflect.TypeOf(filter).Name()).\n\t\t\tMsg(\"LEFT_DISK_COUNT_AFTER_FILTER\")\n\t\tif result.IsFailed() {\n\t\t\treturn disks, result\n\t\t}\n\t}\n\t// 对盘的Score进行排序\n\treturn disks, response.SucResult()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_bill_compute_task.go",
        "code_start_line": 26,
        "code_end_line": 40,
        "code_key": "Execute",
        "code_value": "func (t *SnapBillComputeTask) Execute(ctx context.Context) (bool, error) {\n\tt.Ctx = ctx\n\tt.InitTask(ctx)\n\tdefer t.MqIns.Close()\n\n\t// 获取待处理的用户资源\n\tgo t.GetUserResources()\n\t// 执行Ack确认逻辑\n\tgo t.AckAppId()\n\t// 处理用户资源\n\tt.ProcessUserResources()\n\n\tlogs.Info(ctx).Msg(\"SNAP_COMPUTE_TASK_DONE\")\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_calculate_cost_locally_task.go",
        "code_start_line": 21,
        "code_end_line": 37,
        "code_key": "Execute",
        "code_value": "func (t *SnapCalculateCostLocallyTask) Execute(ctx context.Context) (bool, error) {\n\tt.ctx = ctx\n\tsnapRecSrv := measureReconciliation.NewReconciliationSrvImpl(ctx)\n\n\t// 结算上上个周期的用量\n\tnow := time.Now()\n\tstartTime := now.Truncate(time.Hour).Add(-2 * time.Hour)\n\tendTime := now.Truncate(time.Hour).Add(-1 * time.Hour).Add(-1 * time.Second)\n\tlogs.Info(t.ctx).Time(\"startTime\", startTime).Time(\"endTime\", endTime).Msg(\"START_CALCULATE_COST_LOCALLY\")\n\terr := snapRecSrv.CalculateCostLocally(startTime, endTime)\n\tif err != nil {\n\t\tlogs.Error(t.ctx).Err(err).Msg(\"CALCULATE_COST_LOCALLY_ERROR\")\n\t\treturn false, err\n\t}\n\tlogs.Info(t.ctx).Msg(\"CALCULATE_COST_LOCALLY_DONE\")\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/cbs_bill_compute_task.go",
        "code_start_line": 26,
        "code_end_line": 42,
        "code_key": "Execute",
        "code_value": "func (t *CbsBillComputeTask) Execute(ctx context.Context) (bool, error) {\n\tt.Ctx = ctx\n\tt.InitTask(ctx)\n\tdefer t.MqIns.Close()\n\n\t// 获取待处理的用户资源\n\tgo t.GetUserResources()\n\t// 执行Ack确认逻辑\n\tgo t.AckAppId()\n\t// 处理用户资源\n\tt.ProcessUserResources()\n\tt.ChargeItemProducer.Close()\n\n\tt.WG.Wait()\n\tlogs.Info(ctx).Msg(\"CBS_COMPUTE_TASK_DONE\")\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/update_ccbs_normal_rb_task.go",
        "code_start_line": 23,
        "code_end_line": 34,
        "code_key": "Execute",
        "code_value": "func (t *UpdateCCbsNormalRollbackTask) Execute(ctx context.Context) (bool, error) {\n\tt.Count += 1\n\tserv := registry.GetRegistry(ctx).DomainServices.DiskRollbackingService.(diskLogical.DiskRollbackingServiceInterface)\n\tisFinish, err := serv.UpdateCbsRollbackingPercent(ctx, t.DiskAggregate)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tlogs.Info(ctx).Int(\"Status\", t.DiskAggregate.DiskRecord.Status).\n\t\tInt(\"Percent\", t.DiskAggregate.DiskRecord.RollbackingPercent).\n\t\tInt(\"Count\", t.Count).Msg(\"FINISH_EXECUTE_TASK\")\n\treturn isFinish, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/repush_user_billing_task.go",
        "code_start_line": 53,
        "code_end_line": 61,
        "code_key": "Execute",
        "code_value": "func (t *RepushUserBillingTask) Execute(ctx context.Context) (bool, error) {\n\tt.ctx = ctx\n\tt.InitTask(ctx)\n\tdefer t.MqIns.Close()\n\n\tt.ProcessRepushDetailMsg()\n\tlogs.Info(ctx).Msg(\"REPUSH_USER_BILLING_TASK_DONE\")\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/update_create_task.go",
        "code_start_line": 31,
        "code_end_line": 69,
        "code_key": "Execute",
        "code_value": "func (t *UpdateCreateTask) Execute(ctx context.Context) (bool, error) {\n\tt.Count += 1\n\tserv := registry.GetRegistry(ctx).DomainServices.SnapCreatingService.(snapLogical.SnapCreatingServiceInterface)\n\tif t.SnapAggregate.SnapRecord.Status == ccdb.SnapCreating &&\n\t\tt.SnapAggregate.SnapRecord.LifeState == ccdb.SnapLifeStateNormal &&\n\t\tt.SnapAggregate.SnapRecord.Percent == 100 &&\n\t\tt.SnapAggregate.SnapRecord.Attribute != ccdb.SnapAttUserSnap {\n\t\t// 隐藏快照转正常快照\n\t\tlogs.Info(ctx).Msg(\"FIX_INNER_TO_NORMAL\")\n\t\terr := serv.SnapCreateTaskFollowup(ctx, t.SnapAggregate, SnapInnerFollowup)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\treturn true, nil\n\t}\n\n\tisFinish, err := serv.UpdateSnapCreatingPercent(ctx, t.SnapAggregate)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\t// 创建完成的用户快照进行后续操作，隐藏快照不进行\n\tif isFinish && t.SnapAggregate.SnapRecord.Status == ccdb.SnapNormal &&\n\t\tt.SnapAggregate.SnapRecord.LifeState == ccdb.SnapLifeStateNormal {\n\t\t// 目的端快照复制完成时，需更新源端的快照状态\n\t\t// 计算base snap size，并更新\n\t\t// merge\n\t\t// 插入计费，并更新快照大小\n\t\terr = serv.SnapCreateTaskFollowup(ctx, t.SnapAggregate, SnapNormalFollowup)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\n\tlogs.Info(ctx).Int(\"Status\", t.SnapAggregate.SnapRecord.Status).\n\t\tInt(\"Percent\", t.SnapAggregate.SnapRecord.Percent).\n\t\tInt(\"Count\", t.Count).Msg(\"FINISH_EXECUTE_TASK\")\n\treturn isFinish, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/update_image_snap_rb_task.go",
        "code_start_line": 23,
        "code_end_line": 41,
        "code_key": "Execute",
        "code_value": "func (t *UpdateImageSnapRollbackTask) Execute(ctx context.Context) (bool, error) {\n\tt.Count += 1\n\tserv := registry.GetRegistry(ctx).DomainServices.DiskRollbackingService.(diskLogical.DiskRollbackingServiceInterface)\n\tisFinish, err := serv.UpdateImageSnapRollbackingPercent(ctx, t.DiskAggregate)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif isFinish {\n\t\t// TODO：这里应该放入一个管道中，后续再优化\n\t\terr = serv.UpdateRollbackQuota(ctx, t.DiskAggregate)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\tlogs.Info(ctx).Str(\"Status\", t.DiskAggregate.ImageSnapRollbackRecord.Status).\n\t\tInt(\"Percent\", t.DiskAggregate.ImageSnapRollbackRecord.Percent).\n\t\tInt(\"Count\", t.Count).Msg(\"FINISH_EXECUTE_TASK\")\n\treturn isFinish, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/cbs_measure_send_task.go",
        "code_start_line": 30,
        "code_end_line": 54,
        "code_key": "Execute",
        "code_value": "func (t *CbsMeasureSendTask) Execute(ctx context.Context) (bool, error) {\n\t// 初始化各项配置\n\tt.Ctx = ctx\n\tt.InitTask(ctx)\n\tt.cbsSrv = cbsResource.NewCbsSrvImpl(t.Ctx)\n\tdefer t.MqIns.Close()\n\t// 根据区域分发到国内和国际两个不同channel中去处理\n\tt.ChannelDistribution()\n\n\t// MSG处理的生命周期Msg -->chargeItem -->MeasureDetails-->MeasureDetailsChannel-->Params-->Ack Msg\n\tgo t.ProcessMsgByRegion()\n\n\t// 计费详情转换成计费参数\n\tgo t.ProcessMeasureDetailToParams()\n\n\t// 执行ACK\n\tgo t.AckResourceID()\n\n\t// 根据计费参数发送计费消息\n\tt.ProcessParamsSendMeasure()\n\n\tt.WG.Wait()\n\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/cbs_rec_task.go",
        "code_start_line": 37,
        "code_end_line": 61,
        "code_key": "Execute",
        "code_value": "func (t *CbsMeasureRecTask) Execute(ctx context.Context) (bool, error) {\n\t// 初始化各项配置\n\tt.Ctx = ctx\n\tt.InitTask(ctx)\n\t// 初始化snapSrv\n\tt.cbsReSrv = measureReconciliation.NewReconciliationSrvImpl(t.Ctx)\n\tt.cbsSrv = cbsResource.NewCbsSrvImpl(t.Ctx)\n\tdefer t.MqIns.Close()\n\t// 根据区域分发到国内和国际两个不同channel中去处理\n\tt.ChannelDistribution()\n\n\t// MSG处理的生命周期Msg -->chargeItem -->subMeasureDetails-->subMeasureDetailsChannel-->db-->Ack Msg\n\tgo t.ProcessMsg()\n\n\t// 生成批次外发的计费对账数据\n\tgo t.ProcessMeasureDetailBatch()\n\n\t// 执行ACK\n\tgo t.AckResourceID()\n\n\t// 将计费数据外发到数据库\n\tt.ProcessMeasureToDb()\n\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_measure_send_task.go",
        "code_start_line": 27,
        "code_end_line": 49,
        "code_key": "Execute",
        "code_value": "func (t *SnapMeasureSendTask) Execute(ctx context.Context) (bool, error) {\n\t// 初始化各项配置\n\tt.Ctx = ctx\n\tt.InitTask(ctx)\n\tdefer t.MqIns.Close()\n\n\t// 根据区域分发到国内和国际两个不同channel中去处理\n\tt.ChannelDistribution()\n\n\t// 启动外发任务\n\tgo t.ProcessMsgByRegion()\n\n\t// 用量详情转换成计费协议\n\tgo t.ProcessMeasureDetailToParams()\n\n\t// 执行ACK\n\tgo t.AckResourceID()\n\n\t// 根据计费协议发送到计费客户端\n\tt.ProcessParamsSendMeasure()\n\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_rec_task.go",
        "code_start_line": 48,
        "code_end_line": 61,
        "code_key": "Execute",
        "code_value": "func (t *SnapMeasureReconciliationTask) Execute(ctx context.Context) (bool, error) {\n\t// 初始化各项配置\n\tt.ctx = ctx\n\tt.initTask()\n\n\t// 将数据推送到数据库\n\tvar wg sync.WaitGroup\n\tgo t.sendDbFromMsg(&wg)\n\n\t// 执行ACK\n\tgo t.AckResourceID()\n\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/base_measure/base_appId_fetch_task.go",
        "code_start_line": 38,
        "code_end_line": 61,
        "code_key": "Execute",
        "code_value": "func (t *BaseAppIdFetchTask) Execute(ctx context.Context) (bool, error) {\n\tt.ctx = ctx\n\tt.initTask()\n\n\tappIds := t.resSrv.GetAppIdsWithValidResources(t.chargeTime)\n\tfor _, appId := range appIds {\n\t\tappIdItem := measure.AppIdInfo{\n\t\t\tAppId: appId,\n\t\t}\n\t\t// Send自带Confirm机制. error为nil表示发送成功\n\t\t// Send会阻塞等待Confirm，如果需要，可以考虑放协程里跑\n\t\terr := t.client.Send(ctx, measure.BuildRabbitRequest(&appIdItem))\n\t\tif err != nil {\n\t\t\tlogs.Error(ctx).Err(err).Msg(\"SEND_MESSAGE_FAILED\")\n\t\t\treturn false, err\n\t\t}\n\t\tlogs.Info(ctx).Interface(\"appId\", appId).Msg(\"SEND_MESSAGE_SUCCESS\")\n\t}\n\n\tstopChan := make(chan struct{})\n\t_ = t.server.Close(stopChan)\n\t<-stopChan\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": []
  },
  "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/desdb/repos/impl/shm.go:17:28:ListRecordByStatus": {
    "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/desdb/repos/impl/shm.go",
    "code_start_line": 17,
    "code_end_line": 28,
    "code_start_column": 24,
    "code_key": "ListRecordByStatus",
    "code_value": "func (s ShmRepository) ListRecordByStatus(ctx context.Context, status repos.ShmStatus) ([]*models.Shm, error) {\n\tvar records []*models.Shm\n\ttx := s.DB.Where(\"status = ?\", status).Find(&records)\n\tif tx.Error != nil {\n\t\treturn nil, tx.Error\n\t}\n\n\tif tx.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\treturn records, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/schedule/shm.go",
        "code_start_line": 20,
        "code_end_line": 38,
        "code_key": "refreshShmRound",
        "code_value": "func (r *RefreshShmTask) refreshShmRound(ctx context.Context) error {\n\tshmRecords, err := app.GlobalRegistry.Repository.ShmRepo.ListRecordByStatus(ctx, repos.VALID)\n\tif err != nil {\n\t\tlogs.Error(ctx).Err(err).Msg(\"FETCH_SHM_CONF_FAILED\")\n\t\treturn err\n\t}\n\tshmCacheManager := cache.GetCacheManager(cache.ShmCache)\n\n\tfor _, record := range shmRecords {\n\t\terr = shmCacheManager.Set(ctx, &managers.ShmCacheKeyResolver{CacheKey: record.ConfKey}, record.ConfValue)\n\t\tif err != nil {\n\t\t\tlogs.Error(ctx).Err(err).\n\t\t\t\tStr(\"conf_key\", record.ConfKey).\n\t\t\t\tStr(\"conf_value\", record.ConfValue).\n\t\t\t\tMsg(\"REFRESH_SHM_CACHE_FAILED\")\n\t\t}\n\t}\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/tracker.go",
        "code_start_line": 37,
        "code_end_line": 42,
        "code_key": "Track",
        "code_value": "func (rdp *PhyDiskTracker) Track(ctx context.Context) {\n\t// TODO:分页查询\n\trdp.OriPhyDisks = app.GlobalRegistry.Repository.RDPhyRepo.ListRecordByState(ctx, int(models.PVSOnline))\n\trdp.DrgroupMembers = app.GlobalRegistry.Repository.DiskAffinityRepo.ListRecordByStatus(ctx, string(models.NORMAL))\n\tlogs.Info(ctx).Int(\"disk_num\", len(rdp.OriPhyDisks)).Msg(\"TRACK_PHY_DISK_FROM_META_DB\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/set/cache/tracker.go",
        "code_start_line": 20,
        "code_end_line": 33,
        "code_key": "Track",
        "code_value": "func (d *DiskSetTracker) Track(ctx context.Context) {\n\tentityList, err := app.GlobalRegistry.Repository.SetRepo.ListNormalRecords(ctx)\n\tif err != nil {\n\t\tlogs.Error(ctx).Err(err).Msg(\"DISK_SET_TRACKER_REFRESH_ERROR\")\n\t\treturn\n\t}\n\t// convert to interfaces{}\n\tinfList := make([]interface{}, 0, 10000)\n\tfor _, obj := range entityList {\n\t\tinfList = append(infList, obj)\n\t}\n\td.DiskSetEntityInf = infList\n\tlogs.Info(ctx).Int(\"set_num\", len(d.DiskSetEntityInf)).Msg(\"TRACK_DISK_SET_FROM_DB\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/desdb/models/shm.go",
        "code_start_line": 11,
        "code_end_line": 19,
        "code_key": "Shm",
        "code_value": "type Shm struct {\n\tID           uint64    `gorm:\"column:id;primaryKey\"` // 主键 ID\n\tConfKey      string    `gorm:\"column:confKey\"`\n\tConfValue    string    `gorm:\"column:confValue\"`\n\tStatus       string    `gorm:\"column:status\"`\n\tValidateRule string    `gorm:\"column:validateRule\"`\n\tAddTime      time.Time `gorm:\"column:addTime\"`\n\tModifyTime   time.Time `gorm:\"column:modifyTime\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/desdb/models/shm.go",
        "code_start_line": 21,
        "code_end_line": 23,
        "code_key": "DBName",
        "code_value": "func (s *Shm) DBName() string {\n\treturn \"cbs_des_online\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/desdb/models/shm.go",
        "code_start_line": 25,
        "code_end_line": 27,
        "code_key": "TableName",
        "code_value": "func (s *Shm) TableName() string {\n\treturn \"t_cbs_shm_conf\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/benchmark/benchmark.go",
        "code_start_line": 25,
        "code_end_line": 25,
        "code_key": "Status",
        "code_value": "type Status int",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/repo/impl/dmg.go:29:37:ListRecordByStatus": {
    "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/repo/impl/dmg.go",
    "code_start_line": 29,
    "code_end_line": 37,
    "code_start_column": 38,
    "code_key": "ListRecordByStatus",
    "code_value": "func (d *DiskBindAffinityRepository) ListRecordByStatus(ctx context.Context, status string) []*models.DmDrgroupMembers {\n\tvar records []*models.DmDrgroupMembers\n\ttx := d.DB.Find(&records)\n\tif tx.Error != nil {\n\t\tlogs.Error(ctx).Err(tx.Error).Str(\"status\", status).Msg(\"LIST_DM_GROUP_MEMBER_FAILED\")\n\t\treturn nil\n\t}\n\treturn records\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/schedule/shm.go",
        "code_start_line": 20,
        "code_end_line": 38,
        "code_key": "refreshShmRound",
        "code_value": "func (r *RefreshShmTask) refreshShmRound(ctx context.Context) error {\n\tshmRecords, err := app.GlobalRegistry.Repository.ShmRepo.ListRecordByStatus(ctx, repos.VALID)\n\tif err != nil {\n\t\tlogs.Error(ctx).Err(err).Msg(\"FETCH_SHM_CONF_FAILED\")\n\t\treturn err\n\t}\n\tshmCacheManager := cache.GetCacheManager(cache.ShmCache)\n\n\tfor _, record := range shmRecords {\n\t\terr = shmCacheManager.Set(ctx, &managers.ShmCacheKeyResolver{CacheKey: record.ConfKey}, record.ConfValue)\n\t\tif err != nil {\n\t\t\tlogs.Error(ctx).Err(err).\n\t\t\t\tStr(\"conf_key\", record.ConfKey).\n\t\t\t\tStr(\"conf_value\", record.ConfValue).\n\t\t\t\tMsg(\"REFRESH_SHM_CACHE_FAILED\")\n\t\t}\n\t}\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/tracker.go",
        "code_start_line": 37,
        "code_end_line": 42,
        "code_key": "Track",
        "code_value": "func (rdp *PhyDiskTracker) Track(ctx context.Context) {\n\t// TODO:分页查询\n\trdp.OriPhyDisks = app.GlobalRegistry.Repository.RDPhyRepo.ListRecordByState(ctx, int(models.PVSOnline))\n\trdp.DrgroupMembers = app.GlobalRegistry.Repository.DiskAffinityRepo.ListRecordByStatus(ctx, string(models.NORMAL))\n\tlogs.Info(ctx).Int(\"disk_num\", len(rdp.OriPhyDisks)).Msg(\"TRACK_PHY_DISK_FROM_META_DB\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/set/cache/tracker.go",
        "code_start_line": 20,
        "code_end_line": 33,
        "code_key": "Track",
        "code_value": "func (d *DiskSetTracker) Track(ctx context.Context) {\n\tentityList, err := app.GlobalRegistry.Repository.SetRepo.ListNormalRecords(ctx)\n\tif err != nil {\n\t\tlogs.Error(ctx).Err(err).Msg(\"DISK_SET_TRACKER_REFRESH_ERROR\")\n\t\treturn\n\t}\n\t// convert to interfaces{}\n\tinfList := make([]interface{}, 0, 10000)\n\tfor _, obj := range entityList {\n\t\tinfList = append(infList, obj)\n\t}\n\td.DiskSetEntityInf = infList\n\tlogs.Info(ctx).Int(\"set_num\", len(d.DiskSetEntityInf)).Msg(\"TRACK_DISK_SET_FROM_DB\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 39,
        "code_end_line": 49,
        "code_key": "DmDrgroupMembers",
        "code_value": "type DmDrgroupMembers struct {\n\tID        uint64    `gorm:\"column:id;primaryKey\"`                                                          // 主键 ID\n\tAppID     int64     `gorm:\"column:app_id;index:dm_drgroup_members_app_id_group_name_member_id,unique\"`     // AppID\n\tGroupName string    `gorm:\"column:group_name;index:dm_drgroup_members_app_id_group_name_member_id,unique\"` // DRGroup 名称，用户名下唯一\n\tSubGroup  string    `gorm:\"column:sub_group\"`                                                              // 子组名称\n\tLoc       string    `gorm:\"column:loc\"`                                                                    // 位置信息，例如母机 IP\n\tMemberID  string    `gorm:\"column:member_id;index:dm_drgroup_members_app_id_group_name_member_id,unique\"`  // DRGroup 成员 ID，例如逻辑卷 UUID\n\tExtra     string    `gorm:\"column:extra\"`                                                                  // 额外信息\n\tCreated   time.Time `gorm:\"column:created\"`\n\tUpdated   time.Time `gorm:\"column:updated\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 55,
        "code_end_line": 57,
        "code_key": "TableName",
        "code_value": "func (DmDrgroupMembers) TableName() string {\n\treturn \"dm_drgroup_members\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 51,
        "code_end_line": 53,
        "code_key": "DBName",
        "code_value": "func (m DmDrgroupMembers) DBName() string {\n\treturn \"metadb\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 135,
        "code_end_line": 145,
        "code_key": "DmDrgroupMembers",
        "code_value": "type DmDrgroupMembers struct {\n\tID        uint64    `gorm:\"column:id;primaryKey\"`                                                          // 主键 ID\n\tAppID     int64     `gorm:\"column:app_id;index:dm_drgroup_members_app_id_group_name_member_id,unique\"`     // AppID\n\tGroupName string    `gorm:\"column:group_name;index:dm_drgroup_members_app_id_group_name_member_id,unique\"` // DRGroup 名称，用户名下唯一\n\tSubGroup  string    `gorm:\"column:sub_group\"`                                                              // 子组名称\n\tLoc       string    `gorm:\"column:loc\"`                                                                    // 位置信息，例如母机 IP\n\tMemberID  string    `gorm:\"column:member_id;index:dm_drgroup_members_app_id_group_name_member_id,unique\"`  // DRGroup 成员 ID，例如逻辑卷 UUID\n\tExtra     string    `gorm:\"column:extra\"`                                                                  // 额外信息\n\tCreated   time.Time `gorm:\"column:created\"`\n\tUpdated   time.Time `gorm:\"column:updated\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 147,
        "code_end_line": 149,
        "code_key": "TableName",
        "code_value": "func (DmDrgroupMembers) TableName() string {\n\treturn \"dm_drgroup_members\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/benchmark/benchmark.go",
        "code_start_line": 25,
        "code_end_line": 25,
        "code_key": "Status",
        "code_value": "type Status int",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/desdb/repos/impl/rule.go:37:55:GetRulesByZone": {
    "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/desdb/repos/impl/rule.go",
    "code_start_line": 37,
    "code_end_line": 55,
    "code_start_column": 25,
    "code_key": "GetRulesByZone",
    "code_value": "func (r RuleRepository) GetRulesByZone(ctx context.Context, ruleType string, zoneId int) ([]*rule.SetRuleEntity, error) {\n\tvar records []*models.DmRule\n\tresult := r.DB.Where(\"status = ? and ruleType = ? and (zoneId IS NULL or zoneId = ?)\", rule.StatusNormal, ruleType, zoneId).Order(\"priority desc\").Find(&records)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tvar entities []*rule.SetRuleEntity\n\tfor _, record := range records {\n\t\tentity, err := r.convertModelToEntity(record, ruleType)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tentities = append(entities, entity)\n\t}\n\treturn entities, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/rule/handler/rule_filter.go",
        "code_start_line": 15,
        "code_end_line": 18,
        "code_key": "PackingByRule",
        "code_value": "func (r RuleFilterHandler) PackingByRule(ctx context.Context, setList []*set.DiskSetEntity) *rule.SetRulePackingResult {\n\t//TODO implement me\n\tpanic(\"implement me\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/rule/handler/rule_weigher.go",
        "code_start_line": 19,
        "code_end_line": 56,
        "code_key": "PackingByRule",
        "code_value": "func (r RuleWeigherHandler) PackingByRule(ctx context.Context, setList []*set.DiskSetEntity) *rule.SetRulePackingResult {\n\tscoreMap := make(map[*set.DiskSetEntity]int32)\n\tif len(setList) == 0 {\n\t\tlogs.Warn(ctx).Msgf(\"EMPTY_SET_ENTITY_SIKP_WEIGHER_PACKING\")\n\t\treturn &rule.SetRulePackingResult{\n\t\t\tResult: &response.Result{\n\t\t\t\tCode:    response.RulePackingError,\n\t\t\t\tMessage: \"empty set entity and skip to weigher packing\",\n\t\t\t},\n\t\t\tSetScoreMap: scoreMap,\n\t\t}\n\t}\n\n\truleRepo := app.GlobalRegistry.Repository.RuleRepo\n\truleEntities, err := ruleRepo.GetRulesByZone(ctx, string(rule.Weigher), int(r.PackingRuleInfo.ZoneId))\n\tif err != nil {\n\t\tlogs.Warn(ctx).Msgf(\"GET_RULE_FAILED\")\n\t\treturn &rule.SetRulePackingResult{\n\t\t\tResult: &response.Result{\n\t\t\t\tCode:    response.RulePackingError,\n\t\t\t\tMessage: fmt.Sprintf(\"get rule failed, err: %s\", err),\n\t\t\t},\n\t\t\tSetScoreMap: scoreMap,\n\t\t}\n\t}\n\tlogs.Info(ctx).Int(\"rule_count\", len(ruleEntities)).Msgf(\"GET_RULES\")\n\tfor _, entity := range ruleEntities {\n\t\tif entity.Match(ctx, r.PackingRuleInfo) {\n\t\t\tscoreMap = entity.Weigher(ctx, setList)\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn &rule.SetRulePackingResult{\n\t\tResult:      response.DefaultResult(),\n\t\tSetScoreMap: scoreMap,\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/packing/services/cloud.go",
        "code_start_line": 72,
        "code_end_line": 88,
        "code_key": "PackingByRule",
        "code_value": "func (c *CloudPackSetService) PackingByRule(ctx context.Context, ruleType rule.PackingRuleType, setList []*set.DiskSetEntity) *rule.SetRulePackingResult {\n\truleHandler := ruleServices.SetRuleFactory{\n\t\tPackingRuleType: ruleType,\n\t\tPackingRuleInfo: rule.SetRulePackingDTO{\n\t\t\tAppId:              c.entity.RuleInfo.AppId,\n\t\t\tZoneId:             c.entity.RuleInfo.ZoneId,\n\t\t\tDiskSize:           c.entity.RuleInfo.DiskSize,\n\t\t\tSnapUuid:           c.entity.RuleInfo.SnapUuid,\n\t\t\tDiskType:           c.entity.RuleInfo.DiskType,\n\t\t\tPayMode:            c.entity.RuleInfo.PayMode,\n\t\t\tOriginalVolumeType: c.entity.RuleInfo.OriginalVolumeType,\n\t\t\tConcreteVolumeType: c.entity.RuleInfo.ConcreteVolumeType,\n\t\t\tCbsDiskTrait:       c.entity.RuleInfo.CbsDiskTrait,\n\t\t},\n\t}\n\treturn ruleHandler.GetRuleHandler().PackingByRule(ctx, setList)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/desdb/models/rule.go",
        "code_start_line": 10,
        "code_end_line": 21,
        "code_key": "DmRule",
        "code_value": "type DmRule struct {\n\tID         uint64    `gorm:\"column:id;primaryKey\"` // 主键 ID\n\tZoneId     int       `gorm:\"column:zoneId\"`        // 公有云可用区ID\n\tCondition  string    `gorm:\"column:condition\"`     // 规则需要满足的条件\n\tAction     string    `gorm:\"column:action\"`\n\tStatus     string    `gorm:\"column:status\"`\n\tPriority   int       `gorm:\"column:priority\"`\n\tRuleType   string    `gorm:\"column:ruleType\"`\n\tCreateTime time.Time `gorm:\"column:createTime\"`\n\tUpdateTime time.Time `gorm:\"column:updateTime\"`\n\tComment    string    `gorm:\"column:comment\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/desdb/models/rule.go",
        "code_start_line": 23,
        "code_end_line": 25,
        "code_key": "DBName",
        "code_value": "func (s *DmRule) DBName() string {\n\treturn \"cbs_des_online\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/desdb/models/rule.go",
        "code_start_line": 27,
        "code_end_line": 29,
        "code_key": "TableName",
        "code_value": "func (*DmRule) TableName() string {\n\treturn \"t_cbs_set_rule_filter\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/rule/entity.go",
        "code_start_line": 124,
        "code_end_line": 130,
        "code_key": "SetRuleEntity",
        "code_value": "type SetRuleEntity struct {\n\tRuleId    uint64\n\tCondition map[string]interface{}\n\tAction    map[string]interface{}\n\truleType  PackingRuleType\n\tPriority  int\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/desdb/repos/impl/set.go:35:54:ListRecordsByUuid": {
    "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/desdb/repos/impl/set.go",
    "code_start_line": 35,
    "code_end_line": 54,
    "code_start_column": 35,
    "code_key": "ListRecordsByUuid",
    "code_value": "func (setRepoImpl *SetRepository) ListRecordsByUuid(ctx context.Context, setUuids []string) ([]*set.DiskSetEntity, error) {\n\tvar records []*models.DmSet\n\tresult := setRepoImpl.DB.Where(\"setUuid in ?\", setUuids).Find(&records)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\n\tvar entities []*set.DiskSetEntity\n\tfor _, record := range records {\n\t\tentity, err := setRepoImpl.convertModelToEntity(record)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tentities = append(entities, entity)\n\t}\n\treturn entities, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/desdb/models/set.go",
        "code_start_line": 11,
        "code_end_line": 53,
        "code_key": "DmSet",
        "code_value": "type DmSet struct {\n\tID                        uint64    `gorm:\"column:id;primaryKey\"` // 主键 ID\n\tVolumeType                string    `gorm:\"column:volumeType\"`    // 仓库介质类型\n\tZoneId                    uint64    `gorm:\"column:zoneId\"`        // 公有云可用区ID\n\tCbsZoneId                 int       `gorm:\"column:cbsZoneId\"`     // CBS可用区ID\n\tDepotId                   int       `gorm:\"column:depotId\"`\n\tSetId                     int       `gorm:\"column:setId\"`\n\tSetUuid                   string    `gorm:\"column:setUuid\"`\n\tModuleId                  int       `gorm:\"column:moduleId\"`\n\tPool                      string    `gorm:\"column:pool\"`\n\tStatus                    string    `gorm:\"column:status\"`\n\tForceStatus               string    `gorm:\"column:forceStatus\"`\n\tOverSold                  int       `gorm:\"column:overSold\"`\n\tMaxDiskNum                int       `gorm:\"column:maxDiskNum\"`\n\tMaxDiskSize               int       `gorm:\"column:maxDiskSize\"`\n\tMaxMigratingCount         int       `gorm:\"column:maxMigratingCount\"`\n\tMaxRootDiskCount          int       `gorm:\"column:maxRootDiskCount\"`\n\tUnlockedDiskNum           int       `gorm:\"column:unlockedDiskNum\"`\n\tUnlockedDiskSize          int       `gorm:\"column:unlockedDiskSize\"`\n\tTotalDiskSize             int       `gorm:\"column:totalDiskSize\"`\n\tUsedDiskNum               int       `gorm:\"column:usedDiskNum\"`\n\tUsedDiskSize              int       `gorm:\"column:usedDiskSize\"`\n\tIs1c1g                    int       `gorm:\"column:is1c1g\"`\n\tIsActivity                int       `gorm:\"column:isActivity\"`\n\tIsBigDisk                 int       `gorm:\"column:isBigDisk\"`\n\tArchType                  string    `gorm:\"column:archType\"`\n\tSpecialType               string    `gorm:\"column:specialType\"`\n\tNetType                   string    `gorm:\"column:netType\"`\n\tCellBlockUsage            float32   `gorm:\"column:cellBlockUsage\"`\n\tCellBlockUsageStaticTime  time.Time `gorm:\"column:cellBlockUsageStaticTime\"`\n\tGrayKey                   string    `gorm:\"column:gray_key\"`\n\tAttributes                string    `gorm:\"column:attributes\"`\n\tUsedThroughputPerformance int       `gorm:\"column:usedThroughputPerformance\"`\n\tOutpostId                 string    `gorm:\"column:outpostId\"`\n\tClusterId                 string    `gorm:\"column:clusterId\"`\n\tBucketName                string    `gorm:\"column:bucketName\"`\n\tIsTssd                    int       `gorm:\"column:isTssd\"`\n\tReserved                  int       `gorm:\"column:reserved\"`\n\tAddTime                   time.Time `gorm:\"column:addTime\"`\n\tUpdateTime                time.Time `gorm:\"column:updateTime\"`\n\tDosUpdateTime             time.Time `gorm:\"column:dosUpdateTime\"`\n\tHitTime                   time.Time `gorm:\"column:hitTime\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/desdb/models/set.go",
        "code_start_line": 55,
        "code_end_line": 57,
        "code_key": "DBName",
        "code_value": "func (s *DmSet) DBName() string {\n\treturn \"cbs_des_online\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/desdb/models/set.go",
        "code_start_line": 59,
        "code_end_line": 61,
        "code_key": "TableName",
        "code_value": "func (*DmSet) TableName() string {\n\treturn \"t_cbs_set_select\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/set/entity.go",
        "code_start_line": 6,
        "code_end_line": 11,
        "code_key": "DiskSetEntity",
        "code_value": "type DiskSetEntity struct {\n\tSetUuid    types.SetUuid\n\tVolumeType types.VolumeType\n\tZoneId     types.ZoneId\n\tAttributes []string\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/desdb/repos/impl/set.go:56:75:ListNormalRecords": {
    "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/desdb/repos/impl/set.go",
    "code_start_line": 56,
    "code_end_line": 75,
    "code_start_column": 35,
    "code_key": "ListNormalRecords",
    "code_value": "func (setRepoImpl *SetRepository) ListNormalRecords(ctx context.Context) ([]*set.DiskSetEntity, error) {\n\t// TODO: t_cbs_set_select没有对status建立索引，这里的sql会全表扫描。但是目前北上广记录都不超过2千条，所以暂时先这样\n\tvar records []*models.DmSet\n\tresult := setRepoImpl.DB.Where(\"status = ? and (forceStatus IS NULL or forceStatus != ?)\", models.SetNormal, models.SetDisable).Find(&records)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tvar entities []*set.DiskSetEntity\n\tfor _, record := range records {\n\t\tentity, err := setRepoImpl.convertModelToEntity(record)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tentities = append(entities, entity)\n\t}\n\treturn entities, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/tracker.go",
        "code_start_line": 37,
        "code_end_line": 42,
        "code_key": "Track",
        "code_value": "func (rdp *PhyDiskTracker) Track(ctx context.Context) {\n\t// TODO:分页查询\n\trdp.OriPhyDisks = app.GlobalRegistry.Repository.RDPhyRepo.ListRecordByState(ctx, int(models.PVSOnline))\n\trdp.DrgroupMembers = app.GlobalRegistry.Repository.DiskAffinityRepo.ListRecordByStatus(ctx, string(models.NORMAL))\n\tlogs.Info(ctx).Int(\"disk_num\", len(rdp.OriPhyDisks)).Msg(\"TRACK_PHY_DISK_FROM_META_DB\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/set/cache/tracker.go",
        "code_start_line": 20,
        "code_end_line": 33,
        "code_key": "Track",
        "code_value": "func (d *DiskSetTracker) Track(ctx context.Context) {\n\tentityList, err := app.GlobalRegistry.Repository.SetRepo.ListNormalRecords(ctx)\n\tif err != nil {\n\t\tlogs.Error(ctx).Err(err).Msg(\"DISK_SET_TRACKER_REFRESH_ERROR\")\n\t\treturn\n\t}\n\t// convert to interfaces{}\n\tinfList := make([]interface{}, 0, 10000)\n\tfor _, obj := range entityList {\n\t\tinfList = append(infList, obj)\n\t}\n\td.DiskSetEntityInf = infList\n\tlogs.Info(ctx).Int(\"set_num\", len(d.DiskSetEntityInf)).Msg(\"TRACK_DISK_SET_FROM_DB\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/desdb/models/set.go",
        "code_start_line": 11,
        "code_end_line": 53,
        "code_key": "DmSet",
        "code_value": "type DmSet struct {\n\tID                        uint64    `gorm:\"column:id;primaryKey\"` // 主键 ID\n\tVolumeType                string    `gorm:\"column:volumeType\"`    // 仓库介质类型\n\tZoneId                    uint64    `gorm:\"column:zoneId\"`        // 公有云可用区ID\n\tCbsZoneId                 int       `gorm:\"column:cbsZoneId\"`     // CBS可用区ID\n\tDepotId                   int       `gorm:\"column:depotId\"`\n\tSetId                     int       `gorm:\"column:setId\"`\n\tSetUuid                   string    `gorm:\"column:setUuid\"`\n\tModuleId                  int       `gorm:\"column:moduleId\"`\n\tPool                      string    `gorm:\"column:pool\"`\n\tStatus                    string    `gorm:\"column:status\"`\n\tForceStatus               string    `gorm:\"column:forceStatus\"`\n\tOverSold                  int       `gorm:\"column:overSold\"`\n\tMaxDiskNum                int       `gorm:\"column:maxDiskNum\"`\n\tMaxDiskSize               int       `gorm:\"column:maxDiskSize\"`\n\tMaxMigratingCount         int       `gorm:\"column:maxMigratingCount\"`\n\tMaxRootDiskCount          int       `gorm:\"column:maxRootDiskCount\"`\n\tUnlockedDiskNum           int       `gorm:\"column:unlockedDiskNum\"`\n\tUnlockedDiskSize          int       `gorm:\"column:unlockedDiskSize\"`\n\tTotalDiskSize             int       `gorm:\"column:totalDiskSize\"`\n\tUsedDiskNum               int       `gorm:\"column:usedDiskNum\"`\n\tUsedDiskSize              int       `gorm:\"column:usedDiskSize\"`\n\tIs1c1g                    int       `gorm:\"column:is1c1g\"`\n\tIsActivity                int       `gorm:\"column:isActivity\"`\n\tIsBigDisk                 int       `gorm:\"column:isBigDisk\"`\n\tArchType                  string    `gorm:\"column:archType\"`\n\tSpecialType               string    `gorm:\"column:specialType\"`\n\tNetType                   string    `gorm:\"column:netType\"`\n\tCellBlockUsage            float32   `gorm:\"column:cellBlockUsage\"`\n\tCellBlockUsageStaticTime  time.Time `gorm:\"column:cellBlockUsageStaticTime\"`\n\tGrayKey                   string    `gorm:\"column:gray_key\"`\n\tAttributes                string    `gorm:\"column:attributes\"`\n\tUsedThroughputPerformance int       `gorm:\"column:usedThroughputPerformance\"`\n\tOutpostId                 string    `gorm:\"column:outpostId\"`\n\tClusterId                 string    `gorm:\"column:clusterId\"`\n\tBucketName                string    `gorm:\"column:bucketName\"`\n\tIsTssd                    int       `gorm:\"column:isTssd\"`\n\tReserved                  int       `gorm:\"column:reserved\"`\n\tAddTime                   time.Time `gorm:\"column:addTime\"`\n\tUpdateTime                time.Time `gorm:\"column:updateTime\"`\n\tDosUpdateTime             time.Time `gorm:\"column:dosUpdateTime\"`\n\tHitTime                   time.Time `gorm:\"column:hitTime\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/desdb/models/set.go",
        "code_start_line": 55,
        "code_end_line": 57,
        "code_key": "DBName",
        "code_value": "func (s *DmSet) DBName() string {\n\treturn \"cbs_des_online\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/desdb/models/set.go",
        "code_start_line": 59,
        "code_end_line": 61,
        "code_key": "TableName",
        "code_value": "func (*DmSet) TableName() string {\n\treturn \"t_cbs_set_select\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/set/entity.go",
        "code_start_line": 6,
        "code_end_line": 11,
        "code_key": "DiskSetEntity",
        "code_value": "type DiskSetEntity struct {\n\tSetUuid    types.SetUuid\n\tVolumeType types.VolumeType\n\tZoneId     types.ZoneId\n\tAttributes []string\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/repo/impl/phy.go:20:28:ListRecordByState": {
    "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/repo/impl/phy.go",
    "code_start_line": 20,
    "code_end_line": 28,
    "code_start_column": 42,
    "code_key": "ListRecordByState",
    "code_value": "func (phyImpl *PhysicalVolumeRepository) ListRecordByState(ctx context.Context, state int) []*models.DmPhydisk {\n\tvar records []*models.DmPhydisk\n\ttx := phyImpl.DB.Where(\"status = ?\", state).Find(&records)\n\tif tx.Error != nil {\n\t\tlogs.Error(ctx).Err(tx.Error).Int(\"state\", state).Msg(\"LIST_RECORD_BY_STATE_ERROR\")\n\t\treturn nil\n\t}\n\treturn records\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/tracker.go",
        "code_start_line": 37,
        "code_end_line": 42,
        "code_key": "Track",
        "code_value": "func (rdp *PhyDiskTracker) Track(ctx context.Context) {\n\t// TODO:分页查询\n\trdp.OriPhyDisks = app.GlobalRegistry.Repository.RDPhyRepo.ListRecordByState(ctx, int(models.PVSOnline))\n\trdp.DrgroupMembers = app.GlobalRegistry.Repository.DiskAffinityRepo.ListRecordByStatus(ctx, string(models.NORMAL))\n\tlogs.Info(ctx).Int(\"disk_num\", len(rdp.OriPhyDisks)).Msg(\"TRACK_PHY_DISK_FROM_META_DB\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/set/cache/tracker.go",
        "code_start_line": 20,
        "code_end_line": 33,
        "code_key": "Track",
        "code_value": "func (d *DiskSetTracker) Track(ctx context.Context) {\n\tentityList, err := app.GlobalRegistry.Repository.SetRepo.ListNormalRecords(ctx)\n\tif err != nil {\n\t\tlogs.Error(ctx).Err(err).Msg(\"DISK_SET_TRACKER_REFRESH_ERROR\")\n\t\treturn\n\t}\n\t// convert to interfaces{}\n\tinfList := make([]interface{}, 0, 10000)\n\tfor _, obj := range entityList {\n\t\tinfList = append(infList, obj)\n\t}\n\td.DiskSetEntityInf = infList\n\tlogs.Info(ctx).Int(\"set_num\", len(d.DiskSetEntityInf)).Msg(\"TRACK_DISK_SET_FROM_DB\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 65,
        "code_end_line": 82,
        "code_key": "DmPhydisk",
        "code_value": "type DmPhydisk struct {\n\tID         uint64    `gorm:\"column:id;primaryKey\"`\n\tSerial     string    `gorm:\"column:serial;unique\"`\n\tIP         string    `gorm:\"column:host_ip\"`\n\tBDF        string    `gorm:\"column:bdf\"`\n\tDiskID     uint64    `gorm:\"column:disk_id\"`\n\tPort       int       `gorm:\"column:port\"`\n\tStatus     int       `gorm:\"column:status\"`\n\tSize       uint32    `gorm:\"column:size\"`\n\tRealSize   int64     `gorm:\"column:real_size\"`\n\tBlockSize  int       `gorm:\"column:block_size\"`\n\tZoneID     uint64    `gorm:\"column:zone_id\"`\n\tVolumeType string    `gorm:\"column:volume_type\"`\n\tExtra      string    `gorm:\"column:extra\"`\n\tCreated    time.Time `gorm:\"column:created\"`\n\tUpdated    time.Time `gorm:\"column:updated\"`\n\tPerfRank   string    `gorm:\"column:perf_rank\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 85,
        "code_end_line": 87,
        "code_key": "TableName",
        "code_value": "func (d *DmPhydisk) TableName() string {\n\treturn \"dm_phydisk\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 90,
        "code_end_line": 92,
        "code_key": "DBName",
        "code_value": "func (d *DmPhydisk) DBName() string {\n\treturn \"metadb\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 57,
        "code_end_line": 75,
        "code_key": "DmPhydisk",
        "code_value": "type DmPhydisk struct {\n\tID              uint64    `gorm:\"column:id;primaryKey\"`\n\tSerial          string    `gorm:\"column:serial;unique\"`\n\tIP              string    `gorm:\"column:host_ip\"`\n\tBDF             string    `gorm:\"column:bdf\"`\n\tDiskID          uint64    `gorm:\"column:disk_id\"`\n\tPort            int       `gorm:\"column:port\"`\n\tStatus          int       `gorm:\"column:status\"`\n\tSize            int64     `gorm:\"column:size\"`\n\tRealSize        int64     `gorm:\"column:real_size\"`\n\tBlockSize       int       `gorm:\"column:block_size\"`\n\tZoneID          int64     `gorm:\"column:zone_id\"`\n\tVolumeType      string    `gorm:\"column:volume_type\"`\n\tExtra           string    `gorm:\"column:extra\"`\n\tNodeType        string    `gorm:\"column:node_type\"`\n\tCreated         time.Time `gorm:\"column:created\"`\n\tUpdated         time.Time `gorm:\"column:updated\"`\n\tPerformanceRank string    `gorm:\"column:perf_rank\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 77,
        "code_end_line": 79,
        "code_key": "TableName",
        "code_value": "func (DmPhydisk) TableName() string {\n\treturn \"dm_phydisk\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/repo/impl/phy.go:30:38:FindById": {
    "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/repo/impl/phy.go",
    "code_start_line": 30,
    "code_end_line": 38,
    "code_start_column": 42,
    "code_key": "FindById",
    "code_value": "func (phyImpl *PhysicalVolumeRepository) FindById(ctx context.Context, id common.ID) *models.DmPhydisk {\n\tvar record = models.DmPhydisk{}\n\ttx := phyImpl.DB.Find(&record, id)\n\tif tx.Error != nil {\n\t\tlogs.Error(ctx).Err(tx.Error).Uint64(\"id\", uint64(id)).Msg(\"FIND_DM_PHY_RECORD_BY_ID_ERROR\")\n\t\treturn nil\n\t}\n\treturn &record\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 65,
        "code_end_line": 82,
        "code_key": "DmPhydisk",
        "code_value": "type DmPhydisk struct {\n\tID         uint64    `gorm:\"column:id;primaryKey\"`\n\tSerial     string    `gorm:\"column:serial;unique\"`\n\tIP         string    `gorm:\"column:host_ip\"`\n\tBDF        string    `gorm:\"column:bdf\"`\n\tDiskID     uint64    `gorm:\"column:disk_id\"`\n\tPort       int       `gorm:\"column:port\"`\n\tStatus     int       `gorm:\"column:status\"`\n\tSize       uint32    `gorm:\"column:size\"`\n\tRealSize   int64     `gorm:\"column:real_size\"`\n\tBlockSize  int       `gorm:\"column:block_size\"`\n\tZoneID     uint64    `gorm:\"column:zone_id\"`\n\tVolumeType string    `gorm:\"column:volume_type\"`\n\tExtra      string    `gorm:\"column:extra\"`\n\tCreated    time.Time `gorm:\"column:created\"`\n\tUpdated    time.Time `gorm:\"column:updated\"`\n\tPerfRank   string    `gorm:\"column:perf_rank\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 85,
        "code_end_line": 87,
        "code_key": "TableName",
        "code_value": "func (d *DmPhydisk) TableName() string {\n\treturn \"dm_phydisk\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 90,
        "code_end_line": 92,
        "code_key": "DBName",
        "code_value": "func (d *DmPhydisk) DBName() string {\n\treturn \"metadb\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 57,
        "code_end_line": 75,
        "code_key": "DmPhydisk",
        "code_value": "type DmPhydisk struct {\n\tID              uint64    `gorm:\"column:id;primaryKey\"`\n\tSerial          string    `gorm:\"column:serial;unique\"`\n\tIP              string    `gorm:\"column:host_ip\"`\n\tBDF             string    `gorm:\"column:bdf\"`\n\tDiskID          uint64    `gorm:\"column:disk_id\"`\n\tPort            int       `gorm:\"column:port\"`\n\tStatus          int       `gorm:\"column:status\"`\n\tSize            int64     `gorm:\"column:size\"`\n\tRealSize        int64     `gorm:\"column:real_size\"`\n\tBlockSize       int       `gorm:\"column:block_size\"`\n\tZoneID          int64     `gorm:\"column:zone_id\"`\n\tVolumeType      string    `gorm:\"column:volume_type\"`\n\tExtra           string    `gorm:\"column:extra\"`\n\tNodeType        string    `gorm:\"column:node_type\"`\n\tCreated         time.Time `gorm:\"column:created\"`\n\tUpdated         time.Time `gorm:\"column:updated\"`\n\tPerformanceRank string    `gorm:\"column:perf_rank\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 77,
        "code_end_line": 79,
        "code_key": "TableName",
        "code_value": "func (DmPhydisk) TableName() string {\n\treturn \"dm_phydisk\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/repo/impl/dmg.go:19:27:FindById": {
    "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/repo/impl/dmg.go",
    "code_start_line": 19,
    "code_end_line": 27,
    "code_start_column": 38,
    "code_key": "FindById",
    "code_value": "func (d *DiskBindAffinityRepository) FindById(ctx context.Context, id uint64) *models.DmDrgroupMembers {\n\trecord := models.DmDrgroupMembers{}\n\ttx := d.DB.First(&record, id)\n\tif tx.Error != nil {\n\t\tlogs.Error(ctx).Err(tx.Error).Uint64(\"id\", id).Msg(\"GET_DM_GROUP_MEMBER_FAILED\")\n\t\treturn nil\n\t}\n\treturn &record\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 39,
        "code_end_line": 49,
        "code_key": "DmDrgroupMembers",
        "code_value": "type DmDrgroupMembers struct {\n\tID        uint64    `gorm:\"column:id;primaryKey\"`                                                          // 主键 ID\n\tAppID     int64     `gorm:\"column:app_id;index:dm_drgroup_members_app_id_group_name_member_id,unique\"`     // AppID\n\tGroupName string    `gorm:\"column:group_name;index:dm_drgroup_members_app_id_group_name_member_id,unique\"` // DRGroup 名称，用户名下唯一\n\tSubGroup  string    `gorm:\"column:sub_group\"`                                                              // 子组名称\n\tLoc       string    `gorm:\"column:loc\"`                                                                    // 位置信息，例如母机 IP\n\tMemberID  string    `gorm:\"column:member_id;index:dm_drgroup_members_app_id_group_name_member_id,unique\"`  // DRGroup 成员 ID，例如逻辑卷 UUID\n\tExtra     string    `gorm:\"column:extra\"`                                                                  // 额外信息\n\tCreated   time.Time `gorm:\"column:created\"`\n\tUpdated   time.Time `gorm:\"column:updated\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 55,
        "code_end_line": 57,
        "code_key": "TableName",
        "code_value": "func (DmDrgroupMembers) TableName() string {\n\treturn \"dm_drgroup_members\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 51,
        "code_end_line": 53,
        "code_key": "DBName",
        "code_value": "func (m DmDrgroupMembers) DBName() string {\n\treturn \"metadb\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 135,
        "code_end_line": 145,
        "code_key": "DmDrgroupMembers",
        "code_value": "type DmDrgroupMembers struct {\n\tID        uint64    `gorm:\"column:id;primaryKey\"`                                                          // 主键 ID\n\tAppID     int64     `gorm:\"column:app_id;index:dm_drgroup_members_app_id_group_name_member_id,unique\"`     // AppID\n\tGroupName string    `gorm:\"column:group_name;index:dm_drgroup_members_app_id_group_name_member_id,unique\"` // DRGroup 名称，用户名下唯一\n\tSubGroup  string    `gorm:\"column:sub_group\"`                                                              // 子组名称\n\tLoc       string    `gorm:\"column:loc\"`                                                                    // 位置信息，例如母机 IP\n\tMemberID  string    `gorm:\"column:member_id;index:dm_drgroup_members_app_id_group_name_member_id,unique\"`  // DRGroup 成员 ID，例如逻辑卷 UUID\n\tExtra     string    `gorm:\"column:extra\"`                                                                  // 额外信息\n\tCreated   time.Time `gorm:\"column:created\"`\n\tUpdated   time.Time `gorm:\"column:updated\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 147,
        "code_end_line": 149,
        "code_key": "TableName",
        "code_value": "func (DmDrgroupMembers) TableName() string {\n\treturn \"dm_drgroup_members\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/benchmark.go:32:39:Delete": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/benchmark.go",
    "code_start_line": 32,
    "code_end_line": 39,
    "code_start_column": 43,
    "code_key": "Delete",
    "code_value": "func (repo *rdiskBenchmarkRepositoryImpl) Delete(ctx context.Context, bench *benchmark.Benchmark) error {\n\tuow := getUow(ctx)\n\tresult := uow.tx.Delete(&metadb.DmRdiskBenchmark{}, \"id = ?\", bench.ID)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/expiremap.go",
        "code_start_line": 91,
        "code_end_line": 96,
        "code_key": "Delete",
        "code_value": "func (e *ExpiredMap) Delete(key interface{}) {\n\te.lck.Lock()\n\tdelete(e.m, key)\n\te.deleteTimeMap(key)\n\te.lck.Unlock()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/scheduler.go",
        "code_start_line": 135,
        "code_end_line": 139,
        "code_key": "Delete",
        "code_value": "func (s *scheduler) Delete(name string) {\n\ts.mutex.Lock()\n\tdefer s.mutex.Unlock()\n\tdelete(s.loads, name)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/benchmark.go",
        "code_start_line": 32,
        "code_end_line": 39,
        "code_key": "Delete",
        "code_value": "func (repo *rdiskBenchmarkRepositoryImpl) Delete(ctx context.Context, bench *benchmark.Benchmark) error {\n\tuow := getUow(ctx)\n\tresult := uow.tx.Delete(&metadb.DmRdiskBenchmark{}, \"id = ?\", bench.ID)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/backup.go",
        "code_start_line": 34,
        "code_end_line": 41,
        "code_key": "Delete",
        "code_value": "func (*rdiskBackupRepositoryImpl) Delete(ctx context.Context, backup *backupPkg.Backup) error {\n\tuow := getUow(ctx)\n\tresult := uow.tx.Delete(&metadb.DmRdiskBackup{}, \"id = ?\", backup.ID)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go",
        "code_start_line": 73,
        "code_end_line": 81,
        "code_key": "Delete",
        "code_value": "func (p *physicalVolumeRepositoryImpl) Delete(ctx context.Context, pv *rdiskDomain.PhysicalVolume) error {\n\tuow := getUow(ctx)\n\tidt := pv.GetID()\n\tresult := uow.tx.Where(\"id = ?\", idt).Delete(&metadb.DmPhydisk{})\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
        "code_start_line": 111,
        "code_end_line": 122,
        "code_key": "Delete",
        "code_value": "func (d drgroupRepositoryImpl) Delete(ctx context.Context, group *drgroup.DRGroup) error {\n\tuow := getUow(ctx)\n\tresult := uow.tx.Delete(&metadb.DmDrgroup{}, \"id = ?\", group.ID)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tresult = uow.tx.Delete(&metadb.DmDrgroupMembers{}, \"app_id = ? and group_name = ?\", group.AppID, group.Name)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 356,
        "code_end_line": 363,
        "code_key": "Delete",
        "code_value": "func (l *LogicalVolume) Delete() error {\n\tif len(l.Attachments) > 0 {\n\t\treturn errors.New(ErrVolumeAttached, \"volume is still attached to some hosts\")\n\t}\n\tl.PhysicalVolume = nil\n\tl.State = LVSDeleted\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 54,
        "code_end_line": 59,
        "code_key": "Delete",
        "code_value": "func (m *MockPhysicalVolumeRepository) Delete(arg0 context.Context, arg1 *rdiskDomain.PhysicalVolume) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Delete\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 62,
        "code_end_line": 65,
        "code_key": "Delete",
        "code_value": "func (mr *MockPhysicalVolumeRepositoryMockRecorder) Delete(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Delete\", reflect.TypeOf((*MockPhysicalVolumeRepository)(nil).Delete), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 54,
        "code_end_line": 59,
        "code_key": "Delete",
        "code_value": "func (m *MockRepository) Delete(arg0 context.Context, arg1 *drgroup.DRGroup) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Delete\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 62,
        "code_end_line": 65,
        "code_key": "Delete",
        "code_value": "func (mr *MockRepositoryMockRecorder) Delete(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Delete\", reflect.TypeOf((*MockRepository)(nil).Delete), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/expiremap.go",
        "code_start_line": 98,
        "code_end_line": 100,
        "code_key": "Remove",
        "code_value": "func (e *ExpiredMap) Remove(key interface{}) {\n\te.Delete(key)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/managers/shm.go",
        "code_start_line": 51,
        "code_end_line": 54,
        "code_key": "Remove",
        "code_value": "func (s *ShmCacheManager) Remove(ctx context.Context, keyResolver cache.GeneralCacheKeyResolverInf) error {\n\ts.m.Delete(keyResolver.GenerateKey(ctx))\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/subgroup.go",
        "code_start_line": 78,
        "code_end_line": 82,
        "code_key": "Remove",
        "code_value": "func (s *SubGroupCacheManager) Remove(ctx context.Context, keyResolver cache.GeneralCacheKeyResolverInf) error {\n\tcacheKey := keyResolver.GenerateKey(ctx)\n\ts.cacheMap.Delete(cacheKey)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/managers/shm.go",
        "code_start_line": 82,
        "code_end_line": 84,
        "code_key": "Pop",
        "code_value": "func (s *ShmCacheManager) Pop(ctx context.Context, keyResolver cache.GeneralCacheKeyResolverInf) (interface{}, error) {\n\tpanic(\"implement me\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/subgroup.go",
        "code_start_line": 104,
        "code_end_line": 117,
        "code_key": "Pop",
        "code_value": "func (s *SubGroupCacheManager) Pop(ctx context.Context, keyResolver cache.GeneralCacheKeyResolverInf) (interface{}, error) {\n\tcacheKey := keyResolver.GenerateKey(ctx)\n\tif ok, disks := s.cacheMap.Get(cacheKey); ok {\n\t\tniceDisks := disks.([]*disk.Disk)\n\t\toneDisk := niceDisks[0]\n\t\tif len(niceDisks) > 1 {\n\t\t\ts.cacheMap.Set(cacheKey, niceDisks[1:], s.expiredSeconds)\n\t\t} else {\n\t\t\ts.cacheMap.Delete(cacheKey)\n\t\t}\n\t\treturn oneDisk, nil\n\t}\n\treturn nil, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/queue/priority_queue.go",
        "code_start_line": 35,
        "code_end_line": 42,
        "code_key": "Pop",
        "code_value": "func (pq *PriorityQueue) Pop() any {\n\told := pq.Task\n\tn := len(old)\n\titem := old[n-1]\n\told[n-1] = nil // avoid memory leak\n\tpq.Task = old[0 : n-1]\n\treturn item\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/queue/priority_queue.go",
        "code_start_line": 56,
        "code_end_line": 60,
        "code_key": "Pop",
        "code_value": "func (spq *SyncTaskPriorityQueue) Pop() interfaces.Task {\n\tspq.mutex.Lock()\n\tdefer spq.mutex.Unlock()\n\treturn heap.Pop(spq.priorityQueue).(interfaces.Task)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go",
        "code_start_line": 51,
        "code_end_line": 72,
        "code_key": "Handle",
        "code_value": "func (c *CbsAppIdConsumer) Handle(ctx context.Context, delivery *rabbitmq.Delivery) error {\n\tu, chargeTime, err := c.ParseDelivery(ctx, delivery)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif u == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"USER_INFO_NOT_FOUND\")\n\t\treturn nil\n\t}\n\n\tchargeDetail := c.GetChargeDetailForSingleUser(u, chargeTime)\n\tif chargeDetail == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tUint64(\"appId\", uint64(u.AppId)).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"NO_RESOURCE_TO_CHARGE\")\n\t\treturn nil\n\t}\n\treturn c.ProcessChargeDetail(chargeDetail)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 105,
        "code_end_line": 116,
        "code_key": "Handle",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tif err := c.ensureLocks(ctx); err != nil {\n\t\treturn err\n\t}\n\tif c.lvUUID != nil {\n\t\t// 涉及到逻辑卷时，需要先标记逻辑卷为故障\n\t\treturn c.handleBindedVolume(ctx)\n\t} else {\n\t\t// 不涉及到逻辑卷时，直接标记物理卷为故障\n\t\treturn c.handleIdleVolume(ctx)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/detach_logical_volume.go",
        "code_start_line": 56,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *DetachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDetachLogicalVolume, c)\n\n\t// 如果没有挂载到指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume not attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_benchmark_task.go",
        "code_start_line": 125,
        "code_end_line": 165,
        "code_key": "Handle",
        "code_value": "func (c *CreateBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tvolSm     = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = volSm.Fire(ctx, c.relatedVolume.State, domain.PVEStartBenchmark, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark = benchmark.New(benchmark.DiskInfo{\n\t\tSerial: string(c.relatedVolume.Serial),\n\t\tHostIP: c.relatedVolume.IP,\n\t\tBDF:    string(c.relatedVolume.BDF),\n\t})\n\n\tif err = benchRepo.Add(ctx, c.relatedBenchmark); err != nil {\n\t\tdelegate := &benchmarkDelegate{cmd: c}\n\t\tif _err := delegate.TaskFinishCallback(ctx, c.relatedBenchmark); _err != nil {\n\t\t\tlogs.Warn(ctx).Err(_err).Str(\"serial\", string(c.relatedVolume.Serial)).Msg(\"failed to rollback: create bdev\")\n\t\t}\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventCreateBench,\n\t\tbenchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_logical_volume.go",
        "code_start_line": 71,
        "code_end_line": 108,
        "code_key": "Handle",
        "code_value": "func (d *DeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\td.volume, err = repo.FindByID(ctx, d.UUID)\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif e := d.volume.CheckDelete(); e != nil {\n\t\treturn e\n\t}\n\n\tif d.volume.AppID != d.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"refuse to delet: app id mismatch\")\n\t}\n\n\td.drgroup, err = app.GetRegistry(ctx).Repositories.DRGroup.FindByMember(ctx, d.AppID, d.volume.UUID.String())\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\td.drgroup = nil\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := d.checkDRGroupMatch(ctx); err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, d.volume.State, rdiskDomain.LVEMarkToRecycle, d)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_recycled_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmRecycledPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEConfirmRecycled, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_rdisk_backup.go",
        "code_start_line": 52,
        "code_end_line": 75,
        "code_key": "Handle",
        "code_value": "func (c *DeleteRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tsm   = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\tc.relatedBackup, err = repo.FindByUUID(ctx, c.BackupID.String())\n\tif err != nil || c.relatedBackup == nil || c.relatedBackup.AppID != c.AppID {\n\t\treturn errors.New(backupDomain.ErrBackupNotExist, \"backup not exists\")\n\t}\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tc.relatedBackup.Status,\n\t\tbackupDomain.EventSoftDeleteBackup,\n\t\tbackupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: c.relatedBackup})\n\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_rdisk_backup.go",
        "code_start_line": 47,
        "code_end_line": 80,
        "code_key": "Handle",
        "code_value": "func (c *CreateRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tlvSm  = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\tbakSm = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo  = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t_, err = lvSm.Fire(ctx, c.relatedVolume.State, rdiskDomain.LVEBackupStarted, c)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tlv := c.relatedVolume\n\tbackup := backupDomain.New(\n\t\tlv.AppID,\n\t\tbackupDomain.DiskInfo{\n\t\t\tVolumeUUID: lv.UUID,\n\t\t\tVolumeSize: uint64(lv.Size),\n\t\t\tHostIP:     lv.PhysicalVolume.IP,\n\t\t\tHostBDF:    string(lv.PhysicalVolume.BDF),\n\t\t\tSerial:     string(lv.PhysicalVolume.Serial),\n\t\t},\n\t)\n\tif err := repo.Add(ctx, backup); err != nil {\n\t\treturn err\n\t}\n\tc.relatedBackup = backup\n\t_, err = bakSm.Fire(ctx, backupDomain.StatusInit, backupDomain.EventStartBackup, backupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: backup})\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/attach_logical_volume.go",
        "code_start_line": 49,
        "code_end_line": 71,
        "code_key": "Handle",
        "code_value": "func (c *AttachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEAttachLogicalVolume, c)\n\n\t// 如果已经挂载到了指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeAlreadyAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume already attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_delete_logical_volume.go",
        "code_start_line": 34,
        "code_end_line": 55,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\t// 如果逻辑卷不存在，则直接返回成功\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"failed to confirm delete: app id mismatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDeleteLogicalVolume, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/offline_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OfflinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOfflinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *DeletePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\t// 如果物理卷不存在，则直接幂等返回\n\t\treturn nil\n\t}\n\n\tvar event = domain.PVEDeletePhysicalVolume\n\tif c.Force && (c.relatedVolume.State == domain.PVSDefunct) {\n\t\t// 这里的实现不太好，状态机的逻辑不应该侵入 cmd\n\t\t// 时间太赶了，后续重构优化吧\n\t\tevent = domain.PVEForceDeleteForDefunct\n\t}\n\n\tif c.relatedVolume.HasBindedPV() {\n\t\treturn errors.New(domain.ErrVolumeBusy, \"logic volume has binded to this physical volume\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, event, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_logical_volume.go",
        "code_start_line": 55,
        "code_end_line": 70,
        "code_key": "Handle",
        "code_value": "func (c *CleanupLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVECleanupLogicalVolume, c)\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_init_physical_volume.go",
        "code_start_line": 26,
        "code_end_line": 52,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmInitPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\tif c.relatedVolume.IP.String() != c.Host.String() {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume host ip mistmatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVECreatePhysicalVolumeOnHost, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_physical_volume.go",
        "code_start_line": 51,
        "code_end_line": 101,
        "code_key": "Handle",
        "code_value": "func (c *CreatePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\n\t// 获取物理卷状态机\n\tsm := app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\trepo := app.GetRegistry(ctx).Repositories.PhysicalVolume\n\n\t// 检查物理卷是否已经存在，如果存在则直接幂等返回\n\tvol1, err := repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"serial\", c.Serial).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tvol2, err := repo.FindByIPAndBDF(ctx, c.Host, domain.BDF(c.BDF))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"host\", c.Host.String()).Str(\"bdf\", c.BDF).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tfor _, vol := range []*domain.PhysicalVolume{vol1, vol2} {\n\t\texisted, err := c.checkExisting(ctx, vol)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif existed {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// 触发事件，创建物理卷\n\t_, err = sm.Fire(ctx,\n\t\tdomain.PVSUnInited,\n\t\tdomain.PVECreatePhysicalVolume,\n\t\tc,\n\t)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 创建 Bdev 以及格式化移动到创建物理卷的状态机中\n\n\t// _, err = sm.Fire(ctx,\n\t// \tc.GetPhysicalVolume().State,\n\t// \tdomain.PVECreatePhysicalVolumeOnHost,\n\t// \tc,\n\t// )\n\t// if err != nil {\n\t// \treturn err\n\t// }\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_benchmark_task.go",
        "code_start_line": 32,
        "code_end_line": 57,
        "code_key": "Handle",
        "code_value": "func (c *DeleteBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\terr       error\n\t)\n\n\tbench, err := benchRepo.FindByUUID(ctx, c.BenchmarkUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif bench.DiskInfo.Serial != c.Serial {\n\t\treturn errors.Newf(benchmark.ErrTaskNotFound, \"benchmark serial not match %s, want %s\", c.Serial, bench.DiskInfo.Serial)\n\t}\n\n\t_, err = benchSm.Fire(ctx, bench.Status, benchmark.EventDeleteBench, benchmark.Data{Benchmark: bench, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := benchRepo.Delete(ctx, bench); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_logical_volume.go",
        "code_start_line": 52,
        "code_end_line": 98,
        "code_key": "Handle",
        "code_value": "func (c *CreateLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tpvRepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tlvRepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm     = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\t// 1. 查找底层物理卷\n\tc.selectedPhysicalVolume, err = pvRepo.FindBySerial(ctx, rdiskDomain.Serial(c.PhysicalVolumeSerial))\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// 检查底层物理卷大小是否满足要求\n\tif c.selectedPhysicalVolume.Size < rdiskDomain.Size(c.DiskSize) {\n\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume size %d is smaller than requested size %d\", c.selectedPhysicalVolume.Size, c.DiskSize)\n\t}\n\n\t// 检查底层物理卷性能等级是否满足要求\n\tif c.PerformanceRank != \"\" {\n\t\tif string(c.selectedPhysicalVolume.PerformanceRank) != c.PerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not match requested rank %s\", c.selectedPhysicalVolume.PerformanceRank, c.PerformanceRank)\n\t\t}\n\t} else {\n\t\tif c.selectedPhysicalVolume.PerformanceRank != rdiskDomain.DefaultPerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not default rank %s\", c.selectedPhysicalVolume.PerformanceRank, rdiskDomain.DefaultPerformanceRank)\n\t\t}\n\t}\n\n\t// 2. 创建逻辑卷\n\tvol := rdiskDomain.NewLogicalVolume(users.AppID(c.AppID), rdiskDomain.Size(c.DiskSize), rdiskDomain.ZoneID(c.ZoneID))\n\tif c.VolumeType != \"\" {\n\t\tvol.VolumeType = rdiskDomain.VolumeType(c.VolumeType)\n\t}\n\tif c.DiskType != \"\" {\n\t\tvol.DiskType = rdiskDomain.DiskType(c.DiskType)\n\t}\n\terr = lvRepo.Add(ctx, vol)\n\tif err != nil {\n\t\treturn\n\t}\n\tc.createdLogicalVolume = vol\n\n\t// 3. 触发状态机，联动更新逻辑卷和物理卷状态\n\t_, err = sm.Fire(ctx, rdiskDomain.LVSUnInited, rdiskDomain.LVECreateLogicalVolume, c)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_running_backup_task.go",
        "code_start_line": 31,
        "code_end_line": 61,
        "code_key": "Handle",
        "code_value": "func (c *UpdateRunningBackupTaskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventUpdateBackupProgress,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_drgroup.go",
        "code_start_line": 78,
        "code_end_line": 173,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeDRGroupCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tlvView  = app.GetRegistry(ctx).Viewers.LogicalVolume\n\t\tdrgRepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t\tsm      = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\terr     error\n\t)\n\n\t// 0. 初始化\n\tc.drgroupRef = make(map[string]*drgroup.DRGroup)\n\n\t// 1. 加载所有逻辑卷所在的置放群组\n\tallVolumeUUIDs := make([]string, 0, len(c.UUIDs))\n\tfor _, _uuid := range c.UUIDs {\n\t\tallVolumeUUIDs = append(allVolumeUUIDs, _uuid.String())\n\t}\n\tif groups, err := drgRepo.FindByMembers(ctx, c.AppID, allVolumeUUIDs); err == nil {\n\t\tif err != nil {\n\t\t\tif !errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tfor _, group := range groups {\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t\tc.curDRGroupNames = append(c.curDRGroupNames, group.Name)\n\t\t}\n\t} else {\n\t\treturn err\n\t}\n\n\t// 2. 确认已上锁的置放群组和当前一致\n\tif !c.checkLockedDRGroupNames() {\n\t\treturn errors.New(drgroup.ErrGroupModified, \"drgroup changed\")\n\t}\n\n\t// 3. 加载所有逻辑卷的状态，不需要完整实体，因为不会修改 Volume\n\tc.relatedLogicalVolume, err = lvView.FindByIDs(ctx, c.AppID, c.UUIDs)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(c.relatedLogicalVolume) < len(c.UUIDs) {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t// 4. 加载所有目标置放群组，key 为 name\n\tfor _, spec := range c.Specs {\n\t\tvar group *drgroup.DRGroup\n\t\tif _, ok := c.drgroupRef[spec.Name]; ok {\n\t\t\tgroup = c.drgroupRef[spec.Name]\n\t\t} else {\n\t\t\tgroup, err = c.getOrCreateDRGroup(ctx, drgRepo, spec)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t}\n\n\t\tif spec.Affinity > 0 {\n\t\t\tgroup.Affinity = spec.Affinity\n\t\t}\n\t\tif spec.Type != \"\" {\n\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t}\n\t}\n\n\t// 5. 对所有逻辑卷执行置放群组变更事件，检查状态是否允许，\n\t//    实际的更新还是在这里执行。\n\tfor _, vol := range c.relatedLogicalVolume {\n\t\terr := sm.Check(ctx, vol.State, rdiskDomain.LVEUpdateDrGroup, c)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// 将逻辑卷从原有的置放群组中移除\n\t\tfor _, name := range c.curDRGroupNames {\n\t\t\tc.drgroupRef[name].RemoveMember(vol.UUID.String())\n\t\t}\n\t\t// 将逻辑卷添加到新的置放群组中\n\t\tfor _, spec := range c.Specs {\n\t\t\tsubGroup := spec.SubGroup\n\t\t\tif subGroup == \"\" {\n\t\t\t\t// 如果没有指定子组，则使用远端 SSD UUID 作为子组名称\n\t\t\t\t// 相当于每块盘都是一个子组，相当于没有使用子组功能\n\t\t\t\tsubGroup = vol.UUID.String()\n\t\t\t}\n\t\t\tif err := c.drgroupRef[spec.Name].AddMember(vol.UUID.String(), subGroup, vol.PhysicalVolume.IP.String()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tif c.DryRun {\n\t\treturn errors.New(errors.ErrDryRunSuccessExit, \"dry run check success\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/online_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OnlinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOnlinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_benchmark_task.go",
        "code_start_line": 34,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *UpdateBenchmarkTask) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, rdisk.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark, err = benchRepo.FindByUUID(ctx, c.BenchmarkUUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventUpdateBench, benchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_flow_ctrl.go",
        "code_start_line": 80,
        "code_end_line": 103,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeFlowControlCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not found\")\n\t}\n\n\tspec := c.volume.FlowControlSpec\n\tif !c.UpdateRequest.UpdateSpec(&spec, c.volume.GetDefaultFlowControlSpec()) {\n\t\t// 没有任何更新，直接返回成功\n\t\treturn nil\n\t}\n\tc.volume.SetFlowControlSpec(spec)\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEUpdateFlowControl, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_defunct_volume.go",
        "code_start_line": 46,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *CleanupDefunctCommand) Handle(ctx context.Context) error {\n\tvar err error\n\tc.lv, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar sm = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\tvar event = rdiskDomain.LVECleanupDefunct\n\n\tfor _, attachment := range c.lv.Attachments {\n\t\tlogs.Info(ctx).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).Msg(\"cleanup defuncting volume\")\n\t\tsubCmd := &cleanDefunctSubCommand{Parent: c, HostIP: attachment.IP}\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, subCmd)\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，因为只要有一个挂载点清理失败，其他挂载点还是需要继续清理的\n\t\t\t// 失败的挂载点会在后台继续清理\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).\n\t\t\t\tMsg(\"failed to cleanup defunct volume, retry later.\")\n\t\t}\n\t}\n\n\tif len(c.lv.Attachments) == 0 {\n\t\t// 没有挂载点，直接清理\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, &cleanDefunctSubCommand{Parent: c, HostIP: net.IP{}})\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，后续自动重试即可\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Msg(\"failed to complete cleanup defunct volume\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_drgroup_exists.go",
        "code_start_line": 28,
        "code_end_line": 53,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDRGroupExistsCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t)\n\tfor _, spec := range c.DRGroup {\n\t\t_, err := repo.FindByName(ctx, users.AppID(c.AppID), spec.Name)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\tgroup := drgroup.New(spec.Name, users.AppID(c.AppID))\n\t\t\t\tif spec.Affinity > 0 {\n\t\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t\t}\n\t\t\t\tif spec.Type != \"\" {\n\t\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t\t}\n\t\t\t\terr = repo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_physical_volume.go",
        "code_start_line": 31,
        "code_end_line": 54,
        "code_key": "Handle",
        "code_value": "func (c *UpdatePhyRDiskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEUpdatePhysicalVolume, c)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/recycle_backup_data.go",
        "code_start_line": 32,
        "code_end_line": 62,
        "code_key": "Handle",
        "code_value": "func (c *RecycleBackupDataCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventDeleteBackup,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/clients/cos/client.go",
        "code_start_line": 101,
        "code_end_line": 104,
        "code_key": "DeleteObject",
        "code_value": "func (c *clientImpl) DeleteObject(ctx context.Context, key string) error {\n\t_, err := c.c.Object.Delete(ctx, key)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go",
        "code_start_line": 208,
        "code_end_line": 215,
        "code_key": "deleteFinishTask",
        "code_value": "func (sc *Scheduler) deleteFinishTask(ctx context.Context, task interfaces.Task) {\n\tsubTaskName := task.GetSubTaskName()\n\tif _, ok := sc.metrics.taskExecuteCountMap[subTaskName]; !ok {\n\t\tsc.metrics.taskExecuteCountMap[subTaskName], _ = initHistogramVec(subTaskName).GetMetricWith(sc.metrics.labels)\n\t}\n\tsc.metrics.taskExecuteCountMap[subTaskName].Observe(float64(task.GetExecuteCounts()))\n\tsc.taskMap.Delete(task.GetTaskId())\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_physical_volume.go",
        "code_start_line": 113,
        "code_end_line": 131,
        "code_key": "checkExisting",
        "code_value": "func (c *CreatePhysicalVolumeCommand) checkExisting(ctx context.Context, vol *domain.PhysicalVolume) (existed bool, err error) {\n\tif vol == nil {\n\t\treturn false, nil\n\t}\n\tif vol.Deleted() {\n\t\terr := app.GetRegistry(ctx).Repositories.PhysicalVolume.Delete(ctx, vol)\n\t\tif err != nil {\n\t\t\treturn false, errors.Newf(domain.ErrConflictVolume, \"failed to delete conflict physical volume: %v\", err)\n\t\t}\n\t\treturn false, nil\n\t}\n\tif string(vol.Serial) != c.Serial {\n\t\treturn false, errors.Newf(domain.ErrConflictVolume, \"host %s bdf %s has been taken by %s\", vol.IP, vol.BDF, vol.Serial)\n\t}\n\tif !vol.IP.Equal(c.Host) || string(vol.BDF) != c.BDF {\n\t\treturn false, errors.Newf(domain.ErrConflictVolume, \"volume %s has been assigned to host %s bdf %s\", vol.Serial, vol.IP, vol.BDF)\n\t}\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/create_logic_disk.go",
        "code_start_line": 61,
        "code_end_line": 63,
        "code_key": "InvokeDeleteLogicalVolume",
        "code_value": "func InvokeDeleteLogicalVolume(ctx context.Context, source rdiskDomain.LogicalVolumeState, target rdiskDomain.LogicalVolumeState, stateCtx app.LogicalVolumeContext) (rdiskDomain.LogicalVolumeState, error) {\n\treturn target, stateCtx.GetLogicalVolume().Delete()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go",
        "code_start_line": 199,
        "code_end_line": 305,
        "code_key": "updateLogicalVolume",
        "code_value": "func updateLogicalVolume(ctx context.Context, item, originalState *rdiskDomain.LogicalVolume) error {\n\tuow := getUow(ctx)\n\tcurDO := fromModelToDmRDisk(item)\n\toriginalDO := fromModelToDmRDisk(originalState)\n\tchanges := make(map[string]interface{})\n\tcheckChange := func(field string, cur interface{}, original interface{}) {\n\t\tif cur != original {\n\t\t\tchanges[field] = cur\n\t\t}\n\t}\n\tcheckChange(\"uuid\", curDO.UUID, originalDO.UUID)\n\tcheckChange(\"status\", curDO.Status, originalDO.Status)\n\tcheckChange(\"app_id\", curDO.AppID, originalDO.AppID)\n\tcheckChange(\"size\", curDO.Size, originalDO.Size)\n\tcheckChange(\"phydisk_serial\", curDO.PhydiskSerial, originalDO.PhydiskSerial)\n\tcheckChange(\"zone_id\", curDO.ZoneID, originalDO.ZoneID)\n\tcheckChange(\"volume_type\", curDO.VolumeType, originalDO.VolumeType)\n\tcheckChange(\"disk_type\", curDO.DiskType, originalDO.DiskType)\n\tcheckChange(\"read_iops\", curDO.ReadIOPS, originalDO.ReadIOPS)\n\tcheckChange(\"write_iops\", curDO.WriteIOPS, originalDO.WriteIOPS)\n\tcheckChange(\"rw_iops\", curDO.ReadWriteIOPS, originalDO.ReadWriteIOPS)\n\tcheckChange(\"read_bandwidth\", curDO.ReadBandwidth, originalDO.ReadBandwidth)\n\tcheckChange(\"write_bandwidth\", curDO.WriteBandwidth, originalDO.WriteBandwidth)\n\tcheckChange(\"rw_bandwidth\", curDO.ReadWriteBandwidth, originalDO.ReadWriteBandwidth)\n\n\tif len(changes) != 0 {\n\t\tchanges[\"updated\"] = uow.tx.NowFunc()\n\n\t\tresult := uow.tx.Model(curDO).Where(\"id = ?\", curDO.ID).Updates(changes)\n\t\tif result.Error != nil {\n\t\t\treturn result.Error\n\t\t}\n\t}\n\n\t// 更新挂载信息\n\n\tallHosts := make(map[string]struct{})\n\toriginHosts := make(map[string]*rdiskDomain.VolumeAttachment)\n\tcurHosts := make(map[string]*rdiskDomain.VolumeAttachment)\n\tfor _, a := range item.Attachments {\n\t\tallHosts[a.IP.String()] = struct{}{}\n\t\tcurHosts[a.IP.String()] = a\n\t}\n\tfor _, a := range originalState.Attachments {\n\t\tallHosts[a.IP.String()] = struct{}{}\n\t\toriginHosts[a.IP.String()] = a\n\t}\n\n\tfor hostIp := range allHosts {\n\t\tcurAttachment, _ := curHosts[hostIp]\n\t\toriginAttachment, _ := originHosts[hostIp]\n\t\tif originAttachment == nil && curAttachment != nil {\n\t\t\t// 新增挂载\n\t\t\tdo := fromModelToDmRDiskAttachment(curAttachment)\n\t\t\tdo.UUID = curDO.UUID\n\t\t\tdo.Created = uow.tx.NowFunc()\n\t\t\tdo.Updated = uow.tx.NowFunc()\n\t\t\terr := uow.tx.Model(curDO).Association(\"Attachments\").Append(do)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else if originAttachment != nil && curAttachment == nil {\n\t\t\t// 删除挂载\n\t\t\tdo := fromModelToDmRDiskAttachment(originAttachment)\n\t\t\tdo.UUID = curDO.UUID\n\t\t\tresult := uow.tx.Where(\"host_ip = ? and uuid = ?\", do.IP, do.UUID).Delete(do)\n\t\t\tif result.Error != nil {\n\t\t\t\treturn result.Error\n\t\t\t}\n\t\t} else if originAttachment != nil && curAttachment != nil {\n\t\t\t// 更新挂载\n\t\t\tdo := fromModelToDmRDiskAttachment(curAttachment)\n\t\t\tdo.UUID = curDO.UUID\n\t\t\toriginDo := fromModelToDmRDiskAttachment(originAttachment)\n\t\t\toriginDo.UUID = curDO.UUID\n\t\t\tchanges := make(map[string]interface{})\n\t\t\tcheckChange := func(field string, cur interface{}, original interface{}) {\n\t\t\t\tif cur != original {\n\t\t\t\t\tchanges[field] = cur\n\t\t\t\t}\n\t\t\t}\n\t\t\tcheckChange(\"mode\", do.Mode, originDo.Mode)\n\t\t\tcheckChange(\"read_iops\", do.ReadIOPS, originDo.ReadIOPS)\n\t\t\tcheckChange(\"write_iops\", do.WriteIOPS, originDo.WriteIOPS)\n\t\t\tcheckChange(\"rw_iops\", do.ReadWriteIOPS, originDo.ReadWriteIOPS)\n\t\t\tcheckChange(\"read_bandwidth\", do.ReadBandwidth, originDo.ReadBandwidth)\n\t\t\tcheckChange(\"write_bandwidth\", do.WriteBandwidth, originDo.WriteBandwidth)\n\t\t\tcheckChange(\"rw_bandwidth\", do.ReadWriteBandwidth, originDo.ReadWriteBandwidth)\n\t\t\tcheckChange(\"num_queue\", do.NumQueue, originDo.NumQueue)\n\t\t\tcheckChange(\"serial\", do.Serial, originDo.Serial)\n\t\t\tcheckChange(\"vcpu\", do.VCPU, originDo.VCPU)\n\t\t\tcheckChange(\"spdk_driver\", do.SPDKDriver, originDo.SPDKDriver)\n\n\t\t\tif len(changes) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tchanges[\"updated\"] = uow.tx.NowFunc()\n\t\t\tresult := uow.tx.Model(do).Where(\"host_ip = ? and uuid = ?\", do.IP, do.UUID).Updates(changes)\n\t\t\tif result.Error != nil {\n\t\t\t\treturn result.Error\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
        "code_start_line": 165,
        "code_end_line": 277,
        "code_key": "updateDRGroup",
        "code_value": "func updateDRGroup(ctx context.Context, item, originalState *drgroup.DRGroup) error {\n\tuow := getUow(ctx)\n\tcurDO := fromModelToDmDRGroup(item)\n\toriginalDO := fromModelToDmDRGroup(originalState)\n\tchanges := make(map[string]interface{})\n\tcheckChange := func(field string, cur interface{}, original interface{}) {\n\t\tif cur != original {\n\t\t\tif field == \"member_cnt\" || field == \"sub_group_cnt\" {\n\t\t\t\tdiff := cur.(int) - original.(int)\n\t\t\t\tif diff < 0 {\n\t\t\t\t\tchanges[field] = gorm.Expr(fmt.Sprintf(\"%s - %d\", field, -1*diff))\n\t\t\t\t} else {\n\t\t\t\t\tchanges[field] = gorm.Expr(fmt.Sprintf(\"%s + %d\", field, diff))\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tchanges[field] = cur\n\t\t\t}\n\t\t}\n\t}\n\tcheckChange(\"status\", curDO.Status, originalDO.Status)\n\tcheckChange(\"app_id\", curDO.AppID, originalDO.AppID)\n\tcheckChange(\"name\", curDO.Name, originalDO.Name)\n\tcheckChange(\"affinity\", curDO.Affinity, originalDO.Affinity)\n\tcheckChange(\"loc_type\", curDO.LocType, originalDO.LocType)\n\tcheckChange(\"satisfied\", curDO.Satisfied, originalDO.Satisfied)\n\tcheckChange(\"member_cnt\", curDO.MemberCnt, originalDO.MemberCnt)\n\tcheckChange(\"sub_group_cnt\", curDO.SubGroupCnt, originalDO.SubGroupCnt)\n\tcheckChange(\"extra\", curDO.Extra, originalDO.Extra)\n\n\tif len(changes) != 0 {\n\t\tchanges[\"updated\"] = uow.tx.NowFunc()\n\n\t\tresult := uow.tx.Model(curDO).Where(\"id = ?\", curDO.ID).Updates(changes)\n\t\tif result.Error != nil {\n\t\t\treturn result.Error\n\t\t}\n\t}\n\n\t// 更新成员信息\n\tallMembers := make(map[string]struct{})\n\ttype memberInfo struct {\n\t\tLoc      string\n\t\tSubGroup string\n\t}\n\toriginMembers := make(map[string]memberInfo)\n\tcurMembers := make(map[string]memberInfo)\n\tfor _, a := range item.GetMembers() {\n\t\tallMembers[a.ID] = struct{}{}\n\t\tcurMembers[a.ID] = memberInfo{\n\t\t\tLoc:      a.Location,\n\t\t\tSubGroup: a.SubGroup,\n\t\t}\n\t}\n\tfor _, a := range originalState.GetMembers() {\n\t\tallMembers[a.ID] = struct{}{}\n\t\toriginMembers[a.ID] = memberInfo{\n\t\t\tLoc:      a.Location,\n\t\t\tSubGroup: a.SubGroup,\n\t\t}\n\t}\n\n\tfor memberId := range allMembers {\n\t\tcurInfo, _ := curMembers[memberId]\n\t\toriginInfo, _ := originMembers[memberId]\n\t\tif originInfo.Loc == \"\" && curInfo.Loc != \"\" {\n\t\t\tdo := &metadb.DmDrgroupMembers{\n\t\t\t\tAppID:     int64(item.AppID),\n\t\t\t\tGroupName: item.Name,\n\t\t\t\tSubGroup:  curInfo.SubGroup,\n\t\t\t\tLoc:       curInfo.Loc,\n\t\t\t\tMemberID:  memberId,\n\t\t\t\tExtra:     \"{}\",\n\t\t\t\tCreated:   uow.tx.NowFunc(),\n\t\t\t\tUpdated:   uow.tx.NowFunc(),\n\t\t\t}\n\t\t\tresult := uow.tx.Create(do)\n\t\t\tif result.Error != nil {\n\t\t\t\treturn result.Error\n\t\t\t}\n\t\t} else if originInfo.Loc != \"\" && curInfo.Loc == \"\" {\n\t\t\tresult := uow.tx.Delete(&metadb.DmDrgroupMembers{},\n\t\t\t\t\"app_id = ? and group_name = ? and member_id = ?\",\n\t\t\t\toriginalState.AppID, originalState.Name, memberId)\n\t\t\tif result.Error != nil {\n\t\t\t\treturn result.Error\n\t\t\t}\n\t\t} else if originInfo.Loc != \"\" && curInfo.Loc != \"\" {\n\t\t\tchanges := make(map[string]interface{})\n\t\t\tcheckChange := func(field string, cur interface{}, original interface{}) {\n\t\t\t\tif cur != original {\n\t\t\t\t\tchanges[field] = cur\n\t\t\t\t}\n\t\t\t}\n\t\t\tcheckChange(\"loc\", curInfo.Loc, originInfo.Loc)\n\t\t\tcheckChange(\"app_id\", item.AppID, originalState.AppID)\n\t\t\tcheckChange(\"group_name\", item.Name, originalState.Name)\n\t\t\tcheckChange(\"sub_group\", curInfo.SubGroup, originInfo.SubGroup)\n\t\t\t//checkChange(\"extra\", \"{}\", \"{}\")\n\n\t\t\tif len(changes) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tchanges[\"updated\"] = uow.tx.NowFunc()\n\t\t\tresult := uow.tx.Model(&metadb.DmDrgroupMembers{}).Where(\n\t\t\t\t\"app_id = ? and group_name = ? and member_id = ?\",\n\t\t\t\toriginalState.AppID, originalState.Name, memberId).Updates(changes)\n\t\t\tif result.Error != nil {\n\t\t\t\treturn result.Error\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 176,
        "code_end_line": 193,
        "code_key": "DmRdiskBenchmark",
        "code_value": "type DmRdiskBenchmark struct {\n\tID             uint64    `gorm:\"column:id;primaryKey\"`   // 主键 ID\n\tUUID           string    `gorm:\"column:uuid\"`            // 备份 UUID\n\tPhyID          string    `gorm:\"column:phy_id\"`          // 物理卷 Serial\n\tBDF            string    `gorm:\"column:host_bdf\"`        // 物理盘 BDF 号\n\tError          string    `gorm:\"column:error\"`           // 错误信息\n\tTaskID         int64     `gorm:\"column:task_id\"`         // BlockAgent 任务 ID\n\tHostIP         string    `gorm:\"column:host_ip\"`         // 主机 IP\n\tStatus         int       `gorm:\"column:status\"`          // 备份状态\n\tReadBandwidth  float64   `gorm:\"column:read_bandwidth\"`  // 最大读带宽 in MBps\n\tWriteBandwidth float64   `gorm:\"column:write_bandwidth\"` // 最大写带宽 in MBps\n\tReadLatency    float64   `gorm:\"column:read_latency\"`    // 最大读延迟 in micro second\n\tWriteLatency   float64   `gorm:\"column:write_latency\"`   // 最大写延迟 in micro second\n\tCreated        time.Time `gorm:\"column:created\"`         // 压测创建时间\n\tFinished       time.Time `gorm:\"column:finished\"`        // 压测结束时间\n\tUpdated        time.Time `gorm:\"column:updated\"`         // 数据更新时间\n\tExtra          string    `gorm:\"column:extra\"`           // 额外信息\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 195,
        "code_end_line": 197,
        "code_key": "TableName",
        "code_value": "func (DmRdiskBenchmark) TableName() string {\n\treturn \"dm_phydisk_benchmark\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/backup.go:34:41:Delete": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/backup.go",
    "code_start_line": 34,
    "code_end_line": 41,
    "code_start_column": 35,
    "code_key": "Delete",
    "code_value": "func (*rdiskBackupRepositoryImpl) Delete(ctx context.Context, backup *backupPkg.Backup) error {\n\tuow := getUow(ctx)\n\tresult := uow.tx.Delete(&metadb.DmRdiskBackup{}, \"id = ?\", backup.ID)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/expiremap.go",
        "code_start_line": 91,
        "code_end_line": 96,
        "code_key": "Delete",
        "code_value": "func (e *ExpiredMap) Delete(key interface{}) {\n\te.lck.Lock()\n\tdelete(e.m, key)\n\te.deleteTimeMap(key)\n\te.lck.Unlock()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/scheduler.go",
        "code_start_line": 135,
        "code_end_line": 139,
        "code_key": "Delete",
        "code_value": "func (s *scheduler) Delete(name string) {\n\ts.mutex.Lock()\n\tdefer s.mutex.Unlock()\n\tdelete(s.loads, name)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/benchmark.go",
        "code_start_line": 32,
        "code_end_line": 39,
        "code_key": "Delete",
        "code_value": "func (repo *rdiskBenchmarkRepositoryImpl) Delete(ctx context.Context, bench *benchmark.Benchmark) error {\n\tuow := getUow(ctx)\n\tresult := uow.tx.Delete(&metadb.DmRdiskBenchmark{}, \"id = ?\", bench.ID)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/backup.go",
        "code_start_line": 34,
        "code_end_line": 41,
        "code_key": "Delete",
        "code_value": "func (*rdiskBackupRepositoryImpl) Delete(ctx context.Context, backup *backupPkg.Backup) error {\n\tuow := getUow(ctx)\n\tresult := uow.tx.Delete(&metadb.DmRdiskBackup{}, \"id = ?\", backup.ID)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go",
        "code_start_line": 73,
        "code_end_line": 81,
        "code_key": "Delete",
        "code_value": "func (p *physicalVolumeRepositoryImpl) Delete(ctx context.Context, pv *rdiskDomain.PhysicalVolume) error {\n\tuow := getUow(ctx)\n\tidt := pv.GetID()\n\tresult := uow.tx.Where(\"id = ?\", idt).Delete(&metadb.DmPhydisk{})\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
        "code_start_line": 111,
        "code_end_line": 122,
        "code_key": "Delete",
        "code_value": "func (d drgroupRepositoryImpl) Delete(ctx context.Context, group *drgroup.DRGroup) error {\n\tuow := getUow(ctx)\n\tresult := uow.tx.Delete(&metadb.DmDrgroup{}, \"id = ?\", group.ID)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tresult = uow.tx.Delete(&metadb.DmDrgroupMembers{}, \"app_id = ? and group_name = ?\", group.AppID, group.Name)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 356,
        "code_end_line": 363,
        "code_key": "Delete",
        "code_value": "func (l *LogicalVolume) Delete() error {\n\tif len(l.Attachments) > 0 {\n\t\treturn errors.New(ErrVolumeAttached, \"volume is still attached to some hosts\")\n\t}\n\tl.PhysicalVolume = nil\n\tl.State = LVSDeleted\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 54,
        "code_end_line": 59,
        "code_key": "Delete",
        "code_value": "func (m *MockPhysicalVolumeRepository) Delete(arg0 context.Context, arg1 *rdiskDomain.PhysicalVolume) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Delete\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 62,
        "code_end_line": 65,
        "code_key": "Delete",
        "code_value": "func (mr *MockPhysicalVolumeRepositoryMockRecorder) Delete(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Delete\", reflect.TypeOf((*MockPhysicalVolumeRepository)(nil).Delete), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 54,
        "code_end_line": 59,
        "code_key": "Delete",
        "code_value": "func (m *MockRepository) Delete(arg0 context.Context, arg1 *drgroup.DRGroup) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Delete\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 62,
        "code_end_line": 65,
        "code_key": "Delete",
        "code_value": "func (mr *MockRepositoryMockRecorder) Delete(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Delete\", reflect.TypeOf((*MockRepository)(nil).Delete), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/expiremap.go",
        "code_start_line": 98,
        "code_end_line": 100,
        "code_key": "Remove",
        "code_value": "func (e *ExpiredMap) Remove(key interface{}) {\n\te.Delete(key)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/managers/shm.go",
        "code_start_line": 51,
        "code_end_line": 54,
        "code_key": "Remove",
        "code_value": "func (s *ShmCacheManager) Remove(ctx context.Context, keyResolver cache.GeneralCacheKeyResolverInf) error {\n\ts.m.Delete(keyResolver.GenerateKey(ctx))\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/subgroup.go",
        "code_start_line": 78,
        "code_end_line": 82,
        "code_key": "Remove",
        "code_value": "func (s *SubGroupCacheManager) Remove(ctx context.Context, keyResolver cache.GeneralCacheKeyResolverInf) error {\n\tcacheKey := keyResolver.GenerateKey(ctx)\n\ts.cacheMap.Delete(cacheKey)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/managers/shm.go",
        "code_start_line": 82,
        "code_end_line": 84,
        "code_key": "Pop",
        "code_value": "func (s *ShmCacheManager) Pop(ctx context.Context, keyResolver cache.GeneralCacheKeyResolverInf) (interface{}, error) {\n\tpanic(\"implement me\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/subgroup.go",
        "code_start_line": 104,
        "code_end_line": 117,
        "code_key": "Pop",
        "code_value": "func (s *SubGroupCacheManager) Pop(ctx context.Context, keyResolver cache.GeneralCacheKeyResolverInf) (interface{}, error) {\n\tcacheKey := keyResolver.GenerateKey(ctx)\n\tif ok, disks := s.cacheMap.Get(cacheKey); ok {\n\t\tniceDisks := disks.([]*disk.Disk)\n\t\toneDisk := niceDisks[0]\n\t\tif len(niceDisks) > 1 {\n\t\t\ts.cacheMap.Set(cacheKey, niceDisks[1:], s.expiredSeconds)\n\t\t} else {\n\t\t\ts.cacheMap.Delete(cacheKey)\n\t\t}\n\t\treturn oneDisk, nil\n\t}\n\treturn nil, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/queue/priority_queue.go",
        "code_start_line": 35,
        "code_end_line": 42,
        "code_key": "Pop",
        "code_value": "func (pq *PriorityQueue) Pop() any {\n\told := pq.Task\n\tn := len(old)\n\titem := old[n-1]\n\told[n-1] = nil // avoid memory leak\n\tpq.Task = old[0 : n-1]\n\treturn item\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/queue/priority_queue.go",
        "code_start_line": 56,
        "code_end_line": 60,
        "code_key": "Pop",
        "code_value": "func (spq *SyncTaskPriorityQueue) Pop() interfaces.Task {\n\tspq.mutex.Lock()\n\tdefer spq.mutex.Unlock()\n\treturn heap.Pop(spq.priorityQueue).(interfaces.Task)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go",
        "code_start_line": 51,
        "code_end_line": 72,
        "code_key": "Handle",
        "code_value": "func (c *CbsAppIdConsumer) Handle(ctx context.Context, delivery *rabbitmq.Delivery) error {\n\tu, chargeTime, err := c.ParseDelivery(ctx, delivery)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif u == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"USER_INFO_NOT_FOUND\")\n\t\treturn nil\n\t}\n\n\tchargeDetail := c.GetChargeDetailForSingleUser(u, chargeTime)\n\tif chargeDetail == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tUint64(\"appId\", uint64(u.AppId)).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"NO_RESOURCE_TO_CHARGE\")\n\t\treturn nil\n\t}\n\treturn c.ProcessChargeDetail(chargeDetail)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 105,
        "code_end_line": 116,
        "code_key": "Handle",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tif err := c.ensureLocks(ctx); err != nil {\n\t\treturn err\n\t}\n\tif c.lvUUID != nil {\n\t\t// 涉及到逻辑卷时，需要先标记逻辑卷为故障\n\t\treturn c.handleBindedVolume(ctx)\n\t} else {\n\t\t// 不涉及到逻辑卷时，直接标记物理卷为故障\n\t\treturn c.handleIdleVolume(ctx)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/detach_logical_volume.go",
        "code_start_line": 56,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *DetachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDetachLogicalVolume, c)\n\n\t// 如果没有挂载到指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume not attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_benchmark_task.go",
        "code_start_line": 125,
        "code_end_line": 165,
        "code_key": "Handle",
        "code_value": "func (c *CreateBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tvolSm     = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = volSm.Fire(ctx, c.relatedVolume.State, domain.PVEStartBenchmark, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark = benchmark.New(benchmark.DiskInfo{\n\t\tSerial: string(c.relatedVolume.Serial),\n\t\tHostIP: c.relatedVolume.IP,\n\t\tBDF:    string(c.relatedVolume.BDF),\n\t})\n\n\tif err = benchRepo.Add(ctx, c.relatedBenchmark); err != nil {\n\t\tdelegate := &benchmarkDelegate{cmd: c}\n\t\tif _err := delegate.TaskFinishCallback(ctx, c.relatedBenchmark); _err != nil {\n\t\t\tlogs.Warn(ctx).Err(_err).Str(\"serial\", string(c.relatedVolume.Serial)).Msg(\"failed to rollback: create bdev\")\n\t\t}\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventCreateBench,\n\t\tbenchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_logical_volume.go",
        "code_start_line": 71,
        "code_end_line": 108,
        "code_key": "Handle",
        "code_value": "func (d *DeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\td.volume, err = repo.FindByID(ctx, d.UUID)\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif e := d.volume.CheckDelete(); e != nil {\n\t\treturn e\n\t}\n\n\tif d.volume.AppID != d.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"refuse to delet: app id mismatch\")\n\t}\n\n\td.drgroup, err = app.GetRegistry(ctx).Repositories.DRGroup.FindByMember(ctx, d.AppID, d.volume.UUID.String())\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\td.drgroup = nil\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := d.checkDRGroupMatch(ctx); err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, d.volume.State, rdiskDomain.LVEMarkToRecycle, d)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_recycled_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmRecycledPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEConfirmRecycled, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_rdisk_backup.go",
        "code_start_line": 52,
        "code_end_line": 75,
        "code_key": "Handle",
        "code_value": "func (c *DeleteRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tsm   = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\tc.relatedBackup, err = repo.FindByUUID(ctx, c.BackupID.String())\n\tif err != nil || c.relatedBackup == nil || c.relatedBackup.AppID != c.AppID {\n\t\treturn errors.New(backupDomain.ErrBackupNotExist, \"backup not exists\")\n\t}\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tc.relatedBackup.Status,\n\t\tbackupDomain.EventSoftDeleteBackup,\n\t\tbackupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: c.relatedBackup})\n\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_rdisk_backup.go",
        "code_start_line": 47,
        "code_end_line": 80,
        "code_key": "Handle",
        "code_value": "func (c *CreateRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tlvSm  = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\tbakSm = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo  = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t_, err = lvSm.Fire(ctx, c.relatedVolume.State, rdiskDomain.LVEBackupStarted, c)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tlv := c.relatedVolume\n\tbackup := backupDomain.New(\n\t\tlv.AppID,\n\t\tbackupDomain.DiskInfo{\n\t\t\tVolumeUUID: lv.UUID,\n\t\t\tVolumeSize: uint64(lv.Size),\n\t\t\tHostIP:     lv.PhysicalVolume.IP,\n\t\t\tHostBDF:    string(lv.PhysicalVolume.BDF),\n\t\t\tSerial:     string(lv.PhysicalVolume.Serial),\n\t\t},\n\t)\n\tif err := repo.Add(ctx, backup); err != nil {\n\t\treturn err\n\t}\n\tc.relatedBackup = backup\n\t_, err = bakSm.Fire(ctx, backupDomain.StatusInit, backupDomain.EventStartBackup, backupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: backup})\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/attach_logical_volume.go",
        "code_start_line": 49,
        "code_end_line": 71,
        "code_key": "Handle",
        "code_value": "func (c *AttachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEAttachLogicalVolume, c)\n\n\t// 如果已经挂载到了指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeAlreadyAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume already attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_delete_logical_volume.go",
        "code_start_line": 34,
        "code_end_line": 55,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\t// 如果逻辑卷不存在，则直接返回成功\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"failed to confirm delete: app id mismatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDeleteLogicalVolume, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/offline_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OfflinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOfflinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *DeletePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\t// 如果物理卷不存在，则直接幂等返回\n\t\treturn nil\n\t}\n\n\tvar event = domain.PVEDeletePhysicalVolume\n\tif c.Force && (c.relatedVolume.State == domain.PVSDefunct) {\n\t\t// 这里的实现不太好，状态机的逻辑不应该侵入 cmd\n\t\t// 时间太赶了，后续重构优化吧\n\t\tevent = domain.PVEForceDeleteForDefunct\n\t}\n\n\tif c.relatedVolume.HasBindedPV() {\n\t\treturn errors.New(domain.ErrVolumeBusy, \"logic volume has binded to this physical volume\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, event, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_logical_volume.go",
        "code_start_line": 55,
        "code_end_line": 70,
        "code_key": "Handle",
        "code_value": "func (c *CleanupLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVECleanupLogicalVolume, c)\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_init_physical_volume.go",
        "code_start_line": 26,
        "code_end_line": 52,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmInitPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\tif c.relatedVolume.IP.String() != c.Host.String() {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume host ip mistmatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVECreatePhysicalVolumeOnHost, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_physical_volume.go",
        "code_start_line": 51,
        "code_end_line": 101,
        "code_key": "Handle",
        "code_value": "func (c *CreatePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\n\t// 获取物理卷状态机\n\tsm := app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\trepo := app.GetRegistry(ctx).Repositories.PhysicalVolume\n\n\t// 检查物理卷是否已经存在，如果存在则直接幂等返回\n\tvol1, err := repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"serial\", c.Serial).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tvol2, err := repo.FindByIPAndBDF(ctx, c.Host, domain.BDF(c.BDF))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"host\", c.Host.String()).Str(\"bdf\", c.BDF).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tfor _, vol := range []*domain.PhysicalVolume{vol1, vol2} {\n\t\texisted, err := c.checkExisting(ctx, vol)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif existed {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// 触发事件，创建物理卷\n\t_, err = sm.Fire(ctx,\n\t\tdomain.PVSUnInited,\n\t\tdomain.PVECreatePhysicalVolume,\n\t\tc,\n\t)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 创建 Bdev 以及格式化移动到创建物理卷的状态机中\n\n\t// _, err = sm.Fire(ctx,\n\t// \tc.GetPhysicalVolume().State,\n\t// \tdomain.PVECreatePhysicalVolumeOnHost,\n\t// \tc,\n\t// )\n\t// if err != nil {\n\t// \treturn err\n\t// }\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_benchmark_task.go",
        "code_start_line": 32,
        "code_end_line": 57,
        "code_key": "Handle",
        "code_value": "func (c *DeleteBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\terr       error\n\t)\n\n\tbench, err := benchRepo.FindByUUID(ctx, c.BenchmarkUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif bench.DiskInfo.Serial != c.Serial {\n\t\treturn errors.Newf(benchmark.ErrTaskNotFound, \"benchmark serial not match %s, want %s\", c.Serial, bench.DiskInfo.Serial)\n\t}\n\n\t_, err = benchSm.Fire(ctx, bench.Status, benchmark.EventDeleteBench, benchmark.Data{Benchmark: bench, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := benchRepo.Delete(ctx, bench); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_logical_volume.go",
        "code_start_line": 52,
        "code_end_line": 98,
        "code_key": "Handle",
        "code_value": "func (c *CreateLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tpvRepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tlvRepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm     = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\t// 1. 查找底层物理卷\n\tc.selectedPhysicalVolume, err = pvRepo.FindBySerial(ctx, rdiskDomain.Serial(c.PhysicalVolumeSerial))\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// 检查底层物理卷大小是否满足要求\n\tif c.selectedPhysicalVolume.Size < rdiskDomain.Size(c.DiskSize) {\n\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume size %d is smaller than requested size %d\", c.selectedPhysicalVolume.Size, c.DiskSize)\n\t}\n\n\t// 检查底层物理卷性能等级是否满足要求\n\tif c.PerformanceRank != \"\" {\n\t\tif string(c.selectedPhysicalVolume.PerformanceRank) != c.PerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not match requested rank %s\", c.selectedPhysicalVolume.PerformanceRank, c.PerformanceRank)\n\t\t}\n\t} else {\n\t\tif c.selectedPhysicalVolume.PerformanceRank != rdiskDomain.DefaultPerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not default rank %s\", c.selectedPhysicalVolume.PerformanceRank, rdiskDomain.DefaultPerformanceRank)\n\t\t}\n\t}\n\n\t// 2. 创建逻辑卷\n\tvol := rdiskDomain.NewLogicalVolume(users.AppID(c.AppID), rdiskDomain.Size(c.DiskSize), rdiskDomain.ZoneID(c.ZoneID))\n\tif c.VolumeType != \"\" {\n\t\tvol.VolumeType = rdiskDomain.VolumeType(c.VolumeType)\n\t}\n\tif c.DiskType != \"\" {\n\t\tvol.DiskType = rdiskDomain.DiskType(c.DiskType)\n\t}\n\terr = lvRepo.Add(ctx, vol)\n\tif err != nil {\n\t\treturn\n\t}\n\tc.createdLogicalVolume = vol\n\n\t// 3. 触发状态机，联动更新逻辑卷和物理卷状态\n\t_, err = sm.Fire(ctx, rdiskDomain.LVSUnInited, rdiskDomain.LVECreateLogicalVolume, c)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_running_backup_task.go",
        "code_start_line": 31,
        "code_end_line": 61,
        "code_key": "Handle",
        "code_value": "func (c *UpdateRunningBackupTaskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventUpdateBackupProgress,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_drgroup.go",
        "code_start_line": 78,
        "code_end_line": 173,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeDRGroupCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tlvView  = app.GetRegistry(ctx).Viewers.LogicalVolume\n\t\tdrgRepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t\tsm      = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\terr     error\n\t)\n\n\t// 0. 初始化\n\tc.drgroupRef = make(map[string]*drgroup.DRGroup)\n\n\t// 1. 加载所有逻辑卷所在的置放群组\n\tallVolumeUUIDs := make([]string, 0, len(c.UUIDs))\n\tfor _, _uuid := range c.UUIDs {\n\t\tallVolumeUUIDs = append(allVolumeUUIDs, _uuid.String())\n\t}\n\tif groups, err := drgRepo.FindByMembers(ctx, c.AppID, allVolumeUUIDs); err == nil {\n\t\tif err != nil {\n\t\t\tif !errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tfor _, group := range groups {\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t\tc.curDRGroupNames = append(c.curDRGroupNames, group.Name)\n\t\t}\n\t} else {\n\t\treturn err\n\t}\n\n\t// 2. 确认已上锁的置放群组和当前一致\n\tif !c.checkLockedDRGroupNames() {\n\t\treturn errors.New(drgroup.ErrGroupModified, \"drgroup changed\")\n\t}\n\n\t// 3. 加载所有逻辑卷的状态，不需要完整实体，因为不会修改 Volume\n\tc.relatedLogicalVolume, err = lvView.FindByIDs(ctx, c.AppID, c.UUIDs)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(c.relatedLogicalVolume) < len(c.UUIDs) {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t// 4. 加载所有目标置放群组，key 为 name\n\tfor _, spec := range c.Specs {\n\t\tvar group *drgroup.DRGroup\n\t\tif _, ok := c.drgroupRef[spec.Name]; ok {\n\t\t\tgroup = c.drgroupRef[spec.Name]\n\t\t} else {\n\t\t\tgroup, err = c.getOrCreateDRGroup(ctx, drgRepo, spec)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t}\n\n\t\tif spec.Affinity > 0 {\n\t\t\tgroup.Affinity = spec.Affinity\n\t\t}\n\t\tif spec.Type != \"\" {\n\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t}\n\t}\n\n\t// 5. 对所有逻辑卷执行置放群组变更事件，检查状态是否允许，\n\t//    实际的更新还是在这里执行。\n\tfor _, vol := range c.relatedLogicalVolume {\n\t\terr := sm.Check(ctx, vol.State, rdiskDomain.LVEUpdateDrGroup, c)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// 将逻辑卷从原有的置放群组中移除\n\t\tfor _, name := range c.curDRGroupNames {\n\t\t\tc.drgroupRef[name].RemoveMember(vol.UUID.String())\n\t\t}\n\t\t// 将逻辑卷添加到新的置放群组中\n\t\tfor _, spec := range c.Specs {\n\t\t\tsubGroup := spec.SubGroup\n\t\t\tif subGroup == \"\" {\n\t\t\t\t// 如果没有指定子组，则使用远端 SSD UUID 作为子组名称\n\t\t\t\t// 相当于每块盘都是一个子组，相当于没有使用子组功能\n\t\t\t\tsubGroup = vol.UUID.String()\n\t\t\t}\n\t\t\tif err := c.drgroupRef[spec.Name].AddMember(vol.UUID.String(), subGroup, vol.PhysicalVolume.IP.String()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tif c.DryRun {\n\t\treturn errors.New(errors.ErrDryRunSuccessExit, \"dry run check success\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/online_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OnlinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOnlinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_benchmark_task.go",
        "code_start_line": 34,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *UpdateBenchmarkTask) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, rdisk.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark, err = benchRepo.FindByUUID(ctx, c.BenchmarkUUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventUpdateBench, benchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_flow_ctrl.go",
        "code_start_line": 80,
        "code_end_line": 103,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeFlowControlCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not found\")\n\t}\n\n\tspec := c.volume.FlowControlSpec\n\tif !c.UpdateRequest.UpdateSpec(&spec, c.volume.GetDefaultFlowControlSpec()) {\n\t\t// 没有任何更新，直接返回成功\n\t\treturn nil\n\t}\n\tc.volume.SetFlowControlSpec(spec)\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEUpdateFlowControl, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_defunct_volume.go",
        "code_start_line": 46,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *CleanupDefunctCommand) Handle(ctx context.Context) error {\n\tvar err error\n\tc.lv, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar sm = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\tvar event = rdiskDomain.LVECleanupDefunct\n\n\tfor _, attachment := range c.lv.Attachments {\n\t\tlogs.Info(ctx).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).Msg(\"cleanup defuncting volume\")\n\t\tsubCmd := &cleanDefunctSubCommand{Parent: c, HostIP: attachment.IP}\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, subCmd)\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，因为只要有一个挂载点清理失败，其他挂载点还是需要继续清理的\n\t\t\t// 失败的挂载点会在后台继续清理\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).\n\t\t\t\tMsg(\"failed to cleanup defunct volume, retry later.\")\n\t\t}\n\t}\n\n\tif len(c.lv.Attachments) == 0 {\n\t\t// 没有挂载点，直接清理\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, &cleanDefunctSubCommand{Parent: c, HostIP: net.IP{}})\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，后续自动重试即可\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Msg(\"failed to complete cleanup defunct volume\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_drgroup_exists.go",
        "code_start_line": 28,
        "code_end_line": 53,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDRGroupExistsCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t)\n\tfor _, spec := range c.DRGroup {\n\t\t_, err := repo.FindByName(ctx, users.AppID(c.AppID), spec.Name)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\tgroup := drgroup.New(spec.Name, users.AppID(c.AppID))\n\t\t\t\tif spec.Affinity > 0 {\n\t\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t\t}\n\t\t\t\tif spec.Type != \"\" {\n\t\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t\t}\n\t\t\t\terr = repo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_physical_volume.go",
        "code_start_line": 31,
        "code_end_line": 54,
        "code_key": "Handle",
        "code_value": "func (c *UpdatePhyRDiskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEUpdatePhysicalVolume, c)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/recycle_backup_data.go",
        "code_start_line": 32,
        "code_end_line": 62,
        "code_key": "Handle",
        "code_value": "func (c *RecycleBackupDataCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventDeleteBackup,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/clients/cos/client.go",
        "code_start_line": 101,
        "code_end_line": 104,
        "code_key": "DeleteObject",
        "code_value": "func (c *clientImpl) DeleteObject(ctx context.Context, key string) error {\n\t_, err := c.c.Object.Delete(ctx, key)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go",
        "code_start_line": 208,
        "code_end_line": 215,
        "code_key": "deleteFinishTask",
        "code_value": "func (sc *Scheduler) deleteFinishTask(ctx context.Context, task interfaces.Task) {\n\tsubTaskName := task.GetSubTaskName()\n\tif _, ok := sc.metrics.taskExecuteCountMap[subTaskName]; !ok {\n\t\tsc.metrics.taskExecuteCountMap[subTaskName], _ = initHistogramVec(subTaskName).GetMetricWith(sc.metrics.labels)\n\t}\n\tsc.metrics.taskExecuteCountMap[subTaskName].Observe(float64(task.GetExecuteCounts()))\n\tsc.taskMap.Delete(task.GetTaskId())\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_physical_volume.go",
        "code_start_line": 113,
        "code_end_line": 131,
        "code_key": "checkExisting",
        "code_value": "func (c *CreatePhysicalVolumeCommand) checkExisting(ctx context.Context, vol *domain.PhysicalVolume) (existed bool, err error) {\n\tif vol == nil {\n\t\treturn false, nil\n\t}\n\tif vol.Deleted() {\n\t\terr := app.GetRegistry(ctx).Repositories.PhysicalVolume.Delete(ctx, vol)\n\t\tif err != nil {\n\t\t\treturn false, errors.Newf(domain.ErrConflictVolume, \"failed to delete conflict physical volume: %v\", err)\n\t\t}\n\t\treturn false, nil\n\t}\n\tif string(vol.Serial) != c.Serial {\n\t\treturn false, errors.Newf(domain.ErrConflictVolume, \"host %s bdf %s has been taken by %s\", vol.IP, vol.BDF, vol.Serial)\n\t}\n\tif !vol.IP.Equal(c.Host) || string(vol.BDF) != c.BDF {\n\t\treturn false, errors.Newf(domain.ErrConflictVolume, \"volume %s has been assigned to host %s bdf %s\", vol.Serial, vol.IP, vol.BDF)\n\t}\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/create_logic_disk.go",
        "code_start_line": 61,
        "code_end_line": 63,
        "code_key": "InvokeDeleteLogicalVolume",
        "code_value": "func InvokeDeleteLogicalVolume(ctx context.Context, source rdiskDomain.LogicalVolumeState, target rdiskDomain.LogicalVolumeState, stateCtx app.LogicalVolumeContext) (rdiskDomain.LogicalVolumeState, error) {\n\treturn target, stateCtx.GetLogicalVolume().Delete()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go",
        "code_start_line": 199,
        "code_end_line": 305,
        "code_key": "updateLogicalVolume",
        "code_value": "func updateLogicalVolume(ctx context.Context, item, originalState *rdiskDomain.LogicalVolume) error {\n\tuow := getUow(ctx)\n\tcurDO := fromModelToDmRDisk(item)\n\toriginalDO := fromModelToDmRDisk(originalState)\n\tchanges := make(map[string]interface{})\n\tcheckChange := func(field string, cur interface{}, original interface{}) {\n\t\tif cur != original {\n\t\t\tchanges[field] = cur\n\t\t}\n\t}\n\tcheckChange(\"uuid\", curDO.UUID, originalDO.UUID)\n\tcheckChange(\"status\", curDO.Status, originalDO.Status)\n\tcheckChange(\"app_id\", curDO.AppID, originalDO.AppID)\n\tcheckChange(\"size\", curDO.Size, originalDO.Size)\n\tcheckChange(\"phydisk_serial\", curDO.PhydiskSerial, originalDO.PhydiskSerial)\n\tcheckChange(\"zone_id\", curDO.ZoneID, originalDO.ZoneID)\n\tcheckChange(\"volume_type\", curDO.VolumeType, originalDO.VolumeType)\n\tcheckChange(\"disk_type\", curDO.DiskType, originalDO.DiskType)\n\tcheckChange(\"read_iops\", curDO.ReadIOPS, originalDO.ReadIOPS)\n\tcheckChange(\"write_iops\", curDO.WriteIOPS, originalDO.WriteIOPS)\n\tcheckChange(\"rw_iops\", curDO.ReadWriteIOPS, originalDO.ReadWriteIOPS)\n\tcheckChange(\"read_bandwidth\", curDO.ReadBandwidth, originalDO.ReadBandwidth)\n\tcheckChange(\"write_bandwidth\", curDO.WriteBandwidth, originalDO.WriteBandwidth)\n\tcheckChange(\"rw_bandwidth\", curDO.ReadWriteBandwidth, originalDO.ReadWriteBandwidth)\n\n\tif len(changes) != 0 {\n\t\tchanges[\"updated\"] = uow.tx.NowFunc()\n\n\t\tresult := uow.tx.Model(curDO).Where(\"id = ?\", curDO.ID).Updates(changes)\n\t\tif result.Error != nil {\n\t\t\treturn result.Error\n\t\t}\n\t}\n\n\t// 更新挂载信息\n\n\tallHosts := make(map[string]struct{})\n\toriginHosts := make(map[string]*rdiskDomain.VolumeAttachment)\n\tcurHosts := make(map[string]*rdiskDomain.VolumeAttachment)\n\tfor _, a := range item.Attachments {\n\t\tallHosts[a.IP.String()] = struct{}{}\n\t\tcurHosts[a.IP.String()] = a\n\t}\n\tfor _, a := range originalState.Attachments {\n\t\tallHosts[a.IP.String()] = struct{}{}\n\t\toriginHosts[a.IP.String()] = a\n\t}\n\n\tfor hostIp := range allHosts {\n\t\tcurAttachment, _ := curHosts[hostIp]\n\t\toriginAttachment, _ := originHosts[hostIp]\n\t\tif originAttachment == nil && curAttachment != nil {\n\t\t\t// 新增挂载\n\t\t\tdo := fromModelToDmRDiskAttachment(curAttachment)\n\t\t\tdo.UUID = curDO.UUID\n\t\t\tdo.Created = uow.tx.NowFunc()\n\t\t\tdo.Updated = uow.tx.NowFunc()\n\t\t\terr := uow.tx.Model(curDO).Association(\"Attachments\").Append(do)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else if originAttachment != nil && curAttachment == nil {\n\t\t\t// 删除挂载\n\t\t\tdo := fromModelToDmRDiskAttachment(originAttachment)\n\t\t\tdo.UUID = curDO.UUID\n\t\t\tresult := uow.tx.Where(\"host_ip = ? and uuid = ?\", do.IP, do.UUID).Delete(do)\n\t\t\tif result.Error != nil {\n\t\t\t\treturn result.Error\n\t\t\t}\n\t\t} else if originAttachment != nil && curAttachment != nil {\n\t\t\t// 更新挂载\n\t\t\tdo := fromModelToDmRDiskAttachment(curAttachment)\n\t\t\tdo.UUID = curDO.UUID\n\t\t\toriginDo := fromModelToDmRDiskAttachment(originAttachment)\n\t\t\toriginDo.UUID = curDO.UUID\n\t\t\tchanges := make(map[string]interface{})\n\t\t\tcheckChange := func(field string, cur interface{}, original interface{}) {\n\t\t\t\tif cur != original {\n\t\t\t\t\tchanges[field] = cur\n\t\t\t\t}\n\t\t\t}\n\t\t\tcheckChange(\"mode\", do.Mode, originDo.Mode)\n\t\t\tcheckChange(\"read_iops\", do.ReadIOPS, originDo.ReadIOPS)\n\t\t\tcheckChange(\"write_iops\", do.WriteIOPS, originDo.WriteIOPS)\n\t\t\tcheckChange(\"rw_iops\", do.ReadWriteIOPS, originDo.ReadWriteIOPS)\n\t\t\tcheckChange(\"read_bandwidth\", do.ReadBandwidth, originDo.ReadBandwidth)\n\t\t\tcheckChange(\"write_bandwidth\", do.WriteBandwidth, originDo.WriteBandwidth)\n\t\t\tcheckChange(\"rw_bandwidth\", do.ReadWriteBandwidth, originDo.ReadWriteBandwidth)\n\t\t\tcheckChange(\"num_queue\", do.NumQueue, originDo.NumQueue)\n\t\t\tcheckChange(\"serial\", do.Serial, originDo.Serial)\n\t\t\tcheckChange(\"vcpu\", do.VCPU, originDo.VCPU)\n\t\t\tcheckChange(\"spdk_driver\", do.SPDKDriver, originDo.SPDKDriver)\n\n\t\t\tif len(changes) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tchanges[\"updated\"] = uow.tx.NowFunc()\n\t\t\tresult := uow.tx.Model(do).Where(\"host_ip = ? and uuid = ?\", do.IP, do.UUID).Updates(changes)\n\t\t\tif result.Error != nil {\n\t\t\t\treturn result.Error\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
        "code_start_line": 165,
        "code_end_line": 277,
        "code_key": "updateDRGroup",
        "code_value": "func updateDRGroup(ctx context.Context, item, originalState *drgroup.DRGroup) error {\n\tuow := getUow(ctx)\n\tcurDO := fromModelToDmDRGroup(item)\n\toriginalDO := fromModelToDmDRGroup(originalState)\n\tchanges := make(map[string]interface{})\n\tcheckChange := func(field string, cur interface{}, original interface{}) {\n\t\tif cur != original {\n\t\t\tif field == \"member_cnt\" || field == \"sub_group_cnt\" {\n\t\t\t\tdiff := cur.(int) - original.(int)\n\t\t\t\tif diff < 0 {\n\t\t\t\t\tchanges[field] = gorm.Expr(fmt.Sprintf(\"%s - %d\", field, -1*diff))\n\t\t\t\t} else {\n\t\t\t\t\tchanges[field] = gorm.Expr(fmt.Sprintf(\"%s + %d\", field, diff))\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tchanges[field] = cur\n\t\t\t}\n\t\t}\n\t}\n\tcheckChange(\"status\", curDO.Status, originalDO.Status)\n\tcheckChange(\"app_id\", curDO.AppID, originalDO.AppID)\n\tcheckChange(\"name\", curDO.Name, originalDO.Name)\n\tcheckChange(\"affinity\", curDO.Affinity, originalDO.Affinity)\n\tcheckChange(\"loc_type\", curDO.LocType, originalDO.LocType)\n\tcheckChange(\"satisfied\", curDO.Satisfied, originalDO.Satisfied)\n\tcheckChange(\"member_cnt\", curDO.MemberCnt, originalDO.MemberCnt)\n\tcheckChange(\"sub_group_cnt\", curDO.SubGroupCnt, originalDO.SubGroupCnt)\n\tcheckChange(\"extra\", curDO.Extra, originalDO.Extra)\n\n\tif len(changes) != 0 {\n\t\tchanges[\"updated\"] = uow.tx.NowFunc()\n\n\t\tresult := uow.tx.Model(curDO).Where(\"id = ?\", curDO.ID).Updates(changes)\n\t\tif result.Error != nil {\n\t\t\treturn result.Error\n\t\t}\n\t}\n\n\t// 更新成员信息\n\tallMembers := make(map[string]struct{})\n\ttype memberInfo struct {\n\t\tLoc      string\n\t\tSubGroup string\n\t}\n\toriginMembers := make(map[string]memberInfo)\n\tcurMembers := make(map[string]memberInfo)\n\tfor _, a := range item.GetMembers() {\n\t\tallMembers[a.ID] = struct{}{}\n\t\tcurMembers[a.ID] = memberInfo{\n\t\t\tLoc:      a.Location,\n\t\t\tSubGroup: a.SubGroup,\n\t\t}\n\t}\n\tfor _, a := range originalState.GetMembers() {\n\t\tallMembers[a.ID] = struct{}{}\n\t\toriginMembers[a.ID] = memberInfo{\n\t\t\tLoc:      a.Location,\n\t\t\tSubGroup: a.SubGroup,\n\t\t}\n\t}\n\n\tfor memberId := range allMembers {\n\t\tcurInfo, _ := curMembers[memberId]\n\t\toriginInfo, _ := originMembers[memberId]\n\t\tif originInfo.Loc == \"\" && curInfo.Loc != \"\" {\n\t\t\tdo := &metadb.DmDrgroupMembers{\n\t\t\t\tAppID:     int64(item.AppID),\n\t\t\t\tGroupName: item.Name,\n\t\t\t\tSubGroup:  curInfo.SubGroup,\n\t\t\t\tLoc:       curInfo.Loc,\n\t\t\t\tMemberID:  memberId,\n\t\t\t\tExtra:     \"{}\",\n\t\t\t\tCreated:   uow.tx.NowFunc(),\n\t\t\t\tUpdated:   uow.tx.NowFunc(),\n\t\t\t}\n\t\t\tresult := uow.tx.Create(do)\n\t\t\tif result.Error != nil {\n\t\t\t\treturn result.Error\n\t\t\t}\n\t\t} else if originInfo.Loc != \"\" && curInfo.Loc == \"\" {\n\t\t\tresult := uow.tx.Delete(&metadb.DmDrgroupMembers{},\n\t\t\t\t\"app_id = ? and group_name = ? and member_id = ?\",\n\t\t\t\toriginalState.AppID, originalState.Name, memberId)\n\t\t\tif result.Error != nil {\n\t\t\t\treturn result.Error\n\t\t\t}\n\t\t} else if originInfo.Loc != \"\" && curInfo.Loc != \"\" {\n\t\t\tchanges := make(map[string]interface{})\n\t\t\tcheckChange := func(field string, cur interface{}, original interface{}) {\n\t\t\t\tif cur != original {\n\t\t\t\t\tchanges[field] = cur\n\t\t\t\t}\n\t\t\t}\n\t\t\tcheckChange(\"loc\", curInfo.Loc, originInfo.Loc)\n\t\t\tcheckChange(\"app_id\", item.AppID, originalState.AppID)\n\t\t\tcheckChange(\"group_name\", item.Name, originalState.Name)\n\t\t\tcheckChange(\"sub_group\", curInfo.SubGroup, originInfo.SubGroup)\n\t\t\t//checkChange(\"extra\", \"{}\", \"{}\")\n\n\t\t\tif len(changes) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tchanges[\"updated\"] = uow.tx.NowFunc()\n\t\t\tresult := uow.tx.Model(&metadb.DmDrgroupMembers{}).Where(\n\t\t\t\t\"app_id = ? and group_name = ? and member_id = ?\",\n\t\t\t\toriginalState.AppID, originalState.Name, memberId).Updates(changes)\n\t\t\tif result.Error != nil {\n\t\t\t\treturn result.Error\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 151,
        "code_end_line": 169,
        "code_key": "DmRdiskBackup",
        "code_value": "type DmRdiskBackup struct {\n\tID        uint64    `gorm:\"column:id;primaryKey\"` // 主键 ID\n\tAppID     int64     `gorm:\"column:app_id;\"`       // AppID\n\tUUID      string    `gorm:\"column:uuid;\"`         // 备份 UUID\n\tDiskUUID  string    `gorm:\"column:rdisk_uuid\"`    // RDisk UUID\n\tStatus    int       `gorm:\"column:status\"`        // 备份状态\n\tSize      uint64    `gorm:\"column:size\"`          // 远端 SSD 大小 in GiB\n\tPhyID     string    `gorm:\"column:phy_id\"`        // 物理卷 Serial\n\tHostIP    string    `gorm:\"column:host_ip\"`       // 主机 IP\n\tHostBDF   string    `gorm:\"column:host_bdf\"`      // 主机上物理盘 BDF 号\n\tCosAppId  int64     `gorm:\"column:cos_appid\"`     // COS AppId\n\tCosRegion string    `gorm:\"column:cos_region\"`    // COS 所在的地域，例如 gz\n\tCosBucket string    `gorm:\"column:cos_bucket\"`    // COS Bucket\n\tCosPath   string    `gorm:\"column:cos_path\"`      // COS Path\n\tPercent   int       `gorm:\"column:percent\"`       // 备份进度\n\tExtra     string    `gorm:\"column:extra\"`         // 额外信息\n\tCreated   time.Time `gorm:\"column:created\"`       // 备份创建时间\n\tUpdated   time.Time `gorm:\"column:updated\"`       // 备份更新时间\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 171,
        "code_end_line": 173,
        "code_key": "TableName",
        "code_value": "func (DmRdiskBackup) TableName() string {\n\treturn \"dm_rdisk_backup\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 67,
        "code_end_line": 83,
        "code_key": "PhysicalVolume",
        "code_value": "type PhysicalVolume struct {\n\tEntityMixin\n\tSerial          Serial              // 物理卷序列号\n\tIP              net.IP              // 物理卷所在主机 IP\n\tBDF             BDF                 // 物理卷所在主机的 BDF\n\tDiskID          uint64              // 物理卷在主机上的 BDev ID\n\tState           PhysicalVolumeState // 物理卷状态\n\tSize            Size                // 物理卷对外售卖大小 GiB\n\tVolumeType      VolumeType          // 物理卷类型\n\tZoneID          ZoneID              // 物理卷所在的 Zone\n\tBlockSize       uint                // 物理卷块大小，通常为 512\n\tRealSize        uint64              // 物理卷实际大小，单位为 Byte\n\tPort            uint                // 物理卷所在主机的端口\n\tDataNodeType    DataNodeType        // 数据节点类型\n\tCuf             Cuf                 // 存储节点 CUF 信息\n\tPerformanceRank PerformanceRank     // 物理卷性能等级\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go:73:81:Delete": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go",
    "code_start_line": 73,
    "code_end_line": 81,
    "code_start_column": 40,
    "code_key": "Delete",
    "code_value": "func (p *physicalVolumeRepositoryImpl) Delete(ctx context.Context, pv *rdiskDomain.PhysicalVolume) error {\n\tuow := getUow(ctx)\n\tidt := pv.GetID()\n\tresult := uow.tx.Where(\"id = ?\", idt).Delete(&metadb.DmPhydisk{})\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/expiremap.go",
        "code_start_line": 91,
        "code_end_line": 96,
        "code_key": "Delete",
        "code_value": "func (e *ExpiredMap) Delete(key interface{}) {\n\te.lck.Lock()\n\tdelete(e.m, key)\n\te.deleteTimeMap(key)\n\te.lck.Unlock()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/scheduler.go",
        "code_start_line": 135,
        "code_end_line": 139,
        "code_key": "Delete",
        "code_value": "func (s *scheduler) Delete(name string) {\n\ts.mutex.Lock()\n\tdefer s.mutex.Unlock()\n\tdelete(s.loads, name)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/benchmark.go",
        "code_start_line": 32,
        "code_end_line": 39,
        "code_key": "Delete",
        "code_value": "func (repo *rdiskBenchmarkRepositoryImpl) Delete(ctx context.Context, bench *benchmark.Benchmark) error {\n\tuow := getUow(ctx)\n\tresult := uow.tx.Delete(&metadb.DmRdiskBenchmark{}, \"id = ?\", bench.ID)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/backup.go",
        "code_start_line": 34,
        "code_end_line": 41,
        "code_key": "Delete",
        "code_value": "func (*rdiskBackupRepositoryImpl) Delete(ctx context.Context, backup *backupPkg.Backup) error {\n\tuow := getUow(ctx)\n\tresult := uow.tx.Delete(&metadb.DmRdiskBackup{}, \"id = ?\", backup.ID)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go",
        "code_start_line": 73,
        "code_end_line": 81,
        "code_key": "Delete",
        "code_value": "func (p *physicalVolumeRepositoryImpl) Delete(ctx context.Context, pv *rdiskDomain.PhysicalVolume) error {\n\tuow := getUow(ctx)\n\tidt := pv.GetID()\n\tresult := uow.tx.Where(\"id = ?\", idt).Delete(&metadb.DmPhydisk{})\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
        "code_start_line": 111,
        "code_end_line": 122,
        "code_key": "Delete",
        "code_value": "func (d drgroupRepositoryImpl) Delete(ctx context.Context, group *drgroup.DRGroup) error {\n\tuow := getUow(ctx)\n\tresult := uow.tx.Delete(&metadb.DmDrgroup{}, \"id = ?\", group.ID)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tresult = uow.tx.Delete(&metadb.DmDrgroupMembers{}, \"app_id = ? and group_name = ?\", group.AppID, group.Name)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 356,
        "code_end_line": 363,
        "code_key": "Delete",
        "code_value": "func (l *LogicalVolume) Delete() error {\n\tif len(l.Attachments) > 0 {\n\t\treturn errors.New(ErrVolumeAttached, \"volume is still attached to some hosts\")\n\t}\n\tl.PhysicalVolume = nil\n\tl.State = LVSDeleted\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 54,
        "code_end_line": 59,
        "code_key": "Delete",
        "code_value": "func (m *MockPhysicalVolumeRepository) Delete(arg0 context.Context, arg1 *rdiskDomain.PhysicalVolume) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Delete\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 62,
        "code_end_line": 65,
        "code_key": "Delete",
        "code_value": "func (mr *MockPhysicalVolumeRepositoryMockRecorder) Delete(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Delete\", reflect.TypeOf((*MockPhysicalVolumeRepository)(nil).Delete), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 54,
        "code_end_line": 59,
        "code_key": "Delete",
        "code_value": "func (m *MockRepository) Delete(arg0 context.Context, arg1 *drgroup.DRGroup) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Delete\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 62,
        "code_end_line": 65,
        "code_key": "Delete",
        "code_value": "func (mr *MockRepositoryMockRecorder) Delete(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Delete\", reflect.TypeOf((*MockRepository)(nil).Delete), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/expiremap.go",
        "code_start_line": 98,
        "code_end_line": 100,
        "code_key": "Remove",
        "code_value": "func (e *ExpiredMap) Remove(key interface{}) {\n\te.Delete(key)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/managers/shm.go",
        "code_start_line": 51,
        "code_end_line": 54,
        "code_key": "Remove",
        "code_value": "func (s *ShmCacheManager) Remove(ctx context.Context, keyResolver cache.GeneralCacheKeyResolverInf) error {\n\ts.m.Delete(keyResolver.GenerateKey(ctx))\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/subgroup.go",
        "code_start_line": 78,
        "code_end_line": 82,
        "code_key": "Remove",
        "code_value": "func (s *SubGroupCacheManager) Remove(ctx context.Context, keyResolver cache.GeneralCacheKeyResolverInf) error {\n\tcacheKey := keyResolver.GenerateKey(ctx)\n\ts.cacheMap.Delete(cacheKey)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/managers/shm.go",
        "code_start_line": 82,
        "code_end_line": 84,
        "code_key": "Pop",
        "code_value": "func (s *ShmCacheManager) Pop(ctx context.Context, keyResolver cache.GeneralCacheKeyResolverInf) (interface{}, error) {\n\tpanic(\"implement me\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/subgroup.go",
        "code_start_line": 104,
        "code_end_line": 117,
        "code_key": "Pop",
        "code_value": "func (s *SubGroupCacheManager) Pop(ctx context.Context, keyResolver cache.GeneralCacheKeyResolverInf) (interface{}, error) {\n\tcacheKey := keyResolver.GenerateKey(ctx)\n\tif ok, disks := s.cacheMap.Get(cacheKey); ok {\n\t\tniceDisks := disks.([]*disk.Disk)\n\t\toneDisk := niceDisks[0]\n\t\tif len(niceDisks) > 1 {\n\t\t\ts.cacheMap.Set(cacheKey, niceDisks[1:], s.expiredSeconds)\n\t\t} else {\n\t\t\ts.cacheMap.Delete(cacheKey)\n\t\t}\n\t\treturn oneDisk, nil\n\t}\n\treturn nil, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/queue/priority_queue.go",
        "code_start_line": 35,
        "code_end_line": 42,
        "code_key": "Pop",
        "code_value": "func (pq *PriorityQueue) Pop() any {\n\told := pq.Task\n\tn := len(old)\n\titem := old[n-1]\n\told[n-1] = nil // avoid memory leak\n\tpq.Task = old[0 : n-1]\n\treturn item\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/queue/priority_queue.go",
        "code_start_line": 56,
        "code_end_line": 60,
        "code_key": "Pop",
        "code_value": "func (spq *SyncTaskPriorityQueue) Pop() interfaces.Task {\n\tspq.mutex.Lock()\n\tdefer spq.mutex.Unlock()\n\treturn heap.Pop(spq.priorityQueue).(interfaces.Task)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go",
        "code_start_line": 51,
        "code_end_line": 72,
        "code_key": "Handle",
        "code_value": "func (c *CbsAppIdConsumer) Handle(ctx context.Context, delivery *rabbitmq.Delivery) error {\n\tu, chargeTime, err := c.ParseDelivery(ctx, delivery)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif u == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"USER_INFO_NOT_FOUND\")\n\t\treturn nil\n\t}\n\n\tchargeDetail := c.GetChargeDetailForSingleUser(u, chargeTime)\n\tif chargeDetail == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tUint64(\"appId\", uint64(u.AppId)).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"NO_RESOURCE_TO_CHARGE\")\n\t\treturn nil\n\t}\n\treturn c.ProcessChargeDetail(chargeDetail)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 105,
        "code_end_line": 116,
        "code_key": "Handle",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tif err := c.ensureLocks(ctx); err != nil {\n\t\treturn err\n\t}\n\tif c.lvUUID != nil {\n\t\t// 涉及到逻辑卷时，需要先标记逻辑卷为故障\n\t\treturn c.handleBindedVolume(ctx)\n\t} else {\n\t\t// 不涉及到逻辑卷时，直接标记物理卷为故障\n\t\treturn c.handleIdleVolume(ctx)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/detach_logical_volume.go",
        "code_start_line": 56,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *DetachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDetachLogicalVolume, c)\n\n\t// 如果没有挂载到指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume not attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_benchmark_task.go",
        "code_start_line": 125,
        "code_end_line": 165,
        "code_key": "Handle",
        "code_value": "func (c *CreateBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tvolSm     = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = volSm.Fire(ctx, c.relatedVolume.State, domain.PVEStartBenchmark, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark = benchmark.New(benchmark.DiskInfo{\n\t\tSerial: string(c.relatedVolume.Serial),\n\t\tHostIP: c.relatedVolume.IP,\n\t\tBDF:    string(c.relatedVolume.BDF),\n\t})\n\n\tif err = benchRepo.Add(ctx, c.relatedBenchmark); err != nil {\n\t\tdelegate := &benchmarkDelegate{cmd: c}\n\t\tif _err := delegate.TaskFinishCallback(ctx, c.relatedBenchmark); _err != nil {\n\t\t\tlogs.Warn(ctx).Err(_err).Str(\"serial\", string(c.relatedVolume.Serial)).Msg(\"failed to rollback: create bdev\")\n\t\t}\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventCreateBench,\n\t\tbenchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_logical_volume.go",
        "code_start_line": 71,
        "code_end_line": 108,
        "code_key": "Handle",
        "code_value": "func (d *DeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\td.volume, err = repo.FindByID(ctx, d.UUID)\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif e := d.volume.CheckDelete(); e != nil {\n\t\treturn e\n\t}\n\n\tif d.volume.AppID != d.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"refuse to delet: app id mismatch\")\n\t}\n\n\td.drgroup, err = app.GetRegistry(ctx).Repositories.DRGroup.FindByMember(ctx, d.AppID, d.volume.UUID.String())\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\td.drgroup = nil\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := d.checkDRGroupMatch(ctx); err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, d.volume.State, rdiskDomain.LVEMarkToRecycle, d)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_recycled_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmRecycledPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEConfirmRecycled, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_rdisk_backup.go",
        "code_start_line": 52,
        "code_end_line": 75,
        "code_key": "Handle",
        "code_value": "func (c *DeleteRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tsm   = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\tc.relatedBackup, err = repo.FindByUUID(ctx, c.BackupID.String())\n\tif err != nil || c.relatedBackup == nil || c.relatedBackup.AppID != c.AppID {\n\t\treturn errors.New(backupDomain.ErrBackupNotExist, \"backup not exists\")\n\t}\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tc.relatedBackup.Status,\n\t\tbackupDomain.EventSoftDeleteBackup,\n\t\tbackupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: c.relatedBackup})\n\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_rdisk_backup.go",
        "code_start_line": 47,
        "code_end_line": 80,
        "code_key": "Handle",
        "code_value": "func (c *CreateRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tlvSm  = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\tbakSm = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo  = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t_, err = lvSm.Fire(ctx, c.relatedVolume.State, rdiskDomain.LVEBackupStarted, c)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tlv := c.relatedVolume\n\tbackup := backupDomain.New(\n\t\tlv.AppID,\n\t\tbackupDomain.DiskInfo{\n\t\t\tVolumeUUID: lv.UUID,\n\t\t\tVolumeSize: uint64(lv.Size),\n\t\t\tHostIP:     lv.PhysicalVolume.IP,\n\t\t\tHostBDF:    string(lv.PhysicalVolume.BDF),\n\t\t\tSerial:     string(lv.PhysicalVolume.Serial),\n\t\t},\n\t)\n\tif err := repo.Add(ctx, backup); err != nil {\n\t\treturn err\n\t}\n\tc.relatedBackup = backup\n\t_, err = bakSm.Fire(ctx, backupDomain.StatusInit, backupDomain.EventStartBackup, backupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: backup})\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/attach_logical_volume.go",
        "code_start_line": 49,
        "code_end_line": 71,
        "code_key": "Handle",
        "code_value": "func (c *AttachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEAttachLogicalVolume, c)\n\n\t// 如果已经挂载到了指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeAlreadyAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume already attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_delete_logical_volume.go",
        "code_start_line": 34,
        "code_end_line": 55,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\t// 如果逻辑卷不存在，则直接返回成功\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"failed to confirm delete: app id mismatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDeleteLogicalVolume, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/offline_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OfflinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOfflinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *DeletePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\t// 如果物理卷不存在，则直接幂等返回\n\t\treturn nil\n\t}\n\n\tvar event = domain.PVEDeletePhysicalVolume\n\tif c.Force && (c.relatedVolume.State == domain.PVSDefunct) {\n\t\t// 这里的实现不太好，状态机的逻辑不应该侵入 cmd\n\t\t// 时间太赶了，后续重构优化吧\n\t\tevent = domain.PVEForceDeleteForDefunct\n\t}\n\n\tif c.relatedVolume.HasBindedPV() {\n\t\treturn errors.New(domain.ErrVolumeBusy, \"logic volume has binded to this physical volume\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, event, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_logical_volume.go",
        "code_start_line": 55,
        "code_end_line": 70,
        "code_key": "Handle",
        "code_value": "func (c *CleanupLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVECleanupLogicalVolume, c)\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_init_physical_volume.go",
        "code_start_line": 26,
        "code_end_line": 52,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmInitPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\tif c.relatedVolume.IP.String() != c.Host.String() {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume host ip mistmatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVECreatePhysicalVolumeOnHost, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_physical_volume.go",
        "code_start_line": 51,
        "code_end_line": 101,
        "code_key": "Handle",
        "code_value": "func (c *CreatePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\n\t// 获取物理卷状态机\n\tsm := app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\trepo := app.GetRegistry(ctx).Repositories.PhysicalVolume\n\n\t// 检查物理卷是否已经存在，如果存在则直接幂等返回\n\tvol1, err := repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"serial\", c.Serial).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tvol2, err := repo.FindByIPAndBDF(ctx, c.Host, domain.BDF(c.BDF))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"host\", c.Host.String()).Str(\"bdf\", c.BDF).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tfor _, vol := range []*domain.PhysicalVolume{vol1, vol2} {\n\t\texisted, err := c.checkExisting(ctx, vol)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif existed {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// 触发事件，创建物理卷\n\t_, err = sm.Fire(ctx,\n\t\tdomain.PVSUnInited,\n\t\tdomain.PVECreatePhysicalVolume,\n\t\tc,\n\t)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 创建 Bdev 以及格式化移动到创建物理卷的状态机中\n\n\t// _, err = sm.Fire(ctx,\n\t// \tc.GetPhysicalVolume().State,\n\t// \tdomain.PVECreatePhysicalVolumeOnHost,\n\t// \tc,\n\t// )\n\t// if err != nil {\n\t// \treturn err\n\t// }\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_benchmark_task.go",
        "code_start_line": 32,
        "code_end_line": 57,
        "code_key": "Handle",
        "code_value": "func (c *DeleteBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\terr       error\n\t)\n\n\tbench, err := benchRepo.FindByUUID(ctx, c.BenchmarkUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif bench.DiskInfo.Serial != c.Serial {\n\t\treturn errors.Newf(benchmark.ErrTaskNotFound, \"benchmark serial not match %s, want %s\", c.Serial, bench.DiskInfo.Serial)\n\t}\n\n\t_, err = benchSm.Fire(ctx, bench.Status, benchmark.EventDeleteBench, benchmark.Data{Benchmark: bench, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := benchRepo.Delete(ctx, bench); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_logical_volume.go",
        "code_start_line": 52,
        "code_end_line": 98,
        "code_key": "Handle",
        "code_value": "func (c *CreateLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tpvRepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tlvRepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm     = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\t// 1. 查找底层物理卷\n\tc.selectedPhysicalVolume, err = pvRepo.FindBySerial(ctx, rdiskDomain.Serial(c.PhysicalVolumeSerial))\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// 检查底层物理卷大小是否满足要求\n\tif c.selectedPhysicalVolume.Size < rdiskDomain.Size(c.DiskSize) {\n\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume size %d is smaller than requested size %d\", c.selectedPhysicalVolume.Size, c.DiskSize)\n\t}\n\n\t// 检查底层物理卷性能等级是否满足要求\n\tif c.PerformanceRank != \"\" {\n\t\tif string(c.selectedPhysicalVolume.PerformanceRank) != c.PerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not match requested rank %s\", c.selectedPhysicalVolume.PerformanceRank, c.PerformanceRank)\n\t\t}\n\t} else {\n\t\tif c.selectedPhysicalVolume.PerformanceRank != rdiskDomain.DefaultPerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not default rank %s\", c.selectedPhysicalVolume.PerformanceRank, rdiskDomain.DefaultPerformanceRank)\n\t\t}\n\t}\n\n\t// 2. 创建逻辑卷\n\tvol := rdiskDomain.NewLogicalVolume(users.AppID(c.AppID), rdiskDomain.Size(c.DiskSize), rdiskDomain.ZoneID(c.ZoneID))\n\tif c.VolumeType != \"\" {\n\t\tvol.VolumeType = rdiskDomain.VolumeType(c.VolumeType)\n\t}\n\tif c.DiskType != \"\" {\n\t\tvol.DiskType = rdiskDomain.DiskType(c.DiskType)\n\t}\n\terr = lvRepo.Add(ctx, vol)\n\tif err != nil {\n\t\treturn\n\t}\n\tc.createdLogicalVolume = vol\n\n\t// 3. 触发状态机，联动更新逻辑卷和物理卷状态\n\t_, err = sm.Fire(ctx, rdiskDomain.LVSUnInited, rdiskDomain.LVECreateLogicalVolume, c)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_running_backup_task.go",
        "code_start_line": 31,
        "code_end_line": 61,
        "code_key": "Handle",
        "code_value": "func (c *UpdateRunningBackupTaskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventUpdateBackupProgress,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_drgroup.go",
        "code_start_line": 78,
        "code_end_line": 173,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeDRGroupCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tlvView  = app.GetRegistry(ctx).Viewers.LogicalVolume\n\t\tdrgRepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t\tsm      = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\terr     error\n\t)\n\n\t// 0. 初始化\n\tc.drgroupRef = make(map[string]*drgroup.DRGroup)\n\n\t// 1. 加载所有逻辑卷所在的置放群组\n\tallVolumeUUIDs := make([]string, 0, len(c.UUIDs))\n\tfor _, _uuid := range c.UUIDs {\n\t\tallVolumeUUIDs = append(allVolumeUUIDs, _uuid.String())\n\t}\n\tif groups, err := drgRepo.FindByMembers(ctx, c.AppID, allVolumeUUIDs); err == nil {\n\t\tif err != nil {\n\t\t\tif !errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tfor _, group := range groups {\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t\tc.curDRGroupNames = append(c.curDRGroupNames, group.Name)\n\t\t}\n\t} else {\n\t\treturn err\n\t}\n\n\t// 2. 确认已上锁的置放群组和当前一致\n\tif !c.checkLockedDRGroupNames() {\n\t\treturn errors.New(drgroup.ErrGroupModified, \"drgroup changed\")\n\t}\n\n\t// 3. 加载所有逻辑卷的状态，不需要完整实体，因为不会修改 Volume\n\tc.relatedLogicalVolume, err = lvView.FindByIDs(ctx, c.AppID, c.UUIDs)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(c.relatedLogicalVolume) < len(c.UUIDs) {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t// 4. 加载所有目标置放群组，key 为 name\n\tfor _, spec := range c.Specs {\n\t\tvar group *drgroup.DRGroup\n\t\tif _, ok := c.drgroupRef[spec.Name]; ok {\n\t\t\tgroup = c.drgroupRef[spec.Name]\n\t\t} else {\n\t\t\tgroup, err = c.getOrCreateDRGroup(ctx, drgRepo, spec)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t}\n\n\t\tif spec.Affinity > 0 {\n\t\t\tgroup.Affinity = spec.Affinity\n\t\t}\n\t\tif spec.Type != \"\" {\n\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t}\n\t}\n\n\t// 5. 对所有逻辑卷执行置放群组变更事件，检查状态是否允许，\n\t//    实际的更新还是在这里执行。\n\tfor _, vol := range c.relatedLogicalVolume {\n\t\terr := sm.Check(ctx, vol.State, rdiskDomain.LVEUpdateDrGroup, c)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// 将逻辑卷从原有的置放群组中移除\n\t\tfor _, name := range c.curDRGroupNames {\n\t\t\tc.drgroupRef[name].RemoveMember(vol.UUID.String())\n\t\t}\n\t\t// 将逻辑卷添加到新的置放群组中\n\t\tfor _, spec := range c.Specs {\n\t\t\tsubGroup := spec.SubGroup\n\t\t\tif subGroup == \"\" {\n\t\t\t\t// 如果没有指定子组，则使用远端 SSD UUID 作为子组名称\n\t\t\t\t// 相当于每块盘都是一个子组，相当于没有使用子组功能\n\t\t\t\tsubGroup = vol.UUID.String()\n\t\t\t}\n\t\t\tif err := c.drgroupRef[spec.Name].AddMember(vol.UUID.String(), subGroup, vol.PhysicalVolume.IP.String()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tif c.DryRun {\n\t\treturn errors.New(errors.ErrDryRunSuccessExit, \"dry run check success\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/online_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OnlinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOnlinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_benchmark_task.go",
        "code_start_line": 34,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *UpdateBenchmarkTask) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, rdisk.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark, err = benchRepo.FindByUUID(ctx, c.BenchmarkUUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventUpdateBench, benchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_flow_ctrl.go",
        "code_start_line": 80,
        "code_end_line": 103,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeFlowControlCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not found\")\n\t}\n\n\tspec := c.volume.FlowControlSpec\n\tif !c.UpdateRequest.UpdateSpec(&spec, c.volume.GetDefaultFlowControlSpec()) {\n\t\t// 没有任何更新，直接返回成功\n\t\treturn nil\n\t}\n\tc.volume.SetFlowControlSpec(spec)\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEUpdateFlowControl, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_defunct_volume.go",
        "code_start_line": 46,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *CleanupDefunctCommand) Handle(ctx context.Context) error {\n\tvar err error\n\tc.lv, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar sm = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\tvar event = rdiskDomain.LVECleanupDefunct\n\n\tfor _, attachment := range c.lv.Attachments {\n\t\tlogs.Info(ctx).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).Msg(\"cleanup defuncting volume\")\n\t\tsubCmd := &cleanDefunctSubCommand{Parent: c, HostIP: attachment.IP}\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, subCmd)\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，因为只要有一个挂载点清理失败，其他挂载点还是需要继续清理的\n\t\t\t// 失败的挂载点会在后台继续清理\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).\n\t\t\t\tMsg(\"failed to cleanup defunct volume, retry later.\")\n\t\t}\n\t}\n\n\tif len(c.lv.Attachments) == 0 {\n\t\t// 没有挂载点，直接清理\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, &cleanDefunctSubCommand{Parent: c, HostIP: net.IP{}})\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，后续自动重试即可\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Msg(\"failed to complete cleanup defunct volume\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_drgroup_exists.go",
        "code_start_line": 28,
        "code_end_line": 53,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDRGroupExistsCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t)\n\tfor _, spec := range c.DRGroup {\n\t\t_, err := repo.FindByName(ctx, users.AppID(c.AppID), spec.Name)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\tgroup := drgroup.New(spec.Name, users.AppID(c.AppID))\n\t\t\t\tif spec.Affinity > 0 {\n\t\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t\t}\n\t\t\t\tif spec.Type != \"\" {\n\t\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t\t}\n\t\t\t\terr = repo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_physical_volume.go",
        "code_start_line": 31,
        "code_end_line": 54,
        "code_key": "Handle",
        "code_value": "func (c *UpdatePhyRDiskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEUpdatePhysicalVolume, c)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/recycle_backup_data.go",
        "code_start_line": 32,
        "code_end_line": 62,
        "code_key": "Handle",
        "code_value": "func (c *RecycleBackupDataCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventDeleteBackup,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/clients/cos/client.go",
        "code_start_line": 101,
        "code_end_line": 104,
        "code_key": "DeleteObject",
        "code_value": "func (c *clientImpl) DeleteObject(ctx context.Context, key string) error {\n\t_, err := c.c.Object.Delete(ctx, key)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go",
        "code_start_line": 208,
        "code_end_line": 215,
        "code_key": "deleteFinishTask",
        "code_value": "func (sc *Scheduler) deleteFinishTask(ctx context.Context, task interfaces.Task) {\n\tsubTaskName := task.GetSubTaskName()\n\tif _, ok := sc.metrics.taskExecuteCountMap[subTaskName]; !ok {\n\t\tsc.metrics.taskExecuteCountMap[subTaskName], _ = initHistogramVec(subTaskName).GetMetricWith(sc.metrics.labels)\n\t}\n\tsc.metrics.taskExecuteCountMap[subTaskName].Observe(float64(task.GetExecuteCounts()))\n\tsc.taskMap.Delete(task.GetTaskId())\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_physical_volume.go",
        "code_start_line": 113,
        "code_end_line": 131,
        "code_key": "checkExisting",
        "code_value": "func (c *CreatePhysicalVolumeCommand) checkExisting(ctx context.Context, vol *domain.PhysicalVolume) (existed bool, err error) {\n\tif vol == nil {\n\t\treturn false, nil\n\t}\n\tif vol.Deleted() {\n\t\terr := app.GetRegistry(ctx).Repositories.PhysicalVolume.Delete(ctx, vol)\n\t\tif err != nil {\n\t\t\treturn false, errors.Newf(domain.ErrConflictVolume, \"failed to delete conflict physical volume: %v\", err)\n\t\t}\n\t\treturn false, nil\n\t}\n\tif string(vol.Serial) != c.Serial {\n\t\treturn false, errors.Newf(domain.ErrConflictVolume, \"host %s bdf %s has been taken by %s\", vol.IP, vol.BDF, vol.Serial)\n\t}\n\tif !vol.IP.Equal(c.Host) || string(vol.BDF) != c.BDF {\n\t\treturn false, errors.Newf(domain.ErrConflictVolume, \"volume %s has been assigned to host %s bdf %s\", vol.Serial, vol.IP, vol.BDF)\n\t}\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/create_logic_disk.go",
        "code_start_line": 61,
        "code_end_line": 63,
        "code_key": "InvokeDeleteLogicalVolume",
        "code_value": "func InvokeDeleteLogicalVolume(ctx context.Context, source rdiskDomain.LogicalVolumeState, target rdiskDomain.LogicalVolumeState, stateCtx app.LogicalVolumeContext) (rdiskDomain.LogicalVolumeState, error) {\n\treturn target, stateCtx.GetLogicalVolume().Delete()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go",
        "code_start_line": 199,
        "code_end_line": 305,
        "code_key": "updateLogicalVolume",
        "code_value": "func updateLogicalVolume(ctx context.Context, item, originalState *rdiskDomain.LogicalVolume) error {\n\tuow := getUow(ctx)\n\tcurDO := fromModelToDmRDisk(item)\n\toriginalDO := fromModelToDmRDisk(originalState)\n\tchanges := make(map[string]interface{})\n\tcheckChange := func(field string, cur interface{}, original interface{}) {\n\t\tif cur != original {\n\t\t\tchanges[field] = cur\n\t\t}\n\t}\n\tcheckChange(\"uuid\", curDO.UUID, originalDO.UUID)\n\tcheckChange(\"status\", curDO.Status, originalDO.Status)\n\tcheckChange(\"app_id\", curDO.AppID, originalDO.AppID)\n\tcheckChange(\"size\", curDO.Size, originalDO.Size)\n\tcheckChange(\"phydisk_serial\", curDO.PhydiskSerial, originalDO.PhydiskSerial)\n\tcheckChange(\"zone_id\", curDO.ZoneID, originalDO.ZoneID)\n\tcheckChange(\"volume_type\", curDO.VolumeType, originalDO.VolumeType)\n\tcheckChange(\"disk_type\", curDO.DiskType, originalDO.DiskType)\n\tcheckChange(\"read_iops\", curDO.ReadIOPS, originalDO.ReadIOPS)\n\tcheckChange(\"write_iops\", curDO.WriteIOPS, originalDO.WriteIOPS)\n\tcheckChange(\"rw_iops\", curDO.ReadWriteIOPS, originalDO.ReadWriteIOPS)\n\tcheckChange(\"read_bandwidth\", curDO.ReadBandwidth, originalDO.ReadBandwidth)\n\tcheckChange(\"write_bandwidth\", curDO.WriteBandwidth, originalDO.WriteBandwidth)\n\tcheckChange(\"rw_bandwidth\", curDO.ReadWriteBandwidth, originalDO.ReadWriteBandwidth)\n\n\tif len(changes) != 0 {\n\t\tchanges[\"updated\"] = uow.tx.NowFunc()\n\n\t\tresult := uow.tx.Model(curDO).Where(\"id = ?\", curDO.ID).Updates(changes)\n\t\tif result.Error != nil {\n\t\t\treturn result.Error\n\t\t}\n\t}\n\n\t// 更新挂载信息\n\n\tallHosts := make(map[string]struct{})\n\toriginHosts := make(map[string]*rdiskDomain.VolumeAttachment)\n\tcurHosts := make(map[string]*rdiskDomain.VolumeAttachment)\n\tfor _, a := range item.Attachments {\n\t\tallHosts[a.IP.String()] = struct{}{}\n\t\tcurHosts[a.IP.String()] = a\n\t}\n\tfor _, a := range originalState.Attachments {\n\t\tallHosts[a.IP.String()] = struct{}{}\n\t\toriginHosts[a.IP.String()] = a\n\t}\n\n\tfor hostIp := range allHosts {\n\t\tcurAttachment, _ := curHosts[hostIp]\n\t\toriginAttachment, _ := originHosts[hostIp]\n\t\tif originAttachment == nil && curAttachment != nil {\n\t\t\t// 新增挂载\n\t\t\tdo := fromModelToDmRDiskAttachment(curAttachment)\n\t\t\tdo.UUID = curDO.UUID\n\t\t\tdo.Created = uow.tx.NowFunc()\n\t\t\tdo.Updated = uow.tx.NowFunc()\n\t\t\terr := uow.tx.Model(curDO).Association(\"Attachments\").Append(do)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else if originAttachment != nil && curAttachment == nil {\n\t\t\t// 删除挂载\n\t\t\tdo := fromModelToDmRDiskAttachment(originAttachment)\n\t\t\tdo.UUID = curDO.UUID\n\t\t\tresult := uow.tx.Where(\"host_ip = ? and uuid = ?\", do.IP, do.UUID).Delete(do)\n\t\t\tif result.Error != nil {\n\t\t\t\treturn result.Error\n\t\t\t}\n\t\t} else if originAttachment != nil && curAttachment != nil {\n\t\t\t// 更新挂载\n\t\t\tdo := fromModelToDmRDiskAttachment(curAttachment)\n\t\t\tdo.UUID = curDO.UUID\n\t\t\toriginDo := fromModelToDmRDiskAttachment(originAttachment)\n\t\t\toriginDo.UUID = curDO.UUID\n\t\t\tchanges := make(map[string]interface{})\n\t\t\tcheckChange := func(field string, cur interface{}, original interface{}) {\n\t\t\t\tif cur != original {\n\t\t\t\t\tchanges[field] = cur\n\t\t\t\t}\n\t\t\t}\n\t\t\tcheckChange(\"mode\", do.Mode, originDo.Mode)\n\t\t\tcheckChange(\"read_iops\", do.ReadIOPS, originDo.ReadIOPS)\n\t\t\tcheckChange(\"write_iops\", do.WriteIOPS, originDo.WriteIOPS)\n\t\t\tcheckChange(\"rw_iops\", do.ReadWriteIOPS, originDo.ReadWriteIOPS)\n\t\t\tcheckChange(\"read_bandwidth\", do.ReadBandwidth, originDo.ReadBandwidth)\n\t\t\tcheckChange(\"write_bandwidth\", do.WriteBandwidth, originDo.WriteBandwidth)\n\t\t\tcheckChange(\"rw_bandwidth\", do.ReadWriteBandwidth, originDo.ReadWriteBandwidth)\n\t\t\tcheckChange(\"num_queue\", do.NumQueue, originDo.NumQueue)\n\t\t\tcheckChange(\"serial\", do.Serial, originDo.Serial)\n\t\t\tcheckChange(\"vcpu\", do.VCPU, originDo.VCPU)\n\t\t\tcheckChange(\"spdk_driver\", do.SPDKDriver, originDo.SPDKDriver)\n\n\t\t\tif len(changes) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tchanges[\"updated\"] = uow.tx.NowFunc()\n\t\t\tresult := uow.tx.Model(do).Where(\"host_ip = ? and uuid = ?\", do.IP, do.UUID).Updates(changes)\n\t\t\tif result.Error != nil {\n\t\t\t\treturn result.Error\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
        "code_start_line": 165,
        "code_end_line": 277,
        "code_key": "updateDRGroup",
        "code_value": "func updateDRGroup(ctx context.Context, item, originalState *drgroup.DRGroup) error {\n\tuow := getUow(ctx)\n\tcurDO := fromModelToDmDRGroup(item)\n\toriginalDO := fromModelToDmDRGroup(originalState)\n\tchanges := make(map[string]interface{})\n\tcheckChange := func(field string, cur interface{}, original interface{}) {\n\t\tif cur != original {\n\t\t\tif field == \"member_cnt\" || field == \"sub_group_cnt\" {\n\t\t\t\tdiff := cur.(int) - original.(int)\n\t\t\t\tif diff < 0 {\n\t\t\t\t\tchanges[field] = gorm.Expr(fmt.Sprintf(\"%s - %d\", field, -1*diff))\n\t\t\t\t} else {\n\t\t\t\t\tchanges[field] = gorm.Expr(fmt.Sprintf(\"%s + %d\", field, diff))\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tchanges[field] = cur\n\t\t\t}\n\t\t}\n\t}\n\tcheckChange(\"status\", curDO.Status, originalDO.Status)\n\tcheckChange(\"app_id\", curDO.AppID, originalDO.AppID)\n\tcheckChange(\"name\", curDO.Name, originalDO.Name)\n\tcheckChange(\"affinity\", curDO.Affinity, originalDO.Affinity)\n\tcheckChange(\"loc_type\", curDO.LocType, originalDO.LocType)\n\tcheckChange(\"satisfied\", curDO.Satisfied, originalDO.Satisfied)\n\tcheckChange(\"member_cnt\", curDO.MemberCnt, originalDO.MemberCnt)\n\tcheckChange(\"sub_group_cnt\", curDO.SubGroupCnt, originalDO.SubGroupCnt)\n\tcheckChange(\"extra\", curDO.Extra, originalDO.Extra)\n\n\tif len(changes) != 0 {\n\t\tchanges[\"updated\"] = uow.tx.NowFunc()\n\n\t\tresult := uow.tx.Model(curDO).Where(\"id = ?\", curDO.ID).Updates(changes)\n\t\tif result.Error != nil {\n\t\t\treturn result.Error\n\t\t}\n\t}\n\n\t// 更新成员信息\n\tallMembers := make(map[string]struct{})\n\ttype memberInfo struct {\n\t\tLoc      string\n\t\tSubGroup string\n\t}\n\toriginMembers := make(map[string]memberInfo)\n\tcurMembers := make(map[string]memberInfo)\n\tfor _, a := range item.GetMembers() {\n\t\tallMembers[a.ID] = struct{}{}\n\t\tcurMembers[a.ID] = memberInfo{\n\t\t\tLoc:      a.Location,\n\t\t\tSubGroup: a.SubGroup,\n\t\t}\n\t}\n\tfor _, a := range originalState.GetMembers() {\n\t\tallMembers[a.ID] = struct{}{}\n\t\toriginMembers[a.ID] = memberInfo{\n\t\t\tLoc:      a.Location,\n\t\t\tSubGroup: a.SubGroup,\n\t\t}\n\t}\n\n\tfor memberId := range allMembers {\n\t\tcurInfo, _ := curMembers[memberId]\n\t\toriginInfo, _ := originMembers[memberId]\n\t\tif originInfo.Loc == \"\" && curInfo.Loc != \"\" {\n\t\t\tdo := &metadb.DmDrgroupMembers{\n\t\t\t\tAppID:     int64(item.AppID),\n\t\t\t\tGroupName: item.Name,\n\t\t\t\tSubGroup:  curInfo.SubGroup,\n\t\t\t\tLoc:       curInfo.Loc,\n\t\t\t\tMemberID:  memberId,\n\t\t\t\tExtra:     \"{}\",\n\t\t\t\tCreated:   uow.tx.NowFunc(),\n\t\t\t\tUpdated:   uow.tx.NowFunc(),\n\t\t\t}\n\t\t\tresult := uow.tx.Create(do)\n\t\t\tif result.Error != nil {\n\t\t\t\treturn result.Error\n\t\t\t}\n\t\t} else if originInfo.Loc != \"\" && curInfo.Loc == \"\" {\n\t\t\tresult := uow.tx.Delete(&metadb.DmDrgroupMembers{},\n\t\t\t\t\"app_id = ? and group_name = ? and member_id = ?\",\n\t\t\t\toriginalState.AppID, originalState.Name, memberId)\n\t\t\tif result.Error != nil {\n\t\t\t\treturn result.Error\n\t\t\t}\n\t\t} else if originInfo.Loc != \"\" && curInfo.Loc != \"\" {\n\t\t\tchanges := make(map[string]interface{})\n\t\t\tcheckChange := func(field string, cur interface{}, original interface{}) {\n\t\t\t\tif cur != original {\n\t\t\t\t\tchanges[field] = cur\n\t\t\t\t}\n\t\t\t}\n\t\t\tcheckChange(\"loc\", curInfo.Loc, originInfo.Loc)\n\t\t\tcheckChange(\"app_id\", item.AppID, originalState.AppID)\n\t\t\tcheckChange(\"group_name\", item.Name, originalState.Name)\n\t\t\tcheckChange(\"sub_group\", curInfo.SubGroup, originInfo.SubGroup)\n\t\t\t//checkChange(\"extra\", \"{}\", \"{}\")\n\n\t\t\tif len(changes) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tchanges[\"updated\"] = uow.tx.NowFunc()\n\t\t\tresult := uow.tx.Model(&metadb.DmDrgroupMembers{}).Where(\n\t\t\t\t\"app_id = ? and group_name = ? and member_id = ?\",\n\t\t\t\toriginalState.AppID, originalState.Name, memberId).Updates(changes)\n\t\t\tif result.Error != nil {\n\t\t\t\treturn result.Error\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 65,
        "code_end_line": 82,
        "code_key": "DmPhydisk",
        "code_value": "type DmPhydisk struct {\n\tID         uint64    `gorm:\"column:id;primaryKey\"`\n\tSerial     string    `gorm:\"column:serial;unique\"`\n\tIP         string    `gorm:\"column:host_ip\"`\n\tBDF        string    `gorm:\"column:bdf\"`\n\tDiskID     uint64    `gorm:\"column:disk_id\"`\n\tPort       int       `gorm:\"column:port\"`\n\tStatus     int       `gorm:\"column:status\"`\n\tSize       uint32    `gorm:\"column:size\"`\n\tRealSize   int64     `gorm:\"column:real_size\"`\n\tBlockSize  int       `gorm:\"column:block_size\"`\n\tZoneID     uint64    `gorm:\"column:zone_id\"`\n\tVolumeType string    `gorm:\"column:volume_type\"`\n\tExtra      string    `gorm:\"column:extra\"`\n\tCreated    time.Time `gorm:\"column:created\"`\n\tUpdated    time.Time `gorm:\"column:updated\"`\n\tPerfRank   string    `gorm:\"column:perf_rank\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 85,
        "code_end_line": 87,
        "code_key": "TableName",
        "code_value": "func (d *DmPhydisk) TableName() string {\n\treturn \"dm_phydisk\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 90,
        "code_end_line": 92,
        "code_key": "DBName",
        "code_value": "func (d *DmPhydisk) DBName() string {\n\treturn \"metadb\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 57,
        "code_end_line": 75,
        "code_key": "DmPhydisk",
        "code_value": "type DmPhydisk struct {\n\tID              uint64    `gorm:\"column:id;primaryKey\"`\n\tSerial          string    `gorm:\"column:serial;unique\"`\n\tIP              string    `gorm:\"column:host_ip\"`\n\tBDF             string    `gorm:\"column:bdf\"`\n\tDiskID          uint64    `gorm:\"column:disk_id\"`\n\tPort            int       `gorm:\"column:port\"`\n\tStatus          int       `gorm:\"column:status\"`\n\tSize            int64     `gorm:\"column:size\"`\n\tRealSize        int64     `gorm:\"column:real_size\"`\n\tBlockSize       int       `gorm:\"column:block_size\"`\n\tZoneID          int64     `gorm:\"column:zone_id\"`\n\tVolumeType      string    `gorm:\"column:volume_type\"`\n\tExtra           string    `gorm:\"column:extra\"`\n\tNodeType        string    `gorm:\"column:node_type\"`\n\tCreated         time.Time `gorm:\"column:created\"`\n\tUpdated         time.Time `gorm:\"column:updated\"`\n\tPerformanceRank string    `gorm:\"column:perf_rank\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 77,
        "code_end_line": 79,
        "code_key": "TableName",
        "code_value": "func (DmPhydisk) TableName() string {\n\treturn \"dm_phydisk\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go:111:122:Delete": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
    "code_start_line": 111,
    "code_end_line": 122,
    "code_start_column": 32,
    "code_key": "Delete",
    "code_value": "func (d drgroupRepositoryImpl) Delete(ctx context.Context, group *drgroup.DRGroup) error {\n\tuow := getUow(ctx)\n\tresult := uow.tx.Delete(&metadb.DmDrgroup{}, \"id = ?\", group.ID)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tresult = uow.tx.Delete(&metadb.DmDrgroupMembers{}, \"app_id = ? and group_name = ?\", group.AppID, group.Name)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 2,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/expiremap.go",
        "code_start_line": 91,
        "code_end_line": 96,
        "code_key": "Delete",
        "code_value": "func (e *ExpiredMap) Delete(key interface{}) {\n\te.lck.Lock()\n\tdelete(e.m, key)\n\te.deleteTimeMap(key)\n\te.lck.Unlock()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/scheduler.go",
        "code_start_line": 135,
        "code_end_line": 139,
        "code_key": "Delete",
        "code_value": "func (s *scheduler) Delete(name string) {\n\ts.mutex.Lock()\n\tdefer s.mutex.Unlock()\n\tdelete(s.loads, name)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/benchmark.go",
        "code_start_line": 32,
        "code_end_line": 39,
        "code_key": "Delete",
        "code_value": "func (repo *rdiskBenchmarkRepositoryImpl) Delete(ctx context.Context, bench *benchmark.Benchmark) error {\n\tuow := getUow(ctx)\n\tresult := uow.tx.Delete(&metadb.DmRdiskBenchmark{}, \"id = ?\", bench.ID)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/backup.go",
        "code_start_line": 34,
        "code_end_line": 41,
        "code_key": "Delete",
        "code_value": "func (*rdiskBackupRepositoryImpl) Delete(ctx context.Context, backup *backupPkg.Backup) error {\n\tuow := getUow(ctx)\n\tresult := uow.tx.Delete(&metadb.DmRdiskBackup{}, \"id = ?\", backup.ID)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go",
        "code_start_line": 73,
        "code_end_line": 81,
        "code_key": "Delete",
        "code_value": "func (p *physicalVolumeRepositoryImpl) Delete(ctx context.Context, pv *rdiskDomain.PhysicalVolume) error {\n\tuow := getUow(ctx)\n\tidt := pv.GetID()\n\tresult := uow.tx.Where(\"id = ?\", idt).Delete(&metadb.DmPhydisk{})\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
        "code_start_line": 111,
        "code_end_line": 122,
        "code_key": "Delete",
        "code_value": "func (d drgroupRepositoryImpl) Delete(ctx context.Context, group *drgroup.DRGroup) error {\n\tuow := getUow(ctx)\n\tresult := uow.tx.Delete(&metadb.DmDrgroup{}, \"id = ?\", group.ID)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tresult = uow.tx.Delete(&metadb.DmDrgroupMembers{}, \"app_id = ? and group_name = ?\", group.AppID, group.Name)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 356,
        "code_end_line": 363,
        "code_key": "Delete",
        "code_value": "func (l *LogicalVolume) Delete() error {\n\tif len(l.Attachments) > 0 {\n\t\treturn errors.New(ErrVolumeAttached, \"volume is still attached to some hosts\")\n\t}\n\tl.PhysicalVolume = nil\n\tl.State = LVSDeleted\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 54,
        "code_end_line": 59,
        "code_key": "Delete",
        "code_value": "func (m *MockPhysicalVolumeRepository) Delete(arg0 context.Context, arg1 *rdiskDomain.PhysicalVolume) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Delete\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 62,
        "code_end_line": 65,
        "code_key": "Delete",
        "code_value": "func (mr *MockPhysicalVolumeRepositoryMockRecorder) Delete(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Delete\", reflect.TypeOf((*MockPhysicalVolumeRepository)(nil).Delete), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 54,
        "code_end_line": 59,
        "code_key": "Delete",
        "code_value": "func (m *MockRepository) Delete(arg0 context.Context, arg1 *drgroup.DRGroup) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Delete\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 62,
        "code_end_line": 65,
        "code_key": "Delete",
        "code_value": "func (mr *MockRepositoryMockRecorder) Delete(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Delete\", reflect.TypeOf((*MockRepository)(nil).Delete), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/expiremap.go",
        "code_start_line": 98,
        "code_end_line": 100,
        "code_key": "Remove",
        "code_value": "func (e *ExpiredMap) Remove(key interface{}) {\n\te.Delete(key)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/managers/shm.go",
        "code_start_line": 51,
        "code_end_line": 54,
        "code_key": "Remove",
        "code_value": "func (s *ShmCacheManager) Remove(ctx context.Context, keyResolver cache.GeneralCacheKeyResolverInf) error {\n\ts.m.Delete(keyResolver.GenerateKey(ctx))\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/subgroup.go",
        "code_start_line": 78,
        "code_end_line": 82,
        "code_key": "Remove",
        "code_value": "func (s *SubGroupCacheManager) Remove(ctx context.Context, keyResolver cache.GeneralCacheKeyResolverInf) error {\n\tcacheKey := keyResolver.GenerateKey(ctx)\n\ts.cacheMap.Delete(cacheKey)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/managers/shm.go",
        "code_start_line": 82,
        "code_end_line": 84,
        "code_key": "Pop",
        "code_value": "func (s *ShmCacheManager) Pop(ctx context.Context, keyResolver cache.GeneralCacheKeyResolverInf) (interface{}, error) {\n\tpanic(\"implement me\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/subgroup.go",
        "code_start_line": 104,
        "code_end_line": 117,
        "code_key": "Pop",
        "code_value": "func (s *SubGroupCacheManager) Pop(ctx context.Context, keyResolver cache.GeneralCacheKeyResolverInf) (interface{}, error) {\n\tcacheKey := keyResolver.GenerateKey(ctx)\n\tif ok, disks := s.cacheMap.Get(cacheKey); ok {\n\t\tniceDisks := disks.([]*disk.Disk)\n\t\toneDisk := niceDisks[0]\n\t\tif len(niceDisks) > 1 {\n\t\t\ts.cacheMap.Set(cacheKey, niceDisks[1:], s.expiredSeconds)\n\t\t} else {\n\t\t\ts.cacheMap.Delete(cacheKey)\n\t\t}\n\t\treturn oneDisk, nil\n\t}\n\treturn nil, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/queue/priority_queue.go",
        "code_start_line": 35,
        "code_end_line": 42,
        "code_key": "Pop",
        "code_value": "func (pq *PriorityQueue) Pop() any {\n\told := pq.Task\n\tn := len(old)\n\titem := old[n-1]\n\told[n-1] = nil // avoid memory leak\n\tpq.Task = old[0 : n-1]\n\treturn item\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/queue/priority_queue.go",
        "code_start_line": 56,
        "code_end_line": 60,
        "code_key": "Pop",
        "code_value": "func (spq *SyncTaskPriorityQueue) Pop() interfaces.Task {\n\tspq.mutex.Lock()\n\tdefer spq.mutex.Unlock()\n\treturn heap.Pop(spq.priorityQueue).(interfaces.Task)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go",
        "code_start_line": 51,
        "code_end_line": 72,
        "code_key": "Handle",
        "code_value": "func (c *CbsAppIdConsumer) Handle(ctx context.Context, delivery *rabbitmq.Delivery) error {\n\tu, chargeTime, err := c.ParseDelivery(ctx, delivery)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif u == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"USER_INFO_NOT_FOUND\")\n\t\treturn nil\n\t}\n\n\tchargeDetail := c.GetChargeDetailForSingleUser(u, chargeTime)\n\tif chargeDetail == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tUint64(\"appId\", uint64(u.AppId)).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"NO_RESOURCE_TO_CHARGE\")\n\t\treturn nil\n\t}\n\treturn c.ProcessChargeDetail(chargeDetail)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 105,
        "code_end_line": 116,
        "code_key": "Handle",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tif err := c.ensureLocks(ctx); err != nil {\n\t\treturn err\n\t}\n\tif c.lvUUID != nil {\n\t\t// 涉及到逻辑卷时，需要先标记逻辑卷为故障\n\t\treturn c.handleBindedVolume(ctx)\n\t} else {\n\t\t// 不涉及到逻辑卷时，直接标记物理卷为故障\n\t\treturn c.handleIdleVolume(ctx)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/detach_logical_volume.go",
        "code_start_line": 56,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *DetachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDetachLogicalVolume, c)\n\n\t// 如果没有挂载到指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume not attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_benchmark_task.go",
        "code_start_line": 125,
        "code_end_line": 165,
        "code_key": "Handle",
        "code_value": "func (c *CreateBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tvolSm     = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = volSm.Fire(ctx, c.relatedVolume.State, domain.PVEStartBenchmark, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark = benchmark.New(benchmark.DiskInfo{\n\t\tSerial: string(c.relatedVolume.Serial),\n\t\tHostIP: c.relatedVolume.IP,\n\t\tBDF:    string(c.relatedVolume.BDF),\n\t})\n\n\tif err = benchRepo.Add(ctx, c.relatedBenchmark); err != nil {\n\t\tdelegate := &benchmarkDelegate{cmd: c}\n\t\tif _err := delegate.TaskFinishCallback(ctx, c.relatedBenchmark); _err != nil {\n\t\t\tlogs.Warn(ctx).Err(_err).Str(\"serial\", string(c.relatedVolume.Serial)).Msg(\"failed to rollback: create bdev\")\n\t\t}\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventCreateBench,\n\t\tbenchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_logical_volume.go",
        "code_start_line": 71,
        "code_end_line": 108,
        "code_key": "Handle",
        "code_value": "func (d *DeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\td.volume, err = repo.FindByID(ctx, d.UUID)\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif e := d.volume.CheckDelete(); e != nil {\n\t\treturn e\n\t}\n\n\tif d.volume.AppID != d.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"refuse to delet: app id mismatch\")\n\t}\n\n\td.drgroup, err = app.GetRegistry(ctx).Repositories.DRGroup.FindByMember(ctx, d.AppID, d.volume.UUID.String())\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\td.drgroup = nil\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := d.checkDRGroupMatch(ctx); err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, d.volume.State, rdiskDomain.LVEMarkToRecycle, d)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_recycled_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmRecycledPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEConfirmRecycled, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_rdisk_backup.go",
        "code_start_line": 52,
        "code_end_line": 75,
        "code_key": "Handle",
        "code_value": "func (c *DeleteRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tsm   = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\tc.relatedBackup, err = repo.FindByUUID(ctx, c.BackupID.String())\n\tif err != nil || c.relatedBackup == nil || c.relatedBackup.AppID != c.AppID {\n\t\treturn errors.New(backupDomain.ErrBackupNotExist, \"backup not exists\")\n\t}\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tc.relatedBackup.Status,\n\t\tbackupDomain.EventSoftDeleteBackup,\n\t\tbackupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: c.relatedBackup})\n\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_rdisk_backup.go",
        "code_start_line": 47,
        "code_end_line": 80,
        "code_key": "Handle",
        "code_value": "func (c *CreateRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tlvSm  = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\tbakSm = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo  = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t_, err = lvSm.Fire(ctx, c.relatedVolume.State, rdiskDomain.LVEBackupStarted, c)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tlv := c.relatedVolume\n\tbackup := backupDomain.New(\n\t\tlv.AppID,\n\t\tbackupDomain.DiskInfo{\n\t\t\tVolumeUUID: lv.UUID,\n\t\t\tVolumeSize: uint64(lv.Size),\n\t\t\tHostIP:     lv.PhysicalVolume.IP,\n\t\t\tHostBDF:    string(lv.PhysicalVolume.BDF),\n\t\t\tSerial:     string(lv.PhysicalVolume.Serial),\n\t\t},\n\t)\n\tif err := repo.Add(ctx, backup); err != nil {\n\t\treturn err\n\t}\n\tc.relatedBackup = backup\n\t_, err = bakSm.Fire(ctx, backupDomain.StatusInit, backupDomain.EventStartBackup, backupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: backup})\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/attach_logical_volume.go",
        "code_start_line": 49,
        "code_end_line": 71,
        "code_key": "Handle",
        "code_value": "func (c *AttachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEAttachLogicalVolume, c)\n\n\t// 如果已经挂载到了指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeAlreadyAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume already attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_delete_logical_volume.go",
        "code_start_line": 34,
        "code_end_line": 55,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\t// 如果逻辑卷不存在，则直接返回成功\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"failed to confirm delete: app id mismatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDeleteLogicalVolume, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/offline_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OfflinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOfflinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *DeletePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\t// 如果物理卷不存在，则直接幂等返回\n\t\treturn nil\n\t}\n\n\tvar event = domain.PVEDeletePhysicalVolume\n\tif c.Force && (c.relatedVolume.State == domain.PVSDefunct) {\n\t\t// 这里的实现不太好，状态机的逻辑不应该侵入 cmd\n\t\t// 时间太赶了，后续重构优化吧\n\t\tevent = domain.PVEForceDeleteForDefunct\n\t}\n\n\tif c.relatedVolume.HasBindedPV() {\n\t\treturn errors.New(domain.ErrVolumeBusy, \"logic volume has binded to this physical volume\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, event, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_logical_volume.go",
        "code_start_line": 55,
        "code_end_line": 70,
        "code_key": "Handle",
        "code_value": "func (c *CleanupLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVECleanupLogicalVolume, c)\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_init_physical_volume.go",
        "code_start_line": 26,
        "code_end_line": 52,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmInitPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\tif c.relatedVolume.IP.String() != c.Host.String() {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume host ip mistmatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVECreatePhysicalVolumeOnHost, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_physical_volume.go",
        "code_start_line": 51,
        "code_end_line": 101,
        "code_key": "Handle",
        "code_value": "func (c *CreatePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\n\t// 获取物理卷状态机\n\tsm := app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\trepo := app.GetRegistry(ctx).Repositories.PhysicalVolume\n\n\t// 检查物理卷是否已经存在，如果存在则直接幂等返回\n\tvol1, err := repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"serial\", c.Serial).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tvol2, err := repo.FindByIPAndBDF(ctx, c.Host, domain.BDF(c.BDF))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"host\", c.Host.String()).Str(\"bdf\", c.BDF).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tfor _, vol := range []*domain.PhysicalVolume{vol1, vol2} {\n\t\texisted, err := c.checkExisting(ctx, vol)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif existed {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// 触发事件，创建物理卷\n\t_, err = sm.Fire(ctx,\n\t\tdomain.PVSUnInited,\n\t\tdomain.PVECreatePhysicalVolume,\n\t\tc,\n\t)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 创建 Bdev 以及格式化移动到创建物理卷的状态机中\n\n\t// _, err = sm.Fire(ctx,\n\t// \tc.GetPhysicalVolume().State,\n\t// \tdomain.PVECreatePhysicalVolumeOnHost,\n\t// \tc,\n\t// )\n\t// if err != nil {\n\t// \treturn err\n\t// }\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_benchmark_task.go",
        "code_start_line": 32,
        "code_end_line": 57,
        "code_key": "Handle",
        "code_value": "func (c *DeleteBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\terr       error\n\t)\n\n\tbench, err := benchRepo.FindByUUID(ctx, c.BenchmarkUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif bench.DiskInfo.Serial != c.Serial {\n\t\treturn errors.Newf(benchmark.ErrTaskNotFound, \"benchmark serial not match %s, want %s\", c.Serial, bench.DiskInfo.Serial)\n\t}\n\n\t_, err = benchSm.Fire(ctx, bench.Status, benchmark.EventDeleteBench, benchmark.Data{Benchmark: bench, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := benchRepo.Delete(ctx, bench); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_logical_volume.go",
        "code_start_line": 52,
        "code_end_line": 98,
        "code_key": "Handle",
        "code_value": "func (c *CreateLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tpvRepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tlvRepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm     = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\t// 1. 查找底层物理卷\n\tc.selectedPhysicalVolume, err = pvRepo.FindBySerial(ctx, rdiskDomain.Serial(c.PhysicalVolumeSerial))\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// 检查底层物理卷大小是否满足要求\n\tif c.selectedPhysicalVolume.Size < rdiskDomain.Size(c.DiskSize) {\n\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume size %d is smaller than requested size %d\", c.selectedPhysicalVolume.Size, c.DiskSize)\n\t}\n\n\t// 检查底层物理卷性能等级是否满足要求\n\tif c.PerformanceRank != \"\" {\n\t\tif string(c.selectedPhysicalVolume.PerformanceRank) != c.PerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not match requested rank %s\", c.selectedPhysicalVolume.PerformanceRank, c.PerformanceRank)\n\t\t}\n\t} else {\n\t\tif c.selectedPhysicalVolume.PerformanceRank != rdiskDomain.DefaultPerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not default rank %s\", c.selectedPhysicalVolume.PerformanceRank, rdiskDomain.DefaultPerformanceRank)\n\t\t}\n\t}\n\n\t// 2. 创建逻辑卷\n\tvol := rdiskDomain.NewLogicalVolume(users.AppID(c.AppID), rdiskDomain.Size(c.DiskSize), rdiskDomain.ZoneID(c.ZoneID))\n\tif c.VolumeType != \"\" {\n\t\tvol.VolumeType = rdiskDomain.VolumeType(c.VolumeType)\n\t}\n\tif c.DiskType != \"\" {\n\t\tvol.DiskType = rdiskDomain.DiskType(c.DiskType)\n\t}\n\terr = lvRepo.Add(ctx, vol)\n\tif err != nil {\n\t\treturn\n\t}\n\tc.createdLogicalVolume = vol\n\n\t// 3. 触发状态机，联动更新逻辑卷和物理卷状态\n\t_, err = sm.Fire(ctx, rdiskDomain.LVSUnInited, rdiskDomain.LVECreateLogicalVolume, c)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_running_backup_task.go",
        "code_start_line": 31,
        "code_end_line": 61,
        "code_key": "Handle",
        "code_value": "func (c *UpdateRunningBackupTaskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventUpdateBackupProgress,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_drgroup.go",
        "code_start_line": 78,
        "code_end_line": 173,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeDRGroupCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tlvView  = app.GetRegistry(ctx).Viewers.LogicalVolume\n\t\tdrgRepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t\tsm      = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\terr     error\n\t)\n\n\t// 0. 初始化\n\tc.drgroupRef = make(map[string]*drgroup.DRGroup)\n\n\t// 1. 加载所有逻辑卷所在的置放群组\n\tallVolumeUUIDs := make([]string, 0, len(c.UUIDs))\n\tfor _, _uuid := range c.UUIDs {\n\t\tallVolumeUUIDs = append(allVolumeUUIDs, _uuid.String())\n\t}\n\tif groups, err := drgRepo.FindByMembers(ctx, c.AppID, allVolumeUUIDs); err == nil {\n\t\tif err != nil {\n\t\t\tif !errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tfor _, group := range groups {\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t\tc.curDRGroupNames = append(c.curDRGroupNames, group.Name)\n\t\t}\n\t} else {\n\t\treturn err\n\t}\n\n\t// 2. 确认已上锁的置放群组和当前一致\n\tif !c.checkLockedDRGroupNames() {\n\t\treturn errors.New(drgroup.ErrGroupModified, \"drgroup changed\")\n\t}\n\n\t// 3. 加载所有逻辑卷的状态，不需要完整实体，因为不会修改 Volume\n\tc.relatedLogicalVolume, err = lvView.FindByIDs(ctx, c.AppID, c.UUIDs)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(c.relatedLogicalVolume) < len(c.UUIDs) {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t// 4. 加载所有目标置放群组，key 为 name\n\tfor _, spec := range c.Specs {\n\t\tvar group *drgroup.DRGroup\n\t\tif _, ok := c.drgroupRef[spec.Name]; ok {\n\t\t\tgroup = c.drgroupRef[spec.Name]\n\t\t} else {\n\t\t\tgroup, err = c.getOrCreateDRGroup(ctx, drgRepo, spec)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t}\n\n\t\tif spec.Affinity > 0 {\n\t\t\tgroup.Affinity = spec.Affinity\n\t\t}\n\t\tif spec.Type != \"\" {\n\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t}\n\t}\n\n\t// 5. 对所有逻辑卷执行置放群组变更事件，检查状态是否允许，\n\t//    实际的更新还是在这里执行。\n\tfor _, vol := range c.relatedLogicalVolume {\n\t\terr := sm.Check(ctx, vol.State, rdiskDomain.LVEUpdateDrGroup, c)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// 将逻辑卷从原有的置放群组中移除\n\t\tfor _, name := range c.curDRGroupNames {\n\t\t\tc.drgroupRef[name].RemoveMember(vol.UUID.String())\n\t\t}\n\t\t// 将逻辑卷添加到新的置放群组中\n\t\tfor _, spec := range c.Specs {\n\t\t\tsubGroup := spec.SubGroup\n\t\t\tif subGroup == \"\" {\n\t\t\t\t// 如果没有指定子组，则使用远端 SSD UUID 作为子组名称\n\t\t\t\t// 相当于每块盘都是一个子组，相当于没有使用子组功能\n\t\t\t\tsubGroup = vol.UUID.String()\n\t\t\t}\n\t\t\tif err := c.drgroupRef[spec.Name].AddMember(vol.UUID.String(), subGroup, vol.PhysicalVolume.IP.String()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tif c.DryRun {\n\t\treturn errors.New(errors.ErrDryRunSuccessExit, \"dry run check success\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/online_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OnlinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOnlinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_benchmark_task.go",
        "code_start_line": 34,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *UpdateBenchmarkTask) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, rdisk.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark, err = benchRepo.FindByUUID(ctx, c.BenchmarkUUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventUpdateBench, benchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_flow_ctrl.go",
        "code_start_line": 80,
        "code_end_line": 103,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeFlowControlCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not found\")\n\t}\n\n\tspec := c.volume.FlowControlSpec\n\tif !c.UpdateRequest.UpdateSpec(&spec, c.volume.GetDefaultFlowControlSpec()) {\n\t\t// 没有任何更新，直接返回成功\n\t\treturn nil\n\t}\n\tc.volume.SetFlowControlSpec(spec)\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEUpdateFlowControl, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_defunct_volume.go",
        "code_start_line": 46,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *CleanupDefunctCommand) Handle(ctx context.Context) error {\n\tvar err error\n\tc.lv, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar sm = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\tvar event = rdiskDomain.LVECleanupDefunct\n\n\tfor _, attachment := range c.lv.Attachments {\n\t\tlogs.Info(ctx).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).Msg(\"cleanup defuncting volume\")\n\t\tsubCmd := &cleanDefunctSubCommand{Parent: c, HostIP: attachment.IP}\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, subCmd)\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，因为只要有一个挂载点清理失败，其他挂载点还是需要继续清理的\n\t\t\t// 失败的挂载点会在后台继续清理\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).\n\t\t\t\tMsg(\"failed to cleanup defunct volume, retry later.\")\n\t\t}\n\t}\n\n\tif len(c.lv.Attachments) == 0 {\n\t\t// 没有挂载点，直接清理\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, &cleanDefunctSubCommand{Parent: c, HostIP: net.IP{}})\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，后续自动重试即可\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Msg(\"failed to complete cleanup defunct volume\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_drgroup_exists.go",
        "code_start_line": 28,
        "code_end_line": 53,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDRGroupExistsCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t)\n\tfor _, spec := range c.DRGroup {\n\t\t_, err := repo.FindByName(ctx, users.AppID(c.AppID), spec.Name)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\tgroup := drgroup.New(spec.Name, users.AppID(c.AppID))\n\t\t\t\tif spec.Affinity > 0 {\n\t\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t\t}\n\t\t\t\tif spec.Type != \"\" {\n\t\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t\t}\n\t\t\t\terr = repo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_physical_volume.go",
        "code_start_line": 31,
        "code_end_line": 54,
        "code_key": "Handle",
        "code_value": "func (c *UpdatePhyRDiskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEUpdatePhysicalVolume, c)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/recycle_backup_data.go",
        "code_start_line": 32,
        "code_end_line": 62,
        "code_key": "Handle",
        "code_value": "func (c *RecycleBackupDataCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventDeleteBackup,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/clients/cos/client.go",
        "code_start_line": 101,
        "code_end_line": 104,
        "code_key": "DeleteObject",
        "code_value": "func (c *clientImpl) DeleteObject(ctx context.Context, key string) error {\n\t_, err := c.c.Object.Delete(ctx, key)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go",
        "code_start_line": 208,
        "code_end_line": 215,
        "code_key": "deleteFinishTask",
        "code_value": "func (sc *Scheduler) deleteFinishTask(ctx context.Context, task interfaces.Task) {\n\tsubTaskName := task.GetSubTaskName()\n\tif _, ok := sc.metrics.taskExecuteCountMap[subTaskName]; !ok {\n\t\tsc.metrics.taskExecuteCountMap[subTaskName], _ = initHistogramVec(subTaskName).GetMetricWith(sc.metrics.labels)\n\t}\n\tsc.metrics.taskExecuteCountMap[subTaskName].Observe(float64(task.GetExecuteCounts()))\n\tsc.taskMap.Delete(task.GetTaskId())\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_physical_volume.go",
        "code_start_line": 113,
        "code_end_line": 131,
        "code_key": "checkExisting",
        "code_value": "func (c *CreatePhysicalVolumeCommand) checkExisting(ctx context.Context, vol *domain.PhysicalVolume) (existed bool, err error) {\n\tif vol == nil {\n\t\treturn false, nil\n\t}\n\tif vol.Deleted() {\n\t\terr := app.GetRegistry(ctx).Repositories.PhysicalVolume.Delete(ctx, vol)\n\t\tif err != nil {\n\t\t\treturn false, errors.Newf(domain.ErrConflictVolume, \"failed to delete conflict physical volume: %v\", err)\n\t\t}\n\t\treturn false, nil\n\t}\n\tif string(vol.Serial) != c.Serial {\n\t\treturn false, errors.Newf(domain.ErrConflictVolume, \"host %s bdf %s has been taken by %s\", vol.IP, vol.BDF, vol.Serial)\n\t}\n\tif !vol.IP.Equal(c.Host) || string(vol.BDF) != c.BDF {\n\t\treturn false, errors.Newf(domain.ErrConflictVolume, \"volume %s has been assigned to host %s bdf %s\", vol.Serial, vol.IP, vol.BDF)\n\t}\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/create_logic_disk.go",
        "code_start_line": 61,
        "code_end_line": 63,
        "code_key": "InvokeDeleteLogicalVolume",
        "code_value": "func InvokeDeleteLogicalVolume(ctx context.Context, source rdiskDomain.LogicalVolumeState, target rdiskDomain.LogicalVolumeState, stateCtx app.LogicalVolumeContext) (rdiskDomain.LogicalVolumeState, error) {\n\treturn target, stateCtx.GetLogicalVolume().Delete()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go",
        "code_start_line": 199,
        "code_end_line": 305,
        "code_key": "updateLogicalVolume",
        "code_value": "func updateLogicalVolume(ctx context.Context, item, originalState *rdiskDomain.LogicalVolume) error {\n\tuow := getUow(ctx)\n\tcurDO := fromModelToDmRDisk(item)\n\toriginalDO := fromModelToDmRDisk(originalState)\n\tchanges := make(map[string]interface{})\n\tcheckChange := func(field string, cur interface{}, original interface{}) {\n\t\tif cur != original {\n\t\t\tchanges[field] = cur\n\t\t}\n\t}\n\tcheckChange(\"uuid\", curDO.UUID, originalDO.UUID)\n\tcheckChange(\"status\", curDO.Status, originalDO.Status)\n\tcheckChange(\"app_id\", curDO.AppID, originalDO.AppID)\n\tcheckChange(\"size\", curDO.Size, originalDO.Size)\n\tcheckChange(\"phydisk_serial\", curDO.PhydiskSerial, originalDO.PhydiskSerial)\n\tcheckChange(\"zone_id\", curDO.ZoneID, originalDO.ZoneID)\n\tcheckChange(\"volume_type\", curDO.VolumeType, originalDO.VolumeType)\n\tcheckChange(\"disk_type\", curDO.DiskType, originalDO.DiskType)\n\tcheckChange(\"read_iops\", curDO.ReadIOPS, originalDO.ReadIOPS)\n\tcheckChange(\"write_iops\", curDO.WriteIOPS, originalDO.WriteIOPS)\n\tcheckChange(\"rw_iops\", curDO.ReadWriteIOPS, originalDO.ReadWriteIOPS)\n\tcheckChange(\"read_bandwidth\", curDO.ReadBandwidth, originalDO.ReadBandwidth)\n\tcheckChange(\"write_bandwidth\", curDO.WriteBandwidth, originalDO.WriteBandwidth)\n\tcheckChange(\"rw_bandwidth\", curDO.ReadWriteBandwidth, originalDO.ReadWriteBandwidth)\n\n\tif len(changes) != 0 {\n\t\tchanges[\"updated\"] = uow.tx.NowFunc()\n\n\t\tresult := uow.tx.Model(curDO).Where(\"id = ?\", curDO.ID).Updates(changes)\n\t\tif result.Error != nil {\n\t\t\treturn result.Error\n\t\t}\n\t}\n\n\t// 更新挂载信息\n\n\tallHosts := make(map[string]struct{})\n\toriginHosts := make(map[string]*rdiskDomain.VolumeAttachment)\n\tcurHosts := make(map[string]*rdiskDomain.VolumeAttachment)\n\tfor _, a := range item.Attachments {\n\t\tallHosts[a.IP.String()] = struct{}{}\n\t\tcurHosts[a.IP.String()] = a\n\t}\n\tfor _, a := range originalState.Attachments {\n\t\tallHosts[a.IP.String()] = struct{}{}\n\t\toriginHosts[a.IP.String()] = a\n\t}\n\n\tfor hostIp := range allHosts {\n\t\tcurAttachment, _ := curHosts[hostIp]\n\t\toriginAttachment, _ := originHosts[hostIp]\n\t\tif originAttachment == nil && curAttachment != nil {\n\t\t\t// 新增挂载\n\t\t\tdo := fromModelToDmRDiskAttachment(curAttachment)\n\t\t\tdo.UUID = curDO.UUID\n\t\t\tdo.Created = uow.tx.NowFunc()\n\t\t\tdo.Updated = uow.tx.NowFunc()\n\t\t\terr := uow.tx.Model(curDO).Association(\"Attachments\").Append(do)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else if originAttachment != nil && curAttachment == nil {\n\t\t\t// 删除挂载\n\t\t\tdo := fromModelToDmRDiskAttachment(originAttachment)\n\t\t\tdo.UUID = curDO.UUID\n\t\t\tresult := uow.tx.Where(\"host_ip = ? and uuid = ?\", do.IP, do.UUID).Delete(do)\n\t\t\tif result.Error != nil {\n\t\t\t\treturn result.Error\n\t\t\t}\n\t\t} else if originAttachment != nil && curAttachment != nil {\n\t\t\t// 更新挂载\n\t\t\tdo := fromModelToDmRDiskAttachment(curAttachment)\n\t\t\tdo.UUID = curDO.UUID\n\t\t\toriginDo := fromModelToDmRDiskAttachment(originAttachment)\n\t\t\toriginDo.UUID = curDO.UUID\n\t\t\tchanges := make(map[string]interface{})\n\t\t\tcheckChange := func(field string, cur interface{}, original interface{}) {\n\t\t\t\tif cur != original {\n\t\t\t\t\tchanges[field] = cur\n\t\t\t\t}\n\t\t\t}\n\t\t\tcheckChange(\"mode\", do.Mode, originDo.Mode)\n\t\t\tcheckChange(\"read_iops\", do.ReadIOPS, originDo.ReadIOPS)\n\t\t\tcheckChange(\"write_iops\", do.WriteIOPS, originDo.WriteIOPS)\n\t\t\tcheckChange(\"rw_iops\", do.ReadWriteIOPS, originDo.ReadWriteIOPS)\n\t\t\tcheckChange(\"read_bandwidth\", do.ReadBandwidth, originDo.ReadBandwidth)\n\t\t\tcheckChange(\"write_bandwidth\", do.WriteBandwidth, originDo.WriteBandwidth)\n\t\t\tcheckChange(\"rw_bandwidth\", do.ReadWriteBandwidth, originDo.ReadWriteBandwidth)\n\t\t\tcheckChange(\"num_queue\", do.NumQueue, originDo.NumQueue)\n\t\t\tcheckChange(\"serial\", do.Serial, originDo.Serial)\n\t\t\tcheckChange(\"vcpu\", do.VCPU, originDo.VCPU)\n\t\t\tcheckChange(\"spdk_driver\", do.SPDKDriver, originDo.SPDKDriver)\n\n\t\t\tif len(changes) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tchanges[\"updated\"] = uow.tx.NowFunc()\n\t\t\tresult := uow.tx.Model(do).Where(\"host_ip = ? and uuid = ?\", do.IP, do.UUID).Updates(changes)\n\t\t\tif result.Error != nil {\n\t\t\t\treturn result.Error\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
        "code_start_line": 165,
        "code_end_line": 277,
        "code_key": "updateDRGroup",
        "code_value": "func updateDRGroup(ctx context.Context, item, originalState *drgroup.DRGroup) error {\n\tuow := getUow(ctx)\n\tcurDO := fromModelToDmDRGroup(item)\n\toriginalDO := fromModelToDmDRGroup(originalState)\n\tchanges := make(map[string]interface{})\n\tcheckChange := func(field string, cur interface{}, original interface{}) {\n\t\tif cur != original {\n\t\t\tif field == \"member_cnt\" || field == \"sub_group_cnt\" {\n\t\t\t\tdiff := cur.(int) - original.(int)\n\t\t\t\tif diff < 0 {\n\t\t\t\t\tchanges[field] = gorm.Expr(fmt.Sprintf(\"%s - %d\", field, -1*diff))\n\t\t\t\t} else {\n\t\t\t\t\tchanges[field] = gorm.Expr(fmt.Sprintf(\"%s + %d\", field, diff))\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tchanges[field] = cur\n\t\t\t}\n\t\t}\n\t}\n\tcheckChange(\"status\", curDO.Status, originalDO.Status)\n\tcheckChange(\"app_id\", curDO.AppID, originalDO.AppID)\n\tcheckChange(\"name\", curDO.Name, originalDO.Name)\n\tcheckChange(\"affinity\", curDO.Affinity, originalDO.Affinity)\n\tcheckChange(\"loc_type\", curDO.LocType, originalDO.LocType)\n\tcheckChange(\"satisfied\", curDO.Satisfied, originalDO.Satisfied)\n\tcheckChange(\"member_cnt\", curDO.MemberCnt, originalDO.MemberCnt)\n\tcheckChange(\"sub_group_cnt\", curDO.SubGroupCnt, originalDO.SubGroupCnt)\n\tcheckChange(\"extra\", curDO.Extra, originalDO.Extra)\n\n\tif len(changes) != 0 {\n\t\tchanges[\"updated\"] = uow.tx.NowFunc()\n\n\t\tresult := uow.tx.Model(curDO).Where(\"id = ?\", curDO.ID).Updates(changes)\n\t\tif result.Error != nil {\n\t\t\treturn result.Error\n\t\t}\n\t}\n\n\t// 更新成员信息\n\tallMembers := make(map[string]struct{})\n\ttype memberInfo struct {\n\t\tLoc      string\n\t\tSubGroup string\n\t}\n\toriginMembers := make(map[string]memberInfo)\n\tcurMembers := make(map[string]memberInfo)\n\tfor _, a := range item.GetMembers() {\n\t\tallMembers[a.ID] = struct{}{}\n\t\tcurMembers[a.ID] = memberInfo{\n\t\t\tLoc:      a.Location,\n\t\t\tSubGroup: a.SubGroup,\n\t\t}\n\t}\n\tfor _, a := range originalState.GetMembers() {\n\t\tallMembers[a.ID] = struct{}{}\n\t\toriginMembers[a.ID] = memberInfo{\n\t\t\tLoc:      a.Location,\n\t\t\tSubGroup: a.SubGroup,\n\t\t}\n\t}\n\n\tfor memberId := range allMembers {\n\t\tcurInfo, _ := curMembers[memberId]\n\t\toriginInfo, _ := originMembers[memberId]\n\t\tif originInfo.Loc == \"\" && curInfo.Loc != \"\" {\n\t\t\tdo := &metadb.DmDrgroupMembers{\n\t\t\t\tAppID:     int64(item.AppID),\n\t\t\t\tGroupName: item.Name,\n\t\t\t\tSubGroup:  curInfo.SubGroup,\n\t\t\t\tLoc:       curInfo.Loc,\n\t\t\t\tMemberID:  memberId,\n\t\t\t\tExtra:     \"{}\",\n\t\t\t\tCreated:   uow.tx.NowFunc(),\n\t\t\t\tUpdated:   uow.tx.NowFunc(),\n\t\t\t}\n\t\t\tresult := uow.tx.Create(do)\n\t\t\tif result.Error != nil {\n\t\t\t\treturn result.Error\n\t\t\t}\n\t\t} else if originInfo.Loc != \"\" && curInfo.Loc == \"\" {\n\t\t\tresult := uow.tx.Delete(&metadb.DmDrgroupMembers{},\n\t\t\t\t\"app_id = ? and group_name = ? and member_id = ?\",\n\t\t\t\toriginalState.AppID, originalState.Name, memberId)\n\t\t\tif result.Error != nil {\n\t\t\t\treturn result.Error\n\t\t\t}\n\t\t} else if originInfo.Loc != \"\" && curInfo.Loc != \"\" {\n\t\t\tchanges := make(map[string]interface{})\n\t\t\tcheckChange := func(field string, cur interface{}, original interface{}) {\n\t\t\t\tif cur != original {\n\t\t\t\t\tchanges[field] = cur\n\t\t\t\t}\n\t\t\t}\n\t\t\tcheckChange(\"loc\", curInfo.Loc, originInfo.Loc)\n\t\t\tcheckChange(\"app_id\", item.AppID, originalState.AppID)\n\t\t\tcheckChange(\"group_name\", item.Name, originalState.Name)\n\t\t\tcheckChange(\"sub_group\", curInfo.SubGroup, originInfo.SubGroup)\n\t\t\t//checkChange(\"extra\", \"{}\", \"{}\")\n\n\t\t\tif len(changes) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tchanges[\"updated\"] = uow.tx.NowFunc()\n\t\t\tresult := uow.tx.Model(&metadb.DmDrgroupMembers{}).Where(\n\t\t\t\t\"app_id = ? and group_name = ? and member_id = ?\",\n\t\t\t\toriginalState.AppID, originalState.Name, memberId).Updates(changes)\n\t\t\tif result.Error != nil {\n\t\t\t\treturn result.Error\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 19,
        "code_end_line": 33,
        "code_key": "DmDrgroup",
        "code_value": "type DmDrgroup struct {\n\tID        uint64    `gorm:\"column:id;primaryKey\"`                              // 主键 ID\n\tStatus    int       `gorm:\"column:status\"`                                     // 状态, 目前无用\n\tAppID     int64     `gorm:\"column:app_id;index:dm_drgroup_app_id_name,unique\"` // AppID\n\tName      string    `gorm:\"column:name;index:dm_drgroup_app_id_name,unique\"`   // DRGroup 名称，用户名下唯一\n\tAffinity  int       `gorm:\"column:affinity\"`                                   // 亲和性\n\tLocType   string    `gorm:\"column:loc_type\"`                                   // 位置类型，对应 HOST、RACK、SWITCH 等等\n\tSatisfied int       `gorm:\"column:satisfied\"`                                  // 组内元素是否满足约束条件\n\tMemberCnt int       `gorm:\"column:member_cnt\"`                                 // 组内元素数量\n\tExtra     string    `gorm:\"column:extra\"`                                      // 额外信息\n\tCreated   time.Time `gorm:\"column:created\"`\n\tUpdated   time.Time `gorm:\"column:updated\"`\n\n\tMembers []DmDrgroupMembers `gorm:\"foreignKey:AppID,GroupName;references:AppID,Name\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 35,
        "code_end_line": 37,
        "code_key": "TableName",
        "code_value": "func (*DmDrgroup) TableName() string {\n\treturn \"dm_drgroup\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 114,
        "code_end_line": 129,
        "code_key": "DmDrgroup",
        "code_value": "type DmDrgroup struct {\n\tID          uint64    `gorm:\"column:id;primaryKey\"`                              // 主键 ID\n\tStatus      int       `gorm:\"column:status\"`                                     // 状态, 目前无用\n\tAppID       int64     `gorm:\"column:app_id;index:dm_drgroup_app_id_name,unique\"` // AppID\n\tName        string    `gorm:\"column:name;index:dm_drgroup_app_id_name,unique\"`   // DRGroup 名称，用户名下唯一\n\tAffinity    int       `gorm:\"column:affinity\"`                                   // 亲和性\n\tLocType     string    `gorm:\"column:loc_type\"`                                   // 位置类型，对应 HOST、RACK、SWITCH 等等\n\tSatisfied   int       `gorm:\"column:satisfied\"`                                  // 组内元素是否满足约束条件\n\tMemberCnt   int       `gorm:\"column:member_cnt\"`                                 // 组内元素数量\n\tSubGroupCnt int       `gorm:\"column:sub_group_cnt\"`                              // 子组数量\n\tExtra       string    `gorm:\"column:extra\"`                                      // 额外信息\n\tCreated     time.Time `gorm:\"column:created\"`\n\tUpdated     time.Time `gorm:\"column:updated\"`\n\n\tMembers []DmDrgroupMembers `gorm:\"foreignKey:AppID,GroupName;references:AppID,Name\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 131,
        "code_end_line": 133,
        "code_key": "TableName",
        "code_value": "func (*DmDrgroup) TableName() string {\n\treturn \"dm_drgroup\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 39,
        "code_end_line": 49,
        "code_key": "DmDrgroupMembers",
        "code_value": "type DmDrgroupMembers struct {\n\tID        uint64    `gorm:\"column:id;primaryKey\"`                                                          // 主键 ID\n\tAppID     int64     `gorm:\"column:app_id;index:dm_drgroup_members_app_id_group_name_member_id,unique\"`     // AppID\n\tGroupName string    `gorm:\"column:group_name;index:dm_drgroup_members_app_id_group_name_member_id,unique\"` // DRGroup 名称，用户名下唯一\n\tSubGroup  string    `gorm:\"column:sub_group\"`                                                              // 子组名称\n\tLoc       string    `gorm:\"column:loc\"`                                                                    // 位置信息，例如母机 IP\n\tMemberID  string    `gorm:\"column:member_id;index:dm_drgroup_members_app_id_group_name_member_id,unique\"`  // DRGroup 成员 ID，例如逻辑卷 UUID\n\tExtra     string    `gorm:\"column:extra\"`                                                                  // 额外信息\n\tCreated   time.Time `gorm:\"column:created\"`\n\tUpdated   time.Time `gorm:\"column:updated\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 55,
        "code_end_line": 57,
        "code_key": "TableName",
        "code_value": "func (DmDrgroupMembers) TableName() string {\n\treturn \"dm_drgroup_members\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 51,
        "code_end_line": 53,
        "code_key": "DBName",
        "code_value": "func (m DmDrgroupMembers) DBName() string {\n\treturn \"metadb\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 135,
        "code_end_line": 145,
        "code_key": "DmDrgroupMembers",
        "code_value": "type DmDrgroupMembers struct {\n\tID        uint64    `gorm:\"column:id;primaryKey\"`                                                          // 主键 ID\n\tAppID     int64     `gorm:\"column:app_id;index:dm_drgroup_members_app_id_group_name_member_id,unique\"`     // AppID\n\tGroupName string    `gorm:\"column:group_name;index:dm_drgroup_members_app_id_group_name_member_id,unique\"` // DRGroup 名称，用户名下唯一\n\tSubGroup  string    `gorm:\"column:sub_group\"`                                                              // 子组名称\n\tLoc       string    `gorm:\"column:loc\"`                                                                    // 位置信息，例如母机 IP\n\tMemberID  string    `gorm:\"column:member_id;index:dm_drgroup_members_app_id_group_name_member_id,unique\"`  // DRGroup 成员 ID，例如逻辑卷 UUID\n\tExtra     string    `gorm:\"column:extra\"`                                                                  // 额外信息\n\tCreated   time.Time `gorm:\"column:created\"`\n\tUpdated   time.Time `gorm:\"column:updated\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 147,
        "code_end_line": 149,
        "code_key": "TableName",
        "code_value": "func (DmDrgroupMembers) TableName() string {\n\treturn \"dm_drgroup_members\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/expiremap.go:98:100:Remove": {
    "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/expiremap.go",
    "code_start_line": 98,
    "code_end_line": 100,
    "code_start_column": 22,
    "code_key": "Remove",
    "code_value": "func (e *ExpiredMap) Remove(key interface{}) {\n\te.Delete(key)\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/schedule/subgroup.go",
        "code_start_line": 92,
        "code_end_line": 116,
        "code_key": "tryCleanExpiredDisks",
        "code_value": "func (s SubGroupCleanTask) tryCleanExpiredDisks(ctx context.Context) error {\n\tstart := time.Now()\n\tfor _, key := range s.cacheManager.ListExpiredKeys(ctx) {\n\t\tlogs.Info(ctx).Str(\"sub_group\", key.(string)).Msg(\"FIND_EXPIRED_SUB_GROUP_POOL\")\n\t\tresolver := cache.SubGroupCacheKeyResolver{}.WithKey(ctx, key.(string))\n\t\tdisks, err := s.cacheManager.Acquire(ctx, resolver)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif disks == nil {\n\t\t\tcontinue\n\t\t}\n\t\ts.RecycleDisk(ctx, disks.([]*disk.Disk))\n\t\terr = s.cacheManager.Remove(ctx, resolver)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tcost := time.Since(start)\n\n\tlogs.Info(ctx).Int(\"cost\", int(cost)).Msg(\"RUN_TASK_ONE_ROUND_COST\")\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": []
  },
  "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/managers/shm.go:51:54:Remove": {
    "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/managers/shm.go",
    "code_start_line": 51,
    "code_end_line": 54,
    "code_start_column": 27,
    "code_key": "Remove",
    "code_value": "func (s *ShmCacheManager) Remove(ctx context.Context, keyResolver cache.GeneralCacheKeyResolverInf) error {\n\ts.m.Delete(keyResolver.GenerateKey(ctx))\n\treturn nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/schedule/subgroup.go",
        "code_start_line": 92,
        "code_end_line": 116,
        "code_key": "tryCleanExpiredDisks",
        "code_value": "func (s SubGroupCleanTask) tryCleanExpiredDisks(ctx context.Context) error {\n\tstart := time.Now()\n\tfor _, key := range s.cacheManager.ListExpiredKeys(ctx) {\n\t\tlogs.Info(ctx).Str(\"sub_group\", key.(string)).Msg(\"FIND_EXPIRED_SUB_GROUP_POOL\")\n\t\tresolver := cache.SubGroupCacheKeyResolver{}.WithKey(ctx, key.(string))\n\t\tdisks, err := s.cacheManager.Acquire(ctx, resolver)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif disks == nil {\n\t\t\tcontinue\n\t\t}\n\t\ts.RecycleDisk(ctx, disks.([]*disk.Disk))\n\t\terr = s.cacheManager.Remove(ctx, resolver)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tcost := time.Since(start)\n\n\tlogs.Info(ctx).Int(\"cost\", int(cost)).Msg(\"RUN_TASK_ONE_ROUND_COST\")\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": []
  },
  "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/subgroup.go:78:82:Remove": {
    "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/subgroup.go",
    "code_start_line": 78,
    "code_end_line": 82,
    "code_start_column": 32,
    "code_key": "Remove",
    "code_value": "func (s *SubGroupCacheManager) Remove(ctx context.Context, keyResolver cache.GeneralCacheKeyResolverInf) error {\n\tcacheKey := keyResolver.GenerateKey(ctx)\n\ts.cacheMap.Delete(cacheKey)\n\treturn nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/schedule/subgroup.go",
        "code_start_line": 92,
        "code_end_line": 116,
        "code_key": "tryCleanExpiredDisks",
        "code_value": "func (s SubGroupCleanTask) tryCleanExpiredDisks(ctx context.Context) error {\n\tstart := time.Now()\n\tfor _, key := range s.cacheManager.ListExpiredKeys(ctx) {\n\t\tlogs.Info(ctx).Str(\"sub_group\", key.(string)).Msg(\"FIND_EXPIRED_SUB_GROUP_POOL\")\n\t\tresolver := cache.SubGroupCacheKeyResolver{}.WithKey(ctx, key.(string))\n\t\tdisks, err := s.cacheManager.Acquire(ctx, resolver)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif disks == nil {\n\t\t\tcontinue\n\t\t}\n\t\ts.RecycleDisk(ctx, disks.([]*disk.Disk))\n\t\terr = s.cacheManager.Remove(ctx, resolver)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tcost := time.Since(start)\n\n\tlogs.Info(ctx).Int(\"cost\", int(cost)).Msg(\"RUN_TASK_ONE_ROUND_COST\")\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": []
  },
  "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/subgroup.go:104:117:Pop": {
    "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/subgroup.go",
    "code_start_line": 104,
    "code_end_line": 117,
    "code_start_column": 32,
    "code_key": "Pop",
    "code_value": "func (s *SubGroupCacheManager) Pop(ctx context.Context, keyResolver cache.GeneralCacheKeyResolverInf) (interface{}, error) {\n\tcacheKey := keyResolver.GenerateKey(ctx)\n\tif ok, disks := s.cacheMap.Get(cacheKey); ok {\n\t\tniceDisks := disks.([]*disk.Disk)\n\t\toneDisk := niceDisks[0]\n\t\tif len(niceDisks) > 1 {\n\t\t\ts.cacheMap.Set(cacheKey, niceDisks[1:], s.expiredSeconds)\n\t\t} else {\n\t\t\ts.cacheMap.Delete(cacheKey)\n\t\t}\n\t\treturn oneDisk, nil\n\t}\n\treturn nil, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/managers/shm.go",
        "code_start_line": 82,
        "code_end_line": 84,
        "code_key": "Pop",
        "code_value": "func (s *ShmCacheManager) Pop(ctx context.Context, keyResolver cache.GeneralCacheKeyResolverInf) (interface{}, error) {\n\tpanic(\"implement me\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/subgroup.go",
        "code_start_line": 104,
        "code_end_line": 117,
        "code_key": "Pop",
        "code_value": "func (s *SubGroupCacheManager) Pop(ctx context.Context, keyResolver cache.GeneralCacheKeyResolverInf) (interface{}, error) {\n\tcacheKey := keyResolver.GenerateKey(ctx)\n\tif ok, disks := s.cacheMap.Get(cacheKey); ok {\n\t\tniceDisks := disks.([]*disk.Disk)\n\t\toneDisk := niceDisks[0]\n\t\tif len(niceDisks) > 1 {\n\t\t\ts.cacheMap.Set(cacheKey, niceDisks[1:], s.expiredSeconds)\n\t\t} else {\n\t\t\ts.cacheMap.Delete(cacheKey)\n\t\t}\n\t\treturn oneDisk, nil\n\t}\n\treturn nil, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/queue/priority_queue.go",
        "code_start_line": 35,
        "code_end_line": 42,
        "code_key": "Pop",
        "code_value": "func (pq *PriorityQueue) Pop() any {\n\told := pq.Task\n\tn := len(old)\n\titem := old[n-1]\n\told[n-1] = nil // avoid memory leak\n\tpq.Task = old[0 : n-1]\n\treturn item\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/queue/priority_queue.go",
        "code_start_line": 56,
        "code_end_line": 60,
        "code_key": "Pop",
        "code_value": "func (spq *SyncTaskPriorityQueue) Pop() interfaces.Task {\n\tspq.mutex.Lock()\n\tdefer spq.mutex.Unlock()\n\treturn heap.Pop(spq.priorityQueue).(interfaces.Task)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/services/subgroup.go",
        "code_start_line": 58,
        "code_end_line": 76,
        "code_key": "spinApplyDisk",
        "code_value": "func (s SubGroupPoolService) spinApplyDisk(ctx context.Context, subGroupId string, intervalMillSeconds int) *disk.Disk {\n\tvar spinTimes = 50\n\tfor i := 0; i < spinTimes; i++ {\n\t\ttime.Sleep(time.Duration(intervalMillSeconds) * time.Millisecond)\n\t\toneDisk, err := s.cacheManager.Pop(ctx, &cache.SubGroupCacheKeyResolver{SubGroupId: subGroupId})\n\t\tif err != nil {\n\t\t\tlogs.Info(ctx).Err(err).Str(\"sub_group\", subGroupId).Msg(\"APPLY_DISK_FROM_SUB_GROUP_POOL_ERROR\")\n\t\t\treturn nil\n\t\t}\n\t\tif oneDisk != nil {\n\t\t\ts.ClosePool(ctx)\n\t\t\treturn oneDisk.(*disk.Disk)\n\t\t}\n\t\tlogs.Info(ctx).\n\t\t\tInt(\"waiting_ms\", i*intervalMillSeconds).\n\t\t\tStr(\"sub_group\", subGroupId).Msg(\"WAITING_SUB_GROUP_POOL_READY\")\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go",
        "code_start_line": 161,
        "code_end_line": 189,
        "code_key": "sendTaskToWorker",
        "code_value": "func (sc *Scheduler) sendTaskToWorker(ctx context.Context) {\n\t// 表示优先队列中第一个任务已经就绪可以开始执行\n\tif sc.syncTaskPriorityQueue.Len() > 0 {\n\t\tif sc.tryGetWorker(ctx) {\n\t\t\t// 获取到worker，执行优先队列中的第一个任务\n\t\t\tfirstTask := sc.syncTaskPriorityQueue.GetFirst()\n\t\t\tif firstTask != nil && firstTask.GetNextTriggerTime().Before(time.Now()) {\n\t\t\t\ttask := sc.syncTaskPriorityQueue.Pop()\n\t\t\t\t// 更新Timer\n\t\t\t\tsc.addTimerEvent(task.GetTaskId())\n\t\t\t\tsc.metrics.taskCountInQueue.Sub(1)\n\n\t\t\t\tlogs.Info(ctx).Str(\"TaskName\", task.GetTaskId()).\n\t\t\t\t\tStr(\"SubTaskName\", task.GetSubTaskName()).\n\t\t\t\t\tInt(\"LeftWorkerNum\", sc.workerNum).\n\t\t\t\t\tInt(\"LeftTaskNum\", sc.syncTaskPriorityQueue.Len()).\n\t\t\t\t\tMsg(\"TRY_TO_EXECUTE_TASK\")\n\n\t\t\t\tgo func() {\n\t\t\t\t\tnewCtx := logs.AddDefaultMessage(ctx, \"TaskName\", task.GetTaskId())\n\t\t\t\t\tnewCtx = logs.AddDefaultMessage(newCtx, \"SubTaskName\", task.GetSubTaskName())\n\t\t\t\t\tsc.processTask(newCtx, task)\n\t\t\t\t}()\n\t\t\t} else {\n\t\t\t\tsc.releaseWorker(ctx)\n\t\t\t}\n\t\t}\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/infra/types/names.go",
        "code_start_line": 66,
        "code_end_line": 71,
        "code_key": "Disk",
        "code_value": "type Disk struct {\n\tDiskId\n\tZoneId\n\tDiskUuid\n\tDiskSize\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/disk/entity.go",
        "code_start_line": 15,
        "code_end_line": 28,
        "code_key": "Disk",
        "code_value": "type Disk struct {\n\tUser            *account.User\n\tDiskId          types.DiskId\n\tDiskUuid        types.DiskUuid\n\tHostIp          types.HostIp\n\tDiskSize        types.DiskSize\n\tSerialId        types.DiskSerialId\n\tZone            types.Zone\n\tStatus          types.DiskStatus\n\tScore           int64 // 装箱分数\n\tPlacementGroups []*dto.PlacementGroup\n\tPerformanceRank types.PerformanceRank\n\tClusterId       types.ClusterId\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/models.go",
        "code_start_line": 56,
        "code_end_line": 64,
        "code_key": "Disk",
        "code_value": "type Disk struct {\n\tPid                    uint\n\tProductCode            string\n\tSubProductCode         string\n\tVCodeMemSpace          string\n\tSvCodeMemSpace         string\n\tVCodeBackupPointQuota  string\n\tSvCodeBackupPointQuota string\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go:644:674:Refresh": {
    "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
    "code_start_line": 644,
    "code_end_line": 674,
    "code_start_column": 21,
    "code_key": "Refresh",
    "code_value": "func (l *mysqlLock) Refresh(ctx context.Context, ttl time.Duration) error {\n\n\ttx := l.locker.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\n\n\tkeysKey := dlock.LockKeySlice(l.keys).GetKeys()\n\t// NOCA:QCloudAkCheck(误报)\n\texistingLocks, err := l.locker.fetchExistingLocksByKeysAndTokens(tx, keysKey, l.tokens)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn err\n\t}\n\n\t// Compare existing locks with the keys.\n\tif !checkStrSetEqual(existingLocks, keysKey) {\n\t\t_ = tx.Rollback()\n\t\treturn errors.Wrap(dlock.ErrLockNotHeld, \"lock is not held\")\n\t}\n\n\t// Update the expiration time.\n\tif err := l.locker.updateLocksTTLByKeysAndTokens(tx, keysKey, l.tokens, ttl); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn err\n\t}\n\n\tif result := tx.Commit(); result.Error != nil {\n\t\treturn errors.Wrap(result.Error, \"failed to commit refresh locks\")\n\t}\n\n\tl.expiration = time.Now().Add(ttl)\n\treturn nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 5,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/schedule/subgroup.go",
        "code_start_line": 118,
        "code_end_line": 131,
        "code_key": "Run",
        "code_value": "func (s SubGroupCleanTask) Run(ctx context.Context) error {\n\ts.cacheManager = app.GlobalRegistry.CacheContainer.GetCacheManager(CacheDomain.SubGroupCache)\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn nil\n\t\tcase <-time.After(time.Duration(s.intervalSeconds) * time.Second):\n\t\t\terr := s.tryCleanExpiredDisks(ctx)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/schedule/shm.go",
        "code_start_line": 40,
        "code_end_line": 52,
        "code_key": "Run",
        "code_value": "func (r *RefreshShmTask) Run(ctx context.Context) error {\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn nil\n\t\tcase <-time.After(time.Duration(r.interval) * time.Second):\n\t\t\terr := r.refreshShmRound(ctx)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/tracker.go",
        "code_start_line": 84,
        "code_end_line": 100,
        "code_key": "Run",
        "code_value": "func (rdp *PhyDiskTracker) Run(ctx context.Context) {\n\tvar refreshTimes = 0\n\tvar interval = app.GlobalRegistry.AppConfig.Track.AffiRefreshInterval\n\t// 兜底保护，防止config中没有设置对应的interval（未设置默认值为0）\n\tif interval == 0 {\n\t\tinterval = app.GlobalRegistry.AppConfig.Track.DefaultRefreshInterval\n\t}\n\tfor {\n\t\trdp.Refresh(ctx)\n\t\trefreshTimes += 1\n\t\ttime.Sleep(time.Second * time.Duration(interval))\n\t\tlogs.Info(ctx).\n\t\t\tInt(\"refresh_times\", refreshTimes).\n\t\t\tInt(\"interval\", interval).\n\t\t\tMsg(\"TRACKER_REFRESH_CACHE_TIMES\")\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/set/cache/tracker.go",
        "code_start_line": 48,
        "code_end_line": 64,
        "code_key": "Run",
        "code_value": "func (d *DiskSetTracker) Run(ctx context.Context) {\n\trefreshTimes := 0\n\tinterval := app.GlobalRegistry.AppConfig.Track.SetRefreshInterval\n\t// 兜底保护，防止config中没有设置对应的interval（未设置默认值为0）\n\tif interval == 0 {\n\t\tinterval = app.GlobalRegistry.AppConfig.Track.DefaultRefreshInterval\n\t}\n\tfor {\n\t\td.Refresh(ctx)\n\t\trefreshTimes += 1\n\t\ttime.Sleep(time.Second * time.Duration(interval))\n\t\tlogs.Info(ctx).\n\t\t\tInt(\"refresh_times\", refreshTimes).\n\t\t\tInt(\"interval\", interval).\n\t\t\tMsg(\"DISK_SET_TRACKER_REFRESH_CACHE_TIMES\")\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/app/app.go",
        "code_start_line": 22,
        "code_end_line": 34,
        "code_key": "Run",
        "code_value": "func (app *App) Run() error {\n\tctx := context.Background()\n\tinitConfig()\n\n\tctx = initLogger(ctx)\n\tctx = initRegion(ctx)\n\tinitDatabases(ctx)\n\n\tserver := NewServer(ctx)\n\tapp.RegisterConsumers(server)\n\n\treturn server.Serve()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/tests/hook.go",
        "code_start_line": 29,
        "code_end_line": 36,
        "code_key": "initCacheTracker",
        "code_value": "func initCacheTracker(ctx context.Context) {\n\ttracker := cache.DiskSetTracker{\n\t\tDiskSetEntityInf: make([]interface{}, 0, 10000),\n\t\tCacheManager:     &cache.DiskSetCacheManager{},\n\t}\n\t// 测试只刷新一次\n\ttracker.Refresh(ctx)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/convertor.go",
        "code_start_line": 28,
        "code_end_line": 38,
        "code_key": "Start",
        "code_value": "func (a *Convertor) Start(ctx context.Context) error {\n\t// 启动转换器\n\tfor _, scanner := range a.scanners {\n\t\tscanner := scanner\n\t\tgo func() {\n\t\t\ta.convertToTask(ctx, scanner)\n\t\t}()\n\t}\n\tlogs.Info(ctx).Msgf(\"Convertor Start Success\")\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_rec_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *CbsMeasureReconciliationTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\t//s.resultChan <- struct{}{}\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_rec_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 35,
        "code_key": "Start",
        "code_value": "func (s *SnapMeasureReconciliationTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_compute_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *SnapComputeTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\t//s.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_measure_send_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *CbsMeasureSendTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_bill_valid_appId_fetch_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *CbsValidAppIdFetchTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_calculate_cost_locally_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 36,
        "code_key": "Start",
        "code_value": "func (s *SnapCalculateCostLocallyTaskScanner) Start(ctx context.Context) error {\n\t//s.resultChan <- struct{}{}\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_create_task_scanner.go",
        "code_start_line": 23,
        "code_end_line": 42,
        "code_key": "Start",
        "code_value": "func (s *UpdateCreateTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\trunning := true\n\t\tfor running {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\trunning = false\n\t\t\tdefault:\n\t\t\t\terr := s.FullScan(ctx)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogs.Fatal(ctx).Msgf(\"%s full scan failed!\\n\", s.name)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\ttime.Sleep(s.scanInterval)\n\t\t}\n\t}()\n\tlogs.Info(ctx).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_measure_send_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 36,
        "code_key": "Start",
        "code_value": "func (s *SnapMeasureSendTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\t//s.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/repush_user_billing_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 39,
        "code_key": "Start",
        "code_value": "func (s *RepushUserBillingTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_rollback_task_scanner.go",
        "code_start_line": 23,
        "code_end_line": 42,
        "code_key": "Start",
        "code_value": "func (s *UpdateRollbackTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\trunning := true\n\t\tfor running {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\trunning = false\n\t\t\tdefault:\n\t\t\t\terr := s.FullScan(ctx)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogs.Fatal(ctx).Msgf(\"%s full scan failed!\\n\", s.name)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\ttime.Sleep(s.scanInterval)\n\t\t}\n\t}()\n\tlogs.Info(ctx).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_valid_appId_fetch_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 36,
        "code_key": "Start",
        "code_value": "func (s *SnapValidAppIdFetchTaskScanner) Start(ctx context.Context) error {\n\t//s.resultChan <- struct{}{}\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_bill_compute_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 39,
        "code_key": "Start",
        "code_value": "func (s *CbsBillComputeTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/app/app.go",
        "code_start_line": 31,
        "code_end_line": 39,
        "code_key": "Start",
        "code_value": "func (m *PipelineManager) Start(ctx context.Context) error {\n\tfor region, pipeline := range m.Pipelines {\n\t\tregionCtx := context.WithValue(ctx, \"region\", region)\n\t\tif err := pipeline.Start(regionCtx); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/app/app.go",
        "code_start_line": 46,
        "code_end_line": 51,
        "code_key": "Start",
        "code_value": "func (app *NebulaApp) Start(ctx context.Context) error {\n\tif err := app.pipelineManager.Start(ctx); err != nil {\n\t\treturn err\n\t}\n\treturn <-app.stopChan\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/app/pipeline.go",
        "code_start_line": 20,
        "code_end_line": 46,
        "code_key": "Start",
        "code_value": "func (p *RegionPipeline) Start(ctx context.Context) error {\n\tregion := ctx.Value(\"region\").(string)\n\tscannerLogCtx := initLogger(ctx, region, \"scanner.log\")\n\tfor _, scanner := range p.scanners {\n\t\tsingleCtx := logs.AddDefaultMessage(scannerLogCtx, \"name\", scanner.GetName())\n\t\terr := scanner.Start(singleCtx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tinitMetric(scanner, region, \"scanner\", scanner.GetName())\n\t}\n\n\tconvertorLogCtx := initLogger(ctx, region, \"convertor.log\")\n\terr := p.convertor.Start(convertorLogCtx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// start scheduler\n\tschedulerLogCtx := initLogger(ctx, region, \"scheduler.log\")\n\terr = p.scheduler.Start(schedulerLogCtx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tinitMetric(p.scheduler, region, \"scheduler\", \"scheduler\")\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go",
        "code_start_line": 109,
        "code_end_line": 112,
        "code_key": "Start",
        "code_value": "func (sc *Scheduler) Start(ctx context.Context) error {\n\tgo sc.mainLoop(ctx)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/scheduler.go",
        "code_start_line": 154,
        "code_end_line": 191,
        "code_key": "Start",
        "code_value": "func (s *scheduler) Start(ctx context.Context) error {\n\twg := sync.WaitGroup{}\n\trunning := true\n\tgo s.haManager.Start(ctx)\n\tdefer s.haManager.Close(ctx)\n\tfor {\n\t\tselect {\n\t\tcase taskName := <-s.eventChan:\n\t\t\twg.Add(1)\n\t\t\tgo func(name string) {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tif task, ok := s.loads[name]; ok {\n\n\t\t\t\t\tif s.isMaster {\n\t\t\t\t\t\t_ctx := logs.With(ctx).Str(\"seqId\", uuid.New().String()).Str(\"taskName\", name).Logger().WithContext(ctx)\n\t\t\t\t\t\ttask.Work(_ctx)\n\t\t\t\t\t}\n\n\t\t\t\t\ttriggerTime := time.Now().Add(task.Interval())\n\t\t\t\t\tfor {\n\t\t\t\t\t\tif !running {\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif time.Now().After(triggerTime) {\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttime.Sleep(time.Second)\n\t\t\t\t\t}\n\t\t\t\t\ts.eventChan <- name\n\t\t\t\t}\n\t\t\t}(taskName)\n\t\tcase <-s.stopChan:\n\t\t\trunning = false\n\t\t\twg.Wait()\n\t\t\treturn nil\n\t\t}\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/easyha/model.go",
        "code_start_line": 108,
        "code_end_line": 180,
        "code_key": "Start",
        "code_value": "func (m *haManagerImpl) Start(ctx context.Context) {\n\tm.keepRunning = true\n\tm.ctx = ctx\n\tvar (\n\t\tmyIdentity            = m.delegate.GetIdentity()                                    // 当前节点的业务标识\n\t\tmyKey                 = fmt.Sprintf(\"easyhaMaster/%s\", url.PathEscape(m.namespace)) // 分布式锁的key\n\t\tmyToken               = m.encodeToken(myIdentity)                                   // 分布式锁 Token，包含业务标识和随机信息\n\t\tmyLock                dlock.Lock                                                    // 获取到的分布式锁, 用于刷新和释放\n\t\tcurrentMasterIdentity string                                                        // 当前 master 的业务标识，如果为空则是还未获取过当前 master\n\t)\n\n\t// Start slave loop.\n\tfor m.keepRunning {\n\t\t// Try observe the master lock first.\n\t\tif view, err := m.locker.Observe(ctx, myKey); err != nil {\n\t\t\tm.logger.Info().Err(err).Str(\"key\", myKey).Msg(\"failed to observe current master lock\")\n\t\t\t// Failed to observe the master lock, try to  obtain the lock.\n\t\t\tmyLock, err = m.locker.Obtain(ctx, dlock.NewWriteLockKey(myKey), m.lockExpired, &dlock.Option{Token: myToken})\n\t\t\tif err == nil {\n\t\t\t\t// Successfully obtained the lock.\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tnewIdentity, err := m.decodeToken(view.Token)\n\t\t\tif err != nil {\n\t\t\t\tm.logger.Warn().Err(err).Str(\"token\", view.Token).Msg(\"failed to decode token\")\n\t\t\t} else if currentMasterIdentity == \"\" {\n\t\t\t\t// First time to observe the master.\n\t\t\t\tcurrentMasterIdentity = newIdentity\n\t\t\t\tif err := m.delegate.OnBecomeSlave(ctx, currentMasterIdentity); err != nil {\n\t\t\t\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle become slave, force quit for safety\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if currentMasterIdentity != newIdentity {\n\t\t\t\t// Master changed. Need update.\n\t\t\t\tcurrentMasterIdentity = newIdentity\n\t\t\t\tif err := m.delegate.OnSwitchMaster(ctx, currentMasterIdentity); err != nil {\n\t\t\t\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle switch master, force quit for safety\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttime.Sleep(m.checkInterval)\n\t}\n\n\tif myLock == nil {\n\t\tm.logger.Fatal().Msg(\"myLock is nil, found bug, force quit for safety\")\n\t\treturn\n\t}\n\n\t// I am the master now.\n\tif err := m.delegate.OnBecomeMaster(ctx); err != nil {\n\t\tmyLock.Release(ctx)\n\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle become master, force quit for safety\")\n\t\treturn\n\t}\n\n\tdefer func() {\n\t\tmyLock.Release(ctx)\n\t\tif err := m.delegate.OnLostMaster(ctx); err != nil {\n\t\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle lost master, force quit for safety\")\n\t\t}\n\t}()\n\n\t// Start the master loop.\n\tfor m.keepRunning {\n\t\ttime.Sleep(m.checkInterval)\n\t\tif err := myLock.Refresh(ctx, m.lockExpired); err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": []
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/uow.go:83:90:Rollback": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/uow.go",
    "code_start_line": 83,
    "code_end_line": 90,
    "code_start_column": 22,
    "code_key": "Rollback",
    "code_value": "func (u *unitOfWork) Rollback(ctx context.Context) error {\n\tu.trackedPhyVolumes.items = make(map[uint64]*rdiskDomain.PhysicalVolume)\n\tu.trackedLogicalVolumes.items = make(map[uint64]*rdiskDomain.LogicalVolume)\n\tu.trackedDRGroups.items = make(map[uint64]*drgroup.DRGroup)\n\tu.trackedBackups.items = make(map[uint64]*backup.Backup)\n\tu.trackedBenchmarks.items = make(map[uint64]*benchmark.Benchmark)\n\treturn u.tx.Rollback().Error\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/infra/event_bus/bus.go",
        "code_start_line": 47,
        "code_end_line": 59,
        "code_key": "RollbackEvents",
        "code_value": "func (eb *EventBusDriver) RollbackEvents(ctx context.Context) *response.Result {\n\tfor _, event := range eb.BlockEventQueue {\n\t\tif event.GetState(ctx) == Executed {\n\t\t\t//result := EventHandlerMap[event.GetType(ctx)].Rollback(ctx)\n\t\t\tresult := event.GetHandler(ctx).Rollback(ctx)\n\t\t\tif result.IsFailed() {\n\t\t\t\tlogs.Info(ctx).Err(result).Int(\"EventType\", int(event.GetType(ctx))).Msg(\"rollback event failed\")\n\t\t\t\treturn result\n\t\t\t}\n\t\t}\n\t}\n\treturn response.DefaultResult()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/tracker.go",
        "code_start_line": 67,
        "code_end_line": 77,
        "code_key": "Refresh",
        "code_value": "func (rdp *PhyDiskTracker) Refresh(ctx context.Context) {\n\trdp.Track(ctx)\n\tlock.RDPhyCacheGlobalLock.GetLocker(lock.RDPhyLockKeyGenerator{}).Lock()\n\trdp.Merge(ctx, rdp.OriPhyDisks)\n\tlogs.Info(ctx).\n\t\tInt(\"disk_num\", len(rdp.ToCachedPhyDisks)).\n\t\tInt(\"member_num\", len(rdp.DrgroupMembers)).\n\t\tMsg(\"CACHE_AVAILABLE_PHY_DISK_AFTER_MERGE\")\n\trdp.CacheManager.RefreshCache(ctx, rdp.ToCachedPhyDisks, rdp.DrgroupMembers)\n\tlock.RDPhyCacheGlobalLock.GetLocker(lock.RDPhyLockKeyGenerator{}).Unlock()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/set/cache/tracker.go",
        "code_start_line": 35,
        "code_end_line": 38,
        "code_key": "Refresh",
        "code_value": "func (d *DiskSetTracker) Refresh(ctx context.Context) {\n\td.Track(ctx)\n\td.CacheManager.RefreshCache(ctx, d.DiskSetEntityInf)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 644,
        "code_end_line": 674,
        "code_key": "Refresh",
        "code_value": "func (l *mysqlLock) Refresh(ctx context.Context, ttl time.Duration) error {\n\n\ttx := l.locker.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\n\n\tkeysKey := dlock.LockKeySlice(l.keys).GetKeys()\n\t// NOCA:QCloudAkCheck(误报)\n\texistingLocks, err := l.locker.fetchExistingLocksByKeysAndTokens(tx, keysKey, l.tokens)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn err\n\t}\n\n\t// Compare existing locks with the keys.\n\tif !checkStrSetEqual(existingLocks, keysKey) {\n\t\t_ = tx.Rollback()\n\t\treturn errors.Wrap(dlock.ErrLockNotHeld, \"lock is not held\")\n\t}\n\n\t// Update the expiration time.\n\tif err := l.locker.updateLocksTTLByKeysAndTokens(tx, keysKey, l.tokens, ttl); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn err\n\t}\n\n\tif result := tx.Commit(); result.Error != nil {\n\t\treturn errors.Wrap(result.Error, \"failed to commit refresh locks\")\n\t}\n\n\tl.expiration = time.Now().Add(ttl)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mem/memdlock.go",
        "code_start_line": 189,
        "code_end_line": 210,
        "code_key": "Refresh",
        "code_value": "func (l *memLock) Refresh(ctx context.Context, ttl time.Duration) error {\n\tl.locker.mutex.Lock()\n\tdefer l.locker.mutex.Unlock()\n\n\ttokens := make(map[string]struct{}, len(l.tokens))\n\tfor _, item := range l.tokens {\n\t\ttokens[item] = struct{}{}\n\t}\n\tfor _, key := range l.keys {\n\t\tif item, ok := l.locker.data[key.Key]; ok {\n\t\t\tif _, exist := tokens[item.token]; !exist {\n\t\t\t\treturn dlock.ErrLockNotHeld\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, key := range l.keys {\n\t\tl.locker.data[key.Key].ttl = time.Now().Add(ttl)\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/inventory/services/remote.go",
        "code_start_line": 25,
        "code_end_line": 27,
        "code_key": "Rollback",
        "code_value": "func (i *InquireRemoteDiskStockService) Rollback(ctx context.Context) *response.Result {\n\treturn response.DefaultResult()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/production/services/remote.go",
        "code_start_line": 43,
        "code_end_line": 46,
        "code_key": "Rollback",
        "code_value": "func (c *CreateRemoteDiskService) Rollback(ctx context.Context) *response.Result {\n\tlogs.Info(ctx).Msg(\"START_ROLLBACK_CREATE_FAILED_DISKS\")\n\treturn response.DefaultResult()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/packing/services/cloud.go",
        "code_start_line": 124,
        "code_end_line": 126,
        "code_key": "Rollback",
        "code_value": "func (c *CloudPackSetService) Rollback(ctx context.Context) *response.Result {\n\treturn response.DefaultResult()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/packing/services/remote.go",
        "code_start_line": 68,
        "code_end_line": 79,
        "code_key": "Rollback",
        "code_value": "func (rdp *RemoteDiskPackService) Rollback(ctx context.Context) *response.Result {\n\taffSrv := AffinityDomain.AffinityDomainFactory{}.NewAffinityService(ctx, rdp.entity.DiskMode, rdp.entity.AffConfig, rdp.entity.User)\n\taffSrv.RefundAppliedDisks(ctx, rdp.entity.GetDisks(ctx))\n\tlogs.Info(ctx).\n\t\tInt(\"app_id\", rdp.entity.User.AppId.AppId).\n\t\tInt(\"disk_size\", int(rdp.entity.DiskSize)).\n\t\tInt(\"disk_count\", int(rdp.entity.DiskCount)).\n\t\tStr(\"sub_group\", rdp.entity.AffConfig.GetSubGroupId(ctx)).\n\t\tStrs(\"group_id\", rdp.entity.AffConfig.GetAllPlacementGroupId(ctx)).\n\t\tMsg(\"ROLLBACK_PACKED_DISKS_SUC\")\n\treturn response.DefaultResult()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/uow.go",
        "code_start_line": 83,
        "code_end_line": 90,
        "code_key": "Rollback",
        "code_value": "func (u *unitOfWork) Rollback(ctx context.Context) error {\n\tu.trackedPhyVolumes.items = make(map[uint64]*rdiskDomain.PhysicalVolume)\n\tu.trackedLogicalVolumes.items = make(map[uint64]*rdiskDomain.LogicalVolume)\n\tu.trackedDRGroups.items = make(map[uint64]*drgroup.DRGroup)\n\tu.trackedBackups.items = make(map[uint64]*backup.Backup)\n\tu.trackedBenchmarks.items = make(map[uint64]*benchmark.Benchmark)\n\treturn u.tx.Rollback().Error\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/fsm/compositor.go",
        "code_start_line": 99,
        "code_end_line": 103,
        "code_key": "Rollback",
        "code_value": "func (a *sequenceActionCompositor[S, E, C]) Rollback(action Action[S, E, C]) *sequenceActionCompositor[S, E, C] {\n\ta.actions = append(a.actions, action)\n\ta.rollbackFlag = append(a.rollbackFlag, true)\n\treturn a\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/test_utils/initdb.go",
        "code_start_line": 53,
        "code_end_line": 58,
        "code_key": "Release",
        "code_value": "func (p *dbPool) Release(idx int) {\n\tp.lock.Lock()\n\tdefer p.lock.Unlock()\n\tdelete(p.busyIdx, idx)\n\tp.freeIdx[idx] = struct{}{}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/testutil/db.go",
        "code_start_line": 59,
        "code_end_line": 64,
        "code_key": "Release",
        "code_value": "func (p *dbPool) Release(idx int) {\n\tp.lock.Lock()\n\tdefer p.lock.Unlock()\n\tdelete(p.busyIdx, idx)\n\tp.freeIdx[idx] = struct{}{}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 677,
        "code_end_line": 710,
        "code_key": "Release",
        "code_value": "func (l *mysqlLock) Release(ctx context.Context) error {\n\tif atomic.LoadInt32(&l.released) == 1 {\n\t\t// fast path\n\t\treturn nil\n\t}\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\n\t// slow path\n\tif l.released == 1 {\n\t\treturn nil\n\t}\n\n\ttx := l.locker.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\n\n\treadLocks, writeLocks := l.locker.getReadLocksAndWriteLocks(tx, l.keys)\n\n\tif err := l.locker.deleteLocksByKeysAndToken(tx, dlock.LockKeySlice(writeLocks).GetKeys(), l.tokens); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn errors.Wrap(err, \"failed to release locks\")\n\t}\n\n\tif err := l.locker.releaseReadLocks(tx, dlock.LockKeySlice(readLocks).GetKeys(), l.tokens); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn errors.Wrap(err, \"failed to release locks\")\n\t}\n\n\tif result := tx.Commit(); result.Error != nil {\n\t\treturn errors.Wrap(result.Error, \"failed to commit release locks\")\n\t}\n\tl.expiration = time.Now()\n\tatomic.StoreInt32(&l.released, 1)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mem/memdlock.go",
        "code_start_line": 213,
        "code_end_line": 246,
        "code_key": "Release",
        "code_value": "func (l *memLock) Release(ctx context.Context) error {\n\tif atomic.LoadInt32(&l.released) == 1 {\n\t\t// fast path\n\t\treturn nil\n\t}\n\tl.locker.mutex.Lock()\n\tdefer l.locker.mutex.Unlock()\n\n\t// slow path\n\tif l.released == 1 {\n\t\treturn nil\n\t}\n\n\ttokens := make(map[string]struct{}, len(l.tokens))\n\tfor _, item := range l.tokens {\n\t\ttokens[item] = struct{}{}\n\t}\n\tfor _, key := range l.keys {\n\t\tif item, ok := l.locker.data[key.Key]; ok {\n\t\t\tif _, exist := tokens[item.token]; !exist {\n\t\t\t\tcontinue\n\t\t\t} else {\n\t\t\t\tif item.lockType == dlock.ReadLock && item.count > 1 {\n\t\t\t\t\titem.count--\n\t\t\t\t} else {\n\t\t\t\t\tdelete(l.locker.data, key.Key)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tatomic.StoreInt32(&l.released, 1)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/dispatcher/dispatcher.go",
        "code_start_line": 33,
        "code_end_line": 103,
        "code_key": "Dispatch",
        "code_value": "func (d *dispatcherImpl) Dispatch(ctx context.Context, cmd app.Command) (err error) {\n\t// 为什么使用 backgroundCtx 而不是 ctx？\n\t// 因为 ctx 代表调用方的上下文，通常是 rpc 请求上下文。\n\t// 而执行命令的上下文，应该是一个独立的上下文，不应该受到调用方的影响\n\t// 即使由于网络抖动等原因，调用方的上下文已经超时，但是命令执行的上下文仍然应该继续执行。\n\tworkerCtx := context.WithValue(d.backgroundCtx, ctxKeyCommand, cmd)\n\tworkerCtx, cancelFunc := context.WithTimeout(workerCtx, d.workerTimeout)\n\tworkerCtx = logs.GetLogger(ctx).WithContext(workerCtx)\n\tlockKeys := cmd.LockKeys()\n\terrChan := make(chan error, 1)\n\tlockOption := &dlock.Option{\n\t\tRetryStrategy: dlock.ExponentialBackoff(100*time.Millisecond, 6*time.Second),\n\t}\n\td.wg.Add(1)\n\t// 最终打印错误\n\t// TODO: 并发控制最大能同时执行的命令数量\n\tgo func() {\n\t\tdefer d.wg.Done()\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\te, ok := err.(error)\n\t\t\t\tif !ok {\n\t\t\t\t\te = errors.Newf(ErrDispatchPanic, \"dispatcher panic: %v\", err)\n\t\t\t\t}\n\t\t\t\terrChan <- e\n\t\t\t\tlogs.Error(workerCtx).Err(e).Stack().Bytes(\"trace\", debug.Stack()).Msgf(\"command execution panic\")\n\t\t\t}\n\t\t}()\n\n\t\tdefer cancelFunc()\n\n\t\tif lockKeys != nil {\n\t\t\tlock, err := d.locker.ObtainMulti(workerCtx, lockKeys, d.workerTimeout, lockOption)\n\t\t\tif err != nil {\n\t\t\t\terrChan <- err\n\t\t\t\tlogs.Warn(workerCtx).Err(err).Msgf(\"command execution waiting locks timeout\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer lock.Release(workerCtx)\n\t\t}\n\n\t\tuow := app.GetRegistry(ctx).Repositories.UoWFactory.New()\n\t\tworkerCtx = app.GetRegistry(ctx).Repositories.UoWFactory.With(workerCtx, uow)\n\n\t\terr = cmd.Handle(workerCtx)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, errors.ErrDryRunSuccessExit) {\n\t\t\t\terr = nil\n\t\t\t} else {\n\t\t\t\tlogs.Warn(workerCtx).Err(err).Msgf(\"command execution failed\")\n\t\t\t}\n\t\t\t_err := uow.Rollback(workerCtx)\n\t\t\tif _err != nil {\n\t\t\t\tlogs.Error(workerCtx).Err(_err).Msgf(\"unit of work rollback failed\")\n\t\t\t}\n\t\t} else {\n\t\t\terr = uow.Commit(workerCtx)\n\t\t\tif err != nil {\n\t\t\t\tlogs.Error(workerCtx).Err(err).Msgf(\"unit of work commit failed\")\n\t\t\t}\n\t\t}\n\t\terrChan <- err\n\t\tclose(errChan)\n\t}()\n\tselect {\n\tcase err := <-errChan:\n\t\treturn err\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 417,
        "code_end_line": 470,
        "code_key": "tryObtainMulti",
        "code_value": "func (l *mysqlLocker) tryObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, tokens []string, opts *dlock.Option) ([]string, error) {\n\t// Starts a new transaction.\n\ttx := l.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\n\n\t// Fetch existing locks.\n\texistingReadKeys, existingWriteKeys, expiredKeys, err := l.fetchExistingLocks(tx, keys)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// If there are existing valid locks, return an error.\n\tif len(existingWriteKeys) > 0 {\n\t\t_ = tx.Rollback()\n\t\treturn nil, errors.Wrap(dlock.ErrLockNotHeld, fmt.Sprintf(\"writeKeys %v are already locked\", existingWriteKeys))\n\t}\n\n\t// Delete expired locks if exists.\n\tif err := l.deleteExpiredLocks(tx, expiredKeys); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Remove existing readLocks from insert.\n\t// NOCA:QCloudAkCheck(误报)\n\tlockKeys, err := l.removeExistingReadLocksFromInsert(tx, keys, existingReadKeys)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Insert locks into database.\n\tneedInsertReadKeys, err := l.insertLocks(tx, lockKeys, ttl, tokens)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Update readLocks.\n\tvar needUpdateExpirationReadKeys []string = nil\n\tvar needUpdateCountReadKeys []string = nil\n\tif needUpdateExpirationReadKeys, needUpdateCountReadKeys, tokens, err = l.updateReadLocks(tx, ttl, existingReadKeys, tokens); err != nil {\n\t\tl.rollback(needUpdateCountReadKeys, tokens)\n\t\tl.rollback(needUpdateExpirationReadKeys, tokens)\n\t\tl.rollback(needInsertReadKeys, tokens)\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\tif result := tx.Commit(); result.Error != nil {\n\t\treturn nil, errors.Wrap(result.Error, \"failed to commit transaction\")\n\t}\n\n\treturn tokens, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mem/memdlock.go",
        "code_start_line": 106,
        "code_end_line": 166,
        "code_key": "tryObtainMulti",
        "code_value": "func (l *memLocker) tryObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, token string) (dlock.Lock, error) {\n\tl.mutex.Lock()\n\tdefer l.mutex.Unlock()\n\tvar readLocks []*dlock.LockKey\n\tvar writeLocks []*dlock.LockKey\n\tvar insertLocks []*dlock.LockKey\n\tvar tokens []string\n\ttokens = append(tokens, token)\n\tfor _, key := range keys {\n\t\tif key.Type == dlock.WriteLock {\n\t\t\twriteLocks = append(writeLocks, key)\n\t\t} else {\n\t\t\treadLocks = append(readLocks, key)\n\t\t}\n\t}\n\tfor _, key := range writeLocks {\n\t\tif item, ok := l.data[key.Key]; ok {\n\t\t\tif time.Until(item.ttl) > 0 {\n\t\t\t\treturn nil, dlock.ErrNotObtained\n\t\t\t} else {\n\t\t\t\tinsertLocks = append(insertLocks, key)\n\t\t\t}\n\t\t} else {\n\t\t\tinsertLocks = append(insertLocks, key)\n\t\t}\n\t}\n\tfor _, key := range readLocks {\n\t\tif item, ok := l.data[key.Key]; ok {\n\t\t\tif item.lockType == dlock.ReadLock {\n\t\t\t\tif time.Until(item.ttl) > 0 {\n\t\t\t\t\titem.count++\n\t\t\t\t\titem.ttl = time.Now().Add(ttl)\n\t\t\t\t\ttokens = append(tokens, item.token)\n\t\t\t\t} else {\n\t\t\t\t\tinsertLocks = append(insertLocks, key)\n\t\t\t\t}\n\t\t\t} else if time.Until(item.ttl) > 0 {\n\t\t\t\treturn nil, dlock.ErrNotObtained\n\t\t\t}\n\t\t} else {\n\t\t\tinsertLocks = append(insertLocks, key)\n\t\t}\n\t}\n\n\tfor _, key := range insertLocks {\n\t\tl.data[key.Key] = &lockItem{\n\t\t\tkey:      key.Key,\n\t\t\tttl:      time.Now().Add(ttl),\n\t\t\ttoken:    token,\n\t\t\tlockType: key.Type,\n\t\t\tcount:    1,\n\t\t}\n\t}\n\n\tlock := &memLock{\n\t\tlocker: l,\n\t\tkeys:   keys,\n\t\ttokens: tokens,\n\t}\n\treturn lock, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 67,
        "code_end_line": 83,
        "code_key": "PhysicalVolume",
        "code_value": "type PhysicalVolume struct {\n\tEntityMixin\n\tSerial          Serial              // 物理卷序列号\n\tIP              net.IP              // 物理卷所在主机 IP\n\tBDF             BDF                 // 物理卷所在主机的 BDF\n\tDiskID          uint64              // 物理卷在主机上的 BDev ID\n\tState           PhysicalVolumeState // 物理卷状态\n\tSize            Size                // 物理卷对外售卖大小 GiB\n\tVolumeType      VolumeType          // 物理卷类型\n\tZoneID          ZoneID              // 物理卷所在的 Zone\n\tBlockSize       uint                // 物理卷块大小，通常为 512\n\tRealSize        uint64              // 物理卷实际大小，单位为 Byte\n\tPort            uint                // 物理卷所在主机的端口\n\tDataNodeType    DataNodeType        // 数据节点类型\n\tCuf             Cuf                 // 存储节点 CUF 信息\n\tPerformanceRank PerformanceRank     // 物理卷性能等级\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 178,
        "code_end_line": 190,
        "code_key": "LogicalVolume",
        "code_value": "type LogicalVolume struct {\n\tEntityMixin\n\tUUID            uuid.UUID\n\tState           LogicalVolumeState\n\tSize            Size\n\tAppID           users.AppID\n\tZoneID          ZoneID\n\tDiskType        DiskType\n\tVolumeType      VolumeType\n\tFlowControlSpec FlowControlSpec\n\tPhysicalVolume  *PhysicalVolume\n\tAttachments     []*VolumeAttachment\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/models.go",
        "code_start_line": 58,
        "code_end_line": 68,
        "code_key": "DRGroup",
        "code_value": "type DRGroup struct {\n\tID       uint64      // 群组 ID，用作实体 ID\n\tName     string      // 群组名称，在同一个 AppID 下必须唯一\n\tAppID    users.AppID // 群组所属应用 ID\n\tType     LocType     // 群组类型，保留字段\n\tAffinity int         // 亲和度，表示群组内子组在同一台位置上最多只能有多少个\n\n\tsubGroups    map[string]*SubGroup   // 子组\n\tlocationsMap map[string][]*SubGroup // 位置到子组的映射\n\tmembersMap   map[string]*SubGroup   // 成员到子组的映射\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/backup/models.go",
        "code_start_line": 47,
        "code_end_line": 56,
        "code_key": "Backup",
        "code_value": "type Backup struct {\n\tID         uint64       // ID\n\tUUID       uuid.UUID    // 备份 UUID\n\tAppID      users.AppID  // 所属 AppID\n\tStatus     BackupStatus // 备份状态\n\tDiskInfo   DiskInfo     // 远端 SSD 信息\n\tPercentage int          // 备份进度，0-100\n\tCreateTime time.Time    // 创建时间\n\tLocation   COSLocation  // COS 存储位置\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/benchmark/benchmark.go",
        "code_start_line": 73,
        "code_end_line": 83,
        "code_key": "Benchmark",
        "code_value": "type Benchmark struct {\n\tID       uint64          // 主键 ID\n\tUUID     uuid.UUID       // 压测 UUID\n\tStatus   Status          // 压测状态\n\tDiskInfo DiskInfo        // 压测磁盘信息\n\tTaskID   uint64          // 任务 ID (BlockAgent 任务 ID)\n\tStat     PerformanceStat // 性能统计数据\n\tError    string          // 错误信息\n\tCreated  time.Time       // 创建时间\n\tFinished time.Time       // 完成时间\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_benchmark_task.go:32:57:Handle": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_benchmark_task.go",
    "code_start_line": 32,
    "code_end_line": 57,
    "code_start_column": 34,
    "code_key": "Handle",
    "code_value": "func (c *DeleteBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\terr       error\n\t)\n\n\tbench, err := benchRepo.FindByUUID(ctx, c.BenchmarkUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif bench.DiskInfo.Serial != c.Serial {\n\t\treturn errors.Newf(benchmark.ErrTaskNotFound, \"benchmark serial not match %s, want %s\", c.Serial, bench.DiskInfo.Serial)\n\t}\n\n\t_, err = benchSm.Fire(ctx, bench.Status, benchmark.EventDeleteBench, benchmark.Data{Benchmark: bench, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := benchRepo.Delete(ctx, bench); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/cmd/run.go",
        "code_start_line": 84,
        "code_end_line": 109,
        "code_key": "initApiServer",
        "code_value": "func initApiServer() {\n\tglobalCfg := registry.GlobalRegistry.AppConfig.Global\n\n\trouter := mux.NewRouter()\n\tserver := &http.Server{\n\t\tAddr:    fmt.Sprintf(\"0.0.0.0:%d\", globalCfg.PprofPort),\n\t\tHandler: router,\n\t}\n\t// Prometheus\n\trouter.Handle(\"/metrics\", promhttp.Handler())\n\n\t// pprof\n\trouter.HandleFunc(\"/debug/pprof/\", pprof.Index)\n\trouter.HandleFunc(\"/debug/pprof/cmdline\", pprof.Cmdline)\n\trouter.HandleFunc(\"/debug/pprof/profile\", pprof.Profile)\n\trouter.HandleFunc(\"/debug/pprof/symbol\", pprof.Symbol)\n\trouter.HandleFunc(\"/debug/pprof/trace\", pprof.Trace)\n\n\t// init k8s liveness readness probe\n\trouter.HandleFunc(\"/live\", k8sProbe)\n\trouter.HandleFunc(\"/ready\", k8sProbe)\n\n\tgo func() {\n\t\tfmt.Println(server.ListenAndServe())\n\t}()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/dispatcher/dispatcher.go",
        "code_start_line": 33,
        "code_end_line": 103,
        "code_key": "Dispatch",
        "code_value": "func (d *dispatcherImpl) Dispatch(ctx context.Context, cmd app.Command) (err error) {\n\t// 为什么使用 backgroundCtx 而不是 ctx？\n\t// 因为 ctx 代表调用方的上下文，通常是 rpc 请求上下文。\n\t// 而执行命令的上下文，应该是一个独立的上下文，不应该受到调用方的影响\n\t// 即使由于网络抖动等原因，调用方的上下文已经超时，但是命令执行的上下文仍然应该继续执行。\n\tworkerCtx := context.WithValue(d.backgroundCtx, ctxKeyCommand, cmd)\n\tworkerCtx, cancelFunc := context.WithTimeout(workerCtx, d.workerTimeout)\n\tworkerCtx = logs.GetLogger(ctx).WithContext(workerCtx)\n\tlockKeys := cmd.LockKeys()\n\terrChan := make(chan error, 1)\n\tlockOption := &dlock.Option{\n\t\tRetryStrategy: dlock.ExponentialBackoff(100*time.Millisecond, 6*time.Second),\n\t}\n\td.wg.Add(1)\n\t// 最终打印错误\n\t// TODO: 并发控制最大能同时执行的命令数量\n\tgo func() {\n\t\tdefer d.wg.Done()\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\te, ok := err.(error)\n\t\t\t\tif !ok {\n\t\t\t\t\te = errors.Newf(ErrDispatchPanic, \"dispatcher panic: %v\", err)\n\t\t\t\t}\n\t\t\t\terrChan <- e\n\t\t\t\tlogs.Error(workerCtx).Err(e).Stack().Bytes(\"trace\", debug.Stack()).Msgf(\"command execution panic\")\n\t\t\t}\n\t\t}()\n\n\t\tdefer cancelFunc()\n\n\t\tif lockKeys != nil {\n\t\t\tlock, err := d.locker.ObtainMulti(workerCtx, lockKeys, d.workerTimeout, lockOption)\n\t\t\tif err != nil {\n\t\t\t\terrChan <- err\n\t\t\t\tlogs.Warn(workerCtx).Err(err).Msgf(\"command execution waiting locks timeout\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer lock.Release(workerCtx)\n\t\t}\n\n\t\tuow := app.GetRegistry(ctx).Repositories.UoWFactory.New()\n\t\tworkerCtx = app.GetRegistry(ctx).Repositories.UoWFactory.With(workerCtx, uow)\n\n\t\terr = cmd.Handle(workerCtx)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, errors.ErrDryRunSuccessExit) {\n\t\t\t\terr = nil\n\t\t\t} else {\n\t\t\t\tlogs.Warn(workerCtx).Err(err).Msgf(\"command execution failed\")\n\t\t\t}\n\t\t\t_err := uow.Rollback(workerCtx)\n\t\t\tif _err != nil {\n\t\t\t\tlogs.Error(workerCtx).Err(_err).Msgf(\"unit of work rollback failed\")\n\t\t\t}\n\t\t} else {\n\t\t\terr = uow.Commit(workerCtx)\n\t\t\tif err != nil {\n\t\t\t\tlogs.Error(workerCtx).Err(err).Msgf(\"unit of work commit failed\")\n\t\t\t}\n\t\t}\n\t\terrChan <- err\n\t\tclose(errChan)\n\t}()\n\tselect {\n\tcase err := <-errChan:\n\t\treturn err\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/benchmark/benchmark.go",
        "code_start_line": 132,
        "code_end_line": 135,
        "code_key": "Data",
        "code_value": "type Data struct {\n\t*Benchmark\n\tDelegate\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/backup/states.go",
        "code_start_line": 24,
        "code_end_line": 27,
        "code_key": "Data",
        "code_value": "type Data struct {\n\tBackup *Backup\n\tDelegate\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_benchmark_task.go",
        "code_start_line": 20,
        "code_end_line": 26,
        "code_key": "benchmarkDelegate",
        "code_value": "type benchmarkDelegate struct {\n\tcmd         app.BenchmarkContext\n\tresultCache *struct {\n\t\tstat *benchmark.PerformanceStat\n\t\terr  error\n\t}\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/consumer_srv/domain/user/repo.go:18:29:GetUserCtlRecord": {
    "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/user/repo.go",
    "code_start_line": 18,
    "code_end_line": 29,
    "code_start_column": 23,
    "code_key": "GetUserCtlRecord",
    "code_value": "func (repo *UserRepo) GetUserCtlRecord(ctx context.Context, appId int64) (*des.TCbsUserControl, error) {\n\tvar userCtl des.TCbsUserControl\n\tresult := repo.DB.Where(\"appId = ?\", appId).First(&userCtl)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\n\treturn &userCtl, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/entity.go",
        "code_start_line": 35,
        "code_end_line": 37,
        "code_key": "GetUser",
        "code_value": "func (a *AffinityEntity) GetUser(ctx context.Context) *account.User {\n\treturn a.user\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/production/entity.go",
        "code_start_line": 16,
        "code_end_line": 18,
        "code_key": "GetUser",
        "code_value": "func (c *CreateDiskEntity) GetUser() *account.User {\n\treturn c.user\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/user/service.go",
        "code_start_line": 24,
        "code_end_line": 40,
        "code_key": "GetUser",
        "code_value": "func (userSrv *UserSrv) GetUser(appId AppId) (*User, error) {\n\tuserCtl, err := userSrv.repo.GetUserCtlRecord(userSrv.ctx, int64(appId))\n\tif err != nil || userCtl == nil {\n\t\tlogs.Error(userSrv.ctx).Err(err).Int64(\"appId\", int64(appId)).Msg(\"GET_USER_CTL_RECORD_ERROR\")\n\t\t// TODO 走account API进行兜底查询\n\t\treturn nil, err\n\t}\n\n\tuser := &User{\n\t\tAppId:      appId,\n\t\tUin:        Uin(userCtl.Uin),\n\t\tOperateUin: Uin(userCtl.Uin),\n\t\tarea:       Area(userCtl.Area),\n\t\tfeature:    userCtl.Feature,\n\t}\n\treturn user, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/user/service.go",
        "code_start_line": 23,
        "code_end_line": 39,
        "code_key": "GetUser",
        "code_value": "func (userSrv *UserSrv) GetUser(appId AppId) (*User, error) {\n\tuserCtl, err := userSrv.repo.GetUserCtlRecord(userSrv.ctx, int64(appId))\n\tif err != nil || userCtl == nil {\n\t\tlogs.Error(userSrv.ctx).Err(err).Int64(\"appId\", int64(appId)).Msg(\"GET_USER_CTL_RECORD_ERROR\")\n\t\t// TODO 走account API进行兜底查询\n\t\treturn nil, err\n\t}\n\n\tuser := &User{\n\t\tAppId:      appId,\n\t\tUin:        Uin(userCtl.Uin),\n\t\tOperateUin: Uin(userCtl.Uin),\n\t\tarea:       Area(userCtl.Area),\n\t\tfeature:    userCtl.Feature,\n\t}\n\treturn user, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/adapter/db/des/model.go",
        "code_start_line": 5,
        "code_end_line": 16,
        "code_key": "TCbsUserControl",
        "code_value": "type TCbsUserControl struct {\n\tID         int64     `gorm:\"column:id;primary_key:true\"`\n\tAppID      int64     `gorm:\"column:appId\"`\n\tUin        string    `gorm:\"column:uin\"`\n\tNickname   string    `gorm:\"column:nickname\"`\n\tArea       string    `gorm:\"column:area\"`\n\tFeature    int64     `gorm:\"column:feature\"`\n\tLevel      int64     `gorm:\"column:level\"`\n\tExtraInfo  string    `gorm:\"column:extraInfo\"`\n\tAddTime    time.Time `gorm:\"column:addTime\"`\n\tUpdateTime time.Time `gorm:\"column:updateTime\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/adapter/db/des/model.go",
        "code_start_line": 18,
        "code_end_line": 20,
        "code_key": "TableName",
        "code_value": "func (TCbsUserControl) TableName() string {\n\treturn \"t_cbs_user_control\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/user.go:15:31:GetUserCtlRecord": {
    "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/user.go",
    "code_start_line": 15,
    "code_end_line": 31,
    "code_start_column": 23,
    "code_key": "GetUserCtlRecord",
    "code_value": "func (repo *UserRepo) GetUserCtlRecord(ctx context.Context, appId int64) (*des.TCbsUserControl, error) {\n\tdb, err := repo.getDesDb(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar userCtl des.TCbsUserControl\n\tresult := db.Where(\"appId = ?\", appId).First(&userCtl)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\n\treturn &userCtl, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/entity.go",
        "code_start_line": 35,
        "code_end_line": 37,
        "code_key": "GetUser",
        "code_value": "func (a *AffinityEntity) GetUser(ctx context.Context) *account.User {\n\treturn a.user\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/production/entity.go",
        "code_start_line": 16,
        "code_end_line": 18,
        "code_key": "GetUser",
        "code_value": "func (c *CreateDiskEntity) GetUser() *account.User {\n\treturn c.user\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/user/service.go",
        "code_start_line": 24,
        "code_end_line": 40,
        "code_key": "GetUser",
        "code_value": "func (userSrv *UserSrv) GetUser(appId AppId) (*User, error) {\n\tuserCtl, err := userSrv.repo.GetUserCtlRecord(userSrv.ctx, int64(appId))\n\tif err != nil || userCtl == nil {\n\t\tlogs.Error(userSrv.ctx).Err(err).Int64(\"appId\", int64(appId)).Msg(\"GET_USER_CTL_RECORD_ERROR\")\n\t\t// TODO 走account API进行兜底查询\n\t\treturn nil, err\n\t}\n\n\tuser := &User{\n\t\tAppId:      appId,\n\t\tUin:        Uin(userCtl.Uin),\n\t\tOperateUin: Uin(userCtl.Uin),\n\t\tarea:       Area(userCtl.Area),\n\t\tfeature:    userCtl.Feature,\n\t}\n\treturn user, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/user/service.go",
        "code_start_line": 23,
        "code_end_line": 39,
        "code_key": "GetUser",
        "code_value": "func (userSrv *UserSrv) GetUser(appId AppId) (*User, error) {\n\tuserCtl, err := userSrv.repo.GetUserCtlRecord(userSrv.ctx, int64(appId))\n\tif err != nil || userCtl == nil {\n\t\tlogs.Error(userSrv.ctx).Err(err).Int64(\"appId\", int64(appId)).Msg(\"GET_USER_CTL_RECORD_ERROR\")\n\t\t// TODO 走account API进行兜底查询\n\t\treturn nil, err\n\t}\n\n\tuser := &User{\n\t\tAppId:      appId,\n\t\tUin:        Uin(userCtl.Uin),\n\t\tOperateUin: Uin(userCtl.Uin),\n\t\tarea:       Area(userCtl.Area),\n\t\tfeature:    userCtl.Feature,\n\t}\n\treturn user, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/adapter/db/des/model.go",
        "code_start_line": 5,
        "code_end_line": 16,
        "code_key": "TCbsUserControl",
        "code_value": "type TCbsUserControl struct {\n\tID         int64     `gorm:\"column:id;primary_key:true\"`\n\tAppID      int64     `gorm:\"column:appId\"`\n\tUin        string    `gorm:\"column:uin\"`\n\tNickname   string    `gorm:\"column:nickname\"`\n\tArea       string    `gorm:\"column:area\"`\n\tFeature    int64     `gorm:\"column:feature\"`\n\tLevel      int64     `gorm:\"column:level\"`\n\tExtraInfo  string    `gorm:\"column:extraInfo\"`\n\tAddTime    time.Time `gorm:\"column:addTime\"`\n\tUpdateTime time.Time `gorm:\"column:updateTime\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/adapter/db/des/model.go",
        "code_start_line": 18,
        "code_end_line": 20,
        "code_key": "TableName",
        "code_value": "func (TCbsUserControl) TableName() string {\n\treturn \"t_cbs_user_control\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/consumer_srv/domain/user/repo.go:31:41:GetUserArea": {
    "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/user/repo.go",
    "code_start_line": 31,
    "code_end_line": 41,
    "code_start_column": 23,
    "code_key": "GetUserArea",
    "code_value": "func (repo *UserRepo) GetUserArea(ctx context.Context, appId int64) (string, error) {\n\tvar userCtl des.TCbsUserControl\n\tresult := repo.DB.Select(\"area\").Where(\"appId = ?\", appId).First(&userCtl)\n\tif result.Error != nil {\n\t\treturn \"\", result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn \"\", nil\n\t}\n\treturn userCtl.Area, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/adapter/db/des/model.go",
        "code_start_line": 5,
        "code_end_line": 16,
        "code_key": "TCbsUserControl",
        "code_value": "type TCbsUserControl struct {\n\tID         int64     `gorm:\"column:id;primary_key:true\"`\n\tAppID      int64     `gorm:\"column:appId\"`\n\tUin        string    `gorm:\"column:uin\"`\n\tNickname   string    `gorm:\"column:nickname\"`\n\tArea       string    `gorm:\"column:area\"`\n\tFeature    int64     `gorm:\"column:feature\"`\n\tLevel      int64     `gorm:\"column:level\"`\n\tExtraInfo  string    `gorm:\"column:extraInfo\"`\n\tAddTime    time.Time `gorm:\"column:addTime\"`\n\tUpdateTime time.Time `gorm:\"column:updateTime\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/adapter/db/des/model.go",
        "code_start_line": 18,
        "code_end_line": 20,
        "code_key": "TableName",
        "code_value": "func (TCbsUserControl) TableName() string {\n\treturn \"t_cbs_user_control\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/user.go:33:48:GetUserArea": {
    "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/user.go",
    "code_start_line": 33,
    "code_end_line": 48,
    "code_start_column": 23,
    "code_key": "GetUserArea",
    "code_value": "func (repo *UserRepo) GetUserArea(ctx context.Context, appId int64) (string, error) {\n\tdb, err := repo.getDesDb(ctx)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tvar userCtl des.TCbsUserControl\n\tresult := db.Select(\"area\").Where(\"appId = ?\", appId).First(&userCtl)\n\tif result.Error != nil {\n\t\treturn \"\", result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn \"\", nil\n\t}\n\treturn userCtl.Area, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/adapter/db/des/model.go",
        "code_start_line": 5,
        "code_end_line": 16,
        "code_key": "TCbsUserControl",
        "code_value": "type TCbsUserControl struct {\n\tID         int64     `gorm:\"column:id;primary_key:true\"`\n\tAppID      int64     `gorm:\"column:appId\"`\n\tUin        string    `gorm:\"column:uin\"`\n\tNickname   string    `gorm:\"column:nickname\"`\n\tArea       string    `gorm:\"column:area\"`\n\tFeature    int64     `gorm:\"column:feature\"`\n\tLevel      int64     `gorm:\"column:level\"`\n\tExtraInfo  string    `gorm:\"column:extraInfo\"`\n\tAddTime    time.Time `gorm:\"column:addTime\"`\n\tUpdateTime time.Time `gorm:\"column:updateTime\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/adapter/db/des/model.go",
        "code_start_line": 18,
        "code_end_line": 20,
        "code_key": "TableName",
        "code_value": "func (TCbsUserControl) TableName() string {\n\treturn \"t_cbs_user_control\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/repositories/cbs.go:22:32:QueryDiskInfoById": {
    "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/repositories/cbs.go",
    "code_start_line": 22,
    "code_end_line": 32,
    "code_start_column": 32,
    "code_key": "QueryDiskInfoById",
    "code_value": "func (cbsRepo *CbsBalanceRepo) QueryDiskInfoById(ctx context.Context, id string) (*ccdb.CCbs, error) {\n\tvar disk ccdb.CCbs\n\n\tresult := cbsRepo.DB.Where(\"cbsInstanceId = ?\", id).Find(&disk)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t} else if result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\treturn &disk, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/service.go",
        "code_start_line": 369,
        "code_end_line": 434,
        "code_key": "processSingleBalanceRecords",
        "code_value": "func (cbsSrv *CbsSrv) processSingleBalanceRecords(chargeItem *ChargeItem, beginBalanceRecord *ccdb.CCbsBalance, endBalanceRecord *ccdb.CCbsBalance, user *user.User, resourceId ResourceId) (stopCharge bool) {\n\tstopCharge = false\n\t// 资源欠费，不收取费用\n\tif beginBalanceRecord.OperationType == int(CbsOpArrearage) {\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"RESOURCE_ARREARAGE\")\n\t\treturn\n\t}\n\t// 资源退还。判断是否为预付费的性能突发场景\n\tif beginBalanceRecord.OperationType == int(CbsOpReturn) || beginBalanceRecord.OperationType == int(CbsOpConvert) {\n\t\t// 判断是否为预付费的性能突发场景.\n\t\t// 获取云盘信息。这里在循环中进行查询，但命中的应该不会很多，放在外层反而会导致每个云盘都被查询\n\t\tdisk, err := cbsSrv.diskRepo.QueryDiskInfoById(cbsSrv.ctx, string(resourceId))\n\t\tif err != nil || disk == nil {\n\t\t\tlogs.Error(cbsSrv.ctx).Err(err).Str(\"resourceId\", string(resourceId)).Msg(\"QUERY_CBS_RECORD_FAILED\")\n\t\t\t// TODO 这里先不返回资源的推量？\n\t\t\treturn true\n\t\t}\n\t\t// TODO 走diskLogical\n\t\tif disk.PayMode == \"prepay\" {\n\t\t\t// 性能突发场景，预付费用户退盘，退盘费用不计\n\t\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"MAYBE_CBS_WITH_BURST_PERFORMANCE\")\n\t\t\treturn\n\t\t}\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"CBS_HAS_RETURNED\")\n\t\treturn true\n\t}\n\n\t// 资源正常\n\tstartTime := beginBalanceRecord.LastBalanceTime\n\tendTime := endBalanceRecord.LastBalanceTime\n\tcurTime := startTime\n\tfor endTime.After(curTime) {\n\t\tcurHourEnd := time.Date(curTime.Year(), curTime.Month(), curTime.Day(), curTime.Hour(), 59, 59, 0, curTime.Location())\n\n\t\tvar config CCbsBalanceConfig\n\t\terr := json.Unmarshal([]byte(beginBalanceRecord.Config), &config)\n\t\tif err != nil {\n\t\t\tlogs.Error(cbsSrv.ctx).Err(err).Msg(\"PARSE_CONFIG_ERROR\")\n\t\t\treturn\n\t\t}\n\n\t\tcurEndTime := endTime\n\t\tcurStarTime := curTime\n\t\tif !endTime.After(curHourEnd) {\n\t\t\t// 同一周期\n\t\t\tcurTime = endTime.Add(time.Second)\n\t\t} else {\n\t\t\tcurEndTime = curHourEnd\n\t\t\tcurTime = curHourEnd.Add(time.Second)\n\t\t}\n\t\tsubItem := &SubItem{\n\t\t\tPid:       beginBalanceRecord.Pid,\n\t\t\tStartTime: curStarTime,\n\t\t\tEndTime:   curEndTime,\n\t\t\tProjectId: beginBalanceRecord.ProjectID,\n\t\t\tParams:    beginBalanceRecord.ResourceInfo,\n\t\t\tSubValueDetail: map[string]interface{}{\n\t\t\t\t// FIXME 性能突发场景待实现\n\t\t\t\t\"Size\":             config.Size,\n\t\t\t\t\"BackupPointQuota\": config.BackupPointQuota,\n\t\t\t},\n\t\t}\n\t\tchargeItem.Items = append(chargeItem.Items, subItem)\n\t}\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 416,
        "code_end_line": 481,
        "code_key": "processSingleBalanceRecords",
        "code_value": "func (cbsSrv *CbsSrv) processSingleBalanceRecords(chargeItem *ChargeItem, beginBalanceRecord *ccdb.CCbsBalance, endBalanceRecord *ccdb.CCbsBalance, user *user.User, resourceId ResourceId) (stopCharge bool) {\n\tstopCharge = false\n\t// 资源欠费，不收取费用\n\tif beginBalanceRecord.OperationType == int(CbsOpArrearage) {\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"RESOURCE_ARREARAGE\")\n\t\treturn\n\t}\n\t// 资源退还。判断是否为预付费的性能突发场景\n\tif beginBalanceRecord.OperationType == int(CbsOpReturn) || beginBalanceRecord.OperationType == int(CbsOpConvert) {\n\t\t// 判断是否为预付费的性能突发场景.\n\t\t// 获取云盘信息。这里在循环中进行查询，但命中的应该不会很多，放在外层反而会导致每个云盘都被查询\n\t\tdisk, err := cbsSrv.diskRepo.QueryDiskInfoById(cbsSrv.ctx, string(resourceId))\n\t\tif err != nil || disk == nil {\n\t\t\tlogs.Error(cbsSrv.ctx).Err(err).Str(\"resourceId\", string(resourceId)).Msg(\"QUERY_CBS_RECORD_FAILED\")\n\t\t\t// TODO 这里先不返回资源的推量？\n\t\t\treturn true\n\t\t}\n\t\t// TODO 走diskLogical\n\t\tif disk.PayMode == \"prepay\" {\n\t\t\t// 性能突发场景，预付费用户退盘，退盘费用不计\n\t\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"MAYBE_CBS_WITH_BURST_PERFORMANCE\")\n\t\t\treturn\n\t\t}\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"CBS_HAS_RETURNED\")\n\t\treturn true\n\t}\n\n\t// 资源正常\n\tstartTime := beginBalanceRecord.LastBalanceTime\n\tendTime := endBalanceRecord.LastBalanceTime\n\tcurTime := startTime\n\tfor endTime.After(curTime) {\n\t\tcurHourEnd := time.Date(curTime.Year(), curTime.Month(), curTime.Day(), curTime.Hour(), 59, 59, 0, curTime.Location())\n\n\t\tvar config CCbsBalanceConfig\n\t\terr := json.Unmarshal([]byte(beginBalanceRecord.Config), &config)\n\t\tif err != nil {\n\t\t\tlogs.Error(cbsSrv.ctx).Err(err).Msg(\"PARSE_CONFIG_ERROR\")\n\t\t\treturn\n\t\t}\n\n\t\tcurEndTime := endTime\n\t\tcurStarTime := curTime\n\t\tif !endTime.After(curHourEnd) {\n\t\t\t// 同一周期\n\t\t\tcurTime = endTime.Add(time.Second)\n\t\t} else {\n\t\t\tcurEndTime = curHourEnd\n\t\t\tcurTime = curHourEnd.Add(time.Second)\n\t\t}\n\t\tsubItem := &SubItem{\n\t\t\tPid:       beginBalanceRecord.Pid,\n\t\t\tStartTime: curStarTime,\n\t\t\tEndTime:   curEndTime,\n\t\t\tProjectId: beginBalanceRecord.ProjectID,\n\t\t\tParams:    beginBalanceRecord.ResourceInfo,\n\t\t\tSubValueDetail: map[string]interface{}{\n\t\t\t\t// FIXME 性能突发场景待实现\n\t\t\t\t\"Size\":             config.Size,\n\t\t\t\t\"BackupPointQuota\": config.BackupPointQuota,\n\t\t\t},\n\t\t}\n\t\tchargeItem.Items = append(chargeItem.Items, subItem)\n\t}\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/adapter/db/ccdb/model.go",
        "code_start_line": 52,
        "code_end_line": 67,
        "code_key": "CCbs",
        "code_value": "type CCbs struct {\n\tCbsId              int64  `gorm:\"column:cbsId;primaryKey\"`\n\tAppId              int64  `gorm:\"column:appId\"`\n\tCbsInstanceId      string `gorm:\"column:cbsInstanceId\"`\n\tCbsUuid            string `gorm:\"column:cbsUuid\"`\n\tDiskSize           int    `gorm:\"column:diskSize\"`\n\tDiskType           string `gorm:\"column:diskType\"`\n\tLifeState          string `gorm:\"column:lifeState\"`\n\tStatus             int    `gorm:\"column:status\"`\n\tRollbacking        int    `gorm:\"column:rollbacking\"`\n\tRollbackingPercent int    `gorm:\"column:rollbackPercent\"`\n\tArchType           string `gorm:\"column:archType\"`\n\tAssigned           int    `gorm:\"column:assigned\"`\n\tAttached           int    `gorm:\"column:attached\"`\n\tPayMode            string `gorm:\"column:payMode\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/adapter/db/ccdb/model.go",
        "code_start_line": 69,
        "code_end_line": 71,
        "code_key": "TableName",
        "code_value": "func (CCbs) TableName() string {\n\treturn \"cCbs\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/db/ccdb/model.go",
        "code_start_line": 52,
        "code_end_line": 67,
        "code_key": "CCbs",
        "code_value": "type CCbs struct {\n\tCbsId              int64  `gorm:\"column:cbsId;primaryKey\"`\n\tAppId              int64  `gorm:\"column:appId\"`\n\tCbsInstanceId      string `gorm:\"column:cbsInstanceId\"`\n\tCbsUuid            string `gorm:\"column:cbsUuid\"`\n\tDiskSize           int    `gorm:\"column:diskSize\"`\n\tDiskType           string `gorm:\"column:diskType\"`\n\tLifeState          string `gorm:\"column:lifeState\"`\n\tStatus             int    `gorm:\"column:status\"`\n\tRollbacking        int    `gorm:\"column:rollbacking\"`\n\tRollbackingPercent int    `gorm:\"column:rollbackPercent\"`\n\tArchType           string `gorm:\"column:archType\"`\n\tAssigned           int    `gorm:\"column:assigned\"`\n\tAttached           int    `gorm:\"column:attached\"`\n\tPayMode            string `gorm:\"column:payMode\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/db/ccdb/model.go",
        "code_start_line": 69,
        "code_end_line": 71,
        "code_key": "TableName",
        "code_value": "func (CCbs) TableName() string {\n\treturn \"cCbs\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/ccdb/model.go",
        "code_start_line": 7,
        "code_end_line": 68,
        "code_key": "CCbs",
        "code_value": "type CCbs struct {\n\tID                 int64     `gorm:\"column:cbsId;primaryKey\"`\n\tAppID              int64     `gorm:\"column:appId\"`\n\tAlias              string    `gorm:\"column:alias\"`\n\tAssigned           int       `gorm:\"column:assigned\"`\n\tAttached           int       `gorm:\"column:attached\"`\n\tAutoRenewFlag      int       `gorm:\"column:autoRenewFlag\"`\n\tCbsInstanceID      string    `gorm:\"column:cbsInstanceId;uniuq_index\"`\n\tCbsSnap            int       `gorm:\"column:cbsSnap\"`\n\tCbsType            string    `gorm:\"column:cbsType\"`\n\tCbsUuid            string    `gorm:\"column:cbsUuid\"`\n\tDeadline           time.Time `gorm:\"column:deadline\"`\n\tDealID             int       `gorm:\"column:dealId\"`\n\tDealName           string    `gorm:\"column:dealName\"`\n\tDeviceID           int64     `gorm:\"column:deviceId\"`\n\tDiskSize           int       `gorm:\"column:diskSize\"`\n\tDiskType           string    `gorm:\"column:diskType\"`\n\tDom0Ip             string    `gorm:\"column:dom0Ip\"`\n\tFsType             string    `gorm:\"column:fsType\"`\n\tHostBlockSize      int       `gorm:\"column:hostBlockSize\"`\n\tLifeState          string    `gorm:\"column:lifeState\"`\n\tPath               string    `gorm:\"column:path\"`\n\tPayMode            string    `gorm:\"column:payMode\"`\n\tPortable           int       `gorm:\"column:portable\"`\n\tProjectID          int       `gorm:\"column:projectId\"`\n\tQcloudZone         int       `gorm:\"column:qcloudZone\"`\n\tStatus             int       `gorm:\"column:status\"`\n\tTarget             string    `gorm:\"column:target\"`\n\tTranID             string    `gorm:\"column:tranId\"`\n\tVmBlockSize        int       `gorm:\"column:vmBlockSize\"`\n\tVolumeType         string    `gorm:\"column:volumeType\"`\n\tZone               int       `gorm:\"column:zone\"`\n\tRollbacking        int       `gorm:\"column:rollbacking;default:0\"`\n\tRollbackPercent    int       `gorm:\"column:rollbackPercent;default:0\"`\n\tArchType           string    `gorm:\"column:archType\"`\n\tFlag               int       `gorm:\"column:flag;default:0\"`\n\tEncrypt            string    `gorm:\"column:encrypt\"`\n\tTransactionID      string    `gorm:\"column:transactionId\"`\n\tIsNewDisk          int       `gorm:\"column:isNewDisk;default:0\"`\n\tThroughValue       int       `gorm:\"column:throughValue\"`\n\tIopsValue          int       `gorm:\"column:iopsValue\"`\n\tDeleteWithInstance int       `gorm:\"column:deleteWithInstance\"`\n\tShareable          int       `gorm:\"column:shareable\"`\n\tOrderID            string    `gorm:\"column:orderId\"`\n\tCdcID              string    `gorm:\"column:cdcId\"`\n\tMigrating          int       `gorm:\"column:migrating\"`\n\tMigratePercent     int       `gorm:\"column:migratePercent\"`\n\tEncryptTime        time.Time `gorm:\"column:encryptTime\"`\n\tSnapshotSize       int       `gorm:\"column:snapshotSize\"`\n\tSnapshotCount      int       `gorm:\"column:snapshotCount\"`\n\tInsType            string    `gorm:\"column:insType\"`\n\tInsID              string    `gorm:\"column:insId\"`\n\tInsUuid            string    `gorm:\"column:insUuid\"`\n\tBackupMode         int       `gorm:\"column:backupMode\"`\n\tDeleteMode         string    `gorm:\"column:deleteMode\"`\n\tBackupQuota        int       `gorm:\"column:backupQuota\"`\n\tBackupCount        int       `gorm:\"column:backupCount\"`\n\tClusterGroupId     string    `gorm:\"column:clusterGroupId\"`\n\tOutpostID          string    `gorm:\"column:outpost_id\"`\n\tCreatedAt          time.Time `gorm:\"column:addTimeStamp;type:time\"`\n\tUpdatedAt          time.Time `gorm:\"column:modTimeStamp;type:time\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/ccdb/model.go",
        "code_start_line": 71,
        "code_end_line": 73,
        "code_key": "TableName",
        "code_value": "func (CCbs) TableName() string {\n\treturn \"cCbs\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/disk.go:15:29:QueryDiskInfoById": {
    "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/disk.go",
    "code_start_line": 15,
    "code_end_line": 29,
    "code_start_column": 20,
    "code_key": "QueryDiskInfoById",
    "code_value": "func (d *DiskRepo) QueryDiskInfoById(ctx context.Context, id string) (*ccdb.CCbs, error) {\n\tvar disk ccdb.CCbs\n\n\tdb, err := d.getCCDBDb(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresult := db.Where(\"cbsInstanceId = ?\", id).Find(&disk)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t} else if result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\treturn &disk, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/service.go",
        "code_start_line": 369,
        "code_end_line": 434,
        "code_key": "processSingleBalanceRecords",
        "code_value": "func (cbsSrv *CbsSrv) processSingleBalanceRecords(chargeItem *ChargeItem, beginBalanceRecord *ccdb.CCbsBalance, endBalanceRecord *ccdb.CCbsBalance, user *user.User, resourceId ResourceId) (stopCharge bool) {\n\tstopCharge = false\n\t// 资源欠费，不收取费用\n\tif beginBalanceRecord.OperationType == int(CbsOpArrearage) {\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"RESOURCE_ARREARAGE\")\n\t\treturn\n\t}\n\t// 资源退还。判断是否为预付费的性能突发场景\n\tif beginBalanceRecord.OperationType == int(CbsOpReturn) || beginBalanceRecord.OperationType == int(CbsOpConvert) {\n\t\t// 判断是否为预付费的性能突发场景.\n\t\t// 获取云盘信息。这里在循环中进行查询，但命中的应该不会很多，放在外层反而会导致每个云盘都被查询\n\t\tdisk, err := cbsSrv.diskRepo.QueryDiskInfoById(cbsSrv.ctx, string(resourceId))\n\t\tif err != nil || disk == nil {\n\t\t\tlogs.Error(cbsSrv.ctx).Err(err).Str(\"resourceId\", string(resourceId)).Msg(\"QUERY_CBS_RECORD_FAILED\")\n\t\t\t// TODO 这里先不返回资源的推量？\n\t\t\treturn true\n\t\t}\n\t\t// TODO 走diskLogical\n\t\tif disk.PayMode == \"prepay\" {\n\t\t\t// 性能突发场景，预付费用户退盘，退盘费用不计\n\t\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"MAYBE_CBS_WITH_BURST_PERFORMANCE\")\n\t\t\treturn\n\t\t}\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"CBS_HAS_RETURNED\")\n\t\treturn true\n\t}\n\n\t// 资源正常\n\tstartTime := beginBalanceRecord.LastBalanceTime\n\tendTime := endBalanceRecord.LastBalanceTime\n\tcurTime := startTime\n\tfor endTime.After(curTime) {\n\t\tcurHourEnd := time.Date(curTime.Year(), curTime.Month(), curTime.Day(), curTime.Hour(), 59, 59, 0, curTime.Location())\n\n\t\tvar config CCbsBalanceConfig\n\t\terr := json.Unmarshal([]byte(beginBalanceRecord.Config), &config)\n\t\tif err != nil {\n\t\t\tlogs.Error(cbsSrv.ctx).Err(err).Msg(\"PARSE_CONFIG_ERROR\")\n\t\t\treturn\n\t\t}\n\n\t\tcurEndTime := endTime\n\t\tcurStarTime := curTime\n\t\tif !endTime.After(curHourEnd) {\n\t\t\t// 同一周期\n\t\t\tcurTime = endTime.Add(time.Second)\n\t\t} else {\n\t\t\tcurEndTime = curHourEnd\n\t\t\tcurTime = curHourEnd.Add(time.Second)\n\t\t}\n\t\tsubItem := &SubItem{\n\t\t\tPid:       beginBalanceRecord.Pid,\n\t\t\tStartTime: curStarTime,\n\t\t\tEndTime:   curEndTime,\n\t\t\tProjectId: beginBalanceRecord.ProjectID,\n\t\t\tParams:    beginBalanceRecord.ResourceInfo,\n\t\t\tSubValueDetail: map[string]interface{}{\n\t\t\t\t// FIXME 性能突发场景待实现\n\t\t\t\t\"Size\":             config.Size,\n\t\t\t\t\"BackupPointQuota\": config.BackupPointQuota,\n\t\t\t},\n\t\t}\n\t\tchargeItem.Items = append(chargeItem.Items, subItem)\n\t}\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 416,
        "code_end_line": 481,
        "code_key": "processSingleBalanceRecords",
        "code_value": "func (cbsSrv *CbsSrv) processSingleBalanceRecords(chargeItem *ChargeItem, beginBalanceRecord *ccdb.CCbsBalance, endBalanceRecord *ccdb.CCbsBalance, user *user.User, resourceId ResourceId) (stopCharge bool) {\n\tstopCharge = false\n\t// 资源欠费，不收取费用\n\tif beginBalanceRecord.OperationType == int(CbsOpArrearage) {\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"RESOURCE_ARREARAGE\")\n\t\treturn\n\t}\n\t// 资源退还。判断是否为预付费的性能突发场景\n\tif beginBalanceRecord.OperationType == int(CbsOpReturn) || beginBalanceRecord.OperationType == int(CbsOpConvert) {\n\t\t// 判断是否为预付费的性能突发场景.\n\t\t// 获取云盘信息。这里在循环中进行查询，但命中的应该不会很多，放在外层反而会导致每个云盘都被查询\n\t\tdisk, err := cbsSrv.diskRepo.QueryDiskInfoById(cbsSrv.ctx, string(resourceId))\n\t\tif err != nil || disk == nil {\n\t\t\tlogs.Error(cbsSrv.ctx).Err(err).Str(\"resourceId\", string(resourceId)).Msg(\"QUERY_CBS_RECORD_FAILED\")\n\t\t\t// TODO 这里先不返回资源的推量？\n\t\t\treturn true\n\t\t}\n\t\t// TODO 走diskLogical\n\t\tif disk.PayMode == \"prepay\" {\n\t\t\t// 性能突发场景，预付费用户退盘，退盘费用不计\n\t\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"MAYBE_CBS_WITH_BURST_PERFORMANCE\")\n\t\t\treturn\n\t\t}\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"CBS_HAS_RETURNED\")\n\t\treturn true\n\t}\n\n\t// 资源正常\n\tstartTime := beginBalanceRecord.LastBalanceTime\n\tendTime := endBalanceRecord.LastBalanceTime\n\tcurTime := startTime\n\tfor endTime.After(curTime) {\n\t\tcurHourEnd := time.Date(curTime.Year(), curTime.Month(), curTime.Day(), curTime.Hour(), 59, 59, 0, curTime.Location())\n\n\t\tvar config CCbsBalanceConfig\n\t\terr := json.Unmarshal([]byte(beginBalanceRecord.Config), &config)\n\t\tif err != nil {\n\t\t\tlogs.Error(cbsSrv.ctx).Err(err).Msg(\"PARSE_CONFIG_ERROR\")\n\t\t\treturn\n\t\t}\n\n\t\tcurEndTime := endTime\n\t\tcurStarTime := curTime\n\t\tif !endTime.After(curHourEnd) {\n\t\t\t// 同一周期\n\t\t\tcurTime = endTime.Add(time.Second)\n\t\t} else {\n\t\t\tcurEndTime = curHourEnd\n\t\t\tcurTime = curHourEnd.Add(time.Second)\n\t\t}\n\t\tsubItem := &SubItem{\n\t\t\tPid:       beginBalanceRecord.Pid,\n\t\t\tStartTime: curStarTime,\n\t\t\tEndTime:   curEndTime,\n\t\t\tProjectId: beginBalanceRecord.ProjectID,\n\t\t\tParams:    beginBalanceRecord.ResourceInfo,\n\t\t\tSubValueDetail: map[string]interface{}{\n\t\t\t\t// FIXME 性能突发场景待实现\n\t\t\t\t\"Size\":             config.Size,\n\t\t\t\t\"BackupPointQuota\": config.BackupPointQuota,\n\t\t\t},\n\t\t}\n\t\tchargeItem.Items = append(chargeItem.Items, subItem)\n\t}\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/adapter/db/ccdb/model.go",
        "code_start_line": 52,
        "code_end_line": 67,
        "code_key": "CCbs",
        "code_value": "type CCbs struct {\n\tCbsId              int64  `gorm:\"column:cbsId;primaryKey\"`\n\tAppId              int64  `gorm:\"column:appId\"`\n\tCbsInstanceId      string `gorm:\"column:cbsInstanceId\"`\n\tCbsUuid            string `gorm:\"column:cbsUuid\"`\n\tDiskSize           int    `gorm:\"column:diskSize\"`\n\tDiskType           string `gorm:\"column:diskType\"`\n\tLifeState          string `gorm:\"column:lifeState\"`\n\tStatus             int    `gorm:\"column:status\"`\n\tRollbacking        int    `gorm:\"column:rollbacking\"`\n\tRollbackingPercent int    `gorm:\"column:rollbackPercent\"`\n\tArchType           string `gorm:\"column:archType\"`\n\tAssigned           int    `gorm:\"column:assigned\"`\n\tAttached           int    `gorm:\"column:attached\"`\n\tPayMode            string `gorm:\"column:payMode\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/adapter/db/ccdb/model.go",
        "code_start_line": 69,
        "code_end_line": 71,
        "code_key": "TableName",
        "code_value": "func (CCbs) TableName() string {\n\treturn \"cCbs\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/db/ccdb/model.go",
        "code_start_line": 52,
        "code_end_line": 67,
        "code_key": "CCbs",
        "code_value": "type CCbs struct {\n\tCbsId              int64  `gorm:\"column:cbsId;primaryKey\"`\n\tAppId              int64  `gorm:\"column:appId\"`\n\tCbsInstanceId      string `gorm:\"column:cbsInstanceId\"`\n\tCbsUuid            string `gorm:\"column:cbsUuid\"`\n\tDiskSize           int    `gorm:\"column:diskSize\"`\n\tDiskType           string `gorm:\"column:diskType\"`\n\tLifeState          string `gorm:\"column:lifeState\"`\n\tStatus             int    `gorm:\"column:status\"`\n\tRollbacking        int    `gorm:\"column:rollbacking\"`\n\tRollbackingPercent int    `gorm:\"column:rollbackPercent\"`\n\tArchType           string `gorm:\"column:archType\"`\n\tAssigned           int    `gorm:\"column:assigned\"`\n\tAttached           int    `gorm:\"column:attached\"`\n\tPayMode            string `gorm:\"column:payMode\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/db/ccdb/model.go",
        "code_start_line": 69,
        "code_end_line": 71,
        "code_key": "TableName",
        "code_value": "func (CCbs) TableName() string {\n\treturn \"cCbs\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/ccdb/model.go",
        "code_start_line": 7,
        "code_end_line": 68,
        "code_key": "CCbs",
        "code_value": "type CCbs struct {\n\tID                 int64     `gorm:\"column:cbsId;primaryKey\"`\n\tAppID              int64     `gorm:\"column:appId\"`\n\tAlias              string    `gorm:\"column:alias\"`\n\tAssigned           int       `gorm:\"column:assigned\"`\n\tAttached           int       `gorm:\"column:attached\"`\n\tAutoRenewFlag      int       `gorm:\"column:autoRenewFlag\"`\n\tCbsInstanceID      string    `gorm:\"column:cbsInstanceId;uniuq_index\"`\n\tCbsSnap            int       `gorm:\"column:cbsSnap\"`\n\tCbsType            string    `gorm:\"column:cbsType\"`\n\tCbsUuid            string    `gorm:\"column:cbsUuid\"`\n\tDeadline           time.Time `gorm:\"column:deadline\"`\n\tDealID             int       `gorm:\"column:dealId\"`\n\tDealName           string    `gorm:\"column:dealName\"`\n\tDeviceID           int64     `gorm:\"column:deviceId\"`\n\tDiskSize           int       `gorm:\"column:diskSize\"`\n\tDiskType           string    `gorm:\"column:diskType\"`\n\tDom0Ip             string    `gorm:\"column:dom0Ip\"`\n\tFsType             string    `gorm:\"column:fsType\"`\n\tHostBlockSize      int       `gorm:\"column:hostBlockSize\"`\n\tLifeState          string    `gorm:\"column:lifeState\"`\n\tPath               string    `gorm:\"column:path\"`\n\tPayMode            string    `gorm:\"column:payMode\"`\n\tPortable           int       `gorm:\"column:portable\"`\n\tProjectID          int       `gorm:\"column:projectId\"`\n\tQcloudZone         int       `gorm:\"column:qcloudZone\"`\n\tStatus             int       `gorm:\"column:status\"`\n\tTarget             string    `gorm:\"column:target\"`\n\tTranID             string    `gorm:\"column:tranId\"`\n\tVmBlockSize        int       `gorm:\"column:vmBlockSize\"`\n\tVolumeType         string    `gorm:\"column:volumeType\"`\n\tZone               int       `gorm:\"column:zone\"`\n\tRollbacking        int       `gorm:\"column:rollbacking;default:0\"`\n\tRollbackPercent    int       `gorm:\"column:rollbackPercent;default:0\"`\n\tArchType           string    `gorm:\"column:archType\"`\n\tFlag               int       `gorm:\"column:flag;default:0\"`\n\tEncrypt            string    `gorm:\"column:encrypt\"`\n\tTransactionID      string    `gorm:\"column:transactionId\"`\n\tIsNewDisk          int       `gorm:\"column:isNewDisk;default:0\"`\n\tThroughValue       int       `gorm:\"column:throughValue\"`\n\tIopsValue          int       `gorm:\"column:iopsValue\"`\n\tDeleteWithInstance int       `gorm:\"column:deleteWithInstance\"`\n\tShareable          int       `gorm:\"column:shareable\"`\n\tOrderID            string    `gorm:\"column:orderId\"`\n\tCdcID              string    `gorm:\"column:cdcId\"`\n\tMigrating          int       `gorm:\"column:migrating\"`\n\tMigratePercent     int       `gorm:\"column:migratePercent\"`\n\tEncryptTime        time.Time `gorm:\"column:encryptTime\"`\n\tSnapshotSize       int       `gorm:\"column:snapshotSize\"`\n\tSnapshotCount      int       `gorm:\"column:snapshotCount\"`\n\tInsType            string    `gorm:\"column:insType\"`\n\tInsID              string    `gorm:\"column:insId\"`\n\tInsUuid            string    `gorm:\"column:insUuid\"`\n\tBackupMode         int       `gorm:\"column:backupMode\"`\n\tDeleteMode         string    `gorm:\"column:deleteMode\"`\n\tBackupQuota        int       `gorm:\"column:backupQuota\"`\n\tBackupCount        int       `gorm:\"column:backupCount\"`\n\tClusterGroupId     string    `gorm:\"column:clusterGroupId\"`\n\tOutpostID          string    `gorm:\"column:outpost_id\"`\n\tCreatedAt          time.Time `gorm:\"column:addTimeStamp;type:time\"`\n\tUpdatedAt          time.Time `gorm:\"column:modTimeStamp;type:time\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/ccdb/model.go",
        "code_start_line": 71,
        "code_end_line": 73,
        "code_key": "TableName",
        "code_value": "func (CCbs) TableName() string {\n\treturn \"cCbs\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/repositories/cbs.go:39:50:GetCbsBalanceRecords": {
    "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/repositories/cbs.go",
    "code_start_line": 39,
    "code_end_line": 50,
    "code_start_column": 32,
    "code_key": "GetCbsBalanceRecords",
    "code_value": "func (cbsRepo *CbsBalanceRepo) GetCbsBalanceRecords(ctx context.Context, resourceId string, chargeTime time.Time, includeInvalidRecord bool) ([]*ccdb.CCbsBalance, error) {\n\n\tvar cCbsBalances []*ccdb.CCbsBalance\n\tvar query *gorm.DB\n\tif !includeInvalidRecord {\n\t\tquery = cbsRepo.DB.Where(\"resourceId = ? and lastBalanceTime < ? and status = 1\", resourceId, chargeTime)\n\t} else {\n\t\tquery = cbsRepo.DB.Where(\"resourceId = ?\", resourceId)\n\t}\n\tquery.Find(&cCbsBalances)\n\treturn cCbsBalances, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/service.go",
        "code_start_line": 208,
        "code_end_line": 217,
        "code_key": "BuildResChargeItem",
        "code_value": "func (cbsSrv *CbsSrv) BuildResChargeItem(u *user.User, resourceId ResourceId, chargeTime time.Time) *ChargeItem {\n\tcbsMeasureRepo := cbsSrv.balanceRepo.(repositories.CbsBalanceRepoIFace)\n\tbalanceRecords, _ := cbsMeasureRepo.GetCbsBalanceRecords(cbsSrv.ctx, string(resourceId), chargeTime, false)\n\n\tif len(balanceRecords) == 0 {\n\t\treturn nil\n\t}\n\n\treturn cbsSrv.convertToChargeItem(u, resourceId, balanceRecords, chargeTime)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 133,
        "code_end_line": 236,
        "code_key": "BuildResChargeItem",
        "code_value": "func (snapSrv *SnapSrv) BuildResChargeItem(u *user.User, resourceId ResourceId, chargeTime time.Time) *ChargeItem {\n\t// 获取符合条件的balanceRecord并根据chargeTime排序\n\tbalanceRecords, _ := snapSrv.snapRepo.GetSnapBalanceRecords(snapSrv.ctx, string(resourceId), chargeTime)\n\n\t// FIXME 临时方案：用内存里的lastBalanceTime覆盖balanceRecords里的balanceTime\n\tfor _, balanceRecord := range balanceRecords {\n\t\tlastBalanceTime, ok := snapSrv.lastBalanceTimeCache[balanceRecord.ID]\n\t\tif ok {\n\t\t\tbalanceRecord.LastBalanceTime = lastBalanceTime\n\t\t}\n\t}\n\n\tif len(balanceRecords) == 0 {\n\t\treturn nil\n\t}\n\tsort.Slice(balanceRecords, func(i, j int) bool {\n\t\tif balanceRecords[i].LastBalanceTime.Equal(balanceRecords[j].LastBalanceTime) {\n\t\t\treturn balanceRecords[i].OperationType < balanceRecords[j].OperationType\n\t\t}\n\t\treturn balanceRecords[i].LastBalanceTime.Before(balanceRecords[j].LastBalanceTime)\n\t})\n\n\t// 区分国内站和国际站用户\n\tvar userArea Area\n\tif u.IsI18nUser() {\n\t\tuserArea = AreaI18n\n\t} else {\n\t\tuserArea = AreaChina\n\t}\n\tisGrayUser, err := u.CheckFeature(user.USER_FLAG_SNAP_GRAY_USER)\n\tif err != nil {\n\t\tlogs.Error(snapSrv.ctx).Err(err).Int64(\"appId\", int64(u.AppId)).Msg(\"CHECK_GRAY_USER_ERR\")\n\t\t// 出错时标记为非灰度用户，避免重复推量\n\t\tisGrayUser = false\n\t}\n\n\tchargeItem := &ChargeItem{\n\t\t// FIXME: 需要从配置文件中获取region id\n\t\tRegionId:     snapSrv.regionId,\n\t\tZoneId:       balanceRecords[0].ZoneID,\n\t\tAppId:        u.AppId,\n\t\tUin:          u.Uin,\n\t\tUserArea:     userArea,\n\t\tIsGrayUser:   isGrayUser,\n\t\tResourceId:   resourceId,\n\t\tResourceArea: snapSrv.regionArea,\n\t\tItems:        make([]*SubItem, 0, len(balanceRecords)),\n\t}\n\n\t// 虚拟计费条目，用于确定endBalanceTime\n\tendBalanceRecord := &ccdb.CSnapBalance{LastBalanceTime: chargeTime.Add(time.Second * -1)}\n\tallBalances := append(balanceRecords, endBalanceRecord)\n\n\tfor i, balanceRecord := range allBalances[1:] {\n\t\tbeginBalanceRecord := balanceRecords[i]\n\t\t// 资源欠费，不收取费用\n\t\tif beginBalanceRecord.OperationType == int(SnapOpArrearage) {\n\t\t\tlogs.Info(snapSrv.ctx).Uint64(\"appId\", uint64(u.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"RESOURCE_ARREARAGE\")\n\t\t\tcontinue\n\t\t}\n\t\t// 资源已退还。退还后还产生了计费条目，非期望行为\n\t\tif beginBalanceRecord.OperationType == int(SnapOpReturn) {\n\t\t\tlogs.Info(snapSrv.ctx).Uint64(\"appId\", uint64(u.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"SNAP_HAS_RETURNED\")\n\t\t\tbreak\n\t\t}\n\n\t\t// 资源正常\n\t\tstartTime := beginBalanceRecord.LastBalanceTime\n\t\tendTime := balanceRecord.LastBalanceTime\n\t\tcurTime := startTime\n\t\tfor endTime.After(curTime) {\n\t\t\tcurHourEnd := time.Date(curTime.Year(), curTime.Month(), curTime.Day(), curTime.Hour(), 59, 59, 0, curTime.Location())\n\t\t\tif !endTime.After(curHourEnd) {\n\t\t\t\t// 同一周期\n\t\t\t\tsubItem := &SubItem{\n\t\t\t\t\tPid:       PidSnap,\n\t\t\t\t\tStartTime: curTime,\n\t\t\t\t\tEndTime:   endTime,\n\t\t\t\t\tSubValueDetail: map[string]interface{}{\n\t\t\t\t\t\t\"Size\": beginBalanceRecord.SnapSize},\n\t\t\t\t}\n\t\t\t\tchargeItem.Items = append(chargeItem.Items, subItem)\n\t\t\t\tcurTime = endTime.Add(time.Second)\n\t\t\t} else {\n\t\t\t\t// 非同一周期，先构建这个周期的\n\t\t\t\tsubItem := &SubItem{\n\t\t\t\t\tStartTime: curTime,\n\t\t\t\t\tEndTime:   curHourEnd,\n\t\t\t\t\tSubValueDetail: map[string]interface{}{\n\t\t\t\t\t\t\"Size\": beginBalanceRecord.SnapSize,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\tchargeItem.Items = append(chargeItem.Items, subItem)\n\t\t\t\tcurTime = curHourEnd.Add(time.Second)\n\t\t\t}\n\n\t\t}\n\t}\n\tif len(chargeItem.Items) == 0 {\n\t\treturn nil\n\t}\n\n\treturn chargeItem\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 247,
        "code_end_line": 264,
        "code_key": "BuildResChargeItem",
        "code_value": "func (cbsSrv *CbsSrv) BuildResChargeItem(u *user.User, resourceId ResourceId, chargeTime time.Time) *ChargeItem {\n\tcbsMeasureRepo := cbsSrv.measureRepo.(CbsMeasureRepoIFace)\n\tbalanceRecords, _ := cbsMeasureRepo.GetCbsBalanceRecords(cbsSrv.ctx, string(resourceId), chargeTime, false)\n\n\t// FIXME 临时方案：用内存里的lastBalanceTime覆盖balanceRecords里的balanceTime\n\tfor _, balanceRecord := range balanceRecords {\n\t\tlastBalanceTime, ok := cbsSrv.lastBalanceTimeCache[balanceRecord.ID]\n\t\tif ok {\n\t\t\tbalanceRecord.LastBalanceTime = lastBalanceTime\n\t\t}\n\t}\n\n\tif len(balanceRecords) == 0 {\n\t\treturn nil\n\t}\n\n\treturn cbsSrv.convertToChargeItem(u, resourceId, balanceRecords, chargeTime)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/service.go",
        "code_start_line": 220,
        "code_end_line": 291,
        "code_key": "BuildResChargeItemForRepush",
        "code_value": "func (cbsSrv *CbsSrv) BuildResChargeItemForRepush(u *user.User, resourceId ResourceId, startTime time.Time, endTime time.Time) *ChargeItem {\n\t/*\n\t\t关于balanceRecords，目前有以下几个特殊逻辑：\n\t\t\t1. 多个balanceRecord之间是以lastBalanceTime作为时间片端点来处理的\n\t\t\t2. 在balanceRecord插入时，createTime和lastBalanceTime保持一致。这样就能够保证在处理balanceRecord时，新插入的和已经被更新\n\t\t       过的balanceRecord的处理是一致的\n\t\t所以在补量时，拉取到balanceRecord后，需要用createTime覆盖lastBalanceTime,这样才不会漏\n\t*/\n\tcbsMeasureRepo := cbsSrv.balanceRepo.(repositories.CbsBalanceRepoIFace)\n\tbalanceRecords, _ := cbsMeasureRepo.GetCbsBalanceRecords(cbsSrv.ctx, string(resourceId), time.Time{}, true)\n\n\t// 根据LastBalanceTime排序\n\tsort.Slice(balanceRecords, func(i, j int) bool {\n\t\tif balanceRecords[i].CreateTime.Equal(balanceRecords[j].CreateTime) {\n\t\t\treturn balanceRecords[i].OperationType < balanceRecords[j].OperationType\n\t\t}\n\t\treturn balanceRecords[i].CreateTime.Before(balanceRecords[j].CreateTime)\n\t})\n\n\t// 筛选出待补量的BalanceRecord\n\tif len(balanceRecords) == 0 {\n\t\treturn nil\n\t}\n\tif balanceRecords[0].CreateTime.After(endTime) {\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(u.AppId)).\n\t\t\tStr(\"resourceId\", string(resourceId)).\n\t\t\tMsg(\"NO_NEED_COMPENSATE\")\n\t\treturn nil\n\t}\n\n\t/*\n\t\t这里有点理解，主要思路如下：\n\t\t\t1. 如果发现CreateTime在endTime之后，直接break，后续全部不需要处理\n\t\t\t2. 如果CreateTime在startTime之前，则把这个计费记录的LastBalanceTime设置为startTime，作为第一个计费条目(左端点)\n\t\t\t3. 如果CreateTime在startTime之前且已经有第一个计费条目了，则替换前现有的第一个计费条目\n\t\t\t4. 不满足上述条件，则把这个计费记录的LastBalanceTime设置为startTime，添加到balanceRecordsToCompensate\n\n\t\t下面的实现依赖于balanceRecords已经按照CreateTime排序，所以只需要从头开始遍历balanceRecords即可。\n\t*/\n\tbalanceRecordsToRepush := make([]*ccdb.CCbsBalance, 0)\n\tfor _, curBalanceRecord := range balanceRecords {\n\t\t// CreateTime不在endTime之后，不需要关注了\n\t\tif !curBalanceRecord.CreateTime.Before(endTime) {\n\t\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(u.AppId)).\n\t\t\t\tStr(\"resourceId\", string(resourceId)).\n\t\t\t\tMsg(\"NO_NEED_REPUSH\")\n\t\t\tbreak\n\t\t}\n\n\t\tif len(balanceRecordsToRepush) == 0 {\n\t\t\tcurBalanceRecord.LastBalanceTime = curBalanceRecord.CreateTime\n\t\t\tbalanceRecordsToRepush = append(balanceRecordsToRepush, curBalanceRecord)\n\t\t} else if len(balanceRecordsToRepush) == 1 && !curBalanceRecord.CreateTime.After(startTime) {\n\t\t\t// 发现离startTime更近的计费记录，替换掉第一个\n\t\t\tcurBalanceRecord.LastBalanceTime = curBalanceRecord.CreateTime\n\t\t\tbalanceRecordsToRepush[0] = curBalanceRecord\n\t\t} else {\n\t\t\tcurBalanceRecord.LastBalanceTime = curBalanceRecord.CreateTime\n\t\t\tbalanceRecordsToRepush = append(balanceRecordsToRepush, curBalanceRecord)\n\t\t}\n\t\t// 开始计费时间不能超过startTime\n\t\tif curBalanceRecord.LastBalanceTime.Before(startTime) {\n\t\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(u.AppId)).Time(\"raw\", curBalanceRecord.LastBalanceTime).Time(\"new\", startTime).Msg(\"REPLACE_FIRST_BALANCE\")\n\t\t\tcurBalanceRecord.LastBalanceTime = startTime\n\t\t}\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(u.AppId)).Str(\"resourceId\", string(resourceId)).Time(\"lastBalance\", curBalanceRecord.LastBalanceTime).Msg(\"GET_NEW_BALANCE\")\n\n\t}\n\n\treturn cbsSrv.convertToChargeItem(u, resourceId, balanceRecordsToRepush, endTime)\n\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 267,
        "code_end_line": 338,
        "code_key": "BuildResChargeItemForRepush",
        "code_value": "func (cbsSrv *CbsSrv) BuildResChargeItemForRepush(u *user.User, resourceId ResourceId, startTime time.Time, endTime time.Time) *ChargeItem {\n\t/*\n\t\t关于balanceRecords，目前有以下几个特殊逻辑：\n\t\t\t1. 多个balanceRecord之间是以lastBalanceTime作为时间片端点来处理的\n\t\t\t2. 在balanceRecord插入时，createTime和lastBalanceTime保持一致。这样就能够保证在处理balanceRecord时，新插入的和已经被更新\n\t\t       过的balanceRecord的处理是一致的\n\t\t所以在补量时，拉取到balanceRecord后，需要用createTime覆盖lastBalanceTime,这样才不会漏\n\t*/\n\tcbsMeasureRepo := cbsSrv.measureRepo.(CbsMeasureRepoIFace)\n\tbalanceRecords, _ := cbsMeasureRepo.GetCbsBalanceRecords(cbsSrv.ctx, string(resourceId), time.Time{}, true)\n\n\t// 根据LastBalanceTime排序\n\tsort.Slice(balanceRecords, func(i, j int) bool {\n\t\tif balanceRecords[i].CreateTime.Equal(balanceRecords[j].CreateTime) {\n\t\t\treturn balanceRecords[i].OperationType < balanceRecords[j].OperationType\n\t\t}\n\t\treturn balanceRecords[i].CreateTime.Before(balanceRecords[j].CreateTime)\n\t})\n\n\t// 筛选出待补量的BalanceRecord\n\tif len(balanceRecords) == 0 {\n\t\treturn nil\n\t}\n\tif balanceRecords[0].CreateTime.After(endTime) {\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(u.AppId)).\n\t\t\tStr(\"resourceId\", string(resourceId)).\n\t\t\tMsg(\"NO_NEED_COMPENSATE\")\n\t\treturn nil\n\t}\n\n\t/*\n\t\t这里有点理解，主要思路如下：\n\t\t\t1. 如果发现CreateTime在endTime之后，直接break，后续全部不需要处理\n\t\t\t2. 如果CreateTime在startTime之前，则把这个计费记录的LastBalanceTime设置为startTime，作为第一个计费条目(左端点)\n\t\t\t3. 如果CreateTime在startTime之前且已经有第一个计费条目了，则替换前现有的第一个计费条目\n\t\t\t4. 不满足上述条件，则把这个计费记录的LastBalanceTime设置为startTime，添加到balanceRecordsToCompensate\n\n\t\t下面的实现依赖于balanceRecords已经按照CreateTime排序，所以只需要从头开始遍历balanceRecords即可。\n\t*/\n\tbalanceRecordsToRepush := make([]*ccdb.CCbsBalance, 0)\n\tfor _, curBalanceRecord := range balanceRecords {\n\t\t// CreateTime不在endTime之后，不需要关注了\n\t\tif !curBalanceRecord.CreateTime.Before(endTime) {\n\t\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(u.AppId)).\n\t\t\t\tStr(\"resourceId\", string(resourceId)).\n\t\t\t\tMsg(\"NO_NEED_REPUSH\")\n\t\t\tbreak\n\t\t}\n\n\t\tif len(balanceRecordsToRepush) == 0 {\n\t\t\tcurBalanceRecord.LastBalanceTime = curBalanceRecord.CreateTime\n\t\t\tbalanceRecordsToRepush = append(balanceRecordsToRepush, curBalanceRecord)\n\t\t} else if len(balanceRecordsToRepush) == 1 && !curBalanceRecord.CreateTime.After(startTime) {\n\t\t\t// 发现离startTime更近的计费记录，替换掉第一个\n\t\t\tcurBalanceRecord.LastBalanceTime = curBalanceRecord.CreateTime\n\t\t\tbalanceRecordsToRepush[0] = curBalanceRecord\n\t\t} else {\n\t\t\tcurBalanceRecord.LastBalanceTime = curBalanceRecord.CreateTime\n\t\t\tbalanceRecordsToRepush = append(balanceRecordsToRepush, curBalanceRecord)\n\t\t}\n\t\t// 开始计费时间不能超过startTime\n\t\tif curBalanceRecord.LastBalanceTime.Before(startTime) {\n\t\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(u.AppId)).Time(\"raw\", curBalanceRecord.LastBalanceTime).Time(\"new\", startTime).Msg(\"REPLACE_FIRST_BALANCE\")\n\t\t\tcurBalanceRecord.LastBalanceTime = startTime\n\t\t}\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(u.AppId)).Str(\"resourceId\", string(resourceId)).Time(\"lastBalance\", curBalanceRecord.LastBalanceTime).Msg(\"GET_NEW_BALANCE\")\n\n\t}\n\n\treturn cbsSrv.convertToChargeItem(u, resourceId, balanceRecordsToRepush, endTime)\n\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/adapter/db/ccdb/model.go",
        "code_start_line": 94,
        "code_end_line": 108,
        "code_key": "CCbsBalance",
        "code_value": "type CCbsBalance struct {\n\tID              int64     `gorm:\"column:id;primaryKey\"`\n\tAppID           int64     `gorm:\"column:appId\"`\n\tZoneID          int       `gorm:\"column:zoneId\"`\n\tPid             int       `gorm:\"column:pid\"`\n\tProjectID       int       `gorm:\"column:projectId;default:0\"`\n\tCid             int       `gorm:\"column:cid\"`\n\tConfig          string    `gorm:\"column:config\"`\n\tCreateTime      time.Time `gorm:\"column:createTime\"`\n\tLastBalanceTime time.Time `gorm:\"column:lastBalanceTime\"`\n\tOperationType   int       `gorm:\"column:operationType\"`\n\tResourceID      string    `gorm:\"column:resourceId;unique\"`\n\tResourceInfo    string    `gorm:\"column:resourceInfo\"`\n\tStatus          int       `gorm:\"column:status\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/adapter/db/ccdb/model.go",
        "code_start_line": 110,
        "code_end_line": 112,
        "code_key": "TableName",
        "code_value": "func (CCbsBalance) TableName() string {\n\treturn \"cCbsBalance\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/db/ccdb/model.go",
        "code_start_line": 94,
        "code_end_line": 108,
        "code_key": "CCbsBalance",
        "code_value": "type CCbsBalance struct {\n\tID              int64     `gorm:\"column:id;primaryKey\"`\n\tAppID           int64     `gorm:\"column:appId\"`\n\tZoneID          int       `gorm:\"column:zoneId\"`\n\tPid             int       `gorm:\"column:pid\"`\n\tProjectID       int       `gorm:\"column:projectId;default:0\"`\n\tCid             int       `gorm:\"column:cid\"`\n\tConfig          string    `gorm:\"column:config\"`\n\tCreateTime      time.Time `gorm:\"column:createTime\"`\n\tLastBalanceTime time.Time `gorm:\"column:lastBalanceTime\"`\n\tOperationType   int       `gorm:\"column:operationType\"`\n\tResourceID      string    `gorm:\"column:resourceId;unique\"`\n\tResourceInfo    string    `gorm:\"column:resourceInfo\"`\n\tStatus          int       `gorm:\"column:status\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/db/ccdb/model.go",
        "code_start_line": 110,
        "code_end_line": 112,
        "code_key": "TableName",
        "code_value": "func (CCbsBalance) TableName() string {\n\treturn \"cCbsBalance\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/measure.go:188:203:GetCbsBalanceRecords": {
    "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/measure.go",
    "code_start_line": 188,
    "code_end_line": 203,
    "code_start_column": 32,
    "code_key": "GetCbsBalanceRecords",
    "code_value": "func (cbsRepo *CbsMeasureRepo) GetCbsBalanceRecords(ctx context.Context, resourceId string, chargeTime time.Time, includeInvalidRecord bool) ([]*ccdb.CCbsBalance, error) {\n\tdb, err := cbsRepo.getCCDBDb(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar cCbsBalances []*ccdb.CCbsBalance\n\tvar query *gorm.DB\n\tif !includeInvalidRecord {\n\t\tquery = db.Where(\"resourceId = ? and lastBalanceTime < ? and status = 1\", resourceId, chargeTime)\n\t} else {\n\t\tquery = db.Where(\"resourceId = ?\", resourceId)\n\t}\n\tquery.Find(&cCbsBalances)\n\treturn cCbsBalances, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/service.go",
        "code_start_line": 208,
        "code_end_line": 217,
        "code_key": "BuildResChargeItem",
        "code_value": "func (cbsSrv *CbsSrv) BuildResChargeItem(u *user.User, resourceId ResourceId, chargeTime time.Time) *ChargeItem {\n\tcbsMeasureRepo := cbsSrv.balanceRepo.(repositories.CbsBalanceRepoIFace)\n\tbalanceRecords, _ := cbsMeasureRepo.GetCbsBalanceRecords(cbsSrv.ctx, string(resourceId), chargeTime, false)\n\n\tif len(balanceRecords) == 0 {\n\t\treturn nil\n\t}\n\n\treturn cbsSrv.convertToChargeItem(u, resourceId, balanceRecords, chargeTime)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 133,
        "code_end_line": 236,
        "code_key": "BuildResChargeItem",
        "code_value": "func (snapSrv *SnapSrv) BuildResChargeItem(u *user.User, resourceId ResourceId, chargeTime time.Time) *ChargeItem {\n\t// 获取符合条件的balanceRecord并根据chargeTime排序\n\tbalanceRecords, _ := snapSrv.snapRepo.GetSnapBalanceRecords(snapSrv.ctx, string(resourceId), chargeTime)\n\n\t// FIXME 临时方案：用内存里的lastBalanceTime覆盖balanceRecords里的balanceTime\n\tfor _, balanceRecord := range balanceRecords {\n\t\tlastBalanceTime, ok := snapSrv.lastBalanceTimeCache[balanceRecord.ID]\n\t\tif ok {\n\t\t\tbalanceRecord.LastBalanceTime = lastBalanceTime\n\t\t}\n\t}\n\n\tif len(balanceRecords) == 0 {\n\t\treturn nil\n\t}\n\tsort.Slice(balanceRecords, func(i, j int) bool {\n\t\tif balanceRecords[i].LastBalanceTime.Equal(balanceRecords[j].LastBalanceTime) {\n\t\t\treturn balanceRecords[i].OperationType < balanceRecords[j].OperationType\n\t\t}\n\t\treturn balanceRecords[i].LastBalanceTime.Before(balanceRecords[j].LastBalanceTime)\n\t})\n\n\t// 区分国内站和国际站用户\n\tvar userArea Area\n\tif u.IsI18nUser() {\n\t\tuserArea = AreaI18n\n\t} else {\n\t\tuserArea = AreaChina\n\t}\n\tisGrayUser, err := u.CheckFeature(user.USER_FLAG_SNAP_GRAY_USER)\n\tif err != nil {\n\t\tlogs.Error(snapSrv.ctx).Err(err).Int64(\"appId\", int64(u.AppId)).Msg(\"CHECK_GRAY_USER_ERR\")\n\t\t// 出错时标记为非灰度用户，避免重复推量\n\t\tisGrayUser = false\n\t}\n\n\tchargeItem := &ChargeItem{\n\t\t// FIXME: 需要从配置文件中获取region id\n\t\tRegionId:     snapSrv.regionId,\n\t\tZoneId:       balanceRecords[0].ZoneID,\n\t\tAppId:        u.AppId,\n\t\tUin:          u.Uin,\n\t\tUserArea:     userArea,\n\t\tIsGrayUser:   isGrayUser,\n\t\tResourceId:   resourceId,\n\t\tResourceArea: snapSrv.regionArea,\n\t\tItems:        make([]*SubItem, 0, len(balanceRecords)),\n\t}\n\n\t// 虚拟计费条目，用于确定endBalanceTime\n\tendBalanceRecord := &ccdb.CSnapBalance{LastBalanceTime: chargeTime.Add(time.Second * -1)}\n\tallBalances := append(balanceRecords, endBalanceRecord)\n\n\tfor i, balanceRecord := range allBalances[1:] {\n\t\tbeginBalanceRecord := balanceRecords[i]\n\t\t// 资源欠费，不收取费用\n\t\tif beginBalanceRecord.OperationType == int(SnapOpArrearage) {\n\t\t\tlogs.Info(snapSrv.ctx).Uint64(\"appId\", uint64(u.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"RESOURCE_ARREARAGE\")\n\t\t\tcontinue\n\t\t}\n\t\t// 资源已退还。退还后还产生了计费条目，非期望行为\n\t\tif beginBalanceRecord.OperationType == int(SnapOpReturn) {\n\t\t\tlogs.Info(snapSrv.ctx).Uint64(\"appId\", uint64(u.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"SNAP_HAS_RETURNED\")\n\t\t\tbreak\n\t\t}\n\n\t\t// 资源正常\n\t\tstartTime := beginBalanceRecord.LastBalanceTime\n\t\tendTime := balanceRecord.LastBalanceTime\n\t\tcurTime := startTime\n\t\tfor endTime.After(curTime) {\n\t\t\tcurHourEnd := time.Date(curTime.Year(), curTime.Month(), curTime.Day(), curTime.Hour(), 59, 59, 0, curTime.Location())\n\t\t\tif !endTime.After(curHourEnd) {\n\t\t\t\t// 同一周期\n\t\t\t\tsubItem := &SubItem{\n\t\t\t\t\tPid:       PidSnap,\n\t\t\t\t\tStartTime: curTime,\n\t\t\t\t\tEndTime:   endTime,\n\t\t\t\t\tSubValueDetail: map[string]interface{}{\n\t\t\t\t\t\t\"Size\": beginBalanceRecord.SnapSize},\n\t\t\t\t}\n\t\t\t\tchargeItem.Items = append(chargeItem.Items, subItem)\n\t\t\t\tcurTime = endTime.Add(time.Second)\n\t\t\t} else {\n\t\t\t\t// 非同一周期，先构建这个周期的\n\t\t\t\tsubItem := &SubItem{\n\t\t\t\t\tStartTime: curTime,\n\t\t\t\t\tEndTime:   curHourEnd,\n\t\t\t\t\tSubValueDetail: map[string]interface{}{\n\t\t\t\t\t\t\"Size\": beginBalanceRecord.SnapSize,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\tchargeItem.Items = append(chargeItem.Items, subItem)\n\t\t\t\tcurTime = curHourEnd.Add(time.Second)\n\t\t\t}\n\n\t\t}\n\t}\n\tif len(chargeItem.Items) == 0 {\n\t\treturn nil\n\t}\n\n\treturn chargeItem\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 247,
        "code_end_line": 264,
        "code_key": "BuildResChargeItem",
        "code_value": "func (cbsSrv *CbsSrv) BuildResChargeItem(u *user.User, resourceId ResourceId, chargeTime time.Time) *ChargeItem {\n\tcbsMeasureRepo := cbsSrv.measureRepo.(CbsMeasureRepoIFace)\n\tbalanceRecords, _ := cbsMeasureRepo.GetCbsBalanceRecords(cbsSrv.ctx, string(resourceId), chargeTime, false)\n\n\t// FIXME 临时方案：用内存里的lastBalanceTime覆盖balanceRecords里的balanceTime\n\tfor _, balanceRecord := range balanceRecords {\n\t\tlastBalanceTime, ok := cbsSrv.lastBalanceTimeCache[balanceRecord.ID]\n\t\tif ok {\n\t\t\tbalanceRecord.LastBalanceTime = lastBalanceTime\n\t\t}\n\t}\n\n\tif len(balanceRecords) == 0 {\n\t\treturn nil\n\t}\n\n\treturn cbsSrv.convertToChargeItem(u, resourceId, balanceRecords, chargeTime)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/service.go",
        "code_start_line": 220,
        "code_end_line": 291,
        "code_key": "BuildResChargeItemForRepush",
        "code_value": "func (cbsSrv *CbsSrv) BuildResChargeItemForRepush(u *user.User, resourceId ResourceId, startTime time.Time, endTime time.Time) *ChargeItem {\n\t/*\n\t\t关于balanceRecords，目前有以下几个特殊逻辑：\n\t\t\t1. 多个balanceRecord之间是以lastBalanceTime作为时间片端点来处理的\n\t\t\t2. 在balanceRecord插入时，createTime和lastBalanceTime保持一致。这样就能够保证在处理balanceRecord时，新插入的和已经被更新\n\t\t       过的balanceRecord的处理是一致的\n\t\t所以在补量时，拉取到balanceRecord后，需要用createTime覆盖lastBalanceTime,这样才不会漏\n\t*/\n\tcbsMeasureRepo := cbsSrv.balanceRepo.(repositories.CbsBalanceRepoIFace)\n\tbalanceRecords, _ := cbsMeasureRepo.GetCbsBalanceRecords(cbsSrv.ctx, string(resourceId), time.Time{}, true)\n\n\t// 根据LastBalanceTime排序\n\tsort.Slice(balanceRecords, func(i, j int) bool {\n\t\tif balanceRecords[i].CreateTime.Equal(balanceRecords[j].CreateTime) {\n\t\t\treturn balanceRecords[i].OperationType < balanceRecords[j].OperationType\n\t\t}\n\t\treturn balanceRecords[i].CreateTime.Before(balanceRecords[j].CreateTime)\n\t})\n\n\t// 筛选出待补量的BalanceRecord\n\tif len(balanceRecords) == 0 {\n\t\treturn nil\n\t}\n\tif balanceRecords[0].CreateTime.After(endTime) {\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(u.AppId)).\n\t\t\tStr(\"resourceId\", string(resourceId)).\n\t\t\tMsg(\"NO_NEED_COMPENSATE\")\n\t\treturn nil\n\t}\n\n\t/*\n\t\t这里有点理解，主要思路如下：\n\t\t\t1. 如果发现CreateTime在endTime之后，直接break，后续全部不需要处理\n\t\t\t2. 如果CreateTime在startTime之前，则把这个计费记录的LastBalanceTime设置为startTime，作为第一个计费条目(左端点)\n\t\t\t3. 如果CreateTime在startTime之前且已经有第一个计费条目了，则替换前现有的第一个计费条目\n\t\t\t4. 不满足上述条件，则把这个计费记录的LastBalanceTime设置为startTime，添加到balanceRecordsToCompensate\n\n\t\t下面的实现依赖于balanceRecords已经按照CreateTime排序，所以只需要从头开始遍历balanceRecords即可。\n\t*/\n\tbalanceRecordsToRepush := make([]*ccdb.CCbsBalance, 0)\n\tfor _, curBalanceRecord := range balanceRecords {\n\t\t// CreateTime不在endTime之后，不需要关注了\n\t\tif !curBalanceRecord.CreateTime.Before(endTime) {\n\t\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(u.AppId)).\n\t\t\t\tStr(\"resourceId\", string(resourceId)).\n\t\t\t\tMsg(\"NO_NEED_REPUSH\")\n\t\t\tbreak\n\t\t}\n\n\t\tif len(balanceRecordsToRepush) == 0 {\n\t\t\tcurBalanceRecord.LastBalanceTime = curBalanceRecord.CreateTime\n\t\t\tbalanceRecordsToRepush = append(balanceRecordsToRepush, curBalanceRecord)\n\t\t} else if len(balanceRecordsToRepush) == 1 && !curBalanceRecord.CreateTime.After(startTime) {\n\t\t\t// 发现离startTime更近的计费记录，替换掉第一个\n\t\t\tcurBalanceRecord.LastBalanceTime = curBalanceRecord.CreateTime\n\t\t\tbalanceRecordsToRepush[0] = curBalanceRecord\n\t\t} else {\n\t\t\tcurBalanceRecord.LastBalanceTime = curBalanceRecord.CreateTime\n\t\t\tbalanceRecordsToRepush = append(balanceRecordsToRepush, curBalanceRecord)\n\t\t}\n\t\t// 开始计费时间不能超过startTime\n\t\tif curBalanceRecord.LastBalanceTime.Before(startTime) {\n\t\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(u.AppId)).Time(\"raw\", curBalanceRecord.LastBalanceTime).Time(\"new\", startTime).Msg(\"REPLACE_FIRST_BALANCE\")\n\t\t\tcurBalanceRecord.LastBalanceTime = startTime\n\t\t}\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(u.AppId)).Str(\"resourceId\", string(resourceId)).Time(\"lastBalance\", curBalanceRecord.LastBalanceTime).Msg(\"GET_NEW_BALANCE\")\n\n\t}\n\n\treturn cbsSrv.convertToChargeItem(u, resourceId, balanceRecordsToRepush, endTime)\n\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 267,
        "code_end_line": 338,
        "code_key": "BuildResChargeItemForRepush",
        "code_value": "func (cbsSrv *CbsSrv) BuildResChargeItemForRepush(u *user.User, resourceId ResourceId, startTime time.Time, endTime time.Time) *ChargeItem {\n\t/*\n\t\t关于balanceRecords，目前有以下几个特殊逻辑：\n\t\t\t1. 多个balanceRecord之间是以lastBalanceTime作为时间片端点来处理的\n\t\t\t2. 在balanceRecord插入时，createTime和lastBalanceTime保持一致。这样就能够保证在处理balanceRecord时，新插入的和已经被更新\n\t\t       过的balanceRecord的处理是一致的\n\t\t所以在补量时，拉取到balanceRecord后，需要用createTime覆盖lastBalanceTime,这样才不会漏\n\t*/\n\tcbsMeasureRepo := cbsSrv.measureRepo.(CbsMeasureRepoIFace)\n\tbalanceRecords, _ := cbsMeasureRepo.GetCbsBalanceRecords(cbsSrv.ctx, string(resourceId), time.Time{}, true)\n\n\t// 根据LastBalanceTime排序\n\tsort.Slice(balanceRecords, func(i, j int) bool {\n\t\tif balanceRecords[i].CreateTime.Equal(balanceRecords[j].CreateTime) {\n\t\t\treturn balanceRecords[i].OperationType < balanceRecords[j].OperationType\n\t\t}\n\t\treturn balanceRecords[i].CreateTime.Before(balanceRecords[j].CreateTime)\n\t})\n\n\t// 筛选出待补量的BalanceRecord\n\tif len(balanceRecords) == 0 {\n\t\treturn nil\n\t}\n\tif balanceRecords[0].CreateTime.After(endTime) {\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(u.AppId)).\n\t\t\tStr(\"resourceId\", string(resourceId)).\n\t\t\tMsg(\"NO_NEED_COMPENSATE\")\n\t\treturn nil\n\t}\n\n\t/*\n\t\t这里有点理解，主要思路如下：\n\t\t\t1. 如果发现CreateTime在endTime之后，直接break，后续全部不需要处理\n\t\t\t2. 如果CreateTime在startTime之前，则把这个计费记录的LastBalanceTime设置为startTime，作为第一个计费条目(左端点)\n\t\t\t3. 如果CreateTime在startTime之前且已经有第一个计费条目了，则替换前现有的第一个计费条目\n\t\t\t4. 不满足上述条件，则把这个计费记录的LastBalanceTime设置为startTime，添加到balanceRecordsToCompensate\n\n\t\t下面的实现依赖于balanceRecords已经按照CreateTime排序，所以只需要从头开始遍历balanceRecords即可。\n\t*/\n\tbalanceRecordsToRepush := make([]*ccdb.CCbsBalance, 0)\n\tfor _, curBalanceRecord := range balanceRecords {\n\t\t// CreateTime不在endTime之后，不需要关注了\n\t\tif !curBalanceRecord.CreateTime.Before(endTime) {\n\t\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(u.AppId)).\n\t\t\t\tStr(\"resourceId\", string(resourceId)).\n\t\t\t\tMsg(\"NO_NEED_REPUSH\")\n\t\t\tbreak\n\t\t}\n\n\t\tif len(balanceRecordsToRepush) == 0 {\n\t\t\tcurBalanceRecord.LastBalanceTime = curBalanceRecord.CreateTime\n\t\t\tbalanceRecordsToRepush = append(balanceRecordsToRepush, curBalanceRecord)\n\t\t} else if len(balanceRecordsToRepush) == 1 && !curBalanceRecord.CreateTime.After(startTime) {\n\t\t\t// 发现离startTime更近的计费记录，替换掉第一个\n\t\t\tcurBalanceRecord.LastBalanceTime = curBalanceRecord.CreateTime\n\t\t\tbalanceRecordsToRepush[0] = curBalanceRecord\n\t\t} else {\n\t\t\tcurBalanceRecord.LastBalanceTime = curBalanceRecord.CreateTime\n\t\t\tbalanceRecordsToRepush = append(balanceRecordsToRepush, curBalanceRecord)\n\t\t}\n\t\t// 开始计费时间不能超过startTime\n\t\tif curBalanceRecord.LastBalanceTime.Before(startTime) {\n\t\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(u.AppId)).Time(\"raw\", curBalanceRecord.LastBalanceTime).Time(\"new\", startTime).Msg(\"REPLACE_FIRST_BALANCE\")\n\t\t\tcurBalanceRecord.LastBalanceTime = startTime\n\t\t}\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(u.AppId)).Str(\"resourceId\", string(resourceId)).Time(\"lastBalance\", curBalanceRecord.LastBalanceTime).Msg(\"GET_NEW_BALANCE\")\n\n\t}\n\n\treturn cbsSrv.convertToChargeItem(u, resourceId, balanceRecordsToRepush, endTime)\n\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/adapter/db/ccdb/model.go",
        "code_start_line": 94,
        "code_end_line": 108,
        "code_key": "CCbsBalance",
        "code_value": "type CCbsBalance struct {\n\tID              int64     `gorm:\"column:id;primaryKey\"`\n\tAppID           int64     `gorm:\"column:appId\"`\n\tZoneID          int       `gorm:\"column:zoneId\"`\n\tPid             int       `gorm:\"column:pid\"`\n\tProjectID       int       `gorm:\"column:projectId;default:0\"`\n\tCid             int       `gorm:\"column:cid\"`\n\tConfig          string    `gorm:\"column:config\"`\n\tCreateTime      time.Time `gorm:\"column:createTime\"`\n\tLastBalanceTime time.Time `gorm:\"column:lastBalanceTime\"`\n\tOperationType   int       `gorm:\"column:operationType\"`\n\tResourceID      string    `gorm:\"column:resourceId;unique\"`\n\tResourceInfo    string    `gorm:\"column:resourceInfo\"`\n\tStatus          int       `gorm:\"column:status\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/adapter/db/ccdb/model.go",
        "code_start_line": 110,
        "code_end_line": 112,
        "code_key": "TableName",
        "code_value": "func (CCbsBalance) TableName() string {\n\treturn \"cCbsBalance\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/db/ccdb/model.go",
        "code_start_line": 94,
        "code_end_line": 108,
        "code_key": "CCbsBalance",
        "code_value": "type CCbsBalance struct {\n\tID              int64     `gorm:\"column:id;primaryKey\"`\n\tAppID           int64     `gorm:\"column:appId\"`\n\tZoneID          int       `gorm:\"column:zoneId\"`\n\tPid             int       `gorm:\"column:pid\"`\n\tProjectID       int       `gorm:\"column:projectId;default:0\"`\n\tCid             int       `gorm:\"column:cid\"`\n\tConfig          string    `gorm:\"column:config\"`\n\tCreateTime      time.Time `gorm:\"column:createTime\"`\n\tLastBalanceTime time.Time `gorm:\"column:lastBalanceTime\"`\n\tOperationType   int       `gorm:\"column:operationType\"`\n\tResourceID      string    `gorm:\"column:resourceId;unique\"`\n\tResourceInfo    string    `gorm:\"column:resourceInfo\"`\n\tStatus          int       `gorm:\"column:status\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/db/ccdb/model.go",
        "code_start_line": 110,
        "code_end_line": 112,
        "code_key": "TableName",
        "code_value": "func (CCbsBalance) TableName() string {\n\treturn \"cCbsBalance\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/repositories/base.go:33:46:GetResourceIdsByAppId": {
    "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/repositories/base.go",
    "code_start_line": 33,
    "code_end_line": 46,
    "code_start_column": 26,
    "code_key": "GetResourceIdsByAppId",
    "code_value": "func (repo *BalanceRepo) GetResourceIdsByAppId(ctx context.Context, appId int64, chargeTime time.Time, includeInvalidRes bool, tableName string) ([]string, error) {\n\t// includeInvalidRes为true时，返回所有资源, 目前用在补量场景\n\tvar resourceIds []string\n\t// FIXME 这里是获取到已经被python更新过的balance，临时兼容使用\n\tquery := repo.DB.Table(tableName).Distinct(\"resourceId\")\n\tif !includeInvalidRes {\n\t\tquery = query.Where(\"appId = ? and status = 1 and lastBalanceTime <= ? \", appId, chargeTime)\n\t} else {\n\t\tquery = query.Where(\"appId = ?\", appId)\n\t}\n\tquery.Pluck(\"resourceId\", &resourceIds)\n\n\treturn resourceIds, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/service.go",
        "code_start_line": 71,
        "code_end_line": 78,
        "code_key": "GetValidResourceIdsByAppId",
        "code_value": "func (srv *BaseResSrv) GetValidResourceIdsByAppId(appId user.AppId, chargeTime time.Time) []ResourceId {\n\tids, _ := srv.balanceRepo.GetResourceIdsByAppId(srv.ctx, int64(appId), chargeTime, false, srv.balanceRepo.GetBalanceTableName())\n\tredIds := make([]ResourceId, len(ids))\n\tfor i, resId := range ids {\n\t\tredIds[i] = ResourceId(resId)\n\t}\n\treturn redIds\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 82,
        "code_end_line": 89,
        "code_key": "GetValidResourceIdsByAppId",
        "code_value": "func (srv *BaseResSrv) GetValidResourceIdsByAppId(appId user.AppId, chargeTime time.Time) []ResourceId {\n\tids, _ := srv.measureRepo.GetResourceIdsByAppId(srv.ctx, int64(appId), chargeTime, false, srv.measureRepo.GetBalanceTableName())\n\tredIds := make([]ResourceId, len(ids))\n\tfor i, snapId := range ids {\n\t\tredIds[i] = ResourceId(snapId)\n\t}\n\treturn redIds\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/repush_user_billing_task.go",
        "code_start_line": 103,
        "code_end_line": 172,
        "code_key": "ProcessSingleRepushDetail",
        "code_value": "func (t *RepushUserBillingTask) ProcessSingleRepushDetail(detail *measure.RepushDetail) error {\n\tcbsMeasureRepo := registry.GetRegistry(t.ctx).AdapterRepos.CbsMeasureRepo.(measure.CbsMeasureRepoIFace)\n\tappIdResIdMaps := make(map[user.AppId][]measure.ResourceId)\n\tif detail.AppId > 0 {\n\t\tif len(detail.ResIds) > 0 {\n\t\t\tappIdResIdMaps[detail.AppId] = detail.ResIds\n\t\t} else {\n\t\t\tids, err := cbsMeasureRepo.GetResourceIdsByAppId(t.ctx, int64(detail.AppId), time.Time{}, true, cbsMeasureRepo.GetBalanceTableName())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tresIds := make([]measure.ResourceId, 0, len(ids))\n\t\t\tfor _, resId := range ids {\n\t\t\t\tresIds = append(resIds, measure.ResourceId(resId))\n\t\t\t}\n\t\t\tappIdResIdMaps[detail.AppId] = resIds\n\t\t}\n\t} else {\n\t\tif len(detail.ResIds) > 0 {\n\t\t\treturn fmt.Errorf(\"AppId is required when ResIds is set\")\n\t\t}\n\t\tlogs.Info(t.ctx).Msg(\"REPUSH_ALL_FOR_APPID_NOT_SET\")\n\t\tappIds, _ := cbsMeasureRepo.GetAppIdsWithResources(t.ctx, time.Time{}, true, cbsMeasureRepo.GetBalanceTableName())\n\t\tfor _, appId := range appIds {\n\t\t\t// 没有指定资源，则补量所有资源\n\t\t\tids, err := cbsMeasureRepo.GetResourceIdsByAppId(t.ctx, appId, time.Time{}, true, cbsMeasureRepo.GetBalanceTableName())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tresIds := make([]measure.ResourceId, 0, len(ids))\n\t\t\tfor _, resId := range ids {\n\t\t\t\tresIds = append(resIds, measure.ResourceId(resId))\n\t\t\t}\n\t\t\tappIdResIdMaps[user.AppId(appId)] = resIds\n\t\t}\n\n\t}\n\n\tvar repushItems []*RepushItem\n\tfor appId, resIds := range appIdResIdMaps {\n\t\tu, err := t.userSrv.GetUser(appId)\n\t\tif err != nil {\n\t\t\t// 这里可能是新注册的用户，user表里没有用户数据，可能会丢失该用户的量\n\t\t\tlogs.Error(t.ctx).Err(err).Uint64(\"appId\", uint64(appId)).Msg(\"GET_USER_ERROR\")\n\t\t\tpanic(err)\n\t\t}\n\t\tfor _, resId := range resIds {\n\t\t\tvar repushItem RepushItem\n\t\t\trepushItem.user = u\n\t\t\trepushItem.cbsInstanceId = resId\n\t\t\trepushItem.startTime = detail.StartTime\n\t\t\trepushItem.endTime = detail.EndTime\n\t\t\trepushItems = append(repushItems, &repushItem)\n\t\t}\n\t}\n\tlogs.Info(t.ctx).Int(\"count\", len(repushItems)).Msg(\"REPUSH_ITEMS_INFO\")\n\n\tvar wg sync.WaitGroup\n\tfor _, repushItem := range repushItems {\n\t\twg.Add(1)\n\t\tt.semaphore <- struct{}{}\n\t\tgo func(item *RepushItem) {\n\t\t\tdefer wg.Done()\n\t\t\tdefer func() { <-t.semaphore }()\n\t\t\tt.ProcessSingleRepushItem(item)\n\t\t}(repushItem)\n\t}\n\twg.Wait()\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": []
  },
  "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/measure.go:46:64:GetResourceIdsByAppId": {
    "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/measure.go",
    "code_start_line": 46,
    "code_end_line": 64,
    "code_start_column": 26,
    "code_key": "GetResourceIdsByAppId",
    "code_value": "func (repo *MeasureRepo) GetResourceIdsByAppId(ctx context.Context, appId int64, chargeTime time.Time, includeInvalidRes bool, tableName string) ([]string, error) {\n\t// includeInvalidRes为true时，返回所有资源, 目前用在补量场景\n\tdb, err := repo.getCCDBDb(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar resourceIds []string\n\t// FIXME 这里是获取到已经被python更新过的balance，临时兼容使用\n\tquery := db.Table(tableName).Distinct(\"resourceId\")\n\tif !includeInvalidRes {\n\t\tquery = query.Where(\"appId = ? and status = 1 and lastBalanceTime <= ? \", appId, chargeTime)\n\t} else {\n\t\tquery = query.Where(\"appId = ?\", appId)\n\t}\n\tquery.Pluck(\"resourceId\", &resourceIds)\n\n\treturn resourceIds, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/service.go",
        "code_start_line": 71,
        "code_end_line": 78,
        "code_key": "GetValidResourceIdsByAppId",
        "code_value": "func (srv *BaseResSrv) GetValidResourceIdsByAppId(appId user.AppId, chargeTime time.Time) []ResourceId {\n\tids, _ := srv.balanceRepo.GetResourceIdsByAppId(srv.ctx, int64(appId), chargeTime, false, srv.balanceRepo.GetBalanceTableName())\n\tredIds := make([]ResourceId, len(ids))\n\tfor i, resId := range ids {\n\t\tredIds[i] = ResourceId(resId)\n\t}\n\treturn redIds\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 82,
        "code_end_line": 89,
        "code_key": "GetValidResourceIdsByAppId",
        "code_value": "func (srv *BaseResSrv) GetValidResourceIdsByAppId(appId user.AppId, chargeTime time.Time) []ResourceId {\n\tids, _ := srv.measureRepo.GetResourceIdsByAppId(srv.ctx, int64(appId), chargeTime, false, srv.measureRepo.GetBalanceTableName())\n\tredIds := make([]ResourceId, len(ids))\n\tfor i, snapId := range ids {\n\t\tredIds[i] = ResourceId(snapId)\n\t}\n\treturn redIds\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/repush_user_billing_task.go",
        "code_start_line": 103,
        "code_end_line": 172,
        "code_key": "ProcessSingleRepushDetail",
        "code_value": "func (t *RepushUserBillingTask) ProcessSingleRepushDetail(detail *measure.RepushDetail) error {\n\tcbsMeasureRepo := registry.GetRegistry(t.ctx).AdapterRepos.CbsMeasureRepo.(measure.CbsMeasureRepoIFace)\n\tappIdResIdMaps := make(map[user.AppId][]measure.ResourceId)\n\tif detail.AppId > 0 {\n\t\tif len(detail.ResIds) > 0 {\n\t\t\tappIdResIdMaps[detail.AppId] = detail.ResIds\n\t\t} else {\n\t\t\tids, err := cbsMeasureRepo.GetResourceIdsByAppId(t.ctx, int64(detail.AppId), time.Time{}, true, cbsMeasureRepo.GetBalanceTableName())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tresIds := make([]measure.ResourceId, 0, len(ids))\n\t\t\tfor _, resId := range ids {\n\t\t\t\tresIds = append(resIds, measure.ResourceId(resId))\n\t\t\t}\n\t\t\tappIdResIdMaps[detail.AppId] = resIds\n\t\t}\n\t} else {\n\t\tif len(detail.ResIds) > 0 {\n\t\t\treturn fmt.Errorf(\"AppId is required when ResIds is set\")\n\t\t}\n\t\tlogs.Info(t.ctx).Msg(\"REPUSH_ALL_FOR_APPID_NOT_SET\")\n\t\tappIds, _ := cbsMeasureRepo.GetAppIdsWithResources(t.ctx, time.Time{}, true, cbsMeasureRepo.GetBalanceTableName())\n\t\tfor _, appId := range appIds {\n\t\t\t// 没有指定资源，则补量所有资源\n\t\t\tids, err := cbsMeasureRepo.GetResourceIdsByAppId(t.ctx, appId, time.Time{}, true, cbsMeasureRepo.GetBalanceTableName())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tresIds := make([]measure.ResourceId, 0, len(ids))\n\t\t\tfor _, resId := range ids {\n\t\t\t\tresIds = append(resIds, measure.ResourceId(resId))\n\t\t\t}\n\t\t\tappIdResIdMaps[user.AppId(appId)] = resIds\n\t\t}\n\n\t}\n\n\tvar repushItems []*RepushItem\n\tfor appId, resIds := range appIdResIdMaps {\n\t\tu, err := t.userSrv.GetUser(appId)\n\t\tif err != nil {\n\t\t\t// 这里可能是新注册的用户，user表里没有用户数据，可能会丢失该用户的量\n\t\t\tlogs.Error(t.ctx).Err(err).Uint64(\"appId\", uint64(appId)).Msg(\"GET_USER_ERROR\")\n\t\t\tpanic(err)\n\t\t}\n\t\tfor _, resId := range resIds {\n\t\t\tvar repushItem RepushItem\n\t\t\trepushItem.user = u\n\t\t\trepushItem.cbsInstanceId = resId\n\t\t\trepushItem.startTime = detail.StartTime\n\t\t\trepushItem.endTime = detail.EndTime\n\t\t\trepushItems = append(repushItems, &repushItem)\n\t\t}\n\t}\n\tlogs.Info(t.ctx).Int(\"count\", len(repushItems)).Msg(\"REPUSH_ITEMS_INFO\")\n\n\tvar wg sync.WaitGroup\n\tfor _, repushItem := range repushItems {\n\t\twg.Add(1)\n\t\tt.semaphore <- struct{}{}\n\t\tgo func(item *RepushItem) {\n\t\t\tdefer wg.Done()\n\t\t\tdefer func() { <-t.semaphore }()\n\t\t\tt.ProcessSingleRepushItem(item)\n\t\t}(repushItem)\n\t}\n\twg.Wait()\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": []
  },
  "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/repositories/base.go:48:65:UpdateResBalanceRecord": {
    "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/repositories/base.go",
    "code_start_line": 48,
    "code_end_line": 65,
    "code_start_column": 26,
    "code_key": "UpdateResBalanceRecord",
    "code_value": "func (repo *BalanceRepo) UpdateResBalanceRecord(ctx context.Context, appId int64, resourceId string, balanceUpdateDetails []*BalanceUpdateDetail, tableName string) error {\n\terr := repo.DB.Transaction(func(tx *gorm.DB) error {\n\t\tfor _, detail := range balanceUpdateDetails {\n\t\t\tupdateKVs := map[string]interface{}{\n\t\t\t\t\"status\":          detail.Status,\n\t\t\t\t\"lastBalanceTime\": detail.LastBalanceTime,\n\t\t\t}\n\t\t\tresult := tx.Table(tableName).\n\t\t\t\tWhere(\"appId = ? and resourceId = ? and id = ?\", appId, resourceId, detail.BalanceId).\n\t\t\t\tUpdates(updateKVs)\n\t\t\tif result.Error != nil {\n\t\t\t\treturn result.Error\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\treturn err\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 2,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/service.go",
        "code_start_line": 436,
        "code_end_line": 466,
        "code_key": "UpdateResBalanceRecords",
        "code_value": "func (cbsSrv *CbsSrv) UpdateResBalanceRecords(appId user.AppId, chargeItem *ChargeItem) error {\n\n\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(appId)).\n\t\tStr(\"resourceId\", string(chargeItem.ResourceId)).Msg(\"UPDATE_CBS_BALANCE_RECORD\")\n\n\tvar err error\n\tdetails := make([]*repositories.BalanceUpdateDetail, 0)\n\tfor _, updateKV := range chargeItem.UpdateKVs {\n\t\tdetails = append(details, &repositories.BalanceUpdateDetail{\n\t\t\tBalanceId:       updateKV.Id,\n\t\t\tStatus:          updateKV.Status,\n\t\t\tLastBalanceTime: updateKV.LastBalanceTime,\n\t\t})\n\n\t}\n\n\terr = cbsSrv.balanceRepo.UpdateResBalanceRecord(\n\t\tcbsSrv.ctx,\n\t\tint64(appId),\n\t\tstring(chargeItem.ResourceId),\n\t\tdetails,\n\t\tcbsSrv.balanceRepo.GetBalanceTableName(),\n\t)\n\n\tif err != nil {\n\t\tlogs.Error(cbsSrv.ctx).Err(err).Uint64(\"appId\", uint64(chargeItem.AppId)).\n\t\t\tStr(\"resourceId\", string(chargeItem.ResourceId)).Msg(\"UPDATE_CBS_BALANCE_RECORD_FAILED\")\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 238,
        "code_end_line": 240,
        "code_key": "UpdateResBalanceRecords",
        "code_value": "func (snapSrv *SnapSrv) UpdateResBalanceRecords(appId user.AppId, chargeItem *ChargeItem) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 483,
        "code_end_line": 508,
        "code_key": "UpdateResBalanceRecords",
        "code_value": "func (cbsSrv *CbsSrv) UpdateResBalanceRecords(appId user.AppId, chargeItem *ChargeItem) error {\n\n\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(appId)).\n\t\tStr(\"resourceId\", string(chargeItem.ResourceId)).Msg(\"UPDATE_CBS_BALANCE_RECORD\")\n\n\tvar err error\n\tdetails := make([]*BalanceUpdateDetail, 0)\n\tfor _, updateKV := range chargeItem.UpdateKVs {\n\t\tdetails = append(details, &BalanceUpdateDetail{\n\t\t\tBalanceId:       updateKV.Id,\n\t\t\tStatus:          updateKV.Status,\n\t\t\tLastBalanceTime: updateKV.LastBalanceTime,\n\t\t})\n\n\t}\n\n\terr = cbsSrv.measureRepo.UpdateResBalanceRecord(\n\t\tcbsSrv.ctx,\n\t\tint64(appId),\n\t\tstring(chargeItem.ResourceId),\n\t\tdetails,\n\t\tcbsSrv.measureRepo.GetBalanceTableName(),\n\t)\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": []
  },
  "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/measure.go:82:104:UpdateResBalanceRecord": {
    "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/measure.go",
    "code_start_line": 82,
    "code_end_line": 104,
    "code_start_column": 26,
    "code_key": "UpdateResBalanceRecord",
    "code_value": "func (repo *MeasureRepo) UpdateResBalanceRecord(ctx context.Context, appId int64, resourceId string, balanceUpdateDetails []*measure.BalanceUpdateDetail, tableName string) error {\n\tdb, err := repo.getCCDBDb(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = db.Transaction(func(tx *gorm.DB) error {\n\t\tfor _, detail := range balanceUpdateDetails {\n\t\t\tupdateKVs := map[string]interface{}{\n\t\t\t\t\"status\":          detail.Status,\n\t\t\t\t\"lastBalanceTime\": detail.LastBalanceTime,\n\t\t\t}\n\t\t\tresult := tx.Table(tableName).\n\t\t\t\tWhere(\"appId = ? and resourceId = ? and id = ?\", appId, resourceId, detail.BalanceId).\n\t\t\t\tUpdates(updateKVs)\n\t\t\tif result.Error != nil {\n\t\t\t\treturn result.Error\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\treturn err\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 2,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/service.go",
        "code_start_line": 436,
        "code_end_line": 466,
        "code_key": "UpdateResBalanceRecords",
        "code_value": "func (cbsSrv *CbsSrv) UpdateResBalanceRecords(appId user.AppId, chargeItem *ChargeItem) error {\n\n\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(appId)).\n\t\tStr(\"resourceId\", string(chargeItem.ResourceId)).Msg(\"UPDATE_CBS_BALANCE_RECORD\")\n\n\tvar err error\n\tdetails := make([]*repositories.BalanceUpdateDetail, 0)\n\tfor _, updateKV := range chargeItem.UpdateKVs {\n\t\tdetails = append(details, &repositories.BalanceUpdateDetail{\n\t\t\tBalanceId:       updateKV.Id,\n\t\t\tStatus:          updateKV.Status,\n\t\t\tLastBalanceTime: updateKV.LastBalanceTime,\n\t\t})\n\n\t}\n\n\terr = cbsSrv.balanceRepo.UpdateResBalanceRecord(\n\t\tcbsSrv.ctx,\n\t\tint64(appId),\n\t\tstring(chargeItem.ResourceId),\n\t\tdetails,\n\t\tcbsSrv.balanceRepo.GetBalanceTableName(),\n\t)\n\n\tif err != nil {\n\t\tlogs.Error(cbsSrv.ctx).Err(err).Uint64(\"appId\", uint64(chargeItem.AppId)).\n\t\t\tStr(\"resourceId\", string(chargeItem.ResourceId)).Msg(\"UPDATE_CBS_BALANCE_RECORD_FAILED\")\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 238,
        "code_end_line": 240,
        "code_key": "UpdateResBalanceRecords",
        "code_value": "func (snapSrv *SnapSrv) UpdateResBalanceRecords(appId user.AppId, chargeItem *ChargeItem) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 483,
        "code_end_line": 508,
        "code_key": "UpdateResBalanceRecords",
        "code_value": "func (cbsSrv *CbsSrv) UpdateResBalanceRecords(appId user.AppId, chargeItem *ChargeItem) error {\n\n\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(appId)).\n\t\tStr(\"resourceId\", string(chargeItem.ResourceId)).Msg(\"UPDATE_CBS_BALANCE_RECORD\")\n\n\tvar err error\n\tdetails := make([]*BalanceUpdateDetail, 0)\n\tfor _, updateKV := range chargeItem.UpdateKVs {\n\t\tdetails = append(details, &BalanceUpdateDetail{\n\t\t\tBalanceId:       updateKV.Id,\n\t\t\tStatus:          updateKV.Status,\n\t\t\tLastBalanceTime: updateKV.LastBalanceTime,\n\t\t})\n\n\t}\n\n\terr = cbsSrv.measureRepo.UpdateResBalanceRecord(\n\t\tcbsSrv.ctx,\n\t\tint64(appId),\n\t\tstring(chargeItem.ResourceId),\n\t\tdetails,\n\t\tcbsSrv.measureRepo.GetBalanceTableName(),\n\t)\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": []
  },
  "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go:677:710:Release": {
    "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
    "code_start_line": 677,
    "code_end_line": 710,
    "code_start_column": 21,
    "code_key": "Release",
    "code_value": "func (l *mysqlLock) Release(ctx context.Context) error {\n\tif atomic.LoadInt32(&l.released) == 1 {\n\t\t// fast path\n\t\treturn nil\n\t}\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\n\t// slow path\n\tif l.released == 1 {\n\t\treturn nil\n\t}\n\n\ttx := l.locker.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\n\n\treadLocks, writeLocks := l.locker.getReadLocksAndWriteLocks(tx, l.keys)\n\n\tif err := l.locker.deleteLocksByKeysAndToken(tx, dlock.LockKeySlice(writeLocks).GetKeys(), l.tokens); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn errors.Wrap(err, \"failed to release locks\")\n\t}\n\n\tif err := l.locker.releaseReadLocks(tx, dlock.LockKeySlice(readLocks).GetKeys(), l.tokens); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn errors.Wrap(err, \"failed to release locks\")\n\t}\n\n\tif result := tx.Commit(); result.Error != nil {\n\t\treturn errors.Wrap(result.Error, \"failed to commit release locks\")\n\t}\n\tl.expiration = time.Now()\n\tatomic.StoreInt32(&l.released, 1)\n\treturn nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 4,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/convertor.go",
        "code_start_line": 28,
        "code_end_line": 38,
        "code_key": "Start",
        "code_value": "func (a *Convertor) Start(ctx context.Context) error {\n\t// 启动转换器\n\tfor _, scanner := range a.scanners {\n\t\tscanner := scanner\n\t\tgo func() {\n\t\t\ta.convertToTask(ctx, scanner)\n\t\t}()\n\t}\n\tlogs.Info(ctx).Msgf(\"Convertor Start Success\")\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_rec_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *CbsMeasureReconciliationTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\t//s.resultChan <- struct{}{}\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_rec_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 35,
        "code_key": "Start",
        "code_value": "func (s *SnapMeasureReconciliationTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_compute_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *SnapComputeTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\t//s.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_measure_send_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *CbsMeasureSendTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_bill_valid_appId_fetch_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *CbsValidAppIdFetchTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_calculate_cost_locally_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 36,
        "code_key": "Start",
        "code_value": "func (s *SnapCalculateCostLocallyTaskScanner) Start(ctx context.Context) error {\n\t//s.resultChan <- struct{}{}\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_create_task_scanner.go",
        "code_start_line": 23,
        "code_end_line": 42,
        "code_key": "Start",
        "code_value": "func (s *UpdateCreateTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\trunning := true\n\t\tfor running {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\trunning = false\n\t\t\tdefault:\n\t\t\t\terr := s.FullScan(ctx)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogs.Fatal(ctx).Msgf(\"%s full scan failed!\\n\", s.name)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\ttime.Sleep(s.scanInterval)\n\t\t}\n\t}()\n\tlogs.Info(ctx).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_measure_send_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 36,
        "code_key": "Start",
        "code_value": "func (s *SnapMeasureSendTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\t//s.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/repush_user_billing_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 39,
        "code_key": "Start",
        "code_value": "func (s *RepushUserBillingTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_rollback_task_scanner.go",
        "code_start_line": 23,
        "code_end_line": 42,
        "code_key": "Start",
        "code_value": "func (s *UpdateRollbackTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\trunning := true\n\t\tfor running {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\trunning = false\n\t\t\tdefault:\n\t\t\t\terr := s.FullScan(ctx)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogs.Fatal(ctx).Msgf(\"%s full scan failed!\\n\", s.name)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\ttime.Sleep(s.scanInterval)\n\t\t}\n\t}()\n\tlogs.Info(ctx).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_valid_appId_fetch_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 36,
        "code_key": "Start",
        "code_value": "func (s *SnapValidAppIdFetchTaskScanner) Start(ctx context.Context) error {\n\t//s.resultChan <- struct{}{}\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_bill_compute_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 39,
        "code_key": "Start",
        "code_value": "func (s *CbsBillComputeTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/app/app.go",
        "code_start_line": 31,
        "code_end_line": 39,
        "code_key": "Start",
        "code_value": "func (m *PipelineManager) Start(ctx context.Context) error {\n\tfor region, pipeline := range m.Pipelines {\n\t\tregionCtx := context.WithValue(ctx, \"region\", region)\n\t\tif err := pipeline.Start(regionCtx); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/app/app.go",
        "code_start_line": 46,
        "code_end_line": 51,
        "code_key": "Start",
        "code_value": "func (app *NebulaApp) Start(ctx context.Context) error {\n\tif err := app.pipelineManager.Start(ctx); err != nil {\n\t\treturn err\n\t}\n\treturn <-app.stopChan\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/app/pipeline.go",
        "code_start_line": 20,
        "code_end_line": 46,
        "code_key": "Start",
        "code_value": "func (p *RegionPipeline) Start(ctx context.Context) error {\n\tregion := ctx.Value(\"region\").(string)\n\tscannerLogCtx := initLogger(ctx, region, \"scanner.log\")\n\tfor _, scanner := range p.scanners {\n\t\tsingleCtx := logs.AddDefaultMessage(scannerLogCtx, \"name\", scanner.GetName())\n\t\terr := scanner.Start(singleCtx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tinitMetric(scanner, region, \"scanner\", scanner.GetName())\n\t}\n\n\tconvertorLogCtx := initLogger(ctx, region, \"convertor.log\")\n\terr := p.convertor.Start(convertorLogCtx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// start scheduler\n\tschedulerLogCtx := initLogger(ctx, region, \"scheduler.log\")\n\terr = p.scheduler.Start(schedulerLogCtx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tinitMetric(p.scheduler, region, \"scheduler\", \"scheduler\")\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go",
        "code_start_line": 109,
        "code_end_line": 112,
        "code_key": "Start",
        "code_value": "func (sc *Scheduler) Start(ctx context.Context) error {\n\tgo sc.mainLoop(ctx)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/scheduler.go",
        "code_start_line": 154,
        "code_end_line": 191,
        "code_key": "Start",
        "code_value": "func (s *scheduler) Start(ctx context.Context) error {\n\twg := sync.WaitGroup{}\n\trunning := true\n\tgo s.haManager.Start(ctx)\n\tdefer s.haManager.Close(ctx)\n\tfor {\n\t\tselect {\n\t\tcase taskName := <-s.eventChan:\n\t\t\twg.Add(1)\n\t\t\tgo func(name string) {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tif task, ok := s.loads[name]; ok {\n\n\t\t\t\t\tif s.isMaster {\n\t\t\t\t\t\t_ctx := logs.With(ctx).Str(\"seqId\", uuid.New().String()).Str(\"taskName\", name).Logger().WithContext(ctx)\n\t\t\t\t\t\ttask.Work(_ctx)\n\t\t\t\t\t}\n\n\t\t\t\t\ttriggerTime := time.Now().Add(task.Interval())\n\t\t\t\t\tfor {\n\t\t\t\t\t\tif !running {\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif time.Now().After(triggerTime) {\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttime.Sleep(time.Second)\n\t\t\t\t\t}\n\t\t\t\t\ts.eventChan <- name\n\t\t\t\t}\n\t\t\t}(taskName)\n\t\tcase <-s.stopChan:\n\t\t\trunning = false\n\t\t\twg.Wait()\n\t\t\treturn nil\n\t\t}\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/easyha/model.go",
        "code_start_line": 108,
        "code_end_line": 180,
        "code_key": "Start",
        "code_value": "func (m *haManagerImpl) Start(ctx context.Context) {\n\tm.keepRunning = true\n\tm.ctx = ctx\n\tvar (\n\t\tmyIdentity            = m.delegate.GetIdentity()                                    // 当前节点的业务标识\n\t\tmyKey                 = fmt.Sprintf(\"easyhaMaster/%s\", url.PathEscape(m.namespace)) // 分布式锁的key\n\t\tmyToken               = m.encodeToken(myIdentity)                                   // 分布式锁 Token，包含业务标识和随机信息\n\t\tmyLock                dlock.Lock                                                    // 获取到的分布式锁, 用于刷新和释放\n\t\tcurrentMasterIdentity string                                                        // 当前 master 的业务标识，如果为空则是还未获取过当前 master\n\t)\n\n\t// Start slave loop.\n\tfor m.keepRunning {\n\t\t// Try observe the master lock first.\n\t\tif view, err := m.locker.Observe(ctx, myKey); err != nil {\n\t\t\tm.logger.Info().Err(err).Str(\"key\", myKey).Msg(\"failed to observe current master lock\")\n\t\t\t// Failed to observe the master lock, try to  obtain the lock.\n\t\t\tmyLock, err = m.locker.Obtain(ctx, dlock.NewWriteLockKey(myKey), m.lockExpired, &dlock.Option{Token: myToken})\n\t\t\tif err == nil {\n\t\t\t\t// Successfully obtained the lock.\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tnewIdentity, err := m.decodeToken(view.Token)\n\t\t\tif err != nil {\n\t\t\t\tm.logger.Warn().Err(err).Str(\"token\", view.Token).Msg(\"failed to decode token\")\n\t\t\t} else if currentMasterIdentity == \"\" {\n\t\t\t\t// First time to observe the master.\n\t\t\t\tcurrentMasterIdentity = newIdentity\n\t\t\t\tif err := m.delegate.OnBecomeSlave(ctx, currentMasterIdentity); err != nil {\n\t\t\t\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle become slave, force quit for safety\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if currentMasterIdentity != newIdentity {\n\t\t\t\t// Master changed. Need update.\n\t\t\t\tcurrentMasterIdentity = newIdentity\n\t\t\t\tif err := m.delegate.OnSwitchMaster(ctx, currentMasterIdentity); err != nil {\n\t\t\t\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle switch master, force quit for safety\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttime.Sleep(m.checkInterval)\n\t}\n\n\tif myLock == nil {\n\t\tm.logger.Fatal().Msg(\"myLock is nil, found bug, force quit for safety\")\n\t\treturn\n\t}\n\n\t// I am the master now.\n\tif err := m.delegate.OnBecomeMaster(ctx); err != nil {\n\t\tmyLock.Release(ctx)\n\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle become master, force quit for safety\")\n\t\treturn\n\t}\n\n\tdefer func() {\n\t\tmyLock.Release(ctx)\n\t\tif err := m.delegate.OnLostMaster(ctx); err != nil {\n\t\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle lost master, force quit for safety\")\n\t\t}\n\t}()\n\n\t// Start the master loop.\n\tfor m.keepRunning {\n\t\ttime.Sleep(m.checkInterval)\n\t\tif err := myLock.Refresh(ctx, m.lockExpired); err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/test_utils/initdb.go",
        "code_start_line": 91,
        "code_end_line": 98,
        "code_key": "SetupTestDatabase",
        "code_value": "func (i dbInitializer) SetupTestDatabase(t *testing.T, database string) (*gorm.DB, func()) {\n\tidx := pool.Get()\n\tdb := i.openMySQLConnection(t, database)\n\treturn db, func() {\n\t\t_idx := idx\n\t\tpool.Release(_idx)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/testutil/db.go",
        "code_start_line": 102,
        "code_end_line": 110,
        "code_key": "SetupTestDatabase",
        "code_value": "func (i dbInitializer) SetupTestDatabase(t *testing.T) (*gorm.DB, func()) {\n\tidx := pool.Get()\n\tdb := i.openMySQLConnection(t, idx)\n\ti.createTables(t, db)\n\treturn db, func() {\n\t\t_idx := idx\n\t\tpool.Release(_idx)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/dispatcher/dispatcher.go",
        "code_start_line": 33,
        "code_end_line": 103,
        "code_key": "Dispatch",
        "code_value": "func (d *dispatcherImpl) Dispatch(ctx context.Context, cmd app.Command) (err error) {\n\t// 为什么使用 backgroundCtx 而不是 ctx？\n\t// 因为 ctx 代表调用方的上下文，通常是 rpc 请求上下文。\n\t// 而执行命令的上下文，应该是一个独立的上下文，不应该受到调用方的影响\n\t// 即使由于网络抖动等原因，调用方的上下文已经超时，但是命令执行的上下文仍然应该继续执行。\n\tworkerCtx := context.WithValue(d.backgroundCtx, ctxKeyCommand, cmd)\n\tworkerCtx, cancelFunc := context.WithTimeout(workerCtx, d.workerTimeout)\n\tworkerCtx = logs.GetLogger(ctx).WithContext(workerCtx)\n\tlockKeys := cmd.LockKeys()\n\terrChan := make(chan error, 1)\n\tlockOption := &dlock.Option{\n\t\tRetryStrategy: dlock.ExponentialBackoff(100*time.Millisecond, 6*time.Second),\n\t}\n\td.wg.Add(1)\n\t// 最终打印错误\n\t// TODO: 并发控制最大能同时执行的命令数量\n\tgo func() {\n\t\tdefer d.wg.Done()\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\te, ok := err.(error)\n\t\t\t\tif !ok {\n\t\t\t\t\te = errors.Newf(ErrDispatchPanic, \"dispatcher panic: %v\", err)\n\t\t\t\t}\n\t\t\t\terrChan <- e\n\t\t\t\tlogs.Error(workerCtx).Err(e).Stack().Bytes(\"trace\", debug.Stack()).Msgf(\"command execution panic\")\n\t\t\t}\n\t\t}()\n\n\t\tdefer cancelFunc()\n\n\t\tif lockKeys != nil {\n\t\t\tlock, err := d.locker.ObtainMulti(workerCtx, lockKeys, d.workerTimeout, lockOption)\n\t\t\tif err != nil {\n\t\t\t\terrChan <- err\n\t\t\t\tlogs.Warn(workerCtx).Err(err).Msgf(\"command execution waiting locks timeout\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer lock.Release(workerCtx)\n\t\t}\n\n\t\tuow := app.GetRegistry(ctx).Repositories.UoWFactory.New()\n\t\tworkerCtx = app.GetRegistry(ctx).Repositories.UoWFactory.With(workerCtx, uow)\n\n\t\terr = cmd.Handle(workerCtx)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, errors.ErrDryRunSuccessExit) {\n\t\t\t\terr = nil\n\t\t\t} else {\n\t\t\t\tlogs.Warn(workerCtx).Err(err).Msgf(\"command execution failed\")\n\t\t\t}\n\t\t\t_err := uow.Rollback(workerCtx)\n\t\t\tif _err != nil {\n\t\t\t\tlogs.Error(workerCtx).Err(_err).Msgf(\"unit of work rollback failed\")\n\t\t\t}\n\t\t} else {\n\t\t\terr = uow.Commit(workerCtx)\n\t\t\tif err != nil {\n\t\t\t\tlogs.Error(workerCtx).Err(err).Msgf(\"unit of work commit failed\")\n\t\t\t}\n\t\t}\n\t\terrChan <- err\n\t\tclose(errChan)\n\t}()\n\tselect {\n\tcase err := <-errChan:\n\t\treturn err\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": []
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/testutil/db.go:76:100:openMySQLConnection": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/testutil/db.go",
    "code_start_line": 76,
    "code_end_line": 100,
    "code_start_column": 22,
    "code_key": "openMySQLConnection",
    "code_value": "func (dbInitializer) openMySQLConnection(t *testing.T, idx int) *gorm.DB {\n\t// Example docker commands to start a docker server\n\tmysqlUrl := os.Getenv(\"CBS_TEST_MYSQL_URL\")\n\tif mysqlUrl == \"\" {\n\t\t// 默认使用这个配置，用 DOCKER 启动一个 MySQL 服务:\n\t\t// docker run -d --rm -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7\n\t\tuser := \"root\"\n\t\tpasswd := \"123456\" // NOCA:PasswordLeak(误报)\n\t\thost := \"127.0.0.1\"\n\t\tport := 3306\n\t\tmysqlUrl = fmt.Sprintf(\"%s:%s@tcp(%s:%d)/?charset=utf8mb4&parseTime=True&loc=Local\",\n\t\t\tuser, passwd, host, port)\n\t}\n\tdatabase := os.Getenv(\"CBS_TEST_MYSQL_DATABASE\")\n\tif database == \"\" {\n\t\tdatabase = fmt.Sprintf(\"test-singularity-%d-%d\", os.Getpid(), idx)\n\t}\n\tdb, err := gorm.Open(mysql.Open(mysqlUrl), &gorm.Config{})\n\tif err != nil {\n\t\tt.Skipf(\"failed to connect to mysql server: %s\", err)\n\t}\n\tassert.NoError(t, db.Exec(fmt.Sprintf(\"DROP DATABASE IF EXISTS `%s`\", database)).Error, \"failed to drop database\")\n\tassert.NoError(t, db.Exec(fmt.Sprintf(\"CREATE DATABASE `%s`\", database)).Error, \"failed to create database\")\n\treturn db.Exec(fmt.Sprintf(\"USE `%s`\", database))\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 3,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/test_utils/initdb.go",
        "code_start_line": 91,
        "code_end_line": 98,
        "code_key": "SetupTestDatabase",
        "code_value": "func (i dbInitializer) SetupTestDatabase(t *testing.T, database string) (*gorm.DB, func()) {\n\tidx := pool.Get()\n\tdb := i.openMySQLConnection(t, database)\n\treturn db, func() {\n\t\t_idx := idx\n\t\tpool.Release(_idx)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/testutil/db.go",
        "code_start_line": 102,
        "code_end_line": 110,
        "code_key": "SetupTestDatabase",
        "code_value": "func (i dbInitializer) SetupTestDatabase(t *testing.T) (*gorm.DB, func()) {\n\tidx := pool.Get()\n\tdb := i.openMySQLConnection(t, idx)\n\ti.createTables(t, db)\n\treturn db, func() {\n\t\t_idx := idx\n\t\tpool.Release(_idx)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/registry/registry.go",
        "code_start_line": 20,
        "code_end_line": 25,
        "code_key": "Config",
        "code_value": "type Config struct {\n\tRegion         map[string]*RegionInfo `mapstructure:\"region\" json:\"region\" yaml:\"region\" toml:\"region\"`\n\tLog            *logs.Config           `mapstructure:\"log\" json:\"log\" yaml:\"log\" toml:\"log\"`\n\tDatabases      *DatabaseConfig        `mapstructure:\"database\" json:\"database\" yaml:\"database\" toml:\"database\"`\n\tConsumerConfig map[string]interface{} `mapstructure:\"consumer\" json:\"consumer\" yaml:\"consumer\" toml:\"consumer\"`\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/config/config.go",
        "code_start_line": 24,
        "code_end_line": 28,
        "code_key": "Config",
        "code_value": "type Config struct {\n\tGlobal          *GlobalConfig\n\tMainLogConfig   *logs.Config\n\tRegionPipelines map[string]*regionPipelineConfig\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/clients/trade_client/trade_api.go",
        "code_start_line": 28,
        "code_end_line": 33,
        "code_key": "Config",
        "code_value": "type Config struct {\n\tProductCode string\n\tURL         string\n\tSecretID    string\n\tSecretKey   string\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/clients/cos/client.go",
        "code_start_line": 22,
        "code_end_line": 31,
        "code_key": "Config",
        "code_value": "type Config struct {\n\tAppID     int64  // 腾讯云 AppID\n\tSecretID  string // 腾讯云 SecretID，可以是临时密钥，也可以是永久密钥\n\tSecretKey string // 腾讯云 SecretKey，可以是临时密钥，也可以是永久密钥\n\tRegion    string // 腾讯云 COS 区域，默认为 ap-guangzhou\n\tBucket    string // 腾讯云 COS Bucket 名称\n\tDomain    string // 自定义域名，如果不传入则使用默认域名\n\tToken     string // 临时密钥 Token，如果使用永久密钥则不需要传入此字段\n\tStsDomain string // Sts 自定义域名\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/logs/log.go",
        "code_start_line": 17,
        "code_end_line": 26,
        "code_key": "Config",
        "code_value": "type Config struct {\n\tLevel               string `mapstructure:\"level\"`                 // 日志级别\n\tEnableConsoleLogger bool   `mapstructure:\"enable_console_logger\"` // 是否启用控制台日志\n\tEnableFileLogger    bool   `mapstructure:\"enable_file_logger\"`    // 是否启用文件日志\n\tLogFileDir          string `mapstructure:\"log_file_dir\"`          // 日志文件目录\n\tLogFileName         string `mapstructure:\"log_file_name\"`         // 日志文件名\n\tLogFileMaxBackups   int    `mapstructure:\"log_file_max_backups\"`  // 日志文件最大备份数\n\tLogFileMaxAge       int    `mapstructure:\"log_file_max_age\"`      // 日志文件最大保存天数\n\tLogFileMaxSize      int    `mapstructure:\"log_file_max_size\"`     // 日志文件最大大小，单位 MB\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/mq/mqimpl/rabbitMq/config.go",
        "code_start_line": 35,
        "code_end_line": 39,
        "code_key": "Config",
        "code_value": "type Config struct {\n\tUrl       string           `mapstructure:\"url\"`\n\tConsumers []ConsumerConfig `mapstructure:\"consumers\"`\n\tProducers []ProducerConfig `mapstructure:\"producers\"`\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/registry.go",
        "code_start_line": 20,
        "code_end_line": 24,
        "code_key": "Config",
        "code_value": "type Config struct {\n\tLog            logs.Config                 `mapstructure:\"log\" json:\"log\" yaml:\"log\"`\n\tMetaDB         configs.MySQLConfig         `mapstructure:\"metadb\" json:\"metadb\" yaml:\"metadb\"`\n\tCOSCredentials backupDomain.COSCredentials `mapstructure:\"cos_credentials\" json:\"cos_credentials\" yaml:\"cos_credentials\"`\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 32,
        "code_end_line": 39,
        "code_key": "Config",
        "code_value": "type Config struct {\n\tTableName      string\n\tLockColumn     string\n\tExpireColumn   string\n\tTokenColumn    string\n\tLockTypeColumn string\n\tLockNumsColumn string\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/measure.go:29:44:GetAppIdsWithResources": {
    "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/measure.go",
    "code_start_line": 29,
    "code_end_line": 44,
    "code_start_column": 26,
    "code_key": "GetAppIdsWithResources",
    "code_value": "func (repo *MeasureRepo) GetAppIdsWithResources(ctx context.Context, chargeTime time.Time, includeInvalidRes bool, tableName string) ([]int64, error) {\n\tdb, err := repo.getCCDBDb(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar appIdList []int64\n\t// FIXME 这里是获取到已经被python更新过的balance，临时兼容使用\n\tquery := db.Table(tableName).Distinct(\"appId\")\n\tif !includeInvalidRes {\n\t\tquery = query.Where(\"status = 1 and lastBalanceTime <= ?\", chargeTime)\n\t}\n\tquery.Pluck(\"appId\", &appIdList)\n\n\treturn appIdList, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/repush_user_billing_task.go",
        "code_start_line": 103,
        "code_end_line": 172,
        "code_key": "ProcessSingleRepushDetail",
        "code_value": "func (t *RepushUserBillingTask) ProcessSingleRepushDetail(detail *measure.RepushDetail) error {\n\tcbsMeasureRepo := registry.GetRegistry(t.ctx).AdapterRepos.CbsMeasureRepo.(measure.CbsMeasureRepoIFace)\n\tappIdResIdMaps := make(map[user.AppId][]measure.ResourceId)\n\tif detail.AppId > 0 {\n\t\tif len(detail.ResIds) > 0 {\n\t\t\tappIdResIdMaps[detail.AppId] = detail.ResIds\n\t\t} else {\n\t\t\tids, err := cbsMeasureRepo.GetResourceIdsByAppId(t.ctx, int64(detail.AppId), time.Time{}, true, cbsMeasureRepo.GetBalanceTableName())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tresIds := make([]measure.ResourceId, 0, len(ids))\n\t\t\tfor _, resId := range ids {\n\t\t\t\tresIds = append(resIds, measure.ResourceId(resId))\n\t\t\t}\n\t\t\tappIdResIdMaps[detail.AppId] = resIds\n\t\t}\n\t} else {\n\t\tif len(detail.ResIds) > 0 {\n\t\t\treturn fmt.Errorf(\"AppId is required when ResIds is set\")\n\t\t}\n\t\tlogs.Info(t.ctx).Msg(\"REPUSH_ALL_FOR_APPID_NOT_SET\")\n\t\tappIds, _ := cbsMeasureRepo.GetAppIdsWithResources(t.ctx, time.Time{}, true, cbsMeasureRepo.GetBalanceTableName())\n\t\tfor _, appId := range appIds {\n\t\t\t// 没有指定资源，则补量所有资源\n\t\t\tids, err := cbsMeasureRepo.GetResourceIdsByAppId(t.ctx, appId, time.Time{}, true, cbsMeasureRepo.GetBalanceTableName())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tresIds := make([]measure.ResourceId, 0, len(ids))\n\t\t\tfor _, resId := range ids {\n\t\t\t\tresIds = append(resIds, measure.ResourceId(resId))\n\t\t\t}\n\t\t\tappIdResIdMaps[user.AppId(appId)] = resIds\n\t\t}\n\n\t}\n\n\tvar repushItems []*RepushItem\n\tfor appId, resIds := range appIdResIdMaps {\n\t\tu, err := t.userSrv.GetUser(appId)\n\t\tif err != nil {\n\t\t\t// 这里可能是新注册的用户，user表里没有用户数据，可能会丢失该用户的量\n\t\t\tlogs.Error(t.ctx).Err(err).Uint64(\"appId\", uint64(appId)).Msg(\"GET_USER_ERROR\")\n\t\t\tpanic(err)\n\t\t}\n\t\tfor _, resId := range resIds {\n\t\t\tvar repushItem RepushItem\n\t\t\trepushItem.user = u\n\t\t\trepushItem.cbsInstanceId = resId\n\t\t\trepushItem.startTime = detail.StartTime\n\t\t\trepushItem.endTime = detail.EndTime\n\t\t\trepushItems = append(repushItems, &repushItem)\n\t\t}\n\t}\n\tlogs.Info(t.ctx).Int(\"count\", len(repushItems)).Msg(\"REPUSH_ITEMS_INFO\")\n\n\tvar wg sync.WaitGroup\n\tfor _, repushItem := range repushItems {\n\t\twg.Add(1)\n\t\tt.semaphore <- struct{}{}\n\t\tgo func(item *RepushItem) {\n\t\t\tdefer wg.Done()\n\t\t\tdefer func() { <-t.semaphore }()\n\t\t\tt.ProcessSingleRepushItem(item)\n\t\t}(repushItem)\n\t}\n\twg.Wait()\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 73,
        "code_end_line": 80,
        "code_key": "GetAppIdsWithValidResources",
        "code_value": "func (srv *BaseResSrv) GetAppIdsWithValidResources(chargeTime time.Time) []user.AppId {\n\tids, _ := srv.measureRepo.GetAppIdsWithResources(srv.ctx, chargeTime, false, srv.measureRepo.GetBalanceTableName())\n\tappIdList := make([]user.AppId, len(ids))\n\tfor i, appId := range ids {\n\t\tappIdList[i] = user.AppId(appId)\n\t}\n\treturn appIdList\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": []
  },
  "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/measure.go:66:80:GetIdLastBalanceTimePairs": {
    "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/measure.go",
    "code_start_line": 66,
    "code_end_line": 80,
    "code_start_column": 26,
    "code_key": "GetIdLastBalanceTimePairs",
    "code_value": "func (repo *MeasureRepo) GetIdLastBalanceTimePairs(ctx context.Context, limit int, searchAfterId int, tableName string) ([]*measure.IdLastBalanceTimePair, error) {\n\tdb, err := repo.getCCDBDb(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// 此处是为了保证有序\n\tvar idLastBalanceTimePairs []*measure.IdLastBalanceTimePair\n\tdb.Table(tableName).\n\t\tSelect(\"id, lastBalanceTime\").Where(\"id > ? and status = 1\", searchAfterId).\n\t\tOrder(\"id\").\n\t\tLimit(limit).\n\t\tScan(&idLastBalanceTimePairs)\n\treturn idLastBalanceTimePairs, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 93,
        "code_end_line": 117,
        "code_key": "BuildLastBalanceTimeCache",
        "code_value": "func (srv *BaseResSrv) BuildLastBalanceTimeCache() {\n\tsrv.lastBalanceTimeCache = make(map[int64]time.Time)\n\tlastID := -1\n\tstepSize := 10000 // 会产生慢查询。这里串行执行，风险还好\n\n\tstartTime := time.Now()\n\tlogs.Info(srv.ctx).Msg(\"START_BUILD_LAST_BALANCE_TIME_CACHE\")\n\tfor {\n\t\t// 查询100条记录，根据ID排序，使用ID进行偏移\n\t\tidLastBalanceTimePairs, _ := srv.measureRepo.GetIdLastBalanceTimePairs(srv.ctx, stepSize, lastID, srv.measureRepo.GetBalanceTableName())\n\n\t\tif len(idLastBalanceTimePairs) == 0 {\n\t\t\tbreak\n\t\t}\n\n\t\t// 将查询结果添加到缓存中\n\t\tfor _, idLastBalanceTimePair := range idLastBalanceTimePairs {\n\t\t\tsrv.lastBalanceTimeCache[idLastBalanceTimePair.ID] = idLastBalanceTimePair.LastBalanceTime\n\t\t}\n\t\tlastID = int(idLastBalanceTimePairs[len(idLastBalanceTimePairs)-1].ID)\n\t}\n\n\tcost := int(time.Now().Sub(startTime).Seconds())\n\tlogs.Info(srv.ctx).Int(\"count\", len(srv.lastBalanceTimeCache)).Int(\"cost\", cost).Msg(\"BUILD_LAST_BALANCE_TIME_CACHE_DONE\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/repositories/base.go",
        "code_start_line": 9,
        "code_end_line": 12,
        "code_key": "IdLastBalanceTimePair",
        "code_value": "type IdLastBalanceTimePair struct {\n\tID              int64     `gorm:\"column:id\"`\n\tLastBalanceTime time.Time `gorm:\"column:lastBalanceTime\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/repo.go",
        "code_start_line": 9,
        "code_end_line": 12,
        "code_key": "IdLastBalanceTimePair",
        "code_value": "type IdLastBalanceTimePair struct {\n\tID              int64     `gorm:\"column:id\"`\n\tLastBalanceTime time.Time `gorm:\"column:lastBalanceTime\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/measure.go:170:177:BatchCreateMeasureRepo": {
    "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/measure.go",
    "code_start_line": 170,
    "code_end_line": 177,
    "code_start_column": 26,
    "code_key": "BatchCreateMeasureRepo",
    "code_value": "func (repo *MeasureRepo) BatchCreateMeasureRepo(ctx context.Context, measures interface{}, nums int) (bool, error) {\n\tdb, err := repo.getMeasureDb(ctx)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdb.CreateInBatches(measures, nums)\n\treturn true, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measureReconciliation/service.go",
        "code_start_line": 119,
        "code_end_line": 124,
        "code_key": "BatchSyncCbsMsgToDb",
        "code_value": "func (measureRecSrv *ReconciliationSrv) BatchSyncCbsMsgToDb(measures *measure.CbsMeasureDetails) error {\n\tcbsMeasures := measures.CbsMeasureDetail\n\tnums := len(cbsMeasures)\n\t_, err := measureRecSrv.repo.BatchCreateMeasureRepo(measureRecSrv.ctx, cbsMeasures, nums)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measureReconciliation/service.go",
        "code_start_line": 126,
        "code_end_line": 131,
        "code_key": "BatchSyncMsgToDb",
        "code_value": "func (measureRecSrv *ReconciliationSrv) BatchSyncMsgToDb(measure *measure.MeasureDetail) bool {\n\tsnapMeasures := measure.ChargeItems\n\tnums := len(snapMeasures)\n\tflag, _ := measureRecSrv.repo.BatchCreateMeasureRepo(measureRecSrv.ctx, snapMeasures, nums)\n\treturn flag\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": []
  },
  "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/disk.go:31:49:QueryRollbackingDiskList": {
    "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/disk.go",
    "code_start_line": 31,
    "code_end_line": 49,
    "code_start_column": 20,
    "code_key": "QueryRollbackingDiskList",
    "code_value": "func (d *DiskRepo) QueryRollbackingDiskList(ctx context.Context) ([]*ccdb.CCbs, error) {\n\tvar diskList []*ccdb.CCbs\n\n\tdb, err := d.getCCDBDb(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcond1 := db.Where(\"lifeState IN ?\", []ccdb.DiskLifeState{ccdb.DiskLifeStateNormal, ccdb.DiskLifeStateIsolated})\n\tcond2 := db.Where(\"lifeState = ?\", ccdb.DiskLifeStateConcealed).\n\t\tWhere(\"status IN ?\", []ccdb.DiskStatus{ccdb.DiskAttached, ccdb.DiskInited})\n\tquery := db.Where(\"rollbacking IN ?\", []ccdb.DiskRollbackType{ccdb.SameDiskRb, ccdb.DiffDiskRb, ccdb.FastRb})\n\tresult := query.Where(cond1.Or(cond2)).Find(&diskList)\n\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\treturn diskList, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_rollback_task_scanner.go",
        "code_start_line": 50,
        "code_end_line": 70,
        "code_key": "getCCbsRollbackTask",
        "code_value": "func (s *UpdateRollbackTaskScanner) getCCbsRollbackTask(ctx context.Context) error {\n\t// cCbs表回滚进度更新\n\tdiskRepo := registry.GetRegistry(ctx).AdapterRepos.DiskRepo.(adapter_interfaces.DiskInterface)\n\tdiskRollbackList, err := diskRepo.QueryRollbackingDiskList(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, diskRecord := range diskRollbackList {\n\t\tentity := &diskLogical.DiskEntity{\n\t\t\tDiskRecord: diskRecord,\n\t\t}\n\t\tdiskRollbackAgg := &diskLogical.DiskRollbackingTaskAggregate{\n\t\t\tDiskEntity:        entity,\n\t\t\tRollbackingEntity: nil,\n\t\t\tTaskName:          core.UpdateCCbsNormalRBTask,\n\t\t\tSubTaskName:       core.UpdateCCbsNormalRBTask,\n\t\t}\n\t\ts.resultChan <- diskRollbackAgg\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/adapter/db/ccdb/model.go",
        "code_start_line": 52,
        "code_end_line": 67,
        "code_key": "CCbs",
        "code_value": "type CCbs struct {\n\tCbsId              int64  `gorm:\"column:cbsId;primaryKey\"`\n\tAppId              int64  `gorm:\"column:appId\"`\n\tCbsInstanceId      string `gorm:\"column:cbsInstanceId\"`\n\tCbsUuid            string `gorm:\"column:cbsUuid\"`\n\tDiskSize           int    `gorm:\"column:diskSize\"`\n\tDiskType           string `gorm:\"column:diskType\"`\n\tLifeState          string `gorm:\"column:lifeState\"`\n\tStatus             int    `gorm:\"column:status\"`\n\tRollbacking        int    `gorm:\"column:rollbacking\"`\n\tRollbackingPercent int    `gorm:\"column:rollbackPercent\"`\n\tArchType           string `gorm:\"column:archType\"`\n\tAssigned           int    `gorm:\"column:assigned\"`\n\tAttached           int    `gorm:\"column:attached\"`\n\tPayMode            string `gorm:\"column:payMode\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/adapter/db/ccdb/model.go",
        "code_start_line": 69,
        "code_end_line": 71,
        "code_key": "TableName",
        "code_value": "func (CCbs) TableName() string {\n\treturn \"cCbs\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/db/ccdb/model.go",
        "code_start_line": 52,
        "code_end_line": 67,
        "code_key": "CCbs",
        "code_value": "type CCbs struct {\n\tCbsId              int64  `gorm:\"column:cbsId;primaryKey\"`\n\tAppId              int64  `gorm:\"column:appId\"`\n\tCbsInstanceId      string `gorm:\"column:cbsInstanceId\"`\n\tCbsUuid            string `gorm:\"column:cbsUuid\"`\n\tDiskSize           int    `gorm:\"column:diskSize\"`\n\tDiskType           string `gorm:\"column:diskType\"`\n\tLifeState          string `gorm:\"column:lifeState\"`\n\tStatus             int    `gorm:\"column:status\"`\n\tRollbacking        int    `gorm:\"column:rollbacking\"`\n\tRollbackingPercent int    `gorm:\"column:rollbackPercent\"`\n\tArchType           string `gorm:\"column:archType\"`\n\tAssigned           int    `gorm:\"column:assigned\"`\n\tAttached           int    `gorm:\"column:attached\"`\n\tPayMode            string `gorm:\"column:payMode\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/db/ccdb/model.go",
        "code_start_line": 69,
        "code_end_line": 71,
        "code_key": "TableName",
        "code_value": "func (CCbs) TableName() string {\n\treturn \"cCbs\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/ccdb/model.go",
        "code_start_line": 7,
        "code_end_line": 68,
        "code_key": "CCbs",
        "code_value": "type CCbs struct {\n\tID                 int64     `gorm:\"column:cbsId;primaryKey\"`\n\tAppID              int64     `gorm:\"column:appId\"`\n\tAlias              string    `gorm:\"column:alias\"`\n\tAssigned           int       `gorm:\"column:assigned\"`\n\tAttached           int       `gorm:\"column:attached\"`\n\tAutoRenewFlag      int       `gorm:\"column:autoRenewFlag\"`\n\tCbsInstanceID      string    `gorm:\"column:cbsInstanceId;uniuq_index\"`\n\tCbsSnap            int       `gorm:\"column:cbsSnap\"`\n\tCbsType            string    `gorm:\"column:cbsType\"`\n\tCbsUuid            string    `gorm:\"column:cbsUuid\"`\n\tDeadline           time.Time `gorm:\"column:deadline\"`\n\tDealID             int       `gorm:\"column:dealId\"`\n\tDealName           string    `gorm:\"column:dealName\"`\n\tDeviceID           int64     `gorm:\"column:deviceId\"`\n\tDiskSize           int       `gorm:\"column:diskSize\"`\n\tDiskType           string    `gorm:\"column:diskType\"`\n\tDom0Ip             string    `gorm:\"column:dom0Ip\"`\n\tFsType             string    `gorm:\"column:fsType\"`\n\tHostBlockSize      int       `gorm:\"column:hostBlockSize\"`\n\tLifeState          string    `gorm:\"column:lifeState\"`\n\tPath               string    `gorm:\"column:path\"`\n\tPayMode            string    `gorm:\"column:payMode\"`\n\tPortable           int       `gorm:\"column:portable\"`\n\tProjectID          int       `gorm:\"column:projectId\"`\n\tQcloudZone         int       `gorm:\"column:qcloudZone\"`\n\tStatus             int       `gorm:\"column:status\"`\n\tTarget             string    `gorm:\"column:target\"`\n\tTranID             string    `gorm:\"column:tranId\"`\n\tVmBlockSize        int       `gorm:\"column:vmBlockSize\"`\n\tVolumeType         string    `gorm:\"column:volumeType\"`\n\tZone               int       `gorm:\"column:zone\"`\n\tRollbacking        int       `gorm:\"column:rollbacking;default:0\"`\n\tRollbackPercent    int       `gorm:\"column:rollbackPercent;default:0\"`\n\tArchType           string    `gorm:\"column:archType\"`\n\tFlag               int       `gorm:\"column:flag;default:0\"`\n\tEncrypt            string    `gorm:\"column:encrypt\"`\n\tTransactionID      string    `gorm:\"column:transactionId\"`\n\tIsNewDisk          int       `gorm:\"column:isNewDisk;default:0\"`\n\tThroughValue       int       `gorm:\"column:throughValue\"`\n\tIopsValue          int       `gorm:\"column:iopsValue\"`\n\tDeleteWithInstance int       `gorm:\"column:deleteWithInstance\"`\n\tShareable          int       `gorm:\"column:shareable\"`\n\tOrderID            string    `gorm:\"column:orderId\"`\n\tCdcID              string    `gorm:\"column:cdcId\"`\n\tMigrating          int       `gorm:\"column:migrating\"`\n\tMigratePercent     int       `gorm:\"column:migratePercent\"`\n\tEncryptTime        time.Time `gorm:\"column:encryptTime\"`\n\tSnapshotSize       int       `gorm:\"column:snapshotSize\"`\n\tSnapshotCount      int       `gorm:\"column:snapshotCount\"`\n\tInsType            string    `gorm:\"column:insType\"`\n\tInsID              string    `gorm:\"column:insId\"`\n\tInsUuid            string    `gorm:\"column:insUuid\"`\n\tBackupMode         int       `gorm:\"column:backupMode\"`\n\tDeleteMode         string    `gorm:\"column:deleteMode\"`\n\tBackupQuota        int       `gorm:\"column:backupQuota\"`\n\tBackupCount        int       `gorm:\"column:backupCount\"`\n\tClusterGroupId     string    `gorm:\"column:clusterGroupId\"`\n\tOutpostID          string    `gorm:\"column:outpost_id\"`\n\tCreatedAt          time.Time `gorm:\"column:addTimeStamp;type:time\"`\n\tUpdatedAt          time.Time `gorm:\"column:modTimeStamp;type:time\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/ccdb/model.go",
        "code_start_line": 71,
        "code_end_line": 73,
        "code_key": "TableName",
        "code_value": "func (CCbs) TableName() string {\n\treturn \"cCbs\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/infra/types/names.go",
        "code_start_line": 10,
        "code_end_line": 10,
        "code_key": "DiskStatus",
        "code_value": "type DiskStatus uint8",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/disk.go:51:65:UpdateRollbackingPercent": {
    "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/disk.go",
    "code_start_line": 51,
    "code_end_line": 65,
    "code_start_column": 20,
    "code_key": "UpdateRollbackingPercent",
    "code_value": "func (d *DiskRepo) UpdateRollbackingPercent(ctx context.Context, disk *ccdb.CCbs) error {\n\tdb, err := d.getCCDBDb(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tchanges := make(map[string]interface{})\n\tchanges[\"rollbackPercent\"] = disk.RollbackingPercent\n\tchanges[\"rollbacking\"] = disk.Rollbacking\n\tresult := db.Model(disk).Where(\"cbsInstanceId = ?\", disk.CbsInstanceId).Updates(changes)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/diskLogical/service.go",
        "code_start_line": 22,
        "code_end_line": 53,
        "code_key": "UpdateCbsRollbackingPercent",
        "code_value": "func (s *DiskRollbackingServicesImpl) UpdateCbsRollbackingPercent(ctx context.Context, agg *DiskRollbackingTaskAggregate) (bool, error) {\n\tisFinish := false\n\n\tsnapPhySrv := registry.GetRegistry(ctx).DomainServices.SnapPhyService.(snapPhysical.SnapPhyServiceInterface)\n\trsp, err := snapPhySrv.QueryDiskRollbackingPercent(ctx, agg.DiskRecord.AppId, agg.DiskRecord.CbsUuid, agg.DiskRecord.ArchType)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tpercent := rsp.Percent\n\tstatus := rsp.Status\n\tif status == 3 && agg.DiskRecord.RollbackingPercent > percent {\n\t\t// 这种场景通常因为发起了多个快照回滚，此时的进度已经不是原来的进度了，直接忽略修改 cCbs\n\t\tlogs.Info(ctx).Msg(\"CBS_ROLLBACK_EXPIRED_SKIP_UPDATE_CCBS\")\n\t} else {\n\t\tif status == 1 {\n\t\t\t// 盘的状态为normal\n\t\t\tpercent = 100\n\t\t} else if status == 2 {\n\t\t\t// preRollback\n\t\t\tpercent = 0\n\t\t}\n\t\terr = agg.UpdateCbsRollbackingPercent(ctx, percent)\n\t}\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif percent >= 100 {\n\t\tisFinish = true\n\t}\n\treturn isFinish, err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/diskLogical/model.go",
        "code_start_line": 38,
        "code_end_line": 53,
        "code_key": "UpdateCbsRollbackingPercent",
        "code_value": "func (agg *DiskRollbackingTaskAggregate) UpdateCbsRollbackingPercent(ctx context.Context, percent int) error {\n\tif percent > agg.DiskRecord.RollbackingPercent {\n\t\tif percent >= 100 {\n\t\t\tagg.DiskRecord.RollbackingPercent = 100\n\t\t\tagg.DiskRecord.Rollbacking = 0\n\t\t} else {\n\t\t\tagg.DiskRecord.RollbackingPercent = percent\n\t\t}\n\t}\n\tdiskRepo := registry.GetRegistry(ctx).AdapterRepos.DiskRepo.(adapter_interfaces.DiskInterface)\n\terr := diskRepo.UpdateRollbackingPercent(ctx, agg.DiskRecord)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/model.go",
        "code_start_line": 10,
        "code_end_line": 12,
        "code_key": "Model",
        "code_value": "type Model struct {\n\tId ID `json:\"id\" gorm:\"primaryKey;autoIncrement;comment:主键\"`\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/shm_conf.go:13:28:QueryValidShmConfByKey": {
    "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/shm_conf.go",
    "code_start_line": 13,
    "code_end_line": 28,
    "code_start_column": 23,
    "code_key": "QueryValidShmConfByKey",
    "code_value": "func (r *ShmConfRepo) QueryValidShmConfByKey(ctx context.Context, key string) (*des.TCbsShmConf, error) {\n\tdb, err := r.getDesDb(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar conf des.TCbsShmConf\n\tresult := db.Where(\"confKey = ? AND status = ?\", key, des.ShmConfValid).Find(&conf)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, fmt.Errorf(\"shm config record not found\")\n\t}\n\treturn &conf, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/common/service.go",
        "code_start_line": 17,
        "code_end_line": 35,
        "code_key": "CacheGetShmConf",
        "code_value": "func (s *ShmConfService) CacheGetShmConf(ctx context.Context, key string) (*des.TCbsShmConf, error) {\n\tregion, ok := ctx.Value(\"region\").(string)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"region not found in context\")\n\t}\n\tcacheKey := fmt.Sprintf(\"ShmConf-%s\", key)\n\tcache := registry.GetRegistry(ctx).Caches[region]\n\tconf, ok := cache.Get(cacheKey)\n\tif !ok {\n\t\trepo := registry.GetRegistry(ctx).AdapterRepos.ShmConfigRepo.(adapter_interfaces.ShmConfigInterface)\n\t\tconf, err := repo.QueryValidShmConfByKey(ctx, key)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tcache.Set(cacheKey, conf, time.Minute*10) // 10分钟过期\n\t\treturn conf, nil\n\t}\n\treturn conf.(*des.TCbsShmConf), nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/db/des/model.go",
        "code_start_line": 28,
        "code_end_line": 36,
        "code_key": "TCbsShmConf",
        "code_value": "type TCbsShmConf struct {\n\tId           int64     `gorm:\"column:id;primaryKey\"`\n\tConfKey      string    `gorm:\"column:confKey\"`\n\tConfValue    string    `gorm:\"column:confValue\"`\n\tStatus       string    `gorm:\"column:status\"`\n\tAddTime      time.Time `gorm:\"column:addTime\"`\n\tModifyTime   time.Time `gorm:\"column:modifyTime\"`\n\tValidateRule string    `gorm:\"column:validateRule\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/db/des/model.go",
        "code_start_line": 38,
        "code_end_line": 40,
        "code_key": "TableName",
        "code_value": "func (TCbsShmConf) TableName() string {\n\treturn \"t_cbs_shm_conf\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/snap.go:16:30:QuerySnapInfoById": {
    "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/snap.go",
    "code_start_line": 16,
    "code_end_line": 30,
    "code_start_column": 20,
    "code_key": "QuerySnapInfoById",
    "code_value": "func (r *SnapRepo) QuerySnapInfoById(ctx context.Context, id string) (*ccdb.CSnap, error) {\n\tdb, err := r.getCCDBDb(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar cSnap ccdb.CSnap\n\tresult := db.First(&cSnap)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t} else if result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\treturn &cSnap, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/adapter/db/ccdb/model.go",
        "code_start_line": 7,
        "code_end_line": 46,
        "code_key": "CSnap",
        "code_value": "type CSnap struct {\n\tID               int64     `gorm:\"column:Id;primaryKey\"`\n\tAppId            int64     `gorm:\"column:appId\"`\n\tCbsId            int64     `gorm:\"column:cbsId\"`\n\tCbsInstanceId    string    `gorm:\"column:cbsInstanceId\"`\n\tCbsUuid          string    `gorm:\"column:cbsUuid\"`\n\tDiskSize         int       `gorm:\"column:diskSize\"`\n\tDiskType         string    `gorm:\"column:diskType\"`\n\tCreateTime       time.Time `gorm:\"column:createTime\"`\n\tModifyTime       time.Time `gorm:\"column:modifyTime\"`\n\tPercent          int       `gorm:\"column:percent\"`\n\tProjectId        int       `gorm:\"column:projectId\"`\n\tSnapInstanceId   string    `gorm:\"column:snapInstanceId;uniuq_index\"`\n\tSnapName         string    `gorm:\"column:snapName\"`\n\tSnapSize         int       `gorm:\"column:snapSize\"`\n\tSnapUuid         string    `gorm:\"column:snapUuid;uniuq_index\"`\n\tStatus           int       `gorm:\"column:status\"`\n\tVmBlockSize      int       `gorm:\"column:vmBlockSize;default:0\"`\n\tZone             int       `gorm:\"column:zone\"`\n\tZoneId           int       `gorm:\"column:zoneId\"`\n\tDeletedTime      time.Time `gorm:\"column:deletedTime\"`\n\tIsPermanent      int       `gorm:\"column:isPermanent\"`\n\tDeadlineNew      time.Time `gorm:\"column:deadline\"`\n\tDeadline         time.Time `gorm:\"column:deadline1\"`\n\tLifeState        string    `gorm:\"column:lifeState\"`\n\tFlag             int       `gorm:\"column:flag\"`\n\tArchType         string    `gorm:\"column:archType\"`\n\tExtraInfo        string    `gorm:\"column:extraInfo\"`\n\tEncrypt          string    `gorm:\"column:encrypt\"`\n\tCopyFromRemote   int       `gorm:\"column:copyFromRemote\"`\n\tCopyingToRegions string    `gorm:\"column:copyingToRegions\"`\n\tBackendSnap      int       `gorm:\"column:backendSnap\"`\n\tShareReference   int       `gorm:\"column:shareReference\"`\n\tAttribute        string    `gorm:\"column:attribute\"`\n\tTranId           string    `gorm:\"column:tranId\"`\n\tDealName         string    `gorm:\"column:dealName\"`\n\tAspInstanceId    string    `gorm:\"column:aspInstanceId\"`\n\tOutpostId        string    `gorm:\"column:outpostId\"`\n\tSavePlace        string    `gorm:\"column:savePlace\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/adapter/db/ccdb/model.go",
        "code_start_line": 48,
        "code_end_line": 50,
        "code_key": "TableName",
        "code_value": "func (CSnap) TableName() string {\n\treturn \"cSnap\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/db/ccdb/model.go",
        "code_start_line": 7,
        "code_end_line": 46,
        "code_key": "CSnap",
        "code_value": "type CSnap struct {\n\tID               int64     `gorm:\"column:Id;primaryKey\"`\n\tAppId            int64     `gorm:\"column:appId\"`\n\tCbsId            int64     `gorm:\"column:cbsId\"`\n\tCbsInstanceId    string    `gorm:\"column:cbsInstanceId\"`\n\tCbsUuid          string    `gorm:\"column:cbsUuid\"`\n\tDiskSize         int       `gorm:\"column:diskSize\"`\n\tDiskType         string    `gorm:\"column:diskType\"`\n\tCreateTime       time.Time `gorm:\"column:createTime\"`\n\tModifyTime       time.Time `gorm:\"column:modifyTime\"`\n\tPercent          int       `gorm:\"column:percent\"`\n\tProjectId        int       `gorm:\"column:projectId\"`\n\tSnapInstanceId   string    `gorm:\"column:snapInstanceId;uniuq_index\"`\n\tSnapName         string    `gorm:\"column:snapName\"`\n\tSnapSize         int       `gorm:\"column:snapSize\"`\n\tSnapUuid         string    `gorm:\"column:snapUuid;uniuq_index\"`\n\tStatus           int       `gorm:\"column:status\"`\n\tVmBlockSize      int       `gorm:\"column:vmBlockSize;default:0\"`\n\tZone             int       `gorm:\"column:zone\"`\n\tZoneId           int       `gorm:\"column:zoneId\"`\n\tDeletedTime      time.Time `gorm:\"column:deletedTime\"`\n\tIsPermanent      int       `gorm:\"column:isPermanent\"`\n\tDeadlineNew      time.Time `gorm:\"column:deadline\"`\n\tDeadline         time.Time `gorm:\"column:deadline1\"`\n\tLifeState        string    `gorm:\"column:lifeState\"`\n\tFlag             int       `gorm:\"column:flag\"`\n\tArchType         string    `gorm:\"column:archType\"`\n\tExtraInfo        string    `gorm:\"column:extraInfo\"`\n\tEncrypt          string    `gorm:\"column:encrypt\"`\n\tCopyFromRemote   int       `gorm:\"column:copyFromRemote\"`\n\tCopyingToRegions string    `gorm:\"column:copyingToRegions\"`\n\tBackendSnap      int       `gorm:\"column:backendSnap\"`\n\tShareReference   int       `gorm:\"column:shareReference\"`\n\tAttribute        string    `gorm:\"column:attribute\"`\n\tTranId           string    `gorm:\"column:tranId\"`\n\tDealName         string    `gorm:\"column:dealName\"`\n\tAspInstanceId    string    `gorm:\"column:aspInstanceId\"`\n\tOutpostId        string    `gorm:\"column:outpostId\"`\n\tSavePlace        string    `gorm:\"column:savePlace\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/db/ccdb/model.go",
        "code_start_line": 48,
        "code_end_line": 50,
        "code_key": "TableName",
        "code_value": "func (CSnap) TableName() string {\n\treturn \"cSnap\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/snap.go:32:44:QueryCreatingCopyingSnapList": {
    "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/snap.go",
    "code_start_line": 32,
    "code_end_line": 44,
    "code_start_column": 20,
    "code_key": "QueryCreatingCopyingSnapList",
    "code_value": "func (r *SnapRepo) QueryCreatingCopyingSnapList(ctx context.Context) ([]*ccdb.CSnap, error) {\n\tdb, err := r.getCCDBDb(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar snapList []*ccdb.CSnap\n\tresult := db.Where(\"status in ?\", []ccdb.SnapStatus{ccdb.SnapCreating, ccdb.SnapCopyingFromRemote, ccdb.SnapCheckingCopied}).Find(&snapList)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\treturn snapList, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_rec_task_scanner.go",
        "code_start_line": 39,
        "code_end_line": 41,
        "code_key": "FullScan",
        "code_value": "func (s *CbsMeasureReconciliationTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_rec_task_scanner.go",
        "code_start_line": 37,
        "code_end_line": 39,
        "code_key": "FullScan",
        "code_value": "func (s *SnapMeasureReconciliationTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_compute_task_scanner.go",
        "code_start_line": 39,
        "code_end_line": 41,
        "code_key": "FullScan",
        "code_value": "func (s *SnapComputeTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_measure_send_task_scanner.go",
        "code_start_line": 39,
        "code_end_line": 41,
        "code_key": "FullScan",
        "code_value": "func (s *CbsMeasureSendTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_bill_valid_appId_fetch_task_scanner.go",
        "code_start_line": 39,
        "code_end_line": 41,
        "code_key": "FullScan",
        "code_value": "func (s *CbsValidAppIdFetchTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_calculate_cost_locally_task_scanner.go",
        "code_start_line": 38,
        "code_end_line": 40,
        "code_key": "FullScan",
        "code_value": "func (s *SnapCalculateCostLocallyTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_create_task_scanner.go",
        "code_start_line": 50,
        "code_end_line": 78,
        "code_key": "FullScan",
        "code_value": "func (s *UpdateCreateTaskScanner) FullScan(ctx context.Context) error {\n\tsnapRepo := registry.GetRegistry(ctx).AdapterRepos.SnapRepo.(adapter_interfaces.SnapInterface)\n\tsnapList, err := snapRepo.QueryCreatingCopyingSnapList(ctx)\n\tif err != nil {\n\t\tlogs.Error(ctx).Err(err).Msg(\"FULL_SCAN_FAILED\")\n\t\treturn err\n\t}\n\tresultCnt := 0\n\tfor _, snapRecord := range snapList {\n\t\t// 剔除快照组预生成的快照记录\n\t\tif strings.Contains(snapRecord.SnapUuid, \"temp\") {\n\t\t\tlogs.Info(ctx).Str(\"SnapId\", snapRecord.SnapInstanceId).Msgf(\"PRE_CREATED_SNAPSHOT_SKIP_UPDATE\")\n\t\t\tcontinue\n\t\t}\n\n\t\tentity := &snapLogical.Entity{\n\t\t\tSnapRecord: snapRecord,\n\t\t}\n\t\tsnapAggregate := &snapLogical.SnapCreateTaskAggregate{\n\t\t\tEntity:      entity,\n\t\t\tTaskName:    core.UpdateCreateTask,\n\t\t\tSubTaskName: core.UpdateCreateTask,\n\t\t}\n\t\ts.resultChan <- snapAggregate\n\t\tresultCnt += 1\n\t}\n\ts.resultChanMetric.Add(float64(resultCnt))\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_measure_send_task_scanner.go",
        "code_start_line": 38,
        "code_end_line": 40,
        "code_key": "FullScan",
        "code_value": "func (s *SnapMeasureSendTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/repush_user_billing_task_scanner.go",
        "code_start_line": 41,
        "code_end_line": 43,
        "code_key": "FullScan",
        "code_value": "func (s *RepushUserBillingTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_rollback_task_scanner.go",
        "code_start_line": 103,
        "code_end_line": 113,
        "code_key": "FullScan",
        "code_value": "func (s *UpdateRollbackTaskScanner) FullScan(ctx context.Context) error {\n\tif err := s.getCCbsRollbackTask(ctx); err != nil {\n\t\tlogs.Error(ctx).Err(err).Msg(\"FULL_SCAN_FAILED\")\n\t\treturn err\n\t}\n\tif err := s.getImageSnapRollbackTask(ctx); err != nil {\n\t\tlogs.Error(ctx).Err(err).Msg(\"FULL_SCAN_FAILED\")\n\t\treturn err\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_valid_appId_fetch_task_scanner.go",
        "code_start_line": 38,
        "code_end_line": 40,
        "code_key": "FullScan",
        "code_value": "func (s *SnapValidAppIdFetchTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_bill_compute_task_scanner.go",
        "code_start_line": 41,
        "code_end_line": 43,
        "code_key": "FullScan",
        "code_value": "func (s *CbsBillComputeTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/adapter/db/ccdb/model.go",
        "code_start_line": 7,
        "code_end_line": 46,
        "code_key": "CSnap",
        "code_value": "type CSnap struct {\n\tID               int64     `gorm:\"column:Id;primaryKey\"`\n\tAppId            int64     `gorm:\"column:appId\"`\n\tCbsId            int64     `gorm:\"column:cbsId\"`\n\tCbsInstanceId    string    `gorm:\"column:cbsInstanceId\"`\n\tCbsUuid          string    `gorm:\"column:cbsUuid\"`\n\tDiskSize         int       `gorm:\"column:diskSize\"`\n\tDiskType         string    `gorm:\"column:diskType\"`\n\tCreateTime       time.Time `gorm:\"column:createTime\"`\n\tModifyTime       time.Time `gorm:\"column:modifyTime\"`\n\tPercent          int       `gorm:\"column:percent\"`\n\tProjectId        int       `gorm:\"column:projectId\"`\n\tSnapInstanceId   string    `gorm:\"column:snapInstanceId;uniuq_index\"`\n\tSnapName         string    `gorm:\"column:snapName\"`\n\tSnapSize         int       `gorm:\"column:snapSize\"`\n\tSnapUuid         string    `gorm:\"column:snapUuid;uniuq_index\"`\n\tStatus           int       `gorm:\"column:status\"`\n\tVmBlockSize      int       `gorm:\"column:vmBlockSize;default:0\"`\n\tZone             int       `gorm:\"column:zone\"`\n\tZoneId           int       `gorm:\"column:zoneId\"`\n\tDeletedTime      time.Time `gorm:\"column:deletedTime\"`\n\tIsPermanent      int       `gorm:\"column:isPermanent\"`\n\tDeadlineNew      time.Time `gorm:\"column:deadline\"`\n\tDeadline         time.Time `gorm:\"column:deadline1\"`\n\tLifeState        string    `gorm:\"column:lifeState\"`\n\tFlag             int       `gorm:\"column:flag\"`\n\tArchType         string    `gorm:\"column:archType\"`\n\tExtraInfo        string    `gorm:\"column:extraInfo\"`\n\tEncrypt          string    `gorm:\"column:encrypt\"`\n\tCopyFromRemote   int       `gorm:\"column:copyFromRemote\"`\n\tCopyingToRegions string    `gorm:\"column:copyingToRegions\"`\n\tBackendSnap      int       `gorm:\"column:backendSnap\"`\n\tShareReference   int       `gorm:\"column:shareReference\"`\n\tAttribute        string    `gorm:\"column:attribute\"`\n\tTranId           string    `gorm:\"column:tranId\"`\n\tDealName         string    `gorm:\"column:dealName\"`\n\tAspInstanceId    string    `gorm:\"column:aspInstanceId\"`\n\tOutpostId        string    `gorm:\"column:outpostId\"`\n\tSavePlace        string    `gorm:\"column:savePlace\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/adapter/db/ccdb/model.go",
        "code_start_line": 48,
        "code_end_line": 50,
        "code_key": "TableName",
        "code_value": "func (CSnap) TableName() string {\n\treturn \"cSnap\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/db/ccdb/model.go",
        "code_start_line": 7,
        "code_end_line": 46,
        "code_key": "CSnap",
        "code_value": "type CSnap struct {\n\tID               int64     `gorm:\"column:Id;primaryKey\"`\n\tAppId            int64     `gorm:\"column:appId\"`\n\tCbsId            int64     `gorm:\"column:cbsId\"`\n\tCbsInstanceId    string    `gorm:\"column:cbsInstanceId\"`\n\tCbsUuid          string    `gorm:\"column:cbsUuid\"`\n\tDiskSize         int       `gorm:\"column:diskSize\"`\n\tDiskType         string    `gorm:\"column:diskType\"`\n\tCreateTime       time.Time `gorm:\"column:createTime\"`\n\tModifyTime       time.Time `gorm:\"column:modifyTime\"`\n\tPercent          int       `gorm:\"column:percent\"`\n\tProjectId        int       `gorm:\"column:projectId\"`\n\tSnapInstanceId   string    `gorm:\"column:snapInstanceId;uniuq_index\"`\n\tSnapName         string    `gorm:\"column:snapName\"`\n\tSnapSize         int       `gorm:\"column:snapSize\"`\n\tSnapUuid         string    `gorm:\"column:snapUuid;uniuq_index\"`\n\tStatus           int       `gorm:\"column:status\"`\n\tVmBlockSize      int       `gorm:\"column:vmBlockSize;default:0\"`\n\tZone             int       `gorm:\"column:zone\"`\n\tZoneId           int       `gorm:\"column:zoneId\"`\n\tDeletedTime      time.Time `gorm:\"column:deletedTime\"`\n\tIsPermanent      int       `gorm:\"column:isPermanent\"`\n\tDeadlineNew      time.Time `gorm:\"column:deadline\"`\n\tDeadline         time.Time `gorm:\"column:deadline1\"`\n\tLifeState        string    `gorm:\"column:lifeState\"`\n\tFlag             int       `gorm:\"column:flag\"`\n\tArchType         string    `gorm:\"column:archType\"`\n\tExtraInfo        string    `gorm:\"column:extraInfo\"`\n\tEncrypt          string    `gorm:\"column:encrypt\"`\n\tCopyFromRemote   int       `gorm:\"column:copyFromRemote\"`\n\tCopyingToRegions string    `gorm:\"column:copyingToRegions\"`\n\tBackendSnap      int       `gorm:\"column:backendSnap\"`\n\tShareReference   int       `gorm:\"column:shareReference\"`\n\tAttribute        string    `gorm:\"column:attribute\"`\n\tTranId           string    `gorm:\"column:tranId\"`\n\tDealName         string    `gorm:\"column:dealName\"`\n\tAspInstanceId    string    `gorm:\"column:aspInstanceId\"`\n\tOutpostId        string    `gorm:\"column:outpostId\"`\n\tSavePlace        string    `gorm:\"column:savePlace\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/db/ccdb/model.go",
        "code_start_line": 48,
        "code_end_line": 50,
        "code_key": "TableName",
        "code_value": "func (CSnap) TableName() string {\n\treturn \"cSnap\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/snap.go:46:61:UpdateCreatingPercent": {
    "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/snap.go",
    "code_start_line": 46,
    "code_end_line": 61,
    "code_start_column": 20,
    "code_key": "UpdateCreatingPercent",
    "code_value": "func (r *SnapRepo) UpdateCreatingPercent(ctx context.Context, snap *ccdb.CSnap) error {\n\tdb, err := r.getCCDBDb(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tchanges := make(map[string]interface{})\n\tchanges[\"percent\"] = snap.Percent\n\tchanges[\"status\"] = snap.Status\n\tchanges[\"snapSize\"] = snap.SnapSize\n\tresult := db.Model(snap).Where(\"snapInstanceId = ?\", snap.SnapInstanceId).Updates(changes)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/snapLogical/service.go",
        "code_start_line": 27,
        "code_end_line": 53,
        "code_key": "UpdateSnapCreatingPercent",
        "code_value": "func (s *SnapCreatingServiceImpl) UpdateSnapCreatingPercent(ctx context.Context, agg *SnapCreateTaskAggregate) (bool, error) {\n\t// 调用OSS Domain查询进度\n\tisFinish := false\n\tsnapPhySrv := registry.GetRegistry(ctx).DomainServices.SnapPhyService.(snapPhysical.SnapPhyServiceInterface)\n\trsp, err := snapPhySrv.QuerySnapCreatingPercent(ctx, agg.SnapRecord.AppId, agg.SnapRecord.SnapUuid, agg.SnapRecord.CbsUuid, agg.SnapRecord.ArchType)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tpercent := rsp.Percent\n\ttaskStatus := rsp.Status\n\tsnapSize := rsp.SnapSize\n\tsnapStatus, ok := snapOssStatusMap[taskStatus]\n\tif !ok {\n\t\tlogs.Error(ctx).Str(\"SnapId\", agg.SnapRecord.SnapInstanceId).\n\t\t\tInt(\"OssStatus\", taskStatus).Msg(\"SNAP_STATUS_ERROR\")\n\t}\n\n\tpercent = agg.GetSnapCreatePercent(ctx, percent, snapStatus)\n\terr = agg.UpdateSnapCreatingPercent(ctx, percent, snapStatus, snapSize)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif agg.SnapRecord.Status == ccdb.SnapNormal || taskStatus == snapPhysical.OssSnapStatusDeleted || taskStatus == snapPhysical.OssSnapStatusCanceled {\n\t\tisFinish = true\n\t}\n\treturn isFinish, err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/snapLogical/model.go",
        "code_start_line": 36,
        "code_end_line": 59,
        "code_key": "UpdateSnapCreatingPercent",
        "code_value": "func (agg *SnapCreateTaskAggregate) UpdateSnapCreatingPercent(ctx context.Context, percent int, snapStatus int, snapSize int) error {\n\tif percent <= agg.SnapRecord.Percent && snapStatus == agg.SnapRecord.Status {\n\t\tlogs.Info(ctx).Msg(\"PERCENT_NOT_CHANGED_ADN_SKIP_UPDATE\")\n\t\treturn nil\n\t}\n\n\tmaxSnapSize := agg.SnapRecord.DiskSize * 1024\n\tif snapSize > maxSnapSize {\n\t\tlogs.Error(ctx).Int(\"SnapSize\", snapSize).\n\t\t\tInt(\"MaxSnapSize\", maxSnapSize).Msg(\"SNAP_SIZE_LARGER_THAN_MAX_SIZE\")\n\t\tsnapSize = maxSnapSize\n\t}\n\n\tagg.SnapRecord.SnapSize = snapSize\n\tagg.SnapRecord.Percent = percent\n\tagg.SnapRecord.Status = snapStatus\n\n\tsnapRepo := registry.GetRegistry(ctx).AdapterRepos.SnapRepo.(adapter_interfaces.SnapInterface)\n\terr := snapRepo.UpdateCreatingPercent(ctx, agg.SnapRecord)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/model.go",
        "code_start_line": 10,
        "code_end_line": 12,
        "code_key": "Model",
        "code_value": "type Model struct {\n\tId ID `json:\"id\" gorm:\"primaryKey;autoIncrement;comment:主键\"`\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/snap.go:64:75:GetExpiredSnapDeadlineInfo": {
    "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/snap.go",
    "code_start_line": 64,
    "code_end_line": 75,
    "code_start_column": 20,
    "code_key": "GetExpiredSnapDeadlineInfo",
    "code_value": "func (r *SnapRepo) GetExpiredSnapDeadlineInfo(ctx context.Context, appId int64, deadline time.Time) ([]*ccdb.CSnap, error) {\n\tdb, err := r.getCCDBDb(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar snapList []*ccdb.CSnap\n\tdb.Select(\"snapInstanceId\", \"deadline1\").\n\t\tWhere(\"appId = ? and lifeState = ? and deadline1 is not null and deadline1 < ?\", appId, \"normal\", deadline).\n\t\tFind(&snapList)\n\treturn snapList, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 123,
        "code_end_line": 131,
        "code_key": "GetSnapRealChargeTimes",
        "code_value": "func (snapSrv *SnapSrv) GetSnapRealChargeTimes(appId user.AppId, chargeTime time.Time) map[ResourceId]time.Time {\n\tsnapList, _ := snapSrv.snapRepo.GetExpiredSnapDeadlineInfo(snapSrv.ctx, int64(appId), chargeTime)\n\n\tsnapIdDeadlineMap := make(map[ResourceId]time.Time, len(snapList))\n\tfor _, snap := range snapList {\n\t\tsnapIdDeadlineMap[ResourceId(snap.SnapInstanceId)] = snap.Deadline\n\t}\n\treturn snapIdDeadlineMap\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/adapter/db/ccdb/model.go",
        "code_start_line": 7,
        "code_end_line": 46,
        "code_key": "CSnap",
        "code_value": "type CSnap struct {\n\tID               int64     `gorm:\"column:Id;primaryKey\"`\n\tAppId            int64     `gorm:\"column:appId\"`\n\tCbsId            int64     `gorm:\"column:cbsId\"`\n\tCbsInstanceId    string    `gorm:\"column:cbsInstanceId\"`\n\tCbsUuid          string    `gorm:\"column:cbsUuid\"`\n\tDiskSize         int       `gorm:\"column:diskSize\"`\n\tDiskType         string    `gorm:\"column:diskType\"`\n\tCreateTime       time.Time `gorm:\"column:createTime\"`\n\tModifyTime       time.Time `gorm:\"column:modifyTime\"`\n\tPercent          int       `gorm:\"column:percent\"`\n\tProjectId        int       `gorm:\"column:projectId\"`\n\tSnapInstanceId   string    `gorm:\"column:snapInstanceId;uniuq_index\"`\n\tSnapName         string    `gorm:\"column:snapName\"`\n\tSnapSize         int       `gorm:\"column:snapSize\"`\n\tSnapUuid         string    `gorm:\"column:snapUuid;uniuq_index\"`\n\tStatus           int       `gorm:\"column:status\"`\n\tVmBlockSize      int       `gorm:\"column:vmBlockSize;default:0\"`\n\tZone             int       `gorm:\"column:zone\"`\n\tZoneId           int       `gorm:\"column:zoneId\"`\n\tDeletedTime      time.Time `gorm:\"column:deletedTime\"`\n\tIsPermanent      int       `gorm:\"column:isPermanent\"`\n\tDeadlineNew      time.Time `gorm:\"column:deadline\"`\n\tDeadline         time.Time `gorm:\"column:deadline1\"`\n\tLifeState        string    `gorm:\"column:lifeState\"`\n\tFlag             int       `gorm:\"column:flag\"`\n\tArchType         string    `gorm:\"column:archType\"`\n\tExtraInfo        string    `gorm:\"column:extraInfo\"`\n\tEncrypt          string    `gorm:\"column:encrypt\"`\n\tCopyFromRemote   int       `gorm:\"column:copyFromRemote\"`\n\tCopyingToRegions string    `gorm:\"column:copyingToRegions\"`\n\tBackendSnap      int       `gorm:\"column:backendSnap\"`\n\tShareReference   int       `gorm:\"column:shareReference\"`\n\tAttribute        string    `gorm:\"column:attribute\"`\n\tTranId           string    `gorm:\"column:tranId\"`\n\tDealName         string    `gorm:\"column:dealName\"`\n\tAspInstanceId    string    `gorm:\"column:aspInstanceId\"`\n\tOutpostId        string    `gorm:\"column:outpostId\"`\n\tSavePlace        string    `gorm:\"column:savePlace\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/adapter/db/ccdb/model.go",
        "code_start_line": 48,
        "code_end_line": 50,
        "code_key": "TableName",
        "code_value": "func (CSnap) TableName() string {\n\treturn \"cSnap\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/db/ccdb/model.go",
        "code_start_line": 7,
        "code_end_line": 46,
        "code_key": "CSnap",
        "code_value": "type CSnap struct {\n\tID               int64     `gorm:\"column:Id;primaryKey\"`\n\tAppId            int64     `gorm:\"column:appId\"`\n\tCbsId            int64     `gorm:\"column:cbsId\"`\n\tCbsInstanceId    string    `gorm:\"column:cbsInstanceId\"`\n\tCbsUuid          string    `gorm:\"column:cbsUuid\"`\n\tDiskSize         int       `gorm:\"column:diskSize\"`\n\tDiskType         string    `gorm:\"column:diskType\"`\n\tCreateTime       time.Time `gorm:\"column:createTime\"`\n\tModifyTime       time.Time `gorm:\"column:modifyTime\"`\n\tPercent          int       `gorm:\"column:percent\"`\n\tProjectId        int       `gorm:\"column:projectId\"`\n\tSnapInstanceId   string    `gorm:\"column:snapInstanceId;uniuq_index\"`\n\tSnapName         string    `gorm:\"column:snapName\"`\n\tSnapSize         int       `gorm:\"column:snapSize\"`\n\tSnapUuid         string    `gorm:\"column:snapUuid;uniuq_index\"`\n\tStatus           int       `gorm:\"column:status\"`\n\tVmBlockSize      int       `gorm:\"column:vmBlockSize;default:0\"`\n\tZone             int       `gorm:\"column:zone\"`\n\tZoneId           int       `gorm:\"column:zoneId\"`\n\tDeletedTime      time.Time `gorm:\"column:deletedTime\"`\n\tIsPermanent      int       `gorm:\"column:isPermanent\"`\n\tDeadlineNew      time.Time `gorm:\"column:deadline\"`\n\tDeadline         time.Time `gorm:\"column:deadline1\"`\n\tLifeState        string    `gorm:\"column:lifeState\"`\n\tFlag             int       `gorm:\"column:flag\"`\n\tArchType         string    `gorm:\"column:archType\"`\n\tExtraInfo        string    `gorm:\"column:extraInfo\"`\n\tEncrypt          string    `gorm:\"column:encrypt\"`\n\tCopyFromRemote   int       `gorm:\"column:copyFromRemote\"`\n\tCopyingToRegions string    `gorm:\"column:copyingToRegions\"`\n\tBackendSnap      int       `gorm:\"column:backendSnap\"`\n\tShareReference   int       `gorm:\"column:shareReference\"`\n\tAttribute        string    `gorm:\"column:attribute\"`\n\tTranId           string    `gorm:\"column:tranId\"`\n\tDealName         string    `gorm:\"column:dealName\"`\n\tAspInstanceId    string    `gorm:\"column:aspInstanceId\"`\n\tOutpostId        string    `gorm:\"column:outpostId\"`\n\tSavePlace        string    `gorm:\"column:savePlace\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/db/ccdb/model.go",
        "code_start_line": 48,
        "code_end_line": 50,
        "code_key": "TableName",
        "code_value": "func (CSnap) TableName() string {\n\treturn \"cSnap\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/snap.go:82:91:GetSnapBalanceRecords": {
    "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/snap.go",
    "code_start_line": 82,
    "code_end_line": 91,
    "code_start_column": 20,
    "code_key": "GetSnapBalanceRecords",
    "code_value": "func (r *SnapRepo) GetSnapBalanceRecords(ctx context.Context, resourceId string, chargeTime time.Time) ([]*ccdb.CSnapBalance, error) {\n\tdb, err := r.getCCDBDb(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar cSnapBalance []*ccdb.CSnapBalance\n\tdb.Where(\"resourceId = ? and lastBalanceTime < ? and status = 1\", resourceId, chargeTime).Find(&cSnapBalance)\n\treturn cSnapBalance, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/service.go",
        "code_start_line": 208,
        "code_end_line": 217,
        "code_key": "BuildResChargeItem",
        "code_value": "func (cbsSrv *CbsSrv) BuildResChargeItem(u *user.User, resourceId ResourceId, chargeTime time.Time) *ChargeItem {\n\tcbsMeasureRepo := cbsSrv.balanceRepo.(repositories.CbsBalanceRepoIFace)\n\tbalanceRecords, _ := cbsMeasureRepo.GetCbsBalanceRecords(cbsSrv.ctx, string(resourceId), chargeTime, false)\n\n\tif len(balanceRecords) == 0 {\n\t\treturn nil\n\t}\n\n\treturn cbsSrv.convertToChargeItem(u, resourceId, balanceRecords, chargeTime)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 133,
        "code_end_line": 236,
        "code_key": "BuildResChargeItem",
        "code_value": "func (snapSrv *SnapSrv) BuildResChargeItem(u *user.User, resourceId ResourceId, chargeTime time.Time) *ChargeItem {\n\t// 获取符合条件的balanceRecord并根据chargeTime排序\n\tbalanceRecords, _ := snapSrv.snapRepo.GetSnapBalanceRecords(snapSrv.ctx, string(resourceId), chargeTime)\n\n\t// FIXME 临时方案：用内存里的lastBalanceTime覆盖balanceRecords里的balanceTime\n\tfor _, balanceRecord := range balanceRecords {\n\t\tlastBalanceTime, ok := snapSrv.lastBalanceTimeCache[balanceRecord.ID]\n\t\tif ok {\n\t\t\tbalanceRecord.LastBalanceTime = lastBalanceTime\n\t\t}\n\t}\n\n\tif len(balanceRecords) == 0 {\n\t\treturn nil\n\t}\n\tsort.Slice(balanceRecords, func(i, j int) bool {\n\t\tif balanceRecords[i].LastBalanceTime.Equal(balanceRecords[j].LastBalanceTime) {\n\t\t\treturn balanceRecords[i].OperationType < balanceRecords[j].OperationType\n\t\t}\n\t\treturn balanceRecords[i].LastBalanceTime.Before(balanceRecords[j].LastBalanceTime)\n\t})\n\n\t// 区分国内站和国际站用户\n\tvar userArea Area\n\tif u.IsI18nUser() {\n\t\tuserArea = AreaI18n\n\t} else {\n\t\tuserArea = AreaChina\n\t}\n\tisGrayUser, err := u.CheckFeature(user.USER_FLAG_SNAP_GRAY_USER)\n\tif err != nil {\n\t\tlogs.Error(snapSrv.ctx).Err(err).Int64(\"appId\", int64(u.AppId)).Msg(\"CHECK_GRAY_USER_ERR\")\n\t\t// 出错时标记为非灰度用户，避免重复推量\n\t\tisGrayUser = false\n\t}\n\n\tchargeItem := &ChargeItem{\n\t\t// FIXME: 需要从配置文件中获取region id\n\t\tRegionId:     snapSrv.regionId,\n\t\tZoneId:       balanceRecords[0].ZoneID,\n\t\tAppId:        u.AppId,\n\t\tUin:          u.Uin,\n\t\tUserArea:     userArea,\n\t\tIsGrayUser:   isGrayUser,\n\t\tResourceId:   resourceId,\n\t\tResourceArea: snapSrv.regionArea,\n\t\tItems:        make([]*SubItem, 0, len(balanceRecords)),\n\t}\n\n\t// 虚拟计费条目，用于确定endBalanceTime\n\tendBalanceRecord := &ccdb.CSnapBalance{LastBalanceTime: chargeTime.Add(time.Second * -1)}\n\tallBalances := append(balanceRecords, endBalanceRecord)\n\n\tfor i, balanceRecord := range allBalances[1:] {\n\t\tbeginBalanceRecord := balanceRecords[i]\n\t\t// 资源欠费，不收取费用\n\t\tif beginBalanceRecord.OperationType == int(SnapOpArrearage) {\n\t\t\tlogs.Info(snapSrv.ctx).Uint64(\"appId\", uint64(u.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"RESOURCE_ARREARAGE\")\n\t\t\tcontinue\n\t\t}\n\t\t// 资源已退还。退还后还产生了计费条目，非期望行为\n\t\tif beginBalanceRecord.OperationType == int(SnapOpReturn) {\n\t\t\tlogs.Info(snapSrv.ctx).Uint64(\"appId\", uint64(u.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"SNAP_HAS_RETURNED\")\n\t\t\tbreak\n\t\t}\n\n\t\t// 资源正常\n\t\tstartTime := beginBalanceRecord.LastBalanceTime\n\t\tendTime := balanceRecord.LastBalanceTime\n\t\tcurTime := startTime\n\t\tfor endTime.After(curTime) {\n\t\t\tcurHourEnd := time.Date(curTime.Year(), curTime.Month(), curTime.Day(), curTime.Hour(), 59, 59, 0, curTime.Location())\n\t\t\tif !endTime.After(curHourEnd) {\n\t\t\t\t// 同一周期\n\t\t\t\tsubItem := &SubItem{\n\t\t\t\t\tPid:       PidSnap,\n\t\t\t\t\tStartTime: curTime,\n\t\t\t\t\tEndTime:   endTime,\n\t\t\t\t\tSubValueDetail: map[string]interface{}{\n\t\t\t\t\t\t\"Size\": beginBalanceRecord.SnapSize},\n\t\t\t\t}\n\t\t\t\tchargeItem.Items = append(chargeItem.Items, subItem)\n\t\t\t\tcurTime = endTime.Add(time.Second)\n\t\t\t} else {\n\t\t\t\t// 非同一周期，先构建这个周期的\n\t\t\t\tsubItem := &SubItem{\n\t\t\t\t\tStartTime: curTime,\n\t\t\t\t\tEndTime:   curHourEnd,\n\t\t\t\t\tSubValueDetail: map[string]interface{}{\n\t\t\t\t\t\t\"Size\": beginBalanceRecord.SnapSize,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\tchargeItem.Items = append(chargeItem.Items, subItem)\n\t\t\t\tcurTime = curHourEnd.Add(time.Second)\n\t\t\t}\n\n\t\t}\n\t}\n\tif len(chargeItem.Items) == 0 {\n\t\treturn nil\n\t}\n\n\treturn chargeItem\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 247,
        "code_end_line": 264,
        "code_key": "BuildResChargeItem",
        "code_value": "func (cbsSrv *CbsSrv) BuildResChargeItem(u *user.User, resourceId ResourceId, chargeTime time.Time) *ChargeItem {\n\tcbsMeasureRepo := cbsSrv.measureRepo.(CbsMeasureRepoIFace)\n\tbalanceRecords, _ := cbsMeasureRepo.GetCbsBalanceRecords(cbsSrv.ctx, string(resourceId), chargeTime, false)\n\n\t// FIXME 临时方案：用内存里的lastBalanceTime覆盖balanceRecords里的balanceTime\n\tfor _, balanceRecord := range balanceRecords {\n\t\tlastBalanceTime, ok := cbsSrv.lastBalanceTimeCache[balanceRecord.ID]\n\t\tif ok {\n\t\t\tbalanceRecord.LastBalanceTime = lastBalanceTime\n\t\t}\n\t}\n\n\tif len(balanceRecords) == 0 {\n\t\treturn nil\n\t}\n\n\treturn cbsSrv.convertToChargeItem(u, resourceId, balanceRecords, chargeTime)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/adapter/db/ccdb/model.go",
        "code_start_line": 73,
        "code_end_line": 88,
        "code_key": "CSnapBalance",
        "code_value": "type CSnapBalance struct {\n\tID              int64     `gorm:\"column:id;primaryKey\"`\n\tAppID           int64     `gorm:\"column:appId;primaryKey\"`\n\tResourceID      string    `gorm:\"column:resourceId;unique\"`\n\tCid             int       `gorm:\"column:cid\"`\n\tConfig          string    `gorm:\"column:config\"`\n\tSnapSize        int       `gorm:\"column:snapSize;default:0\"`\n\tZoneID          int       `gorm:\"column:zoneId\"`\n\tPid             int       `gorm:\"column:pid\"`\n\tCreateTime      time.Time `gorm:\"column:createTime\"`\n\tLastBalanceTime time.Time `gorm:\"column:lastBalanceTime\"`\n\tOperationType   int       `gorm:\"column:operationType\"`\n\tResourceInfo    string    `gorm:\"column:resourceInfo\"`\n\tStatus          int       `gorm:\"column:status\"`\n\tSeqID           string    `gorm:\"column:seqId;default:'0'\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/adapter/db/ccdb/model.go",
        "code_start_line": 90,
        "code_end_line": 92,
        "code_key": "TableName",
        "code_value": "func (CSnapBalance) TableName() string {\n\treturn \"cSnapBalance\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/db/ccdb/model.go",
        "code_start_line": 73,
        "code_end_line": 88,
        "code_key": "CSnapBalance",
        "code_value": "type CSnapBalance struct {\n\tID              int64     `gorm:\"column:id;primaryKey\"`\n\tAppID           int64     `gorm:\"column:appId;primaryKey\"`\n\tResourceID      string    `gorm:\"column:resourceId;unique\"`\n\tCid             int       `gorm:\"column:cid\"`\n\tConfig          string    `gorm:\"column:config\"`\n\tSnapSize        int       `gorm:\"column:snapSize;default:0\"`\n\tZoneID          int       `gorm:\"column:zoneId\"`\n\tPid             int       `gorm:\"column:pid\"`\n\tCreateTime      time.Time `gorm:\"column:createTime\"`\n\tLastBalanceTime time.Time `gorm:\"column:lastBalanceTime\"`\n\tOperationType   int       `gorm:\"column:operationType\"`\n\tResourceInfo    string    `gorm:\"column:resourceInfo\"`\n\tStatus          int       `gorm:\"column:status\"`\n\tSeqID           string    `gorm:\"column:seqId;default:'0'\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/db/ccdb/model.go",
        "code_start_line": 90,
        "code_end_line": 92,
        "code_key": "TableName",
        "code_value": "func (CSnapBalance) TableName() string {\n\treturn \"cSnapBalance\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/image_snap_rollback.go:16:29:QueryImageSnapRollbackByStatus": {
    "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/image_snap_rollback.go",
    "code_start_line": 16,
    "code_end_line": 29,
    "code_start_column": 33,
    "code_key": "QueryImageSnapRollbackByStatus",
    "code_value": "func (r *ImageSnapRollbackRepo) QueryImageSnapRollbackByStatus(ctx context.Context, status string) ([]*des.TCbsImageSnapRollbackRecord, error) {\n\tdb, err := r.getDesDb(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar rollbackList []*des.TCbsImageSnapRollbackRecord\n\n\tresult := db.Where(\"status = ?\", status).Find(&rollbackList)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\treturn rollbackList, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_rollback_task_scanner.go",
        "code_start_line": 72,
        "code_end_line": 101,
        "code_key": "getImageSnapRollbackTask",
        "code_value": "func (s *UpdateRollbackTaskScanner) getImageSnapRollbackTask(ctx context.Context) error {\n\t// ImageSnapRecord表回滚进度更新任务\n\timageSnapRbRepo := registry.GetRegistry(ctx).AdapterRepos.ImageSnapRollbackRepo.(adapter_interfaces.ImageSnapRollbackInterface)\n\timageSnapRbList, err := imageSnapRbRepo.QueryImageSnapRollbackByStatus(ctx, des.ImageSnapRbMigrating)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, imageSnapRbRecord := range imageSnapRbList {\n\t\tentity := &diskLogical.RollbackingEntity{\n\t\t\tImageSnapRollbackRecord: imageSnapRbRecord,\n\t\t}\n\t\trollbackType := entity.GetRollbackType()\n\t\tsubTaskName := core.UpdateOrderRBTask\n\t\tif rollbackType == des.FastRollback {\n\t\t\tsubTaskName = core.UpdateFastRBTask\n\t\t} else if rollbackType == des.ImageCache {\n\t\t\tsubTaskName = core.UpdateTriggerRBTask\n\t\t} else {\n\t\t\tsubTaskName = core.UpdateOrderRBTask\n\t\t}\n\t\tdiskRollbackAgg := &diskLogical.DiskRollbackingTaskAggregate{\n\t\t\tDiskEntity:        nil,\n\t\t\tRollbackingEntity: entity,\n\t\t\tTaskName:          core.UpdateImageSnapRBTask,\n\t\t\tSubTaskName:       subTaskName,\n\t\t}\n\t\ts.resultChan <- diskRollbackAgg\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/db/des/model.go",
        "code_start_line": 5,
        "code_end_line": 22,
        "code_key": "TCbsImageSnapRollbackRecord",
        "code_value": "type TCbsImageSnapRollbackRecord struct {\n\tId          int64     `gorm:\"column:id;primaryKey\"`\n\tAppId       int64     `gorm:\"column:appId\"`\n\tCbsUuid     string    `gorm:\"column:cbsUuid\"`\n\tSnapUuid    string    `gorm:\"column:snapUuid\"`\n\tStatus      string    `gorm:\"column:status\"`\n\tPercent     int       `gorm:\"column:percent\"`\n\tStorageUuid string    `gorm:\"column:storageUuid\"`\n\tMigrateType string    `gorm:\"column:migrateType\"`\n\tArchType    string    `gorm:\"column:archType\"`\n\tVolumeType  string    `gorm:\"column:volumeType\"`\n\tPool        string    `gorm:\"column:pool\"`\n\tZoneId      int       `gorm:\"column:zoneId\"`\n\tUserGroup   string    `gorm:\"column:userGroup\"`\n\tStartTime   time.Time `gorm:\"column:startTime\"`\n\tEndTime     time.Time `gorm:\"column:endTime\"`\n\tUpdateTime  time.Time `gorm:\"column:updateTime\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/db/des/model.go",
        "code_start_line": 24,
        "code_end_line": 26,
        "code_key": "TableName",
        "code_value": "func (TCbsImageSnapRollbackRecord) TableName() string {\n\treturn \"t_cbs_image_snap_rollback_record\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/benchmark/benchmark.go",
        "code_start_line": 25,
        "code_end_line": 25,
        "code_key": "Status",
        "code_value": "type Status int",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/image_snap_rollback.go:31:49:UpdateImageSnapRollbackPercent": {
    "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/repositories/image_snap_rollback.go",
    "code_start_line": 31,
    "code_end_line": 49,
    "code_start_column": 33,
    "code_key": "UpdateImageSnapRollbackPercent",
    "code_value": "func (r *ImageSnapRollbackRepo) UpdateImageSnapRollbackPercent(ctx context.Context, imageSnapRbRecord *des.TCbsImageSnapRollbackRecord) error {\n\tdb, err := r.getDesDb(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tchanges := make(map[string]interface{})\n\tchanges[\"percent\"] = imageSnapRbRecord.Percent\n\tchanges[\"status\"] = imageSnapRbRecord.Status\n\tif imageSnapRbRecord.Status == des.ImageSnapRbDone {\n\t\timageSnapRbRecord.EndTime = time.Now()\n\t\tchanges[\"endTime\"] = imageSnapRbRecord.EndTime\n\t}\n\tresult := db.Model(imageSnapRbRecord).Where(\"id = ?\", imageSnapRbRecord.Id).Updates(changes)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/diskLogical/service.go",
        "code_start_line": 56,
        "code_end_line": 106,
        "code_key": "UpdateImageSnapRollbackingPercent",
        "code_value": "func (s *DiskRollbackingServicesImpl) UpdateImageSnapRollbackingPercent(ctx context.Context, agg *DiskRollbackingTaskAggregate) (bool, error) {\n\tisFinish := false\n\n\tpercent := -1 // -1不会更新表中的内容\n\trStatus := des.ImageSnapRbMigrating\n\n\tshmSrv := common.ShmConfService{}\n\tlockTime := time.Now().Truncate(shmSrv.GetTriggerTaskLockTime(ctx))\n\n\tif agg.SubTaskName == core.UpdateTriggerRBTask && agg.ImageSnapRollbackRecord.StartTime.Before(lockTime) {\n\t\t// 长时间未完成的trigger任务直接置为done\n\t\tlogs.Info(ctx).Interface(\"StartTime\", agg.ImageSnapRollbackRecord.StartTime).Msg(\"MARK_TRIGGER_ROLLBACK_FINISHED\")\n\t\trStatus = des.ImageSnapRbDone\n\t} else {\n\t\tsnapPhySrv := registry.GetRegistry(ctx).DomainServices.SnapPhyService.(snapPhysical.SnapPhyServiceInterface)\n\t\trsp, err := snapPhySrv.QueryDiskRollbackingPercent(ctx, agg.ImageSnapRollbackRecord.AppId, agg.ImageSnapRollbackRecord.CbsUuid, agg.ImageSnapRollbackRecord.ArchType)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\n\t\tpercent = rsp.Percent\n\t\ttaskStatus := rsp.Status\n\t\tif taskStatus == 1 {\n\t\t\t// 已完成回滚，盘的状态为正常\n\t\t\tpercent = 100\n\t\t} else if taskStatus == 2 {\n\t\t\tpercent = 0\n\t\t} else if taskStatus == 3 {\n\t\t\tif agg.ImageSnapRollbackRecord.Percent > percent {\n\t\t\t\t// 如果更新的进度小于已经记录的进度，\n\t\t\t\t// 说明用户可能发起了多次重装，当前的record已经被重置了，直接标记为已完成。\n\t\t\t\tlogs.Info(ctx).Int(\"OldPercent\", agg.ImageSnapRollbackRecord.Percent).Int(\"NewPercent\", percent).Msg(\"IMAGE_SNAP_MIGR_REC_EXPIRED\")\n\t\t\t\tpercent = 100\n\t\t\t}\n\t\t} else if taskStatus == 5 {\n\t\t\t// 取消任务时直接标记为已完成\n\t\t\trStatus = des.ImageSnapRbDone\n\t\t} else {\n\t\t\tpercent = 100\n\t\t\tlogs.Error(ctx).Int(\"TaskStatus\", taskStatus).Msg(\"UNKNOWN_STATUS\")\n\t\t}\n\t}\n\terr := agg.UpdateImageSnapRollbackingPercent(ctx, percent, rStatus)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif percent >= 100 || rStatus == des.ImageSnapRbDone {\n\t\tisFinish = true\n\t}\n\treturn isFinish, err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/diskLogical/model.go",
        "code_start_line": 55,
        "code_end_line": 71,
        "code_key": "UpdateImageSnapRollbackingPercent",
        "code_value": "func (agg *DiskRollbackingTaskAggregate) UpdateImageSnapRollbackingPercent(ctx context.Context, percent int, rStatus des.ImageSnapRollbackRecordStatus) error {\n\tagg.ImageSnapRollbackRecord.Status = rStatus\n\tif percent >= agg.ImageSnapRollbackRecord.Percent {\n\t\tif percent >= 100 {\n\t\t\tagg.ImageSnapRollbackRecord.Percent = 100\n\t\t\tagg.ImageSnapRollbackRecord.Status = des.ImageSnapRbDone\n\t\t} else {\n\t\t\tagg.ImageSnapRollbackRecord.Percent = percent\n\t\t}\n\t}\n\timageSnapRbRepo := registry.GetRegistry(ctx).AdapterRepos.ImageSnapRollbackRepo.(adapter_interfaces.ImageSnapRollbackInterface)\n\terr := imageSnapRbRepo.UpdateImageSnapRollbackPercent(ctx, agg.ImageSnapRollbackRecord)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/model.go",
        "code_start_line": 10,
        "code_end_line": 12,
        "code_key": "Model",
        "code_value": "type Model struct {\n\tId ID `json:\"id\" gorm:\"primaryKey;autoIncrement;comment:主键\"`\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/uow.go:96:106:New": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/uow.go",
    "code_start_line": 96,
    "code_end_line": 106,
    "code_start_column": 32,
    "code_key": "New",
    "code_value": "func (u unitOfWorkFactoryImpl) New() dddcore.UnitOfWork {\n\tuow := &unitOfWork{\n\t\ttx:                    u.db.Begin(),\n\t\ttrackedPhyVolumes:     newTracker[*rdiskDomain.PhysicalVolume](updatePhysicalVolume),\n\t\ttrackedLogicalVolumes: newTracker[*rdiskDomain.LogicalVolume](updateLogicalVolume),\n\t\ttrackedDRGroups:       newTracker[*drgroup.DRGroup](updateDRGroup),\n\t\ttrackedBackups:        newTracker[*backup.Backup](updateBackup),\n\t\ttrackedBenchmarks:     newTracker[*benchmark.Benchmark](updateBenchmark),\n\t}\n\treturn uow\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/cmd/main.go",
        "code_start_line": 21,
        "code_end_line": 26,
        "code_key": "main",
        "code_value": "func main() {\n\tif err := rootCmd.Execute(); err != nil {\n\t\t_, _ = fmt.Fprintf(os.Stderr, \"cbs_packing_srv run failed %s\\n\", err)\n\t\tos.Exit(-1)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/cmd/main.go",
        "code_start_line": 22,
        "code_end_line": 28,
        "code_key": "main",
        "code_value": "func main() {\n\tif err := rootCmd.Execute(); err != nil {\n\t\teCode := -1\n\t\t_, _ = fmt.Fprintf(os.Stderr, \"sheduler run failed: %s\\n\", err.Error())\n\t\tos.Exit(eCode)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/cmd/main.go",
        "code_start_line": 18,
        "code_end_line": 24,
        "code_key": "main",
        "code_value": "func main() {\n\tif err := rootCmd.Execute(); err != nil {\n\t\teCode := -1\n\t\t_, _ = fmt.Fprintf(os.Stderr, \"sheduler run failed: %s\\n\", err.Error())\n\t\tos.Exit(eCode)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/clients/trade_client/main/main.go",
        "code_start_line": 20,
        "code_end_line": 50,
        "code_key": "main",
        "code_value": "func main() {\n\treq := APIRequestBody{\n\t\tVersion:       1,\n\t\tComponentName: \"example\",\n\t\tPassword:      \"password\",\n\t\tEventID:       \"123\",\n\t\tTimestamp:     1234567890,\n\t\tRequestInterface: struct {\n\t\t\tInterfaceName string                 `json:\"interfaceName\"`\n\t\t\tPara          map[string]interface{} `json:\"para\"`\n\t\t}{\n\t\t\tInterfaceName: \"exampleInterface\",\n\t\t\tPara: map[string]interface{}{\n\t\t\t\t\"param1\": \"value1\",\n\t\t\t\t\"param2\": 123,\n\t\t\t},\n\t\t},\n\t}\n\n\treqBody := make(map[string]interface{})\n\tv := reflect.ValueOf(req)\n\tt := reflect.TypeOf(req)\n\n\tfor i := 0; i < v.NumField(); i++ {\n\t\tfield := v.Field(i)\n\t\ttag := t.Field(i).Tag.Get(\"json\")\n\t\treqBody[tag] = field.Interface()\n\t}\n\n\tfmt.Println(reqBody)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/hademo/hademo.go",
        "code_start_line": 73,
        "code_end_line": 88,
        "code_key": "main",
        "code_value": "func main() {\n\tdb := initDB()\n\tlocker := initLocker(db)\n\n\t// read identity from cmdline args\n\tidentityP := flag.String(\"identity\", \"server1\", \"server identity\")\n\tflag.Parse()\n\n\tmanager := easyha.New(\n\t\t&server{identity: *identityP},\n\t\tlocker,\n\t\teasyha.WithNamespace(\"hademo\"),\n\t)\n\n\tmanager.Start(context.Background())\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/cmd/rdisk_master/main.go",
        "code_start_line": 19,
        "code_end_line": 25,
        "code_key": "main",
        "code_value": "func main() {\n\tif err := rootCmd.Execute(); err != nil {\n\t\teCode := -1\n\t\t_, _ = fmt.Fprintf(os.Stderr, \"rdisk master run failed %s\\n\", err)\n\t\tos.Exit(eCode)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/generate/errgen/errgen.go",
        "code_start_line": 38,
        "code_end_line": 87,
        "code_key": "main",
        "code_value": "func main() {\n\tlog.SetFlags(0)\n\tlog.SetPrefix(\"stringer: \")\n\tflag.Usage = Usage\n\tflag.Parse()\n\n\t// We accept either one directory or a list of files. Which do we have?\n\targs := flag.Args()\n\tif len(args) == 0 {\n\t\t// Default: process whole package in current directory.\n\t\targs = []string{\".\"}\n\t}\n\tvar dir string\n\tg := Generator{\n\t\ttrimPrefix: \"_\",\n\t}\n\tif trimPrefix != nil && *trimPrefix != \"\" {\n\t\tg.trimPrefix = *trimPrefix\n\t}\n\tif len(args) == 1 && isDirectory(args[0]) {\n\t\tdir = args[0]\n\t} else {\n\t\tdir = filepath.Dir(args[0])\n\t}\n\n\tg.parsePackage(args)\n\n\t// Print the header and package clause.\n\tg.Printf(\"// Code generated by \\\"errgen %s\\\"; DO NOT EDIT.\\n\", strings.Join(os.Args[1:], \" \"))\n\tg.Printf(\"\\n\")\n\tg.Printf(\"package %s\", g.pkg.name)\n\tg.Printf(\"\\n\")\n\n\tg.generate()\n\n\t// Format the output.\n\tsrc := g.format()\n\n\t// Write to file.\n\toutputName := *output\n\tif outputName == \"\" {\n\t\tbaseName := \"gen_errors.go\"\n\t\toutputName = filepath.Join(dir, strings.ToLower(baseName))\n\t}\n\t// NOCA:path_traversal(设计如此)\n\terr := os.WriteFile(outputName, src, 0o644) //nolint:gosec //标准权限\n\tif err != nil {\n\t\tlog.Fatalf(\"writing output: %s\", err)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/cmd/initialize/apiserver.go",
        "code_start_line": 16,
        "code_end_line": 49,
        "code_key": "logRequestFilter",
        "code_value": "func logRequestFilter(ctx context.Context, req interface{}, next filter.ServerHandleFunc) (rsp interface{}, err error) {\n\tmsg := trpc.Message(ctx)\n\taddr := msg.RemoteAddr()\n\tstartTime := time.Now()\n\t// 目前方案是每个请求生成一个 seqId，后续可以考虑使用 traceId\n\tseqId := uuid.New().String()\n\tlogger := logs.GetLogger(ctx)\n\tif logger != nil {\n\t\tctx = logger.With().Str(\"seqId\", seqId).Logger().WithContext(ctx)\n\t}\n\tlogs.Info(ctx).Interface(\"req\", req).\n\t\tStr(\"action\", msg.CalleeMethod()).\n\t\tStr(\"caller\", addr.String()).\n\t\tMsg(\"NEW_REQUEST\")\n\trsp, err = next(ctx, req)\n\tendTime := time.Now()\n\tif err == nil {\n\t\tlogs.Info(ctx).Interface(\"req\", req).\n\t\t\tInterface(\"rsp\", rsp).\n\t\t\tStr(\"action\", msg.CalleeMethod()).\n\t\t\tStr(\"caller\", addr.String()).\n\t\t\tDur(\"cost\", endTime.Sub(startTime)).\n\t\t\tMsg(\"API_SUCCESS\")\n\t} else {\n\t\tlogs.Warn(ctx).\n\t\t\tInterface(\"req\", req).\n\t\t\tErr(err).Interface(\"rsp\", rsp).\n\t\t\tStr(\"action\", msg.CalleeMethod()).\n\t\t\tStr(\"caller\", addr.String()).\n\t\t\tDur(\"cost\", endTime.Sub(startTime)).\n\t\t\tMsg(\"API_ERROR\")\n\t}\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 799,
        "code_end_line": 818,
        "code_key": "logRequestFilter",
        "code_value": "func logRequestFilter(ctx context.Context, req interface{}, next filter.ServerHandleFunc) (rsp interface{}, err error) {\n\tmsg := trpc.Message(ctx)\n\taddr := msg.RemoteAddr()\n\tstartTime := time.Now()\n\t// 目前方案是每个请求生成一个 seqId，后续可以考虑使用 traceId\n\tseqId := uuid.New().String()\n\tlogger := logs.GetLogger(ctx)\n\tif logger != nil {\n\t\tctx = logger.With().Str(\"seqId\", seqId).Logger().WithContext(ctx)\n\t}\n\tlogs.Info(ctx).Interface(\"params\", req).Str(\"action\", msg.CalleeMethod()).Str(\"caller\", addr.String()).Msg(\"NEW_REQUEST\")\n\trsp, err = next(ctx, req)\n\tendTime := time.Now()\n\tif err == nil {\n\t\tlogs.Info(ctx).Interface(\"params\", req).Interface(\"result\", rsp).Str(\"caller\", addr.String()).Dur(\"cost\", endTime.Sub(startTime)).Msg(\"API_SUCCESS\")\n\t} else {\n\t\tlogs.Warn(ctx).Interface(\"params\", req).Err(err).Interface(\"result\", rsp).Str(\"caller\", addr.String()).Dur(\"cost\", endTime.Sub(startTime)).Msg(\"API_ERROR\")\n\t}\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/cmd/initialize/ha.go",
        "code_start_line": 53,
        "code_end_line": 58,
        "code_key": "GetIdentity",
        "code_value": "func (h *HAEngine) GetIdentity() string {\n\tif ip := utils.GetLocalIP(); ip != \"\" {\n\t\treturn ip\n\t}\n\tpanic(\"Packing HA Manager GetIdentity failed\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/hademo/hademo.go",
        "code_start_line": 43,
        "code_end_line": 45,
        "code_key": "GetIdentity",
        "code_value": "func (s *server) GetIdentity() string {\n\treturn s.identity\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/scheduler.go",
        "code_start_line": 61,
        "code_end_line": 66,
        "code_key": "GetIdentity",
        "code_value": "func (*scheduler) GetIdentity() string {\n\tif ip := getLocalIP(); ip != \"\" {\n\t\treturn ip\n\t}\n\treturn uuid.New().String()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/cmd/initialize/ha.go",
        "code_start_line": 89,
        "code_end_line": 102,
        "code_key": "NewHAManager",
        "code_value": "func (h *HAEngine) NewHAManager(ctx context.Context) easyha.HAManager {\n\thaManager := easyha.New(h,\n\t\tapp.GlobalRegistry.DLocker,\n\t\teasyha.WithNamespace(\"cbs-packing\"),\n\t\teasyha.WithLockExpired(10*time.Second),\n\t\teasyha.WithCheckInterval(5*time.Second),\n\t\teasyha.WithLogger(*logs.GetLogger(ctx)))\n\n\tif h.manager != nil {\n\t\th.manager.Close(ctx)\n\t}\n\th.manager = haManager\n\treturn haManager\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/cmd/initialize/dlock.go",
        "code_start_line": 11,
        "code_end_line": 26,
        "code_key": "InitDLocker",
        "code_value": "func InitDLocker(ctx context.Context) {\n\tdbInstance, err := (&app.GlobalRegistry.AppConfig.DesDb).DB()\n\tif err != nil {\n\t\tlogs.Fatal(ctx).Err(err).Msg(\"init des db instance failed.\")\n\t}\n\tdLockerConf := dlock_mysql.Config{\n\t\tTableName:      \"packing_lock\",\n\t\tLockColumn:     \"lock_key\",\n\t\tExpireColumn:   \"expired\",\n\t\tTokenColumn:    \"lock_token\", // NOCA:PasswordLeak(误报)\n\t\tLockTypeColumn: \"lock_type\",\n\t\tLockNumsColumn: \"lock_count\",\n\t}\n\tdLocker := dlock_mysql.New(dbInstance, dLockerConf)\n\tapp.GlobalRegistry.RegisterDLocker(dLocker)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/infra/response/errors.go",
        "code_start_line": 28,
        "code_end_line": 30,
        "code_key": "TRPCError",
        "code_value": "func TRPCError(code int, text string) error {\n\treturn errors.New(code, text)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/app/api/api.go",
        "code_start_line": 43,
        "code_end_line": 125,
        "code_key": "ApplyRemoteDiskVolume",
        "code_value": "func (s *PackingApiImpl) ApplyRemoteDiskVolume(\n\tctx context.Context,\n\treq *pb.ApplyRemoteDiskVolumeRequest,\n) (*pb.ApplyRemoteDiskVolumeResponse, error) {\n\tappCtx := context.WithValue(ctx, app.GetApplicationContextName(), app.GlobalRegistry.AppContext)\n\t// HA决策, 所有流量转到Master执行\n\tif !app.GlobalRegistry.HAEngine.IsMaster() {\n\t\treturn app.GlobalRegistry.HAEngine.BuildMasterNode(appCtx).ApplyRemoteDiskVolume(appCtx, req)\n\t}\n\n\tif err := s.checkApplyReq(req); err != nil {\n\t\treturn nil, err\n\t}\n\n\tuser := account.NewUser(int(req.AppId), req.Uin, req.SubAccountUin)\n\taffinityConfig := affi.AffinityFacade{}.ConvertToAffinityConfig(req.PlacementGroupSet, req.PlacementPolicy)\n\n\t// 优先尝试从子组池中申请已创建的盘\n\tsubGroupSrv, err := services.NewSubGroupPoolService(appCtx, user, affinityConfig)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\toneDisk := subGroupSrv.ApplyPoolDisks(appCtx)\n\n\t// 子组池申领成功则直接返回\n\tif oneDisk != nil {\n\t\tlogs.Info(appCtx).\n\t\t\tInt(\"app_id\", int(req.AppId)).\n\t\t\tStr(\"disk_uuid\", string(oneDisk.DiskUuid)).\n\t\t\tStr(\"sub_group\", affinityConfig.GetSubGroupId(appCtx)).\n\t\t\tMsg(\"APPLY_REMOTE_DISK_FROM_SUB_GROUP_POOL_SUC\")\n\t\treturn &pb.ApplyRemoteDiskVolumeResponse{\n\t\t\tDiskVolumeSet: []*pb.DiskVolumeModel{\n\t\t\t\t{DiskUuid: string(oneDisk.DiskUuid)},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// 子组池不存在则为首次申领, 通过事件总线进行新建申领\n\tdiskCount := req.PlacementGroupSet[0].GetSubGroupMemberCount()\n\tbusContext := flow.NewPackDiskBusContext(\n\t\tuser,\n\t\ttypes.DiskSize(req.DiskSize),\n\t\ttypes.ZoneId(req.ZoneId),\n\t\ttypes.DiskCount(diskCount),\n\t\tdisk.RemoteDisk,\n\t\taffinityConfig,\n\t\ttypes.PerformanceRank(req.PerformanceRank))\n\n\teventBusDriver := event_bus.NewEventBusDriver().\n\t\tSetBusContext(appCtx, busContext).\n\t\tRegisterEvent(appCtx, event_bus.ApplyRDEvent, &PackingDomain.RemoteDiskPackService{}).\n\t\tRegisterEvent(appCtx, event_bus.CreateRDEvent, &ProductionDomain.CreateRemoteDiskService{}).\n\t\tPublishBusEvents(appCtx)\n\n\tresult := eventBusDriver.Execute(appCtx)\n\tif result.IsFailed() {\n\t\tsubGroupSrv.ClosePool(ctx)\n\t\tlogs.Info(appCtx).Err(result).Int(\"ERROR_CODE\", int(result.Code)).Msg(\"APPLY_REMOTE_DISK_FAILED\")\n\t\treturn nil, result.ToTRPCError()\n\t}\n\n\t//首次申领, 申领成功之后入子组池, 后续该子组申领直接从子组池中领取\n\terr = subGroupSrv.PushPool(appCtx, busContext.Disks[1:])\n\n\tif err != nil {\n\t\tlogs.Info(appCtx).Err(err).\n\t\t\tUint64(\"app_id\", req.AppId).\n\t\t\tStr(\"sub_group\", affinityConfig.GetSubGroupId(appCtx)).\n\t\t\tMsg(\"PUSH_SUB_GROUP_POOL_FAILED\")\n\t\treturn nil, err\n\t}\n\n\tdiskVolumeSet := make([]*pb.DiskVolumeModel, 0, 100)\n\tfor _, diskObj := range busContext.Disks[:1] {\n\t\tdiskVolumeSet = append(diskVolumeSet, &pb.DiskVolumeModel{\n\t\t\tDiskUuid: string(diskObj.DiskUuid),\n\t\t})\n\t}\n\n\trsp := &pb.ApplyRemoteDiskVolumeResponse{DiskVolumeSet: diskVolumeSet}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv.trpc.go",
        "code_start_line": 140,
        "code_end_line": 142,
        "code_key": "ApplyRemoteDiskVolume",
        "code_value": "func (s *UnimplementedApi) ApplyRemoteDiskVolume(ctx context.Context, req *ApplyRemoteDiskVolumeRequest) (*ApplyRemoteDiskVolumeResponse, error) {\n\treturn nil, errors.New(\"rpc ApplyRemoteDiskVolume of service Api is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv.trpc.go",
        "code_start_line": 189,
        "code_end_line": 207,
        "code_key": "ApplyRemoteDiskVolume",
        "code_value": "func (c *ApiClientProxyImpl) ApplyRemoteDiskVolume(ctx context.Context, req *ApplyRemoteDiskVolumeRequest, opts ...client.Option) (*ApplyRemoteDiskVolumeResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.cbs.packing.api/ApplyRemoteDiskVolume\")\n\tmsg.WithCalleeServiceName(ApiServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"cbs\")\n\tmsg.WithCalleeServer(\"packing\")\n\tmsg.WithCalleeService(\"api\")\n\tmsg.WithCalleeMethod(\"ApplyRemoteDiskVolume\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &ApplyRemoteDiskVolumeResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv_mock.go",
        "code_start_line": 39,
        "code_end_line": 45,
        "code_key": "ApplyRemoteDiskVolume",
        "code_value": "func (m *MockApiService) ApplyRemoteDiskVolume(ctx context.Context, req *ApplyRemoteDiskVolumeRequest) (*ApplyRemoteDiskVolumeResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"ApplyRemoteDiskVolume\", ctx, req)\n\tret0, _ := ret[0].(*ApplyRemoteDiskVolumeResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv_mock.go",
        "code_start_line": 48,
        "code_end_line": 51,
        "code_key": "ApplyRemoteDiskVolume",
        "code_value": "func (mr *MockApiServiceMockRecorder) ApplyRemoteDiskVolume(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ApplyRemoteDiskVolume\", reflect.TypeOf((*MockApiService)(nil).ApplyRemoteDiskVolume), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv_mock.go",
        "code_start_line": 122,
        "code_end_line": 132,
        "code_key": "ApplyRemoteDiskVolume",
        "code_value": "func (m *MockApiClientProxy) ApplyRemoteDiskVolume(ctx context.Context, req *ApplyRemoteDiskVolumeRequest, opts ...client.Option) (*ApplyRemoteDiskVolumeResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"ApplyRemoteDiskVolume\", varargs...)\n\tret0, _ := ret[0].(*ApplyRemoteDiskVolumeResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv_mock.go",
        "code_start_line": 135,
        "code_end_line": 139,
        "code_key": "ApplyRemoteDiskVolume",
        "code_value": "func (mr *MockApiClientProxyMockRecorder) ApplyRemoteDiskVolume(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ApplyRemoteDiskVolume\", reflect.TypeOf((*MockApiClientProxy)(nil).ApplyRemoteDiskVolume), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/app/api/api.go",
        "code_start_line": 128,
        "code_end_line": 134,
        "code_key": "ReplaceRemoteDiskVolume",
        "code_value": "func (s *PackingApiImpl) ReplaceRemoteDiskVolume(\n\tctx context.Context,\n\treq *pb.ReplaceRemoteDiskVolumeRequest,\n) (*pb.ReplaceRemoteDiskVolumeResponse, error) {\n\trsp := &pb.ReplaceRemoteDiskVolumeResponse{}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv.trpc.go",
        "code_start_line": 145,
        "code_end_line": 147,
        "code_key": "ReplaceRemoteDiskVolume",
        "code_value": "func (s *UnimplementedApi) ReplaceRemoteDiskVolume(ctx context.Context, req *ReplaceRemoteDiskVolumeRequest) (*ReplaceRemoteDiskVolumeResponse, error) {\n\treturn nil, errors.New(\"rpc ReplaceRemoteDiskVolume of service Api is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv.trpc.go",
        "code_start_line": 209,
        "code_end_line": 227,
        "code_key": "ReplaceRemoteDiskVolume",
        "code_value": "func (c *ApiClientProxyImpl) ReplaceRemoteDiskVolume(ctx context.Context, req *ReplaceRemoteDiskVolumeRequest, opts ...client.Option) (*ReplaceRemoteDiskVolumeResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.cbs.packing.api/ReplaceRemoteDiskVolume\")\n\tmsg.WithCalleeServiceName(ApiServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"cbs\")\n\tmsg.WithCalleeServer(\"packing\")\n\tmsg.WithCalleeService(\"api\")\n\tmsg.WithCalleeMethod(\"ReplaceRemoteDiskVolume\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &ReplaceRemoteDiskVolumeResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv_mock.go",
        "code_start_line": 84,
        "code_end_line": 90,
        "code_key": "ReplaceRemoteDiskVolume",
        "code_value": "func (m *MockApiService) ReplaceRemoteDiskVolume(ctx context.Context, req *ReplaceRemoteDiskVolumeRequest) (*ReplaceRemoteDiskVolumeResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"ReplaceRemoteDiskVolume\", ctx, req)\n\tret0, _ := ret[0].(*ReplaceRemoteDiskVolumeResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv_mock.go",
        "code_start_line": 93,
        "code_end_line": 96,
        "code_key": "ReplaceRemoteDiskVolume",
        "code_value": "func (mr *MockApiServiceMockRecorder) ReplaceRemoteDiskVolume(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ReplaceRemoteDiskVolume\", reflect.TypeOf((*MockApiService)(nil).ReplaceRemoteDiskVolume), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv_mock.go",
        "code_start_line": 182,
        "code_end_line": 192,
        "code_key": "ReplaceRemoteDiskVolume",
        "code_value": "func (m *MockApiClientProxy) ReplaceRemoteDiskVolume(ctx context.Context, req *ReplaceRemoteDiskVolumeRequest, opts ...client.Option) (*ReplaceRemoteDiskVolumeResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"ReplaceRemoteDiskVolume\", varargs...)\n\tret0, _ := ret[0].(*ReplaceRemoteDiskVolumeResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv_mock.go",
        "code_start_line": 195,
        "code_end_line": 199,
        "code_key": "ReplaceRemoteDiskVolume",
        "code_value": "func (mr *MockApiClientProxyMockRecorder) ReplaceRemoteDiskVolume(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ReplaceRemoteDiskVolume\", reflect.TypeOf((*MockApiClientProxy)(nil).ReplaceRemoteDiskVolume), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/app/api/api.go",
        "code_start_line": 137,
        "code_end_line": 177,
        "code_key": "InquireRemoteDiskStock",
        "code_value": "func (s *PackingApiImpl) InquireRemoteDiskStock(\n\tctx context.Context,\n\treq *pb.InquireRemoteDiskStockRequest,\n) (*pb.InquireDiskStockResponse, error) {\n\tappCtx := context.WithValue(ctx, app.GetApplicationContextName(), app.GlobalRegistry.AppContext)\n\n\tinquireStockContext := flow.NewInquireDiskStockBusContext(\n\t\taccount.NewUser(int(req.AppId), req.Uin, req.SubAccountUin),\n\t\ttypes.ZoneId(req.ZoneId), types.DiskSize(req.DiskSize),\n\t\taffi.AffinityFacade{}.ConvertToAffinityConfig(req.PlacementGroupSet, nil),\n\t\ttypes.PerformanceRank(req.PerformanceRank))\n\n\tif !app.GlobalRegistry.HAEngine.IsMaster() {\n\t\treturn app.GlobalRegistry.HAEngine.BuildMasterNode(appCtx).InquireRemoteDiskStock(ctx, req)\n\t}\n\n\teventBusDriver := event_bus.NewEventBusDriver().\n\t\tSetBusContext(appCtx, inquireStockContext).\n\t\tRegisterEvent(appCtx, event_bus.InquireDiskStockEvent, &InventoryDomain.InquireRemoteDiskStockService{}).\n\t\tPublishBusEvents(appCtx)\n\tresult := eventBusDriver.Execute(appCtx)\n\n\tif result.IsFailed() {\n\t\tlogs.Info(appCtx).Err(result).Int(\"err_code\", int(result.Code)).Msg(\"INQUIRE_REMOTE_DISK_FAILED\")\n\t\treturn nil, result.ToTRPCError()\n\t}\n\n\tstockModelSet := make([]*pb.DiskStockModel, 0, 10)\n\tstockModelSet = append(stockModelSet, inquireStockContext.DiskStockModel)\n\trsp := &pb.InquireDiskStockResponse{DiskStockModelSet: stockModelSet}\n\n\tlogs.Info(appCtx).\n\t\tInt(\"app_id\", int(req.AppId)).\n\t\tInt(\"disk_size\", int(req.DiskSize)).\n\t\tInt(\"zone_id\", int(req.ZoneId)).\n\t\tStrs(\"group_id\", inquireStockContext.AffinityConfig.GetAllPlacementGroupId(ctx)).\n\t\tInt(\"stock_count\", int(inquireStockContext.DiskStockModel.GetStockCount())).\n\t\tMsg(\"INQUIRE_REMOTE_DISK_STOCK_SUC\")\n\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv.trpc.go",
        "code_start_line": 150,
        "code_end_line": 152,
        "code_key": "InquireRemoteDiskStock",
        "code_value": "func (s *UnimplementedApi) InquireRemoteDiskStock(ctx context.Context, req *InquireRemoteDiskStockRequest) (*InquireDiskStockResponse, error) {\n\treturn nil, errors.New(\"rpc InquireRemoteDiskStock of service Api is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv.trpc.go",
        "code_start_line": 229,
        "code_end_line": 247,
        "code_key": "InquireRemoteDiskStock",
        "code_value": "func (c *ApiClientProxyImpl) InquireRemoteDiskStock(ctx context.Context, req *InquireRemoteDiskStockRequest, opts ...client.Option) (*InquireDiskStockResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.cbs.packing.api/InquireRemoteDiskStock\")\n\tmsg.WithCalleeServiceName(ApiServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"cbs\")\n\tmsg.WithCalleeServer(\"packing\")\n\tmsg.WithCalleeService(\"api\")\n\tmsg.WithCalleeMethod(\"InquireRemoteDiskStock\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &InquireDiskStockResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv_mock.go",
        "code_start_line": 69,
        "code_end_line": 75,
        "code_key": "InquireRemoteDiskStock",
        "code_value": "func (m *MockApiService) InquireRemoteDiskStock(ctx context.Context, req *InquireRemoteDiskStockRequest) (*InquireDiskStockResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"InquireRemoteDiskStock\", ctx, req)\n\tret0, _ := ret[0].(*InquireDiskStockResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv_mock.go",
        "code_start_line": 78,
        "code_end_line": 81,
        "code_key": "InquireRemoteDiskStock",
        "code_value": "func (mr *MockApiServiceMockRecorder) InquireRemoteDiskStock(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"InquireRemoteDiskStock\", reflect.TypeOf((*MockApiService)(nil).InquireRemoteDiskStock), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv_mock.go",
        "code_start_line": 162,
        "code_end_line": 172,
        "code_key": "InquireRemoteDiskStock",
        "code_value": "func (m *MockApiClientProxy) InquireRemoteDiskStock(ctx context.Context, req *InquireRemoteDiskStockRequest, opts ...client.Option) (*InquireDiskStockResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"InquireRemoteDiskStock\", varargs...)\n\tret0, _ := ret[0].(*InquireDiskStockResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv_mock.go",
        "code_start_line": 175,
        "code_end_line": 179,
        "code_key": "InquireRemoteDiskStock",
        "code_value": "func (mr *MockApiClientProxyMockRecorder) InquireRemoteDiskStock(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"InquireRemoteDiskStock\", reflect.TypeOf((*MockApiClientProxy)(nil).InquireRemoteDiskStock), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/app/api/api.go",
        "code_start_line": 180,
        "code_end_line": 231,
        "code_key": "CalculateSetWeigherScore",
        "code_value": "func (s *PackingApiImpl) CalculateSetWeigherScore(\n\tctx context.Context,\n\treq *pb.CalculateSetWeigherScoreRequest,\n) (*pb.CalculateSetWeigherScoreResponse, error) {\n\n\tappCtx := context.WithValue(ctx, app.GetApplicationContextName(), app.GlobalRegistry.AppContext)\n\n\trulePackingBusContext := &flow.SetPackingBusContext{\n\t\tAppId:              types.AppId{AppId: int(req.AppId)},\n\t\tZoneId:             types.ZoneId(req.ZoneId),\n\t\tDiskSize:           types.DiskSize(req.DiskSize),\n\t\tSnapUuid:           types.SnapUuid(req.SnapUuid),\n\t\tDiskType:           types.DiskType(req.DiskType),\n\t\tPayMode:            types.PayMode(req.PayMode),\n\t\tOriginalVolumeType: req.OriginalVolumeType,\n\t\tConcreteVolumeType: req.ConcreteVolumeType,\n\t\tSetUuidList:        req.SetUuidList,\n\t\tCbsDiskTrait:       req.CbsDiskTrait,\n\t}\n\n\tif !app.GlobalRegistry.HAEngine.IsMaster() {\n\t\treturn app.GlobalRegistry.HAEngine.BuildMasterNode(appCtx).CalculateSetWeigherScore(ctx, req)\n\t}\n\n\teventBusDriver := event_bus.NewEventBusDriver().\n\t\tSetBusContext(appCtx, rulePackingBusContext).\n\t\tRegisterEvent(appCtx, event_bus.SetPackingEvent, &PackingDomain.CloudPackSetService{}).\n\t\tPublishBusEvents(appCtx)\n\n\tresult := eventBusDriver.Execute(appCtx)\n\n\tif result.IsFailed() {\n\t\tlogs.Info(appCtx).Err(result).Int(\"err_code\", int(result.Code)).Msg(\"CALCULATE_SET_WEIGHER_SCORE_FAILED\")\n\t\treturn nil, result.ToTRPCError()\n\t}\n\n\tscoreMap := make(map[string]int32)\n\tfor setUuid, scoreList := range rulePackingBusContext.SetScoreMap {\n\t\tscoreMap[setUuid] = scoreList[0]\n\t}\n\n\tlogs.Info(appCtx).\n\t\tInt(\"app_id\", int(req.AppId)).\n\t\tInterface(\"score_map\", scoreMap).\n\t\tMsg(\"CALCULATE_SET_WEIGHER_SCORE_SUCCESS\")\n\n\trsp := &pb.CalculateSetWeigherScoreResponse{\n\t\tSetScoreMap: scoreMap,\n\t}\n\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv.trpc.go",
        "code_start_line": 155,
        "code_end_line": 157,
        "code_key": "CalculateSetWeigherScore",
        "code_value": "func (s *UnimplementedApi) CalculateSetWeigherScore(ctx context.Context, req *CalculateSetWeigherScoreRequest) (*CalculateSetWeigherScoreResponse, error) {\n\treturn nil, errors.New(\"rpc CalculateSetWeigherScore of service Api is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv.trpc.go",
        "code_start_line": 249,
        "code_end_line": 267,
        "code_key": "CalculateSetWeigherScore",
        "code_value": "func (c *ApiClientProxyImpl) CalculateSetWeigherScore(ctx context.Context, req *CalculateSetWeigherScoreRequest, opts ...client.Option) (*CalculateSetWeigherScoreResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.cbs.packing.api/CalculateSetWeigherScore\")\n\tmsg.WithCalleeServiceName(ApiServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"cbs\")\n\tmsg.WithCalleeServer(\"packing\")\n\tmsg.WithCalleeService(\"api\")\n\tmsg.WithCalleeMethod(\"CalculateSetWeigherScore\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &CalculateSetWeigherScoreResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv_mock.go",
        "code_start_line": 54,
        "code_end_line": 60,
        "code_key": "CalculateSetWeigherScore",
        "code_value": "func (m *MockApiService) CalculateSetWeigherScore(ctx context.Context, req *CalculateSetWeigherScoreRequest) (*CalculateSetWeigherScoreResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CalculateSetWeigherScore\", ctx, req)\n\tret0, _ := ret[0].(*CalculateSetWeigherScoreResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv_mock.go",
        "code_start_line": 63,
        "code_end_line": 66,
        "code_key": "CalculateSetWeigherScore",
        "code_value": "func (mr *MockApiServiceMockRecorder) CalculateSetWeigherScore(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CalculateSetWeigherScore\", reflect.TypeOf((*MockApiService)(nil).CalculateSetWeigherScore), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv_mock.go",
        "code_start_line": 142,
        "code_end_line": 152,
        "code_key": "CalculateSetWeigherScore",
        "code_value": "func (m *MockApiClientProxy) CalculateSetWeigherScore(ctx context.Context, req *CalculateSetWeigherScoreRequest, opts ...client.Option) (*CalculateSetWeigherScoreResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"CalculateSetWeigherScore\", varargs...)\n\tret0, _ := ret[0].(*CalculateSetWeigherScoreResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv_mock.go",
        "code_start_line": 155,
        "code_end_line": 159,
        "code_key": "CalculateSetWeigherScore",
        "code_value": "func (mr *MockApiClientProxyMockRecorder) CalculateSetWeigherScore(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CalculateSetWeigherScore\", reflect.TypeOf((*MockApiClientProxy)(nil).CalculateSetWeigherScore), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/expiremap.go",
        "code_start_line": 91,
        "code_end_line": 96,
        "code_key": "Delete",
        "code_value": "func (e *ExpiredMap) Delete(key interface{}) {\n\te.lck.Lock()\n\tdelete(e.m, key)\n\te.deleteTimeMap(key)\n\te.lck.Unlock()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/scheduler.go",
        "code_start_line": 135,
        "code_end_line": 139,
        "code_key": "Delete",
        "code_value": "func (s *scheduler) Delete(name string) {\n\ts.mutex.Lock()\n\tdefer s.mutex.Unlock()\n\tdelete(s.loads, name)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/benchmark.go",
        "code_start_line": 32,
        "code_end_line": 39,
        "code_key": "Delete",
        "code_value": "func (repo *rdiskBenchmarkRepositoryImpl) Delete(ctx context.Context, bench *benchmark.Benchmark) error {\n\tuow := getUow(ctx)\n\tresult := uow.tx.Delete(&metadb.DmRdiskBenchmark{}, \"id = ?\", bench.ID)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/backup.go",
        "code_start_line": 34,
        "code_end_line": 41,
        "code_key": "Delete",
        "code_value": "func (*rdiskBackupRepositoryImpl) Delete(ctx context.Context, backup *backupPkg.Backup) error {\n\tuow := getUow(ctx)\n\tresult := uow.tx.Delete(&metadb.DmRdiskBackup{}, \"id = ?\", backup.ID)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go",
        "code_start_line": 73,
        "code_end_line": 81,
        "code_key": "Delete",
        "code_value": "func (p *physicalVolumeRepositoryImpl) Delete(ctx context.Context, pv *rdiskDomain.PhysicalVolume) error {\n\tuow := getUow(ctx)\n\tidt := pv.GetID()\n\tresult := uow.tx.Where(\"id = ?\", idt).Delete(&metadb.DmPhydisk{})\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
        "code_start_line": 111,
        "code_end_line": 122,
        "code_key": "Delete",
        "code_value": "func (d drgroupRepositoryImpl) Delete(ctx context.Context, group *drgroup.DRGroup) error {\n\tuow := getUow(ctx)\n\tresult := uow.tx.Delete(&metadb.DmDrgroup{}, \"id = ?\", group.ID)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tresult = uow.tx.Delete(&metadb.DmDrgroupMembers{}, \"app_id = ? and group_name = ?\", group.AppID, group.Name)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 356,
        "code_end_line": 363,
        "code_key": "Delete",
        "code_value": "func (l *LogicalVolume) Delete() error {\n\tif len(l.Attachments) > 0 {\n\t\treturn errors.New(ErrVolumeAttached, \"volume is still attached to some hosts\")\n\t}\n\tl.PhysicalVolume = nil\n\tl.State = LVSDeleted\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 54,
        "code_end_line": 59,
        "code_key": "Delete",
        "code_value": "func (m *MockPhysicalVolumeRepository) Delete(arg0 context.Context, arg1 *rdiskDomain.PhysicalVolume) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Delete\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 62,
        "code_end_line": 65,
        "code_key": "Delete",
        "code_value": "func (mr *MockPhysicalVolumeRepositoryMockRecorder) Delete(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Delete\", reflect.TypeOf((*MockPhysicalVolumeRepository)(nil).Delete), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 54,
        "code_end_line": 59,
        "code_key": "Delete",
        "code_value": "func (m *MockRepository) Delete(arg0 context.Context, arg1 *drgroup.DRGroup) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Delete\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 62,
        "code_end_line": 65,
        "code_key": "Delete",
        "code_value": "func (mr *MockRepositoryMockRecorder) Delete(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Delete\", reflect.TypeOf((*MockRepository)(nil).Delete), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go",
        "code_start_line": 51,
        "code_end_line": 72,
        "code_key": "Handle",
        "code_value": "func (c *CbsAppIdConsumer) Handle(ctx context.Context, delivery *rabbitmq.Delivery) error {\n\tu, chargeTime, err := c.ParseDelivery(ctx, delivery)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif u == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"USER_INFO_NOT_FOUND\")\n\t\treturn nil\n\t}\n\n\tchargeDetail := c.GetChargeDetailForSingleUser(u, chargeTime)\n\tif chargeDetail == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tUint64(\"appId\", uint64(u.AppId)).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"NO_RESOURCE_TO_CHARGE\")\n\t\treturn nil\n\t}\n\treturn c.ProcessChargeDetail(chargeDetail)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 105,
        "code_end_line": 116,
        "code_key": "Handle",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tif err := c.ensureLocks(ctx); err != nil {\n\t\treturn err\n\t}\n\tif c.lvUUID != nil {\n\t\t// 涉及到逻辑卷时，需要先标记逻辑卷为故障\n\t\treturn c.handleBindedVolume(ctx)\n\t} else {\n\t\t// 不涉及到逻辑卷时，直接标记物理卷为故障\n\t\treturn c.handleIdleVolume(ctx)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/detach_logical_volume.go",
        "code_start_line": 56,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *DetachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDetachLogicalVolume, c)\n\n\t// 如果没有挂载到指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume not attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_benchmark_task.go",
        "code_start_line": 125,
        "code_end_line": 165,
        "code_key": "Handle",
        "code_value": "func (c *CreateBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tvolSm     = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = volSm.Fire(ctx, c.relatedVolume.State, domain.PVEStartBenchmark, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark = benchmark.New(benchmark.DiskInfo{\n\t\tSerial: string(c.relatedVolume.Serial),\n\t\tHostIP: c.relatedVolume.IP,\n\t\tBDF:    string(c.relatedVolume.BDF),\n\t})\n\n\tif err = benchRepo.Add(ctx, c.relatedBenchmark); err != nil {\n\t\tdelegate := &benchmarkDelegate{cmd: c}\n\t\tif _err := delegate.TaskFinishCallback(ctx, c.relatedBenchmark); _err != nil {\n\t\t\tlogs.Warn(ctx).Err(_err).Str(\"serial\", string(c.relatedVolume.Serial)).Msg(\"failed to rollback: create bdev\")\n\t\t}\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventCreateBench,\n\t\tbenchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_logical_volume.go",
        "code_start_line": 71,
        "code_end_line": 108,
        "code_key": "Handle",
        "code_value": "func (d *DeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\td.volume, err = repo.FindByID(ctx, d.UUID)\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif e := d.volume.CheckDelete(); e != nil {\n\t\treturn e\n\t}\n\n\tif d.volume.AppID != d.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"refuse to delet: app id mismatch\")\n\t}\n\n\td.drgroup, err = app.GetRegistry(ctx).Repositories.DRGroup.FindByMember(ctx, d.AppID, d.volume.UUID.String())\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\td.drgroup = nil\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := d.checkDRGroupMatch(ctx); err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, d.volume.State, rdiskDomain.LVEMarkToRecycle, d)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_recycled_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmRecycledPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEConfirmRecycled, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_rdisk_backup.go",
        "code_start_line": 52,
        "code_end_line": 75,
        "code_key": "Handle",
        "code_value": "func (c *DeleteRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tsm   = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\tc.relatedBackup, err = repo.FindByUUID(ctx, c.BackupID.String())\n\tif err != nil || c.relatedBackup == nil || c.relatedBackup.AppID != c.AppID {\n\t\treturn errors.New(backupDomain.ErrBackupNotExist, \"backup not exists\")\n\t}\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tc.relatedBackup.Status,\n\t\tbackupDomain.EventSoftDeleteBackup,\n\t\tbackupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: c.relatedBackup})\n\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_rdisk_backup.go",
        "code_start_line": 47,
        "code_end_line": 80,
        "code_key": "Handle",
        "code_value": "func (c *CreateRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tlvSm  = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\tbakSm = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo  = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t_, err = lvSm.Fire(ctx, c.relatedVolume.State, rdiskDomain.LVEBackupStarted, c)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tlv := c.relatedVolume\n\tbackup := backupDomain.New(\n\t\tlv.AppID,\n\t\tbackupDomain.DiskInfo{\n\t\t\tVolumeUUID: lv.UUID,\n\t\t\tVolumeSize: uint64(lv.Size),\n\t\t\tHostIP:     lv.PhysicalVolume.IP,\n\t\t\tHostBDF:    string(lv.PhysicalVolume.BDF),\n\t\t\tSerial:     string(lv.PhysicalVolume.Serial),\n\t\t},\n\t)\n\tif err := repo.Add(ctx, backup); err != nil {\n\t\treturn err\n\t}\n\tc.relatedBackup = backup\n\t_, err = bakSm.Fire(ctx, backupDomain.StatusInit, backupDomain.EventStartBackup, backupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: backup})\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/attach_logical_volume.go",
        "code_start_line": 49,
        "code_end_line": 71,
        "code_key": "Handle",
        "code_value": "func (c *AttachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEAttachLogicalVolume, c)\n\n\t// 如果已经挂载到了指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeAlreadyAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume already attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_delete_logical_volume.go",
        "code_start_line": 34,
        "code_end_line": 55,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\t// 如果逻辑卷不存在，则直接返回成功\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"failed to confirm delete: app id mismatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDeleteLogicalVolume, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/offline_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OfflinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOfflinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *DeletePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\t// 如果物理卷不存在，则直接幂等返回\n\t\treturn nil\n\t}\n\n\tvar event = domain.PVEDeletePhysicalVolume\n\tif c.Force && (c.relatedVolume.State == domain.PVSDefunct) {\n\t\t// 这里的实现不太好，状态机的逻辑不应该侵入 cmd\n\t\t// 时间太赶了，后续重构优化吧\n\t\tevent = domain.PVEForceDeleteForDefunct\n\t}\n\n\tif c.relatedVolume.HasBindedPV() {\n\t\treturn errors.New(domain.ErrVolumeBusy, \"logic volume has binded to this physical volume\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, event, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_logical_volume.go",
        "code_start_line": 55,
        "code_end_line": 70,
        "code_key": "Handle",
        "code_value": "func (c *CleanupLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVECleanupLogicalVolume, c)\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_init_physical_volume.go",
        "code_start_line": 26,
        "code_end_line": 52,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmInitPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\tif c.relatedVolume.IP.String() != c.Host.String() {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume host ip mistmatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVECreatePhysicalVolumeOnHost, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_physical_volume.go",
        "code_start_line": 51,
        "code_end_line": 101,
        "code_key": "Handle",
        "code_value": "func (c *CreatePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\n\t// 获取物理卷状态机\n\tsm := app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\trepo := app.GetRegistry(ctx).Repositories.PhysicalVolume\n\n\t// 检查物理卷是否已经存在，如果存在则直接幂等返回\n\tvol1, err := repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"serial\", c.Serial).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tvol2, err := repo.FindByIPAndBDF(ctx, c.Host, domain.BDF(c.BDF))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"host\", c.Host.String()).Str(\"bdf\", c.BDF).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tfor _, vol := range []*domain.PhysicalVolume{vol1, vol2} {\n\t\texisted, err := c.checkExisting(ctx, vol)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif existed {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// 触发事件，创建物理卷\n\t_, err = sm.Fire(ctx,\n\t\tdomain.PVSUnInited,\n\t\tdomain.PVECreatePhysicalVolume,\n\t\tc,\n\t)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 创建 Bdev 以及格式化移动到创建物理卷的状态机中\n\n\t// _, err = sm.Fire(ctx,\n\t// \tc.GetPhysicalVolume().State,\n\t// \tdomain.PVECreatePhysicalVolumeOnHost,\n\t// \tc,\n\t// )\n\t// if err != nil {\n\t// \treturn err\n\t// }\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_benchmark_task.go",
        "code_start_line": 32,
        "code_end_line": 57,
        "code_key": "Handle",
        "code_value": "func (c *DeleteBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\terr       error\n\t)\n\n\tbench, err := benchRepo.FindByUUID(ctx, c.BenchmarkUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif bench.DiskInfo.Serial != c.Serial {\n\t\treturn errors.Newf(benchmark.ErrTaskNotFound, \"benchmark serial not match %s, want %s\", c.Serial, bench.DiskInfo.Serial)\n\t}\n\n\t_, err = benchSm.Fire(ctx, bench.Status, benchmark.EventDeleteBench, benchmark.Data{Benchmark: bench, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := benchRepo.Delete(ctx, bench); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_logical_volume.go",
        "code_start_line": 52,
        "code_end_line": 98,
        "code_key": "Handle",
        "code_value": "func (c *CreateLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tpvRepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tlvRepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm     = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\t// 1. 查找底层物理卷\n\tc.selectedPhysicalVolume, err = pvRepo.FindBySerial(ctx, rdiskDomain.Serial(c.PhysicalVolumeSerial))\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// 检查底层物理卷大小是否满足要求\n\tif c.selectedPhysicalVolume.Size < rdiskDomain.Size(c.DiskSize) {\n\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume size %d is smaller than requested size %d\", c.selectedPhysicalVolume.Size, c.DiskSize)\n\t}\n\n\t// 检查底层物理卷性能等级是否满足要求\n\tif c.PerformanceRank != \"\" {\n\t\tif string(c.selectedPhysicalVolume.PerformanceRank) != c.PerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not match requested rank %s\", c.selectedPhysicalVolume.PerformanceRank, c.PerformanceRank)\n\t\t}\n\t} else {\n\t\tif c.selectedPhysicalVolume.PerformanceRank != rdiskDomain.DefaultPerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not default rank %s\", c.selectedPhysicalVolume.PerformanceRank, rdiskDomain.DefaultPerformanceRank)\n\t\t}\n\t}\n\n\t// 2. 创建逻辑卷\n\tvol := rdiskDomain.NewLogicalVolume(users.AppID(c.AppID), rdiskDomain.Size(c.DiskSize), rdiskDomain.ZoneID(c.ZoneID))\n\tif c.VolumeType != \"\" {\n\t\tvol.VolumeType = rdiskDomain.VolumeType(c.VolumeType)\n\t}\n\tif c.DiskType != \"\" {\n\t\tvol.DiskType = rdiskDomain.DiskType(c.DiskType)\n\t}\n\terr = lvRepo.Add(ctx, vol)\n\tif err != nil {\n\t\treturn\n\t}\n\tc.createdLogicalVolume = vol\n\n\t// 3. 触发状态机，联动更新逻辑卷和物理卷状态\n\t_, err = sm.Fire(ctx, rdiskDomain.LVSUnInited, rdiskDomain.LVECreateLogicalVolume, c)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_running_backup_task.go",
        "code_start_line": 31,
        "code_end_line": 61,
        "code_key": "Handle",
        "code_value": "func (c *UpdateRunningBackupTaskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventUpdateBackupProgress,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_drgroup.go",
        "code_start_line": 78,
        "code_end_line": 173,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeDRGroupCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tlvView  = app.GetRegistry(ctx).Viewers.LogicalVolume\n\t\tdrgRepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t\tsm      = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\terr     error\n\t)\n\n\t// 0. 初始化\n\tc.drgroupRef = make(map[string]*drgroup.DRGroup)\n\n\t// 1. 加载所有逻辑卷所在的置放群组\n\tallVolumeUUIDs := make([]string, 0, len(c.UUIDs))\n\tfor _, _uuid := range c.UUIDs {\n\t\tallVolumeUUIDs = append(allVolumeUUIDs, _uuid.String())\n\t}\n\tif groups, err := drgRepo.FindByMembers(ctx, c.AppID, allVolumeUUIDs); err == nil {\n\t\tif err != nil {\n\t\t\tif !errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tfor _, group := range groups {\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t\tc.curDRGroupNames = append(c.curDRGroupNames, group.Name)\n\t\t}\n\t} else {\n\t\treturn err\n\t}\n\n\t// 2. 确认已上锁的置放群组和当前一致\n\tif !c.checkLockedDRGroupNames() {\n\t\treturn errors.New(drgroup.ErrGroupModified, \"drgroup changed\")\n\t}\n\n\t// 3. 加载所有逻辑卷的状态，不需要完整实体，因为不会修改 Volume\n\tc.relatedLogicalVolume, err = lvView.FindByIDs(ctx, c.AppID, c.UUIDs)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(c.relatedLogicalVolume) < len(c.UUIDs) {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t// 4. 加载所有目标置放群组，key 为 name\n\tfor _, spec := range c.Specs {\n\t\tvar group *drgroup.DRGroup\n\t\tif _, ok := c.drgroupRef[spec.Name]; ok {\n\t\t\tgroup = c.drgroupRef[spec.Name]\n\t\t} else {\n\t\t\tgroup, err = c.getOrCreateDRGroup(ctx, drgRepo, spec)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t}\n\n\t\tif spec.Affinity > 0 {\n\t\t\tgroup.Affinity = spec.Affinity\n\t\t}\n\t\tif spec.Type != \"\" {\n\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t}\n\t}\n\n\t// 5. 对所有逻辑卷执行置放群组变更事件，检查状态是否允许，\n\t//    实际的更新还是在这里执行。\n\tfor _, vol := range c.relatedLogicalVolume {\n\t\terr := sm.Check(ctx, vol.State, rdiskDomain.LVEUpdateDrGroup, c)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// 将逻辑卷从原有的置放群组中移除\n\t\tfor _, name := range c.curDRGroupNames {\n\t\t\tc.drgroupRef[name].RemoveMember(vol.UUID.String())\n\t\t}\n\t\t// 将逻辑卷添加到新的置放群组中\n\t\tfor _, spec := range c.Specs {\n\t\t\tsubGroup := spec.SubGroup\n\t\t\tif subGroup == \"\" {\n\t\t\t\t// 如果没有指定子组，则使用远端 SSD UUID 作为子组名称\n\t\t\t\t// 相当于每块盘都是一个子组，相当于没有使用子组功能\n\t\t\t\tsubGroup = vol.UUID.String()\n\t\t\t}\n\t\t\tif err := c.drgroupRef[spec.Name].AddMember(vol.UUID.String(), subGroup, vol.PhysicalVolume.IP.String()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tif c.DryRun {\n\t\treturn errors.New(errors.ErrDryRunSuccessExit, \"dry run check success\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/online_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OnlinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOnlinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_benchmark_task.go",
        "code_start_line": 34,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *UpdateBenchmarkTask) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, rdisk.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark, err = benchRepo.FindByUUID(ctx, c.BenchmarkUUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventUpdateBench, benchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_flow_ctrl.go",
        "code_start_line": 80,
        "code_end_line": 103,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeFlowControlCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not found\")\n\t}\n\n\tspec := c.volume.FlowControlSpec\n\tif !c.UpdateRequest.UpdateSpec(&spec, c.volume.GetDefaultFlowControlSpec()) {\n\t\t// 没有任何更新，直接返回成功\n\t\treturn nil\n\t}\n\tc.volume.SetFlowControlSpec(spec)\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEUpdateFlowControl, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_defunct_volume.go",
        "code_start_line": 46,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *CleanupDefunctCommand) Handle(ctx context.Context) error {\n\tvar err error\n\tc.lv, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar sm = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\tvar event = rdiskDomain.LVECleanupDefunct\n\n\tfor _, attachment := range c.lv.Attachments {\n\t\tlogs.Info(ctx).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).Msg(\"cleanup defuncting volume\")\n\t\tsubCmd := &cleanDefunctSubCommand{Parent: c, HostIP: attachment.IP}\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, subCmd)\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，因为只要有一个挂载点清理失败，其他挂载点还是需要继续清理的\n\t\t\t// 失败的挂载点会在后台继续清理\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).\n\t\t\t\tMsg(\"failed to cleanup defunct volume, retry later.\")\n\t\t}\n\t}\n\n\tif len(c.lv.Attachments) == 0 {\n\t\t// 没有挂载点，直接清理\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, &cleanDefunctSubCommand{Parent: c, HostIP: net.IP{}})\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，后续自动重试即可\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Msg(\"failed to complete cleanup defunct volume\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_drgroup_exists.go",
        "code_start_line": 28,
        "code_end_line": 53,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDRGroupExistsCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t)\n\tfor _, spec := range c.DRGroup {\n\t\t_, err := repo.FindByName(ctx, users.AppID(c.AppID), spec.Name)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\tgroup := drgroup.New(spec.Name, users.AppID(c.AppID))\n\t\t\t\tif spec.Affinity > 0 {\n\t\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t\t}\n\t\t\t\tif spec.Type != \"\" {\n\t\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t\t}\n\t\t\t\terr = repo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_physical_volume.go",
        "code_start_line": 31,
        "code_end_line": 54,
        "code_key": "Handle",
        "code_value": "func (c *UpdatePhyRDiskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEUpdatePhysicalVolume, c)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/recycle_backup_data.go",
        "code_start_line": 32,
        "code_end_line": 62,
        "code_key": "Handle",
        "code_value": "func (c *RecycleBackupDataCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventDeleteBackup,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/config/config.go",
        "code_start_line": 68,
        "code_end_line": 143,
        "code_key": "LoadConfig",
        "code_value": "func LoadConfig(raw *viper.Viper) (*Config, error) {\n\tconfig := &Config{\n\t\tGlobal: &GlobalConfig{\n\t\t\tPprofPort: uint16(raw.GetInt(\"global.pprofPort\")),\n\t\t\tTestEnv:   raw.GetBool(\"global.testEnv\"),\n\t\t\tTestUin:   raw.GetString(\"global.testUin\"),\n\t\t},\n\t\tRegionPipelines: make(map[string]*regionPipelineConfig),\n\t}\n\n\t// load base databases config\n\tbaseDbConfigMap := make(map[string]configs.MySQLConfig)\n\tdatabases := raw.GetStringMap(\"databases\")\n\tfor name, database := range databases {\n\t\tdbConfig := database.(map[string]interface{})\n\t\tprops := map[string]string{\n\t\t\t\"charset\": dbConfig[\"charset\"].(string),\n\t\t}\n\t\tbaseDbConfigMap[name] = configs.MySQLConfig{\n\t\t\tName:  dbConfig[\"db\"].(string),\n\t\t\tProps: props,\n\t\t}\n\t}\n\n\t// load base mq config\n\tbaseMqConfigMap := make(map[string]interface{})\n\tmessageQueues := raw.GetStringMap(\"messageQueues\")\n\tfor name, mqConfig := range messageQueues {\n\t\tbaseMqConfigMap[name] = mqConfig\n\t}\n\n\t// load base log config\n\tbaseLogConfig := logs.Config{\n\t\tLevel:               raw.GetString(\"log.level\"),\n\t\tEnableConsoleLogger: raw.GetBool(\"log.enableConsoleLogger\"),\n\t\tEnableFileLogger:    raw.GetBool(\"log.enableFileLogger\"),\n\t\tLogFileMaxBackups:   raw.GetInt(\"log.logFileMaxBackups\"),\n\t\tLogFileMaxAge:       raw.GetInt(\"log.logFileMaxAge\"),\n\t\tLogFileMaxSize:      raw.GetInt(\"log.logFileMaxSize\"),\n\t}\n\n\t// load base task config\n\tvar tasks []map[string]interface{}\n\tbaseTaskConfigMap := make(map[string]*TaskConfig)\n\terr := raw.UnmarshalKey(\"tasks\", &tasks)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unmarshal tasks failed: %s\", err.Error())\n\t}\n\tfor _, taskRaw := range tasks {\n\t\tname, ok := taskRaw[\"name\"].(string)\n\t\tif !ok {\n\t\t\treturn nil, fmt.Errorf(\"tasks name not found\")\n\t\t}\n\t\tbaseTaskConfigMap[name] = &TaskConfig{\n\t\t\tInterval:    taskRaw[\"interval\"].(int),\n\t\t\tMaxInterval: taskRaw[strings.ToLower(\"maxInterval\")].(int),\n\t\t}\n\t}\n\n\trawRegionPipelines := raw.GetStringMap(\"regions\")\n\tfor region, _ := range rawRegionPipelines {\n\t\trawRegionConfig := raw.Sub(fmt.Sprintf(\"regions.%s\", region))\n\t\tregionConfig, err := loadRegionConfig(rawRegionConfig, baseTaskConfigMap, baseDbConfigMap, baseMqConfigMap, baseLogConfig)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tconfig.RegionPipelines[region] = regionConfig\n\t}\n\n\t// load main log config\n\tbaseLogConfig.LogFileDir = raw.GetString(\"log.logFileDir\")\n\t//baseLogConfig.LogFileName = raw.GetString(\"log.logFileName\")\n\tconfig.MainLogConfig = &baseLogConfig\n\n\treturn config, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/configs/loader.go",
        "code_start_line": 12,
        "code_end_line": 20,
        "code_key": "LoadConfig",
        "code_value": "func LoadConfig(path string, receiver interface{}) error {\n\tviperIns := viper.New()\n\tviperIns.SetConfigFile(path)\n\n\tif err := viperIns.ReadInConfig(); err != nil {\n\t\treturn err\n\t}\n\treturn viperIns.Unmarshal(receiver)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/convertor.go",
        "code_start_line": 28,
        "code_end_line": 38,
        "code_key": "Start",
        "code_value": "func (a *Convertor) Start(ctx context.Context) error {\n\t// 启动转换器\n\tfor _, scanner := range a.scanners {\n\t\tscanner := scanner\n\t\tgo func() {\n\t\t\ta.convertToTask(ctx, scanner)\n\t\t}()\n\t}\n\tlogs.Info(ctx).Msgf(\"Convertor Start Success\")\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_rec_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *CbsMeasureReconciliationTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\t//s.resultChan <- struct{}{}\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_rec_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 35,
        "code_key": "Start",
        "code_value": "func (s *SnapMeasureReconciliationTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_compute_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *SnapComputeTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\t//s.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_measure_send_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *CbsMeasureSendTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_bill_valid_appId_fetch_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *CbsValidAppIdFetchTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_calculate_cost_locally_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 36,
        "code_key": "Start",
        "code_value": "func (s *SnapCalculateCostLocallyTaskScanner) Start(ctx context.Context) error {\n\t//s.resultChan <- struct{}{}\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_create_task_scanner.go",
        "code_start_line": 23,
        "code_end_line": 42,
        "code_key": "Start",
        "code_value": "func (s *UpdateCreateTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\trunning := true\n\t\tfor running {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\trunning = false\n\t\t\tdefault:\n\t\t\t\terr := s.FullScan(ctx)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogs.Fatal(ctx).Msgf(\"%s full scan failed!\\n\", s.name)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\ttime.Sleep(s.scanInterval)\n\t\t}\n\t}()\n\tlogs.Info(ctx).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_measure_send_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 36,
        "code_key": "Start",
        "code_value": "func (s *SnapMeasureSendTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\t//s.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/repush_user_billing_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 39,
        "code_key": "Start",
        "code_value": "func (s *RepushUserBillingTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_rollback_task_scanner.go",
        "code_start_line": 23,
        "code_end_line": 42,
        "code_key": "Start",
        "code_value": "func (s *UpdateRollbackTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\trunning := true\n\t\tfor running {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\trunning = false\n\t\t\tdefault:\n\t\t\t\terr := s.FullScan(ctx)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogs.Fatal(ctx).Msgf(\"%s full scan failed!\\n\", s.name)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\ttime.Sleep(s.scanInterval)\n\t\t}\n\t}()\n\tlogs.Info(ctx).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_valid_appId_fetch_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 36,
        "code_key": "Start",
        "code_value": "func (s *SnapValidAppIdFetchTaskScanner) Start(ctx context.Context) error {\n\t//s.resultChan <- struct{}{}\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_bill_compute_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 39,
        "code_key": "Start",
        "code_value": "func (s *CbsBillComputeTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/app/app.go",
        "code_start_line": 31,
        "code_end_line": 39,
        "code_key": "Start",
        "code_value": "func (m *PipelineManager) Start(ctx context.Context) error {\n\tfor region, pipeline := range m.Pipelines {\n\t\tregionCtx := context.WithValue(ctx, \"region\", region)\n\t\tif err := pipeline.Start(regionCtx); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/app/app.go",
        "code_start_line": 46,
        "code_end_line": 51,
        "code_key": "Start",
        "code_value": "func (app *NebulaApp) Start(ctx context.Context) error {\n\tif err := app.pipelineManager.Start(ctx); err != nil {\n\t\treturn err\n\t}\n\treturn <-app.stopChan\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/app/pipeline.go",
        "code_start_line": 20,
        "code_end_line": 46,
        "code_key": "Start",
        "code_value": "func (p *RegionPipeline) Start(ctx context.Context) error {\n\tregion := ctx.Value(\"region\").(string)\n\tscannerLogCtx := initLogger(ctx, region, \"scanner.log\")\n\tfor _, scanner := range p.scanners {\n\t\tsingleCtx := logs.AddDefaultMessage(scannerLogCtx, \"name\", scanner.GetName())\n\t\terr := scanner.Start(singleCtx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tinitMetric(scanner, region, \"scanner\", scanner.GetName())\n\t}\n\n\tconvertorLogCtx := initLogger(ctx, region, \"convertor.log\")\n\terr := p.convertor.Start(convertorLogCtx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// start scheduler\n\tschedulerLogCtx := initLogger(ctx, region, \"scheduler.log\")\n\terr = p.scheduler.Start(schedulerLogCtx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tinitMetric(p.scheduler, region, \"scheduler\", \"scheduler\")\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go",
        "code_start_line": 109,
        "code_end_line": 112,
        "code_key": "Start",
        "code_value": "func (sc *Scheduler) Start(ctx context.Context) error {\n\tgo sc.mainLoop(ctx)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/scheduler.go",
        "code_start_line": 154,
        "code_end_line": 191,
        "code_key": "Start",
        "code_value": "func (s *scheduler) Start(ctx context.Context) error {\n\twg := sync.WaitGroup{}\n\trunning := true\n\tgo s.haManager.Start(ctx)\n\tdefer s.haManager.Close(ctx)\n\tfor {\n\t\tselect {\n\t\tcase taskName := <-s.eventChan:\n\t\t\twg.Add(1)\n\t\t\tgo func(name string) {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tif task, ok := s.loads[name]; ok {\n\n\t\t\t\t\tif s.isMaster {\n\t\t\t\t\t\t_ctx := logs.With(ctx).Str(\"seqId\", uuid.New().String()).Str(\"taskName\", name).Logger().WithContext(ctx)\n\t\t\t\t\t\ttask.Work(_ctx)\n\t\t\t\t\t}\n\n\t\t\t\t\ttriggerTime := time.Now().Add(task.Interval())\n\t\t\t\t\tfor {\n\t\t\t\t\t\tif !running {\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif time.Now().After(triggerTime) {\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttime.Sleep(time.Second)\n\t\t\t\t\t}\n\t\t\t\t\ts.eventChan <- name\n\t\t\t\t}\n\t\t\t}(taskName)\n\t\tcase <-s.stopChan:\n\t\t\trunning = false\n\t\t\twg.Wait()\n\t\t\treturn nil\n\t\t}\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/easyha/model.go",
        "code_start_line": 108,
        "code_end_line": 180,
        "code_key": "Start",
        "code_value": "func (m *haManagerImpl) Start(ctx context.Context) {\n\tm.keepRunning = true\n\tm.ctx = ctx\n\tvar (\n\t\tmyIdentity            = m.delegate.GetIdentity()                                    // 当前节点的业务标识\n\t\tmyKey                 = fmt.Sprintf(\"easyhaMaster/%s\", url.PathEscape(m.namespace)) // 分布式锁的key\n\t\tmyToken               = m.encodeToken(myIdentity)                                   // 分布式锁 Token，包含业务标识和随机信息\n\t\tmyLock                dlock.Lock                                                    // 获取到的分布式锁, 用于刷新和释放\n\t\tcurrentMasterIdentity string                                                        // 当前 master 的业务标识，如果为空则是还未获取过当前 master\n\t)\n\n\t// Start slave loop.\n\tfor m.keepRunning {\n\t\t// Try observe the master lock first.\n\t\tif view, err := m.locker.Observe(ctx, myKey); err != nil {\n\t\t\tm.logger.Info().Err(err).Str(\"key\", myKey).Msg(\"failed to observe current master lock\")\n\t\t\t// Failed to observe the master lock, try to  obtain the lock.\n\t\t\tmyLock, err = m.locker.Obtain(ctx, dlock.NewWriteLockKey(myKey), m.lockExpired, &dlock.Option{Token: myToken})\n\t\t\tif err == nil {\n\t\t\t\t// Successfully obtained the lock.\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tnewIdentity, err := m.decodeToken(view.Token)\n\t\t\tif err != nil {\n\t\t\t\tm.logger.Warn().Err(err).Str(\"token\", view.Token).Msg(\"failed to decode token\")\n\t\t\t} else if currentMasterIdentity == \"\" {\n\t\t\t\t// First time to observe the master.\n\t\t\t\tcurrentMasterIdentity = newIdentity\n\t\t\t\tif err := m.delegate.OnBecomeSlave(ctx, currentMasterIdentity); err != nil {\n\t\t\t\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle become slave, force quit for safety\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if currentMasterIdentity != newIdentity {\n\t\t\t\t// Master changed. Need update.\n\t\t\t\tcurrentMasterIdentity = newIdentity\n\t\t\t\tif err := m.delegate.OnSwitchMaster(ctx, currentMasterIdentity); err != nil {\n\t\t\t\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle switch master, force quit for safety\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttime.Sleep(m.checkInterval)\n\t}\n\n\tif myLock == nil {\n\t\tm.logger.Fatal().Msg(\"myLock is nil, found bug, force quit for safety\")\n\t\treturn\n\t}\n\n\t// I am the master now.\n\tif err := m.delegate.OnBecomeMaster(ctx); err != nil {\n\t\tmyLock.Release(ctx)\n\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle become master, force quit for safety\")\n\t\treturn\n\t}\n\n\tdefer func() {\n\t\tmyLock.Release(ctx)\n\t\tif err := m.delegate.OnLostMaster(ctx); err != nil {\n\t\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle lost master, force quit for safety\")\n\t\t}\n\t}()\n\n\t// Start the master loop.\n\tfor m.keepRunning {\n\t\ttime.Sleep(m.checkInterval)\n\t\tif err := myLock.Refresh(ctx, m.lockExpired); err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/base_measure/utils.go",
        "code_start_line": 48,
        "code_end_line": 55,
        "code_key": "GenerateUuid",
        "code_value": "func GenerateUuid(originString string) string {\n\tgenHash := md5.New()\n\tgenHash.Write([]byte(originString))\n\thash := hex.EncodeToString(genHash.Sum(nil))\n\n\tgeneratedUUID := uuid.NewSHA1(uuid.Nil, []byte(hash))\n\treturn generatedUUID.String()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/app/app.go",
        "code_start_line": 78,
        "code_end_line": 129,
        "code_key": "initRegionPipelines",
        "code_value": "func initRegionPipelines(ctx context.Context, app *NebulaApp) error {\n\tconfig := registry.GlobalRegistry.AppConfig\n\tif len(config.RegionPipelines) == 0 {\n\t\treturn fmt.Errorf(\"region pipeline not found\")\n\t}\n\n\tfor region, cfg := range config.RegionPipelines {\n\t\tregionPipe := NewRegionPipeline()\n\t\t// init db\n\t\tinitDatabases(ctx, region, cfg.Databases)\n\n\t\t// init mq\n\t\tinitMessageQueues(ctx, cfg.MessageQueues)\n\n\t\t// init cache 默认30s过期，每隔1min清理过期的内容\n\t\terr := registry.GlobalRegistry.RegistryCache(region, cache.New(time.Second*30, time.Minute))\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\n\t\t// init scheduler\n\t\tschedulerConfig := cfg.Scheduler\n\t\tsc := scheduler.NewScheduler(schedulerConfig.MaxWorkerNum)\n\n\t\t// init convertor\n\t\tscannersConfig := cfg.Scanners\n\t\tconvertor := core.NewConvertor(len(scannersConfig))\n\t\tconvertor.AddScheduler(ctx, sc)\n\n\t\tscanners := make(map[string]scInterfaces.Scanner, len(scannersConfig))\n\t\tlogs.Info(ctx).Msgf(\"Initializing Scanners, Total Nums: %d\", len(scannersConfig))\n\t\tfor _, conf := range scannersConfig {\n\t\t\tfactory, ok := registry.GlobalRegistry.ScannerFactories[conf.Name]\n\t\t\tif !ok {\n\t\t\t\treturn fmt.Errorf(\"failed to get scanner factory: %s\", conf.Name)\n\t\t\t}\n\t\t\tscanner, err := factory(conf.Data)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to init scan adapter: %s \", err.Error())\n\t\t\t}\n\t\t\tscanners[conf.Name] = scanner\n\t\t\tconvertor.AddScanner(ctx, scanner)\n\t\t\tlogs.Info(ctx).Msgf(\"%s Scanner Initialize Success\", conf.Name)\n\t\t}\n\t\tregionPipe.convertor = convertor\n\t\tregionPipe.scanners = scanners\n\t\tregionPipe.scheduler = sc\n\t\tapp.pipelineManager.Pipelines[region] = regionPipe\n\t\tlogs.Info(ctx).Msgf(\"%s region initialize success\", region)\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/client/client.go",
        "code_start_line": 20,
        "code_end_line": 62,
        "code_key": "Request",
        "code_value": "func (c *BaseClient) Request(ctx context.Context, interfaceName string, reqJsonData []byte) ([]byte, error) {\n\tlogger := logs.With(ctx).Str(\"interface\", interfaceName).Logger()\n\tlogger.Info().Str(\"para\", string(reqJsonData)).Msg(\"NEW_REQUEST\")\n\n\tctx, cancel := context.WithTimeout(ctx, time.Second*time.Duration(c.Timeout))\n\tdefer cancel()\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPost, c.Url, bytes.NewReader(reqJsonData))\n\n\tif global.TestEnv {\n\t\treq.Header.Add(\"X-QCloud-Transaction-ID\", uuid.New().String())\n\t\treq.Header.Add(\"X-QCloud-User-ID\", global.TestUin)\n\t}\n\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"new request failed: %v\", err)\n\t}\n\theader := \"\"\n\tfor key, value := range req.Header {\n\t\theader += fmt.Sprintf(\"-H \\\"%s: %s\\\" \", key, value[0])\n\t}\n\tcurl := fmt.Sprintf(\"curl %s --connect-timeout %d -d '%s' %s\", header, c.Timeout, string(reqJsonData), c.Url)\n\tlogger.Info().Any(\"cmd\", curl).Msgf(\"SHOW_CURL_CMD\")\n\n\trsp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\tlogger.Error().Err(err).Msgf(\"RESPONSE_ERR\")\n\t\treturn nil, fmt.Errorf(\"do request failed: %v\", err)\n\t}\n\tdefer func(Body io.ReadCloser) {\n\t\t_ = Body.Close()\n\t}(rsp.Body)\n\n\tif rsp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"unexpected status code: %d\", rsp.StatusCode)\n\t}\n\tbodyData, err := io.ReadAll(rsp.Body)\n\tlogger.Info().Any(\"response\", string(bodyData)).Msgf(\"SHOW_RESPONSE\")\n\tif err != nil {\n\t\tlogger.Error().Err(err).Msgf(\"RESPONSE_ERR\")\n\t\treturn nil, err\n\t}\n\treturn bodyData, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/client/cgw/client.go",
        "code_start_line": 32,
        "code_end_line": 57,
        "code_key": "request",
        "code_value": "func (c *cgwClient) request(ctx context.Context, interfaceName string, para interface{}, data interface{}) error {\n\tjsonData, err := json.Marshal(cgwRequest{\n\t\tVersion:       \"1.0\",\n\t\tComponentName: \"go_scheduler\",\n\t\tCaller:        \"go_scheduler\",\n\t\tInterface: InterfaceInfo{\n\t\t\tInterfaceName: interfaceName,\n\t\t\tPara:          para,\n\t\t},\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tresponse := cgwResponse{}\n\tresponse.Data = data\n\n\tbodyData, err := c.BaseClient.Request(ctx, interfaceName, jsonData)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = json.Unmarshal(bodyData, &response)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/client/oss/client.go",
        "code_start_line": 43,
        "code_end_line": 86,
        "code_key": "request",
        "code_value": "func (c *ossClient) request(ctx context.Context, interfaceName string, para interface{}, data interface{}) error {\n\trandomUuid := uuid.New().String()\n\trequestInfo := map[string]string{\n\t\t\"requestKey\":    \"sng\",\n\t\t\"requestModule\": \"scheduler\",\n\t\t\"operator\":      \"scheduler\",\n\t}\n\tjsonData, err := json.Marshal(ossRequest{\n\t\tSeqId: randomUuid,\n\t\tParams: params{\n\t\t\tContent: ossContent{\n\t\t\t\tType:        \"Json\",\n\t\t\t\tVersion:     \"1.0\",\n\t\t\t\tRequestInfo: requestInfo,\n\t\t\t\tRequestItem: requestItem{\n\t\t\t\t\tMethod: interfaceName,\n\t\t\t\t\tData:   para,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tresponse := ossResponse{}\n\tresponse.Data = data\n\n\t// 修改url，带上cgi后缀\n\tc.BaseClient.Url = fmt.Sprintf(\"%s%s.cgi\", c.Url, interfaceName)\n\tbodyData, err := c.BaseClient.Request(ctx, interfaceName, jsonData)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = json.Unmarshal(bodyData, &response)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif response.Code != 0 {\n\t\treturn fmt.Errorf(response.Message)\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/client/cbsV3/client.go",
        "code_start_line": 33,
        "code_end_line": 57,
        "code_key": "request",
        "code_value": "func (c *cbsV3Client) request(ctx context.Context, interfaceName string, para interface{}, data interface{}) error {\n\trandomUuid := uuid.New().String()\n\tbaseReq := cbsV3Request{\n\t\tAction:        interfaceName,\n\t\tVersion:       \"1.0\",\n\t\tApiModule:     \"go_scheduler\",\n\t\tRequestSource: \"go_scheduler\",\n\t\tRequestId:     randomUuid,\n\t}\n\tjsonData, err := client.MergeInterface(baseReq, para)\n\tif err != nil {\n\t\treturn err\n\t}\n\tresponse := cbsV3Response{}\n\tresponse.Response = data\n\tbodyData, err := c.BaseClient.Request(ctx, interfaceName, jsonData)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = json.Unmarshal(bodyData, &response)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/clients/cbs_blk_flow_agent/api.go",
        "code_start_line": 172,
        "code_end_line": 217,
        "code_key": "request",
        "code_value": "func (c *client) request(ctx context.Context, cmd string, param, data interface{}) error {\n\tlogger := logs.With(ctx).Str(\"cmd\", cmd).Str(\"host_ip\", c.hostIp).Logger()\n\tlogger.Info().Interface(\"req\", param).Msg(\"REQUEST_BLK_AGENT\")\n\trandomUuid := uuid.New().String()\n\tjsonData, err := json.Marshal(blockAgentRequest{\n\t\tUsername: \"cbs\",\n\t\tSeqID:    randomUuid,\n\t\tCommand:  cmd,\n\t\tSpanID:   \"rdisk_master\",\n\t\tPassword: \"cbs@2020\", // NOCA:PasswordLeak(误报)\n\t\tData:     param,\n\t})\n\tif err != nil {\n\t\treturn errors.Newf(ErrEncodeRequest, \"marshal request body failed: %v\", err)\n\t}\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPost, c.url, bytes.NewReader(jsonData))\n\tif err != nil {\n\t\treturn errors.Newf(ErrRequest, \"new request failed: %v\", err)\n\t}\n\trsp, err := http.DefaultClient.Do(req) //nolint:bodyclose // 误报\n\tif err != nil {\n\t\treturn errors.Newf(ErrRequest, \"do request failed: %v\", err)\n\t}\n\tdefer func(body io.ReadCloser) {\n\t\t_ = body.Close()\n\t}(rsp.Body)\n\n\tif rsp.StatusCode != http.StatusOK {\n\t\treturn errors.Newf(ErrRequest, \"unexpected status code: %d\", rsp.StatusCode)\n\t}\n\tresponse := blockAgentResponse{}\n\tresponse.Data = data\n\tbodyData, err := io.ReadAll(rsp.Body)\n\tif err != nil {\n\t\tlogger.Error().Err(err).Msgf(\"RESPONSE_FROM_BLK_AGENT_READ_ERR\")\n\t\treturn errors.Newf(ErrReadResponse, \"%v\", err)\n\t}\n\n\terr = json.Unmarshal(bodyData, &response)\n\tif err != nil {\n\t\tlogger.Error().Bytes(\"result\", bodyData).Err(err).Msgf(\"RESPONSE_FROM_BLK_AGENT_DECODE_ERR\")\n\t\treturn errors.Newf(ErrDecodeResponse, \"decode response failed: %v\", err)\n\t}\n\tlogger.Info().Any(\"response\", response).Msgf(\"RESPONSE_FROM_BLK_AGENT\")\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/clients/trade_client/utils.go",
        "code_start_line": 33,
        "code_end_line": 37,
        "code_key": "hmacsha256",
        "code_value": "func hmacsha256(s, key string) string {\n\thashed := hmac.New(sha256.New, []byte(key))\n\thashed.Write([]byte(s))\n\treturn string(hashed.Sum(nil))\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/clients/cos/client.go",
        "code_start_line": 33,
        "code_end_line": 64,
        "code_key": "New",
        "code_value": "func New(cfg Config) Client {\n\tvar (\n\t\t//region = \"ap-guangzhou\"\n\t\tdomain = cfg.Domain\n\t)\n\n\tif domain == \"\" {\n\t\tif cfg.Region != \"\" {\n\t\t\tregion := cfg.Region\n\t\t\tdomain = \"cos.\" + region + \".myqcloud.com\"\n\t\t} else {\n\t\t\tdomain = \"cos.ap-guangzhou.myqcloud.com\"\n\t\t}\n\t}\n\n\tu, _ := url.Parse(fmt.Sprintf(\"https://%s.%s\", cfg.Bucket, domain))\n\tb := &cos.BaseURL{BucketURL: u}\n\t// 获取签名客户端。\n\ttransport := &cos.AuthorizationTransport{\n\t\tSecretID:  cfg.SecretID,\n\t\tSecretKey: cfg.SecretKey,\n\t}\n\t// 如果使用临时密钥，可以将 Token 字段赋值为临时密钥的 Token 值。\n\tif cfg.Token != \"\" {\n\t\ttransport.SessionToken = cfg.Token\n\t}\n\tc := cos.NewClient(b, &http.Client{\n\t\tTransport: transport,\n\t})\n\n\treturn &clientImpl{c: c}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/clients/cbs_blk_flow_agent/api.go",
        "code_start_line": 337,
        "code_end_line": 345,
        "code_key": "New",
        "code_value": "func New(hostIp string, opts ...BlockAgentOptions) Interface {\n\t// 默认端口号为 24500\n\tdefaultPort := 24500\n\tclient := &client{hostIp: hostIp, url: fmt.Sprintf(\"http://%s:%d\", hostIp, defaultPort), RetryPolicy: DefaultRetryPolicy}\n\tfor _, opt := range opts {\n\t\topt(client)\n\t}\n\treturn client\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/errors/errors.go",
        "code_start_line": 71,
        "code_end_line": 73,
        "code_key": "New",
        "code_value": "func New(code int, text string) error {\n\treturn errs.New(code, text)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/scheduler.go",
        "code_start_line": 101,
        "code_end_line": 111,
        "code_key": "New",
        "code_value": "func New(ctx context.Context, locker dlock.Locker) Scheduler {\n\ts := &scheduler{\n\t\tbaseCtx:   ctx,\n\t\tloads:     make(map[string]WorkLoad),\n\t\tstopChan:  make(chan struct{}, defaultBufferSize),\n\t\teventChan: make(chan string, defaultBufferSize),\n\t\tlocker:    locker,\n\t}\n\ts.newHAManager(ctx)\n\treturn s\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 833,
        "code_end_line": 841,
        "code_key": "New",
        "code_value": "func New(baseCtx context.Context) *server.Server {\n\timpl := &masterApiServerImpl{}\n\tfilter.Register(\"initContext\", newInitContextFilter(baseCtx), newInitContextClientFilter(baseCtx))\n\tfilter.Register(\"logRequest\", logRequestFilter, logRequestClientFilter)\n\tinitCustomErrorHandler()\n\ts := trpc.NewServer(serverOpts()...)\n\tpb.RegisterMasterService(s.Service(\"trpc.rdisk.master.Master\"), impl)\n\treturn s\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/uow.go",
        "code_start_line": 96,
        "code_end_line": 106,
        "code_key": "New",
        "code_value": "func (u unitOfWorkFactoryImpl) New() dddcore.UnitOfWork {\n\tuow := &unitOfWork{\n\t\ttx:                    u.db.Begin(),\n\t\ttrackedPhyVolumes:     newTracker[*rdiskDomain.PhysicalVolume](updatePhysicalVolume),\n\t\ttrackedLogicalVolumes: newTracker[*rdiskDomain.LogicalVolume](updateLogicalVolume),\n\t\ttrackedDRGroups:       newTracker[*drgroup.DRGroup](updateDRGroup),\n\t\ttrackedBackups:        newTracker[*backup.Backup](updateBackup),\n\t\ttrackedBenchmarks:     newTracker[*benchmark.Benchmark](updateBenchmark),\n\t}\n\treturn uow\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/benchmark/benchmark.go",
        "code_start_line": 114,
        "code_end_line": 122,
        "code_key": "New",
        "code_value": "func New(disk DiskInfo) *Benchmark {\n\tb := &Benchmark{}\n\tb.DiskInfo = disk\n\tb.UUID = uuid.New()\n\tb.Status = StatusInited\n\tb.Created = time.Now()\n\tb.Finished = time.Now()\n\treturn b\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/models.go",
        "code_start_line": 265,
        "code_end_line": 278,
        "code_key": "New",
        "code_value": "func New(name string, appID users.AppID) *DRGroup {\n\tif name == \"\" {\n\t\tname = DefaultName\n\t}\n\treturn &DRGroup{\n\t\tName:         name,\n\t\tAppID:        appID,\n\t\tType:         DefaultType,\n\t\tAffinity:     DefaultAffinity,\n\t\tsubGroups:    make(map[string]*SubGroup),\n\t\tlocationsMap: make(map[string][]*SubGroup),\n\t\tmembersMap:   make(map[string]*SubGroup),\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/backup/models.go",
        "code_start_line": 137,
        "code_end_line": 142,
        "code_key": "New",
        "code_value": "func New(appId users.AppID, diskInfo DiskInfo) *Backup {\n\tif defaultFactory == nil {\n\t\tpanic(\"defaultFactory is nil\")\n\t}\n\treturn defaultFactory.Create(appId, diskInfo)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/easyha/model.go",
        "code_start_line": 209,
        "code_end_line": 225,
        "code_key": "New",
        "code_value": "func New(delegate Delegate, locker dlock.Locker, opts ...Option) HAManager {\n\tm := &haManagerImpl{\n\t\tctx:           context.Background(),\n\t\tdelegate:      delegate,\n\t\tcheckInterval: 5 * time.Second,\n\t\tlockExpired:   10 * time.Second,\n\t\tnamespace:     \"easyha\",\n\t\tlocker:        locker,\n\t\tlogger:        *zerolog.Ctx(context.Background()),\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(m)\n\t}\n\n\treturn m\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 47,
        "code_end_line": 59,
        "code_key": "New",
        "code_value": "func New(db *gorm.DB, conf Config) *mysqlLocker {\n\tlocker := &mysqlLocker{\n\t\tdb:              db,\n\t\ttableName:       conf.TableName,\n\t\tlockColumn:      conf.LockColumn,\n\t\texpireColumn:    conf.ExpireColumn,\n\t\ttokenColumn:     conf.TokenColumn,\n\t\tlockTypeColumn:  conf.LockTypeColumn,\n\t\tlockNumsColumn:  conf.LockNumsColumn,\n\t\treadKeysMemLock: make(map[string]*readKeysMemLock),\n\t}\n\treturn locker\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mem/memdlock.go",
        "code_start_line": 283,
        "code_end_line": 287,
        "code_key": "New",
        "code_value": "func New() dlock.Locker {\n\treturn &memLocker{\n\t\tdata: make(map[string]*lockItem),\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/logs/log.go",
        "code_start_line": 42,
        "code_end_line": 71,
        "code_key": "InitLogWith",
        "code_value": "func InitLogWith(ctx context.Context, config *Config) context.Context {\n\t// 设置日志输出\n\tvar writers []io.Writer\n\tif config.EnableConsoleLogger {\n\t\twriters = append(writers, zerolog.ConsoleWriter{Out: os.Stderr})\n\t}\n\tif config.EnableFileLogger {\n\t\twriters = append(writers, newRollingFileWriter(config))\n\t}\n\tzerolog.DurationFieldUnit = time.Second\n\tlogger := zerolog.New(io.MultiWriter(writers...)).With().Timestamp().Caller().Logger()\n\tzerolog.ErrorStackMarshaler = pkgerrors.MarshalStack\n\tzerolog.CallerMarshalFunc = Lshortfile\n\n\t// 设置日志级别\n\tswitch config.Level {\n\tcase \"debug\":\n\t\tlogger.Level(zerolog.DebugLevel)\n\tcase \"info\":\n\t\tlogger.Level(zerolog.InfoLevel)\n\tcase \"warn\":\n\t\tlogger.Level(zerolog.WarnLevel)\n\tcase \"error\":\n\t\tlogger.Level(zerolog.ErrorLevel)\n\tcase \"fatal\":\n\t\tlogger.Level(zerolog.FatalLevel)\n\t}\n\n\treturn logger.WithContext(ctx)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cmdb/cmdb_mock.go",
        "code_start_line": 39,
        "code_end_line": 45,
        "code_key": "DescribeServerDetail",
        "code_value": "func (m *MockApiService) DescribeServerDetail(ctx context.Context, req *DescribeServerDetailRequest) (*DescribeServerDetailResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"DescribeServerDetail\", ctx, req)\n\tret0, _ := ret[0].(*DescribeServerDetailResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cmdb/cmdb_mock.go",
        "code_start_line": 48,
        "code_end_line": 51,
        "code_key": "DescribeServerDetail",
        "code_value": "func (mr *MockApiServiceMockRecorder) DescribeServerDetail(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DescribeServerDetail\", reflect.TypeOf((*MockApiService)(nil).DescribeServerDetail), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cmdb/cmdb_mock.go",
        "code_start_line": 77,
        "code_end_line": 87,
        "code_key": "DescribeServerDetail",
        "code_value": "func (m *MockApiClientProxy) DescribeServerDetail(ctx context.Context, req *DescribeServerDetailRequest, opts ...client.Option) (*DescribeServerDetailResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"DescribeServerDetail\", varargs...)\n\tret0, _ := ret[0].(*DescribeServerDetailResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cmdb/cmdb_mock.go",
        "code_start_line": 90,
        "code_end_line": 94,
        "code_key": "DescribeServerDetail",
        "code_value": "func (mr *MockApiClientProxyMockRecorder) DescribeServerDetail(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DescribeServerDetail\", reflect.TypeOf((*MockApiClientProxy)(nil).DescribeServerDetail), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cmdb/cmdb.trpc.go",
        "code_start_line": 66,
        "code_end_line": 68,
        "code_key": "DescribeServerDetail",
        "code_value": "func (s *UnimplementedApi) DescribeServerDetail(ctx context.Context, req *DescribeServerDetailRequest) (*DescribeServerDetailResponse, error) {\n\treturn nil, errors.New(\"rpc DescribeServerDetail of services Api is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cmdb/cmdb.trpc.go",
        "code_start_line": 90,
        "code_end_line": 108,
        "code_key": "DescribeServerDetail",
        "code_value": "func (c *ApiClientProxyImpl) DescribeServerDetail(ctx context.Context, req *DescribeServerDetailRequest, opts ...client.Option) (*DescribeServerDetailResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.tencent.cloud.cmdb.Api/DescribeServerDetail\")\n\tmsg.WithCalleeServiceName(ApiServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"\")\n\tmsg.WithCalleeServer(\"\")\n\tmsg.WithCalleeService(\"Api\")\n\tmsg.WithCalleeMethod(\"DescribeServerDetail\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &DescribeServerDetailResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 644,
        "code_end_line": 646,
        "code_key": "CreateRDiskVol",
        "code_value": "func (s *UnimplementedMaster) CreateRDiskVol(ctx context.Context, req *CreateRDiskVolRequest) (*CreateRDiskVolResponse, error) {\n\treturn nil, errors.New(\"rpc CreateRDiskVol of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 837,
        "code_end_line": 855,
        "code_key": "CreateRDiskVol",
        "code_value": "func (c *MasterClientProxyImpl) CreateRDiskVol(ctx context.Context, req *CreateRDiskVolRequest, opts ...client.Option) (*CreateRDiskVolResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/CreateRDiskVol\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"CreateRDiskVol\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &CreateRDiskVolResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 174,
        "code_end_line": 180,
        "code_key": "CreateRDiskVol",
        "code_value": "func (m *MockMasterService) CreateRDiskVol(ctx context.Context, req *CreateRDiskVolRequest) (*CreateRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CreateRDiskVol\", ctx, req)\n\tret0, _ := ret[0].(*CreateRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 183,
        "code_end_line": 186,
        "code_key": "CreateRDiskVol",
        "code_value": "func (mr *MockMasterServiceMockRecorder) CreateRDiskVol(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateRDiskVol\", reflect.TypeOf((*MockMasterService)(nil).CreateRDiskVol), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 617,
        "code_end_line": 627,
        "code_key": "CreateRDiskVol",
        "code_value": "func (m *MockMasterClientProxy) CreateRDiskVol(ctx context.Context, req *CreateRDiskVolRequest, opts ...client.Option) (*CreateRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"CreateRDiskVol\", varargs...)\n\tret0, _ := ret[0].(*CreateRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 630,
        "code_end_line": 634,
        "code_key": "CreateRDiskVol",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) CreateRDiskVol(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateRDiskVol\", reflect.TypeOf((*MockMasterClientProxy)(nil).CreateRDiskVol), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 184,
        "code_end_line": 235,
        "code_key": "CreateRDiskVol",
        "code_value": "func (s *masterApiServerImpl) CreateRDiskVol(ctx context.Context, req *pb.CreateRDiskVolRequest) (*pb.CreateRDiskVolResponse, error) {\n\tvar (\n\t\terr           error\n\t\tresponse      *pb.CreateRDiskVolResponse\n\t\tcreateCmd     *commands.CreateLogicalVolumeCommand\n\t\tconfirmCmd    *commands.ConfirmDRGroupExistsCommand\n\t\tcreatedVolume *rdiskDomain.LogicalVolume\n\t\tpvViewer      = app.GetRegistry(ctx).Viewers.PhysicalVolume\n\t)\n\n\tconfirmCmd = &commands.ConfirmDRGroupExistsCommand{\n\t\tAppID:   int64(req.AppId),\n\t\tDRGroup: functools.MapTo(req.AffinitySpec, functools.MapRef(make([]drgroup.Spec, len(req.AffinitySpec))), parseAffinitySpec),\n\t}\n\terr = app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, confirmCmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tselectedPhysicalVolume, err := pvViewer.QueryBySerial(ctx, []string{req.PhyId})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(selectedPhysicalVolume) == 0 {\n\t\treturn nil, errs.New(errors.ErrInvalidArgument, \"physical volume not found\")\n\t}\n\n\tcreateCmd = &commands.CreateLogicalVolumeCommand{\n\t\tAppID:                  int64(req.AppId),\n\t\tPhysicalVolumeSerial:   req.PhyId,\n\t\tZoneID:                 req.ZoneId,\n\t\tVolumeType:             req.VolumeType,\n\t\tDiskSize:               req.DiskSize,\n\t\tDiskType:               req.DiskType,\n\t\tDRGroup:                functools.MapTo(req.AffinitySpec, functools.MapRef(make([]drgroup.Spec, len(req.AffinitySpec))), parseAffinitySpec),\n\t\tSelectedPhysicalVolume: selectedPhysicalVolume[0],\n\t\tPerformanceRank:        req.PerformanceRank,\n\t}\n\n\terr = app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, createCmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcreatedVolume = createCmd.GetLogicalVolume()\n\tresponse = &pb.CreateRDiskVolResponse{\n\t\tDisk: encodeLogicalVolume(createdVolume, &pb.RDisk{}),\n\t}\n\n\treturn response, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 649,
        "code_end_line": 651,
        "code_key": "QueryRDiskVol",
        "code_value": "func (s *UnimplementedMaster) QueryRDiskVol(ctx context.Context, req *QueryRDiskVolRequest) (*QueryRDiskVolResponse, error) {\n\treturn nil, errors.New(\"rpc QueryRDiskVol of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 857,
        "code_end_line": 875,
        "code_key": "QueryRDiskVol",
        "code_value": "func (c *MasterClientProxyImpl) QueryRDiskVol(ctx context.Context, req *QueryRDiskVolRequest, opts ...client.Option) (*QueryRDiskVolResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/QueryRDiskVol\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"QueryRDiskVol\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &QueryRDiskVolResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 354,
        "code_end_line": 360,
        "code_key": "QueryRDiskVol",
        "code_value": "func (m *MockMasterService) QueryRDiskVol(ctx context.Context, req *QueryRDiskVolRequest) (*QueryRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"QueryRDiskVol\", ctx, req)\n\tret0, _ := ret[0].(*QueryRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 363,
        "code_end_line": 366,
        "code_key": "QueryRDiskVol",
        "code_value": "func (mr *MockMasterServiceMockRecorder) QueryRDiskVol(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryRDiskVol\", reflect.TypeOf((*MockMasterService)(nil).QueryRDiskVol), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 857,
        "code_end_line": 867,
        "code_key": "QueryRDiskVol",
        "code_value": "func (m *MockMasterClientProxy) QueryRDiskVol(ctx context.Context, req *QueryRDiskVolRequest, opts ...client.Option) (*QueryRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"QueryRDiskVol\", varargs...)\n\tret0, _ := ret[0].(*QueryRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 870,
        "code_end_line": 874,
        "code_key": "QueryRDiskVol",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) QueryRDiskVol(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryRDiskVol\", reflect.TypeOf((*MockMasterClientProxy)(nil).QueryRDiskVol), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 498,
        "code_end_line": 596,
        "code_key": "QueryRDiskVol",
        "code_value": "func (*masterApiServerImpl) QueryRDiskVol(ctx context.Context, req *pb.QueryRDiskVolRequest) (*pb.QueryRDiskVolResponse, error) {\n\tview := app.GetRegistry(ctx).Viewers.LogicalVolume\n\tphyView := app.GetRegistry(ctx).Viewers.PhysicalVolume\n\tvar err error\n\n\ttype checker func(*pb.QueryRDiskVolRequest) error\n\tfor _, rule := range []checker{\n\t\t// 不允许不带任何参数的空查询\n\t\tcheckQueryRDiskVolNoEmptyQuery,\n\t\t// 如果带有 BdfIds 参数，必须带有 HostIps 参数缩小范围，单纯 Bdf 查询意义不大，区分度太低了\n\t\tcheckQueryRDiskVolBdfIdsMustComeWithHostIps,\n\t} {\n\t\tif err := rule(req); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Stage 1 - （如有）确认物理卷 Serials\n\tserials := []rdiskDomain.Serial{}\n\tif len(req.HostIps) > 0 {\n\t\tcriteria := rdiskDomain.PVSearchCriteria{\n\t\t\tIPs:           functools.Map(req.HostIps, net.ParseIP),\n\t\t\tSerials:       functools.Map(req.PhyIds, func(x string) rdiskDomain.Serial { return rdiskDomain.Serial(x) }),\n\t\t\tBDFs:          functools.Map(req.BdfIds, func(x string) rdiskDomain.BDF { return rdiskDomain.BDF(x) }),\n\t\t\tAvailableOnly: false,\n\t\t}\n\t\tphyDisks, err := phyView.Search(ctx, criteria, rdiskDomain.Pagination{Limit: 1000})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tserials = functools.Map(phyDisks, func(x *rdiskDomain.PhysicalVolume) rdiskDomain.Serial { return x.Serial })\n\t} else if len(req.PhyIds) > 0 {\n\t\tserials = functools.Map(req.PhyIds, func(x string) rdiskDomain.Serial { return rdiskDomain.Serial(x) })\n\t}\n\n\t// Stage 2 - 确认用户 AppId\n\tuuidSlice := functools.Map(req.CbsUuids, uuid.MustParse)\n\tappId := users.AppID(req.AppId)\n\tif req.AppId <= 0 {\n\t\tif appId, err = view.ProbeAppID(ctx, uuidSlice, serials); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Stage 3 - 发起查询\n\tcriteria := rdiskDomain.LVSearchCriteria{\n\t\tUUIDs:   uuidSlice,\n\t\tSerials: serials,\n\t}\n\tvar limit uint64 = 100\n\tvar offset uint64 = 0\n\tif req.Page != nil {\n\t\tlimit = req.Page.PageSize\n\t\toffset = req.Page.Page * limit\n\t}\n\n\tresults, err := view.Search(ctx, appId, criteria, rdiskDomain.Pagination{Limit: limit, Offset: offset})\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn &pb.QueryRDiskVolResponse{}, nil\n\t\t}\n\t}\n\n\tif len(results) == 0 {\n\t\treturn &pb.QueryRDiskVolResponse{}, nil\n\t}\n\n\t// Stage 4 - 查询关联的置放群组\n\trelatedUuidStrings := functools.Map(results, func(x *rdiskDomain.LogicalVolume) string { return x.UUID.String() })\n\tdrgroupRelations, err := app.GetRegistry(ctx).Viewers.DRGroup.QueryRelationsMap(ctx, appId, relatedUuidStrings)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Stage 5 - 组装数据返回\n\n\tgroupNameToSpecMap := make(map[string]*pb.AffinitySpec)\n\tresponseDataRef := functools.MapRef(make([]pb.RDisk, len(results)))\n\tfor i := range results {\n\t\tencodeLogicalVolume(results[i], responseDataRef[i])\n\n\t\t// 找到关联的置放群组并返回\n\t\tif drgroupViews, ok := drgroupRelations[results[i].UUID.String()]; ok {\n\t\t\tresponseDataRef[i].AffinitySpec = make([]*pb.AffinitySpec, len(drgroupViews))\n\t\t\tfor j := range drgroupViews {\n\t\t\t\tgroupName := drgroupViews[j].Name\n\t\t\t\tif spec, ok := groupNameToSpecMap[groupName]; ok {\n\t\t\t\t\tresponseDataRef[i].AffinitySpec[j] = spec\n\t\t\t\t} else {\n\t\t\t\t\tspec := encodeDRGroupView(drgroupViews[j], &pb.AffinitySpec{}, results[i].UUID.String())\n\t\t\t\t\tgroupNameToSpecMap[groupName] = spec\n\t\t\t\t\tresponseDataRef[i].AffinitySpec[j] = spec\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\treturn &pb.QueryRDiskVolResponse{Disks: responseDataRef}, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 654,
        "code_end_line": 656,
        "code_key": "DeleteRDiskVol",
        "code_value": "func (s *UnimplementedMaster) DeleteRDiskVol(ctx context.Context, req *DeleteRDiskVolRequest) (*DeleteRDiskVolResponse, error) {\n\treturn nil, errors.New(\"rpc DeleteRDiskVol of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 877,
        "code_end_line": 895,
        "code_key": "DeleteRDiskVol",
        "code_value": "func (c *MasterClientProxyImpl) DeleteRDiskVol(ctx context.Context, req *DeleteRDiskVolRequest, opts ...client.Option) (*DeleteRDiskVolResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/DeleteRDiskVol\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"DeleteRDiskVol\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &DeleteRDiskVolResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 234,
        "code_end_line": 240,
        "code_key": "DeleteRDiskVol",
        "code_value": "func (m *MockMasterService) DeleteRDiskVol(ctx context.Context, req *DeleteRDiskVolRequest) (*DeleteRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"DeleteRDiskVol\", ctx, req)\n\tret0, _ := ret[0].(*DeleteRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 243,
        "code_end_line": 246,
        "code_key": "DeleteRDiskVol",
        "code_value": "func (mr *MockMasterServiceMockRecorder) DeleteRDiskVol(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeleteRDiskVol\", reflect.TypeOf((*MockMasterService)(nil).DeleteRDiskVol), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 697,
        "code_end_line": 707,
        "code_key": "DeleteRDiskVol",
        "code_value": "func (m *MockMasterClientProxy) DeleteRDiskVol(ctx context.Context, req *DeleteRDiskVolRequest, opts ...client.Option) (*DeleteRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"DeleteRDiskVol\", varargs...)\n\tret0, _ := ret[0].(*DeleteRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 710,
        "code_end_line": 714,
        "code_key": "DeleteRDiskVol",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) DeleteRDiskVol(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeleteRDiskVol\", reflect.TypeOf((*MockMasterClientProxy)(nil).DeleteRDiskVol), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 238,
        "code_end_line": 260,
        "code_key": "DeleteRDiskVol",
        "code_value": "func (s *masterApiServerImpl) DeleteRDiskVol(ctx context.Context, req *pb.DeleteRDiskVolRequest) (*pb.DeleteRDiskVolResponse, error) {\n\tvar (\n\t\terr      error\n\t\tresponse = &pb.DeleteRDiskVolResponse{}\n\t\tcmd      *commands.DeleteLogicalVolumeCommand\n\t)\n\tcmd = &commands.DeleteLogicalVolumeCommand{\n\t\tAppID: users.AppID(req.AppId),\n\t\tUUID:  uuid.MustParse(req.CbsUuid),\n\t}\n\terr = cmd.Prepare(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, cmd)\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn &pb.DeleteRDiskVolResponse{}, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn response, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 659,
        "code_end_line": 661,
        "code_key": "ConfirmDeleteRDiskVol",
        "code_value": "func (s *UnimplementedMaster) ConfirmDeleteRDiskVol(ctx context.Context, req *DeleteRDiskVolRequest) (*DeleteRDiskVolResponse, error) {\n\treturn nil, errors.New(\"rpc ConfirmDeleteRDiskVol of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 897,
        "code_end_line": 915,
        "code_key": "ConfirmDeleteRDiskVol",
        "code_value": "func (c *MasterClientProxyImpl) ConfirmDeleteRDiskVol(ctx context.Context, req *DeleteRDiskVolRequest, opts ...client.Option) (*DeleteRDiskVolResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/ConfirmDeleteRDiskVol\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"ConfirmDeleteRDiskVol\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &DeleteRDiskVolResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 99,
        "code_end_line": 105,
        "code_key": "ConfirmDeleteRDiskVol",
        "code_value": "func (m *MockMasterService) ConfirmDeleteRDiskVol(ctx context.Context, req *DeleteRDiskVolRequest) (*DeleteRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"ConfirmDeleteRDiskVol\", ctx, req)\n\tret0, _ := ret[0].(*DeleteRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 108,
        "code_end_line": 111,
        "code_key": "ConfirmDeleteRDiskVol",
        "code_value": "func (mr *MockMasterServiceMockRecorder) ConfirmDeleteRDiskVol(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ConfirmDeleteRDiskVol\", reflect.TypeOf((*MockMasterService)(nil).ConfirmDeleteRDiskVol), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 517,
        "code_end_line": 527,
        "code_key": "ConfirmDeleteRDiskVol",
        "code_value": "func (m *MockMasterClientProxy) ConfirmDeleteRDiskVol(ctx context.Context, req *DeleteRDiskVolRequest, opts ...client.Option) (*DeleteRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"ConfirmDeleteRDiskVol\", varargs...)\n\tret0, _ := ret[0].(*DeleteRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 530,
        "code_end_line": 534,
        "code_key": "ConfirmDeleteRDiskVol",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) ConfirmDeleteRDiskVol(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ConfirmDeleteRDiskVol\", reflect.TypeOf((*MockMasterClientProxy)(nil).ConfirmDeleteRDiskVol), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 263,
        "code_end_line": 276,
        "code_key": "ConfirmDeleteRDiskVol",
        "code_value": "func (s *masterApiServerImpl) ConfirmDeleteRDiskVol(ctx context.Context, req *pb.DeleteRDiskVolRequest) (*pb.DeleteRDiskVolResponse, error) {\n\tcmd := commands.ConfirmDeleteLogicalVolumeCommand{\n\t\tAppID: users.AppID(req.AppId),\n\t\tUUID:  uuid.MustParse(req.CbsUuid),\n\t}\n\terr := app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, &cmd)\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn &pb.DeleteRDiskVolResponse{}, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn &pb.DeleteRDiskVolResponse{}, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 664,
        "code_end_line": 666,
        "code_key": "UpdateRDiskFlowCtrl",
        "code_value": "func (s *UnimplementedMaster) UpdateRDiskFlowCtrl(ctx context.Context, req *UpdateRDiskFlowCtrlRequest) (*UpdateRDiskFlowCtrlResponse, error) {\n\treturn nil, errors.New(\"rpc UpdateRDiskFlowCtrl of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 917,
        "code_end_line": 935,
        "code_key": "UpdateRDiskFlowCtrl",
        "code_value": "func (c *MasterClientProxyImpl) UpdateRDiskFlowCtrl(ctx context.Context, req *UpdateRDiskFlowCtrlRequest, opts ...client.Option) (*UpdateRDiskFlowCtrlResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/UpdateRDiskFlowCtrl\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"UpdateRDiskFlowCtrl\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &UpdateRDiskFlowCtrlResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 399,
        "code_end_line": 405,
        "code_key": "UpdateRDiskFlowCtrl",
        "code_value": "func (m *MockMasterService) UpdateRDiskFlowCtrl(ctx context.Context, req *UpdateRDiskFlowCtrlRequest) (*UpdateRDiskFlowCtrlResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"UpdateRDiskFlowCtrl\", ctx, req)\n\tret0, _ := ret[0].(*UpdateRDiskFlowCtrlResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 408,
        "code_end_line": 411,
        "code_key": "UpdateRDiskFlowCtrl",
        "code_value": "func (mr *MockMasterServiceMockRecorder) UpdateRDiskFlowCtrl(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"UpdateRDiskFlowCtrl\", reflect.TypeOf((*MockMasterService)(nil).UpdateRDiskFlowCtrl), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 917,
        "code_end_line": 927,
        "code_key": "UpdateRDiskFlowCtrl",
        "code_value": "func (m *MockMasterClientProxy) UpdateRDiskFlowCtrl(ctx context.Context, req *UpdateRDiskFlowCtrlRequest, opts ...client.Option) (*UpdateRDiskFlowCtrlResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"UpdateRDiskFlowCtrl\", varargs...)\n\tret0, _ := ret[0].(*UpdateRDiskFlowCtrlResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 930,
        "code_end_line": 934,
        "code_key": "UpdateRDiskFlowCtrl",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) UpdateRDiskFlowCtrl(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"UpdateRDiskFlowCtrl\", reflect.TypeOf((*MockMasterClientProxy)(nil).UpdateRDiskFlowCtrl), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 359,
        "code_end_line": 382,
        "code_key": "UpdateRDiskFlowCtrl",
        "code_value": "func (*masterApiServerImpl) UpdateRDiskFlowCtrl(ctx context.Context, req *pb.UpdateRDiskFlowCtrlRequest) (*pb.UpdateRDiskFlowCtrlResponse, error) {\n\tvar (\n\t\terr      error\n\t\tresponse = &pb.UpdateRDiskFlowCtrlResponse{}\n\t\tcmd      = &commands.UpdateLogicalVolumeFlowControlCommand{}\n\t)\n\n\tcmd.AppID = users.AppID(req.AppId)\n\tcmd.UUID = uuid.MustParse(req.CbsUuid)\n\n\tif ctrl := req.GetFlowCtrl(); ctrl != nil {\n\t\tcmd.UpdateRequest.ReadIOPS = ctrl.ReadIops\n\t\tcmd.UpdateRequest.ReadIO = ctrl.ReadBandwidth\n\t\tcmd.UpdateRequest.WriteIOPS = ctrl.WriteIops\n\t\tcmd.UpdateRequest.WriteIO = ctrl.WriteBandwidth\n\t\tcmd.UpdateRequest.RWIO = ctrl.RwBandwidth\n\t\tcmd.UpdateRequest.RWIOPS = ctrl.RwIops\n\t} else {\n\t\treturn response, nil\n\t}\n\n\terr = app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, cmd)\n\treturn response, err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 669,
        "code_end_line": 671,
        "code_key": "AttachRDiskVol",
        "code_value": "func (s *UnimplementedMaster) AttachRDiskVol(ctx context.Context, req *AttachRDiskVolRequest) (*AttachRDiskVolResponse, error) {\n\treturn nil, errors.New(\"rpc AttachRDiskVol of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 937,
        "code_end_line": 955,
        "code_key": "AttachRDiskVol",
        "code_value": "func (c *MasterClientProxyImpl) AttachRDiskVol(ctx context.Context, req *AttachRDiskVolRequest, opts ...client.Option) (*AttachRDiskVolResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/AttachRDiskVol\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"AttachRDiskVol\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &AttachRDiskVolResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 39,
        "code_end_line": 45,
        "code_key": "AttachRDiskVol",
        "code_value": "func (m *MockMasterService) AttachRDiskVol(ctx context.Context, req *AttachRDiskVolRequest) (*AttachRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"AttachRDiskVol\", ctx, req)\n\tret0, _ := ret[0].(*AttachRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 48,
        "code_end_line": 51,
        "code_key": "AttachRDiskVol",
        "code_value": "func (mr *MockMasterServiceMockRecorder) AttachRDiskVol(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"AttachRDiskVol\", reflect.TypeOf((*MockMasterService)(nil).AttachRDiskVol), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 437,
        "code_end_line": 447,
        "code_key": "AttachRDiskVol",
        "code_value": "func (m *MockMasterClientProxy) AttachRDiskVol(ctx context.Context, req *AttachRDiskVolRequest, opts ...client.Option) (*AttachRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"AttachRDiskVol\", varargs...)\n\tret0, _ := ret[0].(*AttachRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 450,
        "code_end_line": 454,
        "code_key": "AttachRDiskVol",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) AttachRDiskVol(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"AttachRDiskVol\", reflect.TypeOf((*MockMasterClientProxy)(nil).AttachRDiskVol), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 309,
        "code_end_line": 338,
        "code_key": "AttachRDiskVol",
        "code_value": "func (s *masterApiServerImpl) AttachRDiskVol(ctx context.Context, req *pb.AttachRDiskVolRequest) (*pb.AttachRDiskVolResponse, error) {\n\tcmd := commands.AttachLogicalVolumeCommand{\n\t\tAppID:   users.AppID(req.AppId),\n\t\tUUID:    uuid.MustParse(req.CbsUuid),\n\t\tIP:      net.ParseIP(req.HostIp),\n\t\tOptions: actions.NewAttachOptions(),\n\t}\n\n\tif req.Option != nil {\n\t\tif req.Option.Serial != \"\" {\n\t\t\tcmd.Options.Serial = req.Option.Serial\n\t\t}\n\t\tif req.Option.Vcpu > 0 {\n\t\t\tcmd.Options.VCPU = int(req.Option.Vcpu)\n\t\t}\n\t}\n\n\terr := app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, &cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvol := cmd.GetLogicalVolume()\n\tspdkDriver := \"\"\n\tattachment, err := vol.GetAttachment(net.ParseIP(req.HostIp))\n\tif err == nil {\n\t\tspdkDriver = attachment.Options.SPDKDriver\n\t}\n\tblockSize := vol.PhysicalVolume.BlockSize\n\treturn &pb.AttachRDiskVolResponse{SpdkDriver: spdkDriver, BlockSize: int64(blockSize)}, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 674,
        "code_end_line": 676,
        "code_key": "DetachRDiskVol",
        "code_value": "func (s *UnimplementedMaster) DetachRDiskVol(ctx context.Context, req *DetachRDiskVolRequest) (*DetachRDiskVolResponse, error) {\n\treturn nil, errors.New(\"rpc DetachRDiskVol of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 957,
        "code_end_line": 975,
        "code_key": "DetachRDiskVol",
        "code_value": "func (c *MasterClientProxyImpl) DetachRDiskVol(ctx context.Context, req *DetachRDiskVolRequest, opts ...client.Option) (*DetachRDiskVolResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/DetachRDiskVol\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"DetachRDiskVol\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &DetachRDiskVolResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 249,
        "code_end_line": 255,
        "code_key": "DetachRDiskVol",
        "code_value": "func (m *MockMasterService) DetachRDiskVol(ctx context.Context, req *DetachRDiskVolRequest) (*DetachRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"DetachRDiskVol\", ctx, req)\n\tret0, _ := ret[0].(*DetachRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 258,
        "code_end_line": 261,
        "code_key": "DetachRDiskVol",
        "code_value": "func (mr *MockMasterServiceMockRecorder) DetachRDiskVol(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DetachRDiskVol\", reflect.TypeOf((*MockMasterService)(nil).DetachRDiskVol), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 717,
        "code_end_line": 727,
        "code_key": "DetachRDiskVol",
        "code_value": "func (m *MockMasterClientProxy) DetachRDiskVol(ctx context.Context, req *DetachRDiskVolRequest, opts ...client.Option) (*DetachRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"DetachRDiskVol\", varargs...)\n\tret0, _ := ret[0].(*DetachRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 730,
        "code_end_line": 734,
        "code_key": "DetachRDiskVol",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) DetachRDiskVol(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DetachRDiskVol\", reflect.TypeOf((*MockMasterClientProxy)(nil).DetachRDiskVol), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 341,
        "code_end_line": 356,
        "code_key": "DetachRDiskVol",
        "code_value": "func (s *masterApiServerImpl) DetachRDiskVol(ctx context.Context, req *pb.DetachRDiskVolRequest) (*pb.DetachRDiskVolResponse, error) {\n\tvar (\n\t\terr      error\n\t\tresponse = &pb.DetachRDiskVolResponse{}\n\t\tcmd      *commands.DetachLogicalVolumeCommand\n\t)\n\n\tcmd = &commands.DetachLogicalVolumeCommand{\n\t\tAppID:       users.AppID(req.AppId),\n\t\tUUID:        uuid.MustParse(req.CbsUuid),\n\t\tIP:          net.ParseIP(req.HostIp),\n\t\tForceDetach: req.Force,\n\t}\n\terr = app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, cmd)\n\treturn response, err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 679,
        "code_end_line": 681,
        "code_key": "CreateRDiskLiveMigration",
        "code_value": "func (s *UnimplementedMaster) CreateRDiskLiveMigration(ctx context.Context, req *CreateRDiskLiveMigrationRequest) (*CreateRDiskLiveMigrationResponse, error) {\n\treturn nil, errors.New(\"rpc CreateRDiskLiveMigration of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 977,
        "code_end_line": 995,
        "code_key": "CreateRDiskLiveMigration",
        "code_value": "func (c *MasterClientProxyImpl) CreateRDiskLiveMigration(ctx context.Context, req *CreateRDiskLiveMigrationRequest, opts ...client.Option) (*CreateRDiskLiveMigrationResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/CreateRDiskLiveMigration\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"CreateRDiskLiveMigration\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &CreateRDiskLiveMigrationResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 159,
        "code_end_line": 165,
        "code_key": "CreateRDiskLiveMigration",
        "code_value": "func (m *MockMasterService) CreateRDiskLiveMigration(ctx context.Context, req *CreateRDiskLiveMigrationRequest) (*CreateRDiskLiveMigrationResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CreateRDiskLiveMigration\", ctx, req)\n\tret0, _ := ret[0].(*CreateRDiskLiveMigrationResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 168,
        "code_end_line": 171,
        "code_key": "CreateRDiskLiveMigration",
        "code_value": "func (mr *MockMasterServiceMockRecorder) CreateRDiskLiveMigration(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateRDiskLiveMigration\", reflect.TypeOf((*MockMasterService)(nil).CreateRDiskLiveMigration), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 597,
        "code_end_line": 607,
        "code_key": "CreateRDiskLiveMigration",
        "code_value": "func (m *MockMasterClientProxy) CreateRDiskLiveMigration(ctx context.Context, req *CreateRDiskLiveMigrationRequest, opts ...client.Option) (*CreateRDiskLiveMigrationResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"CreateRDiskLiveMigration\", varargs...)\n\tret0, _ := ret[0].(*CreateRDiskLiveMigrationResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 610,
        "code_end_line": 614,
        "code_key": "CreateRDiskLiveMigration",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) CreateRDiskLiveMigration(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateRDiskLiveMigration\", reflect.TypeOf((*MockMasterClientProxy)(nil).CreateRDiskLiveMigration), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 433,
        "code_end_line": 435,
        "code_key": "CreateRDiskLiveMigration",
        "code_value": "func (*masterApiServerImpl) CreateRDiskLiveMigration(ctx context.Context, req *pb.CreateRDiskLiveMigrationRequest) (*pb.CreateRDiskLiveMigrationResponse, error) {\n\tpanic(\"unimplemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 684,
        "code_end_line": 686,
        "code_key": "CreateRDiskColdMigration",
        "code_value": "func (s *UnimplementedMaster) CreateRDiskColdMigration(ctx context.Context, req *CreateRDiskColdMigrationRequest) (*CreateRDiskColdMigrationResponse, error) {\n\treturn nil, errors.New(\"rpc CreateRDiskColdMigration of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 997,
        "code_end_line": 1015,
        "code_key": "CreateRDiskColdMigration",
        "code_value": "func (c *MasterClientProxyImpl) CreateRDiskColdMigration(ctx context.Context, req *CreateRDiskColdMigrationRequest, opts ...client.Option) (*CreateRDiskColdMigrationResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/CreateRDiskColdMigration\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"CreateRDiskColdMigration\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &CreateRDiskColdMigrationResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 144,
        "code_end_line": 150,
        "code_key": "CreateRDiskColdMigration",
        "code_value": "func (m *MockMasterService) CreateRDiskColdMigration(ctx context.Context, req *CreateRDiskColdMigrationRequest) (*CreateRDiskColdMigrationResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CreateRDiskColdMigration\", ctx, req)\n\tret0, _ := ret[0].(*CreateRDiskColdMigrationResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 153,
        "code_end_line": 156,
        "code_key": "CreateRDiskColdMigration",
        "code_value": "func (mr *MockMasterServiceMockRecorder) CreateRDiskColdMigration(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateRDiskColdMigration\", reflect.TypeOf((*MockMasterService)(nil).CreateRDiskColdMigration), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 577,
        "code_end_line": 587,
        "code_key": "CreateRDiskColdMigration",
        "code_value": "func (m *MockMasterClientProxy) CreateRDiskColdMigration(ctx context.Context, req *CreateRDiskColdMigrationRequest, opts ...client.Option) (*CreateRDiskColdMigrationResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"CreateRDiskColdMigration\", varargs...)\n\tret0, _ := ret[0].(*CreateRDiskColdMigrationResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 590,
        "code_end_line": 594,
        "code_key": "CreateRDiskColdMigration",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) CreateRDiskColdMigration(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateRDiskColdMigration\", reflect.TypeOf((*MockMasterClientProxy)(nil).CreateRDiskColdMigration), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 428,
        "code_end_line": 430,
        "code_key": "CreateRDiskColdMigration",
        "code_value": "func (*masterApiServerImpl) CreateRDiskColdMigration(ctx context.Context, req *pb.CreateRDiskColdMigrationRequest) (*pb.CreateRDiskColdMigrationResponse, error) {\n\tpanic(\"unimplemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 689,
        "code_end_line": 691,
        "code_key": "QueryRDiskMigrationTask",
        "code_value": "func (s *UnimplementedMaster) QueryRDiskMigrationTask(ctx context.Context, req *QueryRDiskMigrationTaskRequest) (*QueryRDiskMigrationTaskResponse, error) {\n\treturn nil, errors.New(\"rpc QueryRDiskMigrationTask of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1017,
        "code_end_line": 1035,
        "code_key": "QueryRDiskMigrationTask",
        "code_value": "func (c *MasterClientProxyImpl) QueryRDiskMigrationTask(ctx context.Context, req *QueryRDiskMigrationTaskRequest, opts ...client.Option) (*QueryRDiskMigrationTaskResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/QueryRDiskMigrationTask\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"QueryRDiskMigrationTask\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &QueryRDiskMigrationTaskResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 339,
        "code_end_line": 345,
        "code_key": "QueryRDiskMigrationTask",
        "code_value": "func (m *MockMasterService) QueryRDiskMigrationTask(ctx context.Context, req *QueryRDiskMigrationTaskRequest) (*QueryRDiskMigrationTaskResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"QueryRDiskMigrationTask\", ctx, req)\n\tret0, _ := ret[0].(*QueryRDiskMigrationTaskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 348,
        "code_end_line": 351,
        "code_key": "QueryRDiskMigrationTask",
        "code_value": "func (mr *MockMasterServiceMockRecorder) QueryRDiskMigrationTask(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryRDiskMigrationTask\", reflect.TypeOf((*MockMasterService)(nil).QueryRDiskMigrationTask), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 837,
        "code_end_line": 847,
        "code_key": "QueryRDiskMigrationTask",
        "code_value": "func (m *MockMasterClientProxy) QueryRDiskMigrationTask(ctx context.Context, req *QueryRDiskMigrationTaskRequest, opts ...client.Option) (*QueryRDiskMigrationTaskResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"QueryRDiskMigrationTask\", varargs...)\n\tret0, _ := ret[0].(*QueryRDiskMigrationTaskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 850,
        "code_end_line": 854,
        "code_key": "QueryRDiskMigrationTask",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) QueryRDiskMigrationTask(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryRDiskMigrationTask\", reflect.TypeOf((*MockMasterClientProxy)(nil).QueryRDiskMigrationTask), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 463,
        "code_end_line": 465,
        "code_key": "QueryRDiskMigrationTask",
        "code_value": "func (*masterApiServerImpl) QueryRDiskMigrationTask(ctx context.Context, req *pb.QueryRDiskMigrationTaskRequest) (*pb.QueryRDiskMigrationTaskResponse, error) {\n\tpanic(\"unimplemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 694,
        "code_end_line": 696,
        "code_key": "CancelRDiskMigration",
        "code_value": "func (s *UnimplementedMaster) CancelRDiskMigration(ctx context.Context, req *CancelRDiskMigrationRequest) (*CancelRDiskMigrationResponse, error) {\n\treturn nil, errors.New(\"rpc CancelRDiskMigration of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1037,
        "code_end_line": 1055,
        "code_key": "CancelRDiskMigration",
        "code_value": "func (c *MasterClientProxyImpl) CancelRDiskMigration(ctx context.Context, req *CancelRDiskMigrationRequest, opts ...client.Option) (*CancelRDiskMigrationResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/CancelRDiskMigration\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"CancelRDiskMigration\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &CancelRDiskMigrationResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 69,
        "code_end_line": 75,
        "code_key": "CancelRDiskMigration",
        "code_value": "func (m *MockMasterService) CancelRDiskMigration(ctx context.Context, req *CancelRDiskMigrationRequest) (*CancelRDiskMigrationResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CancelRDiskMigration\", ctx, req)\n\tret0, _ := ret[0].(*CancelRDiskMigrationResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 78,
        "code_end_line": 81,
        "code_key": "CancelRDiskMigration",
        "code_value": "func (mr *MockMasterServiceMockRecorder) CancelRDiskMigration(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CancelRDiskMigration\", reflect.TypeOf((*MockMasterService)(nil).CancelRDiskMigration), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 477,
        "code_end_line": 487,
        "code_key": "CancelRDiskMigration",
        "code_value": "func (m *MockMasterClientProxy) CancelRDiskMigration(ctx context.Context, req *CancelRDiskMigrationRequest, opts ...client.Option) (*CancelRDiskMigrationResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"CancelRDiskMigration\", varargs...)\n\tret0, _ := ret[0].(*CancelRDiskMigrationResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 490,
        "code_end_line": 494,
        "code_key": "CancelRDiskMigration",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) CancelRDiskMigration(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CancelRDiskMigration\", reflect.TypeOf((*MockMasterClientProxy)(nil).CancelRDiskMigration), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 438,
        "code_end_line": 440,
        "code_key": "CancelRDiskMigration",
        "code_value": "func (*masterApiServerImpl) CancelRDiskMigration(ctx context.Context, req *pb.CancelRDiskMigrationRequest) (*pb.CancelRDiskMigrationResponse, error) {\n\tpanic(\"unimplemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 699,
        "code_end_line": 701,
        "code_key": "CreateRDiskBackup",
        "code_value": "func (s *UnimplementedMaster) CreateRDiskBackup(ctx context.Context, req *CreateRDiskBackupRequest) (*CreateRDiskBackupResponse, error) {\n\treturn nil, errors.New(\"rpc CreateRDiskBackup of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1057,
        "code_end_line": 1075,
        "code_key": "CreateRDiskBackup",
        "code_value": "func (c *MasterClientProxyImpl) CreateRDiskBackup(ctx context.Context, req *CreateRDiskBackupRequest, opts ...client.Option) (*CreateRDiskBackupResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/CreateRDiskBackup\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"CreateRDiskBackup\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &CreateRDiskBackupResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 129,
        "code_end_line": 135,
        "code_key": "CreateRDiskBackup",
        "code_value": "func (m *MockMasterService) CreateRDiskBackup(ctx context.Context, req *CreateRDiskBackupRequest) (*CreateRDiskBackupResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CreateRDiskBackup\", ctx, req)\n\tret0, _ := ret[0].(*CreateRDiskBackupResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 138,
        "code_end_line": 141,
        "code_key": "CreateRDiskBackup",
        "code_value": "func (mr *MockMasterServiceMockRecorder) CreateRDiskBackup(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateRDiskBackup\", reflect.TypeOf((*MockMasterService)(nil).CreateRDiskBackup), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 557,
        "code_end_line": 567,
        "code_key": "CreateRDiskBackup",
        "code_value": "func (m *MockMasterClientProxy) CreateRDiskBackup(ctx context.Context, req *CreateRDiskBackupRequest, opts ...client.Option) (*CreateRDiskBackupResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"CreateRDiskBackup\", varargs...)\n\tret0, _ := ret[0].(*CreateRDiskBackupResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 570,
        "code_end_line": 574,
        "code_key": "CreateRDiskBackup",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) CreateRDiskBackup(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateRDiskBackup\", reflect.TypeOf((*MockMasterClientProxy)(nil).CreateRDiskBackup), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 385,
        "code_end_line": 404,
        "code_key": "CreateRDiskBackup",
        "code_value": "func (*masterApiServerImpl) CreateRDiskBackup(ctx context.Context, req *pb.CreateRDiskBackupRequest) (*pb.CreateRDiskBackupResponse, error) {\n\tvar (\n\t\terr       error\n\t\tresponse  = &pb.CreateRDiskBackupResponse{}\n\t\tcmd       = &commands.CreateRDiskBackupCommand{}\n\t\tdispacher = app.GetRegistry(ctx).Dispatcher\n\t)\n\n\tcmd.AppID = users.AppID(req.AppId)\n\tcmd.UUID = uuid.MustParse(req.CbsUuid)\n\n\terr = dispacher.Dispatch(ctx, cmd)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse.Backup = encodeRDiskBackup(cmd.GetBackup(), &pb.RDiskBackup{})\n\treturn response, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 704,
        "code_end_line": 706,
        "code_key": "QueryRDiskBackup",
        "code_value": "func (s *UnimplementedMaster) QueryRDiskBackup(ctx context.Context, req *QueryRDiskBackupRequest) (*QueryRDiskBackupResponse, error) {\n\treturn nil, errors.New(\"rpc QueryRDiskBackup of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1077,
        "code_end_line": 1095,
        "code_key": "QueryRDiskBackup",
        "code_value": "func (c *MasterClientProxyImpl) QueryRDiskBackup(ctx context.Context, req *QueryRDiskBackupRequest, opts ...client.Option) (*QueryRDiskBackupResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/QueryRDiskBackup\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"QueryRDiskBackup\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &QueryRDiskBackupResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 324,
        "code_end_line": 330,
        "code_key": "QueryRDiskBackup",
        "code_value": "func (m *MockMasterService) QueryRDiskBackup(ctx context.Context, req *QueryRDiskBackupRequest) (*QueryRDiskBackupResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"QueryRDiskBackup\", ctx, req)\n\tret0, _ := ret[0].(*QueryRDiskBackupResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 333,
        "code_end_line": 336,
        "code_key": "QueryRDiskBackup",
        "code_value": "func (mr *MockMasterServiceMockRecorder) QueryRDiskBackup(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryRDiskBackup\", reflect.TypeOf((*MockMasterService)(nil).QueryRDiskBackup), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 817,
        "code_end_line": 827,
        "code_key": "QueryRDiskBackup",
        "code_value": "func (m *MockMasterClientProxy) QueryRDiskBackup(ctx context.Context, req *QueryRDiskBackupRequest, opts ...client.Option) (*QueryRDiskBackupResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"QueryRDiskBackup\", varargs...)\n\tret0, _ := ret[0].(*QueryRDiskBackupResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 830,
        "code_end_line": 834,
        "code_key": "QueryRDiskBackup",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) QueryRDiskBackup(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryRDiskBackup\", reflect.TypeOf((*MockMasterClientProxy)(nil).QueryRDiskBackup), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 443,
        "code_end_line": 460,
        "code_key": "QueryRDiskBackup",
        "code_value": "func (*masterApiServerImpl) QueryRDiskBackup(ctx context.Context, req *pb.QueryRDiskBackupRequest) (*pb.QueryRDiskBackupResponse, error) {\n\tvar (\n\t\tview  = app.GetRegistry(ctx).Viewers.Backup\n\t\tappId = users.AppID(req.AppId)\n\t\tresp  = &pb.QueryRDiskBackupResponse{}\n\t)\n\n\tviews, err := view.FindByAppID(ctx, appId, req.FilterBackupId, req.FilterCbsUuid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdtos := functools.MapRef(make([]pb.RDiskBackup, len(views)))\n\tfunctools.MapTo(views, dtos, encodeRDiskBackupView)\n\tresp.Backup = dtos\n\n\treturn resp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 709,
        "code_end_line": 711,
        "code_key": "DeleteRDiskBackup",
        "code_value": "func (s *UnimplementedMaster) DeleteRDiskBackup(ctx context.Context, req *DeleteRDiskBackupRequest) (*DeleteRDiskBackupResponse, error) {\n\treturn nil, errors.New(\"rpc DeleteRDiskBackup of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1097,
        "code_end_line": 1115,
        "code_key": "DeleteRDiskBackup",
        "code_value": "func (c *MasterClientProxyImpl) DeleteRDiskBackup(ctx context.Context, req *DeleteRDiskBackupRequest, opts ...client.Option) (*DeleteRDiskBackupResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/DeleteRDiskBackup\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"DeleteRDiskBackup\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &DeleteRDiskBackupResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 219,
        "code_end_line": 225,
        "code_key": "DeleteRDiskBackup",
        "code_value": "func (m *MockMasterService) DeleteRDiskBackup(ctx context.Context, req *DeleteRDiskBackupRequest) (*DeleteRDiskBackupResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"DeleteRDiskBackup\", ctx, req)\n\tret0, _ := ret[0].(*DeleteRDiskBackupResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 228,
        "code_end_line": 231,
        "code_key": "DeleteRDiskBackup",
        "code_value": "func (mr *MockMasterServiceMockRecorder) DeleteRDiskBackup(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeleteRDiskBackup\", reflect.TypeOf((*MockMasterService)(nil).DeleteRDiskBackup), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 677,
        "code_end_line": 687,
        "code_key": "DeleteRDiskBackup",
        "code_value": "func (m *MockMasterClientProxy) DeleteRDiskBackup(ctx context.Context, req *DeleteRDiskBackupRequest, opts ...client.Option) (*DeleteRDiskBackupResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"DeleteRDiskBackup\", varargs...)\n\tret0, _ := ret[0].(*DeleteRDiskBackupResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 690,
        "code_end_line": 694,
        "code_key": "DeleteRDiskBackup",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) DeleteRDiskBackup(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeleteRDiskBackup\", reflect.TypeOf((*MockMasterClientProxy)(nil).DeleteRDiskBackup), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 407,
        "code_end_line": 425,
        "code_key": "DeleteRDiskBackup",
        "code_value": "func (*masterApiServerImpl) DeleteRDiskBackup(ctx context.Context, req *pb.DeleteRDiskBackupRequest) (*pb.DeleteRDiskBackupResponse, error) {\n\tvar (\n\t\terr       error\n\t\tresponse  = &pb.DeleteRDiskBackupResponse{}\n\t\tcmd       = &commands.DeleteRDiskBackupCommand{}\n\t\tdispacher = app.GetRegistry(ctx).Dispatcher\n\t)\n\n\tcmd.AppID = users.AppID(req.AppId)\n\tcmd.BackupID = uuid.MustParse(req.BackupId)\n\tcmd.UUID = uuid.MustParse(req.CbsUuid)\n\n\terr = dispacher.Dispatch(ctx, cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 714,
        "code_end_line": 716,
        "code_key": "UpdateRDiskDRGroup",
        "code_value": "func (s *UnimplementedMaster) UpdateRDiskDRGroup(ctx context.Context, req *UpdateRDiskDRGroupRequest) (*UpdateRDiskDRGroupResponse, error) {\n\treturn nil, errors.New(\"rpc UpdateRDiskDRGroup of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1117,
        "code_end_line": 1135,
        "code_key": "UpdateRDiskDRGroup",
        "code_value": "func (c *MasterClientProxyImpl) UpdateRDiskDRGroup(ctx context.Context, req *UpdateRDiskDRGroupRequest, opts ...client.Option) (*UpdateRDiskDRGroupResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/UpdateRDiskDRGroup\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"UpdateRDiskDRGroup\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &UpdateRDiskDRGroupResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 384,
        "code_end_line": 390,
        "code_key": "UpdateRDiskDRGroup",
        "code_value": "func (m *MockMasterService) UpdateRDiskDRGroup(ctx context.Context, req *UpdateRDiskDRGroupRequest) (*UpdateRDiskDRGroupResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"UpdateRDiskDRGroup\", ctx, req)\n\tret0, _ := ret[0].(*UpdateRDiskDRGroupResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 393,
        "code_end_line": 396,
        "code_key": "UpdateRDiskDRGroup",
        "code_value": "func (mr *MockMasterServiceMockRecorder) UpdateRDiskDRGroup(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"UpdateRDiskDRGroup\", reflect.TypeOf((*MockMasterService)(nil).UpdateRDiskDRGroup), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 897,
        "code_end_line": 907,
        "code_key": "UpdateRDiskDRGroup",
        "code_value": "func (m *MockMasterClientProxy) UpdateRDiskDRGroup(ctx context.Context, req *UpdateRDiskDRGroupRequest, opts ...client.Option) (*UpdateRDiskDRGroupResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"UpdateRDiskDRGroup\", varargs...)\n\tret0, _ := ret[0].(*UpdateRDiskDRGroupResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 910,
        "code_end_line": 914,
        "code_key": "UpdateRDiskDRGroup",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) UpdateRDiskDRGroup(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"UpdateRDiskDRGroup\", reflect.TypeOf((*MockMasterClientProxy)(nil).UpdateRDiskDRGroup), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 286,
        "code_end_line": 306,
        "code_key": "UpdateRDiskDRGroup",
        "code_value": "func (s *masterApiServerImpl) UpdateRDiskDRGroup(ctx context.Context, req *pb.UpdateRDiskDRGroupRequest) (*pb.UpdateRDiskDRGroupResponse, error) {\n\tcmd := commands.UpdateLogicalVolumeDRGroupCommand{\n\t\tAppID: users.AppID(req.AppId),\n\t\tUUIDs: functools.Map(req.CbsUuids, uuid.MustParse),\n\t\tSpecs: functools.MapTo(req.AffinitySpecs,\n\t\t\tfunctools.MapRef(make([]drgroup.Spec, len(req.AffinitySpecs))),\n\t\t\tparseAffinitySpec),\n\t\tDryRun: req.DryRun,\n\t}\n\tif err := cmd.Prepare(ctx); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, &cmd); err != nil {\n\t\tif errors.IsCode(err, errors.ErrDryRunSuccessExit) {\n\t\t\treturn &pb.UpdateRDiskDRGroupResponse{}, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn &pb.UpdateRDiskDRGroupResponse{}, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 719,
        "code_end_line": 721,
        "code_key": "CleanupRDiskVol",
        "code_value": "func (s *UnimplementedMaster) CleanupRDiskVol(ctx context.Context, req *CleanupRDiskVolRequest) (*CleanupRDiskVolResponse, error) {\n\treturn nil, errors.New(\"rpc CleanupRDiskVol of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1137,
        "code_end_line": 1155,
        "code_key": "CleanupRDiskVol",
        "code_value": "func (c *MasterClientProxyImpl) CleanupRDiskVol(ctx context.Context, req *CleanupRDiskVolRequest, opts ...client.Option) (*CleanupRDiskVolResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/CleanupRDiskVol\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"CleanupRDiskVol\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &CleanupRDiskVolResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 84,
        "code_end_line": 90,
        "code_key": "CleanupRDiskVol",
        "code_value": "func (m *MockMasterService) CleanupRDiskVol(ctx context.Context, req *CleanupRDiskVolRequest) (*CleanupRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CleanupRDiskVol\", ctx, req)\n\tret0, _ := ret[0].(*CleanupRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 93,
        "code_end_line": 96,
        "code_key": "CleanupRDiskVol",
        "code_value": "func (mr *MockMasterServiceMockRecorder) CleanupRDiskVol(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CleanupRDiskVol\", reflect.TypeOf((*MockMasterService)(nil).CleanupRDiskVol), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 497,
        "code_end_line": 507,
        "code_key": "CleanupRDiskVol",
        "code_value": "func (m *MockMasterClientProxy) CleanupRDiskVol(ctx context.Context, req *CleanupRDiskVolRequest, opts ...client.Option) (*CleanupRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"CleanupRDiskVol\", varargs...)\n\tret0, _ := ret[0].(*CleanupRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 510,
        "code_end_line": 514,
        "code_key": "CleanupRDiskVol",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) CleanupRDiskVol(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CleanupRDiskVol\", reflect.TypeOf((*MockMasterClientProxy)(nil).CleanupRDiskVol), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 73,
        "code_end_line": 84,
        "code_key": "CleanupRDiskVol",
        "code_value": "func (*masterApiServerImpl) CleanupRDiskVol(ctx context.Context, req *pb.CleanupRDiskVolRequest) (*pb.CleanupRDiskVolResponse, error) {\n\tvar dispatcher = app.GetRegistry(ctx).Dispatcher\n\n\tcmd := &commands.CleanupLogicalVolumeCommand{\n\t\tUUID: uuid.MustParse(req.CbsUuid),\n\t\tIP:   net.ParseIP(req.HostIp),\n\t}\n\tif err := dispatcher.Dispatch(ctx, cmd); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &pb.CleanupRDiskVolResponse{}, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 724,
        "code_end_line": 726,
        "code_key": "CreatePhyRDisk",
        "code_value": "func (s *UnimplementedMaster) CreatePhyRDisk(ctx context.Context, req *CreatePhyRDiskRequest) (*CreatePhyRDiskResponse, error) {\n\treturn nil, errors.New(\"rpc CreatePhyRDisk of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1157,
        "code_end_line": 1175,
        "code_key": "CreatePhyRDisk",
        "code_value": "func (c *MasterClientProxyImpl) CreatePhyRDisk(ctx context.Context, req *CreatePhyRDiskRequest, opts ...client.Option) (*CreatePhyRDiskResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/CreatePhyRDisk\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"CreatePhyRDisk\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &CreatePhyRDiskResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 114,
        "code_end_line": 120,
        "code_key": "CreatePhyRDisk",
        "code_value": "func (m *MockMasterService) CreatePhyRDisk(ctx context.Context, req *CreatePhyRDiskRequest) (*CreatePhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CreatePhyRDisk\", ctx, req)\n\tret0, _ := ret[0].(*CreatePhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 123,
        "code_end_line": 126,
        "code_key": "CreatePhyRDisk",
        "code_value": "func (mr *MockMasterServiceMockRecorder) CreatePhyRDisk(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreatePhyRDisk\", reflect.TypeOf((*MockMasterService)(nil).CreatePhyRDisk), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 537,
        "code_end_line": 547,
        "code_key": "CreatePhyRDisk",
        "code_value": "func (m *MockMasterClientProxy) CreatePhyRDisk(ctx context.Context, req *CreatePhyRDiskRequest, opts ...client.Option) (*CreatePhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"CreatePhyRDisk\", varargs...)\n\tret0, _ := ret[0].(*CreatePhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 550,
        "code_end_line": 554,
        "code_key": "CreatePhyRDisk",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) CreatePhyRDisk(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreatePhyRDisk\", reflect.TypeOf((*MockMasterClientProxy)(nil).CreatePhyRDisk), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 603,
        "code_end_line": 654,
        "code_key": "CreatePhyRDisk",
        "code_value": "func (s *masterApiServerImpl) CreatePhyRDisk(ctx context.Context, req *pb.CreatePhyRDiskRequest) (*pb.CreatePhyRDiskResponse, error) {\n\tcmd := commands.CreatePhysicalVolumeCommand{\n\t\tSerial:          req.PhyId,\n\t\tHost:            net.ParseIP(req.HostIp),\n\t\tBDF:             req.BdfId,\n\t\tSize:            req.Size,\n\t\tZoneID:          req.ZoneId,\n\t\tVolumeType:      req.VolumeType,\n\t\tCuf:             req.Cuf,\n\t\tPerformanceRank: req.PerformanceRank,\n\t}\n\n\tswitch req.Type {\n\tcase pb.DataNodeType_unknown:\n\t\tcmd.DataNodeType = rdiskDomain.DataNodeTypeUnknown\n\tcase pb.DataNodeType_mix:\n\t\tcmd.DataNodeType = rdiskDomain.DataNodeTypeMix\n\tcase pb.DataNodeType_monopoly:\n\t\tcmd.DataNodeType = rdiskDomain.DataNodeTypeMonopoly\n\t}\n\n\terr := app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, &cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &pb.CreatePhyRDiskResponse{\n\t\tPhyDisk: &pb.PhyRDisk{\n\t\t\tPhyId:  req.PhyId,\n\t\t\tBdfId:  req.BdfId,\n\t\t\tStatus: \"inited\",\n\t\t\tSize:   req.Size,\n\t\t\tZoneId: req.ZoneId,\n\t\t\tNode: &pb.DataNode{\n\t\t\t\tHostIp: req.HostIp,\n\t\t\t\tStatus: \"online\",\n\t\t\t},\n\t\t\tCuf: req.Cuf,\n\t\t},\n\t}\n\n\t// 查询物理卷状态\n\tresults, err := app.GetRegistry(ctx).Viewers.PhysicalVolume.QueryBySerial(ctx, []string{req.PhyId})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(results) == 1 {\n\t\tvol := results[0]\n\t\tencodePhysicalVolume(vol, response.PhyDisk)\n\t}\n\treturn response, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 729,
        "code_end_line": 731,
        "code_key": "DeletePhyRDisk",
        "code_value": "func (s *UnimplementedMaster) DeletePhyRDisk(ctx context.Context, req *DeletePhyRDiskRequest) (*DeletePhyRDiskResponse, error) {\n\treturn nil, errors.New(\"rpc DeletePhyRDisk of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1177,
        "code_end_line": 1195,
        "code_key": "DeletePhyRDisk",
        "code_value": "func (c *MasterClientProxyImpl) DeletePhyRDisk(ctx context.Context, req *DeletePhyRDiskRequest, opts ...client.Option) (*DeletePhyRDiskResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/DeletePhyRDisk\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"DeletePhyRDisk\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &DeletePhyRDiskResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 204,
        "code_end_line": 210,
        "code_key": "DeletePhyRDisk",
        "code_value": "func (m *MockMasterService) DeletePhyRDisk(ctx context.Context, req *DeletePhyRDiskRequest) (*DeletePhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"DeletePhyRDisk\", ctx, req)\n\tret0, _ := ret[0].(*DeletePhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 213,
        "code_end_line": 216,
        "code_key": "DeletePhyRDisk",
        "code_value": "func (mr *MockMasterServiceMockRecorder) DeletePhyRDisk(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeletePhyRDisk\", reflect.TypeOf((*MockMasterService)(nil).DeletePhyRDisk), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 657,
        "code_end_line": 667,
        "code_key": "DeletePhyRDisk",
        "code_value": "func (m *MockMasterClientProxy) DeletePhyRDisk(ctx context.Context, req *DeletePhyRDiskRequest, opts ...client.Option) (*DeletePhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"DeletePhyRDisk\", varargs...)\n\tret0, _ := ret[0].(*DeletePhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 670,
        "code_end_line": 674,
        "code_key": "DeletePhyRDisk",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) DeletePhyRDisk(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeletePhyRDisk\", reflect.TypeOf((*MockMasterClientProxy)(nil).DeletePhyRDisk), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 657,
        "code_end_line": 676,
        "code_key": "DeletePhyRDisk",
        "code_value": "func (s *masterApiServerImpl) DeletePhyRDisk(ctx context.Context, req *pb.DeletePhyRDiskRequest) (*pb.DeletePhyRDiskResponse, error) {\n\tvar (\n\t\terr      error\n\t\tresponse *pb.DeletePhyRDiskResponse\n\t\tcmd      *commands.DeletePhysicalVolumeCommand\n\t)\n\tcmd = &commands.DeletePhysicalVolumeCommand{\n\t\tSerial: req.PhyId,\n\t\tForce:  req.Force,\n\t}\n\terr = app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, cmd)\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn &pb.DeletePhyRDiskResponse{}, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\tresponse = &pb.DeletePhyRDiskResponse{}\n\treturn response, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 734,
        "code_end_line": 736,
        "code_key": "QueryPhyRDiskInfo",
        "code_value": "func (s *UnimplementedMaster) QueryPhyRDiskInfo(ctx context.Context, req *QueryPhyRDiskInfoRequest) (*QueryPhyRDiskInfoResponse, error) {\n\treturn nil, errors.New(\"rpc QueryPhyRDiskInfo of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1197,
        "code_end_line": 1215,
        "code_key": "QueryPhyRDiskInfo",
        "code_value": "func (c *MasterClientProxyImpl) QueryPhyRDiskInfo(ctx context.Context, req *QueryPhyRDiskInfoRequest, opts ...client.Option) (*QueryPhyRDiskInfoResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/QueryPhyRDiskInfo\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"QueryPhyRDiskInfo\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &QueryPhyRDiskInfoResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 309,
        "code_end_line": 315,
        "code_key": "QueryPhyRDiskInfo",
        "code_value": "func (m *MockMasterService) QueryPhyRDiskInfo(ctx context.Context, req *QueryPhyRDiskInfoRequest) (*QueryPhyRDiskInfoResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"QueryPhyRDiskInfo\", ctx, req)\n\tret0, _ := ret[0].(*QueryPhyRDiskInfoResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 318,
        "code_end_line": 321,
        "code_key": "QueryPhyRDiskInfo",
        "code_value": "func (mr *MockMasterServiceMockRecorder) QueryPhyRDiskInfo(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryPhyRDiskInfo\", reflect.TypeOf((*MockMasterService)(nil).QueryPhyRDiskInfo), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 797,
        "code_end_line": 807,
        "code_key": "QueryPhyRDiskInfo",
        "code_value": "func (m *MockMasterClientProxy) QueryPhyRDiskInfo(ctx context.Context, req *QueryPhyRDiskInfoRequest, opts ...client.Option) (*QueryPhyRDiskInfoResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"QueryPhyRDiskInfo\", varargs...)\n\tret0, _ := ret[0].(*QueryPhyRDiskInfoResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 810,
        "code_end_line": 814,
        "code_key": "QueryPhyRDiskInfo",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) QueryPhyRDiskInfo(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryPhyRDiskInfo\", reflect.TypeOf((*MockMasterClientProxy)(nil).QueryPhyRDiskInfo), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 715,
        "code_end_line": 752,
        "code_key": "QueryPhyRDiskInfo",
        "code_value": "func (*masterApiServerImpl) QueryPhyRDiskInfo(ctx context.Context, req *pb.QueryPhyRDiskInfoRequest) (*pb.QueryPhyRDiskInfoResponse, error) {\n\tvar (\n\t\terr        error\n\t\tresponse   = &pb.QueryPhyRDiskInfoResponse{}\n\t\tview       = app.GetRegistry(ctx).Viewers.PhysicalVolume\n\t\tpagination rdiskDomain.Pagination\n\t)\n\tif req.Page != nil {\n\t\tpagination = rdiskDomain.Pagination{\n\t\t\tLimit:  req.Page.PageSize,\n\t\t\tOffset: req.Page.Page * req.Page.PageSize,\n\t\t}\n\t} else {\n\t\tpagination = rdiskDomain.Pagination{\n\t\t\tLimit:  100,\n\t\t\tOffset: 0,\n\t\t}\n\t}\n\tcriteria := rdiskDomain.PVSearchCriteria{}\n\tif len(req.HostIps) > 0 {\n\t\tcriteria.IPs = functools.Map(req.HostIps, net.ParseIP)\n\t}\n\tif len(req.PhyIds) > 0 {\n\t\tcriteria.Serials = functools.Map(req.PhyIds, func(id string) rdiskDomain.Serial { return rdiskDomain.Serial(id) })\n\t}\n\tif len(req.ZoneIds) > 0 {\n\t\tcriteria.ZoneIDs = functools.Map(req.ZoneIds, func(id uint64) rdiskDomain.ZoneID { return rdiskDomain.ZoneID(id) })\n\t}\n\tcriteria.AvailableOnly = req.AvailableOnly\n\tresults, err := view.Search(ctx, criteria, pagination)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse.PhyDisk = functools.MapRef(make([]pb.PhyRDisk, len(results)))\n\tfunctools.MapTo(results, response.PhyDisk, encodePhysicalVolume)\n\treturn response, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 739,
        "code_end_line": 741,
        "code_key": "UpdatePhyRDisk",
        "code_value": "func (s *UnimplementedMaster) UpdatePhyRDisk(ctx context.Context, req *UpdatePhyRDiskRequest) (*UpdatePhyRDiskResponse, error) {\n\treturn nil, errors.New(\"rpc UpdatePhyRDisk of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1217,
        "code_end_line": 1235,
        "code_key": "UpdatePhyRDisk",
        "code_value": "func (c *MasterClientProxyImpl) UpdatePhyRDisk(ctx context.Context, req *UpdatePhyRDiskRequest, opts ...client.Option) (*UpdatePhyRDiskResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/UpdatePhyRDisk\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"UpdatePhyRDisk\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &UpdatePhyRDiskResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 369,
        "code_end_line": 375,
        "code_key": "UpdatePhyRDisk",
        "code_value": "func (m *MockMasterService) UpdatePhyRDisk(ctx context.Context, req *UpdatePhyRDiskRequest) (*UpdatePhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"UpdatePhyRDisk\", ctx, req)\n\tret0, _ := ret[0].(*UpdatePhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 378,
        "code_end_line": 381,
        "code_key": "UpdatePhyRDisk",
        "code_value": "func (mr *MockMasterServiceMockRecorder) UpdatePhyRDisk(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"UpdatePhyRDisk\", reflect.TypeOf((*MockMasterService)(nil).UpdatePhyRDisk), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 877,
        "code_end_line": 887,
        "code_key": "UpdatePhyRDisk",
        "code_value": "func (m *MockMasterClientProxy) UpdatePhyRDisk(ctx context.Context, req *UpdatePhyRDiskRequest, opts ...client.Option) (*UpdatePhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"UpdatePhyRDisk\", varargs...)\n\tret0, _ := ret[0].(*UpdatePhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 890,
        "code_end_line": 894,
        "code_key": "UpdatePhyRDisk",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) UpdatePhyRDisk(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"UpdatePhyRDisk\", reflect.TypeOf((*MockMasterClientProxy)(nil).UpdatePhyRDisk), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 44,
        "code_end_line": 70,
        "code_key": "UpdatePhyRDisk",
        "code_value": "func (s *masterApiServerImpl) UpdatePhyRDisk(ctx context.Context, req *pb.UpdatePhyRDiskRequest) (*pb.UpdatePhyRDiskResponse, error) {\n\tvar dispatcher = app.GetRegistry(ctx).Dispatcher\n\n\tcmd := &commands.UpdatePhyRDiskCommand{\n\t\tSerial: req.PhyId,\n\t\tParams: rdiskDomain.PhysicalVolumeParamsModification{},\n\t}\n\n\tif len(req.Params) == 0 {\n\t\treturn nil, fmt.Errorf(\"no params\")\n\t}\n\n\tif cufString, ok := req.Params[\"cuf\"]; ok {\n\t\tvar cuf = rdiskDomain.Cuf(cufString)\n\t\tcmd.Params.Cuf = &cuf\n\t}\n\n\tif rankString, ok := req.Params[\"performance_rank\"]; ok {\n\t\tvar rank = rdiskDomain.PerformanceRank(rankString)\n\t\tcmd.Params.PerformanceRank = &rank\n\t}\n\n\tif err := dispatcher.Dispatch(ctx, cmd); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &pb.UpdatePhyRDiskResponse{}, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 744,
        "code_end_line": 746,
        "code_key": "OnlinePhyRDisk",
        "code_value": "func (s *UnimplementedMaster) OnlinePhyRDisk(ctx context.Context, req *OnlinePhyRDiskRequest) (*OnlinePhyRDiskResponse, error) {\n\treturn nil, errors.New(\"rpc OnlinePhyRDisk of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1237,
        "code_end_line": 1255,
        "code_key": "OnlinePhyRDisk",
        "code_value": "func (c *MasterClientProxyImpl) OnlinePhyRDisk(ctx context.Context, req *OnlinePhyRDiskRequest, opts ...client.Option) (*OnlinePhyRDiskResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/OnlinePhyRDisk\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"OnlinePhyRDisk\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &OnlinePhyRDiskResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 279,
        "code_end_line": 285,
        "code_key": "OnlinePhyRDisk",
        "code_value": "func (m *MockMasterService) OnlinePhyRDisk(ctx context.Context, req *OnlinePhyRDiskRequest) (*OnlinePhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"OnlinePhyRDisk\", ctx, req)\n\tret0, _ := ret[0].(*OnlinePhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 288,
        "code_end_line": 291,
        "code_key": "OnlinePhyRDisk",
        "code_value": "func (mr *MockMasterServiceMockRecorder) OnlinePhyRDisk(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"OnlinePhyRDisk\", reflect.TypeOf((*MockMasterService)(nil).OnlinePhyRDisk), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 757,
        "code_end_line": 767,
        "code_key": "OnlinePhyRDisk",
        "code_value": "func (m *MockMasterClientProxy) OnlinePhyRDisk(ctx context.Context, req *OnlinePhyRDiskRequest, opts ...client.Option) (*OnlinePhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"OnlinePhyRDisk\", varargs...)\n\tret0, _ := ret[0].(*OnlinePhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 770,
        "code_end_line": 774,
        "code_key": "OnlinePhyRDisk",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) OnlinePhyRDisk(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"OnlinePhyRDisk\", reflect.TypeOf((*MockMasterClientProxy)(nil).OnlinePhyRDisk), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 697,
        "code_end_line": 712,
        "code_key": "OnlinePhyRDisk",
        "code_value": "func (s *masterApiServerImpl) OnlinePhyRDisk(ctx context.Context, req *pb.OnlinePhyRDiskRequest) (*pb.OnlinePhyRDiskResponse, error) {\n\tvar (\n\t\terr      error\n\t\tresponse = &pb.OnlinePhyRDiskResponse{}\n\t\tcmd      *commands.OnlinePhysicalVolumeCommand\n\t)\n\tcmd = &commands.OnlinePhysicalVolumeCommand{\n\t\tSerial: req.PhyId,\n\t}\n\terr = app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, cmd)\n\tresponse.PhyDisk = &pb.PhyRDisk{}\n\tif cmd.GetPhysicalVolume() != nil {\n\t\tencodePhysicalVolume(cmd.GetPhysicalVolume(), response.PhyDisk)\n\t}\n\treturn response, err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 749,
        "code_end_line": 751,
        "code_key": "OfflinePhyRDisk",
        "code_value": "func (s *UnimplementedMaster) OfflinePhyRDisk(ctx context.Context, req *OfflinePhyRDiskRequest) (*OfflinePhyRDiskResponse, error) {\n\treturn nil, errors.New(\"rpc OfflinePhyRDisk of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1257,
        "code_end_line": 1275,
        "code_key": "OfflinePhyRDisk",
        "code_value": "func (c *MasterClientProxyImpl) OfflinePhyRDisk(ctx context.Context, req *OfflinePhyRDiskRequest, opts ...client.Option) (*OfflinePhyRDiskResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/OfflinePhyRDisk\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"OfflinePhyRDisk\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &OfflinePhyRDiskResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 264,
        "code_end_line": 270,
        "code_key": "OfflinePhyRDisk",
        "code_value": "func (m *MockMasterService) OfflinePhyRDisk(ctx context.Context, req *OfflinePhyRDiskRequest) (*OfflinePhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"OfflinePhyRDisk\", ctx, req)\n\tret0, _ := ret[0].(*OfflinePhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 273,
        "code_end_line": 276,
        "code_key": "OfflinePhyRDisk",
        "code_value": "func (mr *MockMasterServiceMockRecorder) OfflinePhyRDisk(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"OfflinePhyRDisk\", reflect.TypeOf((*MockMasterService)(nil).OfflinePhyRDisk), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 737,
        "code_end_line": 747,
        "code_key": "OfflinePhyRDisk",
        "code_value": "func (m *MockMasterClientProxy) OfflinePhyRDisk(ctx context.Context, req *OfflinePhyRDiskRequest, opts ...client.Option) (*OfflinePhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"OfflinePhyRDisk\", varargs...)\n\tret0, _ := ret[0].(*OfflinePhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 750,
        "code_end_line": 754,
        "code_key": "OfflinePhyRDisk",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) OfflinePhyRDisk(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"OfflinePhyRDisk\", reflect.TypeOf((*MockMasterClientProxy)(nil).OfflinePhyRDisk), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 679,
        "code_end_line": 694,
        "code_key": "OfflinePhyRDisk",
        "code_value": "func (s *masterApiServerImpl) OfflinePhyRDisk(ctx context.Context, req *pb.OfflinePhyRDiskRequest) (*pb.OfflinePhyRDiskResponse, error) {\n\tvar (\n\t\terr      error\n\t\tresponse = &pb.OfflinePhyRDiskResponse{}\n\t\tcmd      *commands.OfflinePhysicalVolumeCommand\n\t)\n\tcmd = &commands.OfflinePhysicalVolumeCommand{\n\t\tSerial: req.PhyId,\n\t}\n\terr = app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, cmd)\n\tresponse.PhyDisk = &pb.PhyRDisk{}\n\tif cmd.GetPhysicalVolume() != nil {\n\t\tencodePhysicalVolume(cmd.GetPhysicalVolume(), response.PhyDisk)\n\t}\n\treturn response, err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 754,
        "code_end_line": 756,
        "code_key": "BenchmarkPhyRDisk",
        "code_value": "func (s *UnimplementedMaster) BenchmarkPhyRDisk(ctx context.Context, req *BenchmarkPhyRDiskRequest) (*BenchmarkPhyRDiskResponse, error) {\n\treturn nil, errors.New(\"rpc BenchmarkPhyRDisk of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1277,
        "code_end_line": 1295,
        "code_key": "BenchmarkPhyRDisk",
        "code_value": "func (c *MasterClientProxyImpl) BenchmarkPhyRDisk(ctx context.Context, req *BenchmarkPhyRDiskRequest, opts ...client.Option) (*BenchmarkPhyRDiskResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/BenchmarkPhyRDisk\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"BenchmarkPhyRDisk\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &BenchmarkPhyRDiskResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 54,
        "code_end_line": 60,
        "code_key": "BenchmarkPhyRDisk",
        "code_value": "func (m *MockMasterService) BenchmarkPhyRDisk(ctx context.Context, req *BenchmarkPhyRDiskRequest) (*BenchmarkPhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"BenchmarkPhyRDisk\", ctx, req)\n\tret0, _ := ret[0].(*BenchmarkPhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 63,
        "code_end_line": 66,
        "code_key": "BenchmarkPhyRDisk",
        "code_value": "func (mr *MockMasterServiceMockRecorder) BenchmarkPhyRDisk(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"BenchmarkPhyRDisk\", reflect.TypeOf((*MockMasterService)(nil).BenchmarkPhyRDisk), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 457,
        "code_end_line": 467,
        "code_key": "BenchmarkPhyRDisk",
        "code_value": "func (m *MockMasterClientProxy) BenchmarkPhyRDisk(ctx context.Context, req *BenchmarkPhyRDiskRequest, opts ...client.Option) (*BenchmarkPhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"BenchmarkPhyRDisk\", varargs...)\n\tret0, _ := ret[0].(*BenchmarkPhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 470,
        "code_end_line": 474,
        "code_key": "BenchmarkPhyRDisk",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) BenchmarkPhyRDisk(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"BenchmarkPhyRDisk\", reflect.TypeOf((*MockMasterClientProxy)(nil).BenchmarkPhyRDisk), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 109,
        "code_end_line": 124,
        "code_key": "BenchmarkPhyRDisk",
        "code_value": "func (*masterApiServerImpl) BenchmarkPhyRDisk(ctx context.Context, req *pb.BenchmarkPhyRDiskRequest) (*pb.BenchmarkPhyRDiskResponse, error) {\n\tvar dispatcher = app.GetRegistry(ctx).Dispatcher\n\n\tcmd := &commands.CreateBenchmarkCommand{\n\t\tSerial: req.PhyId,\n\t}\n\n\tif err := dispatcher.Dispatch(ctx, cmd); err != nil {\n\t\treturn nil, err\n\t}\n\n\tresp := &pb.BenchmarkPhyRDiskResponse{}\n\tresp.TaskId = cmd.GetBenchmark().UUID.String()\n\n\treturn resp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 759,
        "code_end_line": 761,
        "code_key": "QueryPhyRDiskBenchmark",
        "code_value": "func (s *UnimplementedMaster) QueryPhyRDiskBenchmark(ctx context.Context, req *QueryPhyRDiskBenchmarkRequest) (*QueryPhyRDiskBenchmarkResponse, error) {\n\treturn nil, errors.New(\"rpc QueryPhyRDiskBenchmark of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1297,
        "code_end_line": 1315,
        "code_key": "QueryPhyRDiskBenchmark",
        "code_value": "func (c *MasterClientProxyImpl) QueryPhyRDiskBenchmark(ctx context.Context, req *QueryPhyRDiskBenchmarkRequest, opts ...client.Option) (*QueryPhyRDiskBenchmarkResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/QueryPhyRDiskBenchmark\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"QueryPhyRDiskBenchmark\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &QueryPhyRDiskBenchmarkResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 294,
        "code_end_line": 300,
        "code_key": "QueryPhyRDiskBenchmark",
        "code_value": "func (m *MockMasterService) QueryPhyRDiskBenchmark(ctx context.Context, req *QueryPhyRDiskBenchmarkRequest) (*QueryPhyRDiskBenchmarkResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"QueryPhyRDiskBenchmark\", ctx, req)\n\tret0, _ := ret[0].(*QueryPhyRDiskBenchmarkResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 303,
        "code_end_line": 306,
        "code_key": "QueryPhyRDiskBenchmark",
        "code_value": "func (mr *MockMasterServiceMockRecorder) QueryPhyRDiskBenchmark(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryPhyRDiskBenchmark\", reflect.TypeOf((*MockMasterService)(nil).QueryPhyRDiskBenchmark), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 777,
        "code_end_line": 787,
        "code_key": "QueryPhyRDiskBenchmark",
        "code_value": "func (m *MockMasterClientProxy) QueryPhyRDiskBenchmark(ctx context.Context, req *QueryPhyRDiskBenchmarkRequest, opts ...client.Option) (*QueryPhyRDiskBenchmarkResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"QueryPhyRDiskBenchmark\", varargs...)\n\tret0, _ := ret[0].(*QueryPhyRDiskBenchmarkResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 790,
        "code_end_line": 794,
        "code_key": "QueryPhyRDiskBenchmark",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) QueryPhyRDiskBenchmark(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryPhyRDiskBenchmark\", reflect.TypeOf((*MockMasterClientProxy)(nil).QueryPhyRDiskBenchmark), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 127,
        "code_end_line": 177,
        "code_key": "QueryPhyRDiskBenchmark",
        "code_value": "func (*masterApiServerImpl) QueryPhyRDiskBenchmark(ctx context.Context, req *pb.QueryPhyRDiskBenchmarkRequest) (*pb.QueryPhyRDiskBenchmarkResponse, error) {\n\tvar (\n\t\tviewer     = app.GetRegistry(ctx).Viewers.Benchmark\n\t\tdiskSerial = req.PhyId\n\t\tbakUuids   = req.TaskId\n\t\tresp       = &pb.QueryPhyRDiskBenchmarkResponse{}\n\t)\n\n\tif len(bakUuids) == 0 {\n\t\tbakUuids = nil\n\t}\n\n\tresults, err := viewer.FindByDisk(ctx, diskSerial, bakUuids)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tencodeFunc := func(b *benchmark.Benchmark, r *pb.BenchmarkResult) {\n\t\tr.TaskId = b.UUID.String()\n\t\tr.PhyId = b.DiskInfo.Serial\n\t\tr.ErrorMsg = b.Error\n\t\tr.HostIp = b.DiskInfo.HostIP.String()\n\t\tr.BdfId = b.DiskInfo.BDF\n\t\tr.Created = timestamppb.New(b.Created)\n\t\tr.Finished = timestamppb.New(b.Finished)\n\t\tr.ReadBw = b.Stat.ReadBandwidth\n\t\tr.WriteBw = b.Stat.WriteBandwidth\n\t\tr.ReadLat = b.Stat.ReadLatency\n\t\tr.WriteLat = b.Stat.WriteLatency\n\t\tswitch b.Status {\n\t\tcase benchmark.StatusInited:\n\t\t\tr.Status = \"inited\"\n\t\tcase benchmark.StatusRunning:\n\t\t\tr.Status = \"running\"\n\t\tcase benchmark.StatusFailed:\n\t\t\tr.Status = \"failed\"\n\t\tcase benchmark.StatusSuccess:\n\t\t\tr.Status = \"success\"\n\t\tdefault:\n\t\t\tr.Status = \"unknown\"\n\t\t}\n\t}\n\n\tresp.Result = functools.MapTo(\n\t\tresults,\n\t\tfunctools.MapRef(make([]pb.BenchmarkResult, len(results))),\n\t\tencodeFunc,\n\t)\n\n\treturn resp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 764,
        "code_end_line": 766,
        "code_key": "DefunctPhyRDisk",
        "code_value": "func (s *UnimplementedMaster) DefunctPhyRDisk(ctx context.Context, req *DefunctPhyRDiskRequest) (*DefunctPhyRDiskResponse, error) {\n\treturn nil, errors.New(\"rpc DefunctPhyRDisk of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1317,
        "code_end_line": 1335,
        "code_key": "DefunctPhyRDisk",
        "code_value": "func (c *MasterClientProxyImpl) DefunctPhyRDisk(ctx context.Context, req *DefunctPhyRDiskRequest, opts ...client.Option) (*DefunctPhyRDiskResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/DefunctPhyRDisk\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"DefunctPhyRDisk\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &DefunctPhyRDiskResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 189,
        "code_end_line": 195,
        "code_key": "DefunctPhyRDisk",
        "code_value": "func (m *MockMasterService) DefunctPhyRDisk(ctx context.Context, req *DefunctPhyRDiskRequest) (*DefunctPhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"DefunctPhyRDisk\", ctx, req)\n\tret0, _ := ret[0].(*DefunctPhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 198,
        "code_end_line": 201,
        "code_key": "DefunctPhyRDisk",
        "code_value": "func (mr *MockMasterServiceMockRecorder) DefunctPhyRDisk(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DefunctPhyRDisk\", reflect.TypeOf((*MockMasterService)(nil).DefunctPhyRDisk), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 637,
        "code_end_line": 647,
        "code_key": "DefunctPhyRDisk",
        "code_value": "func (m *MockMasterClientProxy) DefunctPhyRDisk(ctx context.Context, req *DefunctPhyRDiskRequest, opts ...client.Option) (*DefunctPhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"DefunctPhyRDisk\", varargs...)\n\tret0, _ := ret[0].(*DefunctPhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 650,
        "code_end_line": 654,
        "code_key": "DefunctPhyRDisk",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) DefunctPhyRDisk(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DefunctPhyRDisk\", reflect.TypeOf((*MockMasterClientProxy)(nil).DefunctPhyRDisk), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 87,
        "code_end_line": 106,
        "code_key": "DefunctPhyRDisk",
        "code_value": "func (*masterApiServerImpl) DefunctPhyRDisk(ctx context.Context, req *pb.DefunctPhyRDiskRequest) (*pb.DefunctPhyRDiskResponse, error) {\n\tvar dispatcher = app.GetRegistry(ctx).Dispatcher\n\tvar cmd = &commands.DefunctPhysicalVolumeCommand{\n\t\tSerial:         rdiskDomain.Serial(req.PhyId),\n\t\tHostIP:         net.ParseIP(req.HostIp),\n\t\tBDF:            rdiskDomain.BDF(req.BdfId),\n\t\tAuthorizeToken: req.AuthorizeToken,\n\t}\n\n\tif err := cmd.Prepare(ctx); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := dispatcher.Dispatch(ctx, cmd); err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar resp = &pb.DefunctPhyRDiskResponse{}\n\treturn resp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.pb.validate.go",
        "code_start_line": 131,
        "code_end_line": 137,
        "code_key": "_validateUuid",
        "code_value": "func (m *RDisk) _validateUuid(uuid string) error {\n\tif matched := _rdisk_master_uuidPattern.MatchString(uuid); !matched {\n\t\treturn errors.New(\"invalid uuid format\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.pb.validate.go",
        "code_start_line": 1061,
        "code_end_line": 1067,
        "code_key": "_validateUuid",
        "code_value": "func (m *QueryRDiskVolRequest) _validateUuid(uuid string) error {\n\tif matched := _rdisk_master_uuidPattern.MatchString(uuid); !matched {\n\t\treturn errors.New(\"invalid uuid format\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.pb.validate.go",
        "code_start_line": 1328,
        "code_end_line": 1334,
        "code_key": "_validateUuid",
        "code_value": "func (m *DeleteRDiskVolRequest) _validateUuid(uuid string) error {\n\tif matched := _rdisk_master_uuidPattern.MatchString(uuid); !matched {\n\t\treturn errors.New(\"invalid uuid format\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.pb.validate.go",
        "code_start_line": 1590,
        "code_end_line": 1596,
        "code_key": "_validateUuid",
        "code_value": "func (m *UpdateRDiskFlowCtrlRequest) _validateUuid(uuid string) error {\n\tif matched := _rdisk_master_uuidPattern.MatchString(uuid); !matched {\n\t\treturn errors.New(\"invalid uuid format\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.pb.validate.go",
        "code_start_line": 1966,
        "code_end_line": 1972,
        "code_key": "_validateUuid",
        "code_value": "func (m *AttachRDiskVolRequest) _validateUuid(uuid string) error {\n\tif matched := _rdisk_master_uuidPattern.MatchString(uuid); !matched {\n\t\treturn errors.New(\"invalid uuid format\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.pb.validate.go",
        "code_start_line": 2216,
        "code_end_line": 2222,
        "code_key": "_validateUuid",
        "code_value": "func (m *DetachRDiskVolRequest) _validateUuid(uuid string) error {\n\tif matched := _rdisk_master_uuidPattern.MatchString(uuid); !matched {\n\t\treturn errors.New(\"invalid uuid format\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.pb.validate.go",
        "code_start_line": 6249,
        "code_end_line": 6255,
        "code_key": "_validateUuid",
        "code_value": "func (m *UpdateRDiskDRGroupRequest) _validateUuid(uuid string) error {\n\tif matched := _rdisk_master_uuidPattern.MatchString(uuid); !matched {\n\t\treturn errors.New(\"invalid uuid format\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/hademo/hademo.go",
        "code_start_line": 26,
        "code_end_line": 36,
        "code_key": "initLocker",
        "code_value": "func initLocker(db *gorm.DB) dlock.Locker {\n\tlocker := mysqllock.New(db, mysqllock.Config{\n\t\tTableName:      \"dlock\",\n\t\tLockColumn:     \"lock\",\n\t\tExpireColumn:   \"expire\",\n\t\tTokenColumn:    \"token\", // NOCA:PasswordLeak(误报)\n\t\tLockTypeColumn: \"type\",\n\t\tLockNumsColumn: \"count\",\n\t})\n\treturn locker\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/cmd/rdisk_master/run.go",
        "code_start_line": 83,
        "code_end_line": 92,
        "code_key": "runApiServer",
        "code_value": "func runApiServer(appCtx context.Context, wg *sync.WaitGroup) {\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ts := apiserver.New(appCtx)\n\t\tif err := s.Serve(); err != nil {\n\t\t\tlogs.Fatal(appCtx).Err(err).Msg(\"server exited\")\n\t\t}\n\t}()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/cmd/rdisk_master/run.go",
        "code_start_line": 135,
        "code_end_line": 151,
        "code_key": "initDLocker",
        "code_value": "func initDLocker(ctx context.Context) {\n\tconfig := &app.GlobalRegistry.Config\n\tdb, err := config.MetaDB.DB()\n\tif err != nil {\n\t\tlogs.Fatal(ctx).Err(err).Msg(\"failed to connect to meta db\")\n\t\tpanic(err)\n\t}\n\tdlockConf := dlock_mysql.Config{\n\t\tTableName:      \"dm_locks\",\n\t\tLockColumn:     \"lock_key\",\n\t\tExpireColumn:   \"expired\",\n\t\tTokenColumn:    \"lock_token\", // NOCA:PasswordLeak(误报)\n\t\tLockTypeColumn: \"lock_type\",\n\t\tLockNumsColumn: \"lock_count\",\n\t}\n\tapp.GlobalRegistry.Locker = dlock_mysql.New(db, dlockConf)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/cmd/rdisk_master/run.go",
        "code_start_line": 172,
        "code_end_line": 182,
        "code_key": "initSchedulers",
        "code_value": "func initSchedulers(ctx context.Context) {\n\tapp.GlobalRegistry.Scheduler = scheduler.New(ctx, app.GlobalRegistry.Locker)\n\n\t// 注册定时任务\n\n\tapp.GlobalRegistry.Scheduler.Add(\"update_backup_task\", &tasks.UpdateBackupTask{})\n\tapp.GlobalRegistry.Scheduler.Add(\"recycle_backup_task\", &tasks.RecycleBackupTask{})\n\tapp.GlobalRegistry.Scheduler.Add(\"update_benchmark_task\", &tasks.UpdateBenchmarkTask{})\n\tapp.GlobalRegistry.Scheduler.Add(\"confirm_init_physicaldisk_task\", &tasks.ConfirmInitPhysicalDiskTask{})\n\tapp.GlobalRegistry.Scheduler.Add(\"cleanup_defunct_task\", &tasks.CleanupDefunctTask{})\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/dispatcher/dispatcher.go",
        "code_start_line": 33,
        "code_end_line": 103,
        "code_key": "Dispatch",
        "code_value": "func (d *dispatcherImpl) Dispatch(ctx context.Context, cmd app.Command) (err error) {\n\t// 为什么使用 backgroundCtx 而不是 ctx？\n\t// 因为 ctx 代表调用方的上下文，通常是 rpc 请求上下文。\n\t// 而执行命令的上下文，应该是一个独立的上下文，不应该受到调用方的影响\n\t// 即使由于网络抖动等原因，调用方的上下文已经超时，但是命令执行的上下文仍然应该继续执行。\n\tworkerCtx := context.WithValue(d.backgroundCtx, ctxKeyCommand, cmd)\n\tworkerCtx, cancelFunc := context.WithTimeout(workerCtx, d.workerTimeout)\n\tworkerCtx = logs.GetLogger(ctx).WithContext(workerCtx)\n\tlockKeys := cmd.LockKeys()\n\terrChan := make(chan error, 1)\n\tlockOption := &dlock.Option{\n\t\tRetryStrategy: dlock.ExponentialBackoff(100*time.Millisecond, 6*time.Second),\n\t}\n\td.wg.Add(1)\n\t// 最终打印错误\n\t// TODO: 并发控制最大能同时执行的命令数量\n\tgo func() {\n\t\tdefer d.wg.Done()\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\te, ok := err.(error)\n\t\t\t\tif !ok {\n\t\t\t\t\te = errors.Newf(ErrDispatchPanic, \"dispatcher panic: %v\", err)\n\t\t\t\t}\n\t\t\t\terrChan <- e\n\t\t\t\tlogs.Error(workerCtx).Err(e).Stack().Bytes(\"trace\", debug.Stack()).Msgf(\"command execution panic\")\n\t\t\t}\n\t\t}()\n\n\t\tdefer cancelFunc()\n\n\t\tif lockKeys != nil {\n\t\t\tlock, err := d.locker.ObtainMulti(workerCtx, lockKeys, d.workerTimeout, lockOption)\n\t\t\tif err != nil {\n\t\t\t\terrChan <- err\n\t\t\t\tlogs.Warn(workerCtx).Err(err).Msgf(\"command execution waiting locks timeout\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer lock.Release(workerCtx)\n\t\t}\n\n\t\tuow := app.GetRegistry(ctx).Repositories.UoWFactory.New()\n\t\tworkerCtx = app.GetRegistry(ctx).Repositories.UoWFactory.With(workerCtx, uow)\n\n\t\terr = cmd.Handle(workerCtx)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, errors.ErrDryRunSuccessExit) {\n\t\t\t\terr = nil\n\t\t\t} else {\n\t\t\t\tlogs.Warn(workerCtx).Err(err).Msgf(\"command execution failed\")\n\t\t\t}\n\t\t\t_err := uow.Rollback(workerCtx)\n\t\t\tif _err != nil {\n\t\t\t\tlogs.Error(workerCtx).Err(_err).Msgf(\"unit of work rollback failed\")\n\t\t\t}\n\t\t} else {\n\t\t\terr = uow.Commit(workerCtx)\n\t\t\tif err != nil {\n\t\t\t\tlogs.Error(workerCtx).Err(err).Msgf(\"unit of work commit failed\")\n\t\t\t}\n\t\t}\n\t\terrChan <- err\n\t\tclose(errChan)\n\t}()\n\tselect {\n\tcase err := <-errChan:\n\t\treturn err\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/scheduler.go",
        "code_start_line": 113,
        "code_end_line": 124,
        "code_key": "newHAManager",
        "code_value": "func (s *scheduler) newHAManager(ctx context.Context) easyha.HAManager {\n\thaManager := easyha.New(s, s.locker,\n\t\teasyha.WithNamespace(\"rdmaster-Scheduler\"),\n\t\teasyha.WithCheckInterval(5*time.Second),\n\t\teasyha.WithLockExpired(10*time.Second),\n\t\teasyha.WithLogger(*logs.GetLogger(ctx)))\n\tif s.haManager != nil {\n\t\ts.haManager.Close(ctx)\n\t}\n\ts.haManager = haManager\n\treturn haManager\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/mapper.go",
        "code_start_line": 130,
        "code_end_line": 138,
        "code_key": "encodeRDiskBackup",
        "code_value": "func encodeRDiskBackup(backup *backupDomain.Backup, dto *pb.RDiskBackup) *pb.RDiskBackup {\n\tdto.BackupId = backup.UUID.String()\n\tdto.CbsUuid = backup.DiskInfo.VolumeUUID.String()\n\tdto.Created = timestamppb.New(backup.CreateTime)\n\tdto.Status = mapperBackupStatus2RDiskBackupStatus(backup.Status)\n\tdto.Progress = int32(backup.Percentage)\n\tdto.Size = backup.DiskInfo.VolumeSize\n\treturn dto\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/mapper.go",
        "code_start_line": 140,
        "code_end_line": 147,
        "code_key": "encodeRDiskBackupView",
        "code_value": "func encodeRDiskBackupView(view *backupDomain.View, dto *pb.RDiskBackup) {\n\tdto.BackupId = view.UUID.String()\n\tdto.CbsUuid = view.VolumeUUID.String()\n\tdto.Created = timestamppb.New(view.CreateTime)\n\tdto.Status = mapperBackupStatus2RDiskBackupStatus(view.Status)\n\tdto.Progress = int32(view.Percentage)\n\tdto.Size = view.Size\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 468,
        "code_end_line": 477,
        "code_key": "checkQueryRDiskVolNoEmptyQuery",
        "code_value": "func checkQueryRDiskVolNoEmptyQuery(req *pb.QueryRDiskVolRequest) error {\n\tif req.AppId == 0 &&\n\t\tlen(req.PhyIds) == 0 &&\n\t\tlen(req.HostIps) == 0 &&\n\t\tlen(req.BdfIds) == 0 &&\n\t\tlen(req.CbsUuids) == 0 {\n\t\treturn errors.New(errors.ErrInvalidArgument, \"all query parameters are empty\")\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 480,
        "code_end_line": 485,
        "code_key": "checkQueryRDiskVolBdfIdsMustComeWithHostIps",
        "code_value": "func checkQueryRDiskVolBdfIdsMustComeWithHostIps(req *pb.QueryRDiskVolRequest) error {\n\tif len(req.BdfIds) > 0 && len(req.HostIps) == 0 {\n\t\treturn errors.New(errors.ErrInvalidArgument, \"bdf_ids must be used with host_ips together\")\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 80,
        "code_end_line": 102,
        "code_key": "checkPhysicalVolume",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) checkPhysicalVolume(ctx context.Context) error {\n\tif c.pv == nil {\n\t\treturn nil\n\t}\n\n\tif !c.pv.IP.Equal(c.HostIP) {\n\t\tlogs.Warn(ctx).\n\t\t\tStringer(\"host_ip\", c.HostIP).\n\t\t\tStringer(\"want\", c.pv.IP).\n\t\t\tMsg(\"host ip not match\")\n\t\treturn errors.New(rdiskDomain.ErrInvalidPhysicalVolume, \"host ip not match\")\n\t}\n\n\tif c.pv.BDF != c.BDF {\n\t\tlogs.Warn(ctx).\n\t\t\tStringer(\"bdf\", c.BDF).\n\t\t\tStringer(\"want\", c.pv.BDF).\n\t\t\tMsg(\"bdf not match\")\n\t\treturn errors.New(rdiskDomain.ErrInvalidPhysicalVolume, \"bdf not match\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 143,
        "code_end_line": 190,
        "code_key": "handleBindedVolume",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) handleBindedVolume(ctx context.Context) error {\n\tlogicalVolume, err := app.GetRegistry(ctx).Repositories.LogicalVolume.FindByAppIDAndUUID(ctx, *c.appId, *c.lvUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif logicalVolume.PhysicalVolume.Serial != c.Serial {\n\t\treturn errors.New(\n\t\t\trdiskDomain.ErrInvalidSerial,\n\t\t\tfmt.Sprintf(\"serial not match %s != %s\", string(logicalVolume.PhysicalVolume.Serial), c.Serial))\n\t}\n\n\tif logicalVolume.MustDefunctWithAuthorization() && !c.validateAuthorizeToken(ctx) {\n\t\treturn errors.New(rdiskDomain.ErrUnAuthorizedDefunct, \"unauthorized defunct, vol is binded to a account disk\")\n\t}\n\n\tc.lv = logicalVolume\n\tc.pv = logicalVolume.PhysicalVolume\n\tif err := c.checkPhysicalVolume(ctx); err != nil {\n\t\treturn err\n\t}\n\tc.drgroups, err = app.GetRegistry(ctx).Repositories.DRGroup.FindByMember(ctx, c.lv.AppID, c.lv.UUID.String())\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\tc.drgroups = nil\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tlogs.Warn(ctx).Str(\"token\", c.AuthorizeToken).\n\t\tStr(\"serial\", string(c.Serial)).\n\t\tStr(\"uuid\", c.lvUUID.String()).\n\t\tInt64(\"app_id\", int64(*c.appId)).\n\t\tMsg(\"authorized defunct binded volume\")\n\n\tif _, err := app.GetRegistry(ctx).StateMachines.LogicalVolume.Fire(ctx, c.lv.State,\n\t\trdiskDomain.LVEMarkDefunct, c); err != nil {\n\n\t\tlogs.Error(ctx).Err(err).\n\t\t\tStringer(\"serial\", c.Serial).\n\t\t\tInt64(\"app_id\", int64(*c.appId)).\n\t\t\tStringer(\"uuid\", c.lvUUID).\n\t\t\tMsg(\"failed to mark logical volume as defunct\")\n\t\treturn err\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 202,
        "code_end_line": 211,
        "code_key": "ensureLocks",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) ensureLocks(ctx context.Context) error {\n\trequiredLocks, err := c.queryRequiredLocks(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !slices.Equal(c.aquiredLocks, requiredLocks) {\n\t\treturn errors.New(dispatcher.ErrLockChanged, \"defunct failed\")\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_drgroup.go",
        "code_start_line": 176,
        "code_end_line": 198,
        "code_key": "getOrCreateDRGroup",
        "code_value": "func (c *UpdateLogicalVolumeDRGroupCommand) getOrCreateDRGroup(ctx context.Context, drgRepo drgroup.Repository, spec *drgroup.Spec) (*drgroup.DRGroup, error) {\n\tgroup, err := drgRepo.FindByName(ctx, c.AppID, spec.Name)\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\tgroup = drgroup.New(spec.Name, c.AppID)\n\t\t\tif spec.Affinity > 0 {\n\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t}\n\t\t\tif spec.Type != \"\" {\n\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t}\n\t\t\tif !c.DryRun {\n\t\t\t\terr := drgRepo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn group, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/attach_detach.go",
        "code_start_line": 45,
        "code_end_line": 57,
        "code_key": "CheckLogicalVolumeSingleAttached",
        "code_value": "func CheckLogicalVolumeSingleAttached(ctx context.Context, source rdiskDomain.LogicalVolumeState, target rdiskDomain.LogicalVolumeState, stateCtx app.LogicalVolumeContext) error {\n\tattachCnt := len(stateCtx.GetLogicalVolume().Attachments)\n\tswitch {\n\tcase attachCnt <= 0:\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotAttached, \"volume not attached\")\n\tcase attachCnt == 1:\n\t\treturn nil\n\tcase attachCnt > 1:\n\t\treturn errors.New(rdiskDomain.ErrVolumeAttachOnMultipleHost, \"volume attached on multiple host\")\n\tdefault:\n\t\treturn nil\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/attach_detach.go",
        "code_start_line": 64,
        "code_end_line": 76,
        "code_key": "CheckLogicalVolumeMultipleAttached",
        "code_value": "func CheckLogicalVolumeMultipleAttached(ctx context.Context, source rdiskDomain.LogicalVolumeState, target rdiskDomain.LogicalVolumeState, stateCtx app.LogicalVolumeContext) error {\n\tattachCnt := len(stateCtx.GetLogicalVolume().Attachments)\n\tswitch {\n\tcase attachCnt <= 0:\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotAttached, \"volume not attached\")\n\tcase attachCnt == 1:\n\t\treturn errors.New(rdiskDomain.ErrVolumeAttachOnSingleHost, \"volume attached on single host\")\n\tcase attachCnt > 1:\n\t\treturn nil\n\tdefault:\n\t\treturn nil\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/attach_detach.go",
        "code_start_line": 222,
        "code_end_line": 245,
        "code_key": "UpdateFlowControlOnInitiator",
        "code_value": "func UpdateFlowControlOnInitiator(ctx context.Context, source rdiskDomain.LogicalVolumeState,\n\ttarget rdiskDomain.LogicalVolumeState, stateCtx app.LogicalVolumeContext) (state rdiskDomain.LogicalVolumeState, err error) {\n\n\tdata := stateCtx.(AttachDetachContext)\n\tlv := data.GetLogicalVolume()\n\tattachment, err := lv.GetAttachment(data.GetHost())\n\tif err != nil {\n\t\treturn source, errors.New(rdiskDomain.ErrVolumeNotAttached, fmt.Sprintf(\"volume not attached to host %s\", data.GetHost().String()))\n\t}\n\n\tblk := app.GetRegistry(ctx).Factories.BlockAgentClient(data.GetHost().String())\n\treq := cbs_blk_flow_agent.NewUpdateRDiskFlowControlRequest(lv.UUID.String(), lv.PhysicalVolume.DiskID)\n\treq.SpdkDriver = attachment.Options.SPDKDriver\n\treq.SetRead(attachment.FlowControlSpec.MaxReadIOPS, attachment.FlowControlSpec.MaxReadMBps)\n\treq.SetWrite(attachment.FlowControlSpec.MaxWriteIOPS, attachment.FlowControlSpec.MaxWriteMBps)\n\treq.SetReadWrite(attachment.FlowControlSpec.MaxRWIOPS, attachment.FlowControlSpec.MaxRWMBps)\n\n\terr = blk.UpdateRDiskFlowControl(ctx, req)\n\tif err != nil {\n\t\treturn source, err\n\t}\n\n\treturn target, err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/attach_detach.go",
        "code_start_line": 247,
        "code_end_line": 297,
        "code_key": "UpdateFlowControlOnAllInitiator",
        "code_value": "func UpdateFlowControlOnAllInitiator(ctx context.Context, source rdiskDomain.LogicalVolumeState,\n\ttarget rdiskDomain.LogicalVolumeState, stateCtx app.LogicalVolumeContext) (state rdiskDomain.LogicalVolumeState, err error) {\n\n\tlv := stateCtx.GetLogicalVolume()\n\tif len(lv.Attachments) == 0 {\n\t\tlogs.Info(ctx).Str(\"uuid\", lv.UUID.String()).Msg(\"no attachment found, skip update flow control\")\n\t\treturn target, nil\n\t}\n\n\tvar wg sync.WaitGroup\n\tvar collectedErr []error = make([]error, len(lv.Attachments))\n\n\twg.Add(len(lv.Attachments))\n\n\tfor idx, attachment := range lv.Attachments {\n\t\tgo func(idx int, attachment *rdiskDomain.VolumeAttachment) {\n\t\t\tdefer wg.Done()\n\n\t\t\tblk := app.GetRegistry(ctx).Factories.BlockAgentClient(attachment.IP.String())\n\t\t\treq := cbs_blk_flow_agent.NewUpdateRDiskFlowControlRequest(lv.UUID.String(), lv.PhysicalVolume.DiskID)\n\t\t\treq.SpdkDriver = attachment.Options.SPDKDriver\n\t\t\treq.SetRead(attachment.FlowControlSpec.MaxReadIOPS, attachment.FlowControlSpec.MaxReadMBps)\n\t\t\treq.SetWrite(attachment.FlowControlSpec.MaxWriteIOPS, attachment.FlowControlSpec.MaxWriteMBps)\n\t\t\treq.SetReadWrite(attachment.FlowControlSpec.MaxRWIOPS, attachment.FlowControlSpec.MaxRWMBps)\n\n\t\t\terr = blk.UpdateRDiskFlowControl(ctx, req)\n\t\t\tif err != nil {\n\t\t\t\tlogs.Error(ctx).Err(err).Str(\"ip\", attachment.IP.String()).Msg(\"failed to update flow control\")\n\t\t\t}\n\t\t\tcollectedErr[idx] = err\n\t\t}(idx, attachment)\n\t}\n\n\twg.Wait()\n\n\t// collect error ip and print error count\n\tvar errList []error\n\tvar errIPs []string\n\tfor idx, err := range collectedErr {\n\t\tif err != nil {\n\t\t\terrList = append(errList, err)\n\t\t\terrIPs = append(errIPs, lv.Attachments[idx].IP.String())\n\t\t}\n\t}\n\tif len(errList) > 0 {\n\t\tlogs.Warn(ctx).Errs(\"errors\", errList).Strs(\"host_ips\", errIPs).Msg(\"failed to update flow control on some initiators\")\n\t\treturn source, errors.New(rdiskDomain.ErrUpdateFlowControl, fmt.Sprintf(\"failed to update flow control on some initiators: %v, errors: %v\", errIPs, errList))\n\t}\n\n\treturn target, err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/drgroups.go",
        "code_start_line": 22,
        "code_end_line": 71,
        "code_key": "AddHostToDRGroup",
        "code_value": "func AddHostToDRGroup(ctx context.Context, source rdiskDomain.LogicalVolumeState, target rdiskDomain.LogicalVolumeState, stateCtx app.LogicalVolumeContext) (rdiskDomain.LogicalVolumeState, error) {\n\tdata := stateCtx.(CreateLogicalVolumeContext)\n\tvol := data.GetLogicalVolume()\n\tphy := data.GetPhysicalVolume()\n\tspecs := data.GetDRGroupSpecList()\n\trepo := app.GetRegistry(ctx).Repositories.DRGroup\n\tif len(specs) == 0 {\n\t\treturn target, nil\n\t}\n\tfor _, spec := range specs {\n\t\tgroup, err := repo.FindByName(ctx, vol.AppID, spec.Name)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\tgroup = drgroup.New(spec.Name, vol.AppID)\n\t\t\t\tif spec.Affinity > 0 {\n\t\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t\t}\n\t\t\t\tif spec.Type != \"\" {\n\t\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t\t}\n\t\t\t\terr = repo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn source, err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn source, err\n\t\t\t}\n\t\t}\n\t\tif spec.Affinity > 0 && group.Affinity != spec.Affinity {\n\t\t\tlogs.Info(ctx).Uint64(\"app_id\", uint64(vol.AppID)).\n\t\t\t\tStr(\"group_name\", spec.Name).\n\t\t\t\tInt(\"old_affinity\", group.Affinity).\n\t\t\t\tInt(\"new_affinity\", spec.Affinity).\n\t\t\t\tMsg(\"update affinity of drgroup\")\n\t\t\tgroup.Affinity = spec.Affinity\n\t\t}\n\t\tsubGroup := spec.SubGroup\n\t\tif subGroup == \"\" {\n\t\t\t// 如果没有指定子组，则使用远端 SSD UUID 作为子组名称\n\t\t\t// 相当于每块盘都是一个子组，相当于没有使用子组功能\n\t\t\tsubGroup = vol.UUID.String()\n\t\t}\n\t\terr = group.AddMember(vol.UUID.String(), subGroup, phy.IP.String())\n\t\tif err != nil {\n\t\t\treturn source, err\n\t\t}\n\t}\n\n\treturn target, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 138,
        "code_end_line": 209,
        "code_key": "StepGivenARegistry",
        "code_value": "func StepGivenARegistry(db *gorm.DB, t *testing.T, ctx context.Context) (*app.Registry, context.Context) {\n\t// 初始化Locker\n\tdlockConf := dlock_mysql.Config{\n\t\tTableName:      \"dm_locks\",\n\t\tLockColumn:     \"lock_key\",\n\t\tExpireColumn:   \"expired\",\n\t\tTokenColumn:    \"lock_token\",\n\t\tLockTypeColumn: \"lock_type\",\n\t\tLockNumsColumn: \"lock_count\",\n\t}\n\tapp.GlobalRegistry.Locker = dlock_mysql.New(db, dlockConf)\n\t// 初始化Dispatcher\n\tapp.GlobalRegistry.Dispatcher = dispatcher.NewDispatcher(ctx, app.GlobalRegistry.Locker)\n\t// 初始化状态机\n\tapp.GlobalRegistry.StateMachines.Backup = backup.FsmFactory()\n\tapp.GlobalRegistry.StateMachines.Benchmark = benchmark.FsmFactory()\n\tbackup.SetDefaultFactory(\"\")\n\tapp.GlobalRegistry.Config = app.Config{\n\t\tCOSCredentials: backup.COSCredentials{\n\t\t\tRegion:     \"\",\n\t\t\tAppID:      0,\n\t\t\tSecretID:   \"\",\n\t\t\tSecretKey:  \"\",\n\t\t\tToken:      \"\",\n\t\t\tBucket:     \"\",\n\t\t\tBaseDomain: \"\",\n\t\t\tStsDomain:  \"\",\n\t\t},\n\t}\n\t// 初始化Repositories\n\tapp.GlobalRegistry.Repositories.UoWFactory = repositories.NewFactory(db)\n\trepositories.RegisterImpl()\n\t// 初始化Factories\n\tapp.GlobalRegistry.Factories.BlockAgentClient = func(s string, options ...cbs_blk_flow_agent.BlockAgentOptions) cbs_blk_flow_agent.Interface {\n\t\tctrl := gomock.NewController(t)\n\t\t// defer ctrl.Finish()\n\t\tmockClient := mocks.NewMockInterface(ctrl)\n\t\tmockClient.EXPECT().CreateHarpController(gomock.Any(), gomock.Any()).Return(&cbs_blk_flow_agent.CreateHarpControllerResult{\n\t\t\tPort:   1234,\n\t\t\tDiskId: 0,\n\t\t}, nil).AnyTimes()\n\t\tmockClient.EXPECT().CreateRDiskSpdkVolume(gomock.Any(), gomock.Any()).Return(&cbs_blk_flow_agent.CreateRDiskSpdkVolumeResult{\n\t\t\tSpdkDriver: \"abc\",\n\t\t}, nil).AnyTimes()\n\t\tmockClient.EXPECT().UpdateRDiskFlowControl(gomock.Any(), gomock.Any()).Return(nil).AnyTimes()\n\t\tmockClient.EXPECT().DeleteRDiskSpdkVolume(gomock.Any(), gomock.Any()).Return(nil).AnyTimes()\n\t\tmockClient.EXPECT().DeleteHarpController(gomock.Any(), gomock.Any()).Return(nil).AnyTimes()\n\t\tmockClient.EXPECT().DeleteHarpBdev(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil).AnyTimes()\n\t\tmockClient.EXPECT().CreateHarpBdev(gomock.Any(), gomock.Any(), gomock.Any()).Return(&cbs_blk_flow_agent.CreateHarpBdevResult{\n\t\t\tSizeBytes: 512,\n\t\t\tBlockSize: 512,\n\t\t}, nil).AnyTimes()\n\t\tmockClient.EXPECT().AsyncQueryRdiskPerfBenchmark(gomock.Any(), gomock.Any()).Return(123, nil).AnyTimes()\n\t\tmockClient.EXPECT().DropRDiskInflightIO(gomock.Any(), gomock.Any()).Return(&cbs_blk_flow_agent.DropRDiskInflightIOResponse{\n\t\t\tDiskID: 0,\n\t\t}, nil).AnyTimes()\n\t\tmockClient.EXPECT().DeleteRDiskSpdkVolume(gomock.Any(), gomock.Any()).Return(nil).AnyTimes()\n\t\treturn mockClient\n\t}\n\tapp.GlobalRegistry.Factories.COSTmpCredential = cos.NewTmpSecret\n\tapp.GlobalRegistry.Factories.COSClient = cos.New\n\t// 初始化viewer\n\tapp.GlobalRegistry.Viewers.PhysicalVolume = viewers.NewPhysicalVolumeViewer(db)\n\tapp.GlobalRegistry.Viewers.LogicalVolume = viewers.NewLogicalVolumeViewer(db)\n\tapp.GlobalRegistry.Viewers.DRGroup = viewers.NewDRGroupViewer(db)\n\tapp.GlobalRegistry.Viewers.Backup = viewers.NewBackupViewer(db)\n\tapp.GlobalRegistry.Viewers.Benchmark = viewers.NewBenchmarkViewer(db)\n\n\tregistry := app.GetRegistry(ctx)\n\tctx = app.SetRegistry(ctx, registry)\n\treturn registry, ctx\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 214,
        "code_end_line": 239,
        "code_key": "StepGivenAPhysicalVol",
        "code_value": "func StepGivenAPhysicalVol(registry *app.Registry, value interface{}) *rdiskDomain.PhysicalVolume {\n\tphysicalVol := &rdiskDomain.PhysicalVolume{\n\t\tEntityMixin:  rdiskDomain.EntityMixin{ID: 1},\n\t\tSerial:       \"12345\",\n\t\tIP:           net.IP{127, 0, 0, 1},\n\t\tBDF:          \"bdf\",\n\t\tDiskID:       0,\n\t\tState:        rdiskDomain.PhysicalVolumeState(value.(int)),\n\t\tSize:         1,\n\t\tVolumeType:   \"NVME\",\n\t\tZoneID:       1,\n\t\tBlockSize:    512,\n\t\tRealSize:     5120,\n\t\tPort:         1,\n\t\tDataNodeType: \"unknown\",\n\t\tCuf:          \"清远-清新-C2\",\n\t}\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\terr := registry.Repositories.PhysicalVolume.Add(workerCtx, physicalVol)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn physicalVol\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 244,
        "code_end_line": 277,
        "code_key": "StepGivenPhysicalVols",
        "code_value": "func StepGivenPhysicalVols(registry *app.Registry, value interface{}, num interface{}) []*rdiskDomain.PhysicalVolume {\n\tvar physicalVols []*rdiskDomain.PhysicalVolume\n\tfor i := 0; i < num.(int); i++ {\n\t\tphysicalVols = append(physicalVols, &rdiskDomain.PhysicalVolume{\n\t\t\tEntityMixin:  rdiskDomain.EntityMixin{},\n\t\t\tSerial:       rdiskDomain.Serial(\"111\" + strconv.Itoa(i)),\n\t\t\tIP:           net.IP{127, 0, byte(((i + 2) / 255) % 255), byte((i + 2) % 255)},\n\t\t\tBDF:          \"bdf\",\n\t\t\tDiskID:       0,\n\t\t\tState:        rdiskDomain.PhysicalVolumeState(value.(int)),\n\t\t\tSize:         1,\n\t\t\tVolumeType:   \"\",\n\t\t\tZoneID:       1,\n\t\t\tBlockSize:    512,\n\t\t\tRealSize:     5120,\n\t\t\tPort:         1,\n\t\t\tDataNodeType: \"\",\n\t\t\tCuf:          \"清远-清新-C2\",\n\t\t})\n\t}\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\tfor _, vol := range physicalVols {\n\t\terr := registry.Repositories.PhysicalVolume.Add(workerCtx, vol)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\terr := uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn physicalVols\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 282,
        "code_end_line": 304,
        "code_key": "StepGivenALogicalVol",
        "code_value": "func StepGivenALogicalVol(registry *app.Registry, physicalVol *rdiskDomain.PhysicalVolume, value interface{}) *rdiskDomain.LogicalVolume {\n\tlogicalVol := &rdiskDomain.LogicalVolume{\n\t\tEntityMixin:     rdiskDomain.EntityMixin{ID: 1},\n\t\tUUID:            uuid.Must(uuid.NewRandom()),\n\t\tState:           rdiskDomain.LogicalVolumeState(value.(int)),\n\t\tSize:            1,\n\t\tAppID:           123,\n\t\tZoneID:          1,\n\t\tDiskType:        \"\",\n\t\tVolumeType:      \"\",\n\t\tFlowControlSpec: rdiskDomain.FlowControlSpec{},\n\t\tPhysicalVolume:  physicalVol,\n\t\tAttachments:     nil,\n\t}\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\terr := registry.Repositories.LogicalVolume.Add(workerCtx, logicalVol)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn logicalVol\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 351,
        "code_end_line": 364,
        "code_key": "StepThenLogicalVolStateShouldBe",
        "code_value": "func StepThenLogicalVolStateShouldBe(logicalVol *rdiskDomain.LogicalVolume, registry *app.Registry, db *gorm.DB, database string, value interface{}) *rdiskDomain.LogicalVolume {\n\tdb.Exec(fmt.Sprintf(\"USE `%s`\", database))\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\tnewLogicalVol, err := registry.Repositories.LogicalVolume.FindByAppIDAndUUID(workerCtx, logicalVol.AppID, logicalVol.UUID)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif newLogicalVol.State != rdiskDomain.LogicalVolumeState(value.(int)) {\n\t\tpanic(\"LogicalVol state error\")\n\t}\n\treturn newLogicalVol\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 433,
        "code_end_line": 449,
        "code_key": "StepThenPhysicalVolShouldBe",
        "code_value": "func StepThenPhysicalVolShouldBe(physicalVol *rdiskDomain.PhysicalVolume, registry *app.Registry, db *gorm.DB, database string, field string, value interface{}) *rdiskDomain.PhysicalVolume {\n\tdb.Exec(fmt.Sprintf(\"USE `%s`\", database))\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\tnewPhysicalVol, err := registry.Repositories.PhysicalVolume.FindBySerial(workerCtx, physicalVol.Serial)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tswitch field {\n\tcase \"cuf\":\n\t\tif newPhysicalVol.Cuf != rdiskDomain.Cuf(value.(string)) {\n\t\t\tpanic(\"Result error\")\n\t\t}\n\t}\n\treturn newPhysicalVol\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 618,
        "code_end_line": 630,
        "code_key": "StepThenPhysicalVolShouldBeRight",
        "code_value": "func StepThenPhysicalVolShouldBeRight(physicalVol *rdiskDomain.PhysicalVolume, registry *app.Registry, t *testing.T) {\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\tnewPhysicalVol, err := registry.Repositories.PhysicalVolume.FindBySerial(workerCtx, physicalVol.Serial)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif physicalVol.BDF != newPhysicalVol.BDF || physicalVol.Cuf != newPhysicalVol.Cuf || rdiskDomain.PVSInited != newPhysicalVol.State || physicalVol.DataNodeType != newPhysicalVol.DataNodeType ||\n\t\t!physicalVol.IP.Equal(newPhysicalVol.IP) || physicalVol.VolumeType != newPhysicalVol.VolumeType || physicalVol.Size != newPhysicalVol.Size {\n\t\tpanic(\"data error\")\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go",
        "code_start_line": 22,
        "code_end_line": 47,
        "code_key": "FindByAppIDAndUUID",
        "code_value": "func (logicalVolumeRepositoryImpl) FindByAppIDAndUUID(ctx context.Context, appID users.AppID, id uuid.UUID) (*rdiskDomain.LogicalVolume, error) {\n\tuow := getUow(ctx)\n\tvol := metadb.DmRdisk{}\n\tresult := uow.tx.\n\t\tPreload(\"Attachments\").\n\t\tPreload(\"DmPhyDisk\").\n\t\tFirst(&vol, \"uuid = ? AND app_id = ?\", id.String(), appID)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tlv, err := fromDmRDiskToModel(ctx, &vol)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlv = uow.trackedLogicalVolumes.Add(lv)\n\tif lv.PhysicalVolume != nil {\n\t\tlv.PhysicalVolume = uow.trackedPhyVolumes.Add(lv.PhysicalVolume)\n\t}\n\treturn lv, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 55,
        "code_end_line": 61,
        "code_key": "FindByAppIDAndUUID",
        "code_value": "func (m *MockLogicalVolumeRepository) FindByAppIDAndUUID(arg0 context.Context, arg1 users.AppID, arg2 uuid.UUID) (*rdiskDomain.LogicalVolume, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByAppIDAndUUID\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(*rdiskDomain.LogicalVolume)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 64,
        "code_end_line": 67,
        "code_key": "FindByAppIDAndUUID",
        "code_value": "func (mr *MockLogicalVolumeRepositoryMockRecorder) FindByAppIDAndUUID(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByAppIDAndUUID\", reflect.TypeOf((*MockLogicalVolumeRepository)(nil).FindByAppIDAndUUID), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go",
        "code_start_line": 49,
        "code_end_line": 74,
        "code_key": "FindByID",
        "code_value": "func (l logicalVolumeRepositoryImpl) FindByID(ctx context.Context, id uuid.UUID) (*rdiskDomain.LogicalVolume, error) {\n\tuow := getUow(ctx)\n\tvol := metadb.DmRdisk{}\n\tresult := uow.tx.\n\t\tPreload(\"Attachments\").\n\t\tPreload(\"DmPhyDisk\").\n\t\tFirst(&vol, \"uuid = ?\", id.String())\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tlv, err := fromDmRDiskToModel(ctx, &vol)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlv = uow.trackedLogicalVolumes.Add(lv)\n\tif lv.PhysicalVolume != nil {\n\t\tlv.PhysicalVolume = uow.trackedPhyVolumes.Add(lv.PhysicalVolume)\n\t}\n\treturn lv, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 70,
        "code_end_line": 76,
        "code_key": "FindByID",
        "code_value": "func (m *MockLogicalVolumeRepository) FindByID(arg0 context.Context, arg1 uuid.UUID) (*rdiskDomain.LogicalVolume, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByID\", arg0, arg1)\n\tret0, _ := ret[0].(*rdiskDomain.LogicalVolume)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 79,
        "code_end_line": 82,
        "code_key": "FindByID",
        "code_value": "func (mr *MockLogicalVolumeRepositoryMockRecorder) FindByID(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByID\", reflect.TypeOf((*MockLogicalVolumeRepository)(nil).FindByID), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go",
        "code_start_line": 21,
        "code_end_line": 38,
        "code_key": "FindBySerial",
        "code_value": "func (p *physicalVolumeRepositoryImpl) FindBySerial(ctx context.Context, serial rdiskDomain.Serial) (*rdiskDomain.PhysicalVolume, error) {\n\tuow := getUow(ctx)\n\tvar vol metadb.DmPhydisk\n\tresult := uow.tx.Where(\"serial = ?\", string(serial)).First(&vol)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\t// 覆盖 gorm 的错误\n\t\t\treturn nil, errors.New(rdiskDomain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tpv := fromDmPhyDiskToPhysicalVolume(ctx, &vol)\n\tpv = uow.trackedPhyVolumes.Add(pv)\n\treturn pv, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 83,
        "code_end_line": 89,
        "code_key": "FindBySerial",
        "code_value": "func (m *MockPhysicalVolumeRepository) FindBySerial(arg0 context.Context, arg1 rdiskDomain.Serial) (*rdiskDomain.PhysicalVolume, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindBySerial\", arg0, arg1)\n\tret0, _ := ret[0].(*rdiskDomain.PhysicalVolume)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 92,
        "code_end_line": 95,
        "code_key": "FindBySerial",
        "code_value": "func (mr *MockPhysicalVolumeRepositoryMockRecorder) FindBySerial(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindBySerial\", reflect.TypeOf((*MockPhysicalVolumeRepository)(nil).FindBySerial), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go",
        "code_start_line": 40,
        "code_end_line": 57,
        "code_key": "FindByIPAndBDF",
        "code_value": "func (p *physicalVolumeRepositoryImpl) FindByIPAndBDF(ctx context.Context, ip net.IP, bdf rdiskDomain.BDF) (*rdiskDomain.PhysicalVolume, error) {\n\tuow := getUow(ctx)\n\tvar vol metadb.DmPhydisk\n\tresult := uow.tx.Where(\"host_ip = ? AND bdf = ?\", ip.String(), string(bdf)).Find(&vol)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\t// 覆盖 gorm 的错误\n\t\t\treturn nil, errors.New(rdiskDomain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tpv := fromDmPhyDiskToPhysicalVolume(ctx, &vol)\n\tpv = uow.trackedPhyVolumes.Add(pv)\n\treturn pv, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 68,
        "code_end_line": 74,
        "code_key": "FindByIPAndBDF",
        "code_value": "func (m *MockPhysicalVolumeRepository) FindByIPAndBDF(arg0 context.Context, arg1 net.IP, arg2 rdiskDomain.BDF) (*rdiskDomain.PhysicalVolume, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByIPAndBDF\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(*rdiskDomain.PhysicalVolume)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 77,
        "code_end_line": 80,
        "code_key": "FindByIPAndBDF",
        "code_value": "func (mr *MockPhysicalVolumeRepositoryMockRecorder) FindByIPAndBDF(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByIPAndBDF\", reflect.TypeOf((*MockPhysicalVolumeRepository)(nil).FindByIPAndBDF), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
        "code_start_line": 20,
        "code_end_line": 29,
        "code_key": "FindByName",
        "code_value": "func (d drgroupRepositoryImpl) FindByName(ctx context.Context, appId users.AppID, name string) (*drgroup.DRGroup, error) {\n\tresults, err := d.FindByNames(ctx, appId, []string{name})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(results) < 1 {\n\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"disaster recovery group not exists\")\n\t}\n\treturn results[0], nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/drgroup.go",
        "code_start_line": 75,
        "code_end_line": 90,
        "code_key": "FindByName",
        "code_value": "func (d *drgroupViewerImpl) FindByName(ctx context.Context, appId users.AppID, name string) (*drgroup.View, error) {\n\tvar (\n\t\tresultView drgroup.View\n\t\tdataObject metadb.DmDrgroup\n\t)\n\n\tresult := d.db.WithContext(ctx).First(&dataObject, \"app_id = ? and name = ?\", appId, name)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"group not exist\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\td.translate(&dataObject, &resultView)\n\treturn &resultView, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 98,
        "code_end_line": 104,
        "code_key": "FindByName",
        "code_value": "func (m *MockRepository) FindByName(arg0 context.Context, arg1 users.AppID, arg2 string) (*drgroup.DRGroup, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByName\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(*drgroup.DRGroup)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 107,
        "code_end_line": 110,
        "code_key": "FindByName",
        "code_value": "func (mr *MockRepositoryMockRecorder) FindByName(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByName\", reflect.TypeOf((*MockRepository)(nil).FindByName), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/view.go",
        "code_start_line": 70,
        "code_end_line": 76,
        "code_key": "FindByName",
        "code_value": "func (m *MockViewer) FindByName(arg0 context.Context, arg1 users.AppID, arg2 string) (*drgroup.View, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByName\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(*drgroup.View)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/view.go",
        "code_start_line": 79,
        "code_end_line": 82,
        "code_key": "FindByName",
        "code_value": "func (mr *MockViewerMockRecorder) FindByName(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByName\", reflect.TypeOf((*MockViewer)(nil).FindByName), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
        "code_start_line": 31,
        "code_end_line": 52,
        "code_key": "FindByNames",
        "code_value": "func (d drgroupRepositoryImpl) FindByNames(ctx context.Context, appId users.AppID, names []string) ([]*drgroup.DRGroup, error) {\n\tuow := getUow(ctx)\n\tgroup := []metadb.DmDrgroup{}\n\tresult := uow.tx.\n\t\tPreload(\"Members\").\n\t\tFind(&group, \"app_id = ? and name in ?\", appId, names)\n\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"disaster recovery group not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tresults := make([]*drgroup.DRGroup, len(group))\n\tfor i := range group {\n\t\tresults[i] = uow.trackedDRGroups.Add(fromDmDRGroupToModel(&group[i]))\n\t}\n\treturn results, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 113,
        "code_end_line": 119,
        "code_key": "FindByNames",
        "code_value": "func (m *MockRepository) FindByNames(arg0 context.Context, arg1 users.AppID, arg2 []string) ([]*drgroup.DRGroup, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByNames\", arg0, arg1, arg2)\n\tret0, _ := ret[0].([]*drgroup.DRGroup)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 122,
        "code_end_line": 125,
        "code_key": "FindByNames",
        "code_value": "func (mr *MockRepositoryMockRecorder) FindByNames(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByNames\", reflect.TypeOf((*MockRepository)(nil).FindByNames), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
        "code_start_line": 58,
        "code_end_line": 94,
        "code_key": "FindByMembers",
        "code_value": "func (d drgroupRepositoryImpl) FindByMembers(ctx context.Context, appId users.AppID, members []string) ([]*drgroup.DRGroup, error) {\n\tuow := getUow(ctx)\n\tgroup := []metadb.DmDrgroup{}\n\n\tmembersResult := []metadb.DmDrgroupMembers{}\n\tresult := uow.tx.\n\t\tFind(&membersResult, \"app_id = ? and member_id in ?\", appId, members)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tnames := make([]string, 0, len(members))\n\tfor i := range membersResult {\n\t\tnames = append(names, membersResult[i].GroupName)\n\t}\n\tresult = uow.tx.\n\t\tPreload(\"Members\").\n\t\tFind(&group, \"app_id = ? and name in ?\", appId, names)\n\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"disaster recovery group not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tresults := make([]*drgroup.DRGroup, len(group))\n\tfor i := range group {\n\t\tresults[i] = fromDmDRGroupToModel(&group[i])\n\t\tresults[i] = uow.trackedDRGroups.Add(results[i])\n\t}\n\treturn results, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/drgroup.go",
        "code_start_line": 92,
        "code_end_line": 124,
        "code_key": "FindByMembers",
        "code_value": "func (d *drgroupViewerImpl) FindByMembers(ctx context.Context, appId users.AppID, members []string) ([]*drgroup.View, error) {\n\tvar (\n\t\tresultViews       []drgroup.View\n\t\tresultViewRef     []*drgroup.View\n\t\tdataObjects       []*metadb.DmDrgroup\n\t\tdataObjectMembers []*metadb.DmDrgroupMembers\n\t)\n\tresult := d.db.WithContext(ctx).Find(&dataObjectMembers, \"app_id = ? and member_id in ?\", appId, members)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"group not exist\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tgroupNames := make([]string, len(dataObjectMembers))\n\tfor i := range dataObjectMembers {\n\t\tgroupNames[i] = dataObjectMembers[i].GroupName\n\t}\n\tresult = d.db.WithContext(ctx).Find(&dataObjects, \"app_id = ? and name in ?\", appId, groupNames)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"group not exist\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tresultViews = make([]drgroup.View, len(dataObjects))\n\tresultViewRef = make([]*drgroup.View, len(dataObjects))\n\tfor i := range dataObjects {\n\t\tresultViewRef[i] = &resultViews[i]\n\t\td.translate(dataObjects[i], resultViewRef[i])\n\t}\n\treturn resultViewRef, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 83,
        "code_end_line": 89,
        "code_key": "FindByMembers",
        "code_value": "func (m *MockRepository) FindByMembers(arg0 context.Context, arg1 users.AppID, arg2 []string) ([]*drgroup.DRGroup, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByMembers\", arg0, arg1, arg2)\n\tret0, _ := ret[0].([]*drgroup.DRGroup)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 92,
        "code_end_line": 95,
        "code_key": "FindByMembers",
        "code_value": "func (mr *MockRepositoryMockRecorder) FindByMembers(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByMembers\", reflect.TypeOf((*MockRepository)(nil).FindByMembers), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/view.go",
        "code_start_line": 55,
        "code_end_line": 61,
        "code_key": "FindByMembers",
        "code_value": "func (m *MockViewer) FindByMembers(arg0 context.Context, arg1 users.AppID, arg2 []string) ([]*drgroup.View, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByMembers\", arg0, arg1, arg2)\n\tret0, _ := ret[0].([]*drgroup.View)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/view.go",
        "code_start_line": 64,
        "code_end_line": 67,
        "code_key": "FindByMembers",
        "code_value": "func (mr *MockViewerMockRecorder) FindByMembers(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByMembers\", reflect.TypeOf((*MockViewer)(nil).FindByMembers), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/logi_vol.go",
        "code_start_line": 80,
        "code_end_line": 102,
        "code_key": "ProbeAppID",
        "code_value": "func (v *logicalVolumeViewerImpl) ProbeAppID(ctx context.Context, uuids []uuid.UUID, serial []rdiskDomain.Serial) (users.AppID, error) {\n\tvar (\n\t\tdataObjects *metadb.DmRdisk\n\t)\n\tstmt := v.db.WithContext(ctx).Where(\"1 = 1\")\n\tif len(uuids) > 0 {\n\t\tstmt = stmt.Where(\"uuid in ?\", functools.Map(uuids, func(i uuid.UUID) string { return i.String() }))\n\t}\n\tif len(serial) > 0 {\n\t\tstmt = stmt.Where(\"phydisk_serial in ?\", functools.Map(serial, func(i rdiskDomain.Serial) string { return string(i) }))\n\t}\n\tresult := stmt.Select(\"app_id\").Limit(1).Find(&dataObjects)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn users.AppID(0), nil\n\t\t}\n\t\treturn users.AppID(0), result.Error\n\t}\n\tif dataObjects.AppID == 0 {\n\t\treturn users.AppID(0), errors.New(rdiskDomain.ErrVolumeNotExists, \"logical volume not exist\")\n\t}\n\treturn users.AppID(dataObjects.AppID), nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_view.go",
        "code_start_line": 71,
        "code_end_line": 77,
        "code_key": "ProbeAppID",
        "code_value": "func (m *MockLogicalVolumeViewer) ProbeAppID(arg0 context.Context, arg1 []uuid.UUID, arg2 []rdiskDomain.Serial) (users.AppID, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"ProbeAppID\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(users.AppID)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_view.go",
        "code_start_line": 80,
        "code_end_line": 83,
        "code_key": "ProbeAppID",
        "code_value": "func (mr *MockLogicalVolumeViewerMockRecorder) ProbeAppID(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ProbeAppID\", reflect.TypeOf((*MockLogicalVolumeViewer)(nil).ProbeAppID), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/logi_vol.go",
        "code_start_line": 109,
        "code_end_line": 132,
        "code_key": "FindByIDs",
        "code_value": "func (v *logicalVolumeViewerImpl) FindByIDs(ctx context.Context, appID users.AppID, id []uuid.UUID) ([]*rdiskDomain.LogicalVolume, error) {\n\tvar (\n\t\tresultViews   []rdiskDomain.LogicalVolume\n\t\tresultViewRef []*rdiskDomain.LogicalVolume\n\t\tdataObjects   []*metadb.DmRdisk\n\t)\n\n\tuuidStrSlice := functools.Map(id, func(i uuid.UUID) string { return i.String() })\n\tresult := v.db.WithContext(ctx).Preload(\"DmPhyDisk\").Find(&dataObjects, \"app_id = ? and uuid in ?\", appID, uuidStrSlice)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(rdiskDomain.ErrVolumeNotExists, \"logical volume not exist\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\n\tresultViews = make([]rdiskDomain.LogicalVolume, len(dataObjects))\n\tresultViewRef = make([]*rdiskDomain.LogicalVolume, len(dataObjects))\n\tfor i := range dataObjects {\n\t\tresultViewRef[i] = &resultViews[i]\n\t\tv.translate(dataObjects[i], resultViewRef[i])\n\t}\n\treturn resultViewRef, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_view.go",
        "code_start_line": 41,
        "code_end_line": 47,
        "code_key": "FindByIDs",
        "code_value": "func (m *MockLogicalVolumeViewer) FindByIDs(arg0 context.Context, arg1 users.AppID, arg2 []uuid.UUID) ([]*rdiskDomain.LogicalVolume, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByIDs\", arg0, arg1, arg2)\n\tret0, _ := ret[0].([]*rdiskDomain.LogicalVolume)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_view.go",
        "code_start_line": 50,
        "code_end_line": 53,
        "code_key": "FindByIDs",
        "code_value": "func (mr *MockLogicalVolumeViewerMockRecorder) FindByIDs(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByIDs\", reflect.TypeOf((*MockLogicalVolumeViewer)(nil).FindByIDs), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/backup.go",
        "code_start_line": 19,
        "code_end_line": 41,
        "code_key": "FindByAppID",
        "code_value": "func (v *backupViewerImpl) FindByAppID(ctx context.Context, appID users.AppID, uuids, rdisks []string) ([]*backup.View, error) {\n\tvar (\n\t\tviews []*backup.View\n\t\tdtos  []*metadb.DmRdiskBackup\n\t)\n\tquery := v.db.WithContext(ctx).Where(\"app_id = ?\", appID)\n\tif len(uuids) > 0 {\n\t\tquery = query.Where(\"uuid in ?\", uuids)\n\t}\n\tif len(rdisks) > 0 {\n\t\tquery = query.Where(\"rdisk_uuid in ?\", rdisks)\n\t}\n\tresult := query.Find(&dtos)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\tviews = functools.MapRef(make([]backup.View, len(dtos)))\n\tfor i := range dtos {\n\t\tv.translate(dtos[i], views[i])\n\t}\n\n\treturn views, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/drgroup.go",
        "code_start_line": 126,
        "code_end_line": 147,
        "code_key": "FindByAppID",
        "code_value": "func (d *drgroupViewerImpl) FindByAppID(ctx context.Context, appId users.AppID) ([]*drgroup.View, error) {\n\tvar (\n\t\tresultViews       []drgroup.View\n\t\tresultViewRef     []*drgroup.View\n\t\tdataObjects       []*metadb.DmDrgroup\n\t\tdataObjectMembers []*metadb.DmDrgroupMembers\n\t)\n\tresult := d.db.WithContext(ctx).Find(&dataObjects).Where(\"app_id = ?\", appId, dataObjectMembers)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"group not exist\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tresultViews = make([]drgroup.View, len(dataObjects))\n\tresultViewRef = make([]*drgroup.View, len(dataObjects))\n\tfor i := range dataObjects {\n\t\tresultViewRef[i] = &resultViews[i]\n\t\td.translate(dataObjects[i], resultViewRef[i])\n\t}\n\treturn resultViewRef, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/view.go",
        "code_start_line": 40,
        "code_end_line": 46,
        "code_key": "FindByAppID",
        "code_value": "func (m *MockViewer) FindByAppID(arg0 context.Context, arg1 users.AppID) ([]*drgroup.View, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByAppID\", arg0, arg1)\n\tret0, _ := ret[0].([]*drgroup.View)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/view.go",
        "code_start_line": 49,
        "code_end_line": 52,
        "code_key": "FindByAppID",
        "code_value": "func (mr *MockViewerMockRecorder) FindByAppID(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByAppID\", reflect.TypeOf((*MockViewer)(nil).FindByAppID), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/benchmark/benchmark.go",
        "code_start_line": 186,
        "code_end_line": 196,
        "code_key": "whenTaskFinish",
        "code_value": "func whenTaskFinish(ctx context.Context, source, target Status, stateCtx Data) error {\n\tresult, err := stateCtx.Delegate.QueryTask(ctx, stateCtx.Benchmark)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif result == nil {\n\t\treturn errors.New(ErrTaskNotFinish, \"benchmark task not finish\")\n\t}\n\tstateCtx.Benchmark.UpdateStat(*result)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/benchmark/benchmark.go",
        "code_start_line": 199,
        "code_end_line": 208,
        "code_key": "whenTaskStillRunning",
        "code_value": "func whenTaskStillRunning(ctx context.Context, source, target Status, stateCtx Data) error {\n\tresult, err := stateCtx.Delegate.QueryTask(ctx, stateCtx.Benchmark)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif result != nil {\n\t\treturn errors.New(ErrTaskFinished, \"benchmark already finish\")\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/backup/states.go",
        "code_start_line": 169,
        "code_end_line": 183,
        "code_key": "whenTaskStillRunning",
        "code_value": "func whenTaskStillRunning(\n\tctx context.Context,\n\tsource BackupStatus,\n\ttarget BackupStatus,\n\tstateCtx Data) error {\n\tprogress, err := stateCtx.Delegate.QueryBackupProgress(ctx, stateCtx.Backup)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !progress.Done && progress.Error == \"\" {\n\t\tstateCtx.Backup.UpdatePercentage(progress.Progress, progress.TotalSize)\n\t\treturn nil\n\t}\n\treturn errors.New(ErrTaskNotRunning, \"backup task not running\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/benchmark/benchmark.go",
        "code_start_line": 211,
        "code_end_line": 218,
        "code_key": "whenTaskFailed",
        "code_value": "func whenTaskFailed(ctx context.Context, source, target Status, stateCtx Data) error {\n\t_, err := stateCtx.Delegate.QueryTask(ctx, stateCtx.Benchmark)\n\tif err != nil {\n\t\tstateCtx.UpdateError(err)\n\t\treturn nil\n\t}\n\treturn errors.New(ErrTaskNotFinish, \"benchmark not failed\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/backup/states.go",
        "code_start_line": 186,
        "code_end_line": 201,
        "code_key": "whenTaskFailed",
        "code_value": "func whenTaskFailed(\n\tctx context.Context,\n\tsource BackupStatus,\n\ttarget BackupStatus,\n\tstateCtx Data) error {\n\tprogress, err := stateCtx.Delegate.QueryBackupProgress(ctx, stateCtx.Backup)\n\tif err != nil {\n\t\tlogs.Warn(ctx).Err(err).Str(\"task\", stateCtx.Backup.UUID.String()).Msg(\"backup task failed\")\n\t\treturn nil\n\t}\n\tif progress.Error != \"\" {\n\t\tlogs.Warn(ctx).Str(\"error\", progress.Error).Str(\"task\", stateCtx.Backup.UUID.String()).Msg(\"backup task failed\")\n\t\treturn nil\n\t}\n\treturn errors.New(ErrTaskNotFailed, \"backup task not failed\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 193,
        "code_end_line": 205,
        "code_key": "NewLogicalVolume",
        "code_value": "func NewLogicalVolume(appId users.AppID, size Size, zoneId ZoneID) *LogicalVolume {\n\tvol := &LogicalVolume{\n\t\tState:           LVSUnInited,\n\t\tSize:            size,\n\t\tAppID:           appId,\n\t\tUUID:            uuid.New(),\n\t\tZoneID:          zoneId,\n\t\tVolumeType:      VolumeTypeNVME,\n\t\tDiskType:        DiskTypeData,\n\t\tFlowControlSpec: DefaultFlowControlSpec,\n\t}\n\treturn vol\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 207,
        "code_end_line": 218,
        "code_key": "CheckSerial",
        "code_value": "func CheckSerial(serial Serial) error {\n\tif len(serial) < 5 {\n\t\treturn errors.New(ErrInvalidSerial, \"invalid serial, minimum length is 5\")\n\t}\n\n\tif strings.Contains(string(serial), \"---\") {\n\t\t// 在某些场景下 NVME 扫描脚本会检查到一些无效的设备，这些设备的序列号是 ---，这里过滤掉\n\t\treturn errors.New(ErrInvalidSerial, \"invalid serial, contains ---\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 256,
        "code_end_line": 276,
        "code_key": "Attach",
        "code_value": "func (l *LogicalVolume) Attach(ip net.IP) (*VolumeAttachment, error) {\n\tfor _, a := range l.Attachments {\n\t\tif a.IP.Equal(ip) {\n\t\t\treturn nil, errors.New(ErrVolumeAlreadyAttachedToHost, \"volume already attached to host\")\n\t\t}\n\t}\n\n\tif len(l.Attachments) >= MaxAttachmentCount {\n\t\treturn nil, errors.New(ErrVolumeAttachedOnTooManyHost, \"volume attached on too many host\")\n\t}\n\n\tnewAttachment := &VolumeAttachment{\n\t\tIP:              ip,\n\t\tMode:            ReadWrite,\n\t\tFlowControlSpec: l.FlowControlSpec,\n\t\tOptions:         DefaultAttachmentOption,\n\t}\n\tl.Attachments = append(l.Attachments, newAttachment)\n\n\treturn newAttachment, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 281,
        "code_end_line": 298,
        "code_key": "Detach",
        "code_value": "func (l *LogicalVolume) Detach(ip net.IP) error {\n\t// 以后如果有更复杂的逻辑需要调用检查接口\n\t// 目前他们做的事情是一样的，只是为了保留 DiskIds 等信息给后续步骤使用才需要先调用 CheckDetach\n\t// l.CheckDetach()\n\tfor i, a := range l.Attachments {\n\t\tif a.IP.Equal(ip) {\n\t\t\tl.Attachments = append(l.Attachments[:i], l.Attachments[i+1:]...)\n\t\t\tif len(l.Attachments) == 0 {\n\t\t\t\t// 如果逻辑卷已经没有挂载信息了，重置物理卷的 DiskID 和 Port\n\t\t\t\tif l.PhysicalVolume != nil {\n\t\t\t\t\tl.PhysicalVolume.ResetDiskIDPort()\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn errors.New(ErrVolumeNotAttachedToHost, \"volume not attached to host\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 301,
        "code_end_line": 308,
        "code_key": "CheckDetach",
        "code_value": "func (l *LogicalVolume) CheckDetach(ip net.IP) error {\n\tfor _, a := range l.Attachments {\n\t\tif a.IP.Equal(ip) {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn errors.New(ErrVolumeNotAttachedToHost, \"volume not attached to host\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 311,
        "code_end_line": 317,
        "code_key": "CheckDelete",
        "code_value": "func (l *LogicalVolume) CheckDelete() error {\n\t// Defuncting vol can't be deleted\n\tif l.State == LVSDefuncting {\n\t\treturn errors.New(ErrVolumeBusy, \"volume is defuncting, please try again later\")\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 324,
        "code_end_line": 344,
        "code_key": "BindPhysicalVolume",
        "code_value": "func (l *LogicalVolume) BindPhysicalVolume(pv *PhysicalVolume) error {\n\tif pv == nil {\n\t\treturn errors.New(ErrPhysicalVolumeNotExists, \"physical volume is nil\")\n\t}\n\tif l.PhysicalVolume != nil {\n\t\treturn errors.New(ErrPhysicalVolumeAlreadyBound, \"physical volume is bound to another logical volume\")\n\t}\n\tif l.Size != pv.Size {\n\t\treturn errors.New(ErrPhysicalVolumeSizeNotMatch, \"physical volume size not match\")\n\t}\n\tif l.ZoneID == 0 {\n\t\t// 如果逻辑卷没有指定可用区，就使用物理卷的可用区\n\t\tl.ZoneID = pv.ZoneID\n\t} else if l.ZoneID != pv.ZoneID {\n\t\treturn errors.Newf(ErrZoneIdMismatch, \"zone id mismatch, %d != %d\", l.ZoneID, pv.ZoneID)\n\t}\n\tl.PhysicalVolume = pv\n\t// 设置流控规格\n\tl.FlowControlSpec = defaultSpecForPerformanceRank(pv.PerformanceRank)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 347,
        "code_end_line": 353,
        "code_key": "MigratePhysicalVolume",
        "code_value": "func (l *LogicalVolume) MigratePhysicalVolume(target *PhysicalVolume) error {\n\tif l.Size != target.Size {\n\t\treturn errors.New(ErrPhysicalVolumeSizeNotMatch, \"physical volume size not match\")\n\t}\n\tl.PhysicalVolume = target\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 366,
        "code_end_line": 373,
        "code_key": "Defunct",
        "code_value": "func (l *LogicalVolume) Defunct() error {\n\tif len(l.Attachments) > 0 {\n\t\treturn errors.New(ErrVolumeAttached, \"volume is still attached to some hosts\")\n\t}\n\tl.PhysicalVolume = nil\n\tl.State = LVSDefunct\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 376,
        "code_end_line": 383,
        "code_key": "GetAttachment",
        "code_value": "func (l *LogicalVolume) GetAttachment(host net.IP) (att *VolumeAttachment, err error) {\n\tfor _, a := range l.Attachments {\n\t\tif a.IP.Equal(host) {\n\t\t\treturn a, nil\n\t\t}\n\t}\n\treturn nil, errors.New(ErrVolumeNotAttachedToHost, \"volume not attached to host\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/backup/models.go",
        "code_start_line": 117,
        "code_end_line": 130,
        "code_key": "Create",
        "code_value": "func (f *COSBasedFactory) Create(appId users.AppID, diskInfo DiskInfo) *Backup {\n\tbak := &Backup{}\n\tbak.UUID = uuid.New()\n\tbak.CreateTime = time.Now()\n\tbak.Status = StatusInit\n\tbak.AppID = appId\n\tbak.DiskInfo = diskInfo\n\tbak.Location.Bucket = f.bucket\n\t// rdiskBackups/20230102/1234678/abcd/efgh\n\tbak.Location.Path = fmt.Sprintf(\n\t\t\"rdisk-backups/%s/%d/%s/%s/backup\",\n\t\tbak.CreateTime.Format(\"20060102\"), appId, bak.DiskInfo.VolumeUUID, bak.UUID)\n\treturn bak\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/backup/states.go",
        "code_start_line": 152,
        "code_end_line": 166,
        "code_key": "whenTaskDone",
        "code_value": "func whenTaskDone(\n\tctx context.Context,\n\tsource BackupStatus,\n\ttarget BackupStatus,\n\tstateCtx Data) error {\n\tprogress, err := stateCtx.Delegate.QueryBackupProgress(ctx, stateCtx.Backup)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif progress.Done {\n\t\tstateCtx.Backup.UpdatePercentage(progress.Progress, progress.TotalSize)\n\t\treturn nil\n\t}\n\treturn errors.New(ErrTaskNotSuccess, \"backup task not success\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/fsm/fsm.go",
        "code_start_line": 79,
        "code_end_line": 92,
        "code_key": "getTransition",
        "code_value": "func (c *stateMachineImpl[S, E, C]) getTransition(currentState S, event E) ([]*transitionImpl[S, E, C], error) {\n\tif state, ok := c.stateMap[currentState]; ok {\n\t\tif transitions, ok := state.transitions[event]; ok {\n\t\t\trefs := make([]*transitionImpl[S, E, C], len(transitions))\n\t\t\tfor i := range transitions {\n\t\t\t\trefs[i] = &transitions[i]\n\t\t\t}\n\t\t\treturn refs, nil\n\t\t}\n\t\treturn nil, errors.New(ErrEventNotExists, \"event not exists\")\n\t} else {\n\t\treturn nil, errors.New(ErrStateNotExists, \"state not exists\")\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/fsm/fsm.go",
        "code_start_line": 94,
        "code_end_line": 109,
        "code_key": "getFirstOkTransition",
        "code_value": "func (c *stateMachineImpl[S, E, C]) getFirstOkTransition(ctx context.Context, currentState S, event E, stateCtx C) (int, error) {\n\ttransitions, err := c.getTransition(currentState, event)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tfor idx, transition := range transitions {\n\t\tif transition.condition != nil {\n\t\t\tif err := transition.condition.Check(ctx, transition.sourceState.stateId, transition.targetState.stateId, stateCtx); err == nil {\n\t\t\t\treturn idx, nil\n\t\t\t}\n\t\t} else {\n\t\t\treturn idx, nil\n\t\t}\n\t}\n\treturn 0, errors.New(ErrNoTransition, \"no valid transition\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 473,
        "code_end_line": 520,
        "code_key": "ObtainMulti",
        "code_value": "func (l *mysqlLocker) ObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, opts *dlock.Option) (dlock.Lock, error) {\n\tif len(keys) == 0 {\n\t\treturn nil, errors.New(\"keys cannot be empty\")\n\t}\n\tkeys = dedupAndSort(keys)\n\n\t// Get the lock token.\n\tlockToken, err := l.getOrCreateLockToken(opts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tretryStrategy := dlock.NoRetry()\n\tif opts != nil && opts.RetryStrategy != nil {\n\t\tretryStrategy = opts.RetryStrategy\n\t}\n\n\tretries := 0\n\tlogger := logs.GetLogger(ctx).With().Strs(\"keys\", dlock.LockKeySlice(keys).GetKeys()).Strs(\"tokens\", lockToken).Logger()\n\n\tfor {\n\t\t// Try to obtain the locks.\n\t\t// If the locks are not obtained, retry based on the retry strategy.\n\t\tif tokens, err := l.tryObtainMulti(ctx, keys, ttl, lockToken, opts); err != nil {\n\t\t\t// If context is canceled, return immediately.\n\t\t\tif ctx.Err() != nil {\n\t\t\t\treturn nil, errors.Wrap(dlock.ErrNotObtained, \"context is canceled\")\n\t\t\t}\n\n\t\t\t// If the lock is not obtained, retry.\n\t\t\twaitDuration := retryStrategy.NextBackoff()\n\t\t\tif waitDuration <= 0 {\n\t\t\t\tlogger.Debug().Int(\"retry\", retries).Msg(\"stop retrying lock\")\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tlogger.Debug().Int(\"retry\", retries).Msg(\"retry obtaining lock\")\n\t\t\ttime.Sleep(waitDuration)\n\t\t} else {\n\t\t\tlockToken = tokens\n\t\t\tlogger.Debug().Msg(\"lock obtained\")\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// TODO xuanzeng: 这里采用内部记录 TTL 的方式，可能和底层的数据库时间不同步，后续应该从数据库中获取过期时间。\n\tlock := &mysqlLock{keys: keys, locker: l, tokens: lockToken, expiration: time.Now().Add(ttl)}\n\treturn lock, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mem/memdlock.go",
        "code_start_line": 74,
        "code_end_line": 103,
        "code_key": "ObtainMulti",
        "code_value": "func (l *memLocker) ObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, opts *dlock.Option) (dlock.Lock, error) {\n\tvar token string\n\tif opts == nil || opts.Token == \"\" {\n\t\ttoken = uuid.New().String()\n\t} else {\n\t\ttoken = opts.Token\n\t}\n\n\tretryStrategy := dlock.NoRetry()\n\tif opts != nil && opts.RetryStrategy != nil {\n\t\tretryStrategy = opts.RetryStrategy\n\t}\n\n\tfor {\n\t\tlock, err := l.tryObtainMulti(ctx, keys, ttl, token)\n\t\tif err == nil {\n\t\t\treturn lock, nil\n\t\t}\n\n\t\tif ctx.Err() != nil {\n\t\t\treturn nil, ctx.Err()\n\t\t}\n\n\t\twaitInterval := retryStrategy.NextBackoff()\n\t\tif waitInterval <= 0 {\n\t\t\treturn nil, dlock.ErrNotObtained\n\t\t}\n\t\ttime.Sleep(waitInterval)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/uow.go",
        "code_start_line": 50,
        "code_end_line": 57,
        "code_key": "unitOfWork",
        "code_value": "type unitOfWork struct {\n\ttx                    *gorm.DB\n\ttrackedPhyVolumes     changeTracker[*rdiskDomain.PhysicalVolume]\n\ttrackedLogicalVolumes changeTracker[*rdiskDomain.LogicalVolume]\n\ttrackedDRGroups       changeTracker[*drgroup.DRGroup]\n\ttrackedBackups        changeTracker[*backup.Backup]\n\ttrackedBenchmarks     changeTracker[*benchmark.Benchmark]\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 67,
        "code_end_line": 83,
        "code_key": "PhysicalVolume",
        "code_value": "type PhysicalVolume struct {\n\tEntityMixin\n\tSerial          Serial              // 物理卷序列号\n\tIP              net.IP              // 物理卷所在主机 IP\n\tBDF             BDF                 // 物理卷所在主机的 BDF\n\tDiskID          uint64              // 物理卷在主机上的 BDev ID\n\tState           PhysicalVolumeState // 物理卷状态\n\tSize            Size                // 物理卷对外售卖大小 GiB\n\tVolumeType      VolumeType          // 物理卷类型\n\tZoneID          ZoneID              // 物理卷所在的 Zone\n\tBlockSize       uint                // 物理卷块大小，通常为 512\n\tRealSize        uint64              // 物理卷实际大小，单位为 Byte\n\tPort            uint                // 物理卷所在主机的端口\n\tDataNodeType    DataNodeType        // 数据节点类型\n\tCuf             Cuf                 // 存储节点 CUF 信息\n\tPerformanceRank PerformanceRank     // 物理卷性能等级\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 178,
        "code_end_line": 190,
        "code_key": "LogicalVolume",
        "code_value": "type LogicalVolume struct {\n\tEntityMixin\n\tUUID            uuid.UUID\n\tState           LogicalVolumeState\n\tSize            Size\n\tAppID           users.AppID\n\tZoneID          ZoneID\n\tDiskType        DiskType\n\tVolumeType      VolumeType\n\tFlowControlSpec FlowControlSpec\n\tPhysicalVolume  *PhysicalVolume\n\tAttachments     []*VolumeAttachment\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/models.go",
        "code_start_line": 58,
        "code_end_line": 68,
        "code_key": "DRGroup",
        "code_value": "type DRGroup struct {\n\tID       uint64      // 群组 ID，用作实体 ID\n\tName     string      // 群组名称，在同一个 AppID 下必须唯一\n\tAppID    users.AppID // 群组所属应用 ID\n\tType     LocType     // 群组类型，保留字段\n\tAffinity int         // 亲和度，表示群组内子组在同一台位置上最多只能有多少个\n\n\tsubGroups    map[string]*SubGroup   // 子组\n\tlocationsMap map[string][]*SubGroup // 位置到子组的映射\n\tmembersMap   map[string]*SubGroup   // 成员到子组的映射\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/backup/models.go",
        "code_start_line": 47,
        "code_end_line": 56,
        "code_key": "Backup",
        "code_value": "type Backup struct {\n\tID         uint64       // ID\n\tUUID       uuid.UUID    // 备份 UUID\n\tAppID      users.AppID  // 所属 AppID\n\tStatus     BackupStatus // 备份状态\n\tDiskInfo   DiskInfo     // 远端 SSD 信息\n\tPercentage int          // 备份进度，0-100\n\tCreateTime time.Time    // 创建时间\n\tLocation   COSLocation  // COS 存储位置\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/benchmark/benchmark.go",
        "code_start_line": 73,
        "code_end_line": 83,
        "code_key": "Benchmark",
        "code_value": "type Benchmark struct {\n\tID       uint64          // 主键 ID\n\tUUID     uuid.UUID       // 压测 UUID\n\tStatus   Status          // 压测状态\n\tDiskInfo DiskInfo        // 压测磁盘信息\n\tTaskID   uint64          // 任务 ID (BlockAgent 任务 ID)\n\tStat     PerformanceStat // 性能统计数据\n\tError    string          // 错误信息\n\tCreated  time.Time       // 创建时间\n\tFinished time.Time       // 完成时间\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/domain/backup/models.go:137:142:New": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/backup/models.go",
    "code_start_line": 137,
    "code_end_line": 142,
    "code_start_column": 6,
    "code_key": "New",
    "code_value": "func New(appId users.AppID, diskInfo DiskInfo) *Backup {\n\tif defaultFactory == nil {\n\t\tpanic(\"defaultFactory is nil\")\n\t}\n\treturn defaultFactory.Create(appId, diskInfo)\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/cmd/main.go",
        "code_start_line": 21,
        "code_end_line": 26,
        "code_key": "main",
        "code_value": "func main() {\n\tif err := rootCmd.Execute(); err != nil {\n\t\t_, _ = fmt.Fprintf(os.Stderr, \"cbs_packing_srv run failed %s\\n\", err)\n\t\tos.Exit(-1)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/cmd/main.go",
        "code_start_line": 22,
        "code_end_line": 28,
        "code_key": "main",
        "code_value": "func main() {\n\tif err := rootCmd.Execute(); err != nil {\n\t\teCode := -1\n\t\t_, _ = fmt.Fprintf(os.Stderr, \"sheduler run failed: %s\\n\", err.Error())\n\t\tos.Exit(eCode)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/cmd/main.go",
        "code_start_line": 18,
        "code_end_line": 24,
        "code_key": "main",
        "code_value": "func main() {\n\tif err := rootCmd.Execute(); err != nil {\n\t\teCode := -1\n\t\t_, _ = fmt.Fprintf(os.Stderr, \"sheduler run failed: %s\\n\", err.Error())\n\t\tos.Exit(eCode)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/clients/trade_client/main/main.go",
        "code_start_line": 20,
        "code_end_line": 50,
        "code_key": "main",
        "code_value": "func main() {\n\treq := APIRequestBody{\n\t\tVersion:       1,\n\t\tComponentName: \"example\",\n\t\tPassword:      \"password\",\n\t\tEventID:       \"123\",\n\t\tTimestamp:     1234567890,\n\t\tRequestInterface: struct {\n\t\t\tInterfaceName string                 `json:\"interfaceName\"`\n\t\t\tPara          map[string]interface{} `json:\"para\"`\n\t\t}{\n\t\t\tInterfaceName: \"exampleInterface\",\n\t\t\tPara: map[string]interface{}{\n\t\t\t\t\"param1\": \"value1\",\n\t\t\t\t\"param2\": 123,\n\t\t\t},\n\t\t},\n\t}\n\n\treqBody := make(map[string]interface{})\n\tv := reflect.ValueOf(req)\n\tt := reflect.TypeOf(req)\n\n\tfor i := 0; i < v.NumField(); i++ {\n\t\tfield := v.Field(i)\n\t\ttag := t.Field(i).Tag.Get(\"json\")\n\t\treqBody[tag] = field.Interface()\n\t}\n\n\tfmt.Println(reqBody)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/hademo/hademo.go",
        "code_start_line": 73,
        "code_end_line": 88,
        "code_key": "main",
        "code_value": "func main() {\n\tdb := initDB()\n\tlocker := initLocker(db)\n\n\t// read identity from cmdline args\n\tidentityP := flag.String(\"identity\", \"server1\", \"server identity\")\n\tflag.Parse()\n\n\tmanager := easyha.New(\n\t\t&server{identity: *identityP},\n\t\tlocker,\n\t\teasyha.WithNamespace(\"hademo\"),\n\t)\n\n\tmanager.Start(context.Background())\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/cmd/rdisk_master/main.go",
        "code_start_line": 19,
        "code_end_line": 25,
        "code_key": "main",
        "code_value": "func main() {\n\tif err := rootCmd.Execute(); err != nil {\n\t\teCode := -1\n\t\t_, _ = fmt.Fprintf(os.Stderr, \"rdisk master run failed %s\\n\", err)\n\t\tos.Exit(eCode)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/generate/errgen/errgen.go",
        "code_start_line": 38,
        "code_end_line": 87,
        "code_key": "main",
        "code_value": "func main() {\n\tlog.SetFlags(0)\n\tlog.SetPrefix(\"stringer: \")\n\tflag.Usage = Usage\n\tflag.Parse()\n\n\t// We accept either one directory or a list of files. Which do we have?\n\targs := flag.Args()\n\tif len(args) == 0 {\n\t\t// Default: process whole package in current directory.\n\t\targs = []string{\".\"}\n\t}\n\tvar dir string\n\tg := Generator{\n\t\ttrimPrefix: \"_\",\n\t}\n\tif trimPrefix != nil && *trimPrefix != \"\" {\n\t\tg.trimPrefix = *trimPrefix\n\t}\n\tif len(args) == 1 && isDirectory(args[0]) {\n\t\tdir = args[0]\n\t} else {\n\t\tdir = filepath.Dir(args[0])\n\t}\n\n\tg.parsePackage(args)\n\n\t// Print the header and package clause.\n\tg.Printf(\"// Code generated by \\\"errgen %s\\\"; DO NOT EDIT.\\n\", strings.Join(os.Args[1:], \" \"))\n\tg.Printf(\"\\n\")\n\tg.Printf(\"package %s\", g.pkg.name)\n\tg.Printf(\"\\n\")\n\n\tg.generate()\n\n\t// Format the output.\n\tsrc := g.format()\n\n\t// Write to file.\n\toutputName := *output\n\tif outputName == \"\" {\n\t\tbaseName := \"gen_errors.go\"\n\t\toutputName = filepath.Join(dir, strings.ToLower(baseName))\n\t}\n\t// NOCA:path_traversal(设计如此)\n\terr := os.WriteFile(outputName, src, 0o644) //nolint:gosec //标准权限\n\tif err != nil {\n\t\tlog.Fatalf(\"writing output: %s\", err)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/cmd/initialize/apiserver.go",
        "code_start_line": 16,
        "code_end_line": 49,
        "code_key": "logRequestFilter",
        "code_value": "func logRequestFilter(ctx context.Context, req interface{}, next filter.ServerHandleFunc) (rsp interface{}, err error) {\n\tmsg := trpc.Message(ctx)\n\taddr := msg.RemoteAddr()\n\tstartTime := time.Now()\n\t// 目前方案是每个请求生成一个 seqId，后续可以考虑使用 traceId\n\tseqId := uuid.New().String()\n\tlogger := logs.GetLogger(ctx)\n\tif logger != nil {\n\t\tctx = logger.With().Str(\"seqId\", seqId).Logger().WithContext(ctx)\n\t}\n\tlogs.Info(ctx).Interface(\"req\", req).\n\t\tStr(\"action\", msg.CalleeMethod()).\n\t\tStr(\"caller\", addr.String()).\n\t\tMsg(\"NEW_REQUEST\")\n\trsp, err = next(ctx, req)\n\tendTime := time.Now()\n\tif err == nil {\n\t\tlogs.Info(ctx).Interface(\"req\", req).\n\t\t\tInterface(\"rsp\", rsp).\n\t\t\tStr(\"action\", msg.CalleeMethod()).\n\t\t\tStr(\"caller\", addr.String()).\n\t\t\tDur(\"cost\", endTime.Sub(startTime)).\n\t\t\tMsg(\"API_SUCCESS\")\n\t} else {\n\t\tlogs.Warn(ctx).\n\t\t\tInterface(\"req\", req).\n\t\t\tErr(err).Interface(\"rsp\", rsp).\n\t\t\tStr(\"action\", msg.CalleeMethod()).\n\t\t\tStr(\"caller\", addr.String()).\n\t\t\tDur(\"cost\", endTime.Sub(startTime)).\n\t\t\tMsg(\"API_ERROR\")\n\t}\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 799,
        "code_end_line": 818,
        "code_key": "logRequestFilter",
        "code_value": "func logRequestFilter(ctx context.Context, req interface{}, next filter.ServerHandleFunc) (rsp interface{}, err error) {\n\tmsg := trpc.Message(ctx)\n\taddr := msg.RemoteAddr()\n\tstartTime := time.Now()\n\t// 目前方案是每个请求生成一个 seqId，后续可以考虑使用 traceId\n\tseqId := uuid.New().String()\n\tlogger := logs.GetLogger(ctx)\n\tif logger != nil {\n\t\tctx = logger.With().Str(\"seqId\", seqId).Logger().WithContext(ctx)\n\t}\n\tlogs.Info(ctx).Interface(\"params\", req).Str(\"action\", msg.CalleeMethod()).Str(\"caller\", addr.String()).Msg(\"NEW_REQUEST\")\n\trsp, err = next(ctx, req)\n\tendTime := time.Now()\n\tif err == nil {\n\t\tlogs.Info(ctx).Interface(\"params\", req).Interface(\"result\", rsp).Str(\"caller\", addr.String()).Dur(\"cost\", endTime.Sub(startTime)).Msg(\"API_SUCCESS\")\n\t} else {\n\t\tlogs.Warn(ctx).Interface(\"params\", req).Err(err).Interface(\"result\", rsp).Str(\"caller\", addr.String()).Dur(\"cost\", endTime.Sub(startTime)).Msg(\"API_ERROR\")\n\t}\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/cmd/initialize/ha.go",
        "code_start_line": 53,
        "code_end_line": 58,
        "code_key": "GetIdentity",
        "code_value": "func (h *HAEngine) GetIdentity() string {\n\tif ip := utils.GetLocalIP(); ip != \"\" {\n\t\treturn ip\n\t}\n\tpanic(\"Packing HA Manager GetIdentity failed\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/hademo/hademo.go",
        "code_start_line": 43,
        "code_end_line": 45,
        "code_key": "GetIdentity",
        "code_value": "func (s *server) GetIdentity() string {\n\treturn s.identity\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/scheduler.go",
        "code_start_line": 61,
        "code_end_line": 66,
        "code_key": "GetIdentity",
        "code_value": "func (*scheduler) GetIdentity() string {\n\tif ip := getLocalIP(); ip != \"\" {\n\t\treturn ip\n\t}\n\treturn uuid.New().String()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/cmd/initialize/ha.go",
        "code_start_line": 89,
        "code_end_line": 102,
        "code_key": "NewHAManager",
        "code_value": "func (h *HAEngine) NewHAManager(ctx context.Context) easyha.HAManager {\n\thaManager := easyha.New(h,\n\t\tapp.GlobalRegistry.DLocker,\n\t\teasyha.WithNamespace(\"cbs-packing\"),\n\t\teasyha.WithLockExpired(10*time.Second),\n\t\teasyha.WithCheckInterval(5*time.Second),\n\t\teasyha.WithLogger(*logs.GetLogger(ctx)))\n\n\tif h.manager != nil {\n\t\th.manager.Close(ctx)\n\t}\n\th.manager = haManager\n\treturn haManager\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/cmd/initialize/dlock.go",
        "code_start_line": 11,
        "code_end_line": 26,
        "code_key": "InitDLocker",
        "code_value": "func InitDLocker(ctx context.Context) {\n\tdbInstance, err := (&app.GlobalRegistry.AppConfig.DesDb).DB()\n\tif err != nil {\n\t\tlogs.Fatal(ctx).Err(err).Msg(\"init des db instance failed.\")\n\t}\n\tdLockerConf := dlock_mysql.Config{\n\t\tTableName:      \"packing_lock\",\n\t\tLockColumn:     \"lock_key\",\n\t\tExpireColumn:   \"expired\",\n\t\tTokenColumn:    \"lock_token\", // NOCA:PasswordLeak(误报)\n\t\tLockTypeColumn: \"lock_type\",\n\t\tLockNumsColumn: \"lock_count\",\n\t}\n\tdLocker := dlock_mysql.New(dbInstance, dLockerConf)\n\tapp.GlobalRegistry.RegisterDLocker(dLocker)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/infra/response/errors.go",
        "code_start_line": 28,
        "code_end_line": 30,
        "code_key": "TRPCError",
        "code_value": "func TRPCError(code int, text string) error {\n\treturn errors.New(code, text)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/app/api/api.go",
        "code_start_line": 43,
        "code_end_line": 125,
        "code_key": "ApplyRemoteDiskVolume",
        "code_value": "func (s *PackingApiImpl) ApplyRemoteDiskVolume(\n\tctx context.Context,\n\treq *pb.ApplyRemoteDiskVolumeRequest,\n) (*pb.ApplyRemoteDiskVolumeResponse, error) {\n\tappCtx := context.WithValue(ctx, app.GetApplicationContextName(), app.GlobalRegistry.AppContext)\n\t// HA决策, 所有流量转到Master执行\n\tif !app.GlobalRegistry.HAEngine.IsMaster() {\n\t\treturn app.GlobalRegistry.HAEngine.BuildMasterNode(appCtx).ApplyRemoteDiskVolume(appCtx, req)\n\t}\n\n\tif err := s.checkApplyReq(req); err != nil {\n\t\treturn nil, err\n\t}\n\n\tuser := account.NewUser(int(req.AppId), req.Uin, req.SubAccountUin)\n\taffinityConfig := affi.AffinityFacade{}.ConvertToAffinityConfig(req.PlacementGroupSet, req.PlacementPolicy)\n\n\t// 优先尝试从子组池中申请已创建的盘\n\tsubGroupSrv, err := services.NewSubGroupPoolService(appCtx, user, affinityConfig)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\toneDisk := subGroupSrv.ApplyPoolDisks(appCtx)\n\n\t// 子组池申领成功则直接返回\n\tif oneDisk != nil {\n\t\tlogs.Info(appCtx).\n\t\t\tInt(\"app_id\", int(req.AppId)).\n\t\t\tStr(\"disk_uuid\", string(oneDisk.DiskUuid)).\n\t\t\tStr(\"sub_group\", affinityConfig.GetSubGroupId(appCtx)).\n\t\t\tMsg(\"APPLY_REMOTE_DISK_FROM_SUB_GROUP_POOL_SUC\")\n\t\treturn &pb.ApplyRemoteDiskVolumeResponse{\n\t\t\tDiskVolumeSet: []*pb.DiskVolumeModel{\n\t\t\t\t{DiskUuid: string(oneDisk.DiskUuid)},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// 子组池不存在则为首次申领, 通过事件总线进行新建申领\n\tdiskCount := req.PlacementGroupSet[0].GetSubGroupMemberCount()\n\tbusContext := flow.NewPackDiskBusContext(\n\t\tuser,\n\t\ttypes.DiskSize(req.DiskSize),\n\t\ttypes.ZoneId(req.ZoneId),\n\t\ttypes.DiskCount(diskCount),\n\t\tdisk.RemoteDisk,\n\t\taffinityConfig,\n\t\ttypes.PerformanceRank(req.PerformanceRank))\n\n\teventBusDriver := event_bus.NewEventBusDriver().\n\t\tSetBusContext(appCtx, busContext).\n\t\tRegisterEvent(appCtx, event_bus.ApplyRDEvent, &PackingDomain.RemoteDiskPackService{}).\n\t\tRegisterEvent(appCtx, event_bus.CreateRDEvent, &ProductionDomain.CreateRemoteDiskService{}).\n\t\tPublishBusEvents(appCtx)\n\n\tresult := eventBusDriver.Execute(appCtx)\n\tif result.IsFailed() {\n\t\tsubGroupSrv.ClosePool(ctx)\n\t\tlogs.Info(appCtx).Err(result).Int(\"ERROR_CODE\", int(result.Code)).Msg(\"APPLY_REMOTE_DISK_FAILED\")\n\t\treturn nil, result.ToTRPCError()\n\t}\n\n\t//首次申领, 申领成功之后入子组池, 后续该子组申领直接从子组池中领取\n\terr = subGroupSrv.PushPool(appCtx, busContext.Disks[1:])\n\n\tif err != nil {\n\t\tlogs.Info(appCtx).Err(err).\n\t\t\tUint64(\"app_id\", req.AppId).\n\t\t\tStr(\"sub_group\", affinityConfig.GetSubGroupId(appCtx)).\n\t\t\tMsg(\"PUSH_SUB_GROUP_POOL_FAILED\")\n\t\treturn nil, err\n\t}\n\n\tdiskVolumeSet := make([]*pb.DiskVolumeModel, 0, 100)\n\tfor _, diskObj := range busContext.Disks[:1] {\n\t\tdiskVolumeSet = append(diskVolumeSet, &pb.DiskVolumeModel{\n\t\t\tDiskUuid: string(diskObj.DiskUuid),\n\t\t})\n\t}\n\n\trsp := &pb.ApplyRemoteDiskVolumeResponse{DiskVolumeSet: diskVolumeSet}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv.trpc.go",
        "code_start_line": 140,
        "code_end_line": 142,
        "code_key": "ApplyRemoteDiskVolume",
        "code_value": "func (s *UnimplementedApi) ApplyRemoteDiskVolume(ctx context.Context, req *ApplyRemoteDiskVolumeRequest) (*ApplyRemoteDiskVolumeResponse, error) {\n\treturn nil, errors.New(\"rpc ApplyRemoteDiskVolume of service Api is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv.trpc.go",
        "code_start_line": 189,
        "code_end_line": 207,
        "code_key": "ApplyRemoteDiskVolume",
        "code_value": "func (c *ApiClientProxyImpl) ApplyRemoteDiskVolume(ctx context.Context, req *ApplyRemoteDiskVolumeRequest, opts ...client.Option) (*ApplyRemoteDiskVolumeResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.cbs.packing.api/ApplyRemoteDiskVolume\")\n\tmsg.WithCalleeServiceName(ApiServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"cbs\")\n\tmsg.WithCalleeServer(\"packing\")\n\tmsg.WithCalleeService(\"api\")\n\tmsg.WithCalleeMethod(\"ApplyRemoteDiskVolume\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &ApplyRemoteDiskVolumeResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv_mock.go",
        "code_start_line": 39,
        "code_end_line": 45,
        "code_key": "ApplyRemoteDiskVolume",
        "code_value": "func (m *MockApiService) ApplyRemoteDiskVolume(ctx context.Context, req *ApplyRemoteDiskVolumeRequest) (*ApplyRemoteDiskVolumeResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"ApplyRemoteDiskVolume\", ctx, req)\n\tret0, _ := ret[0].(*ApplyRemoteDiskVolumeResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv_mock.go",
        "code_start_line": 48,
        "code_end_line": 51,
        "code_key": "ApplyRemoteDiskVolume",
        "code_value": "func (mr *MockApiServiceMockRecorder) ApplyRemoteDiskVolume(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ApplyRemoteDiskVolume\", reflect.TypeOf((*MockApiService)(nil).ApplyRemoteDiskVolume), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv_mock.go",
        "code_start_line": 122,
        "code_end_line": 132,
        "code_key": "ApplyRemoteDiskVolume",
        "code_value": "func (m *MockApiClientProxy) ApplyRemoteDiskVolume(ctx context.Context, req *ApplyRemoteDiskVolumeRequest, opts ...client.Option) (*ApplyRemoteDiskVolumeResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"ApplyRemoteDiskVolume\", varargs...)\n\tret0, _ := ret[0].(*ApplyRemoteDiskVolumeResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv_mock.go",
        "code_start_line": 135,
        "code_end_line": 139,
        "code_key": "ApplyRemoteDiskVolume",
        "code_value": "func (mr *MockApiClientProxyMockRecorder) ApplyRemoteDiskVolume(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ApplyRemoteDiskVolume\", reflect.TypeOf((*MockApiClientProxy)(nil).ApplyRemoteDiskVolume), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/app/api/api.go",
        "code_start_line": 128,
        "code_end_line": 134,
        "code_key": "ReplaceRemoteDiskVolume",
        "code_value": "func (s *PackingApiImpl) ReplaceRemoteDiskVolume(\n\tctx context.Context,\n\treq *pb.ReplaceRemoteDiskVolumeRequest,\n) (*pb.ReplaceRemoteDiskVolumeResponse, error) {\n\trsp := &pb.ReplaceRemoteDiskVolumeResponse{}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv.trpc.go",
        "code_start_line": 145,
        "code_end_line": 147,
        "code_key": "ReplaceRemoteDiskVolume",
        "code_value": "func (s *UnimplementedApi) ReplaceRemoteDiskVolume(ctx context.Context, req *ReplaceRemoteDiskVolumeRequest) (*ReplaceRemoteDiskVolumeResponse, error) {\n\treturn nil, errors.New(\"rpc ReplaceRemoteDiskVolume of service Api is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv.trpc.go",
        "code_start_line": 209,
        "code_end_line": 227,
        "code_key": "ReplaceRemoteDiskVolume",
        "code_value": "func (c *ApiClientProxyImpl) ReplaceRemoteDiskVolume(ctx context.Context, req *ReplaceRemoteDiskVolumeRequest, opts ...client.Option) (*ReplaceRemoteDiskVolumeResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.cbs.packing.api/ReplaceRemoteDiskVolume\")\n\tmsg.WithCalleeServiceName(ApiServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"cbs\")\n\tmsg.WithCalleeServer(\"packing\")\n\tmsg.WithCalleeService(\"api\")\n\tmsg.WithCalleeMethod(\"ReplaceRemoteDiskVolume\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &ReplaceRemoteDiskVolumeResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv_mock.go",
        "code_start_line": 84,
        "code_end_line": 90,
        "code_key": "ReplaceRemoteDiskVolume",
        "code_value": "func (m *MockApiService) ReplaceRemoteDiskVolume(ctx context.Context, req *ReplaceRemoteDiskVolumeRequest) (*ReplaceRemoteDiskVolumeResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"ReplaceRemoteDiskVolume\", ctx, req)\n\tret0, _ := ret[0].(*ReplaceRemoteDiskVolumeResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv_mock.go",
        "code_start_line": 93,
        "code_end_line": 96,
        "code_key": "ReplaceRemoteDiskVolume",
        "code_value": "func (mr *MockApiServiceMockRecorder) ReplaceRemoteDiskVolume(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ReplaceRemoteDiskVolume\", reflect.TypeOf((*MockApiService)(nil).ReplaceRemoteDiskVolume), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv_mock.go",
        "code_start_line": 182,
        "code_end_line": 192,
        "code_key": "ReplaceRemoteDiskVolume",
        "code_value": "func (m *MockApiClientProxy) ReplaceRemoteDiskVolume(ctx context.Context, req *ReplaceRemoteDiskVolumeRequest, opts ...client.Option) (*ReplaceRemoteDiskVolumeResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"ReplaceRemoteDiskVolume\", varargs...)\n\tret0, _ := ret[0].(*ReplaceRemoteDiskVolumeResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv_mock.go",
        "code_start_line": 195,
        "code_end_line": 199,
        "code_key": "ReplaceRemoteDiskVolume",
        "code_value": "func (mr *MockApiClientProxyMockRecorder) ReplaceRemoteDiskVolume(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ReplaceRemoteDiskVolume\", reflect.TypeOf((*MockApiClientProxy)(nil).ReplaceRemoteDiskVolume), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/app/api/api.go",
        "code_start_line": 137,
        "code_end_line": 177,
        "code_key": "InquireRemoteDiskStock",
        "code_value": "func (s *PackingApiImpl) InquireRemoteDiskStock(\n\tctx context.Context,\n\treq *pb.InquireRemoteDiskStockRequest,\n) (*pb.InquireDiskStockResponse, error) {\n\tappCtx := context.WithValue(ctx, app.GetApplicationContextName(), app.GlobalRegistry.AppContext)\n\n\tinquireStockContext := flow.NewInquireDiskStockBusContext(\n\t\taccount.NewUser(int(req.AppId), req.Uin, req.SubAccountUin),\n\t\ttypes.ZoneId(req.ZoneId), types.DiskSize(req.DiskSize),\n\t\taffi.AffinityFacade{}.ConvertToAffinityConfig(req.PlacementGroupSet, nil),\n\t\ttypes.PerformanceRank(req.PerformanceRank))\n\n\tif !app.GlobalRegistry.HAEngine.IsMaster() {\n\t\treturn app.GlobalRegistry.HAEngine.BuildMasterNode(appCtx).InquireRemoteDiskStock(ctx, req)\n\t}\n\n\teventBusDriver := event_bus.NewEventBusDriver().\n\t\tSetBusContext(appCtx, inquireStockContext).\n\t\tRegisterEvent(appCtx, event_bus.InquireDiskStockEvent, &InventoryDomain.InquireRemoteDiskStockService{}).\n\t\tPublishBusEvents(appCtx)\n\tresult := eventBusDriver.Execute(appCtx)\n\n\tif result.IsFailed() {\n\t\tlogs.Info(appCtx).Err(result).Int(\"err_code\", int(result.Code)).Msg(\"INQUIRE_REMOTE_DISK_FAILED\")\n\t\treturn nil, result.ToTRPCError()\n\t}\n\n\tstockModelSet := make([]*pb.DiskStockModel, 0, 10)\n\tstockModelSet = append(stockModelSet, inquireStockContext.DiskStockModel)\n\trsp := &pb.InquireDiskStockResponse{DiskStockModelSet: stockModelSet}\n\n\tlogs.Info(appCtx).\n\t\tInt(\"app_id\", int(req.AppId)).\n\t\tInt(\"disk_size\", int(req.DiskSize)).\n\t\tInt(\"zone_id\", int(req.ZoneId)).\n\t\tStrs(\"group_id\", inquireStockContext.AffinityConfig.GetAllPlacementGroupId(ctx)).\n\t\tInt(\"stock_count\", int(inquireStockContext.DiskStockModel.GetStockCount())).\n\t\tMsg(\"INQUIRE_REMOTE_DISK_STOCK_SUC\")\n\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv.trpc.go",
        "code_start_line": 150,
        "code_end_line": 152,
        "code_key": "InquireRemoteDiskStock",
        "code_value": "func (s *UnimplementedApi) InquireRemoteDiskStock(ctx context.Context, req *InquireRemoteDiskStockRequest) (*InquireDiskStockResponse, error) {\n\treturn nil, errors.New(\"rpc InquireRemoteDiskStock of service Api is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv.trpc.go",
        "code_start_line": 229,
        "code_end_line": 247,
        "code_key": "InquireRemoteDiskStock",
        "code_value": "func (c *ApiClientProxyImpl) InquireRemoteDiskStock(ctx context.Context, req *InquireRemoteDiskStockRequest, opts ...client.Option) (*InquireDiskStockResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.cbs.packing.api/InquireRemoteDiskStock\")\n\tmsg.WithCalleeServiceName(ApiServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"cbs\")\n\tmsg.WithCalleeServer(\"packing\")\n\tmsg.WithCalleeService(\"api\")\n\tmsg.WithCalleeMethod(\"InquireRemoteDiskStock\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &InquireDiskStockResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv_mock.go",
        "code_start_line": 69,
        "code_end_line": 75,
        "code_key": "InquireRemoteDiskStock",
        "code_value": "func (m *MockApiService) InquireRemoteDiskStock(ctx context.Context, req *InquireRemoteDiskStockRequest) (*InquireDiskStockResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"InquireRemoteDiskStock\", ctx, req)\n\tret0, _ := ret[0].(*InquireDiskStockResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv_mock.go",
        "code_start_line": 78,
        "code_end_line": 81,
        "code_key": "InquireRemoteDiskStock",
        "code_value": "func (mr *MockApiServiceMockRecorder) InquireRemoteDiskStock(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"InquireRemoteDiskStock\", reflect.TypeOf((*MockApiService)(nil).InquireRemoteDiskStock), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv_mock.go",
        "code_start_line": 162,
        "code_end_line": 172,
        "code_key": "InquireRemoteDiskStock",
        "code_value": "func (m *MockApiClientProxy) InquireRemoteDiskStock(ctx context.Context, req *InquireRemoteDiskStockRequest, opts ...client.Option) (*InquireDiskStockResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"InquireRemoteDiskStock\", varargs...)\n\tret0, _ := ret[0].(*InquireDiskStockResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv_mock.go",
        "code_start_line": 175,
        "code_end_line": 179,
        "code_key": "InquireRemoteDiskStock",
        "code_value": "func (mr *MockApiClientProxyMockRecorder) InquireRemoteDiskStock(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"InquireRemoteDiskStock\", reflect.TypeOf((*MockApiClientProxy)(nil).InquireRemoteDiskStock), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/app/api/api.go",
        "code_start_line": 180,
        "code_end_line": 231,
        "code_key": "CalculateSetWeigherScore",
        "code_value": "func (s *PackingApiImpl) CalculateSetWeigherScore(\n\tctx context.Context,\n\treq *pb.CalculateSetWeigherScoreRequest,\n) (*pb.CalculateSetWeigherScoreResponse, error) {\n\n\tappCtx := context.WithValue(ctx, app.GetApplicationContextName(), app.GlobalRegistry.AppContext)\n\n\trulePackingBusContext := &flow.SetPackingBusContext{\n\t\tAppId:              types.AppId{AppId: int(req.AppId)},\n\t\tZoneId:             types.ZoneId(req.ZoneId),\n\t\tDiskSize:           types.DiskSize(req.DiskSize),\n\t\tSnapUuid:           types.SnapUuid(req.SnapUuid),\n\t\tDiskType:           types.DiskType(req.DiskType),\n\t\tPayMode:            types.PayMode(req.PayMode),\n\t\tOriginalVolumeType: req.OriginalVolumeType,\n\t\tConcreteVolumeType: req.ConcreteVolumeType,\n\t\tSetUuidList:        req.SetUuidList,\n\t\tCbsDiskTrait:       req.CbsDiskTrait,\n\t}\n\n\tif !app.GlobalRegistry.HAEngine.IsMaster() {\n\t\treturn app.GlobalRegistry.HAEngine.BuildMasterNode(appCtx).CalculateSetWeigherScore(ctx, req)\n\t}\n\n\teventBusDriver := event_bus.NewEventBusDriver().\n\t\tSetBusContext(appCtx, rulePackingBusContext).\n\t\tRegisterEvent(appCtx, event_bus.SetPackingEvent, &PackingDomain.CloudPackSetService{}).\n\t\tPublishBusEvents(appCtx)\n\n\tresult := eventBusDriver.Execute(appCtx)\n\n\tif result.IsFailed() {\n\t\tlogs.Info(appCtx).Err(result).Int(\"err_code\", int(result.Code)).Msg(\"CALCULATE_SET_WEIGHER_SCORE_FAILED\")\n\t\treturn nil, result.ToTRPCError()\n\t}\n\n\tscoreMap := make(map[string]int32)\n\tfor setUuid, scoreList := range rulePackingBusContext.SetScoreMap {\n\t\tscoreMap[setUuid] = scoreList[0]\n\t}\n\n\tlogs.Info(appCtx).\n\t\tInt(\"app_id\", int(req.AppId)).\n\t\tInterface(\"score_map\", scoreMap).\n\t\tMsg(\"CALCULATE_SET_WEIGHER_SCORE_SUCCESS\")\n\n\trsp := &pb.CalculateSetWeigherScoreResponse{\n\t\tSetScoreMap: scoreMap,\n\t}\n\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv.trpc.go",
        "code_start_line": 155,
        "code_end_line": 157,
        "code_key": "CalculateSetWeigherScore",
        "code_value": "func (s *UnimplementedApi) CalculateSetWeigherScore(ctx context.Context, req *CalculateSetWeigherScoreRequest) (*CalculateSetWeigherScoreResponse, error) {\n\treturn nil, errors.New(\"rpc CalculateSetWeigherScore of service Api is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv.trpc.go",
        "code_start_line": 249,
        "code_end_line": 267,
        "code_key": "CalculateSetWeigherScore",
        "code_value": "func (c *ApiClientProxyImpl) CalculateSetWeigherScore(ctx context.Context, req *CalculateSetWeigherScoreRequest, opts ...client.Option) (*CalculateSetWeigherScoreResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.cbs.packing.api/CalculateSetWeigherScore\")\n\tmsg.WithCalleeServiceName(ApiServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"cbs\")\n\tmsg.WithCalleeServer(\"packing\")\n\tmsg.WithCalleeService(\"api\")\n\tmsg.WithCalleeMethod(\"CalculateSetWeigherScore\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &CalculateSetWeigherScoreResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv_mock.go",
        "code_start_line": 54,
        "code_end_line": 60,
        "code_key": "CalculateSetWeigherScore",
        "code_value": "func (m *MockApiService) CalculateSetWeigherScore(ctx context.Context, req *CalculateSetWeigherScoreRequest) (*CalculateSetWeigherScoreResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CalculateSetWeigherScore\", ctx, req)\n\tret0, _ := ret[0].(*CalculateSetWeigherScoreResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv_mock.go",
        "code_start_line": 63,
        "code_end_line": 66,
        "code_key": "CalculateSetWeigherScore",
        "code_value": "func (mr *MockApiServiceMockRecorder) CalculateSetWeigherScore(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CalculateSetWeigherScore\", reflect.TypeOf((*MockApiService)(nil).CalculateSetWeigherScore), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv_mock.go",
        "code_start_line": 142,
        "code_end_line": 152,
        "code_key": "CalculateSetWeigherScore",
        "code_value": "func (m *MockApiClientProxy) CalculateSetWeigherScore(ctx context.Context, req *CalculateSetWeigherScoreRequest, opts ...client.Option) (*CalculateSetWeigherScoreResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"CalculateSetWeigherScore\", varargs...)\n\tret0, _ := ret[0].(*CalculateSetWeigherScoreResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cbs_packing_srv/cbs_packing_srv_mock.go",
        "code_start_line": 155,
        "code_end_line": 159,
        "code_key": "CalculateSetWeigherScore",
        "code_value": "func (mr *MockApiClientProxyMockRecorder) CalculateSetWeigherScore(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CalculateSetWeigherScore\", reflect.TypeOf((*MockApiClientProxy)(nil).CalculateSetWeigherScore), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/expiremap.go",
        "code_start_line": 91,
        "code_end_line": 96,
        "code_key": "Delete",
        "code_value": "func (e *ExpiredMap) Delete(key interface{}) {\n\te.lck.Lock()\n\tdelete(e.m, key)\n\te.deleteTimeMap(key)\n\te.lck.Unlock()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/scheduler.go",
        "code_start_line": 135,
        "code_end_line": 139,
        "code_key": "Delete",
        "code_value": "func (s *scheduler) Delete(name string) {\n\ts.mutex.Lock()\n\tdefer s.mutex.Unlock()\n\tdelete(s.loads, name)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/benchmark.go",
        "code_start_line": 32,
        "code_end_line": 39,
        "code_key": "Delete",
        "code_value": "func (repo *rdiskBenchmarkRepositoryImpl) Delete(ctx context.Context, bench *benchmark.Benchmark) error {\n\tuow := getUow(ctx)\n\tresult := uow.tx.Delete(&metadb.DmRdiskBenchmark{}, \"id = ?\", bench.ID)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/backup.go",
        "code_start_line": 34,
        "code_end_line": 41,
        "code_key": "Delete",
        "code_value": "func (*rdiskBackupRepositoryImpl) Delete(ctx context.Context, backup *backupPkg.Backup) error {\n\tuow := getUow(ctx)\n\tresult := uow.tx.Delete(&metadb.DmRdiskBackup{}, \"id = ?\", backup.ID)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go",
        "code_start_line": 73,
        "code_end_line": 81,
        "code_key": "Delete",
        "code_value": "func (p *physicalVolumeRepositoryImpl) Delete(ctx context.Context, pv *rdiskDomain.PhysicalVolume) error {\n\tuow := getUow(ctx)\n\tidt := pv.GetID()\n\tresult := uow.tx.Where(\"id = ?\", idt).Delete(&metadb.DmPhydisk{})\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
        "code_start_line": 111,
        "code_end_line": 122,
        "code_key": "Delete",
        "code_value": "func (d drgroupRepositoryImpl) Delete(ctx context.Context, group *drgroup.DRGroup) error {\n\tuow := getUow(ctx)\n\tresult := uow.tx.Delete(&metadb.DmDrgroup{}, \"id = ?\", group.ID)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tresult = uow.tx.Delete(&metadb.DmDrgroupMembers{}, \"app_id = ? and group_name = ?\", group.AppID, group.Name)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 356,
        "code_end_line": 363,
        "code_key": "Delete",
        "code_value": "func (l *LogicalVolume) Delete() error {\n\tif len(l.Attachments) > 0 {\n\t\treturn errors.New(ErrVolumeAttached, \"volume is still attached to some hosts\")\n\t}\n\tl.PhysicalVolume = nil\n\tl.State = LVSDeleted\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 54,
        "code_end_line": 59,
        "code_key": "Delete",
        "code_value": "func (m *MockPhysicalVolumeRepository) Delete(arg0 context.Context, arg1 *rdiskDomain.PhysicalVolume) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Delete\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 62,
        "code_end_line": 65,
        "code_key": "Delete",
        "code_value": "func (mr *MockPhysicalVolumeRepositoryMockRecorder) Delete(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Delete\", reflect.TypeOf((*MockPhysicalVolumeRepository)(nil).Delete), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 54,
        "code_end_line": 59,
        "code_key": "Delete",
        "code_value": "func (m *MockRepository) Delete(arg0 context.Context, arg1 *drgroup.DRGroup) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Delete\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 62,
        "code_end_line": 65,
        "code_key": "Delete",
        "code_value": "func (mr *MockRepositoryMockRecorder) Delete(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Delete\", reflect.TypeOf((*MockRepository)(nil).Delete), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go",
        "code_start_line": 51,
        "code_end_line": 72,
        "code_key": "Handle",
        "code_value": "func (c *CbsAppIdConsumer) Handle(ctx context.Context, delivery *rabbitmq.Delivery) error {\n\tu, chargeTime, err := c.ParseDelivery(ctx, delivery)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif u == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"USER_INFO_NOT_FOUND\")\n\t\treturn nil\n\t}\n\n\tchargeDetail := c.GetChargeDetailForSingleUser(u, chargeTime)\n\tif chargeDetail == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tUint64(\"appId\", uint64(u.AppId)).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"NO_RESOURCE_TO_CHARGE\")\n\t\treturn nil\n\t}\n\treturn c.ProcessChargeDetail(chargeDetail)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 105,
        "code_end_line": 116,
        "code_key": "Handle",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tif err := c.ensureLocks(ctx); err != nil {\n\t\treturn err\n\t}\n\tif c.lvUUID != nil {\n\t\t// 涉及到逻辑卷时，需要先标记逻辑卷为故障\n\t\treturn c.handleBindedVolume(ctx)\n\t} else {\n\t\t// 不涉及到逻辑卷时，直接标记物理卷为故障\n\t\treturn c.handleIdleVolume(ctx)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/detach_logical_volume.go",
        "code_start_line": 56,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *DetachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDetachLogicalVolume, c)\n\n\t// 如果没有挂载到指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume not attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_benchmark_task.go",
        "code_start_line": 125,
        "code_end_line": 165,
        "code_key": "Handle",
        "code_value": "func (c *CreateBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tvolSm     = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = volSm.Fire(ctx, c.relatedVolume.State, domain.PVEStartBenchmark, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark = benchmark.New(benchmark.DiskInfo{\n\t\tSerial: string(c.relatedVolume.Serial),\n\t\tHostIP: c.relatedVolume.IP,\n\t\tBDF:    string(c.relatedVolume.BDF),\n\t})\n\n\tif err = benchRepo.Add(ctx, c.relatedBenchmark); err != nil {\n\t\tdelegate := &benchmarkDelegate{cmd: c}\n\t\tif _err := delegate.TaskFinishCallback(ctx, c.relatedBenchmark); _err != nil {\n\t\t\tlogs.Warn(ctx).Err(_err).Str(\"serial\", string(c.relatedVolume.Serial)).Msg(\"failed to rollback: create bdev\")\n\t\t}\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventCreateBench,\n\t\tbenchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_logical_volume.go",
        "code_start_line": 71,
        "code_end_line": 108,
        "code_key": "Handle",
        "code_value": "func (d *DeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\td.volume, err = repo.FindByID(ctx, d.UUID)\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif e := d.volume.CheckDelete(); e != nil {\n\t\treturn e\n\t}\n\n\tif d.volume.AppID != d.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"refuse to delet: app id mismatch\")\n\t}\n\n\td.drgroup, err = app.GetRegistry(ctx).Repositories.DRGroup.FindByMember(ctx, d.AppID, d.volume.UUID.String())\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\td.drgroup = nil\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := d.checkDRGroupMatch(ctx); err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, d.volume.State, rdiskDomain.LVEMarkToRecycle, d)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_recycled_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmRecycledPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEConfirmRecycled, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_rdisk_backup.go",
        "code_start_line": 52,
        "code_end_line": 75,
        "code_key": "Handle",
        "code_value": "func (c *DeleteRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tsm   = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\tc.relatedBackup, err = repo.FindByUUID(ctx, c.BackupID.String())\n\tif err != nil || c.relatedBackup == nil || c.relatedBackup.AppID != c.AppID {\n\t\treturn errors.New(backupDomain.ErrBackupNotExist, \"backup not exists\")\n\t}\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tc.relatedBackup.Status,\n\t\tbackupDomain.EventSoftDeleteBackup,\n\t\tbackupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: c.relatedBackup})\n\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_rdisk_backup.go",
        "code_start_line": 47,
        "code_end_line": 80,
        "code_key": "Handle",
        "code_value": "func (c *CreateRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tlvSm  = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\tbakSm = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo  = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t_, err = lvSm.Fire(ctx, c.relatedVolume.State, rdiskDomain.LVEBackupStarted, c)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tlv := c.relatedVolume\n\tbackup := backupDomain.New(\n\t\tlv.AppID,\n\t\tbackupDomain.DiskInfo{\n\t\t\tVolumeUUID: lv.UUID,\n\t\t\tVolumeSize: uint64(lv.Size),\n\t\t\tHostIP:     lv.PhysicalVolume.IP,\n\t\t\tHostBDF:    string(lv.PhysicalVolume.BDF),\n\t\t\tSerial:     string(lv.PhysicalVolume.Serial),\n\t\t},\n\t)\n\tif err := repo.Add(ctx, backup); err != nil {\n\t\treturn err\n\t}\n\tc.relatedBackup = backup\n\t_, err = bakSm.Fire(ctx, backupDomain.StatusInit, backupDomain.EventStartBackup, backupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: backup})\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/attach_logical_volume.go",
        "code_start_line": 49,
        "code_end_line": 71,
        "code_key": "Handle",
        "code_value": "func (c *AttachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEAttachLogicalVolume, c)\n\n\t// 如果已经挂载到了指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeAlreadyAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume already attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_delete_logical_volume.go",
        "code_start_line": 34,
        "code_end_line": 55,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\t// 如果逻辑卷不存在，则直接返回成功\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"failed to confirm delete: app id mismatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDeleteLogicalVolume, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/offline_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OfflinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOfflinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *DeletePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\t// 如果物理卷不存在，则直接幂等返回\n\t\treturn nil\n\t}\n\n\tvar event = domain.PVEDeletePhysicalVolume\n\tif c.Force && (c.relatedVolume.State == domain.PVSDefunct) {\n\t\t// 这里的实现不太好，状态机的逻辑不应该侵入 cmd\n\t\t// 时间太赶了，后续重构优化吧\n\t\tevent = domain.PVEForceDeleteForDefunct\n\t}\n\n\tif c.relatedVolume.HasBindedPV() {\n\t\treturn errors.New(domain.ErrVolumeBusy, \"logic volume has binded to this physical volume\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, event, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_logical_volume.go",
        "code_start_line": 55,
        "code_end_line": 70,
        "code_key": "Handle",
        "code_value": "func (c *CleanupLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVECleanupLogicalVolume, c)\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_init_physical_volume.go",
        "code_start_line": 26,
        "code_end_line": 52,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmInitPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\tif c.relatedVolume.IP.String() != c.Host.String() {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume host ip mistmatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVECreatePhysicalVolumeOnHost, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_physical_volume.go",
        "code_start_line": 51,
        "code_end_line": 101,
        "code_key": "Handle",
        "code_value": "func (c *CreatePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\n\t// 获取物理卷状态机\n\tsm := app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\trepo := app.GetRegistry(ctx).Repositories.PhysicalVolume\n\n\t// 检查物理卷是否已经存在，如果存在则直接幂等返回\n\tvol1, err := repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"serial\", c.Serial).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tvol2, err := repo.FindByIPAndBDF(ctx, c.Host, domain.BDF(c.BDF))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"host\", c.Host.String()).Str(\"bdf\", c.BDF).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tfor _, vol := range []*domain.PhysicalVolume{vol1, vol2} {\n\t\texisted, err := c.checkExisting(ctx, vol)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif existed {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// 触发事件，创建物理卷\n\t_, err = sm.Fire(ctx,\n\t\tdomain.PVSUnInited,\n\t\tdomain.PVECreatePhysicalVolume,\n\t\tc,\n\t)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 创建 Bdev 以及格式化移动到创建物理卷的状态机中\n\n\t// _, err = sm.Fire(ctx,\n\t// \tc.GetPhysicalVolume().State,\n\t// \tdomain.PVECreatePhysicalVolumeOnHost,\n\t// \tc,\n\t// )\n\t// if err != nil {\n\t// \treturn err\n\t// }\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_benchmark_task.go",
        "code_start_line": 32,
        "code_end_line": 57,
        "code_key": "Handle",
        "code_value": "func (c *DeleteBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\terr       error\n\t)\n\n\tbench, err := benchRepo.FindByUUID(ctx, c.BenchmarkUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif bench.DiskInfo.Serial != c.Serial {\n\t\treturn errors.Newf(benchmark.ErrTaskNotFound, \"benchmark serial not match %s, want %s\", c.Serial, bench.DiskInfo.Serial)\n\t}\n\n\t_, err = benchSm.Fire(ctx, bench.Status, benchmark.EventDeleteBench, benchmark.Data{Benchmark: bench, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := benchRepo.Delete(ctx, bench); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_logical_volume.go",
        "code_start_line": 52,
        "code_end_line": 98,
        "code_key": "Handle",
        "code_value": "func (c *CreateLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tpvRepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tlvRepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm     = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\t// 1. 查找底层物理卷\n\tc.selectedPhysicalVolume, err = pvRepo.FindBySerial(ctx, rdiskDomain.Serial(c.PhysicalVolumeSerial))\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// 检查底层物理卷大小是否满足要求\n\tif c.selectedPhysicalVolume.Size < rdiskDomain.Size(c.DiskSize) {\n\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume size %d is smaller than requested size %d\", c.selectedPhysicalVolume.Size, c.DiskSize)\n\t}\n\n\t// 检查底层物理卷性能等级是否满足要求\n\tif c.PerformanceRank != \"\" {\n\t\tif string(c.selectedPhysicalVolume.PerformanceRank) != c.PerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not match requested rank %s\", c.selectedPhysicalVolume.PerformanceRank, c.PerformanceRank)\n\t\t}\n\t} else {\n\t\tif c.selectedPhysicalVolume.PerformanceRank != rdiskDomain.DefaultPerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not default rank %s\", c.selectedPhysicalVolume.PerformanceRank, rdiskDomain.DefaultPerformanceRank)\n\t\t}\n\t}\n\n\t// 2. 创建逻辑卷\n\tvol := rdiskDomain.NewLogicalVolume(users.AppID(c.AppID), rdiskDomain.Size(c.DiskSize), rdiskDomain.ZoneID(c.ZoneID))\n\tif c.VolumeType != \"\" {\n\t\tvol.VolumeType = rdiskDomain.VolumeType(c.VolumeType)\n\t}\n\tif c.DiskType != \"\" {\n\t\tvol.DiskType = rdiskDomain.DiskType(c.DiskType)\n\t}\n\terr = lvRepo.Add(ctx, vol)\n\tif err != nil {\n\t\treturn\n\t}\n\tc.createdLogicalVolume = vol\n\n\t// 3. 触发状态机，联动更新逻辑卷和物理卷状态\n\t_, err = sm.Fire(ctx, rdiskDomain.LVSUnInited, rdiskDomain.LVECreateLogicalVolume, c)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_running_backup_task.go",
        "code_start_line": 31,
        "code_end_line": 61,
        "code_key": "Handle",
        "code_value": "func (c *UpdateRunningBackupTaskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventUpdateBackupProgress,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_drgroup.go",
        "code_start_line": 78,
        "code_end_line": 173,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeDRGroupCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tlvView  = app.GetRegistry(ctx).Viewers.LogicalVolume\n\t\tdrgRepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t\tsm      = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\terr     error\n\t)\n\n\t// 0. 初始化\n\tc.drgroupRef = make(map[string]*drgroup.DRGroup)\n\n\t// 1. 加载所有逻辑卷所在的置放群组\n\tallVolumeUUIDs := make([]string, 0, len(c.UUIDs))\n\tfor _, _uuid := range c.UUIDs {\n\t\tallVolumeUUIDs = append(allVolumeUUIDs, _uuid.String())\n\t}\n\tif groups, err := drgRepo.FindByMembers(ctx, c.AppID, allVolumeUUIDs); err == nil {\n\t\tif err != nil {\n\t\t\tif !errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tfor _, group := range groups {\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t\tc.curDRGroupNames = append(c.curDRGroupNames, group.Name)\n\t\t}\n\t} else {\n\t\treturn err\n\t}\n\n\t// 2. 确认已上锁的置放群组和当前一致\n\tif !c.checkLockedDRGroupNames() {\n\t\treturn errors.New(drgroup.ErrGroupModified, \"drgroup changed\")\n\t}\n\n\t// 3. 加载所有逻辑卷的状态，不需要完整实体，因为不会修改 Volume\n\tc.relatedLogicalVolume, err = lvView.FindByIDs(ctx, c.AppID, c.UUIDs)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(c.relatedLogicalVolume) < len(c.UUIDs) {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t// 4. 加载所有目标置放群组，key 为 name\n\tfor _, spec := range c.Specs {\n\t\tvar group *drgroup.DRGroup\n\t\tif _, ok := c.drgroupRef[spec.Name]; ok {\n\t\t\tgroup = c.drgroupRef[spec.Name]\n\t\t} else {\n\t\t\tgroup, err = c.getOrCreateDRGroup(ctx, drgRepo, spec)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t}\n\n\t\tif spec.Affinity > 0 {\n\t\t\tgroup.Affinity = spec.Affinity\n\t\t}\n\t\tif spec.Type != \"\" {\n\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t}\n\t}\n\n\t// 5. 对所有逻辑卷执行置放群组变更事件，检查状态是否允许，\n\t//    实际的更新还是在这里执行。\n\tfor _, vol := range c.relatedLogicalVolume {\n\t\terr := sm.Check(ctx, vol.State, rdiskDomain.LVEUpdateDrGroup, c)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// 将逻辑卷从原有的置放群组中移除\n\t\tfor _, name := range c.curDRGroupNames {\n\t\t\tc.drgroupRef[name].RemoveMember(vol.UUID.String())\n\t\t}\n\t\t// 将逻辑卷添加到新的置放群组中\n\t\tfor _, spec := range c.Specs {\n\t\t\tsubGroup := spec.SubGroup\n\t\t\tif subGroup == \"\" {\n\t\t\t\t// 如果没有指定子组，则使用远端 SSD UUID 作为子组名称\n\t\t\t\t// 相当于每块盘都是一个子组，相当于没有使用子组功能\n\t\t\t\tsubGroup = vol.UUID.String()\n\t\t\t}\n\t\t\tif err := c.drgroupRef[spec.Name].AddMember(vol.UUID.String(), subGroup, vol.PhysicalVolume.IP.String()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tif c.DryRun {\n\t\treturn errors.New(errors.ErrDryRunSuccessExit, \"dry run check success\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/online_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OnlinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOnlinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_benchmark_task.go",
        "code_start_line": 34,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *UpdateBenchmarkTask) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, rdisk.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark, err = benchRepo.FindByUUID(ctx, c.BenchmarkUUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventUpdateBench, benchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_flow_ctrl.go",
        "code_start_line": 80,
        "code_end_line": 103,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeFlowControlCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not found\")\n\t}\n\n\tspec := c.volume.FlowControlSpec\n\tif !c.UpdateRequest.UpdateSpec(&spec, c.volume.GetDefaultFlowControlSpec()) {\n\t\t// 没有任何更新，直接返回成功\n\t\treturn nil\n\t}\n\tc.volume.SetFlowControlSpec(spec)\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEUpdateFlowControl, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_defunct_volume.go",
        "code_start_line": 46,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *CleanupDefunctCommand) Handle(ctx context.Context) error {\n\tvar err error\n\tc.lv, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar sm = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\tvar event = rdiskDomain.LVECleanupDefunct\n\n\tfor _, attachment := range c.lv.Attachments {\n\t\tlogs.Info(ctx).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).Msg(\"cleanup defuncting volume\")\n\t\tsubCmd := &cleanDefunctSubCommand{Parent: c, HostIP: attachment.IP}\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, subCmd)\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，因为只要有一个挂载点清理失败，其他挂载点还是需要继续清理的\n\t\t\t// 失败的挂载点会在后台继续清理\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).\n\t\t\t\tMsg(\"failed to cleanup defunct volume, retry later.\")\n\t\t}\n\t}\n\n\tif len(c.lv.Attachments) == 0 {\n\t\t// 没有挂载点，直接清理\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, &cleanDefunctSubCommand{Parent: c, HostIP: net.IP{}})\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，后续自动重试即可\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Msg(\"failed to complete cleanup defunct volume\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_drgroup_exists.go",
        "code_start_line": 28,
        "code_end_line": 53,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDRGroupExistsCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t)\n\tfor _, spec := range c.DRGroup {\n\t\t_, err := repo.FindByName(ctx, users.AppID(c.AppID), spec.Name)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\tgroup := drgroup.New(spec.Name, users.AppID(c.AppID))\n\t\t\t\tif spec.Affinity > 0 {\n\t\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t\t}\n\t\t\t\tif spec.Type != \"\" {\n\t\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t\t}\n\t\t\t\terr = repo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_physical_volume.go",
        "code_start_line": 31,
        "code_end_line": 54,
        "code_key": "Handle",
        "code_value": "func (c *UpdatePhyRDiskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEUpdatePhysicalVolume, c)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/recycle_backup_data.go",
        "code_start_line": 32,
        "code_end_line": 62,
        "code_key": "Handle",
        "code_value": "func (c *RecycleBackupDataCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventDeleteBackup,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/config/config.go",
        "code_start_line": 68,
        "code_end_line": 143,
        "code_key": "LoadConfig",
        "code_value": "func LoadConfig(raw *viper.Viper) (*Config, error) {\n\tconfig := &Config{\n\t\tGlobal: &GlobalConfig{\n\t\t\tPprofPort: uint16(raw.GetInt(\"global.pprofPort\")),\n\t\t\tTestEnv:   raw.GetBool(\"global.testEnv\"),\n\t\t\tTestUin:   raw.GetString(\"global.testUin\"),\n\t\t},\n\t\tRegionPipelines: make(map[string]*regionPipelineConfig),\n\t}\n\n\t// load base databases config\n\tbaseDbConfigMap := make(map[string]configs.MySQLConfig)\n\tdatabases := raw.GetStringMap(\"databases\")\n\tfor name, database := range databases {\n\t\tdbConfig := database.(map[string]interface{})\n\t\tprops := map[string]string{\n\t\t\t\"charset\": dbConfig[\"charset\"].(string),\n\t\t}\n\t\tbaseDbConfigMap[name] = configs.MySQLConfig{\n\t\t\tName:  dbConfig[\"db\"].(string),\n\t\t\tProps: props,\n\t\t}\n\t}\n\n\t// load base mq config\n\tbaseMqConfigMap := make(map[string]interface{})\n\tmessageQueues := raw.GetStringMap(\"messageQueues\")\n\tfor name, mqConfig := range messageQueues {\n\t\tbaseMqConfigMap[name] = mqConfig\n\t}\n\n\t// load base log config\n\tbaseLogConfig := logs.Config{\n\t\tLevel:               raw.GetString(\"log.level\"),\n\t\tEnableConsoleLogger: raw.GetBool(\"log.enableConsoleLogger\"),\n\t\tEnableFileLogger:    raw.GetBool(\"log.enableFileLogger\"),\n\t\tLogFileMaxBackups:   raw.GetInt(\"log.logFileMaxBackups\"),\n\t\tLogFileMaxAge:       raw.GetInt(\"log.logFileMaxAge\"),\n\t\tLogFileMaxSize:      raw.GetInt(\"log.logFileMaxSize\"),\n\t}\n\n\t// load base task config\n\tvar tasks []map[string]interface{}\n\tbaseTaskConfigMap := make(map[string]*TaskConfig)\n\terr := raw.UnmarshalKey(\"tasks\", &tasks)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unmarshal tasks failed: %s\", err.Error())\n\t}\n\tfor _, taskRaw := range tasks {\n\t\tname, ok := taskRaw[\"name\"].(string)\n\t\tif !ok {\n\t\t\treturn nil, fmt.Errorf(\"tasks name not found\")\n\t\t}\n\t\tbaseTaskConfigMap[name] = &TaskConfig{\n\t\t\tInterval:    taskRaw[\"interval\"].(int),\n\t\t\tMaxInterval: taskRaw[strings.ToLower(\"maxInterval\")].(int),\n\t\t}\n\t}\n\n\trawRegionPipelines := raw.GetStringMap(\"regions\")\n\tfor region, _ := range rawRegionPipelines {\n\t\trawRegionConfig := raw.Sub(fmt.Sprintf(\"regions.%s\", region))\n\t\tregionConfig, err := loadRegionConfig(rawRegionConfig, baseTaskConfigMap, baseDbConfigMap, baseMqConfigMap, baseLogConfig)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tconfig.RegionPipelines[region] = regionConfig\n\t}\n\n\t// load main log config\n\tbaseLogConfig.LogFileDir = raw.GetString(\"log.logFileDir\")\n\t//baseLogConfig.LogFileName = raw.GetString(\"log.logFileName\")\n\tconfig.MainLogConfig = &baseLogConfig\n\n\treturn config, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/configs/loader.go",
        "code_start_line": 12,
        "code_end_line": 20,
        "code_key": "LoadConfig",
        "code_value": "func LoadConfig(path string, receiver interface{}) error {\n\tviperIns := viper.New()\n\tviperIns.SetConfigFile(path)\n\n\tif err := viperIns.ReadInConfig(); err != nil {\n\t\treturn err\n\t}\n\treturn viperIns.Unmarshal(receiver)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/convertor.go",
        "code_start_line": 28,
        "code_end_line": 38,
        "code_key": "Start",
        "code_value": "func (a *Convertor) Start(ctx context.Context) error {\n\t// 启动转换器\n\tfor _, scanner := range a.scanners {\n\t\tscanner := scanner\n\t\tgo func() {\n\t\t\ta.convertToTask(ctx, scanner)\n\t\t}()\n\t}\n\tlogs.Info(ctx).Msgf(\"Convertor Start Success\")\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_rec_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *CbsMeasureReconciliationTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\t//s.resultChan <- struct{}{}\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_rec_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 35,
        "code_key": "Start",
        "code_value": "func (s *SnapMeasureReconciliationTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_compute_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *SnapComputeTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\t//s.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_measure_send_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *CbsMeasureSendTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_bill_valid_appId_fetch_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *CbsValidAppIdFetchTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_calculate_cost_locally_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 36,
        "code_key": "Start",
        "code_value": "func (s *SnapCalculateCostLocallyTaskScanner) Start(ctx context.Context) error {\n\t//s.resultChan <- struct{}{}\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_create_task_scanner.go",
        "code_start_line": 23,
        "code_end_line": 42,
        "code_key": "Start",
        "code_value": "func (s *UpdateCreateTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\trunning := true\n\t\tfor running {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\trunning = false\n\t\t\tdefault:\n\t\t\t\terr := s.FullScan(ctx)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogs.Fatal(ctx).Msgf(\"%s full scan failed!\\n\", s.name)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\ttime.Sleep(s.scanInterval)\n\t\t}\n\t}()\n\tlogs.Info(ctx).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_measure_send_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 36,
        "code_key": "Start",
        "code_value": "func (s *SnapMeasureSendTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\t//s.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/repush_user_billing_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 39,
        "code_key": "Start",
        "code_value": "func (s *RepushUserBillingTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_rollback_task_scanner.go",
        "code_start_line": 23,
        "code_end_line": 42,
        "code_key": "Start",
        "code_value": "func (s *UpdateRollbackTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\trunning := true\n\t\tfor running {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\trunning = false\n\t\t\tdefault:\n\t\t\t\terr := s.FullScan(ctx)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogs.Fatal(ctx).Msgf(\"%s full scan failed!\\n\", s.name)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\ttime.Sleep(s.scanInterval)\n\t\t}\n\t}()\n\tlogs.Info(ctx).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_valid_appId_fetch_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 36,
        "code_key": "Start",
        "code_value": "func (s *SnapValidAppIdFetchTaskScanner) Start(ctx context.Context) error {\n\t//s.resultChan <- struct{}{}\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_bill_compute_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 39,
        "code_key": "Start",
        "code_value": "func (s *CbsBillComputeTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/app/app.go",
        "code_start_line": 31,
        "code_end_line": 39,
        "code_key": "Start",
        "code_value": "func (m *PipelineManager) Start(ctx context.Context) error {\n\tfor region, pipeline := range m.Pipelines {\n\t\tregionCtx := context.WithValue(ctx, \"region\", region)\n\t\tif err := pipeline.Start(regionCtx); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/app/app.go",
        "code_start_line": 46,
        "code_end_line": 51,
        "code_key": "Start",
        "code_value": "func (app *NebulaApp) Start(ctx context.Context) error {\n\tif err := app.pipelineManager.Start(ctx); err != nil {\n\t\treturn err\n\t}\n\treturn <-app.stopChan\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/app/pipeline.go",
        "code_start_line": 20,
        "code_end_line": 46,
        "code_key": "Start",
        "code_value": "func (p *RegionPipeline) Start(ctx context.Context) error {\n\tregion := ctx.Value(\"region\").(string)\n\tscannerLogCtx := initLogger(ctx, region, \"scanner.log\")\n\tfor _, scanner := range p.scanners {\n\t\tsingleCtx := logs.AddDefaultMessage(scannerLogCtx, \"name\", scanner.GetName())\n\t\terr := scanner.Start(singleCtx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tinitMetric(scanner, region, \"scanner\", scanner.GetName())\n\t}\n\n\tconvertorLogCtx := initLogger(ctx, region, \"convertor.log\")\n\terr := p.convertor.Start(convertorLogCtx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// start scheduler\n\tschedulerLogCtx := initLogger(ctx, region, \"scheduler.log\")\n\terr = p.scheduler.Start(schedulerLogCtx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tinitMetric(p.scheduler, region, \"scheduler\", \"scheduler\")\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go",
        "code_start_line": 109,
        "code_end_line": 112,
        "code_key": "Start",
        "code_value": "func (sc *Scheduler) Start(ctx context.Context) error {\n\tgo sc.mainLoop(ctx)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/scheduler.go",
        "code_start_line": 154,
        "code_end_line": 191,
        "code_key": "Start",
        "code_value": "func (s *scheduler) Start(ctx context.Context) error {\n\twg := sync.WaitGroup{}\n\trunning := true\n\tgo s.haManager.Start(ctx)\n\tdefer s.haManager.Close(ctx)\n\tfor {\n\t\tselect {\n\t\tcase taskName := <-s.eventChan:\n\t\t\twg.Add(1)\n\t\t\tgo func(name string) {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tif task, ok := s.loads[name]; ok {\n\n\t\t\t\t\tif s.isMaster {\n\t\t\t\t\t\t_ctx := logs.With(ctx).Str(\"seqId\", uuid.New().String()).Str(\"taskName\", name).Logger().WithContext(ctx)\n\t\t\t\t\t\ttask.Work(_ctx)\n\t\t\t\t\t}\n\n\t\t\t\t\ttriggerTime := time.Now().Add(task.Interval())\n\t\t\t\t\tfor {\n\t\t\t\t\t\tif !running {\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif time.Now().After(triggerTime) {\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttime.Sleep(time.Second)\n\t\t\t\t\t}\n\t\t\t\t\ts.eventChan <- name\n\t\t\t\t}\n\t\t\t}(taskName)\n\t\tcase <-s.stopChan:\n\t\t\trunning = false\n\t\t\twg.Wait()\n\t\t\treturn nil\n\t\t}\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/easyha/model.go",
        "code_start_line": 108,
        "code_end_line": 180,
        "code_key": "Start",
        "code_value": "func (m *haManagerImpl) Start(ctx context.Context) {\n\tm.keepRunning = true\n\tm.ctx = ctx\n\tvar (\n\t\tmyIdentity            = m.delegate.GetIdentity()                                    // 当前节点的业务标识\n\t\tmyKey                 = fmt.Sprintf(\"easyhaMaster/%s\", url.PathEscape(m.namespace)) // 分布式锁的key\n\t\tmyToken               = m.encodeToken(myIdentity)                                   // 分布式锁 Token，包含业务标识和随机信息\n\t\tmyLock                dlock.Lock                                                    // 获取到的分布式锁, 用于刷新和释放\n\t\tcurrentMasterIdentity string                                                        // 当前 master 的业务标识，如果为空则是还未获取过当前 master\n\t)\n\n\t// Start slave loop.\n\tfor m.keepRunning {\n\t\t// Try observe the master lock first.\n\t\tif view, err := m.locker.Observe(ctx, myKey); err != nil {\n\t\t\tm.logger.Info().Err(err).Str(\"key\", myKey).Msg(\"failed to observe current master lock\")\n\t\t\t// Failed to observe the master lock, try to  obtain the lock.\n\t\t\tmyLock, err = m.locker.Obtain(ctx, dlock.NewWriteLockKey(myKey), m.lockExpired, &dlock.Option{Token: myToken})\n\t\t\tif err == nil {\n\t\t\t\t// Successfully obtained the lock.\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tnewIdentity, err := m.decodeToken(view.Token)\n\t\t\tif err != nil {\n\t\t\t\tm.logger.Warn().Err(err).Str(\"token\", view.Token).Msg(\"failed to decode token\")\n\t\t\t} else if currentMasterIdentity == \"\" {\n\t\t\t\t// First time to observe the master.\n\t\t\t\tcurrentMasterIdentity = newIdentity\n\t\t\t\tif err := m.delegate.OnBecomeSlave(ctx, currentMasterIdentity); err != nil {\n\t\t\t\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle become slave, force quit for safety\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if currentMasterIdentity != newIdentity {\n\t\t\t\t// Master changed. Need update.\n\t\t\t\tcurrentMasterIdentity = newIdentity\n\t\t\t\tif err := m.delegate.OnSwitchMaster(ctx, currentMasterIdentity); err != nil {\n\t\t\t\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle switch master, force quit for safety\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttime.Sleep(m.checkInterval)\n\t}\n\n\tif myLock == nil {\n\t\tm.logger.Fatal().Msg(\"myLock is nil, found bug, force quit for safety\")\n\t\treturn\n\t}\n\n\t// I am the master now.\n\tif err := m.delegate.OnBecomeMaster(ctx); err != nil {\n\t\tmyLock.Release(ctx)\n\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle become master, force quit for safety\")\n\t\treturn\n\t}\n\n\tdefer func() {\n\t\tmyLock.Release(ctx)\n\t\tif err := m.delegate.OnLostMaster(ctx); err != nil {\n\t\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle lost master, force quit for safety\")\n\t\t}\n\t}()\n\n\t// Start the master loop.\n\tfor m.keepRunning {\n\t\ttime.Sleep(m.checkInterval)\n\t\tif err := myLock.Refresh(ctx, m.lockExpired); err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/base_measure/utils.go",
        "code_start_line": 48,
        "code_end_line": 55,
        "code_key": "GenerateUuid",
        "code_value": "func GenerateUuid(originString string) string {\n\tgenHash := md5.New()\n\tgenHash.Write([]byte(originString))\n\thash := hex.EncodeToString(genHash.Sum(nil))\n\n\tgeneratedUUID := uuid.NewSHA1(uuid.Nil, []byte(hash))\n\treturn generatedUUID.String()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/app/app.go",
        "code_start_line": 78,
        "code_end_line": 129,
        "code_key": "initRegionPipelines",
        "code_value": "func initRegionPipelines(ctx context.Context, app *NebulaApp) error {\n\tconfig := registry.GlobalRegistry.AppConfig\n\tif len(config.RegionPipelines) == 0 {\n\t\treturn fmt.Errorf(\"region pipeline not found\")\n\t}\n\n\tfor region, cfg := range config.RegionPipelines {\n\t\tregionPipe := NewRegionPipeline()\n\t\t// init db\n\t\tinitDatabases(ctx, region, cfg.Databases)\n\n\t\t// init mq\n\t\tinitMessageQueues(ctx, cfg.MessageQueues)\n\n\t\t// init cache 默认30s过期，每隔1min清理过期的内容\n\t\terr := registry.GlobalRegistry.RegistryCache(region, cache.New(time.Second*30, time.Minute))\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\n\t\t// init scheduler\n\t\tschedulerConfig := cfg.Scheduler\n\t\tsc := scheduler.NewScheduler(schedulerConfig.MaxWorkerNum)\n\n\t\t// init convertor\n\t\tscannersConfig := cfg.Scanners\n\t\tconvertor := core.NewConvertor(len(scannersConfig))\n\t\tconvertor.AddScheduler(ctx, sc)\n\n\t\tscanners := make(map[string]scInterfaces.Scanner, len(scannersConfig))\n\t\tlogs.Info(ctx).Msgf(\"Initializing Scanners, Total Nums: %d\", len(scannersConfig))\n\t\tfor _, conf := range scannersConfig {\n\t\t\tfactory, ok := registry.GlobalRegistry.ScannerFactories[conf.Name]\n\t\t\tif !ok {\n\t\t\t\treturn fmt.Errorf(\"failed to get scanner factory: %s\", conf.Name)\n\t\t\t}\n\t\t\tscanner, err := factory(conf.Data)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to init scan adapter: %s \", err.Error())\n\t\t\t}\n\t\t\tscanners[conf.Name] = scanner\n\t\t\tconvertor.AddScanner(ctx, scanner)\n\t\t\tlogs.Info(ctx).Msgf(\"%s Scanner Initialize Success\", conf.Name)\n\t\t}\n\t\tregionPipe.convertor = convertor\n\t\tregionPipe.scanners = scanners\n\t\tregionPipe.scheduler = sc\n\t\tapp.pipelineManager.Pipelines[region] = regionPipe\n\t\tlogs.Info(ctx).Msgf(\"%s region initialize success\", region)\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/client/client.go",
        "code_start_line": 20,
        "code_end_line": 62,
        "code_key": "Request",
        "code_value": "func (c *BaseClient) Request(ctx context.Context, interfaceName string, reqJsonData []byte) ([]byte, error) {\n\tlogger := logs.With(ctx).Str(\"interface\", interfaceName).Logger()\n\tlogger.Info().Str(\"para\", string(reqJsonData)).Msg(\"NEW_REQUEST\")\n\n\tctx, cancel := context.WithTimeout(ctx, time.Second*time.Duration(c.Timeout))\n\tdefer cancel()\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPost, c.Url, bytes.NewReader(reqJsonData))\n\n\tif global.TestEnv {\n\t\treq.Header.Add(\"X-QCloud-Transaction-ID\", uuid.New().String())\n\t\treq.Header.Add(\"X-QCloud-User-ID\", global.TestUin)\n\t}\n\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"new request failed: %v\", err)\n\t}\n\theader := \"\"\n\tfor key, value := range req.Header {\n\t\theader += fmt.Sprintf(\"-H \\\"%s: %s\\\" \", key, value[0])\n\t}\n\tcurl := fmt.Sprintf(\"curl %s --connect-timeout %d -d '%s' %s\", header, c.Timeout, string(reqJsonData), c.Url)\n\tlogger.Info().Any(\"cmd\", curl).Msgf(\"SHOW_CURL_CMD\")\n\n\trsp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\tlogger.Error().Err(err).Msgf(\"RESPONSE_ERR\")\n\t\treturn nil, fmt.Errorf(\"do request failed: %v\", err)\n\t}\n\tdefer func(Body io.ReadCloser) {\n\t\t_ = Body.Close()\n\t}(rsp.Body)\n\n\tif rsp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"unexpected status code: %d\", rsp.StatusCode)\n\t}\n\tbodyData, err := io.ReadAll(rsp.Body)\n\tlogger.Info().Any(\"response\", string(bodyData)).Msgf(\"SHOW_RESPONSE\")\n\tif err != nil {\n\t\tlogger.Error().Err(err).Msgf(\"RESPONSE_ERR\")\n\t\treturn nil, err\n\t}\n\treturn bodyData, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/client/cgw/client.go",
        "code_start_line": 32,
        "code_end_line": 57,
        "code_key": "request",
        "code_value": "func (c *cgwClient) request(ctx context.Context, interfaceName string, para interface{}, data interface{}) error {\n\tjsonData, err := json.Marshal(cgwRequest{\n\t\tVersion:       \"1.0\",\n\t\tComponentName: \"go_scheduler\",\n\t\tCaller:        \"go_scheduler\",\n\t\tInterface: InterfaceInfo{\n\t\t\tInterfaceName: interfaceName,\n\t\t\tPara:          para,\n\t\t},\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tresponse := cgwResponse{}\n\tresponse.Data = data\n\n\tbodyData, err := c.BaseClient.Request(ctx, interfaceName, jsonData)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = json.Unmarshal(bodyData, &response)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/client/oss/client.go",
        "code_start_line": 43,
        "code_end_line": 86,
        "code_key": "request",
        "code_value": "func (c *ossClient) request(ctx context.Context, interfaceName string, para interface{}, data interface{}) error {\n\trandomUuid := uuid.New().String()\n\trequestInfo := map[string]string{\n\t\t\"requestKey\":    \"sng\",\n\t\t\"requestModule\": \"scheduler\",\n\t\t\"operator\":      \"scheduler\",\n\t}\n\tjsonData, err := json.Marshal(ossRequest{\n\t\tSeqId: randomUuid,\n\t\tParams: params{\n\t\t\tContent: ossContent{\n\t\t\t\tType:        \"Json\",\n\t\t\t\tVersion:     \"1.0\",\n\t\t\t\tRequestInfo: requestInfo,\n\t\t\t\tRequestItem: requestItem{\n\t\t\t\t\tMethod: interfaceName,\n\t\t\t\t\tData:   para,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tresponse := ossResponse{}\n\tresponse.Data = data\n\n\t// 修改url，带上cgi后缀\n\tc.BaseClient.Url = fmt.Sprintf(\"%s%s.cgi\", c.Url, interfaceName)\n\tbodyData, err := c.BaseClient.Request(ctx, interfaceName, jsonData)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = json.Unmarshal(bodyData, &response)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif response.Code != 0 {\n\t\treturn fmt.Errorf(response.Message)\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/client/cbsV3/client.go",
        "code_start_line": 33,
        "code_end_line": 57,
        "code_key": "request",
        "code_value": "func (c *cbsV3Client) request(ctx context.Context, interfaceName string, para interface{}, data interface{}) error {\n\trandomUuid := uuid.New().String()\n\tbaseReq := cbsV3Request{\n\t\tAction:        interfaceName,\n\t\tVersion:       \"1.0\",\n\t\tApiModule:     \"go_scheduler\",\n\t\tRequestSource: \"go_scheduler\",\n\t\tRequestId:     randomUuid,\n\t}\n\tjsonData, err := client.MergeInterface(baseReq, para)\n\tif err != nil {\n\t\treturn err\n\t}\n\tresponse := cbsV3Response{}\n\tresponse.Response = data\n\tbodyData, err := c.BaseClient.Request(ctx, interfaceName, jsonData)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = json.Unmarshal(bodyData, &response)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/clients/cbs_blk_flow_agent/api.go",
        "code_start_line": 172,
        "code_end_line": 217,
        "code_key": "request",
        "code_value": "func (c *client) request(ctx context.Context, cmd string, param, data interface{}) error {\n\tlogger := logs.With(ctx).Str(\"cmd\", cmd).Str(\"host_ip\", c.hostIp).Logger()\n\tlogger.Info().Interface(\"req\", param).Msg(\"REQUEST_BLK_AGENT\")\n\trandomUuid := uuid.New().String()\n\tjsonData, err := json.Marshal(blockAgentRequest{\n\t\tUsername: \"cbs\",\n\t\tSeqID:    randomUuid,\n\t\tCommand:  cmd,\n\t\tSpanID:   \"rdisk_master\",\n\t\tPassword: \"cbs@2020\", // NOCA:PasswordLeak(误报)\n\t\tData:     param,\n\t})\n\tif err != nil {\n\t\treturn errors.Newf(ErrEncodeRequest, \"marshal request body failed: %v\", err)\n\t}\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPost, c.url, bytes.NewReader(jsonData))\n\tif err != nil {\n\t\treturn errors.Newf(ErrRequest, \"new request failed: %v\", err)\n\t}\n\trsp, err := http.DefaultClient.Do(req) //nolint:bodyclose // 误报\n\tif err != nil {\n\t\treturn errors.Newf(ErrRequest, \"do request failed: %v\", err)\n\t}\n\tdefer func(body io.ReadCloser) {\n\t\t_ = body.Close()\n\t}(rsp.Body)\n\n\tif rsp.StatusCode != http.StatusOK {\n\t\treturn errors.Newf(ErrRequest, \"unexpected status code: %d\", rsp.StatusCode)\n\t}\n\tresponse := blockAgentResponse{}\n\tresponse.Data = data\n\tbodyData, err := io.ReadAll(rsp.Body)\n\tif err != nil {\n\t\tlogger.Error().Err(err).Msgf(\"RESPONSE_FROM_BLK_AGENT_READ_ERR\")\n\t\treturn errors.Newf(ErrReadResponse, \"%v\", err)\n\t}\n\n\terr = json.Unmarshal(bodyData, &response)\n\tif err != nil {\n\t\tlogger.Error().Bytes(\"result\", bodyData).Err(err).Msgf(\"RESPONSE_FROM_BLK_AGENT_DECODE_ERR\")\n\t\treturn errors.Newf(ErrDecodeResponse, \"decode response failed: %v\", err)\n\t}\n\tlogger.Info().Any(\"response\", response).Msgf(\"RESPONSE_FROM_BLK_AGENT\")\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/clients/trade_client/utils.go",
        "code_start_line": 33,
        "code_end_line": 37,
        "code_key": "hmacsha256",
        "code_value": "func hmacsha256(s, key string) string {\n\thashed := hmac.New(sha256.New, []byte(key))\n\thashed.Write([]byte(s))\n\treturn string(hashed.Sum(nil))\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/clients/cos/client.go",
        "code_start_line": 33,
        "code_end_line": 64,
        "code_key": "New",
        "code_value": "func New(cfg Config) Client {\n\tvar (\n\t\t//region = \"ap-guangzhou\"\n\t\tdomain = cfg.Domain\n\t)\n\n\tif domain == \"\" {\n\t\tif cfg.Region != \"\" {\n\t\t\tregion := cfg.Region\n\t\t\tdomain = \"cos.\" + region + \".myqcloud.com\"\n\t\t} else {\n\t\t\tdomain = \"cos.ap-guangzhou.myqcloud.com\"\n\t\t}\n\t}\n\n\tu, _ := url.Parse(fmt.Sprintf(\"https://%s.%s\", cfg.Bucket, domain))\n\tb := &cos.BaseURL{BucketURL: u}\n\t// 获取签名客户端。\n\ttransport := &cos.AuthorizationTransport{\n\t\tSecretID:  cfg.SecretID,\n\t\tSecretKey: cfg.SecretKey,\n\t}\n\t// 如果使用临时密钥，可以将 Token 字段赋值为临时密钥的 Token 值。\n\tif cfg.Token != \"\" {\n\t\ttransport.SessionToken = cfg.Token\n\t}\n\tc := cos.NewClient(b, &http.Client{\n\t\tTransport: transport,\n\t})\n\n\treturn &clientImpl{c: c}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/clients/cbs_blk_flow_agent/api.go",
        "code_start_line": 337,
        "code_end_line": 345,
        "code_key": "New",
        "code_value": "func New(hostIp string, opts ...BlockAgentOptions) Interface {\n\t// 默认端口号为 24500\n\tdefaultPort := 24500\n\tclient := &client{hostIp: hostIp, url: fmt.Sprintf(\"http://%s:%d\", hostIp, defaultPort), RetryPolicy: DefaultRetryPolicy}\n\tfor _, opt := range opts {\n\t\topt(client)\n\t}\n\treturn client\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/errors/errors.go",
        "code_start_line": 71,
        "code_end_line": 73,
        "code_key": "New",
        "code_value": "func New(code int, text string) error {\n\treturn errs.New(code, text)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/scheduler.go",
        "code_start_line": 101,
        "code_end_line": 111,
        "code_key": "New",
        "code_value": "func New(ctx context.Context, locker dlock.Locker) Scheduler {\n\ts := &scheduler{\n\t\tbaseCtx:   ctx,\n\t\tloads:     make(map[string]WorkLoad),\n\t\tstopChan:  make(chan struct{}, defaultBufferSize),\n\t\teventChan: make(chan string, defaultBufferSize),\n\t\tlocker:    locker,\n\t}\n\ts.newHAManager(ctx)\n\treturn s\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 833,
        "code_end_line": 841,
        "code_key": "New",
        "code_value": "func New(baseCtx context.Context) *server.Server {\n\timpl := &masterApiServerImpl{}\n\tfilter.Register(\"initContext\", newInitContextFilter(baseCtx), newInitContextClientFilter(baseCtx))\n\tfilter.Register(\"logRequest\", logRequestFilter, logRequestClientFilter)\n\tinitCustomErrorHandler()\n\ts := trpc.NewServer(serverOpts()...)\n\tpb.RegisterMasterService(s.Service(\"trpc.rdisk.master.Master\"), impl)\n\treturn s\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/uow.go",
        "code_start_line": 96,
        "code_end_line": 106,
        "code_key": "New",
        "code_value": "func (u unitOfWorkFactoryImpl) New() dddcore.UnitOfWork {\n\tuow := &unitOfWork{\n\t\ttx:                    u.db.Begin(),\n\t\ttrackedPhyVolumes:     newTracker[*rdiskDomain.PhysicalVolume](updatePhysicalVolume),\n\t\ttrackedLogicalVolumes: newTracker[*rdiskDomain.LogicalVolume](updateLogicalVolume),\n\t\ttrackedDRGroups:       newTracker[*drgroup.DRGroup](updateDRGroup),\n\t\ttrackedBackups:        newTracker[*backup.Backup](updateBackup),\n\t\ttrackedBenchmarks:     newTracker[*benchmark.Benchmark](updateBenchmark),\n\t}\n\treturn uow\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/benchmark/benchmark.go",
        "code_start_line": 114,
        "code_end_line": 122,
        "code_key": "New",
        "code_value": "func New(disk DiskInfo) *Benchmark {\n\tb := &Benchmark{}\n\tb.DiskInfo = disk\n\tb.UUID = uuid.New()\n\tb.Status = StatusInited\n\tb.Created = time.Now()\n\tb.Finished = time.Now()\n\treturn b\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/models.go",
        "code_start_line": 265,
        "code_end_line": 278,
        "code_key": "New",
        "code_value": "func New(name string, appID users.AppID) *DRGroup {\n\tif name == \"\" {\n\t\tname = DefaultName\n\t}\n\treturn &DRGroup{\n\t\tName:         name,\n\t\tAppID:        appID,\n\t\tType:         DefaultType,\n\t\tAffinity:     DefaultAffinity,\n\t\tsubGroups:    make(map[string]*SubGroup),\n\t\tlocationsMap: make(map[string][]*SubGroup),\n\t\tmembersMap:   make(map[string]*SubGroup),\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/backup/models.go",
        "code_start_line": 137,
        "code_end_line": 142,
        "code_key": "New",
        "code_value": "func New(appId users.AppID, diskInfo DiskInfo) *Backup {\n\tif defaultFactory == nil {\n\t\tpanic(\"defaultFactory is nil\")\n\t}\n\treturn defaultFactory.Create(appId, diskInfo)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/easyha/model.go",
        "code_start_line": 209,
        "code_end_line": 225,
        "code_key": "New",
        "code_value": "func New(delegate Delegate, locker dlock.Locker, opts ...Option) HAManager {\n\tm := &haManagerImpl{\n\t\tctx:           context.Background(),\n\t\tdelegate:      delegate,\n\t\tcheckInterval: 5 * time.Second,\n\t\tlockExpired:   10 * time.Second,\n\t\tnamespace:     \"easyha\",\n\t\tlocker:        locker,\n\t\tlogger:        *zerolog.Ctx(context.Background()),\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(m)\n\t}\n\n\treturn m\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 47,
        "code_end_line": 59,
        "code_key": "New",
        "code_value": "func New(db *gorm.DB, conf Config) *mysqlLocker {\n\tlocker := &mysqlLocker{\n\t\tdb:              db,\n\t\ttableName:       conf.TableName,\n\t\tlockColumn:      conf.LockColumn,\n\t\texpireColumn:    conf.ExpireColumn,\n\t\ttokenColumn:     conf.TokenColumn,\n\t\tlockTypeColumn:  conf.LockTypeColumn,\n\t\tlockNumsColumn:  conf.LockNumsColumn,\n\t\treadKeysMemLock: make(map[string]*readKeysMemLock),\n\t}\n\treturn locker\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mem/memdlock.go",
        "code_start_line": 283,
        "code_end_line": 287,
        "code_key": "New",
        "code_value": "func New() dlock.Locker {\n\treturn &memLocker{\n\t\tdata: make(map[string]*lockItem),\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/logs/log.go",
        "code_start_line": 42,
        "code_end_line": 71,
        "code_key": "InitLogWith",
        "code_value": "func InitLogWith(ctx context.Context, config *Config) context.Context {\n\t// 设置日志输出\n\tvar writers []io.Writer\n\tif config.EnableConsoleLogger {\n\t\twriters = append(writers, zerolog.ConsoleWriter{Out: os.Stderr})\n\t}\n\tif config.EnableFileLogger {\n\t\twriters = append(writers, newRollingFileWriter(config))\n\t}\n\tzerolog.DurationFieldUnit = time.Second\n\tlogger := zerolog.New(io.MultiWriter(writers...)).With().Timestamp().Caller().Logger()\n\tzerolog.ErrorStackMarshaler = pkgerrors.MarshalStack\n\tzerolog.CallerMarshalFunc = Lshortfile\n\n\t// 设置日志级别\n\tswitch config.Level {\n\tcase \"debug\":\n\t\tlogger.Level(zerolog.DebugLevel)\n\tcase \"info\":\n\t\tlogger.Level(zerolog.InfoLevel)\n\tcase \"warn\":\n\t\tlogger.Level(zerolog.WarnLevel)\n\tcase \"error\":\n\t\tlogger.Level(zerolog.ErrorLevel)\n\tcase \"fatal\":\n\t\tlogger.Level(zerolog.FatalLevel)\n\t}\n\n\treturn logger.WithContext(ctx)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cmdb/cmdb_mock.go",
        "code_start_line": 39,
        "code_end_line": 45,
        "code_key": "DescribeServerDetail",
        "code_value": "func (m *MockApiService) DescribeServerDetail(ctx context.Context, req *DescribeServerDetailRequest) (*DescribeServerDetailResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"DescribeServerDetail\", ctx, req)\n\tret0, _ := ret[0].(*DescribeServerDetailResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cmdb/cmdb_mock.go",
        "code_start_line": 48,
        "code_end_line": 51,
        "code_key": "DescribeServerDetail",
        "code_value": "func (mr *MockApiServiceMockRecorder) DescribeServerDetail(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DescribeServerDetail\", reflect.TypeOf((*MockApiService)(nil).DescribeServerDetail), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cmdb/cmdb_mock.go",
        "code_start_line": 77,
        "code_end_line": 87,
        "code_key": "DescribeServerDetail",
        "code_value": "func (m *MockApiClientProxy) DescribeServerDetail(ctx context.Context, req *DescribeServerDetailRequest, opts ...client.Option) (*DescribeServerDetailResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"DescribeServerDetail\", varargs...)\n\tret0, _ := ret[0].(*DescribeServerDetailResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cmdb/cmdb_mock.go",
        "code_start_line": 90,
        "code_end_line": 94,
        "code_key": "DescribeServerDetail",
        "code_value": "func (mr *MockApiClientProxyMockRecorder) DescribeServerDetail(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DescribeServerDetail\", reflect.TypeOf((*MockApiClientProxy)(nil).DescribeServerDetail), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cmdb/cmdb.trpc.go",
        "code_start_line": 66,
        "code_end_line": 68,
        "code_key": "DescribeServerDetail",
        "code_value": "func (s *UnimplementedApi) DescribeServerDetail(ctx context.Context, req *DescribeServerDetailRequest) (*DescribeServerDetailResponse, error) {\n\treturn nil, errors.New(\"rpc DescribeServerDetail of services Api is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/cmdb/cmdb.trpc.go",
        "code_start_line": 90,
        "code_end_line": 108,
        "code_key": "DescribeServerDetail",
        "code_value": "func (c *ApiClientProxyImpl) DescribeServerDetail(ctx context.Context, req *DescribeServerDetailRequest, opts ...client.Option) (*DescribeServerDetailResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.tencent.cloud.cmdb.Api/DescribeServerDetail\")\n\tmsg.WithCalleeServiceName(ApiServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"\")\n\tmsg.WithCalleeServer(\"\")\n\tmsg.WithCalleeService(\"Api\")\n\tmsg.WithCalleeMethod(\"DescribeServerDetail\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &DescribeServerDetailResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 644,
        "code_end_line": 646,
        "code_key": "CreateRDiskVol",
        "code_value": "func (s *UnimplementedMaster) CreateRDiskVol(ctx context.Context, req *CreateRDiskVolRequest) (*CreateRDiskVolResponse, error) {\n\treturn nil, errors.New(\"rpc CreateRDiskVol of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 837,
        "code_end_line": 855,
        "code_key": "CreateRDiskVol",
        "code_value": "func (c *MasterClientProxyImpl) CreateRDiskVol(ctx context.Context, req *CreateRDiskVolRequest, opts ...client.Option) (*CreateRDiskVolResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/CreateRDiskVol\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"CreateRDiskVol\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &CreateRDiskVolResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 174,
        "code_end_line": 180,
        "code_key": "CreateRDiskVol",
        "code_value": "func (m *MockMasterService) CreateRDiskVol(ctx context.Context, req *CreateRDiskVolRequest) (*CreateRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CreateRDiskVol\", ctx, req)\n\tret0, _ := ret[0].(*CreateRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 183,
        "code_end_line": 186,
        "code_key": "CreateRDiskVol",
        "code_value": "func (mr *MockMasterServiceMockRecorder) CreateRDiskVol(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateRDiskVol\", reflect.TypeOf((*MockMasterService)(nil).CreateRDiskVol), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 617,
        "code_end_line": 627,
        "code_key": "CreateRDiskVol",
        "code_value": "func (m *MockMasterClientProxy) CreateRDiskVol(ctx context.Context, req *CreateRDiskVolRequest, opts ...client.Option) (*CreateRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"CreateRDiskVol\", varargs...)\n\tret0, _ := ret[0].(*CreateRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 630,
        "code_end_line": 634,
        "code_key": "CreateRDiskVol",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) CreateRDiskVol(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateRDiskVol\", reflect.TypeOf((*MockMasterClientProxy)(nil).CreateRDiskVol), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 184,
        "code_end_line": 235,
        "code_key": "CreateRDiskVol",
        "code_value": "func (s *masterApiServerImpl) CreateRDiskVol(ctx context.Context, req *pb.CreateRDiskVolRequest) (*pb.CreateRDiskVolResponse, error) {\n\tvar (\n\t\terr           error\n\t\tresponse      *pb.CreateRDiskVolResponse\n\t\tcreateCmd     *commands.CreateLogicalVolumeCommand\n\t\tconfirmCmd    *commands.ConfirmDRGroupExistsCommand\n\t\tcreatedVolume *rdiskDomain.LogicalVolume\n\t\tpvViewer      = app.GetRegistry(ctx).Viewers.PhysicalVolume\n\t)\n\n\tconfirmCmd = &commands.ConfirmDRGroupExistsCommand{\n\t\tAppID:   int64(req.AppId),\n\t\tDRGroup: functools.MapTo(req.AffinitySpec, functools.MapRef(make([]drgroup.Spec, len(req.AffinitySpec))), parseAffinitySpec),\n\t}\n\terr = app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, confirmCmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tselectedPhysicalVolume, err := pvViewer.QueryBySerial(ctx, []string{req.PhyId})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(selectedPhysicalVolume) == 0 {\n\t\treturn nil, errs.New(errors.ErrInvalidArgument, \"physical volume not found\")\n\t}\n\n\tcreateCmd = &commands.CreateLogicalVolumeCommand{\n\t\tAppID:                  int64(req.AppId),\n\t\tPhysicalVolumeSerial:   req.PhyId,\n\t\tZoneID:                 req.ZoneId,\n\t\tVolumeType:             req.VolumeType,\n\t\tDiskSize:               req.DiskSize,\n\t\tDiskType:               req.DiskType,\n\t\tDRGroup:                functools.MapTo(req.AffinitySpec, functools.MapRef(make([]drgroup.Spec, len(req.AffinitySpec))), parseAffinitySpec),\n\t\tSelectedPhysicalVolume: selectedPhysicalVolume[0],\n\t\tPerformanceRank:        req.PerformanceRank,\n\t}\n\n\terr = app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, createCmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcreatedVolume = createCmd.GetLogicalVolume()\n\tresponse = &pb.CreateRDiskVolResponse{\n\t\tDisk: encodeLogicalVolume(createdVolume, &pb.RDisk{}),\n\t}\n\n\treturn response, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 649,
        "code_end_line": 651,
        "code_key": "QueryRDiskVol",
        "code_value": "func (s *UnimplementedMaster) QueryRDiskVol(ctx context.Context, req *QueryRDiskVolRequest) (*QueryRDiskVolResponse, error) {\n\treturn nil, errors.New(\"rpc QueryRDiskVol of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 857,
        "code_end_line": 875,
        "code_key": "QueryRDiskVol",
        "code_value": "func (c *MasterClientProxyImpl) QueryRDiskVol(ctx context.Context, req *QueryRDiskVolRequest, opts ...client.Option) (*QueryRDiskVolResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/QueryRDiskVol\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"QueryRDiskVol\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &QueryRDiskVolResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 354,
        "code_end_line": 360,
        "code_key": "QueryRDiskVol",
        "code_value": "func (m *MockMasterService) QueryRDiskVol(ctx context.Context, req *QueryRDiskVolRequest) (*QueryRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"QueryRDiskVol\", ctx, req)\n\tret0, _ := ret[0].(*QueryRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 363,
        "code_end_line": 366,
        "code_key": "QueryRDiskVol",
        "code_value": "func (mr *MockMasterServiceMockRecorder) QueryRDiskVol(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryRDiskVol\", reflect.TypeOf((*MockMasterService)(nil).QueryRDiskVol), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 857,
        "code_end_line": 867,
        "code_key": "QueryRDiskVol",
        "code_value": "func (m *MockMasterClientProxy) QueryRDiskVol(ctx context.Context, req *QueryRDiskVolRequest, opts ...client.Option) (*QueryRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"QueryRDiskVol\", varargs...)\n\tret0, _ := ret[0].(*QueryRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 870,
        "code_end_line": 874,
        "code_key": "QueryRDiskVol",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) QueryRDiskVol(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryRDiskVol\", reflect.TypeOf((*MockMasterClientProxy)(nil).QueryRDiskVol), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 498,
        "code_end_line": 596,
        "code_key": "QueryRDiskVol",
        "code_value": "func (*masterApiServerImpl) QueryRDiskVol(ctx context.Context, req *pb.QueryRDiskVolRequest) (*pb.QueryRDiskVolResponse, error) {\n\tview := app.GetRegistry(ctx).Viewers.LogicalVolume\n\tphyView := app.GetRegistry(ctx).Viewers.PhysicalVolume\n\tvar err error\n\n\ttype checker func(*pb.QueryRDiskVolRequest) error\n\tfor _, rule := range []checker{\n\t\t// 不允许不带任何参数的空查询\n\t\tcheckQueryRDiskVolNoEmptyQuery,\n\t\t// 如果带有 BdfIds 参数，必须带有 HostIps 参数缩小范围，单纯 Bdf 查询意义不大，区分度太低了\n\t\tcheckQueryRDiskVolBdfIdsMustComeWithHostIps,\n\t} {\n\t\tif err := rule(req); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Stage 1 - （如有）确认物理卷 Serials\n\tserials := []rdiskDomain.Serial{}\n\tif len(req.HostIps) > 0 {\n\t\tcriteria := rdiskDomain.PVSearchCriteria{\n\t\t\tIPs:           functools.Map(req.HostIps, net.ParseIP),\n\t\t\tSerials:       functools.Map(req.PhyIds, func(x string) rdiskDomain.Serial { return rdiskDomain.Serial(x) }),\n\t\t\tBDFs:          functools.Map(req.BdfIds, func(x string) rdiskDomain.BDF { return rdiskDomain.BDF(x) }),\n\t\t\tAvailableOnly: false,\n\t\t}\n\t\tphyDisks, err := phyView.Search(ctx, criteria, rdiskDomain.Pagination{Limit: 1000})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tserials = functools.Map(phyDisks, func(x *rdiskDomain.PhysicalVolume) rdiskDomain.Serial { return x.Serial })\n\t} else if len(req.PhyIds) > 0 {\n\t\tserials = functools.Map(req.PhyIds, func(x string) rdiskDomain.Serial { return rdiskDomain.Serial(x) })\n\t}\n\n\t// Stage 2 - 确认用户 AppId\n\tuuidSlice := functools.Map(req.CbsUuids, uuid.MustParse)\n\tappId := users.AppID(req.AppId)\n\tif req.AppId <= 0 {\n\t\tif appId, err = view.ProbeAppID(ctx, uuidSlice, serials); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Stage 3 - 发起查询\n\tcriteria := rdiskDomain.LVSearchCriteria{\n\t\tUUIDs:   uuidSlice,\n\t\tSerials: serials,\n\t}\n\tvar limit uint64 = 100\n\tvar offset uint64 = 0\n\tif req.Page != nil {\n\t\tlimit = req.Page.PageSize\n\t\toffset = req.Page.Page * limit\n\t}\n\n\tresults, err := view.Search(ctx, appId, criteria, rdiskDomain.Pagination{Limit: limit, Offset: offset})\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn &pb.QueryRDiskVolResponse{}, nil\n\t\t}\n\t}\n\n\tif len(results) == 0 {\n\t\treturn &pb.QueryRDiskVolResponse{}, nil\n\t}\n\n\t// Stage 4 - 查询关联的置放群组\n\trelatedUuidStrings := functools.Map(results, func(x *rdiskDomain.LogicalVolume) string { return x.UUID.String() })\n\tdrgroupRelations, err := app.GetRegistry(ctx).Viewers.DRGroup.QueryRelationsMap(ctx, appId, relatedUuidStrings)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Stage 5 - 组装数据返回\n\n\tgroupNameToSpecMap := make(map[string]*pb.AffinitySpec)\n\tresponseDataRef := functools.MapRef(make([]pb.RDisk, len(results)))\n\tfor i := range results {\n\t\tencodeLogicalVolume(results[i], responseDataRef[i])\n\n\t\t// 找到关联的置放群组并返回\n\t\tif drgroupViews, ok := drgroupRelations[results[i].UUID.String()]; ok {\n\t\t\tresponseDataRef[i].AffinitySpec = make([]*pb.AffinitySpec, len(drgroupViews))\n\t\t\tfor j := range drgroupViews {\n\t\t\t\tgroupName := drgroupViews[j].Name\n\t\t\t\tif spec, ok := groupNameToSpecMap[groupName]; ok {\n\t\t\t\t\tresponseDataRef[i].AffinitySpec[j] = spec\n\t\t\t\t} else {\n\t\t\t\t\tspec := encodeDRGroupView(drgroupViews[j], &pb.AffinitySpec{}, results[i].UUID.String())\n\t\t\t\t\tgroupNameToSpecMap[groupName] = spec\n\t\t\t\t\tresponseDataRef[i].AffinitySpec[j] = spec\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\treturn &pb.QueryRDiskVolResponse{Disks: responseDataRef}, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 654,
        "code_end_line": 656,
        "code_key": "DeleteRDiskVol",
        "code_value": "func (s *UnimplementedMaster) DeleteRDiskVol(ctx context.Context, req *DeleteRDiskVolRequest) (*DeleteRDiskVolResponse, error) {\n\treturn nil, errors.New(\"rpc DeleteRDiskVol of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 877,
        "code_end_line": 895,
        "code_key": "DeleteRDiskVol",
        "code_value": "func (c *MasterClientProxyImpl) DeleteRDiskVol(ctx context.Context, req *DeleteRDiskVolRequest, opts ...client.Option) (*DeleteRDiskVolResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/DeleteRDiskVol\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"DeleteRDiskVol\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &DeleteRDiskVolResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 234,
        "code_end_line": 240,
        "code_key": "DeleteRDiskVol",
        "code_value": "func (m *MockMasterService) DeleteRDiskVol(ctx context.Context, req *DeleteRDiskVolRequest) (*DeleteRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"DeleteRDiskVol\", ctx, req)\n\tret0, _ := ret[0].(*DeleteRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 243,
        "code_end_line": 246,
        "code_key": "DeleteRDiskVol",
        "code_value": "func (mr *MockMasterServiceMockRecorder) DeleteRDiskVol(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeleteRDiskVol\", reflect.TypeOf((*MockMasterService)(nil).DeleteRDiskVol), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 697,
        "code_end_line": 707,
        "code_key": "DeleteRDiskVol",
        "code_value": "func (m *MockMasterClientProxy) DeleteRDiskVol(ctx context.Context, req *DeleteRDiskVolRequest, opts ...client.Option) (*DeleteRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"DeleteRDiskVol\", varargs...)\n\tret0, _ := ret[0].(*DeleteRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 710,
        "code_end_line": 714,
        "code_key": "DeleteRDiskVol",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) DeleteRDiskVol(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeleteRDiskVol\", reflect.TypeOf((*MockMasterClientProxy)(nil).DeleteRDiskVol), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 238,
        "code_end_line": 260,
        "code_key": "DeleteRDiskVol",
        "code_value": "func (s *masterApiServerImpl) DeleteRDiskVol(ctx context.Context, req *pb.DeleteRDiskVolRequest) (*pb.DeleteRDiskVolResponse, error) {\n\tvar (\n\t\terr      error\n\t\tresponse = &pb.DeleteRDiskVolResponse{}\n\t\tcmd      *commands.DeleteLogicalVolumeCommand\n\t)\n\tcmd = &commands.DeleteLogicalVolumeCommand{\n\t\tAppID: users.AppID(req.AppId),\n\t\tUUID:  uuid.MustParse(req.CbsUuid),\n\t}\n\terr = cmd.Prepare(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, cmd)\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn &pb.DeleteRDiskVolResponse{}, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn response, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 659,
        "code_end_line": 661,
        "code_key": "ConfirmDeleteRDiskVol",
        "code_value": "func (s *UnimplementedMaster) ConfirmDeleteRDiskVol(ctx context.Context, req *DeleteRDiskVolRequest) (*DeleteRDiskVolResponse, error) {\n\treturn nil, errors.New(\"rpc ConfirmDeleteRDiskVol of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 897,
        "code_end_line": 915,
        "code_key": "ConfirmDeleteRDiskVol",
        "code_value": "func (c *MasterClientProxyImpl) ConfirmDeleteRDiskVol(ctx context.Context, req *DeleteRDiskVolRequest, opts ...client.Option) (*DeleteRDiskVolResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/ConfirmDeleteRDiskVol\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"ConfirmDeleteRDiskVol\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &DeleteRDiskVolResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 99,
        "code_end_line": 105,
        "code_key": "ConfirmDeleteRDiskVol",
        "code_value": "func (m *MockMasterService) ConfirmDeleteRDiskVol(ctx context.Context, req *DeleteRDiskVolRequest) (*DeleteRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"ConfirmDeleteRDiskVol\", ctx, req)\n\tret0, _ := ret[0].(*DeleteRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 108,
        "code_end_line": 111,
        "code_key": "ConfirmDeleteRDiskVol",
        "code_value": "func (mr *MockMasterServiceMockRecorder) ConfirmDeleteRDiskVol(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ConfirmDeleteRDiskVol\", reflect.TypeOf((*MockMasterService)(nil).ConfirmDeleteRDiskVol), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 517,
        "code_end_line": 527,
        "code_key": "ConfirmDeleteRDiskVol",
        "code_value": "func (m *MockMasterClientProxy) ConfirmDeleteRDiskVol(ctx context.Context, req *DeleteRDiskVolRequest, opts ...client.Option) (*DeleteRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"ConfirmDeleteRDiskVol\", varargs...)\n\tret0, _ := ret[0].(*DeleteRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 530,
        "code_end_line": 534,
        "code_key": "ConfirmDeleteRDiskVol",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) ConfirmDeleteRDiskVol(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ConfirmDeleteRDiskVol\", reflect.TypeOf((*MockMasterClientProxy)(nil).ConfirmDeleteRDiskVol), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 263,
        "code_end_line": 276,
        "code_key": "ConfirmDeleteRDiskVol",
        "code_value": "func (s *masterApiServerImpl) ConfirmDeleteRDiskVol(ctx context.Context, req *pb.DeleteRDiskVolRequest) (*pb.DeleteRDiskVolResponse, error) {\n\tcmd := commands.ConfirmDeleteLogicalVolumeCommand{\n\t\tAppID: users.AppID(req.AppId),\n\t\tUUID:  uuid.MustParse(req.CbsUuid),\n\t}\n\terr := app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, &cmd)\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn &pb.DeleteRDiskVolResponse{}, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn &pb.DeleteRDiskVolResponse{}, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 664,
        "code_end_line": 666,
        "code_key": "UpdateRDiskFlowCtrl",
        "code_value": "func (s *UnimplementedMaster) UpdateRDiskFlowCtrl(ctx context.Context, req *UpdateRDiskFlowCtrlRequest) (*UpdateRDiskFlowCtrlResponse, error) {\n\treturn nil, errors.New(\"rpc UpdateRDiskFlowCtrl of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 917,
        "code_end_line": 935,
        "code_key": "UpdateRDiskFlowCtrl",
        "code_value": "func (c *MasterClientProxyImpl) UpdateRDiskFlowCtrl(ctx context.Context, req *UpdateRDiskFlowCtrlRequest, opts ...client.Option) (*UpdateRDiskFlowCtrlResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/UpdateRDiskFlowCtrl\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"UpdateRDiskFlowCtrl\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &UpdateRDiskFlowCtrlResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 399,
        "code_end_line": 405,
        "code_key": "UpdateRDiskFlowCtrl",
        "code_value": "func (m *MockMasterService) UpdateRDiskFlowCtrl(ctx context.Context, req *UpdateRDiskFlowCtrlRequest) (*UpdateRDiskFlowCtrlResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"UpdateRDiskFlowCtrl\", ctx, req)\n\tret0, _ := ret[0].(*UpdateRDiskFlowCtrlResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 408,
        "code_end_line": 411,
        "code_key": "UpdateRDiskFlowCtrl",
        "code_value": "func (mr *MockMasterServiceMockRecorder) UpdateRDiskFlowCtrl(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"UpdateRDiskFlowCtrl\", reflect.TypeOf((*MockMasterService)(nil).UpdateRDiskFlowCtrl), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 917,
        "code_end_line": 927,
        "code_key": "UpdateRDiskFlowCtrl",
        "code_value": "func (m *MockMasterClientProxy) UpdateRDiskFlowCtrl(ctx context.Context, req *UpdateRDiskFlowCtrlRequest, opts ...client.Option) (*UpdateRDiskFlowCtrlResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"UpdateRDiskFlowCtrl\", varargs...)\n\tret0, _ := ret[0].(*UpdateRDiskFlowCtrlResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 930,
        "code_end_line": 934,
        "code_key": "UpdateRDiskFlowCtrl",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) UpdateRDiskFlowCtrl(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"UpdateRDiskFlowCtrl\", reflect.TypeOf((*MockMasterClientProxy)(nil).UpdateRDiskFlowCtrl), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 359,
        "code_end_line": 382,
        "code_key": "UpdateRDiskFlowCtrl",
        "code_value": "func (*masterApiServerImpl) UpdateRDiskFlowCtrl(ctx context.Context, req *pb.UpdateRDiskFlowCtrlRequest) (*pb.UpdateRDiskFlowCtrlResponse, error) {\n\tvar (\n\t\terr      error\n\t\tresponse = &pb.UpdateRDiskFlowCtrlResponse{}\n\t\tcmd      = &commands.UpdateLogicalVolumeFlowControlCommand{}\n\t)\n\n\tcmd.AppID = users.AppID(req.AppId)\n\tcmd.UUID = uuid.MustParse(req.CbsUuid)\n\n\tif ctrl := req.GetFlowCtrl(); ctrl != nil {\n\t\tcmd.UpdateRequest.ReadIOPS = ctrl.ReadIops\n\t\tcmd.UpdateRequest.ReadIO = ctrl.ReadBandwidth\n\t\tcmd.UpdateRequest.WriteIOPS = ctrl.WriteIops\n\t\tcmd.UpdateRequest.WriteIO = ctrl.WriteBandwidth\n\t\tcmd.UpdateRequest.RWIO = ctrl.RwBandwidth\n\t\tcmd.UpdateRequest.RWIOPS = ctrl.RwIops\n\t} else {\n\t\treturn response, nil\n\t}\n\n\terr = app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, cmd)\n\treturn response, err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 669,
        "code_end_line": 671,
        "code_key": "AttachRDiskVol",
        "code_value": "func (s *UnimplementedMaster) AttachRDiskVol(ctx context.Context, req *AttachRDiskVolRequest) (*AttachRDiskVolResponse, error) {\n\treturn nil, errors.New(\"rpc AttachRDiskVol of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 937,
        "code_end_line": 955,
        "code_key": "AttachRDiskVol",
        "code_value": "func (c *MasterClientProxyImpl) AttachRDiskVol(ctx context.Context, req *AttachRDiskVolRequest, opts ...client.Option) (*AttachRDiskVolResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/AttachRDiskVol\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"AttachRDiskVol\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &AttachRDiskVolResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 39,
        "code_end_line": 45,
        "code_key": "AttachRDiskVol",
        "code_value": "func (m *MockMasterService) AttachRDiskVol(ctx context.Context, req *AttachRDiskVolRequest) (*AttachRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"AttachRDiskVol\", ctx, req)\n\tret0, _ := ret[0].(*AttachRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 48,
        "code_end_line": 51,
        "code_key": "AttachRDiskVol",
        "code_value": "func (mr *MockMasterServiceMockRecorder) AttachRDiskVol(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"AttachRDiskVol\", reflect.TypeOf((*MockMasterService)(nil).AttachRDiskVol), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 437,
        "code_end_line": 447,
        "code_key": "AttachRDiskVol",
        "code_value": "func (m *MockMasterClientProxy) AttachRDiskVol(ctx context.Context, req *AttachRDiskVolRequest, opts ...client.Option) (*AttachRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"AttachRDiskVol\", varargs...)\n\tret0, _ := ret[0].(*AttachRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 450,
        "code_end_line": 454,
        "code_key": "AttachRDiskVol",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) AttachRDiskVol(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"AttachRDiskVol\", reflect.TypeOf((*MockMasterClientProxy)(nil).AttachRDiskVol), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 309,
        "code_end_line": 338,
        "code_key": "AttachRDiskVol",
        "code_value": "func (s *masterApiServerImpl) AttachRDiskVol(ctx context.Context, req *pb.AttachRDiskVolRequest) (*pb.AttachRDiskVolResponse, error) {\n\tcmd := commands.AttachLogicalVolumeCommand{\n\t\tAppID:   users.AppID(req.AppId),\n\t\tUUID:    uuid.MustParse(req.CbsUuid),\n\t\tIP:      net.ParseIP(req.HostIp),\n\t\tOptions: actions.NewAttachOptions(),\n\t}\n\n\tif req.Option != nil {\n\t\tif req.Option.Serial != \"\" {\n\t\t\tcmd.Options.Serial = req.Option.Serial\n\t\t}\n\t\tif req.Option.Vcpu > 0 {\n\t\t\tcmd.Options.VCPU = int(req.Option.Vcpu)\n\t\t}\n\t}\n\n\terr := app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, &cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvol := cmd.GetLogicalVolume()\n\tspdkDriver := \"\"\n\tattachment, err := vol.GetAttachment(net.ParseIP(req.HostIp))\n\tif err == nil {\n\t\tspdkDriver = attachment.Options.SPDKDriver\n\t}\n\tblockSize := vol.PhysicalVolume.BlockSize\n\treturn &pb.AttachRDiskVolResponse{SpdkDriver: spdkDriver, BlockSize: int64(blockSize)}, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 674,
        "code_end_line": 676,
        "code_key": "DetachRDiskVol",
        "code_value": "func (s *UnimplementedMaster) DetachRDiskVol(ctx context.Context, req *DetachRDiskVolRequest) (*DetachRDiskVolResponse, error) {\n\treturn nil, errors.New(\"rpc DetachRDiskVol of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 957,
        "code_end_line": 975,
        "code_key": "DetachRDiskVol",
        "code_value": "func (c *MasterClientProxyImpl) DetachRDiskVol(ctx context.Context, req *DetachRDiskVolRequest, opts ...client.Option) (*DetachRDiskVolResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/DetachRDiskVol\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"DetachRDiskVol\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &DetachRDiskVolResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 249,
        "code_end_line": 255,
        "code_key": "DetachRDiskVol",
        "code_value": "func (m *MockMasterService) DetachRDiskVol(ctx context.Context, req *DetachRDiskVolRequest) (*DetachRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"DetachRDiskVol\", ctx, req)\n\tret0, _ := ret[0].(*DetachRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 258,
        "code_end_line": 261,
        "code_key": "DetachRDiskVol",
        "code_value": "func (mr *MockMasterServiceMockRecorder) DetachRDiskVol(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DetachRDiskVol\", reflect.TypeOf((*MockMasterService)(nil).DetachRDiskVol), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 717,
        "code_end_line": 727,
        "code_key": "DetachRDiskVol",
        "code_value": "func (m *MockMasterClientProxy) DetachRDiskVol(ctx context.Context, req *DetachRDiskVolRequest, opts ...client.Option) (*DetachRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"DetachRDiskVol\", varargs...)\n\tret0, _ := ret[0].(*DetachRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 730,
        "code_end_line": 734,
        "code_key": "DetachRDiskVol",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) DetachRDiskVol(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DetachRDiskVol\", reflect.TypeOf((*MockMasterClientProxy)(nil).DetachRDiskVol), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 341,
        "code_end_line": 356,
        "code_key": "DetachRDiskVol",
        "code_value": "func (s *masterApiServerImpl) DetachRDiskVol(ctx context.Context, req *pb.DetachRDiskVolRequest) (*pb.DetachRDiskVolResponse, error) {\n\tvar (\n\t\terr      error\n\t\tresponse = &pb.DetachRDiskVolResponse{}\n\t\tcmd      *commands.DetachLogicalVolumeCommand\n\t)\n\n\tcmd = &commands.DetachLogicalVolumeCommand{\n\t\tAppID:       users.AppID(req.AppId),\n\t\tUUID:        uuid.MustParse(req.CbsUuid),\n\t\tIP:          net.ParseIP(req.HostIp),\n\t\tForceDetach: req.Force,\n\t}\n\terr = app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, cmd)\n\treturn response, err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 679,
        "code_end_line": 681,
        "code_key": "CreateRDiskLiveMigration",
        "code_value": "func (s *UnimplementedMaster) CreateRDiskLiveMigration(ctx context.Context, req *CreateRDiskLiveMigrationRequest) (*CreateRDiskLiveMigrationResponse, error) {\n\treturn nil, errors.New(\"rpc CreateRDiskLiveMigration of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 977,
        "code_end_line": 995,
        "code_key": "CreateRDiskLiveMigration",
        "code_value": "func (c *MasterClientProxyImpl) CreateRDiskLiveMigration(ctx context.Context, req *CreateRDiskLiveMigrationRequest, opts ...client.Option) (*CreateRDiskLiveMigrationResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/CreateRDiskLiveMigration\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"CreateRDiskLiveMigration\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &CreateRDiskLiveMigrationResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 159,
        "code_end_line": 165,
        "code_key": "CreateRDiskLiveMigration",
        "code_value": "func (m *MockMasterService) CreateRDiskLiveMigration(ctx context.Context, req *CreateRDiskLiveMigrationRequest) (*CreateRDiskLiveMigrationResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CreateRDiskLiveMigration\", ctx, req)\n\tret0, _ := ret[0].(*CreateRDiskLiveMigrationResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 168,
        "code_end_line": 171,
        "code_key": "CreateRDiskLiveMigration",
        "code_value": "func (mr *MockMasterServiceMockRecorder) CreateRDiskLiveMigration(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateRDiskLiveMigration\", reflect.TypeOf((*MockMasterService)(nil).CreateRDiskLiveMigration), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 597,
        "code_end_line": 607,
        "code_key": "CreateRDiskLiveMigration",
        "code_value": "func (m *MockMasterClientProxy) CreateRDiskLiveMigration(ctx context.Context, req *CreateRDiskLiveMigrationRequest, opts ...client.Option) (*CreateRDiskLiveMigrationResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"CreateRDiskLiveMigration\", varargs...)\n\tret0, _ := ret[0].(*CreateRDiskLiveMigrationResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 610,
        "code_end_line": 614,
        "code_key": "CreateRDiskLiveMigration",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) CreateRDiskLiveMigration(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateRDiskLiveMigration\", reflect.TypeOf((*MockMasterClientProxy)(nil).CreateRDiskLiveMigration), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 433,
        "code_end_line": 435,
        "code_key": "CreateRDiskLiveMigration",
        "code_value": "func (*masterApiServerImpl) CreateRDiskLiveMigration(ctx context.Context, req *pb.CreateRDiskLiveMigrationRequest) (*pb.CreateRDiskLiveMigrationResponse, error) {\n\tpanic(\"unimplemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 684,
        "code_end_line": 686,
        "code_key": "CreateRDiskColdMigration",
        "code_value": "func (s *UnimplementedMaster) CreateRDiskColdMigration(ctx context.Context, req *CreateRDiskColdMigrationRequest) (*CreateRDiskColdMigrationResponse, error) {\n\treturn nil, errors.New(\"rpc CreateRDiskColdMigration of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 997,
        "code_end_line": 1015,
        "code_key": "CreateRDiskColdMigration",
        "code_value": "func (c *MasterClientProxyImpl) CreateRDiskColdMigration(ctx context.Context, req *CreateRDiskColdMigrationRequest, opts ...client.Option) (*CreateRDiskColdMigrationResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/CreateRDiskColdMigration\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"CreateRDiskColdMigration\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &CreateRDiskColdMigrationResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 144,
        "code_end_line": 150,
        "code_key": "CreateRDiskColdMigration",
        "code_value": "func (m *MockMasterService) CreateRDiskColdMigration(ctx context.Context, req *CreateRDiskColdMigrationRequest) (*CreateRDiskColdMigrationResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CreateRDiskColdMigration\", ctx, req)\n\tret0, _ := ret[0].(*CreateRDiskColdMigrationResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 153,
        "code_end_line": 156,
        "code_key": "CreateRDiskColdMigration",
        "code_value": "func (mr *MockMasterServiceMockRecorder) CreateRDiskColdMigration(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateRDiskColdMigration\", reflect.TypeOf((*MockMasterService)(nil).CreateRDiskColdMigration), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 577,
        "code_end_line": 587,
        "code_key": "CreateRDiskColdMigration",
        "code_value": "func (m *MockMasterClientProxy) CreateRDiskColdMigration(ctx context.Context, req *CreateRDiskColdMigrationRequest, opts ...client.Option) (*CreateRDiskColdMigrationResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"CreateRDiskColdMigration\", varargs...)\n\tret0, _ := ret[0].(*CreateRDiskColdMigrationResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 590,
        "code_end_line": 594,
        "code_key": "CreateRDiskColdMigration",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) CreateRDiskColdMigration(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateRDiskColdMigration\", reflect.TypeOf((*MockMasterClientProxy)(nil).CreateRDiskColdMigration), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 428,
        "code_end_line": 430,
        "code_key": "CreateRDiskColdMigration",
        "code_value": "func (*masterApiServerImpl) CreateRDiskColdMigration(ctx context.Context, req *pb.CreateRDiskColdMigrationRequest) (*pb.CreateRDiskColdMigrationResponse, error) {\n\tpanic(\"unimplemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 689,
        "code_end_line": 691,
        "code_key": "QueryRDiskMigrationTask",
        "code_value": "func (s *UnimplementedMaster) QueryRDiskMigrationTask(ctx context.Context, req *QueryRDiskMigrationTaskRequest) (*QueryRDiskMigrationTaskResponse, error) {\n\treturn nil, errors.New(\"rpc QueryRDiskMigrationTask of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1017,
        "code_end_line": 1035,
        "code_key": "QueryRDiskMigrationTask",
        "code_value": "func (c *MasterClientProxyImpl) QueryRDiskMigrationTask(ctx context.Context, req *QueryRDiskMigrationTaskRequest, opts ...client.Option) (*QueryRDiskMigrationTaskResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/QueryRDiskMigrationTask\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"QueryRDiskMigrationTask\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &QueryRDiskMigrationTaskResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 339,
        "code_end_line": 345,
        "code_key": "QueryRDiskMigrationTask",
        "code_value": "func (m *MockMasterService) QueryRDiskMigrationTask(ctx context.Context, req *QueryRDiskMigrationTaskRequest) (*QueryRDiskMigrationTaskResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"QueryRDiskMigrationTask\", ctx, req)\n\tret0, _ := ret[0].(*QueryRDiskMigrationTaskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 348,
        "code_end_line": 351,
        "code_key": "QueryRDiskMigrationTask",
        "code_value": "func (mr *MockMasterServiceMockRecorder) QueryRDiskMigrationTask(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryRDiskMigrationTask\", reflect.TypeOf((*MockMasterService)(nil).QueryRDiskMigrationTask), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 837,
        "code_end_line": 847,
        "code_key": "QueryRDiskMigrationTask",
        "code_value": "func (m *MockMasterClientProxy) QueryRDiskMigrationTask(ctx context.Context, req *QueryRDiskMigrationTaskRequest, opts ...client.Option) (*QueryRDiskMigrationTaskResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"QueryRDiskMigrationTask\", varargs...)\n\tret0, _ := ret[0].(*QueryRDiskMigrationTaskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 850,
        "code_end_line": 854,
        "code_key": "QueryRDiskMigrationTask",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) QueryRDiskMigrationTask(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryRDiskMigrationTask\", reflect.TypeOf((*MockMasterClientProxy)(nil).QueryRDiskMigrationTask), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 463,
        "code_end_line": 465,
        "code_key": "QueryRDiskMigrationTask",
        "code_value": "func (*masterApiServerImpl) QueryRDiskMigrationTask(ctx context.Context, req *pb.QueryRDiskMigrationTaskRequest) (*pb.QueryRDiskMigrationTaskResponse, error) {\n\tpanic(\"unimplemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 694,
        "code_end_line": 696,
        "code_key": "CancelRDiskMigration",
        "code_value": "func (s *UnimplementedMaster) CancelRDiskMigration(ctx context.Context, req *CancelRDiskMigrationRequest) (*CancelRDiskMigrationResponse, error) {\n\treturn nil, errors.New(\"rpc CancelRDiskMigration of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1037,
        "code_end_line": 1055,
        "code_key": "CancelRDiskMigration",
        "code_value": "func (c *MasterClientProxyImpl) CancelRDiskMigration(ctx context.Context, req *CancelRDiskMigrationRequest, opts ...client.Option) (*CancelRDiskMigrationResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/CancelRDiskMigration\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"CancelRDiskMigration\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &CancelRDiskMigrationResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 69,
        "code_end_line": 75,
        "code_key": "CancelRDiskMigration",
        "code_value": "func (m *MockMasterService) CancelRDiskMigration(ctx context.Context, req *CancelRDiskMigrationRequest) (*CancelRDiskMigrationResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CancelRDiskMigration\", ctx, req)\n\tret0, _ := ret[0].(*CancelRDiskMigrationResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 78,
        "code_end_line": 81,
        "code_key": "CancelRDiskMigration",
        "code_value": "func (mr *MockMasterServiceMockRecorder) CancelRDiskMigration(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CancelRDiskMigration\", reflect.TypeOf((*MockMasterService)(nil).CancelRDiskMigration), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 477,
        "code_end_line": 487,
        "code_key": "CancelRDiskMigration",
        "code_value": "func (m *MockMasterClientProxy) CancelRDiskMigration(ctx context.Context, req *CancelRDiskMigrationRequest, opts ...client.Option) (*CancelRDiskMigrationResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"CancelRDiskMigration\", varargs...)\n\tret0, _ := ret[0].(*CancelRDiskMigrationResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 490,
        "code_end_line": 494,
        "code_key": "CancelRDiskMigration",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) CancelRDiskMigration(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CancelRDiskMigration\", reflect.TypeOf((*MockMasterClientProxy)(nil).CancelRDiskMigration), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 438,
        "code_end_line": 440,
        "code_key": "CancelRDiskMigration",
        "code_value": "func (*masterApiServerImpl) CancelRDiskMigration(ctx context.Context, req *pb.CancelRDiskMigrationRequest) (*pb.CancelRDiskMigrationResponse, error) {\n\tpanic(\"unimplemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 699,
        "code_end_line": 701,
        "code_key": "CreateRDiskBackup",
        "code_value": "func (s *UnimplementedMaster) CreateRDiskBackup(ctx context.Context, req *CreateRDiskBackupRequest) (*CreateRDiskBackupResponse, error) {\n\treturn nil, errors.New(\"rpc CreateRDiskBackup of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1057,
        "code_end_line": 1075,
        "code_key": "CreateRDiskBackup",
        "code_value": "func (c *MasterClientProxyImpl) CreateRDiskBackup(ctx context.Context, req *CreateRDiskBackupRequest, opts ...client.Option) (*CreateRDiskBackupResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/CreateRDiskBackup\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"CreateRDiskBackup\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &CreateRDiskBackupResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 129,
        "code_end_line": 135,
        "code_key": "CreateRDiskBackup",
        "code_value": "func (m *MockMasterService) CreateRDiskBackup(ctx context.Context, req *CreateRDiskBackupRequest) (*CreateRDiskBackupResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CreateRDiskBackup\", ctx, req)\n\tret0, _ := ret[0].(*CreateRDiskBackupResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 138,
        "code_end_line": 141,
        "code_key": "CreateRDiskBackup",
        "code_value": "func (mr *MockMasterServiceMockRecorder) CreateRDiskBackup(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateRDiskBackup\", reflect.TypeOf((*MockMasterService)(nil).CreateRDiskBackup), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 557,
        "code_end_line": 567,
        "code_key": "CreateRDiskBackup",
        "code_value": "func (m *MockMasterClientProxy) CreateRDiskBackup(ctx context.Context, req *CreateRDiskBackupRequest, opts ...client.Option) (*CreateRDiskBackupResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"CreateRDiskBackup\", varargs...)\n\tret0, _ := ret[0].(*CreateRDiskBackupResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 570,
        "code_end_line": 574,
        "code_key": "CreateRDiskBackup",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) CreateRDiskBackup(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateRDiskBackup\", reflect.TypeOf((*MockMasterClientProxy)(nil).CreateRDiskBackup), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 385,
        "code_end_line": 404,
        "code_key": "CreateRDiskBackup",
        "code_value": "func (*masterApiServerImpl) CreateRDiskBackup(ctx context.Context, req *pb.CreateRDiskBackupRequest) (*pb.CreateRDiskBackupResponse, error) {\n\tvar (\n\t\terr       error\n\t\tresponse  = &pb.CreateRDiskBackupResponse{}\n\t\tcmd       = &commands.CreateRDiskBackupCommand{}\n\t\tdispacher = app.GetRegistry(ctx).Dispatcher\n\t)\n\n\tcmd.AppID = users.AppID(req.AppId)\n\tcmd.UUID = uuid.MustParse(req.CbsUuid)\n\n\terr = dispacher.Dispatch(ctx, cmd)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse.Backup = encodeRDiskBackup(cmd.GetBackup(), &pb.RDiskBackup{})\n\treturn response, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 704,
        "code_end_line": 706,
        "code_key": "QueryRDiskBackup",
        "code_value": "func (s *UnimplementedMaster) QueryRDiskBackup(ctx context.Context, req *QueryRDiskBackupRequest) (*QueryRDiskBackupResponse, error) {\n\treturn nil, errors.New(\"rpc QueryRDiskBackup of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1077,
        "code_end_line": 1095,
        "code_key": "QueryRDiskBackup",
        "code_value": "func (c *MasterClientProxyImpl) QueryRDiskBackup(ctx context.Context, req *QueryRDiskBackupRequest, opts ...client.Option) (*QueryRDiskBackupResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/QueryRDiskBackup\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"QueryRDiskBackup\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &QueryRDiskBackupResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 324,
        "code_end_line": 330,
        "code_key": "QueryRDiskBackup",
        "code_value": "func (m *MockMasterService) QueryRDiskBackup(ctx context.Context, req *QueryRDiskBackupRequest) (*QueryRDiskBackupResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"QueryRDiskBackup\", ctx, req)\n\tret0, _ := ret[0].(*QueryRDiskBackupResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 333,
        "code_end_line": 336,
        "code_key": "QueryRDiskBackup",
        "code_value": "func (mr *MockMasterServiceMockRecorder) QueryRDiskBackup(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryRDiskBackup\", reflect.TypeOf((*MockMasterService)(nil).QueryRDiskBackup), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 817,
        "code_end_line": 827,
        "code_key": "QueryRDiskBackup",
        "code_value": "func (m *MockMasterClientProxy) QueryRDiskBackup(ctx context.Context, req *QueryRDiskBackupRequest, opts ...client.Option) (*QueryRDiskBackupResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"QueryRDiskBackup\", varargs...)\n\tret0, _ := ret[0].(*QueryRDiskBackupResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 830,
        "code_end_line": 834,
        "code_key": "QueryRDiskBackup",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) QueryRDiskBackup(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryRDiskBackup\", reflect.TypeOf((*MockMasterClientProxy)(nil).QueryRDiskBackup), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 443,
        "code_end_line": 460,
        "code_key": "QueryRDiskBackup",
        "code_value": "func (*masterApiServerImpl) QueryRDiskBackup(ctx context.Context, req *pb.QueryRDiskBackupRequest) (*pb.QueryRDiskBackupResponse, error) {\n\tvar (\n\t\tview  = app.GetRegistry(ctx).Viewers.Backup\n\t\tappId = users.AppID(req.AppId)\n\t\tresp  = &pb.QueryRDiskBackupResponse{}\n\t)\n\n\tviews, err := view.FindByAppID(ctx, appId, req.FilterBackupId, req.FilterCbsUuid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdtos := functools.MapRef(make([]pb.RDiskBackup, len(views)))\n\tfunctools.MapTo(views, dtos, encodeRDiskBackupView)\n\tresp.Backup = dtos\n\n\treturn resp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 709,
        "code_end_line": 711,
        "code_key": "DeleteRDiskBackup",
        "code_value": "func (s *UnimplementedMaster) DeleteRDiskBackup(ctx context.Context, req *DeleteRDiskBackupRequest) (*DeleteRDiskBackupResponse, error) {\n\treturn nil, errors.New(\"rpc DeleteRDiskBackup of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1097,
        "code_end_line": 1115,
        "code_key": "DeleteRDiskBackup",
        "code_value": "func (c *MasterClientProxyImpl) DeleteRDiskBackup(ctx context.Context, req *DeleteRDiskBackupRequest, opts ...client.Option) (*DeleteRDiskBackupResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/DeleteRDiskBackup\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"DeleteRDiskBackup\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &DeleteRDiskBackupResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 219,
        "code_end_line": 225,
        "code_key": "DeleteRDiskBackup",
        "code_value": "func (m *MockMasterService) DeleteRDiskBackup(ctx context.Context, req *DeleteRDiskBackupRequest) (*DeleteRDiskBackupResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"DeleteRDiskBackup\", ctx, req)\n\tret0, _ := ret[0].(*DeleteRDiskBackupResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 228,
        "code_end_line": 231,
        "code_key": "DeleteRDiskBackup",
        "code_value": "func (mr *MockMasterServiceMockRecorder) DeleteRDiskBackup(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeleteRDiskBackup\", reflect.TypeOf((*MockMasterService)(nil).DeleteRDiskBackup), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 677,
        "code_end_line": 687,
        "code_key": "DeleteRDiskBackup",
        "code_value": "func (m *MockMasterClientProxy) DeleteRDiskBackup(ctx context.Context, req *DeleteRDiskBackupRequest, opts ...client.Option) (*DeleteRDiskBackupResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"DeleteRDiskBackup\", varargs...)\n\tret0, _ := ret[0].(*DeleteRDiskBackupResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 690,
        "code_end_line": 694,
        "code_key": "DeleteRDiskBackup",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) DeleteRDiskBackup(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeleteRDiskBackup\", reflect.TypeOf((*MockMasterClientProxy)(nil).DeleteRDiskBackup), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 407,
        "code_end_line": 425,
        "code_key": "DeleteRDiskBackup",
        "code_value": "func (*masterApiServerImpl) DeleteRDiskBackup(ctx context.Context, req *pb.DeleteRDiskBackupRequest) (*pb.DeleteRDiskBackupResponse, error) {\n\tvar (\n\t\terr       error\n\t\tresponse  = &pb.DeleteRDiskBackupResponse{}\n\t\tcmd       = &commands.DeleteRDiskBackupCommand{}\n\t\tdispacher = app.GetRegistry(ctx).Dispatcher\n\t)\n\n\tcmd.AppID = users.AppID(req.AppId)\n\tcmd.BackupID = uuid.MustParse(req.BackupId)\n\tcmd.UUID = uuid.MustParse(req.CbsUuid)\n\n\terr = dispacher.Dispatch(ctx, cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 714,
        "code_end_line": 716,
        "code_key": "UpdateRDiskDRGroup",
        "code_value": "func (s *UnimplementedMaster) UpdateRDiskDRGroup(ctx context.Context, req *UpdateRDiskDRGroupRequest) (*UpdateRDiskDRGroupResponse, error) {\n\treturn nil, errors.New(\"rpc UpdateRDiskDRGroup of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1117,
        "code_end_line": 1135,
        "code_key": "UpdateRDiskDRGroup",
        "code_value": "func (c *MasterClientProxyImpl) UpdateRDiskDRGroup(ctx context.Context, req *UpdateRDiskDRGroupRequest, opts ...client.Option) (*UpdateRDiskDRGroupResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/UpdateRDiskDRGroup\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"UpdateRDiskDRGroup\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &UpdateRDiskDRGroupResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 384,
        "code_end_line": 390,
        "code_key": "UpdateRDiskDRGroup",
        "code_value": "func (m *MockMasterService) UpdateRDiskDRGroup(ctx context.Context, req *UpdateRDiskDRGroupRequest) (*UpdateRDiskDRGroupResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"UpdateRDiskDRGroup\", ctx, req)\n\tret0, _ := ret[0].(*UpdateRDiskDRGroupResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 393,
        "code_end_line": 396,
        "code_key": "UpdateRDiskDRGroup",
        "code_value": "func (mr *MockMasterServiceMockRecorder) UpdateRDiskDRGroup(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"UpdateRDiskDRGroup\", reflect.TypeOf((*MockMasterService)(nil).UpdateRDiskDRGroup), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 897,
        "code_end_line": 907,
        "code_key": "UpdateRDiskDRGroup",
        "code_value": "func (m *MockMasterClientProxy) UpdateRDiskDRGroup(ctx context.Context, req *UpdateRDiskDRGroupRequest, opts ...client.Option) (*UpdateRDiskDRGroupResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"UpdateRDiskDRGroup\", varargs...)\n\tret0, _ := ret[0].(*UpdateRDiskDRGroupResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 910,
        "code_end_line": 914,
        "code_key": "UpdateRDiskDRGroup",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) UpdateRDiskDRGroup(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"UpdateRDiskDRGroup\", reflect.TypeOf((*MockMasterClientProxy)(nil).UpdateRDiskDRGroup), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 286,
        "code_end_line": 306,
        "code_key": "UpdateRDiskDRGroup",
        "code_value": "func (s *masterApiServerImpl) UpdateRDiskDRGroup(ctx context.Context, req *pb.UpdateRDiskDRGroupRequest) (*pb.UpdateRDiskDRGroupResponse, error) {\n\tcmd := commands.UpdateLogicalVolumeDRGroupCommand{\n\t\tAppID: users.AppID(req.AppId),\n\t\tUUIDs: functools.Map(req.CbsUuids, uuid.MustParse),\n\t\tSpecs: functools.MapTo(req.AffinitySpecs,\n\t\t\tfunctools.MapRef(make([]drgroup.Spec, len(req.AffinitySpecs))),\n\t\t\tparseAffinitySpec),\n\t\tDryRun: req.DryRun,\n\t}\n\tif err := cmd.Prepare(ctx); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, &cmd); err != nil {\n\t\tif errors.IsCode(err, errors.ErrDryRunSuccessExit) {\n\t\t\treturn &pb.UpdateRDiskDRGroupResponse{}, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn &pb.UpdateRDiskDRGroupResponse{}, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 719,
        "code_end_line": 721,
        "code_key": "CleanupRDiskVol",
        "code_value": "func (s *UnimplementedMaster) CleanupRDiskVol(ctx context.Context, req *CleanupRDiskVolRequest) (*CleanupRDiskVolResponse, error) {\n\treturn nil, errors.New(\"rpc CleanupRDiskVol of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1137,
        "code_end_line": 1155,
        "code_key": "CleanupRDiskVol",
        "code_value": "func (c *MasterClientProxyImpl) CleanupRDiskVol(ctx context.Context, req *CleanupRDiskVolRequest, opts ...client.Option) (*CleanupRDiskVolResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/CleanupRDiskVol\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"CleanupRDiskVol\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &CleanupRDiskVolResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 84,
        "code_end_line": 90,
        "code_key": "CleanupRDiskVol",
        "code_value": "func (m *MockMasterService) CleanupRDiskVol(ctx context.Context, req *CleanupRDiskVolRequest) (*CleanupRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CleanupRDiskVol\", ctx, req)\n\tret0, _ := ret[0].(*CleanupRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 93,
        "code_end_line": 96,
        "code_key": "CleanupRDiskVol",
        "code_value": "func (mr *MockMasterServiceMockRecorder) CleanupRDiskVol(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CleanupRDiskVol\", reflect.TypeOf((*MockMasterService)(nil).CleanupRDiskVol), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 497,
        "code_end_line": 507,
        "code_key": "CleanupRDiskVol",
        "code_value": "func (m *MockMasterClientProxy) CleanupRDiskVol(ctx context.Context, req *CleanupRDiskVolRequest, opts ...client.Option) (*CleanupRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"CleanupRDiskVol\", varargs...)\n\tret0, _ := ret[0].(*CleanupRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 510,
        "code_end_line": 514,
        "code_key": "CleanupRDiskVol",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) CleanupRDiskVol(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CleanupRDiskVol\", reflect.TypeOf((*MockMasterClientProxy)(nil).CleanupRDiskVol), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 73,
        "code_end_line": 84,
        "code_key": "CleanupRDiskVol",
        "code_value": "func (*masterApiServerImpl) CleanupRDiskVol(ctx context.Context, req *pb.CleanupRDiskVolRequest) (*pb.CleanupRDiskVolResponse, error) {\n\tvar dispatcher = app.GetRegistry(ctx).Dispatcher\n\n\tcmd := &commands.CleanupLogicalVolumeCommand{\n\t\tUUID: uuid.MustParse(req.CbsUuid),\n\t\tIP:   net.ParseIP(req.HostIp),\n\t}\n\tif err := dispatcher.Dispatch(ctx, cmd); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &pb.CleanupRDiskVolResponse{}, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 724,
        "code_end_line": 726,
        "code_key": "CreatePhyRDisk",
        "code_value": "func (s *UnimplementedMaster) CreatePhyRDisk(ctx context.Context, req *CreatePhyRDiskRequest) (*CreatePhyRDiskResponse, error) {\n\treturn nil, errors.New(\"rpc CreatePhyRDisk of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1157,
        "code_end_line": 1175,
        "code_key": "CreatePhyRDisk",
        "code_value": "func (c *MasterClientProxyImpl) CreatePhyRDisk(ctx context.Context, req *CreatePhyRDiskRequest, opts ...client.Option) (*CreatePhyRDiskResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/CreatePhyRDisk\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"CreatePhyRDisk\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &CreatePhyRDiskResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 114,
        "code_end_line": 120,
        "code_key": "CreatePhyRDisk",
        "code_value": "func (m *MockMasterService) CreatePhyRDisk(ctx context.Context, req *CreatePhyRDiskRequest) (*CreatePhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CreatePhyRDisk\", ctx, req)\n\tret0, _ := ret[0].(*CreatePhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 123,
        "code_end_line": 126,
        "code_key": "CreatePhyRDisk",
        "code_value": "func (mr *MockMasterServiceMockRecorder) CreatePhyRDisk(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreatePhyRDisk\", reflect.TypeOf((*MockMasterService)(nil).CreatePhyRDisk), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 537,
        "code_end_line": 547,
        "code_key": "CreatePhyRDisk",
        "code_value": "func (m *MockMasterClientProxy) CreatePhyRDisk(ctx context.Context, req *CreatePhyRDiskRequest, opts ...client.Option) (*CreatePhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"CreatePhyRDisk\", varargs...)\n\tret0, _ := ret[0].(*CreatePhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 550,
        "code_end_line": 554,
        "code_key": "CreatePhyRDisk",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) CreatePhyRDisk(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreatePhyRDisk\", reflect.TypeOf((*MockMasterClientProxy)(nil).CreatePhyRDisk), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 603,
        "code_end_line": 654,
        "code_key": "CreatePhyRDisk",
        "code_value": "func (s *masterApiServerImpl) CreatePhyRDisk(ctx context.Context, req *pb.CreatePhyRDiskRequest) (*pb.CreatePhyRDiskResponse, error) {\n\tcmd := commands.CreatePhysicalVolumeCommand{\n\t\tSerial:          req.PhyId,\n\t\tHost:            net.ParseIP(req.HostIp),\n\t\tBDF:             req.BdfId,\n\t\tSize:            req.Size,\n\t\tZoneID:          req.ZoneId,\n\t\tVolumeType:      req.VolumeType,\n\t\tCuf:             req.Cuf,\n\t\tPerformanceRank: req.PerformanceRank,\n\t}\n\n\tswitch req.Type {\n\tcase pb.DataNodeType_unknown:\n\t\tcmd.DataNodeType = rdiskDomain.DataNodeTypeUnknown\n\tcase pb.DataNodeType_mix:\n\t\tcmd.DataNodeType = rdiskDomain.DataNodeTypeMix\n\tcase pb.DataNodeType_monopoly:\n\t\tcmd.DataNodeType = rdiskDomain.DataNodeTypeMonopoly\n\t}\n\n\terr := app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, &cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &pb.CreatePhyRDiskResponse{\n\t\tPhyDisk: &pb.PhyRDisk{\n\t\t\tPhyId:  req.PhyId,\n\t\t\tBdfId:  req.BdfId,\n\t\t\tStatus: \"inited\",\n\t\t\tSize:   req.Size,\n\t\t\tZoneId: req.ZoneId,\n\t\t\tNode: &pb.DataNode{\n\t\t\t\tHostIp: req.HostIp,\n\t\t\t\tStatus: \"online\",\n\t\t\t},\n\t\t\tCuf: req.Cuf,\n\t\t},\n\t}\n\n\t// 查询物理卷状态\n\tresults, err := app.GetRegistry(ctx).Viewers.PhysicalVolume.QueryBySerial(ctx, []string{req.PhyId})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(results) == 1 {\n\t\tvol := results[0]\n\t\tencodePhysicalVolume(vol, response.PhyDisk)\n\t}\n\treturn response, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 729,
        "code_end_line": 731,
        "code_key": "DeletePhyRDisk",
        "code_value": "func (s *UnimplementedMaster) DeletePhyRDisk(ctx context.Context, req *DeletePhyRDiskRequest) (*DeletePhyRDiskResponse, error) {\n\treturn nil, errors.New(\"rpc DeletePhyRDisk of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1177,
        "code_end_line": 1195,
        "code_key": "DeletePhyRDisk",
        "code_value": "func (c *MasterClientProxyImpl) DeletePhyRDisk(ctx context.Context, req *DeletePhyRDiskRequest, opts ...client.Option) (*DeletePhyRDiskResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/DeletePhyRDisk\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"DeletePhyRDisk\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &DeletePhyRDiskResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 204,
        "code_end_line": 210,
        "code_key": "DeletePhyRDisk",
        "code_value": "func (m *MockMasterService) DeletePhyRDisk(ctx context.Context, req *DeletePhyRDiskRequest) (*DeletePhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"DeletePhyRDisk\", ctx, req)\n\tret0, _ := ret[0].(*DeletePhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 213,
        "code_end_line": 216,
        "code_key": "DeletePhyRDisk",
        "code_value": "func (mr *MockMasterServiceMockRecorder) DeletePhyRDisk(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeletePhyRDisk\", reflect.TypeOf((*MockMasterService)(nil).DeletePhyRDisk), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 657,
        "code_end_line": 667,
        "code_key": "DeletePhyRDisk",
        "code_value": "func (m *MockMasterClientProxy) DeletePhyRDisk(ctx context.Context, req *DeletePhyRDiskRequest, opts ...client.Option) (*DeletePhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"DeletePhyRDisk\", varargs...)\n\tret0, _ := ret[0].(*DeletePhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 670,
        "code_end_line": 674,
        "code_key": "DeletePhyRDisk",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) DeletePhyRDisk(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeletePhyRDisk\", reflect.TypeOf((*MockMasterClientProxy)(nil).DeletePhyRDisk), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 657,
        "code_end_line": 676,
        "code_key": "DeletePhyRDisk",
        "code_value": "func (s *masterApiServerImpl) DeletePhyRDisk(ctx context.Context, req *pb.DeletePhyRDiskRequest) (*pb.DeletePhyRDiskResponse, error) {\n\tvar (\n\t\terr      error\n\t\tresponse *pb.DeletePhyRDiskResponse\n\t\tcmd      *commands.DeletePhysicalVolumeCommand\n\t)\n\tcmd = &commands.DeletePhysicalVolumeCommand{\n\t\tSerial: req.PhyId,\n\t\tForce:  req.Force,\n\t}\n\terr = app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, cmd)\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn &pb.DeletePhyRDiskResponse{}, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\tresponse = &pb.DeletePhyRDiskResponse{}\n\treturn response, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 734,
        "code_end_line": 736,
        "code_key": "QueryPhyRDiskInfo",
        "code_value": "func (s *UnimplementedMaster) QueryPhyRDiskInfo(ctx context.Context, req *QueryPhyRDiskInfoRequest) (*QueryPhyRDiskInfoResponse, error) {\n\treturn nil, errors.New(\"rpc QueryPhyRDiskInfo of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1197,
        "code_end_line": 1215,
        "code_key": "QueryPhyRDiskInfo",
        "code_value": "func (c *MasterClientProxyImpl) QueryPhyRDiskInfo(ctx context.Context, req *QueryPhyRDiskInfoRequest, opts ...client.Option) (*QueryPhyRDiskInfoResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/QueryPhyRDiskInfo\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"QueryPhyRDiskInfo\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &QueryPhyRDiskInfoResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 309,
        "code_end_line": 315,
        "code_key": "QueryPhyRDiskInfo",
        "code_value": "func (m *MockMasterService) QueryPhyRDiskInfo(ctx context.Context, req *QueryPhyRDiskInfoRequest) (*QueryPhyRDiskInfoResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"QueryPhyRDiskInfo\", ctx, req)\n\tret0, _ := ret[0].(*QueryPhyRDiskInfoResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 318,
        "code_end_line": 321,
        "code_key": "QueryPhyRDiskInfo",
        "code_value": "func (mr *MockMasterServiceMockRecorder) QueryPhyRDiskInfo(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryPhyRDiskInfo\", reflect.TypeOf((*MockMasterService)(nil).QueryPhyRDiskInfo), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 797,
        "code_end_line": 807,
        "code_key": "QueryPhyRDiskInfo",
        "code_value": "func (m *MockMasterClientProxy) QueryPhyRDiskInfo(ctx context.Context, req *QueryPhyRDiskInfoRequest, opts ...client.Option) (*QueryPhyRDiskInfoResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"QueryPhyRDiskInfo\", varargs...)\n\tret0, _ := ret[0].(*QueryPhyRDiskInfoResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 810,
        "code_end_line": 814,
        "code_key": "QueryPhyRDiskInfo",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) QueryPhyRDiskInfo(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryPhyRDiskInfo\", reflect.TypeOf((*MockMasterClientProxy)(nil).QueryPhyRDiskInfo), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 715,
        "code_end_line": 752,
        "code_key": "QueryPhyRDiskInfo",
        "code_value": "func (*masterApiServerImpl) QueryPhyRDiskInfo(ctx context.Context, req *pb.QueryPhyRDiskInfoRequest) (*pb.QueryPhyRDiskInfoResponse, error) {\n\tvar (\n\t\terr        error\n\t\tresponse   = &pb.QueryPhyRDiskInfoResponse{}\n\t\tview       = app.GetRegistry(ctx).Viewers.PhysicalVolume\n\t\tpagination rdiskDomain.Pagination\n\t)\n\tif req.Page != nil {\n\t\tpagination = rdiskDomain.Pagination{\n\t\t\tLimit:  req.Page.PageSize,\n\t\t\tOffset: req.Page.Page * req.Page.PageSize,\n\t\t}\n\t} else {\n\t\tpagination = rdiskDomain.Pagination{\n\t\t\tLimit:  100,\n\t\t\tOffset: 0,\n\t\t}\n\t}\n\tcriteria := rdiskDomain.PVSearchCriteria{}\n\tif len(req.HostIps) > 0 {\n\t\tcriteria.IPs = functools.Map(req.HostIps, net.ParseIP)\n\t}\n\tif len(req.PhyIds) > 0 {\n\t\tcriteria.Serials = functools.Map(req.PhyIds, func(id string) rdiskDomain.Serial { return rdiskDomain.Serial(id) })\n\t}\n\tif len(req.ZoneIds) > 0 {\n\t\tcriteria.ZoneIDs = functools.Map(req.ZoneIds, func(id uint64) rdiskDomain.ZoneID { return rdiskDomain.ZoneID(id) })\n\t}\n\tcriteria.AvailableOnly = req.AvailableOnly\n\tresults, err := view.Search(ctx, criteria, pagination)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse.PhyDisk = functools.MapRef(make([]pb.PhyRDisk, len(results)))\n\tfunctools.MapTo(results, response.PhyDisk, encodePhysicalVolume)\n\treturn response, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 739,
        "code_end_line": 741,
        "code_key": "UpdatePhyRDisk",
        "code_value": "func (s *UnimplementedMaster) UpdatePhyRDisk(ctx context.Context, req *UpdatePhyRDiskRequest) (*UpdatePhyRDiskResponse, error) {\n\treturn nil, errors.New(\"rpc UpdatePhyRDisk of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1217,
        "code_end_line": 1235,
        "code_key": "UpdatePhyRDisk",
        "code_value": "func (c *MasterClientProxyImpl) UpdatePhyRDisk(ctx context.Context, req *UpdatePhyRDiskRequest, opts ...client.Option) (*UpdatePhyRDiskResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/UpdatePhyRDisk\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"UpdatePhyRDisk\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &UpdatePhyRDiskResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 369,
        "code_end_line": 375,
        "code_key": "UpdatePhyRDisk",
        "code_value": "func (m *MockMasterService) UpdatePhyRDisk(ctx context.Context, req *UpdatePhyRDiskRequest) (*UpdatePhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"UpdatePhyRDisk\", ctx, req)\n\tret0, _ := ret[0].(*UpdatePhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 378,
        "code_end_line": 381,
        "code_key": "UpdatePhyRDisk",
        "code_value": "func (mr *MockMasterServiceMockRecorder) UpdatePhyRDisk(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"UpdatePhyRDisk\", reflect.TypeOf((*MockMasterService)(nil).UpdatePhyRDisk), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 877,
        "code_end_line": 887,
        "code_key": "UpdatePhyRDisk",
        "code_value": "func (m *MockMasterClientProxy) UpdatePhyRDisk(ctx context.Context, req *UpdatePhyRDiskRequest, opts ...client.Option) (*UpdatePhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"UpdatePhyRDisk\", varargs...)\n\tret0, _ := ret[0].(*UpdatePhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 890,
        "code_end_line": 894,
        "code_key": "UpdatePhyRDisk",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) UpdatePhyRDisk(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"UpdatePhyRDisk\", reflect.TypeOf((*MockMasterClientProxy)(nil).UpdatePhyRDisk), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 44,
        "code_end_line": 70,
        "code_key": "UpdatePhyRDisk",
        "code_value": "func (s *masterApiServerImpl) UpdatePhyRDisk(ctx context.Context, req *pb.UpdatePhyRDiskRequest) (*pb.UpdatePhyRDiskResponse, error) {\n\tvar dispatcher = app.GetRegistry(ctx).Dispatcher\n\n\tcmd := &commands.UpdatePhyRDiskCommand{\n\t\tSerial: req.PhyId,\n\t\tParams: rdiskDomain.PhysicalVolumeParamsModification{},\n\t}\n\n\tif len(req.Params) == 0 {\n\t\treturn nil, fmt.Errorf(\"no params\")\n\t}\n\n\tif cufString, ok := req.Params[\"cuf\"]; ok {\n\t\tvar cuf = rdiskDomain.Cuf(cufString)\n\t\tcmd.Params.Cuf = &cuf\n\t}\n\n\tif rankString, ok := req.Params[\"performance_rank\"]; ok {\n\t\tvar rank = rdiskDomain.PerformanceRank(rankString)\n\t\tcmd.Params.PerformanceRank = &rank\n\t}\n\n\tif err := dispatcher.Dispatch(ctx, cmd); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &pb.UpdatePhyRDiskResponse{}, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 744,
        "code_end_line": 746,
        "code_key": "OnlinePhyRDisk",
        "code_value": "func (s *UnimplementedMaster) OnlinePhyRDisk(ctx context.Context, req *OnlinePhyRDiskRequest) (*OnlinePhyRDiskResponse, error) {\n\treturn nil, errors.New(\"rpc OnlinePhyRDisk of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1237,
        "code_end_line": 1255,
        "code_key": "OnlinePhyRDisk",
        "code_value": "func (c *MasterClientProxyImpl) OnlinePhyRDisk(ctx context.Context, req *OnlinePhyRDiskRequest, opts ...client.Option) (*OnlinePhyRDiskResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/OnlinePhyRDisk\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"OnlinePhyRDisk\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &OnlinePhyRDiskResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 279,
        "code_end_line": 285,
        "code_key": "OnlinePhyRDisk",
        "code_value": "func (m *MockMasterService) OnlinePhyRDisk(ctx context.Context, req *OnlinePhyRDiskRequest) (*OnlinePhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"OnlinePhyRDisk\", ctx, req)\n\tret0, _ := ret[0].(*OnlinePhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 288,
        "code_end_line": 291,
        "code_key": "OnlinePhyRDisk",
        "code_value": "func (mr *MockMasterServiceMockRecorder) OnlinePhyRDisk(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"OnlinePhyRDisk\", reflect.TypeOf((*MockMasterService)(nil).OnlinePhyRDisk), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 757,
        "code_end_line": 767,
        "code_key": "OnlinePhyRDisk",
        "code_value": "func (m *MockMasterClientProxy) OnlinePhyRDisk(ctx context.Context, req *OnlinePhyRDiskRequest, opts ...client.Option) (*OnlinePhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"OnlinePhyRDisk\", varargs...)\n\tret0, _ := ret[0].(*OnlinePhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 770,
        "code_end_line": 774,
        "code_key": "OnlinePhyRDisk",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) OnlinePhyRDisk(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"OnlinePhyRDisk\", reflect.TypeOf((*MockMasterClientProxy)(nil).OnlinePhyRDisk), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 697,
        "code_end_line": 712,
        "code_key": "OnlinePhyRDisk",
        "code_value": "func (s *masterApiServerImpl) OnlinePhyRDisk(ctx context.Context, req *pb.OnlinePhyRDiskRequest) (*pb.OnlinePhyRDiskResponse, error) {\n\tvar (\n\t\terr      error\n\t\tresponse = &pb.OnlinePhyRDiskResponse{}\n\t\tcmd      *commands.OnlinePhysicalVolumeCommand\n\t)\n\tcmd = &commands.OnlinePhysicalVolumeCommand{\n\t\tSerial: req.PhyId,\n\t}\n\terr = app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, cmd)\n\tresponse.PhyDisk = &pb.PhyRDisk{}\n\tif cmd.GetPhysicalVolume() != nil {\n\t\tencodePhysicalVolume(cmd.GetPhysicalVolume(), response.PhyDisk)\n\t}\n\treturn response, err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 749,
        "code_end_line": 751,
        "code_key": "OfflinePhyRDisk",
        "code_value": "func (s *UnimplementedMaster) OfflinePhyRDisk(ctx context.Context, req *OfflinePhyRDiskRequest) (*OfflinePhyRDiskResponse, error) {\n\treturn nil, errors.New(\"rpc OfflinePhyRDisk of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1257,
        "code_end_line": 1275,
        "code_key": "OfflinePhyRDisk",
        "code_value": "func (c *MasterClientProxyImpl) OfflinePhyRDisk(ctx context.Context, req *OfflinePhyRDiskRequest, opts ...client.Option) (*OfflinePhyRDiskResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/OfflinePhyRDisk\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"OfflinePhyRDisk\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &OfflinePhyRDiskResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 264,
        "code_end_line": 270,
        "code_key": "OfflinePhyRDisk",
        "code_value": "func (m *MockMasterService) OfflinePhyRDisk(ctx context.Context, req *OfflinePhyRDiskRequest) (*OfflinePhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"OfflinePhyRDisk\", ctx, req)\n\tret0, _ := ret[0].(*OfflinePhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 273,
        "code_end_line": 276,
        "code_key": "OfflinePhyRDisk",
        "code_value": "func (mr *MockMasterServiceMockRecorder) OfflinePhyRDisk(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"OfflinePhyRDisk\", reflect.TypeOf((*MockMasterService)(nil).OfflinePhyRDisk), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 737,
        "code_end_line": 747,
        "code_key": "OfflinePhyRDisk",
        "code_value": "func (m *MockMasterClientProxy) OfflinePhyRDisk(ctx context.Context, req *OfflinePhyRDiskRequest, opts ...client.Option) (*OfflinePhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"OfflinePhyRDisk\", varargs...)\n\tret0, _ := ret[0].(*OfflinePhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 750,
        "code_end_line": 754,
        "code_key": "OfflinePhyRDisk",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) OfflinePhyRDisk(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"OfflinePhyRDisk\", reflect.TypeOf((*MockMasterClientProxy)(nil).OfflinePhyRDisk), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 679,
        "code_end_line": 694,
        "code_key": "OfflinePhyRDisk",
        "code_value": "func (s *masterApiServerImpl) OfflinePhyRDisk(ctx context.Context, req *pb.OfflinePhyRDiskRequest) (*pb.OfflinePhyRDiskResponse, error) {\n\tvar (\n\t\terr      error\n\t\tresponse = &pb.OfflinePhyRDiskResponse{}\n\t\tcmd      *commands.OfflinePhysicalVolumeCommand\n\t)\n\tcmd = &commands.OfflinePhysicalVolumeCommand{\n\t\tSerial: req.PhyId,\n\t}\n\terr = app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, cmd)\n\tresponse.PhyDisk = &pb.PhyRDisk{}\n\tif cmd.GetPhysicalVolume() != nil {\n\t\tencodePhysicalVolume(cmd.GetPhysicalVolume(), response.PhyDisk)\n\t}\n\treturn response, err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 754,
        "code_end_line": 756,
        "code_key": "BenchmarkPhyRDisk",
        "code_value": "func (s *UnimplementedMaster) BenchmarkPhyRDisk(ctx context.Context, req *BenchmarkPhyRDiskRequest) (*BenchmarkPhyRDiskResponse, error) {\n\treturn nil, errors.New(\"rpc BenchmarkPhyRDisk of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1277,
        "code_end_line": 1295,
        "code_key": "BenchmarkPhyRDisk",
        "code_value": "func (c *MasterClientProxyImpl) BenchmarkPhyRDisk(ctx context.Context, req *BenchmarkPhyRDiskRequest, opts ...client.Option) (*BenchmarkPhyRDiskResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/BenchmarkPhyRDisk\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"BenchmarkPhyRDisk\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &BenchmarkPhyRDiskResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 54,
        "code_end_line": 60,
        "code_key": "BenchmarkPhyRDisk",
        "code_value": "func (m *MockMasterService) BenchmarkPhyRDisk(ctx context.Context, req *BenchmarkPhyRDiskRequest) (*BenchmarkPhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"BenchmarkPhyRDisk\", ctx, req)\n\tret0, _ := ret[0].(*BenchmarkPhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 63,
        "code_end_line": 66,
        "code_key": "BenchmarkPhyRDisk",
        "code_value": "func (mr *MockMasterServiceMockRecorder) BenchmarkPhyRDisk(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"BenchmarkPhyRDisk\", reflect.TypeOf((*MockMasterService)(nil).BenchmarkPhyRDisk), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 457,
        "code_end_line": 467,
        "code_key": "BenchmarkPhyRDisk",
        "code_value": "func (m *MockMasterClientProxy) BenchmarkPhyRDisk(ctx context.Context, req *BenchmarkPhyRDiskRequest, opts ...client.Option) (*BenchmarkPhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"BenchmarkPhyRDisk\", varargs...)\n\tret0, _ := ret[0].(*BenchmarkPhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 470,
        "code_end_line": 474,
        "code_key": "BenchmarkPhyRDisk",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) BenchmarkPhyRDisk(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"BenchmarkPhyRDisk\", reflect.TypeOf((*MockMasterClientProxy)(nil).BenchmarkPhyRDisk), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 109,
        "code_end_line": 124,
        "code_key": "BenchmarkPhyRDisk",
        "code_value": "func (*masterApiServerImpl) BenchmarkPhyRDisk(ctx context.Context, req *pb.BenchmarkPhyRDiskRequest) (*pb.BenchmarkPhyRDiskResponse, error) {\n\tvar dispatcher = app.GetRegistry(ctx).Dispatcher\n\n\tcmd := &commands.CreateBenchmarkCommand{\n\t\tSerial: req.PhyId,\n\t}\n\n\tif err := dispatcher.Dispatch(ctx, cmd); err != nil {\n\t\treturn nil, err\n\t}\n\n\tresp := &pb.BenchmarkPhyRDiskResponse{}\n\tresp.TaskId = cmd.GetBenchmark().UUID.String()\n\n\treturn resp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 759,
        "code_end_line": 761,
        "code_key": "QueryPhyRDiskBenchmark",
        "code_value": "func (s *UnimplementedMaster) QueryPhyRDiskBenchmark(ctx context.Context, req *QueryPhyRDiskBenchmarkRequest) (*QueryPhyRDiskBenchmarkResponse, error) {\n\treturn nil, errors.New(\"rpc QueryPhyRDiskBenchmark of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1297,
        "code_end_line": 1315,
        "code_key": "QueryPhyRDiskBenchmark",
        "code_value": "func (c *MasterClientProxyImpl) QueryPhyRDiskBenchmark(ctx context.Context, req *QueryPhyRDiskBenchmarkRequest, opts ...client.Option) (*QueryPhyRDiskBenchmarkResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/QueryPhyRDiskBenchmark\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"QueryPhyRDiskBenchmark\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &QueryPhyRDiskBenchmarkResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 294,
        "code_end_line": 300,
        "code_key": "QueryPhyRDiskBenchmark",
        "code_value": "func (m *MockMasterService) QueryPhyRDiskBenchmark(ctx context.Context, req *QueryPhyRDiskBenchmarkRequest) (*QueryPhyRDiskBenchmarkResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"QueryPhyRDiskBenchmark\", ctx, req)\n\tret0, _ := ret[0].(*QueryPhyRDiskBenchmarkResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 303,
        "code_end_line": 306,
        "code_key": "QueryPhyRDiskBenchmark",
        "code_value": "func (mr *MockMasterServiceMockRecorder) QueryPhyRDiskBenchmark(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryPhyRDiskBenchmark\", reflect.TypeOf((*MockMasterService)(nil).QueryPhyRDiskBenchmark), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 777,
        "code_end_line": 787,
        "code_key": "QueryPhyRDiskBenchmark",
        "code_value": "func (m *MockMasterClientProxy) QueryPhyRDiskBenchmark(ctx context.Context, req *QueryPhyRDiskBenchmarkRequest, opts ...client.Option) (*QueryPhyRDiskBenchmarkResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"QueryPhyRDiskBenchmark\", varargs...)\n\tret0, _ := ret[0].(*QueryPhyRDiskBenchmarkResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 790,
        "code_end_line": 794,
        "code_key": "QueryPhyRDiskBenchmark",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) QueryPhyRDiskBenchmark(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryPhyRDiskBenchmark\", reflect.TypeOf((*MockMasterClientProxy)(nil).QueryPhyRDiskBenchmark), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 127,
        "code_end_line": 177,
        "code_key": "QueryPhyRDiskBenchmark",
        "code_value": "func (*masterApiServerImpl) QueryPhyRDiskBenchmark(ctx context.Context, req *pb.QueryPhyRDiskBenchmarkRequest) (*pb.QueryPhyRDiskBenchmarkResponse, error) {\n\tvar (\n\t\tviewer     = app.GetRegistry(ctx).Viewers.Benchmark\n\t\tdiskSerial = req.PhyId\n\t\tbakUuids   = req.TaskId\n\t\tresp       = &pb.QueryPhyRDiskBenchmarkResponse{}\n\t)\n\n\tif len(bakUuids) == 0 {\n\t\tbakUuids = nil\n\t}\n\n\tresults, err := viewer.FindByDisk(ctx, diskSerial, bakUuids)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tencodeFunc := func(b *benchmark.Benchmark, r *pb.BenchmarkResult) {\n\t\tr.TaskId = b.UUID.String()\n\t\tr.PhyId = b.DiskInfo.Serial\n\t\tr.ErrorMsg = b.Error\n\t\tr.HostIp = b.DiskInfo.HostIP.String()\n\t\tr.BdfId = b.DiskInfo.BDF\n\t\tr.Created = timestamppb.New(b.Created)\n\t\tr.Finished = timestamppb.New(b.Finished)\n\t\tr.ReadBw = b.Stat.ReadBandwidth\n\t\tr.WriteBw = b.Stat.WriteBandwidth\n\t\tr.ReadLat = b.Stat.ReadLatency\n\t\tr.WriteLat = b.Stat.WriteLatency\n\t\tswitch b.Status {\n\t\tcase benchmark.StatusInited:\n\t\t\tr.Status = \"inited\"\n\t\tcase benchmark.StatusRunning:\n\t\t\tr.Status = \"running\"\n\t\tcase benchmark.StatusFailed:\n\t\t\tr.Status = \"failed\"\n\t\tcase benchmark.StatusSuccess:\n\t\t\tr.Status = \"success\"\n\t\tdefault:\n\t\t\tr.Status = \"unknown\"\n\t\t}\n\t}\n\n\tresp.Result = functools.MapTo(\n\t\tresults,\n\t\tfunctools.MapRef(make([]pb.BenchmarkResult, len(results))),\n\t\tencodeFunc,\n\t)\n\n\treturn resp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 764,
        "code_end_line": 766,
        "code_key": "DefunctPhyRDisk",
        "code_value": "func (s *UnimplementedMaster) DefunctPhyRDisk(ctx context.Context, req *DefunctPhyRDiskRequest) (*DefunctPhyRDiskResponse, error) {\n\treturn nil, errors.New(\"rpc DefunctPhyRDisk of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1317,
        "code_end_line": 1335,
        "code_key": "DefunctPhyRDisk",
        "code_value": "func (c *MasterClientProxyImpl) DefunctPhyRDisk(ctx context.Context, req *DefunctPhyRDiskRequest, opts ...client.Option) (*DefunctPhyRDiskResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/DefunctPhyRDisk\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"DefunctPhyRDisk\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &DefunctPhyRDiskResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 189,
        "code_end_line": 195,
        "code_key": "DefunctPhyRDisk",
        "code_value": "func (m *MockMasterService) DefunctPhyRDisk(ctx context.Context, req *DefunctPhyRDiskRequest) (*DefunctPhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"DefunctPhyRDisk\", ctx, req)\n\tret0, _ := ret[0].(*DefunctPhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 198,
        "code_end_line": 201,
        "code_key": "DefunctPhyRDisk",
        "code_value": "func (mr *MockMasterServiceMockRecorder) DefunctPhyRDisk(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DefunctPhyRDisk\", reflect.TypeOf((*MockMasterService)(nil).DefunctPhyRDisk), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 637,
        "code_end_line": 647,
        "code_key": "DefunctPhyRDisk",
        "code_value": "func (m *MockMasterClientProxy) DefunctPhyRDisk(ctx context.Context, req *DefunctPhyRDiskRequest, opts ...client.Option) (*DefunctPhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"DefunctPhyRDisk\", varargs...)\n\tret0, _ := ret[0].(*DefunctPhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 650,
        "code_end_line": 654,
        "code_key": "DefunctPhyRDisk",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) DefunctPhyRDisk(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DefunctPhyRDisk\", reflect.TypeOf((*MockMasterClientProxy)(nil).DefunctPhyRDisk), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 87,
        "code_end_line": 106,
        "code_key": "DefunctPhyRDisk",
        "code_value": "func (*masterApiServerImpl) DefunctPhyRDisk(ctx context.Context, req *pb.DefunctPhyRDiskRequest) (*pb.DefunctPhyRDiskResponse, error) {\n\tvar dispatcher = app.GetRegistry(ctx).Dispatcher\n\tvar cmd = &commands.DefunctPhysicalVolumeCommand{\n\t\tSerial:         rdiskDomain.Serial(req.PhyId),\n\t\tHostIP:         net.ParseIP(req.HostIp),\n\t\tBDF:            rdiskDomain.BDF(req.BdfId),\n\t\tAuthorizeToken: req.AuthorizeToken,\n\t}\n\n\tif err := cmd.Prepare(ctx); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := dispatcher.Dispatch(ctx, cmd); err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar resp = &pb.DefunctPhyRDiskResponse{}\n\treturn resp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.pb.validate.go",
        "code_start_line": 131,
        "code_end_line": 137,
        "code_key": "_validateUuid",
        "code_value": "func (m *RDisk) _validateUuid(uuid string) error {\n\tif matched := _rdisk_master_uuidPattern.MatchString(uuid); !matched {\n\t\treturn errors.New(\"invalid uuid format\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.pb.validate.go",
        "code_start_line": 1061,
        "code_end_line": 1067,
        "code_key": "_validateUuid",
        "code_value": "func (m *QueryRDiskVolRequest) _validateUuid(uuid string) error {\n\tif matched := _rdisk_master_uuidPattern.MatchString(uuid); !matched {\n\t\treturn errors.New(\"invalid uuid format\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.pb.validate.go",
        "code_start_line": 1328,
        "code_end_line": 1334,
        "code_key": "_validateUuid",
        "code_value": "func (m *DeleteRDiskVolRequest) _validateUuid(uuid string) error {\n\tif matched := _rdisk_master_uuidPattern.MatchString(uuid); !matched {\n\t\treturn errors.New(\"invalid uuid format\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.pb.validate.go",
        "code_start_line": 1590,
        "code_end_line": 1596,
        "code_key": "_validateUuid",
        "code_value": "func (m *UpdateRDiskFlowCtrlRequest) _validateUuid(uuid string) error {\n\tif matched := _rdisk_master_uuidPattern.MatchString(uuid); !matched {\n\t\treturn errors.New(\"invalid uuid format\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.pb.validate.go",
        "code_start_line": 1966,
        "code_end_line": 1972,
        "code_key": "_validateUuid",
        "code_value": "func (m *AttachRDiskVolRequest) _validateUuid(uuid string) error {\n\tif matched := _rdisk_master_uuidPattern.MatchString(uuid); !matched {\n\t\treturn errors.New(\"invalid uuid format\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.pb.validate.go",
        "code_start_line": 2216,
        "code_end_line": 2222,
        "code_key": "_validateUuid",
        "code_value": "func (m *DetachRDiskVolRequest) _validateUuid(uuid string) error {\n\tif matched := _rdisk_master_uuidPattern.MatchString(uuid); !matched {\n\t\treturn errors.New(\"invalid uuid format\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.pb.validate.go",
        "code_start_line": 6249,
        "code_end_line": 6255,
        "code_key": "_validateUuid",
        "code_value": "func (m *UpdateRDiskDRGroupRequest) _validateUuid(uuid string) error {\n\tif matched := _rdisk_master_uuidPattern.MatchString(uuid); !matched {\n\t\treturn errors.New(\"invalid uuid format\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/hademo/hademo.go",
        "code_start_line": 26,
        "code_end_line": 36,
        "code_key": "initLocker",
        "code_value": "func initLocker(db *gorm.DB) dlock.Locker {\n\tlocker := mysqllock.New(db, mysqllock.Config{\n\t\tTableName:      \"dlock\",\n\t\tLockColumn:     \"lock\",\n\t\tExpireColumn:   \"expire\",\n\t\tTokenColumn:    \"token\", // NOCA:PasswordLeak(误报)\n\t\tLockTypeColumn: \"type\",\n\t\tLockNumsColumn: \"count\",\n\t})\n\treturn locker\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/cmd/rdisk_master/run.go",
        "code_start_line": 83,
        "code_end_line": 92,
        "code_key": "runApiServer",
        "code_value": "func runApiServer(appCtx context.Context, wg *sync.WaitGroup) {\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ts := apiserver.New(appCtx)\n\t\tif err := s.Serve(); err != nil {\n\t\t\tlogs.Fatal(appCtx).Err(err).Msg(\"server exited\")\n\t\t}\n\t}()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/cmd/rdisk_master/run.go",
        "code_start_line": 135,
        "code_end_line": 151,
        "code_key": "initDLocker",
        "code_value": "func initDLocker(ctx context.Context) {\n\tconfig := &app.GlobalRegistry.Config\n\tdb, err := config.MetaDB.DB()\n\tif err != nil {\n\t\tlogs.Fatal(ctx).Err(err).Msg(\"failed to connect to meta db\")\n\t\tpanic(err)\n\t}\n\tdlockConf := dlock_mysql.Config{\n\t\tTableName:      \"dm_locks\",\n\t\tLockColumn:     \"lock_key\",\n\t\tExpireColumn:   \"expired\",\n\t\tTokenColumn:    \"lock_token\", // NOCA:PasswordLeak(误报)\n\t\tLockTypeColumn: \"lock_type\",\n\t\tLockNumsColumn: \"lock_count\",\n\t}\n\tapp.GlobalRegistry.Locker = dlock_mysql.New(db, dlockConf)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/cmd/rdisk_master/run.go",
        "code_start_line": 172,
        "code_end_line": 182,
        "code_key": "initSchedulers",
        "code_value": "func initSchedulers(ctx context.Context) {\n\tapp.GlobalRegistry.Scheduler = scheduler.New(ctx, app.GlobalRegistry.Locker)\n\n\t// 注册定时任务\n\n\tapp.GlobalRegistry.Scheduler.Add(\"update_backup_task\", &tasks.UpdateBackupTask{})\n\tapp.GlobalRegistry.Scheduler.Add(\"recycle_backup_task\", &tasks.RecycleBackupTask{})\n\tapp.GlobalRegistry.Scheduler.Add(\"update_benchmark_task\", &tasks.UpdateBenchmarkTask{})\n\tapp.GlobalRegistry.Scheduler.Add(\"confirm_init_physicaldisk_task\", &tasks.ConfirmInitPhysicalDiskTask{})\n\tapp.GlobalRegistry.Scheduler.Add(\"cleanup_defunct_task\", &tasks.CleanupDefunctTask{})\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/dispatcher/dispatcher.go",
        "code_start_line": 33,
        "code_end_line": 103,
        "code_key": "Dispatch",
        "code_value": "func (d *dispatcherImpl) Dispatch(ctx context.Context, cmd app.Command) (err error) {\n\t// 为什么使用 backgroundCtx 而不是 ctx？\n\t// 因为 ctx 代表调用方的上下文，通常是 rpc 请求上下文。\n\t// 而执行命令的上下文，应该是一个独立的上下文，不应该受到调用方的影响\n\t// 即使由于网络抖动等原因，调用方的上下文已经超时，但是命令执行的上下文仍然应该继续执行。\n\tworkerCtx := context.WithValue(d.backgroundCtx, ctxKeyCommand, cmd)\n\tworkerCtx, cancelFunc := context.WithTimeout(workerCtx, d.workerTimeout)\n\tworkerCtx = logs.GetLogger(ctx).WithContext(workerCtx)\n\tlockKeys := cmd.LockKeys()\n\terrChan := make(chan error, 1)\n\tlockOption := &dlock.Option{\n\t\tRetryStrategy: dlock.ExponentialBackoff(100*time.Millisecond, 6*time.Second),\n\t}\n\td.wg.Add(1)\n\t// 最终打印错误\n\t// TODO: 并发控制最大能同时执行的命令数量\n\tgo func() {\n\t\tdefer d.wg.Done()\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\te, ok := err.(error)\n\t\t\t\tif !ok {\n\t\t\t\t\te = errors.Newf(ErrDispatchPanic, \"dispatcher panic: %v\", err)\n\t\t\t\t}\n\t\t\t\terrChan <- e\n\t\t\t\tlogs.Error(workerCtx).Err(e).Stack().Bytes(\"trace\", debug.Stack()).Msgf(\"command execution panic\")\n\t\t\t}\n\t\t}()\n\n\t\tdefer cancelFunc()\n\n\t\tif lockKeys != nil {\n\t\t\tlock, err := d.locker.ObtainMulti(workerCtx, lockKeys, d.workerTimeout, lockOption)\n\t\t\tif err != nil {\n\t\t\t\terrChan <- err\n\t\t\t\tlogs.Warn(workerCtx).Err(err).Msgf(\"command execution waiting locks timeout\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer lock.Release(workerCtx)\n\t\t}\n\n\t\tuow := app.GetRegistry(ctx).Repositories.UoWFactory.New()\n\t\tworkerCtx = app.GetRegistry(ctx).Repositories.UoWFactory.With(workerCtx, uow)\n\n\t\terr = cmd.Handle(workerCtx)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, errors.ErrDryRunSuccessExit) {\n\t\t\t\terr = nil\n\t\t\t} else {\n\t\t\t\tlogs.Warn(workerCtx).Err(err).Msgf(\"command execution failed\")\n\t\t\t}\n\t\t\t_err := uow.Rollback(workerCtx)\n\t\t\tif _err != nil {\n\t\t\t\tlogs.Error(workerCtx).Err(_err).Msgf(\"unit of work rollback failed\")\n\t\t\t}\n\t\t} else {\n\t\t\terr = uow.Commit(workerCtx)\n\t\t\tif err != nil {\n\t\t\t\tlogs.Error(workerCtx).Err(err).Msgf(\"unit of work commit failed\")\n\t\t\t}\n\t\t}\n\t\terrChan <- err\n\t\tclose(errChan)\n\t}()\n\tselect {\n\tcase err := <-errChan:\n\t\treturn err\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/scheduler.go",
        "code_start_line": 113,
        "code_end_line": 124,
        "code_key": "newHAManager",
        "code_value": "func (s *scheduler) newHAManager(ctx context.Context) easyha.HAManager {\n\thaManager := easyha.New(s, s.locker,\n\t\teasyha.WithNamespace(\"rdmaster-Scheduler\"),\n\t\teasyha.WithCheckInterval(5*time.Second),\n\t\teasyha.WithLockExpired(10*time.Second),\n\t\teasyha.WithLogger(*logs.GetLogger(ctx)))\n\tif s.haManager != nil {\n\t\ts.haManager.Close(ctx)\n\t}\n\ts.haManager = haManager\n\treturn haManager\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/mapper.go",
        "code_start_line": 130,
        "code_end_line": 138,
        "code_key": "encodeRDiskBackup",
        "code_value": "func encodeRDiskBackup(backup *backupDomain.Backup, dto *pb.RDiskBackup) *pb.RDiskBackup {\n\tdto.BackupId = backup.UUID.String()\n\tdto.CbsUuid = backup.DiskInfo.VolumeUUID.String()\n\tdto.Created = timestamppb.New(backup.CreateTime)\n\tdto.Status = mapperBackupStatus2RDiskBackupStatus(backup.Status)\n\tdto.Progress = int32(backup.Percentage)\n\tdto.Size = backup.DiskInfo.VolumeSize\n\treturn dto\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/mapper.go",
        "code_start_line": 140,
        "code_end_line": 147,
        "code_key": "encodeRDiskBackupView",
        "code_value": "func encodeRDiskBackupView(view *backupDomain.View, dto *pb.RDiskBackup) {\n\tdto.BackupId = view.UUID.String()\n\tdto.CbsUuid = view.VolumeUUID.String()\n\tdto.Created = timestamppb.New(view.CreateTime)\n\tdto.Status = mapperBackupStatus2RDiskBackupStatus(view.Status)\n\tdto.Progress = int32(view.Percentage)\n\tdto.Size = view.Size\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 468,
        "code_end_line": 477,
        "code_key": "checkQueryRDiskVolNoEmptyQuery",
        "code_value": "func checkQueryRDiskVolNoEmptyQuery(req *pb.QueryRDiskVolRequest) error {\n\tif req.AppId == 0 &&\n\t\tlen(req.PhyIds) == 0 &&\n\t\tlen(req.HostIps) == 0 &&\n\t\tlen(req.BdfIds) == 0 &&\n\t\tlen(req.CbsUuids) == 0 {\n\t\treturn errors.New(errors.ErrInvalidArgument, \"all query parameters are empty\")\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 480,
        "code_end_line": 485,
        "code_key": "checkQueryRDiskVolBdfIdsMustComeWithHostIps",
        "code_value": "func checkQueryRDiskVolBdfIdsMustComeWithHostIps(req *pb.QueryRDiskVolRequest) error {\n\tif len(req.BdfIds) > 0 && len(req.HostIps) == 0 {\n\t\treturn errors.New(errors.ErrInvalidArgument, \"bdf_ids must be used with host_ips together\")\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 80,
        "code_end_line": 102,
        "code_key": "checkPhysicalVolume",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) checkPhysicalVolume(ctx context.Context) error {\n\tif c.pv == nil {\n\t\treturn nil\n\t}\n\n\tif !c.pv.IP.Equal(c.HostIP) {\n\t\tlogs.Warn(ctx).\n\t\t\tStringer(\"host_ip\", c.HostIP).\n\t\t\tStringer(\"want\", c.pv.IP).\n\t\t\tMsg(\"host ip not match\")\n\t\treturn errors.New(rdiskDomain.ErrInvalidPhysicalVolume, \"host ip not match\")\n\t}\n\n\tif c.pv.BDF != c.BDF {\n\t\tlogs.Warn(ctx).\n\t\t\tStringer(\"bdf\", c.BDF).\n\t\t\tStringer(\"want\", c.pv.BDF).\n\t\t\tMsg(\"bdf not match\")\n\t\treturn errors.New(rdiskDomain.ErrInvalidPhysicalVolume, \"bdf not match\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 143,
        "code_end_line": 190,
        "code_key": "handleBindedVolume",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) handleBindedVolume(ctx context.Context) error {\n\tlogicalVolume, err := app.GetRegistry(ctx).Repositories.LogicalVolume.FindByAppIDAndUUID(ctx, *c.appId, *c.lvUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif logicalVolume.PhysicalVolume.Serial != c.Serial {\n\t\treturn errors.New(\n\t\t\trdiskDomain.ErrInvalidSerial,\n\t\t\tfmt.Sprintf(\"serial not match %s != %s\", string(logicalVolume.PhysicalVolume.Serial), c.Serial))\n\t}\n\n\tif logicalVolume.MustDefunctWithAuthorization() && !c.validateAuthorizeToken(ctx) {\n\t\treturn errors.New(rdiskDomain.ErrUnAuthorizedDefunct, \"unauthorized defunct, vol is binded to a account disk\")\n\t}\n\n\tc.lv = logicalVolume\n\tc.pv = logicalVolume.PhysicalVolume\n\tif err := c.checkPhysicalVolume(ctx); err != nil {\n\t\treturn err\n\t}\n\tc.drgroups, err = app.GetRegistry(ctx).Repositories.DRGroup.FindByMember(ctx, c.lv.AppID, c.lv.UUID.String())\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\tc.drgroups = nil\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tlogs.Warn(ctx).Str(\"token\", c.AuthorizeToken).\n\t\tStr(\"serial\", string(c.Serial)).\n\t\tStr(\"uuid\", c.lvUUID.String()).\n\t\tInt64(\"app_id\", int64(*c.appId)).\n\t\tMsg(\"authorized defunct binded volume\")\n\n\tif _, err := app.GetRegistry(ctx).StateMachines.LogicalVolume.Fire(ctx, c.lv.State,\n\t\trdiskDomain.LVEMarkDefunct, c); err != nil {\n\n\t\tlogs.Error(ctx).Err(err).\n\t\t\tStringer(\"serial\", c.Serial).\n\t\t\tInt64(\"app_id\", int64(*c.appId)).\n\t\t\tStringer(\"uuid\", c.lvUUID).\n\t\t\tMsg(\"failed to mark logical volume as defunct\")\n\t\treturn err\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 202,
        "code_end_line": 211,
        "code_key": "ensureLocks",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) ensureLocks(ctx context.Context) error {\n\trequiredLocks, err := c.queryRequiredLocks(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !slices.Equal(c.aquiredLocks, requiredLocks) {\n\t\treturn errors.New(dispatcher.ErrLockChanged, \"defunct failed\")\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_drgroup.go",
        "code_start_line": 176,
        "code_end_line": 198,
        "code_key": "getOrCreateDRGroup",
        "code_value": "func (c *UpdateLogicalVolumeDRGroupCommand) getOrCreateDRGroup(ctx context.Context, drgRepo drgroup.Repository, spec *drgroup.Spec) (*drgroup.DRGroup, error) {\n\tgroup, err := drgRepo.FindByName(ctx, c.AppID, spec.Name)\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\tgroup = drgroup.New(spec.Name, c.AppID)\n\t\t\tif spec.Affinity > 0 {\n\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t}\n\t\t\tif spec.Type != \"\" {\n\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t}\n\t\t\tif !c.DryRun {\n\t\t\t\terr := drgRepo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn group, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/attach_detach.go",
        "code_start_line": 45,
        "code_end_line": 57,
        "code_key": "CheckLogicalVolumeSingleAttached",
        "code_value": "func CheckLogicalVolumeSingleAttached(ctx context.Context, source rdiskDomain.LogicalVolumeState, target rdiskDomain.LogicalVolumeState, stateCtx app.LogicalVolumeContext) error {\n\tattachCnt := len(stateCtx.GetLogicalVolume().Attachments)\n\tswitch {\n\tcase attachCnt <= 0:\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotAttached, \"volume not attached\")\n\tcase attachCnt == 1:\n\t\treturn nil\n\tcase attachCnt > 1:\n\t\treturn errors.New(rdiskDomain.ErrVolumeAttachOnMultipleHost, \"volume attached on multiple host\")\n\tdefault:\n\t\treturn nil\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/attach_detach.go",
        "code_start_line": 64,
        "code_end_line": 76,
        "code_key": "CheckLogicalVolumeMultipleAttached",
        "code_value": "func CheckLogicalVolumeMultipleAttached(ctx context.Context, source rdiskDomain.LogicalVolumeState, target rdiskDomain.LogicalVolumeState, stateCtx app.LogicalVolumeContext) error {\n\tattachCnt := len(stateCtx.GetLogicalVolume().Attachments)\n\tswitch {\n\tcase attachCnt <= 0:\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotAttached, \"volume not attached\")\n\tcase attachCnt == 1:\n\t\treturn errors.New(rdiskDomain.ErrVolumeAttachOnSingleHost, \"volume attached on single host\")\n\tcase attachCnt > 1:\n\t\treturn nil\n\tdefault:\n\t\treturn nil\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/attach_detach.go",
        "code_start_line": 222,
        "code_end_line": 245,
        "code_key": "UpdateFlowControlOnInitiator",
        "code_value": "func UpdateFlowControlOnInitiator(ctx context.Context, source rdiskDomain.LogicalVolumeState,\n\ttarget rdiskDomain.LogicalVolumeState, stateCtx app.LogicalVolumeContext) (state rdiskDomain.LogicalVolumeState, err error) {\n\n\tdata := stateCtx.(AttachDetachContext)\n\tlv := data.GetLogicalVolume()\n\tattachment, err := lv.GetAttachment(data.GetHost())\n\tif err != nil {\n\t\treturn source, errors.New(rdiskDomain.ErrVolumeNotAttached, fmt.Sprintf(\"volume not attached to host %s\", data.GetHost().String()))\n\t}\n\n\tblk := app.GetRegistry(ctx).Factories.BlockAgentClient(data.GetHost().String())\n\treq := cbs_blk_flow_agent.NewUpdateRDiskFlowControlRequest(lv.UUID.String(), lv.PhysicalVolume.DiskID)\n\treq.SpdkDriver = attachment.Options.SPDKDriver\n\treq.SetRead(attachment.FlowControlSpec.MaxReadIOPS, attachment.FlowControlSpec.MaxReadMBps)\n\treq.SetWrite(attachment.FlowControlSpec.MaxWriteIOPS, attachment.FlowControlSpec.MaxWriteMBps)\n\treq.SetReadWrite(attachment.FlowControlSpec.MaxRWIOPS, attachment.FlowControlSpec.MaxRWMBps)\n\n\terr = blk.UpdateRDiskFlowControl(ctx, req)\n\tif err != nil {\n\t\treturn source, err\n\t}\n\n\treturn target, err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/attach_detach.go",
        "code_start_line": 247,
        "code_end_line": 297,
        "code_key": "UpdateFlowControlOnAllInitiator",
        "code_value": "func UpdateFlowControlOnAllInitiator(ctx context.Context, source rdiskDomain.LogicalVolumeState,\n\ttarget rdiskDomain.LogicalVolumeState, stateCtx app.LogicalVolumeContext) (state rdiskDomain.LogicalVolumeState, err error) {\n\n\tlv := stateCtx.GetLogicalVolume()\n\tif len(lv.Attachments) == 0 {\n\t\tlogs.Info(ctx).Str(\"uuid\", lv.UUID.String()).Msg(\"no attachment found, skip update flow control\")\n\t\treturn target, nil\n\t}\n\n\tvar wg sync.WaitGroup\n\tvar collectedErr []error = make([]error, len(lv.Attachments))\n\n\twg.Add(len(lv.Attachments))\n\n\tfor idx, attachment := range lv.Attachments {\n\t\tgo func(idx int, attachment *rdiskDomain.VolumeAttachment) {\n\t\t\tdefer wg.Done()\n\n\t\t\tblk := app.GetRegistry(ctx).Factories.BlockAgentClient(attachment.IP.String())\n\t\t\treq := cbs_blk_flow_agent.NewUpdateRDiskFlowControlRequest(lv.UUID.String(), lv.PhysicalVolume.DiskID)\n\t\t\treq.SpdkDriver = attachment.Options.SPDKDriver\n\t\t\treq.SetRead(attachment.FlowControlSpec.MaxReadIOPS, attachment.FlowControlSpec.MaxReadMBps)\n\t\t\treq.SetWrite(attachment.FlowControlSpec.MaxWriteIOPS, attachment.FlowControlSpec.MaxWriteMBps)\n\t\t\treq.SetReadWrite(attachment.FlowControlSpec.MaxRWIOPS, attachment.FlowControlSpec.MaxRWMBps)\n\n\t\t\terr = blk.UpdateRDiskFlowControl(ctx, req)\n\t\t\tif err != nil {\n\t\t\t\tlogs.Error(ctx).Err(err).Str(\"ip\", attachment.IP.String()).Msg(\"failed to update flow control\")\n\t\t\t}\n\t\t\tcollectedErr[idx] = err\n\t\t}(idx, attachment)\n\t}\n\n\twg.Wait()\n\n\t// collect error ip and print error count\n\tvar errList []error\n\tvar errIPs []string\n\tfor idx, err := range collectedErr {\n\t\tif err != nil {\n\t\t\terrList = append(errList, err)\n\t\t\terrIPs = append(errIPs, lv.Attachments[idx].IP.String())\n\t\t}\n\t}\n\tif len(errList) > 0 {\n\t\tlogs.Warn(ctx).Errs(\"errors\", errList).Strs(\"host_ips\", errIPs).Msg(\"failed to update flow control on some initiators\")\n\t\treturn source, errors.New(rdiskDomain.ErrUpdateFlowControl, fmt.Sprintf(\"failed to update flow control on some initiators: %v, errors: %v\", errIPs, errList))\n\t}\n\n\treturn target, err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/drgroups.go",
        "code_start_line": 22,
        "code_end_line": 71,
        "code_key": "AddHostToDRGroup",
        "code_value": "func AddHostToDRGroup(ctx context.Context, source rdiskDomain.LogicalVolumeState, target rdiskDomain.LogicalVolumeState, stateCtx app.LogicalVolumeContext) (rdiskDomain.LogicalVolumeState, error) {\n\tdata := stateCtx.(CreateLogicalVolumeContext)\n\tvol := data.GetLogicalVolume()\n\tphy := data.GetPhysicalVolume()\n\tspecs := data.GetDRGroupSpecList()\n\trepo := app.GetRegistry(ctx).Repositories.DRGroup\n\tif len(specs) == 0 {\n\t\treturn target, nil\n\t}\n\tfor _, spec := range specs {\n\t\tgroup, err := repo.FindByName(ctx, vol.AppID, spec.Name)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\tgroup = drgroup.New(spec.Name, vol.AppID)\n\t\t\t\tif spec.Affinity > 0 {\n\t\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t\t}\n\t\t\t\tif spec.Type != \"\" {\n\t\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t\t}\n\t\t\t\terr = repo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn source, err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn source, err\n\t\t\t}\n\t\t}\n\t\tif spec.Affinity > 0 && group.Affinity != spec.Affinity {\n\t\t\tlogs.Info(ctx).Uint64(\"app_id\", uint64(vol.AppID)).\n\t\t\t\tStr(\"group_name\", spec.Name).\n\t\t\t\tInt(\"old_affinity\", group.Affinity).\n\t\t\t\tInt(\"new_affinity\", spec.Affinity).\n\t\t\t\tMsg(\"update affinity of drgroup\")\n\t\t\tgroup.Affinity = spec.Affinity\n\t\t}\n\t\tsubGroup := spec.SubGroup\n\t\tif subGroup == \"\" {\n\t\t\t// 如果没有指定子组，则使用远端 SSD UUID 作为子组名称\n\t\t\t// 相当于每块盘都是一个子组，相当于没有使用子组功能\n\t\t\tsubGroup = vol.UUID.String()\n\t\t}\n\t\terr = group.AddMember(vol.UUID.String(), subGroup, phy.IP.String())\n\t\tif err != nil {\n\t\t\treturn source, err\n\t\t}\n\t}\n\n\treturn target, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 138,
        "code_end_line": 209,
        "code_key": "StepGivenARegistry",
        "code_value": "func StepGivenARegistry(db *gorm.DB, t *testing.T, ctx context.Context) (*app.Registry, context.Context) {\n\t// 初始化Locker\n\tdlockConf := dlock_mysql.Config{\n\t\tTableName:      \"dm_locks\",\n\t\tLockColumn:     \"lock_key\",\n\t\tExpireColumn:   \"expired\",\n\t\tTokenColumn:    \"lock_token\",\n\t\tLockTypeColumn: \"lock_type\",\n\t\tLockNumsColumn: \"lock_count\",\n\t}\n\tapp.GlobalRegistry.Locker = dlock_mysql.New(db, dlockConf)\n\t// 初始化Dispatcher\n\tapp.GlobalRegistry.Dispatcher = dispatcher.NewDispatcher(ctx, app.GlobalRegistry.Locker)\n\t// 初始化状态机\n\tapp.GlobalRegistry.StateMachines.Backup = backup.FsmFactory()\n\tapp.GlobalRegistry.StateMachines.Benchmark = benchmark.FsmFactory()\n\tbackup.SetDefaultFactory(\"\")\n\tapp.GlobalRegistry.Config = app.Config{\n\t\tCOSCredentials: backup.COSCredentials{\n\t\t\tRegion:     \"\",\n\t\t\tAppID:      0,\n\t\t\tSecretID:   \"\",\n\t\t\tSecretKey:  \"\",\n\t\t\tToken:      \"\",\n\t\t\tBucket:     \"\",\n\t\t\tBaseDomain: \"\",\n\t\t\tStsDomain:  \"\",\n\t\t},\n\t}\n\t// 初始化Repositories\n\tapp.GlobalRegistry.Repositories.UoWFactory = repositories.NewFactory(db)\n\trepositories.RegisterImpl()\n\t// 初始化Factories\n\tapp.GlobalRegistry.Factories.BlockAgentClient = func(s string, options ...cbs_blk_flow_agent.BlockAgentOptions) cbs_blk_flow_agent.Interface {\n\t\tctrl := gomock.NewController(t)\n\t\t// defer ctrl.Finish()\n\t\tmockClient := mocks.NewMockInterface(ctrl)\n\t\tmockClient.EXPECT().CreateHarpController(gomock.Any(), gomock.Any()).Return(&cbs_blk_flow_agent.CreateHarpControllerResult{\n\t\t\tPort:   1234,\n\t\t\tDiskId: 0,\n\t\t}, nil).AnyTimes()\n\t\tmockClient.EXPECT().CreateRDiskSpdkVolume(gomock.Any(), gomock.Any()).Return(&cbs_blk_flow_agent.CreateRDiskSpdkVolumeResult{\n\t\t\tSpdkDriver: \"abc\",\n\t\t}, nil).AnyTimes()\n\t\tmockClient.EXPECT().UpdateRDiskFlowControl(gomock.Any(), gomock.Any()).Return(nil).AnyTimes()\n\t\tmockClient.EXPECT().DeleteRDiskSpdkVolume(gomock.Any(), gomock.Any()).Return(nil).AnyTimes()\n\t\tmockClient.EXPECT().DeleteHarpController(gomock.Any(), gomock.Any()).Return(nil).AnyTimes()\n\t\tmockClient.EXPECT().DeleteHarpBdev(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil).AnyTimes()\n\t\tmockClient.EXPECT().CreateHarpBdev(gomock.Any(), gomock.Any(), gomock.Any()).Return(&cbs_blk_flow_agent.CreateHarpBdevResult{\n\t\t\tSizeBytes: 512,\n\t\t\tBlockSize: 512,\n\t\t}, nil).AnyTimes()\n\t\tmockClient.EXPECT().AsyncQueryRdiskPerfBenchmark(gomock.Any(), gomock.Any()).Return(123, nil).AnyTimes()\n\t\tmockClient.EXPECT().DropRDiskInflightIO(gomock.Any(), gomock.Any()).Return(&cbs_blk_flow_agent.DropRDiskInflightIOResponse{\n\t\t\tDiskID: 0,\n\t\t}, nil).AnyTimes()\n\t\tmockClient.EXPECT().DeleteRDiskSpdkVolume(gomock.Any(), gomock.Any()).Return(nil).AnyTimes()\n\t\treturn mockClient\n\t}\n\tapp.GlobalRegistry.Factories.COSTmpCredential = cos.NewTmpSecret\n\tapp.GlobalRegistry.Factories.COSClient = cos.New\n\t// 初始化viewer\n\tapp.GlobalRegistry.Viewers.PhysicalVolume = viewers.NewPhysicalVolumeViewer(db)\n\tapp.GlobalRegistry.Viewers.LogicalVolume = viewers.NewLogicalVolumeViewer(db)\n\tapp.GlobalRegistry.Viewers.DRGroup = viewers.NewDRGroupViewer(db)\n\tapp.GlobalRegistry.Viewers.Backup = viewers.NewBackupViewer(db)\n\tapp.GlobalRegistry.Viewers.Benchmark = viewers.NewBenchmarkViewer(db)\n\n\tregistry := app.GetRegistry(ctx)\n\tctx = app.SetRegistry(ctx, registry)\n\treturn registry, ctx\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 214,
        "code_end_line": 239,
        "code_key": "StepGivenAPhysicalVol",
        "code_value": "func StepGivenAPhysicalVol(registry *app.Registry, value interface{}) *rdiskDomain.PhysicalVolume {\n\tphysicalVol := &rdiskDomain.PhysicalVolume{\n\t\tEntityMixin:  rdiskDomain.EntityMixin{ID: 1},\n\t\tSerial:       \"12345\",\n\t\tIP:           net.IP{127, 0, 0, 1},\n\t\tBDF:          \"bdf\",\n\t\tDiskID:       0,\n\t\tState:        rdiskDomain.PhysicalVolumeState(value.(int)),\n\t\tSize:         1,\n\t\tVolumeType:   \"NVME\",\n\t\tZoneID:       1,\n\t\tBlockSize:    512,\n\t\tRealSize:     5120,\n\t\tPort:         1,\n\t\tDataNodeType: \"unknown\",\n\t\tCuf:          \"清远-清新-C2\",\n\t}\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\terr := registry.Repositories.PhysicalVolume.Add(workerCtx, physicalVol)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn physicalVol\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 244,
        "code_end_line": 277,
        "code_key": "StepGivenPhysicalVols",
        "code_value": "func StepGivenPhysicalVols(registry *app.Registry, value interface{}, num interface{}) []*rdiskDomain.PhysicalVolume {\n\tvar physicalVols []*rdiskDomain.PhysicalVolume\n\tfor i := 0; i < num.(int); i++ {\n\t\tphysicalVols = append(physicalVols, &rdiskDomain.PhysicalVolume{\n\t\t\tEntityMixin:  rdiskDomain.EntityMixin{},\n\t\t\tSerial:       rdiskDomain.Serial(\"111\" + strconv.Itoa(i)),\n\t\t\tIP:           net.IP{127, 0, byte(((i + 2) / 255) % 255), byte((i + 2) % 255)},\n\t\t\tBDF:          \"bdf\",\n\t\t\tDiskID:       0,\n\t\t\tState:        rdiskDomain.PhysicalVolumeState(value.(int)),\n\t\t\tSize:         1,\n\t\t\tVolumeType:   \"\",\n\t\t\tZoneID:       1,\n\t\t\tBlockSize:    512,\n\t\t\tRealSize:     5120,\n\t\t\tPort:         1,\n\t\t\tDataNodeType: \"\",\n\t\t\tCuf:          \"清远-清新-C2\",\n\t\t})\n\t}\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\tfor _, vol := range physicalVols {\n\t\terr := registry.Repositories.PhysicalVolume.Add(workerCtx, vol)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\terr := uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn physicalVols\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 282,
        "code_end_line": 304,
        "code_key": "StepGivenALogicalVol",
        "code_value": "func StepGivenALogicalVol(registry *app.Registry, physicalVol *rdiskDomain.PhysicalVolume, value interface{}) *rdiskDomain.LogicalVolume {\n\tlogicalVol := &rdiskDomain.LogicalVolume{\n\t\tEntityMixin:     rdiskDomain.EntityMixin{ID: 1},\n\t\tUUID:            uuid.Must(uuid.NewRandom()),\n\t\tState:           rdiskDomain.LogicalVolumeState(value.(int)),\n\t\tSize:            1,\n\t\tAppID:           123,\n\t\tZoneID:          1,\n\t\tDiskType:        \"\",\n\t\tVolumeType:      \"\",\n\t\tFlowControlSpec: rdiskDomain.FlowControlSpec{},\n\t\tPhysicalVolume:  physicalVol,\n\t\tAttachments:     nil,\n\t}\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\terr := registry.Repositories.LogicalVolume.Add(workerCtx, logicalVol)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn logicalVol\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 351,
        "code_end_line": 364,
        "code_key": "StepThenLogicalVolStateShouldBe",
        "code_value": "func StepThenLogicalVolStateShouldBe(logicalVol *rdiskDomain.LogicalVolume, registry *app.Registry, db *gorm.DB, database string, value interface{}) *rdiskDomain.LogicalVolume {\n\tdb.Exec(fmt.Sprintf(\"USE `%s`\", database))\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\tnewLogicalVol, err := registry.Repositories.LogicalVolume.FindByAppIDAndUUID(workerCtx, logicalVol.AppID, logicalVol.UUID)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif newLogicalVol.State != rdiskDomain.LogicalVolumeState(value.(int)) {\n\t\tpanic(\"LogicalVol state error\")\n\t}\n\treturn newLogicalVol\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 433,
        "code_end_line": 449,
        "code_key": "StepThenPhysicalVolShouldBe",
        "code_value": "func StepThenPhysicalVolShouldBe(physicalVol *rdiskDomain.PhysicalVolume, registry *app.Registry, db *gorm.DB, database string, field string, value interface{}) *rdiskDomain.PhysicalVolume {\n\tdb.Exec(fmt.Sprintf(\"USE `%s`\", database))\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\tnewPhysicalVol, err := registry.Repositories.PhysicalVolume.FindBySerial(workerCtx, physicalVol.Serial)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tswitch field {\n\tcase \"cuf\":\n\t\tif newPhysicalVol.Cuf != rdiskDomain.Cuf(value.(string)) {\n\t\t\tpanic(\"Result error\")\n\t\t}\n\t}\n\treturn newPhysicalVol\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 618,
        "code_end_line": 630,
        "code_key": "StepThenPhysicalVolShouldBeRight",
        "code_value": "func StepThenPhysicalVolShouldBeRight(physicalVol *rdiskDomain.PhysicalVolume, registry *app.Registry, t *testing.T) {\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\tnewPhysicalVol, err := registry.Repositories.PhysicalVolume.FindBySerial(workerCtx, physicalVol.Serial)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif physicalVol.BDF != newPhysicalVol.BDF || physicalVol.Cuf != newPhysicalVol.Cuf || rdiskDomain.PVSInited != newPhysicalVol.State || physicalVol.DataNodeType != newPhysicalVol.DataNodeType ||\n\t\t!physicalVol.IP.Equal(newPhysicalVol.IP) || physicalVol.VolumeType != newPhysicalVol.VolumeType || physicalVol.Size != newPhysicalVol.Size {\n\t\tpanic(\"data error\")\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go",
        "code_start_line": 22,
        "code_end_line": 47,
        "code_key": "FindByAppIDAndUUID",
        "code_value": "func (logicalVolumeRepositoryImpl) FindByAppIDAndUUID(ctx context.Context, appID users.AppID, id uuid.UUID) (*rdiskDomain.LogicalVolume, error) {\n\tuow := getUow(ctx)\n\tvol := metadb.DmRdisk{}\n\tresult := uow.tx.\n\t\tPreload(\"Attachments\").\n\t\tPreload(\"DmPhyDisk\").\n\t\tFirst(&vol, \"uuid = ? AND app_id = ?\", id.String(), appID)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tlv, err := fromDmRDiskToModel(ctx, &vol)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlv = uow.trackedLogicalVolumes.Add(lv)\n\tif lv.PhysicalVolume != nil {\n\t\tlv.PhysicalVolume = uow.trackedPhyVolumes.Add(lv.PhysicalVolume)\n\t}\n\treturn lv, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 55,
        "code_end_line": 61,
        "code_key": "FindByAppIDAndUUID",
        "code_value": "func (m *MockLogicalVolumeRepository) FindByAppIDAndUUID(arg0 context.Context, arg1 users.AppID, arg2 uuid.UUID) (*rdiskDomain.LogicalVolume, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByAppIDAndUUID\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(*rdiskDomain.LogicalVolume)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 64,
        "code_end_line": 67,
        "code_key": "FindByAppIDAndUUID",
        "code_value": "func (mr *MockLogicalVolumeRepositoryMockRecorder) FindByAppIDAndUUID(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByAppIDAndUUID\", reflect.TypeOf((*MockLogicalVolumeRepository)(nil).FindByAppIDAndUUID), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go",
        "code_start_line": 49,
        "code_end_line": 74,
        "code_key": "FindByID",
        "code_value": "func (l logicalVolumeRepositoryImpl) FindByID(ctx context.Context, id uuid.UUID) (*rdiskDomain.LogicalVolume, error) {\n\tuow := getUow(ctx)\n\tvol := metadb.DmRdisk{}\n\tresult := uow.tx.\n\t\tPreload(\"Attachments\").\n\t\tPreload(\"DmPhyDisk\").\n\t\tFirst(&vol, \"uuid = ?\", id.String())\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tlv, err := fromDmRDiskToModel(ctx, &vol)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlv = uow.trackedLogicalVolumes.Add(lv)\n\tif lv.PhysicalVolume != nil {\n\t\tlv.PhysicalVolume = uow.trackedPhyVolumes.Add(lv.PhysicalVolume)\n\t}\n\treturn lv, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 70,
        "code_end_line": 76,
        "code_key": "FindByID",
        "code_value": "func (m *MockLogicalVolumeRepository) FindByID(arg0 context.Context, arg1 uuid.UUID) (*rdiskDomain.LogicalVolume, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByID\", arg0, arg1)\n\tret0, _ := ret[0].(*rdiskDomain.LogicalVolume)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 79,
        "code_end_line": 82,
        "code_key": "FindByID",
        "code_value": "func (mr *MockLogicalVolumeRepositoryMockRecorder) FindByID(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByID\", reflect.TypeOf((*MockLogicalVolumeRepository)(nil).FindByID), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go",
        "code_start_line": 21,
        "code_end_line": 38,
        "code_key": "FindBySerial",
        "code_value": "func (p *physicalVolumeRepositoryImpl) FindBySerial(ctx context.Context, serial rdiskDomain.Serial) (*rdiskDomain.PhysicalVolume, error) {\n\tuow := getUow(ctx)\n\tvar vol metadb.DmPhydisk\n\tresult := uow.tx.Where(\"serial = ?\", string(serial)).First(&vol)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\t// 覆盖 gorm 的错误\n\t\t\treturn nil, errors.New(rdiskDomain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tpv := fromDmPhyDiskToPhysicalVolume(ctx, &vol)\n\tpv = uow.trackedPhyVolumes.Add(pv)\n\treturn pv, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 83,
        "code_end_line": 89,
        "code_key": "FindBySerial",
        "code_value": "func (m *MockPhysicalVolumeRepository) FindBySerial(arg0 context.Context, arg1 rdiskDomain.Serial) (*rdiskDomain.PhysicalVolume, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindBySerial\", arg0, arg1)\n\tret0, _ := ret[0].(*rdiskDomain.PhysicalVolume)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 92,
        "code_end_line": 95,
        "code_key": "FindBySerial",
        "code_value": "func (mr *MockPhysicalVolumeRepositoryMockRecorder) FindBySerial(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindBySerial\", reflect.TypeOf((*MockPhysicalVolumeRepository)(nil).FindBySerial), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go",
        "code_start_line": 40,
        "code_end_line": 57,
        "code_key": "FindByIPAndBDF",
        "code_value": "func (p *physicalVolumeRepositoryImpl) FindByIPAndBDF(ctx context.Context, ip net.IP, bdf rdiskDomain.BDF) (*rdiskDomain.PhysicalVolume, error) {\n\tuow := getUow(ctx)\n\tvar vol metadb.DmPhydisk\n\tresult := uow.tx.Where(\"host_ip = ? AND bdf = ?\", ip.String(), string(bdf)).Find(&vol)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\t// 覆盖 gorm 的错误\n\t\t\treturn nil, errors.New(rdiskDomain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tpv := fromDmPhyDiskToPhysicalVolume(ctx, &vol)\n\tpv = uow.trackedPhyVolumes.Add(pv)\n\treturn pv, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 68,
        "code_end_line": 74,
        "code_key": "FindByIPAndBDF",
        "code_value": "func (m *MockPhysicalVolumeRepository) FindByIPAndBDF(arg0 context.Context, arg1 net.IP, arg2 rdiskDomain.BDF) (*rdiskDomain.PhysicalVolume, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByIPAndBDF\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(*rdiskDomain.PhysicalVolume)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 77,
        "code_end_line": 80,
        "code_key": "FindByIPAndBDF",
        "code_value": "func (mr *MockPhysicalVolumeRepositoryMockRecorder) FindByIPAndBDF(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByIPAndBDF\", reflect.TypeOf((*MockPhysicalVolumeRepository)(nil).FindByIPAndBDF), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
        "code_start_line": 20,
        "code_end_line": 29,
        "code_key": "FindByName",
        "code_value": "func (d drgroupRepositoryImpl) FindByName(ctx context.Context, appId users.AppID, name string) (*drgroup.DRGroup, error) {\n\tresults, err := d.FindByNames(ctx, appId, []string{name})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(results) < 1 {\n\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"disaster recovery group not exists\")\n\t}\n\treturn results[0], nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/drgroup.go",
        "code_start_line": 75,
        "code_end_line": 90,
        "code_key": "FindByName",
        "code_value": "func (d *drgroupViewerImpl) FindByName(ctx context.Context, appId users.AppID, name string) (*drgroup.View, error) {\n\tvar (\n\t\tresultView drgroup.View\n\t\tdataObject metadb.DmDrgroup\n\t)\n\n\tresult := d.db.WithContext(ctx).First(&dataObject, \"app_id = ? and name = ?\", appId, name)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"group not exist\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\td.translate(&dataObject, &resultView)\n\treturn &resultView, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 98,
        "code_end_line": 104,
        "code_key": "FindByName",
        "code_value": "func (m *MockRepository) FindByName(arg0 context.Context, arg1 users.AppID, arg2 string) (*drgroup.DRGroup, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByName\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(*drgroup.DRGroup)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 107,
        "code_end_line": 110,
        "code_key": "FindByName",
        "code_value": "func (mr *MockRepositoryMockRecorder) FindByName(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByName\", reflect.TypeOf((*MockRepository)(nil).FindByName), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/view.go",
        "code_start_line": 70,
        "code_end_line": 76,
        "code_key": "FindByName",
        "code_value": "func (m *MockViewer) FindByName(arg0 context.Context, arg1 users.AppID, arg2 string) (*drgroup.View, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByName\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(*drgroup.View)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/view.go",
        "code_start_line": 79,
        "code_end_line": 82,
        "code_key": "FindByName",
        "code_value": "func (mr *MockViewerMockRecorder) FindByName(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByName\", reflect.TypeOf((*MockViewer)(nil).FindByName), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
        "code_start_line": 31,
        "code_end_line": 52,
        "code_key": "FindByNames",
        "code_value": "func (d drgroupRepositoryImpl) FindByNames(ctx context.Context, appId users.AppID, names []string) ([]*drgroup.DRGroup, error) {\n\tuow := getUow(ctx)\n\tgroup := []metadb.DmDrgroup{}\n\tresult := uow.tx.\n\t\tPreload(\"Members\").\n\t\tFind(&group, \"app_id = ? and name in ?\", appId, names)\n\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"disaster recovery group not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tresults := make([]*drgroup.DRGroup, len(group))\n\tfor i := range group {\n\t\tresults[i] = uow.trackedDRGroups.Add(fromDmDRGroupToModel(&group[i]))\n\t}\n\treturn results, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 113,
        "code_end_line": 119,
        "code_key": "FindByNames",
        "code_value": "func (m *MockRepository) FindByNames(arg0 context.Context, arg1 users.AppID, arg2 []string) ([]*drgroup.DRGroup, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByNames\", arg0, arg1, arg2)\n\tret0, _ := ret[0].([]*drgroup.DRGroup)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 122,
        "code_end_line": 125,
        "code_key": "FindByNames",
        "code_value": "func (mr *MockRepositoryMockRecorder) FindByNames(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByNames\", reflect.TypeOf((*MockRepository)(nil).FindByNames), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
        "code_start_line": 58,
        "code_end_line": 94,
        "code_key": "FindByMembers",
        "code_value": "func (d drgroupRepositoryImpl) FindByMembers(ctx context.Context, appId users.AppID, members []string) ([]*drgroup.DRGroup, error) {\n\tuow := getUow(ctx)\n\tgroup := []metadb.DmDrgroup{}\n\n\tmembersResult := []metadb.DmDrgroupMembers{}\n\tresult := uow.tx.\n\t\tFind(&membersResult, \"app_id = ? and member_id in ?\", appId, members)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tnames := make([]string, 0, len(members))\n\tfor i := range membersResult {\n\t\tnames = append(names, membersResult[i].GroupName)\n\t}\n\tresult = uow.tx.\n\t\tPreload(\"Members\").\n\t\tFind(&group, \"app_id = ? and name in ?\", appId, names)\n\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"disaster recovery group not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tresults := make([]*drgroup.DRGroup, len(group))\n\tfor i := range group {\n\t\tresults[i] = fromDmDRGroupToModel(&group[i])\n\t\tresults[i] = uow.trackedDRGroups.Add(results[i])\n\t}\n\treturn results, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/drgroup.go",
        "code_start_line": 92,
        "code_end_line": 124,
        "code_key": "FindByMembers",
        "code_value": "func (d *drgroupViewerImpl) FindByMembers(ctx context.Context, appId users.AppID, members []string) ([]*drgroup.View, error) {\n\tvar (\n\t\tresultViews       []drgroup.View\n\t\tresultViewRef     []*drgroup.View\n\t\tdataObjects       []*metadb.DmDrgroup\n\t\tdataObjectMembers []*metadb.DmDrgroupMembers\n\t)\n\tresult := d.db.WithContext(ctx).Find(&dataObjectMembers, \"app_id = ? and member_id in ?\", appId, members)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"group not exist\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tgroupNames := make([]string, len(dataObjectMembers))\n\tfor i := range dataObjectMembers {\n\t\tgroupNames[i] = dataObjectMembers[i].GroupName\n\t}\n\tresult = d.db.WithContext(ctx).Find(&dataObjects, \"app_id = ? and name in ?\", appId, groupNames)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"group not exist\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tresultViews = make([]drgroup.View, len(dataObjects))\n\tresultViewRef = make([]*drgroup.View, len(dataObjects))\n\tfor i := range dataObjects {\n\t\tresultViewRef[i] = &resultViews[i]\n\t\td.translate(dataObjects[i], resultViewRef[i])\n\t}\n\treturn resultViewRef, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 83,
        "code_end_line": 89,
        "code_key": "FindByMembers",
        "code_value": "func (m *MockRepository) FindByMembers(arg0 context.Context, arg1 users.AppID, arg2 []string) ([]*drgroup.DRGroup, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByMembers\", arg0, arg1, arg2)\n\tret0, _ := ret[0].([]*drgroup.DRGroup)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 92,
        "code_end_line": 95,
        "code_key": "FindByMembers",
        "code_value": "func (mr *MockRepositoryMockRecorder) FindByMembers(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByMembers\", reflect.TypeOf((*MockRepository)(nil).FindByMembers), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/view.go",
        "code_start_line": 55,
        "code_end_line": 61,
        "code_key": "FindByMembers",
        "code_value": "func (m *MockViewer) FindByMembers(arg0 context.Context, arg1 users.AppID, arg2 []string) ([]*drgroup.View, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByMembers\", arg0, arg1, arg2)\n\tret0, _ := ret[0].([]*drgroup.View)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/view.go",
        "code_start_line": 64,
        "code_end_line": 67,
        "code_key": "FindByMembers",
        "code_value": "func (mr *MockViewerMockRecorder) FindByMembers(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByMembers\", reflect.TypeOf((*MockViewer)(nil).FindByMembers), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/logi_vol.go",
        "code_start_line": 80,
        "code_end_line": 102,
        "code_key": "ProbeAppID",
        "code_value": "func (v *logicalVolumeViewerImpl) ProbeAppID(ctx context.Context, uuids []uuid.UUID, serial []rdiskDomain.Serial) (users.AppID, error) {\n\tvar (\n\t\tdataObjects *metadb.DmRdisk\n\t)\n\tstmt := v.db.WithContext(ctx).Where(\"1 = 1\")\n\tif len(uuids) > 0 {\n\t\tstmt = stmt.Where(\"uuid in ?\", functools.Map(uuids, func(i uuid.UUID) string { return i.String() }))\n\t}\n\tif len(serial) > 0 {\n\t\tstmt = stmt.Where(\"phydisk_serial in ?\", functools.Map(serial, func(i rdiskDomain.Serial) string { return string(i) }))\n\t}\n\tresult := stmt.Select(\"app_id\").Limit(1).Find(&dataObjects)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn users.AppID(0), nil\n\t\t}\n\t\treturn users.AppID(0), result.Error\n\t}\n\tif dataObjects.AppID == 0 {\n\t\treturn users.AppID(0), errors.New(rdiskDomain.ErrVolumeNotExists, \"logical volume not exist\")\n\t}\n\treturn users.AppID(dataObjects.AppID), nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_view.go",
        "code_start_line": 71,
        "code_end_line": 77,
        "code_key": "ProbeAppID",
        "code_value": "func (m *MockLogicalVolumeViewer) ProbeAppID(arg0 context.Context, arg1 []uuid.UUID, arg2 []rdiskDomain.Serial) (users.AppID, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"ProbeAppID\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(users.AppID)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_view.go",
        "code_start_line": 80,
        "code_end_line": 83,
        "code_key": "ProbeAppID",
        "code_value": "func (mr *MockLogicalVolumeViewerMockRecorder) ProbeAppID(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ProbeAppID\", reflect.TypeOf((*MockLogicalVolumeViewer)(nil).ProbeAppID), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/logi_vol.go",
        "code_start_line": 109,
        "code_end_line": 132,
        "code_key": "FindByIDs",
        "code_value": "func (v *logicalVolumeViewerImpl) FindByIDs(ctx context.Context, appID users.AppID, id []uuid.UUID) ([]*rdiskDomain.LogicalVolume, error) {\n\tvar (\n\t\tresultViews   []rdiskDomain.LogicalVolume\n\t\tresultViewRef []*rdiskDomain.LogicalVolume\n\t\tdataObjects   []*metadb.DmRdisk\n\t)\n\n\tuuidStrSlice := functools.Map(id, func(i uuid.UUID) string { return i.String() })\n\tresult := v.db.WithContext(ctx).Preload(\"DmPhyDisk\").Find(&dataObjects, \"app_id = ? and uuid in ?\", appID, uuidStrSlice)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(rdiskDomain.ErrVolumeNotExists, \"logical volume not exist\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\n\tresultViews = make([]rdiskDomain.LogicalVolume, len(dataObjects))\n\tresultViewRef = make([]*rdiskDomain.LogicalVolume, len(dataObjects))\n\tfor i := range dataObjects {\n\t\tresultViewRef[i] = &resultViews[i]\n\t\tv.translate(dataObjects[i], resultViewRef[i])\n\t}\n\treturn resultViewRef, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_view.go",
        "code_start_line": 41,
        "code_end_line": 47,
        "code_key": "FindByIDs",
        "code_value": "func (m *MockLogicalVolumeViewer) FindByIDs(arg0 context.Context, arg1 users.AppID, arg2 []uuid.UUID) ([]*rdiskDomain.LogicalVolume, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByIDs\", arg0, arg1, arg2)\n\tret0, _ := ret[0].([]*rdiskDomain.LogicalVolume)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_view.go",
        "code_start_line": 50,
        "code_end_line": 53,
        "code_key": "FindByIDs",
        "code_value": "func (mr *MockLogicalVolumeViewerMockRecorder) FindByIDs(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByIDs\", reflect.TypeOf((*MockLogicalVolumeViewer)(nil).FindByIDs), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/backup.go",
        "code_start_line": 19,
        "code_end_line": 41,
        "code_key": "FindByAppID",
        "code_value": "func (v *backupViewerImpl) FindByAppID(ctx context.Context, appID users.AppID, uuids, rdisks []string) ([]*backup.View, error) {\n\tvar (\n\t\tviews []*backup.View\n\t\tdtos  []*metadb.DmRdiskBackup\n\t)\n\tquery := v.db.WithContext(ctx).Where(\"app_id = ?\", appID)\n\tif len(uuids) > 0 {\n\t\tquery = query.Where(\"uuid in ?\", uuids)\n\t}\n\tif len(rdisks) > 0 {\n\t\tquery = query.Where(\"rdisk_uuid in ?\", rdisks)\n\t}\n\tresult := query.Find(&dtos)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\tviews = functools.MapRef(make([]backup.View, len(dtos)))\n\tfor i := range dtos {\n\t\tv.translate(dtos[i], views[i])\n\t}\n\n\treturn views, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/drgroup.go",
        "code_start_line": 126,
        "code_end_line": 147,
        "code_key": "FindByAppID",
        "code_value": "func (d *drgroupViewerImpl) FindByAppID(ctx context.Context, appId users.AppID) ([]*drgroup.View, error) {\n\tvar (\n\t\tresultViews       []drgroup.View\n\t\tresultViewRef     []*drgroup.View\n\t\tdataObjects       []*metadb.DmDrgroup\n\t\tdataObjectMembers []*metadb.DmDrgroupMembers\n\t)\n\tresult := d.db.WithContext(ctx).Find(&dataObjects).Where(\"app_id = ?\", appId, dataObjectMembers)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"group not exist\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tresultViews = make([]drgroup.View, len(dataObjects))\n\tresultViewRef = make([]*drgroup.View, len(dataObjects))\n\tfor i := range dataObjects {\n\t\tresultViewRef[i] = &resultViews[i]\n\t\td.translate(dataObjects[i], resultViewRef[i])\n\t}\n\treturn resultViewRef, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/view.go",
        "code_start_line": 40,
        "code_end_line": 46,
        "code_key": "FindByAppID",
        "code_value": "func (m *MockViewer) FindByAppID(arg0 context.Context, arg1 users.AppID) ([]*drgroup.View, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByAppID\", arg0, arg1)\n\tret0, _ := ret[0].([]*drgroup.View)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/view.go",
        "code_start_line": 49,
        "code_end_line": 52,
        "code_key": "FindByAppID",
        "code_value": "func (mr *MockViewerMockRecorder) FindByAppID(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByAppID\", reflect.TypeOf((*MockViewer)(nil).FindByAppID), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/benchmark/benchmark.go",
        "code_start_line": 186,
        "code_end_line": 196,
        "code_key": "whenTaskFinish",
        "code_value": "func whenTaskFinish(ctx context.Context, source, target Status, stateCtx Data) error {\n\tresult, err := stateCtx.Delegate.QueryTask(ctx, stateCtx.Benchmark)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif result == nil {\n\t\treturn errors.New(ErrTaskNotFinish, \"benchmark task not finish\")\n\t}\n\tstateCtx.Benchmark.UpdateStat(*result)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/benchmark/benchmark.go",
        "code_start_line": 199,
        "code_end_line": 208,
        "code_key": "whenTaskStillRunning",
        "code_value": "func whenTaskStillRunning(ctx context.Context, source, target Status, stateCtx Data) error {\n\tresult, err := stateCtx.Delegate.QueryTask(ctx, stateCtx.Benchmark)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif result != nil {\n\t\treturn errors.New(ErrTaskFinished, \"benchmark already finish\")\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/backup/states.go",
        "code_start_line": 169,
        "code_end_line": 183,
        "code_key": "whenTaskStillRunning",
        "code_value": "func whenTaskStillRunning(\n\tctx context.Context,\n\tsource BackupStatus,\n\ttarget BackupStatus,\n\tstateCtx Data) error {\n\tprogress, err := stateCtx.Delegate.QueryBackupProgress(ctx, stateCtx.Backup)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !progress.Done && progress.Error == \"\" {\n\t\tstateCtx.Backup.UpdatePercentage(progress.Progress, progress.TotalSize)\n\t\treturn nil\n\t}\n\treturn errors.New(ErrTaskNotRunning, \"backup task not running\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/benchmark/benchmark.go",
        "code_start_line": 211,
        "code_end_line": 218,
        "code_key": "whenTaskFailed",
        "code_value": "func whenTaskFailed(ctx context.Context, source, target Status, stateCtx Data) error {\n\t_, err := stateCtx.Delegate.QueryTask(ctx, stateCtx.Benchmark)\n\tif err != nil {\n\t\tstateCtx.UpdateError(err)\n\t\treturn nil\n\t}\n\treturn errors.New(ErrTaskNotFinish, \"benchmark not failed\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/backup/states.go",
        "code_start_line": 186,
        "code_end_line": 201,
        "code_key": "whenTaskFailed",
        "code_value": "func whenTaskFailed(\n\tctx context.Context,\n\tsource BackupStatus,\n\ttarget BackupStatus,\n\tstateCtx Data) error {\n\tprogress, err := stateCtx.Delegate.QueryBackupProgress(ctx, stateCtx.Backup)\n\tif err != nil {\n\t\tlogs.Warn(ctx).Err(err).Str(\"task\", stateCtx.Backup.UUID.String()).Msg(\"backup task failed\")\n\t\treturn nil\n\t}\n\tif progress.Error != \"\" {\n\t\tlogs.Warn(ctx).Str(\"error\", progress.Error).Str(\"task\", stateCtx.Backup.UUID.String()).Msg(\"backup task failed\")\n\t\treturn nil\n\t}\n\treturn errors.New(ErrTaskNotFailed, \"backup task not failed\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 193,
        "code_end_line": 205,
        "code_key": "NewLogicalVolume",
        "code_value": "func NewLogicalVolume(appId users.AppID, size Size, zoneId ZoneID) *LogicalVolume {\n\tvol := &LogicalVolume{\n\t\tState:           LVSUnInited,\n\t\tSize:            size,\n\t\tAppID:           appId,\n\t\tUUID:            uuid.New(),\n\t\tZoneID:          zoneId,\n\t\tVolumeType:      VolumeTypeNVME,\n\t\tDiskType:        DiskTypeData,\n\t\tFlowControlSpec: DefaultFlowControlSpec,\n\t}\n\treturn vol\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 207,
        "code_end_line": 218,
        "code_key": "CheckSerial",
        "code_value": "func CheckSerial(serial Serial) error {\n\tif len(serial) < 5 {\n\t\treturn errors.New(ErrInvalidSerial, \"invalid serial, minimum length is 5\")\n\t}\n\n\tif strings.Contains(string(serial), \"---\") {\n\t\t// 在某些场景下 NVME 扫描脚本会检查到一些无效的设备，这些设备的序列号是 ---，这里过滤掉\n\t\treturn errors.New(ErrInvalidSerial, \"invalid serial, contains ---\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 256,
        "code_end_line": 276,
        "code_key": "Attach",
        "code_value": "func (l *LogicalVolume) Attach(ip net.IP) (*VolumeAttachment, error) {\n\tfor _, a := range l.Attachments {\n\t\tif a.IP.Equal(ip) {\n\t\t\treturn nil, errors.New(ErrVolumeAlreadyAttachedToHost, \"volume already attached to host\")\n\t\t}\n\t}\n\n\tif len(l.Attachments) >= MaxAttachmentCount {\n\t\treturn nil, errors.New(ErrVolumeAttachedOnTooManyHost, \"volume attached on too many host\")\n\t}\n\n\tnewAttachment := &VolumeAttachment{\n\t\tIP:              ip,\n\t\tMode:            ReadWrite,\n\t\tFlowControlSpec: l.FlowControlSpec,\n\t\tOptions:         DefaultAttachmentOption,\n\t}\n\tl.Attachments = append(l.Attachments, newAttachment)\n\n\treturn newAttachment, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 281,
        "code_end_line": 298,
        "code_key": "Detach",
        "code_value": "func (l *LogicalVolume) Detach(ip net.IP) error {\n\t// 以后如果有更复杂的逻辑需要调用检查接口\n\t// 目前他们做的事情是一样的，只是为了保留 DiskIds 等信息给后续步骤使用才需要先调用 CheckDetach\n\t// l.CheckDetach()\n\tfor i, a := range l.Attachments {\n\t\tif a.IP.Equal(ip) {\n\t\t\tl.Attachments = append(l.Attachments[:i], l.Attachments[i+1:]...)\n\t\t\tif len(l.Attachments) == 0 {\n\t\t\t\t// 如果逻辑卷已经没有挂载信息了，重置物理卷的 DiskID 和 Port\n\t\t\t\tif l.PhysicalVolume != nil {\n\t\t\t\t\tl.PhysicalVolume.ResetDiskIDPort()\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn errors.New(ErrVolumeNotAttachedToHost, \"volume not attached to host\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 301,
        "code_end_line": 308,
        "code_key": "CheckDetach",
        "code_value": "func (l *LogicalVolume) CheckDetach(ip net.IP) error {\n\tfor _, a := range l.Attachments {\n\t\tif a.IP.Equal(ip) {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn errors.New(ErrVolumeNotAttachedToHost, \"volume not attached to host\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 311,
        "code_end_line": 317,
        "code_key": "CheckDelete",
        "code_value": "func (l *LogicalVolume) CheckDelete() error {\n\t// Defuncting vol can't be deleted\n\tif l.State == LVSDefuncting {\n\t\treturn errors.New(ErrVolumeBusy, \"volume is defuncting, please try again later\")\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 324,
        "code_end_line": 344,
        "code_key": "BindPhysicalVolume",
        "code_value": "func (l *LogicalVolume) BindPhysicalVolume(pv *PhysicalVolume) error {\n\tif pv == nil {\n\t\treturn errors.New(ErrPhysicalVolumeNotExists, \"physical volume is nil\")\n\t}\n\tif l.PhysicalVolume != nil {\n\t\treturn errors.New(ErrPhysicalVolumeAlreadyBound, \"physical volume is bound to another logical volume\")\n\t}\n\tif l.Size != pv.Size {\n\t\treturn errors.New(ErrPhysicalVolumeSizeNotMatch, \"physical volume size not match\")\n\t}\n\tif l.ZoneID == 0 {\n\t\t// 如果逻辑卷没有指定可用区，就使用物理卷的可用区\n\t\tl.ZoneID = pv.ZoneID\n\t} else if l.ZoneID != pv.ZoneID {\n\t\treturn errors.Newf(ErrZoneIdMismatch, \"zone id mismatch, %d != %d\", l.ZoneID, pv.ZoneID)\n\t}\n\tl.PhysicalVolume = pv\n\t// 设置流控规格\n\tl.FlowControlSpec = defaultSpecForPerformanceRank(pv.PerformanceRank)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 347,
        "code_end_line": 353,
        "code_key": "MigratePhysicalVolume",
        "code_value": "func (l *LogicalVolume) MigratePhysicalVolume(target *PhysicalVolume) error {\n\tif l.Size != target.Size {\n\t\treturn errors.New(ErrPhysicalVolumeSizeNotMatch, \"physical volume size not match\")\n\t}\n\tl.PhysicalVolume = target\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 366,
        "code_end_line": 373,
        "code_key": "Defunct",
        "code_value": "func (l *LogicalVolume) Defunct() error {\n\tif len(l.Attachments) > 0 {\n\t\treturn errors.New(ErrVolumeAttached, \"volume is still attached to some hosts\")\n\t}\n\tl.PhysicalVolume = nil\n\tl.State = LVSDefunct\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 376,
        "code_end_line": 383,
        "code_key": "GetAttachment",
        "code_value": "func (l *LogicalVolume) GetAttachment(host net.IP) (att *VolumeAttachment, err error) {\n\tfor _, a := range l.Attachments {\n\t\tif a.IP.Equal(host) {\n\t\t\treturn a, nil\n\t\t}\n\t}\n\treturn nil, errors.New(ErrVolumeNotAttachedToHost, \"volume not attached to host\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/backup/models.go",
        "code_start_line": 117,
        "code_end_line": 130,
        "code_key": "Create",
        "code_value": "func (f *COSBasedFactory) Create(appId users.AppID, diskInfo DiskInfo) *Backup {\n\tbak := &Backup{}\n\tbak.UUID = uuid.New()\n\tbak.CreateTime = time.Now()\n\tbak.Status = StatusInit\n\tbak.AppID = appId\n\tbak.DiskInfo = diskInfo\n\tbak.Location.Bucket = f.bucket\n\t// rdiskBackups/20230102/1234678/abcd/efgh\n\tbak.Location.Path = fmt.Sprintf(\n\t\t\"rdisk-backups/%s/%d/%s/%s/backup\",\n\t\tbak.CreateTime.Format(\"20060102\"), appId, bak.DiskInfo.VolumeUUID, bak.UUID)\n\treturn bak\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/backup/states.go",
        "code_start_line": 152,
        "code_end_line": 166,
        "code_key": "whenTaskDone",
        "code_value": "func whenTaskDone(\n\tctx context.Context,\n\tsource BackupStatus,\n\ttarget BackupStatus,\n\tstateCtx Data) error {\n\tprogress, err := stateCtx.Delegate.QueryBackupProgress(ctx, stateCtx.Backup)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif progress.Done {\n\t\tstateCtx.Backup.UpdatePercentage(progress.Progress, progress.TotalSize)\n\t\treturn nil\n\t}\n\treturn errors.New(ErrTaskNotSuccess, \"backup task not success\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/fsm/fsm.go",
        "code_start_line": 79,
        "code_end_line": 92,
        "code_key": "getTransition",
        "code_value": "func (c *stateMachineImpl[S, E, C]) getTransition(currentState S, event E) ([]*transitionImpl[S, E, C], error) {\n\tif state, ok := c.stateMap[currentState]; ok {\n\t\tif transitions, ok := state.transitions[event]; ok {\n\t\t\trefs := make([]*transitionImpl[S, E, C], len(transitions))\n\t\t\tfor i := range transitions {\n\t\t\t\trefs[i] = &transitions[i]\n\t\t\t}\n\t\t\treturn refs, nil\n\t\t}\n\t\treturn nil, errors.New(ErrEventNotExists, \"event not exists\")\n\t} else {\n\t\treturn nil, errors.New(ErrStateNotExists, \"state not exists\")\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/fsm/fsm.go",
        "code_start_line": 94,
        "code_end_line": 109,
        "code_key": "getFirstOkTransition",
        "code_value": "func (c *stateMachineImpl[S, E, C]) getFirstOkTransition(ctx context.Context, currentState S, event E, stateCtx C) (int, error) {\n\ttransitions, err := c.getTransition(currentState, event)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tfor idx, transition := range transitions {\n\t\tif transition.condition != nil {\n\t\t\tif err := transition.condition.Check(ctx, transition.sourceState.stateId, transition.targetState.stateId, stateCtx); err == nil {\n\t\t\t\treturn idx, nil\n\t\t\t}\n\t\t} else {\n\t\t\treturn idx, nil\n\t\t}\n\t}\n\treturn 0, errors.New(ErrNoTransition, \"no valid transition\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 473,
        "code_end_line": 520,
        "code_key": "ObtainMulti",
        "code_value": "func (l *mysqlLocker) ObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, opts *dlock.Option) (dlock.Lock, error) {\n\tif len(keys) == 0 {\n\t\treturn nil, errors.New(\"keys cannot be empty\")\n\t}\n\tkeys = dedupAndSort(keys)\n\n\t// Get the lock token.\n\tlockToken, err := l.getOrCreateLockToken(opts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tretryStrategy := dlock.NoRetry()\n\tif opts != nil && opts.RetryStrategy != nil {\n\t\tretryStrategy = opts.RetryStrategy\n\t}\n\n\tretries := 0\n\tlogger := logs.GetLogger(ctx).With().Strs(\"keys\", dlock.LockKeySlice(keys).GetKeys()).Strs(\"tokens\", lockToken).Logger()\n\n\tfor {\n\t\t// Try to obtain the locks.\n\t\t// If the locks are not obtained, retry based on the retry strategy.\n\t\tif tokens, err := l.tryObtainMulti(ctx, keys, ttl, lockToken, opts); err != nil {\n\t\t\t// If context is canceled, return immediately.\n\t\t\tif ctx.Err() != nil {\n\t\t\t\treturn nil, errors.Wrap(dlock.ErrNotObtained, \"context is canceled\")\n\t\t\t}\n\n\t\t\t// If the lock is not obtained, retry.\n\t\t\twaitDuration := retryStrategy.NextBackoff()\n\t\t\tif waitDuration <= 0 {\n\t\t\t\tlogger.Debug().Int(\"retry\", retries).Msg(\"stop retrying lock\")\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tlogger.Debug().Int(\"retry\", retries).Msg(\"retry obtaining lock\")\n\t\t\ttime.Sleep(waitDuration)\n\t\t} else {\n\t\t\tlockToken = tokens\n\t\t\tlogger.Debug().Msg(\"lock obtained\")\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// TODO xuanzeng: 这里采用内部记录 TTL 的方式，可能和底层的数据库时间不同步，后续应该从数据库中获取过期时间。\n\tlock := &mysqlLock{keys: keys, locker: l, tokens: lockToken, expiration: time.Now().Add(ttl)}\n\treturn lock, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mem/memdlock.go",
        "code_start_line": 74,
        "code_end_line": 103,
        "code_key": "ObtainMulti",
        "code_value": "func (l *memLocker) ObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, opts *dlock.Option) (dlock.Lock, error) {\n\tvar token string\n\tif opts == nil || opts.Token == \"\" {\n\t\ttoken = uuid.New().String()\n\t} else {\n\t\ttoken = opts.Token\n\t}\n\n\tretryStrategy := dlock.NoRetry()\n\tif opts != nil && opts.RetryStrategy != nil {\n\t\tretryStrategy = opts.RetryStrategy\n\t}\n\n\tfor {\n\t\tlock, err := l.tryObtainMulti(ctx, keys, ttl, token)\n\t\tif err == nil {\n\t\t\treturn lock, nil\n\t\t}\n\n\t\tif ctx.Err() != nil {\n\t\t\treturn nil, ctx.Err()\n\t\t}\n\n\t\twaitInterval := retryStrategy.NextBackoff()\n\t\tif waitInterval <= 0 {\n\t\t\treturn nil, dlock.ErrNotObtained\n\t\t}\n\t\ttime.Sleep(waitInterval)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": []
  },
  "/Users/freedom/llms/singularity/internal/common/clients/cos/client.go:101:104:DeleteObject": {
    "code_file": "/Users/freedom/llms/singularity/internal/common/clients/cos/client.go",
    "code_start_line": 101,
    "code_end_line": 104,
    "code_start_column": 22,
    "code_key": "DeleteObject",
    "code_value": "func (c *clientImpl) DeleteObject(ctx context.Context, key string) error {\n\t_, err := c.c.Object.Delete(ctx, key)\n\treturn err\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [],
    "code_meta_data": []
  },
  "/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go:208:215:deleteFinishTask": {
    "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go",
    "code_start_line": 208,
    "code_end_line": 215,
    "code_start_column": 22,
    "code_key": "deleteFinishTask",
    "code_value": "func (sc *Scheduler) deleteFinishTask(ctx context.Context, task interfaces.Task) {\n\tsubTaskName := task.GetSubTaskName()\n\tif _, ok := sc.metrics.taskExecuteCountMap[subTaskName]; !ok {\n\t\tsc.metrics.taskExecuteCountMap[subTaskName], _ = initHistogramVec(subTaskName).GetMetricWith(sc.metrics.labels)\n\t}\n\tsc.metrics.taskExecuteCountMap[subTaskName].Observe(float64(task.GetExecuteCounts()))\n\tsc.taskMap.Delete(task.GetTaskId())\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go",
        "code_start_line": 240,
        "code_end_line": 261,
        "code_key": "processTask",
        "code_value": "func (sc *Scheduler) processTask(ctx context.Context, task interfaces.Task) {\n\tif sc.checkTaskChange(ctx, task) {\n\t\tsc.releaseWorker(ctx)\n\t\treturn\n\t}\n\tisFinish, err := task.Execute(ctx)\n\tif err != nil {\n\t\t// 执行出现异常时，等待下次重试\n\t\tlogs.Error(ctx).Str(\"error\", err.Error()).Msg(\"EXECUTE_TASK_FAILED\")\n\t\tisFinish = false\n\t}\n\tif isFinish {\n\t\t// 任务已完成\n\t\tsc.deleteFinishTask(ctx, task)\n\t} else {\n\t\t// 未完成，更新下次执行时间\n\t\ttask.UpdateExecuteTime(ctx)\n\t\t// 重新放入队列\n\t\tsc.rePushTask(ctx, task)\n\t}\n\tsc.releaseWorker(ctx)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": []
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/app/dispatcher/dispatcher.go:33:103:Dispatch": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/dispatcher/dispatcher.go",
    "code_start_line": 33,
    "code_end_line": 103,
    "code_start_column": 26,
    "code_key": "Dispatch",
    "code_value": "func (d *dispatcherImpl) Dispatch(ctx context.Context, cmd app.Command) (err error) {\n\t// 为什么使用 backgroundCtx 而不是 ctx？\n\t// 因为 ctx 代表调用方的上下文，通常是 rpc 请求上下文。\n\t// 而执行命令的上下文，应该是一个独立的上下文，不应该受到调用方的影响\n\t// 即使由于网络抖动等原因，调用方的上下文已经超时，但是命令执行的上下文仍然应该继续执行。\n\tworkerCtx := context.WithValue(d.backgroundCtx, ctxKeyCommand, cmd)\n\tworkerCtx, cancelFunc := context.WithTimeout(workerCtx, d.workerTimeout)\n\tworkerCtx = logs.GetLogger(ctx).WithContext(workerCtx)\n\tlockKeys := cmd.LockKeys()\n\terrChan := make(chan error, 1)\n\tlockOption := &dlock.Option{\n\t\tRetryStrategy: dlock.ExponentialBackoff(100*time.Millisecond, 6*time.Second),\n\t}\n\td.wg.Add(1)\n\t// 最终打印错误\n\t// TODO: 并发控制最大能同时执行的命令数量\n\tgo func() {\n\t\tdefer d.wg.Done()\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\te, ok := err.(error)\n\t\t\t\tif !ok {\n\t\t\t\t\te = errors.Newf(ErrDispatchPanic, \"dispatcher panic: %v\", err)\n\t\t\t\t}\n\t\t\t\terrChan <- e\n\t\t\t\tlogs.Error(workerCtx).Err(e).Stack().Bytes(\"trace\", debug.Stack()).Msgf(\"command execution panic\")\n\t\t\t}\n\t\t}()\n\n\t\tdefer cancelFunc()\n\n\t\tif lockKeys != nil {\n\t\t\tlock, err := d.locker.ObtainMulti(workerCtx, lockKeys, d.workerTimeout, lockOption)\n\t\t\tif err != nil {\n\t\t\t\terrChan <- err\n\t\t\t\tlogs.Warn(workerCtx).Err(err).Msgf(\"command execution waiting locks timeout\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer lock.Release(workerCtx)\n\t\t}\n\n\t\tuow := app.GetRegistry(ctx).Repositories.UoWFactory.New()\n\t\tworkerCtx = app.GetRegistry(ctx).Repositories.UoWFactory.With(workerCtx, uow)\n\n\t\terr = cmd.Handle(workerCtx)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, errors.ErrDryRunSuccessExit) {\n\t\t\t\terr = nil\n\t\t\t} else {\n\t\t\t\tlogs.Warn(workerCtx).Err(err).Msgf(\"command execution failed\")\n\t\t\t}\n\t\t\t_err := uow.Rollback(workerCtx)\n\t\t\tif _err != nil {\n\t\t\t\tlogs.Error(workerCtx).Err(_err).Msgf(\"unit of work rollback failed\")\n\t\t\t}\n\t\t} else {\n\t\t\terr = uow.Commit(workerCtx)\n\t\t\tif err != nil {\n\t\t\t\tlogs.Error(workerCtx).Err(err).Msgf(\"unit of work commit failed\")\n\t\t\t}\n\t\t}\n\t\terrChan <- err\n\t\tclose(errChan)\n\t}()\n\tselect {\n\tcase err := <-errChan:\n\t\treturn err\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\t}\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 2,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 644,
        "code_end_line": 646,
        "code_key": "CreateRDiskVol",
        "code_value": "func (s *UnimplementedMaster) CreateRDiskVol(ctx context.Context, req *CreateRDiskVolRequest) (*CreateRDiskVolResponse, error) {\n\treturn nil, errors.New(\"rpc CreateRDiskVol of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 837,
        "code_end_line": 855,
        "code_key": "CreateRDiskVol",
        "code_value": "func (c *MasterClientProxyImpl) CreateRDiskVol(ctx context.Context, req *CreateRDiskVolRequest, opts ...client.Option) (*CreateRDiskVolResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/CreateRDiskVol\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"CreateRDiskVol\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &CreateRDiskVolResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 174,
        "code_end_line": 180,
        "code_key": "CreateRDiskVol",
        "code_value": "func (m *MockMasterService) CreateRDiskVol(ctx context.Context, req *CreateRDiskVolRequest) (*CreateRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CreateRDiskVol\", ctx, req)\n\tret0, _ := ret[0].(*CreateRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 183,
        "code_end_line": 186,
        "code_key": "CreateRDiskVol",
        "code_value": "func (mr *MockMasterServiceMockRecorder) CreateRDiskVol(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateRDiskVol\", reflect.TypeOf((*MockMasterService)(nil).CreateRDiskVol), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 617,
        "code_end_line": 627,
        "code_key": "CreateRDiskVol",
        "code_value": "func (m *MockMasterClientProxy) CreateRDiskVol(ctx context.Context, req *CreateRDiskVolRequest, opts ...client.Option) (*CreateRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"CreateRDiskVol\", varargs...)\n\tret0, _ := ret[0].(*CreateRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 630,
        "code_end_line": 634,
        "code_key": "CreateRDiskVol",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) CreateRDiskVol(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateRDiskVol\", reflect.TypeOf((*MockMasterClientProxy)(nil).CreateRDiskVol), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 184,
        "code_end_line": 235,
        "code_key": "CreateRDiskVol",
        "code_value": "func (s *masterApiServerImpl) CreateRDiskVol(ctx context.Context, req *pb.CreateRDiskVolRequest) (*pb.CreateRDiskVolResponse, error) {\n\tvar (\n\t\terr           error\n\t\tresponse      *pb.CreateRDiskVolResponse\n\t\tcreateCmd     *commands.CreateLogicalVolumeCommand\n\t\tconfirmCmd    *commands.ConfirmDRGroupExistsCommand\n\t\tcreatedVolume *rdiskDomain.LogicalVolume\n\t\tpvViewer      = app.GetRegistry(ctx).Viewers.PhysicalVolume\n\t)\n\n\tconfirmCmd = &commands.ConfirmDRGroupExistsCommand{\n\t\tAppID:   int64(req.AppId),\n\t\tDRGroup: functools.MapTo(req.AffinitySpec, functools.MapRef(make([]drgroup.Spec, len(req.AffinitySpec))), parseAffinitySpec),\n\t}\n\terr = app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, confirmCmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tselectedPhysicalVolume, err := pvViewer.QueryBySerial(ctx, []string{req.PhyId})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(selectedPhysicalVolume) == 0 {\n\t\treturn nil, errs.New(errors.ErrInvalidArgument, \"physical volume not found\")\n\t}\n\n\tcreateCmd = &commands.CreateLogicalVolumeCommand{\n\t\tAppID:                  int64(req.AppId),\n\t\tPhysicalVolumeSerial:   req.PhyId,\n\t\tZoneID:                 req.ZoneId,\n\t\tVolumeType:             req.VolumeType,\n\t\tDiskSize:               req.DiskSize,\n\t\tDiskType:               req.DiskType,\n\t\tDRGroup:                functools.MapTo(req.AffinitySpec, functools.MapRef(make([]drgroup.Spec, len(req.AffinitySpec))), parseAffinitySpec),\n\t\tSelectedPhysicalVolume: selectedPhysicalVolume[0],\n\t\tPerformanceRank:        req.PerformanceRank,\n\t}\n\n\terr = app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, createCmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcreatedVolume = createCmd.GetLogicalVolume()\n\tresponse = &pb.CreateRDiskVolResponse{\n\t\tDisk: encodeLogicalVolume(createdVolume, &pb.RDisk{}),\n\t}\n\n\treturn response, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 654,
        "code_end_line": 656,
        "code_key": "DeleteRDiskVol",
        "code_value": "func (s *UnimplementedMaster) DeleteRDiskVol(ctx context.Context, req *DeleteRDiskVolRequest) (*DeleteRDiskVolResponse, error) {\n\treturn nil, errors.New(\"rpc DeleteRDiskVol of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 877,
        "code_end_line": 895,
        "code_key": "DeleteRDiskVol",
        "code_value": "func (c *MasterClientProxyImpl) DeleteRDiskVol(ctx context.Context, req *DeleteRDiskVolRequest, opts ...client.Option) (*DeleteRDiskVolResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/DeleteRDiskVol\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"DeleteRDiskVol\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &DeleteRDiskVolResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 234,
        "code_end_line": 240,
        "code_key": "DeleteRDiskVol",
        "code_value": "func (m *MockMasterService) DeleteRDiskVol(ctx context.Context, req *DeleteRDiskVolRequest) (*DeleteRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"DeleteRDiskVol\", ctx, req)\n\tret0, _ := ret[0].(*DeleteRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 243,
        "code_end_line": 246,
        "code_key": "DeleteRDiskVol",
        "code_value": "func (mr *MockMasterServiceMockRecorder) DeleteRDiskVol(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeleteRDiskVol\", reflect.TypeOf((*MockMasterService)(nil).DeleteRDiskVol), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 697,
        "code_end_line": 707,
        "code_key": "DeleteRDiskVol",
        "code_value": "func (m *MockMasterClientProxy) DeleteRDiskVol(ctx context.Context, req *DeleteRDiskVolRequest, opts ...client.Option) (*DeleteRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"DeleteRDiskVol\", varargs...)\n\tret0, _ := ret[0].(*DeleteRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 710,
        "code_end_line": 714,
        "code_key": "DeleteRDiskVol",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) DeleteRDiskVol(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeleteRDiskVol\", reflect.TypeOf((*MockMasterClientProxy)(nil).DeleteRDiskVol), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 238,
        "code_end_line": 260,
        "code_key": "DeleteRDiskVol",
        "code_value": "func (s *masterApiServerImpl) DeleteRDiskVol(ctx context.Context, req *pb.DeleteRDiskVolRequest) (*pb.DeleteRDiskVolResponse, error) {\n\tvar (\n\t\terr      error\n\t\tresponse = &pb.DeleteRDiskVolResponse{}\n\t\tcmd      *commands.DeleteLogicalVolumeCommand\n\t)\n\tcmd = &commands.DeleteLogicalVolumeCommand{\n\t\tAppID: users.AppID(req.AppId),\n\t\tUUID:  uuid.MustParse(req.CbsUuid),\n\t}\n\terr = cmd.Prepare(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, cmd)\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn &pb.DeleteRDiskVolResponse{}, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn response, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 659,
        "code_end_line": 661,
        "code_key": "ConfirmDeleteRDiskVol",
        "code_value": "func (s *UnimplementedMaster) ConfirmDeleteRDiskVol(ctx context.Context, req *DeleteRDiskVolRequest) (*DeleteRDiskVolResponse, error) {\n\treturn nil, errors.New(\"rpc ConfirmDeleteRDiskVol of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 897,
        "code_end_line": 915,
        "code_key": "ConfirmDeleteRDiskVol",
        "code_value": "func (c *MasterClientProxyImpl) ConfirmDeleteRDiskVol(ctx context.Context, req *DeleteRDiskVolRequest, opts ...client.Option) (*DeleteRDiskVolResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/ConfirmDeleteRDiskVol\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"ConfirmDeleteRDiskVol\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &DeleteRDiskVolResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 99,
        "code_end_line": 105,
        "code_key": "ConfirmDeleteRDiskVol",
        "code_value": "func (m *MockMasterService) ConfirmDeleteRDiskVol(ctx context.Context, req *DeleteRDiskVolRequest) (*DeleteRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"ConfirmDeleteRDiskVol\", ctx, req)\n\tret0, _ := ret[0].(*DeleteRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 108,
        "code_end_line": 111,
        "code_key": "ConfirmDeleteRDiskVol",
        "code_value": "func (mr *MockMasterServiceMockRecorder) ConfirmDeleteRDiskVol(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ConfirmDeleteRDiskVol\", reflect.TypeOf((*MockMasterService)(nil).ConfirmDeleteRDiskVol), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 517,
        "code_end_line": 527,
        "code_key": "ConfirmDeleteRDiskVol",
        "code_value": "func (m *MockMasterClientProxy) ConfirmDeleteRDiskVol(ctx context.Context, req *DeleteRDiskVolRequest, opts ...client.Option) (*DeleteRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"ConfirmDeleteRDiskVol\", varargs...)\n\tret0, _ := ret[0].(*DeleteRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 530,
        "code_end_line": 534,
        "code_key": "ConfirmDeleteRDiskVol",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) ConfirmDeleteRDiskVol(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ConfirmDeleteRDiskVol\", reflect.TypeOf((*MockMasterClientProxy)(nil).ConfirmDeleteRDiskVol), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 263,
        "code_end_line": 276,
        "code_key": "ConfirmDeleteRDiskVol",
        "code_value": "func (s *masterApiServerImpl) ConfirmDeleteRDiskVol(ctx context.Context, req *pb.DeleteRDiskVolRequest) (*pb.DeleteRDiskVolResponse, error) {\n\tcmd := commands.ConfirmDeleteLogicalVolumeCommand{\n\t\tAppID: users.AppID(req.AppId),\n\t\tUUID:  uuid.MustParse(req.CbsUuid),\n\t}\n\terr := app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, &cmd)\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn &pb.DeleteRDiskVolResponse{}, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn &pb.DeleteRDiskVolResponse{}, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 664,
        "code_end_line": 666,
        "code_key": "UpdateRDiskFlowCtrl",
        "code_value": "func (s *UnimplementedMaster) UpdateRDiskFlowCtrl(ctx context.Context, req *UpdateRDiskFlowCtrlRequest) (*UpdateRDiskFlowCtrlResponse, error) {\n\treturn nil, errors.New(\"rpc UpdateRDiskFlowCtrl of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 917,
        "code_end_line": 935,
        "code_key": "UpdateRDiskFlowCtrl",
        "code_value": "func (c *MasterClientProxyImpl) UpdateRDiskFlowCtrl(ctx context.Context, req *UpdateRDiskFlowCtrlRequest, opts ...client.Option) (*UpdateRDiskFlowCtrlResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/UpdateRDiskFlowCtrl\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"UpdateRDiskFlowCtrl\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &UpdateRDiskFlowCtrlResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 399,
        "code_end_line": 405,
        "code_key": "UpdateRDiskFlowCtrl",
        "code_value": "func (m *MockMasterService) UpdateRDiskFlowCtrl(ctx context.Context, req *UpdateRDiskFlowCtrlRequest) (*UpdateRDiskFlowCtrlResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"UpdateRDiskFlowCtrl\", ctx, req)\n\tret0, _ := ret[0].(*UpdateRDiskFlowCtrlResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 408,
        "code_end_line": 411,
        "code_key": "UpdateRDiskFlowCtrl",
        "code_value": "func (mr *MockMasterServiceMockRecorder) UpdateRDiskFlowCtrl(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"UpdateRDiskFlowCtrl\", reflect.TypeOf((*MockMasterService)(nil).UpdateRDiskFlowCtrl), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 917,
        "code_end_line": 927,
        "code_key": "UpdateRDiskFlowCtrl",
        "code_value": "func (m *MockMasterClientProxy) UpdateRDiskFlowCtrl(ctx context.Context, req *UpdateRDiskFlowCtrlRequest, opts ...client.Option) (*UpdateRDiskFlowCtrlResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"UpdateRDiskFlowCtrl\", varargs...)\n\tret0, _ := ret[0].(*UpdateRDiskFlowCtrlResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 930,
        "code_end_line": 934,
        "code_key": "UpdateRDiskFlowCtrl",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) UpdateRDiskFlowCtrl(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"UpdateRDiskFlowCtrl\", reflect.TypeOf((*MockMasterClientProxy)(nil).UpdateRDiskFlowCtrl), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 359,
        "code_end_line": 382,
        "code_key": "UpdateRDiskFlowCtrl",
        "code_value": "func (*masterApiServerImpl) UpdateRDiskFlowCtrl(ctx context.Context, req *pb.UpdateRDiskFlowCtrlRequest) (*pb.UpdateRDiskFlowCtrlResponse, error) {\n\tvar (\n\t\terr      error\n\t\tresponse = &pb.UpdateRDiskFlowCtrlResponse{}\n\t\tcmd      = &commands.UpdateLogicalVolumeFlowControlCommand{}\n\t)\n\n\tcmd.AppID = users.AppID(req.AppId)\n\tcmd.UUID = uuid.MustParse(req.CbsUuid)\n\n\tif ctrl := req.GetFlowCtrl(); ctrl != nil {\n\t\tcmd.UpdateRequest.ReadIOPS = ctrl.ReadIops\n\t\tcmd.UpdateRequest.ReadIO = ctrl.ReadBandwidth\n\t\tcmd.UpdateRequest.WriteIOPS = ctrl.WriteIops\n\t\tcmd.UpdateRequest.WriteIO = ctrl.WriteBandwidth\n\t\tcmd.UpdateRequest.RWIO = ctrl.RwBandwidth\n\t\tcmd.UpdateRequest.RWIOPS = ctrl.RwIops\n\t} else {\n\t\treturn response, nil\n\t}\n\n\terr = app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, cmd)\n\treturn response, err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 669,
        "code_end_line": 671,
        "code_key": "AttachRDiskVol",
        "code_value": "func (s *UnimplementedMaster) AttachRDiskVol(ctx context.Context, req *AttachRDiskVolRequest) (*AttachRDiskVolResponse, error) {\n\treturn nil, errors.New(\"rpc AttachRDiskVol of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 937,
        "code_end_line": 955,
        "code_key": "AttachRDiskVol",
        "code_value": "func (c *MasterClientProxyImpl) AttachRDiskVol(ctx context.Context, req *AttachRDiskVolRequest, opts ...client.Option) (*AttachRDiskVolResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/AttachRDiskVol\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"AttachRDiskVol\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &AttachRDiskVolResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 39,
        "code_end_line": 45,
        "code_key": "AttachRDiskVol",
        "code_value": "func (m *MockMasterService) AttachRDiskVol(ctx context.Context, req *AttachRDiskVolRequest) (*AttachRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"AttachRDiskVol\", ctx, req)\n\tret0, _ := ret[0].(*AttachRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 48,
        "code_end_line": 51,
        "code_key": "AttachRDiskVol",
        "code_value": "func (mr *MockMasterServiceMockRecorder) AttachRDiskVol(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"AttachRDiskVol\", reflect.TypeOf((*MockMasterService)(nil).AttachRDiskVol), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 437,
        "code_end_line": 447,
        "code_key": "AttachRDiskVol",
        "code_value": "func (m *MockMasterClientProxy) AttachRDiskVol(ctx context.Context, req *AttachRDiskVolRequest, opts ...client.Option) (*AttachRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"AttachRDiskVol\", varargs...)\n\tret0, _ := ret[0].(*AttachRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 450,
        "code_end_line": 454,
        "code_key": "AttachRDiskVol",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) AttachRDiskVol(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"AttachRDiskVol\", reflect.TypeOf((*MockMasterClientProxy)(nil).AttachRDiskVol), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 309,
        "code_end_line": 338,
        "code_key": "AttachRDiskVol",
        "code_value": "func (s *masterApiServerImpl) AttachRDiskVol(ctx context.Context, req *pb.AttachRDiskVolRequest) (*pb.AttachRDiskVolResponse, error) {\n\tcmd := commands.AttachLogicalVolumeCommand{\n\t\tAppID:   users.AppID(req.AppId),\n\t\tUUID:    uuid.MustParse(req.CbsUuid),\n\t\tIP:      net.ParseIP(req.HostIp),\n\t\tOptions: actions.NewAttachOptions(),\n\t}\n\n\tif req.Option != nil {\n\t\tif req.Option.Serial != \"\" {\n\t\t\tcmd.Options.Serial = req.Option.Serial\n\t\t}\n\t\tif req.Option.Vcpu > 0 {\n\t\t\tcmd.Options.VCPU = int(req.Option.Vcpu)\n\t\t}\n\t}\n\n\terr := app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, &cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvol := cmd.GetLogicalVolume()\n\tspdkDriver := \"\"\n\tattachment, err := vol.GetAttachment(net.ParseIP(req.HostIp))\n\tif err == nil {\n\t\tspdkDriver = attachment.Options.SPDKDriver\n\t}\n\tblockSize := vol.PhysicalVolume.BlockSize\n\treturn &pb.AttachRDiskVolResponse{SpdkDriver: spdkDriver, BlockSize: int64(blockSize)}, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 674,
        "code_end_line": 676,
        "code_key": "DetachRDiskVol",
        "code_value": "func (s *UnimplementedMaster) DetachRDiskVol(ctx context.Context, req *DetachRDiskVolRequest) (*DetachRDiskVolResponse, error) {\n\treturn nil, errors.New(\"rpc DetachRDiskVol of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 957,
        "code_end_line": 975,
        "code_key": "DetachRDiskVol",
        "code_value": "func (c *MasterClientProxyImpl) DetachRDiskVol(ctx context.Context, req *DetachRDiskVolRequest, opts ...client.Option) (*DetachRDiskVolResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/DetachRDiskVol\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"DetachRDiskVol\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &DetachRDiskVolResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 249,
        "code_end_line": 255,
        "code_key": "DetachRDiskVol",
        "code_value": "func (m *MockMasterService) DetachRDiskVol(ctx context.Context, req *DetachRDiskVolRequest) (*DetachRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"DetachRDiskVol\", ctx, req)\n\tret0, _ := ret[0].(*DetachRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 258,
        "code_end_line": 261,
        "code_key": "DetachRDiskVol",
        "code_value": "func (mr *MockMasterServiceMockRecorder) DetachRDiskVol(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DetachRDiskVol\", reflect.TypeOf((*MockMasterService)(nil).DetachRDiskVol), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 717,
        "code_end_line": 727,
        "code_key": "DetachRDiskVol",
        "code_value": "func (m *MockMasterClientProxy) DetachRDiskVol(ctx context.Context, req *DetachRDiskVolRequest, opts ...client.Option) (*DetachRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"DetachRDiskVol\", varargs...)\n\tret0, _ := ret[0].(*DetachRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 730,
        "code_end_line": 734,
        "code_key": "DetachRDiskVol",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) DetachRDiskVol(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DetachRDiskVol\", reflect.TypeOf((*MockMasterClientProxy)(nil).DetachRDiskVol), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 341,
        "code_end_line": 356,
        "code_key": "DetachRDiskVol",
        "code_value": "func (s *masterApiServerImpl) DetachRDiskVol(ctx context.Context, req *pb.DetachRDiskVolRequest) (*pb.DetachRDiskVolResponse, error) {\n\tvar (\n\t\terr      error\n\t\tresponse = &pb.DetachRDiskVolResponse{}\n\t\tcmd      *commands.DetachLogicalVolumeCommand\n\t)\n\n\tcmd = &commands.DetachLogicalVolumeCommand{\n\t\tAppID:       users.AppID(req.AppId),\n\t\tUUID:        uuid.MustParse(req.CbsUuid),\n\t\tIP:          net.ParseIP(req.HostIp),\n\t\tForceDetach: req.Force,\n\t}\n\terr = app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, cmd)\n\treturn response, err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 699,
        "code_end_line": 701,
        "code_key": "CreateRDiskBackup",
        "code_value": "func (s *UnimplementedMaster) CreateRDiskBackup(ctx context.Context, req *CreateRDiskBackupRequest) (*CreateRDiskBackupResponse, error) {\n\treturn nil, errors.New(\"rpc CreateRDiskBackup of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1057,
        "code_end_line": 1075,
        "code_key": "CreateRDiskBackup",
        "code_value": "func (c *MasterClientProxyImpl) CreateRDiskBackup(ctx context.Context, req *CreateRDiskBackupRequest, opts ...client.Option) (*CreateRDiskBackupResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/CreateRDiskBackup\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"CreateRDiskBackup\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &CreateRDiskBackupResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 129,
        "code_end_line": 135,
        "code_key": "CreateRDiskBackup",
        "code_value": "func (m *MockMasterService) CreateRDiskBackup(ctx context.Context, req *CreateRDiskBackupRequest) (*CreateRDiskBackupResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CreateRDiskBackup\", ctx, req)\n\tret0, _ := ret[0].(*CreateRDiskBackupResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 138,
        "code_end_line": 141,
        "code_key": "CreateRDiskBackup",
        "code_value": "func (mr *MockMasterServiceMockRecorder) CreateRDiskBackup(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateRDiskBackup\", reflect.TypeOf((*MockMasterService)(nil).CreateRDiskBackup), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 557,
        "code_end_line": 567,
        "code_key": "CreateRDiskBackup",
        "code_value": "func (m *MockMasterClientProxy) CreateRDiskBackup(ctx context.Context, req *CreateRDiskBackupRequest, opts ...client.Option) (*CreateRDiskBackupResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"CreateRDiskBackup\", varargs...)\n\tret0, _ := ret[0].(*CreateRDiskBackupResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 570,
        "code_end_line": 574,
        "code_key": "CreateRDiskBackup",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) CreateRDiskBackup(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateRDiskBackup\", reflect.TypeOf((*MockMasterClientProxy)(nil).CreateRDiskBackup), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 385,
        "code_end_line": 404,
        "code_key": "CreateRDiskBackup",
        "code_value": "func (*masterApiServerImpl) CreateRDiskBackup(ctx context.Context, req *pb.CreateRDiskBackupRequest) (*pb.CreateRDiskBackupResponse, error) {\n\tvar (\n\t\terr       error\n\t\tresponse  = &pb.CreateRDiskBackupResponse{}\n\t\tcmd       = &commands.CreateRDiskBackupCommand{}\n\t\tdispacher = app.GetRegistry(ctx).Dispatcher\n\t)\n\n\tcmd.AppID = users.AppID(req.AppId)\n\tcmd.UUID = uuid.MustParse(req.CbsUuid)\n\n\terr = dispacher.Dispatch(ctx, cmd)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse.Backup = encodeRDiskBackup(cmd.GetBackup(), &pb.RDiskBackup{})\n\treturn response, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 709,
        "code_end_line": 711,
        "code_key": "DeleteRDiskBackup",
        "code_value": "func (s *UnimplementedMaster) DeleteRDiskBackup(ctx context.Context, req *DeleteRDiskBackupRequest) (*DeleteRDiskBackupResponse, error) {\n\treturn nil, errors.New(\"rpc DeleteRDiskBackup of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1097,
        "code_end_line": 1115,
        "code_key": "DeleteRDiskBackup",
        "code_value": "func (c *MasterClientProxyImpl) DeleteRDiskBackup(ctx context.Context, req *DeleteRDiskBackupRequest, opts ...client.Option) (*DeleteRDiskBackupResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/DeleteRDiskBackup\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"DeleteRDiskBackup\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &DeleteRDiskBackupResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 219,
        "code_end_line": 225,
        "code_key": "DeleteRDiskBackup",
        "code_value": "func (m *MockMasterService) DeleteRDiskBackup(ctx context.Context, req *DeleteRDiskBackupRequest) (*DeleteRDiskBackupResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"DeleteRDiskBackup\", ctx, req)\n\tret0, _ := ret[0].(*DeleteRDiskBackupResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 228,
        "code_end_line": 231,
        "code_key": "DeleteRDiskBackup",
        "code_value": "func (mr *MockMasterServiceMockRecorder) DeleteRDiskBackup(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeleteRDiskBackup\", reflect.TypeOf((*MockMasterService)(nil).DeleteRDiskBackup), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 677,
        "code_end_line": 687,
        "code_key": "DeleteRDiskBackup",
        "code_value": "func (m *MockMasterClientProxy) DeleteRDiskBackup(ctx context.Context, req *DeleteRDiskBackupRequest, opts ...client.Option) (*DeleteRDiskBackupResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"DeleteRDiskBackup\", varargs...)\n\tret0, _ := ret[0].(*DeleteRDiskBackupResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 690,
        "code_end_line": 694,
        "code_key": "DeleteRDiskBackup",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) DeleteRDiskBackup(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeleteRDiskBackup\", reflect.TypeOf((*MockMasterClientProxy)(nil).DeleteRDiskBackup), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 407,
        "code_end_line": 425,
        "code_key": "DeleteRDiskBackup",
        "code_value": "func (*masterApiServerImpl) DeleteRDiskBackup(ctx context.Context, req *pb.DeleteRDiskBackupRequest) (*pb.DeleteRDiskBackupResponse, error) {\n\tvar (\n\t\terr       error\n\t\tresponse  = &pb.DeleteRDiskBackupResponse{}\n\t\tcmd       = &commands.DeleteRDiskBackupCommand{}\n\t\tdispacher = app.GetRegistry(ctx).Dispatcher\n\t)\n\n\tcmd.AppID = users.AppID(req.AppId)\n\tcmd.BackupID = uuid.MustParse(req.BackupId)\n\tcmd.UUID = uuid.MustParse(req.CbsUuid)\n\n\terr = dispacher.Dispatch(ctx, cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 714,
        "code_end_line": 716,
        "code_key": "UpdateRDiskDRGroup",
        "code_value": "func (s *UnimplementedMaster) UpdateRDiskDRGroup(ctx context.Context, req *UpdateRDiskDRGroupRequest) (*UpdateRDiskDRGroupResponse, error) {\n\treturn nil, errors.New(\"rpc UpdateRDiskDRGroup of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1117,
        "code_end_line": 1135,
        "code_key": "UpdateRDiskDRGroup",
        "code_value": "func (c *MasterClientProxyImpl) UpdateRDiskDRGroup(ctx context.Context, req *UpdateRDiskDRGroupRequest, opts ...client.Option) (*UpdateRDiskDRGroupResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/UpdateRDiskDRGroup\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"UpdateRDiskDRGroup\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &UpdateRDiskDRGroupResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 384,
        "code_end_line": 390,
        "code_key": "UpdateRDiskDRGroup",
        "code_value": "func (m *MockMasterService) UpdateRDiskDRGroup(ctx context.Context, req *UpdateRDiskDRGroupRequest) (*UpdateRDiskDRGroupResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"UpdateRDiskDRGroup\", ctx, req)\n\tret0, _ := ret[0].(*UpdateRDiskDRGroupResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 393,
        "code_end_line": 396,
        "code_key": "UpdateRDiskDRGroup",
        "code_value": "func (mr *MockMasterServiceMockRecorder) UpdateRDiskDRGroup(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"UpdateRDiskDRGroup\", reflect.TypeOf((*MockMasterService)(nil).UpdateRDiskDRGroup), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 897,
        "code_end_line": 907,
        "code_key": "UpdateRDiskDRGroup",
        "code_value": "func (m *MockMasterClientProxy) UpdateRDiskDRGroup(ctx context.Context, req *UpdateRDiskDRGroupRequest, opts ...client.Option) (*UpdateRDiskDRGroupResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"UpdateRDiskDRGroup\", varargs...)\n\tret0, _ := ret[0].(*UpdateRDiskDRGroupResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 910,
        "code_end_line": 914,
        "code_key": "UpdateRDiskDRGroup",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) UpdateRDiskDRGroup(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"UpdateRDiskDRGroup\", reflect.TypeOf((*MockMasterClientProxy)(nil).UpdateRDiskDRGroup), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 286,
        "code_end_line": 306,
        "code_key": "UpdateRDiskDRGroup",
        "code_value": "func (s *masterApiServerImpl) UpdateRDiskDRGroup(ctx context.Context, req *pb.UpdateRDiskDRGroupRequest) (*pb.UpdateRDiskDRGroupResponse, error) {\n\tcmd := commands.UpdateLogicalVolumeDRGroupCommand{\n\t\tAppID: users.AppID(req.AppId),\n\t\tUUIDs: functools.Map(req.CbsUuids, uuid.MustParse),\n\t\tSpecs: functools.MapTo(req.AffinitySpecs,\n\t\t\tfunctools.MapRef(make([]drgroup.Spec, len(req.AffinitySpecs))),\n\t\t\tparseAffinitySpec),\n\t\tDryRun: req.DryRun,\n\t}\n\tif err := cmd.Prepare(ctx); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, &cmd); err != nil {\n\t\tif errors.IsCode(err, errors.ErrDryRunSuccessExit) {\n\t\t\treturn &pb.UpdateRDiskDRGroupResponse{}, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn &pb.UpdateRDiskDRGroupResponse{}, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 719,
        "code_end_line": 721,
        "code_key": "CleanupRDiskVol",
        "code_value": "func (s *UnimplementedMaster) CleanupRDiskVol(ctx context.Context, req *CleanupRDiskVolRequest) (*CleanupRDiskVolResponse, error) {\n\treturn nil, errors.New(\"rpc CleanupRDiskVol of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1137,
        "code_end_line": 1155,
        "code_key": "CleanupRDiskVol",
        "code_value": "func (c *MasterClientProxyImpl) CleanupRDiskVol(ctx context.Context, req *CleanupRDiskVolRequest, opts ...client.Option) (*CleanupRDiskVolResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/CleanupRDiskVol\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"CleanupRDiskVol\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &CleanupRDiskVolResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 84,
        "code_end_line": 90,
        "code_key": "CleanupRDiskVol",
        "code_value": "func (m *MockMasterService) CleanupRDiskVol(ctx context.Context, req *CleanupRDiskVolRequest) (*CleanupRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CleanupRDiskVol\", ctx, req)\n\tret0, _ := ret[0].(*CleanupRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 93,
        "code_end_line": 96,
        "code_key": "CleanupRDiskVol",
        "code_value": "func (mr *MockMasterServiceMockRecorder) CleanupRDiskVol(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CleanupRDiskVol\", reflect.TypeOf((*MockMasterService)(nil).CleanupRDiskVol), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 497,
        "code_end_line": 507,
        "code_key": "CleanupRDiskVol",
        "code_value": "func (m *MockMasterClientProxy) CleanupRDiskVol(ctx context.Context, req *CleanupRDiskVolRequest, opts ...client.Option) (*CleanupRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"CleanupRDiskVol\", varargs...)\n\tret0, _ := ret[0].(*CleanupRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 510,
        "code_end_line": 514,
        "code_key": "CleanupRDiskVol",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) CleanupRDiskVol(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CleanupRDiskVol\", reflect.TypeOf((*MockMasterClientProxy)(nil).CleanupRDiskVol), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 73,
        "code_end_line": 84,
        "code_key": "CleanupRDiskVol",
        "code_value": "func (*masterApiServerImpl) CleanupRDiskVol(ctx context.Context, req *pb.CleanupRDiskVolRequest) (*pb.CleanupRDiskVolResponse, error) {\n\tvar dispatcher = app.GetRegistry(ctx).Dispatcher\n\n\tcmd := &commands.CleanupLogicalVolumeCommand{\n\t\tUUID: uuid.MustParse(req.CbsUuid),\n\t\tIP:   net.ParseIP(req.HostIp),\n\t}\n\tif err := dispatcher.Dispatch(ctx, cmd); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &pb.CleanupRDiskVolResponse{}, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 724,
        "code_end_line": 726,
        "code_key": "CreatePhyRDisk",
        "code_value": "func (s *UnimplementedMaster) CreatePhyRDisk(ctx context.Context, req *CreatePhyRDiskRequest) (*CreatePhyRDiskResponse, error) {\n\treturn nil, errors.New(\"rpc CreatePhyRDisk of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1157,
        "code_end_line": 1175,
        "code_key": "CreatePhyRDisk",
        "code_value": "func (c *MasterClientProxyImpl) CreatePhyRDisk(ctx context.Context, req *CreatePhyRDiskRequest, opts ...client.Option) (*CreatePhyRDiskResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/CreatePhyRDisk\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"CreatePhyRDisk\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &CreatePhyRDiskResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 114,
        "code_end_line": 120,
        "code_key": "CreatePhyRDisk",
        "code_value": "func (m *MockMasterService) CreatePhyRDisk(ctx context.Context, req *CreatePhyRDiskRequest) (*CreatePhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CreatePhyRDisk\", ctx, req)\n\tret0, _ := ret[0].(*CreatePhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 123,
        "code_end_line": 126,
        "code_key": "CreatePhyRDisk",
        "code_value": "func (mr *MockMasterServiceMockRecorder) CreatePhyRDisk(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreatePhyRDisk\", reflect.TypeOf((*MockMasterService)(nil).CreatePhyRDisk), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 537,
        "code_end_line": 547,
        "code_key": "CreatePhyRDisk",
        "code_value": "func (m *MockMasterClientProxy) CreatePhyRDisk(ctx context.Context, req *CreatePhyRDiskRequest, opts ...client.Option) (*CreatePhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"CreatePhyRDisk\", varargs...)\n\tret0, _ := ret[0].(*CreatePhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 550,
        "code_end_line": 554,
        "code_key": "CreatePhyRDisk",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) CreatePhyRDisk(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreatePhyRDisk\", reflect.TypeOf((*MockMasterClientProxy)(nil).CreatePhyRDisk), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 603,
        "code_end_line": 654,
        "code_key": "CreatePhyRDisk",
        "code_value": "func (s *masterApiServerImpl) CreatePhyRDisk(ctx context.Context, req *pb.CreatePhyRDiskRequest) (*pb.CreatePhyRDiskResponse, error) {\n\tcmd := commands.CreatePhysicalVolumeCommand{\n\t\tSerial:          req.PhyId,\n\t\tHost:            net.ParseIP(req.HostIp),\n\t\tBDF:             req.BdfId,\n\t\tSize:            req.Size,\n\t\tZoneID:          req.ZoneId,\n\t\tVolumeType:      req.VolumeType,\n\t\tCuf:             req.Cuf,\n\t\tPerformanceRank: req.PerformanceRank,\n\t}\n\n\tswitch req.Type {\n\tcase pb.DataNodeType_unknown:\n\t\tcmd.DataNodeType = rdiskDomain.DataNodeTypeUnknown\n\tcase pb.DataNodeType_mix:\n\t\tcmd.DataNodeType = rdiskDomain.DataNodeTypeMix\n\tcase pb.DataNodeType_monopoly:\n\t\tcmd.DataNodeType = rdiskDomain.DataNodeTypeMonopoly\n\t}\n\n\terr := app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, &cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &pb.CreatePhyRDiskResponse{\n\t\tPhyDisk: &pb.PhyRDisk{\n\t\t\tPhyId:  req.PhyId,\n\t\t\tBdfId:  req.BdfId,\n\t\t\tStatus: \"inited\",\n\t\t\tSize:   req.Size,\n\t\t\tZoneId: req.ZoneId,\n\t\t\tNode: &pb.DataNode{\n\t\t\t\tHostIp: req.HostIp,\n\t\t\t\tStatus: \"online\",\n\t\t\t},\n\t\t\tCuf: req.Cuf,\n\t\t},\n\t}\n\n\t// 查询物理卷状态\n\tresults, err := app.GetRegistry(ctx).Viewers.PhysicalVolume.QueryBySerial(ctx, []string{req.PhyId})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(results) == 1 {\n\t\tvol := results[0]\n\t\tencodePhysicalVolume(vol, response.PhyDisk)\n\t}\n\treturn response, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 729,
        "code_end_line": 731,
        "code_key": "DeletePhyRDisk",
        "code_value": "func (s *UnimplementedMaster) DeletePhyRDisk(ctx context.Context, req *DeletePhyRDiskRequest) (*DeletePhyRDiskResponse, error) {\n\treturn nil, errors.New(\"rpc DeletePhyRDisk of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1177,
        "code_end_line": 1195,
        "code_key": "DeletePhyRDisk",
        "code_value": "func (c *MasterClientProxyImpl) DeletePhyRDisk(ctx context.Context, req *DeletePhyRDiskRequest, opts ...client.Option) (*DeletePhyRDiskResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/DeletePhyRDisk\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"DeletePhyRDisk\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &DeletePhyRDiskResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 204,
        "code_end_line": 210,
        "code_key": "DeletePhyRDisk",
        "code_value": "func (m *MockMasterService) DeletePhyRDisk(ctx context.Context, req *DeletePhyRDiskRequest) (*DeletePhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"DeletePhyRDisk\", ctx, req)\n\tret0, _ := ret[0].(*DeletePhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 213,
        "code_end_line": 216,
        "code_key": "DeletePhyRDisk",
        "code_value": "func (mr *MockMasterServiceMockRecorder) DeletePhyRDisk(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeletePhyRDisk\", reflect.TypeOf((*MockMasterService)(nil).DeletePhyRDisk), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 657,
        "code_end_line": 667,
        "code_key": "DeletePhyRDisk",
        "code_value": "func (m *MockMasterClientProxy) DeletePhyRDisk(ctx context.Context, req *DeletePhyRDiskRequest, opts ...client.Option) (*DeletePhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"DeletePhyRDisk\", varargs...)\n\tret0, _ := ret[0].(*DeletePhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 670,
        "code_end_line": 674,
        "code_key": "DeletePhyRDisk",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) DeletePhyRDisk(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeletePhyRDisk\", reflect.TypeOf((*MockMasterClientProxy)(nil).DeletePhyRDisk), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 657,
        "code_end_line": 676,
        "code_key": "DeletePhyRDisk",
        "code_value": "func (s *masterApiServerImpl) DeletePhyRDisk(ctx context.Context, req *pb.DeletePhyRDiskRequest) (*pb.DeletePhyRDiskResponse, error) {\n\tvar (\n\t\terr      error\n\t\tresponse *pb.DeletePhyRDiskResponse\n\t\tcmd      *commands.DeletePhysicalVolumeCommand\n\t)\n\tcmd = &commands.DeletePhysicalVolumeCommand{\n\t\tSerial: req.PhyId,\n\t\tForce:  req.Force,\n\t}\n\terr = app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, cmd)\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn &pb.DeletePhyRDiskResponse{}, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\tresponse = &pb.DeletePhyRDiskResponse{}\n\treturn response, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 739,
        "code_end_line": 741,
        "code_key": "UpdatePhyRDisk",
        "code_value": "func (s *UnimplementedMaster) UpdatePhyRDisk(ctx context.Context, req *UpdatePhyRDiskRequest) (*UpdatePhyRDiskResponse, error) {\n\treturn nil, errors.New(\"rpc UpdatePhyRDisk of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1217,
        "code_end_line": 1235,
        "code_key": "UpdatePhyRDisk",
        "code_value": "func (c *MasterClientProxyImpl) UpdatePhyRDisk(ctx context.Context, req *UpdatePhyRDiskRequest, opts ...client.Option) (*UpdatePhyRDiskResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/UpdatePhyRDisk\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"UpdatePhyRDisk\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &UpdatePhyRDiskResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 369,
        "code_end_line": 375,
        "code_key": "UpdatePhyRDisk",
        "code_value": "func (m *MockMasterService) UpdatePhyRDisk(ctx context.Context, req *UpdatePhyRDiskRequest) (*UpdatePhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"UpdatePhyRDisk\", ctx, req)\n\tret0, _ := ret[0].(*UpdatePhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 378,
        "code_end_line": 381,
        "code_key": "UpdatePhyRDisk",
        "code_value": "func (mr *MockMasterServiceMockRecorder) UpdatePhyRDisk(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"UpdatePhyRDisk\", reflect.TypeOf((*MockMasterService)(nil).UpdatePhyRDisk), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 877,
        "code_end_line": 887,
        "code_key": "UpdatePhyRDisk",
        "code_value": "func (m *MockMasterClientProxy) UpdatePhyRDisk(ctx context.Context, req *UpdatePhyRDiskRequest, opts ...client.Option) (*UpdatePhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"UpdatePhyRDisk\", varargs...)\n\tret0, _ := ret[0].(*UpdatePhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 890,
        "code_end_line": 894,
        "code_key": "UpdatePhyRDisk",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) UpdatePhyRDisk(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"UpdatePhyRDisk\", reflect.TypeOf((*MockMasterClientProxy)(nil).UpdatePhyRDisk), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 44,
        "code_end_line": 70,
        "code_key": "UpdatePhyRDisk",
        "code_value": "func (s *masterApiServerImpl) UpdatePhyRDisk(ctx context.Context, req *pb.UpdatePhyRDiskRequest) (*pb.UpdatePhyRDiskResponse, error) {\n\tvar dispatcher = app.GetRegistry(ctx).Dispatcher\n\n\tcmd := &commands.UpdatePhyRDiskCommand{\n\t\tSerial: req.PhyId,\n\t\tParams: rdiskDomain.PhysicalVolumeParamsModification{},\n\t}\n\n\tif len(req.Params) == 0 {\n\t\treturn nil, fmt.Errorf(\"no params\")\n\t}\n\n\tif cufString, ok := req.Params[\"cuf\"]; ok {\n\t\tvar cuf = rdiskDomain.Cuf(cufString)\n\t\tcmd.Params.Cuf = &cuf\n\t}\n\n\tif rankString, ok := req.Params[\"performance_rank\"]; ok {\n\t\tvar rank = rdiskDomain.PerformanceRank(rankString)\n\t\tcmd.Params.PerformanceRank = &rank\n\t}\n\n\tif err := dispatcher.Dispatch(ctx, cmd); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &pb.UpdatePhyRDiskResponse{}, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 744,
        "code_end_line": 746,
        "code_key": "OnlinePhyRDisk",
        "code_value": "func (s *UnimplementedMaster) OnlinePhyRDisk(ctx context.Context, req *OnlinePhyRDiskRequest) (*OnlinePhyRDiskResponse, error) {\n\treturn nil, errors.New(\"rpc OnlinePhyRDisk of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1237,
        "code_end_line": 1255,
        "code_key": "OnlinePhyRDisk",
        "code_value": "func (c *MasterClientProxyImpl) OnlinePhyRDisk(ctx context.Context, req *OnlinePhyRDiskRequest, opts ...client.Option) (*OnlinePhyRDiskResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/OnlinePhyRDisk\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"OnlinePhyRDisk\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &OnlinePhyRDiskResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 279,
        "code_end_line": 285,
        "code_key": "OnlinePhyRDisk",
        "code_value": "func (m *MockMasterService) OnlinePhyRDisk(ctx context.Context, req *OnlinePhyRDiskRequest) (*OnlinePhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"OnlinePhyRDisk\", ctx, req)\n\tret0, _ := ret[0].(*OnlinePhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 288,
        "code_end_line": 291,
        "code_key": "OnlinePhyRDisk",
        "code_value": "func (mr *MockMasterServiceMockRecorder) OnlinePhyRDisk(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"OnlinePhyRDisk\", reflect.TypeOf((*MockMasterService)(nil).OnlinePhyRDisk), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 757,
        "code_end_line": 767,
        "code_key": "OnlinePhyRDisk",
        "code_value": "func (m *MockMasterClientProxy) OnlinePhyRDisk(ctx context.Context, req *OnlinePhyRDiskRequest, opts ...client.Option) (*OnlinePhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"OnlinePhyRDisk\", varargs...)\n\tret0, _ := ret[0].(*OnlinePhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 770,
        "code_end_line": 774,
        "code_key": "OnlinePhyRDisk",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) OnlinePhyRDisk(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"OnlinePhyRDisk\", reflect.TypeOf((*MockMasterClientProxy)(nil).OnlinePhyRDisk), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 697,
        "code_end_line": 712,
        "code_key": "OnlinePhyRDisk",
        "code_value": "func (s *masterApiServerImpl) OnlinePhyRDisk(ctx context.Context, req *pb.OnlinePhyRDiskRequest) (*pb.OnlinePhyRDiskResponse, error) {\n\tvar (\n\t\terr      error\n\t\tresponse = &pb.OnlinePhyRDiskResponse{}\n\t\tcmd      *commands.OnlinePhysicalVolumeCommand\n\t)\n\tcmd = &commands.OnlinePhysicalVolumeCommand{\n\t\tSerial: req.PhyId,\n\t}\n\terr = app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, cmd)\n\tresponse.PhyDisk = &pb.PhyRDisk{}\n\tif cmd.GetPhysicalVolume() != nil {\n\t\tencodePhysicalVolume(cmd.GetPhysicalVolume(), response.PhyDisk)\n\t}\n\treturn response, err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 749,
        "code_end_line": 751,
        "code_key": "OfflinePhyRDisk",
        "code_value": "func (s *UnimplementedMaster) OfflinePhyRDisk(ctx context.Context, req *OfflinePhyRDiskRequest) (*OfflinePhyRDiskResponse, error) {\n\treturn nil, errors.New(\"rpc OfflinePhyRDisk of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1257,
        "code_end_line": 1275,
        "code_key": "OfflinePhyRDisk",
        "code_value": "func (c *MasterClientProxyImpl) OfflinePhyRDisk(ctx context.Context, req *OfflinePhyRDiskRequest, opts ...client.Option) (*OfflinePhyRDiskResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/OfflinePhyRDisk\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"OfflinePhyRDisk\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &OfflinePhyRDiskResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 264,
        "code_end_line": 270,
        "code_key": "OfflinePhyRDisk",
        "code_value": "func (m *MockMasterService) OfflinePhyRDisk(ctx context.Context, req *OfflinePhyRDiskRequest) (*OfflinePhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"OfflinePhyRDisk\", ctx, req)\n\tret0, _ := ret[0].(*OfflinePhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 273,
        "code_end_line": 276,
        "code_key": "OfflinePhyRDisk",
        "code_value": "func (mr *MockMasterServiceMockRecorder) OfflinePhyRDisk(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"OfflinePhyRDisk\", reflect.TypeOf((*MockMasterService)(nil).OfflinePhyRDisk), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 737,
        "code_end_line": 747,
        "code_key": "OfflinePhyRDisk",
        "code_value": "func (m *MockMasterClientProxy) OfflinePhyRDisk(ctx context.Context, req *OfflinePhyRDiskRequest, opts ...client.Option) (*OfflinePhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"OfflinePhyRDisk\", varargs...)\n\tret0, _ := ret[0].(*OfflinePhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 750,
        "code_end_line": 754,
        "code_key": "OfflinePhyRDisk",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) OfflinePhyRDisk(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"OfflinePhyRDisk\", reflect.TypeOf((*MockMasterClientProxy)(nil).OfflinePhyRDisk), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 679,
        "code_end_line": 694,
        "code_key": "OfflinePhyRDisk",
        "code_value": "func (s *masterApiServerImpl) OfflinePhyRDisk(ctx context.Context, req *pb.OfflinePhyRDiskRequest) (*pb.OfflinePhyRDiskResponse, error) {\n\tvar (\n\t\terr      error\n\t\tresponse = &pb.OfflinePhyRDiskResponse{}\n\t\tcmd      *commands.OfflinePhysicalVolumeCommand\n\t)\n\tcmd = &commands.OfflinePhysicalVolumeCommand{\n\t\tSerial: req.PhyId,\n\t}\n\terr = app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, cmd)\n\tresponse.PhyDisk = &pb.PhyRDisk{}\n\tif cmd.GetPhysicalVolume() != nil {\n\t\tencodePhysicalVolume(cmd.GetPhysicalVolume(), response.PhyDisk)\n\t}\n\treturn response, err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 754,
        "code_end_line": 756,
        "code_key": "BenchmarkPhyRDisk",
        "code_value": "func (s *UnimplementedMaster) BenchmarkPhyRDisk(ctx context.Context, req *BenchmarkPhyRDiskRequest) (*BenchmarkPhyRDiskResponse, error) {\n\treturn nil, errors.New(\"rpc BenchmarkPhyRDisk of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1277,
        "code_end_line": 1295,
        "code_key": "BenchmarkPhyRDisk",
        "code_value": "func (c *MasterClientProxyImpl) BenchmarkPhyRDisk(ctx context.Context, req *BenchmarkPhyRDiskRequest, opts ...client.Option) (*BenchmarkPhyRDiskResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/BenchmarkPhyRDisk\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"BenchmarkPhyRDisk\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &BenchmarkPhyRDiskResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 54,
        "code_end_line": 60,
        "code_key": "BenchmarkPhyRDisk",
        "code_value": "func (m *MockMasterService) BenchmarkPhyRDisk(ctx context.Context, req *BenchmarkPhyRDiskRequest) (*BenchmarkPhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"BenchmarkPhyRDisk\", ctx, req)\n\tret0, _ := ret[0].(*BenchmarkPhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 63,
        "code_end_line": 66,
        "code_key": "BenchmarkPhyRDisk",
        "code_value": "func (mr *MockMasterServiceMockRecorder) BenchmarkPhyRDisk(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"BenchmarkPhyRDisk\", reflect.TypeOf((*MockMasterService)(nil).BenchmarkPhyRDisk), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 457,
        "code_end_line": 467,
        "code_key": "BenchmarkPhyRDisk",
        "code_value": "func (m *MockMasterClientProxy) BenchmarkPhyRDisk(ctx context.Context, req *BenchmarkPhyRDiskRequest, opts ...client.Option) (*BenchmarkPhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"BenchmarkPhyRDisk\", varargs...)\n\tret0, _ := ret[0].(*BenchmarkPhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 470,
        "code_end_line": 474,
        "code_key": "BenchmarkPhyRDisk",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) BenchmarkPhyRDisk(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"BenchmarkPhyRDisk\", reflect.TypeOf((*MockMasterClientProxy)(nil).BenchmarkPhyRDisk), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 109,
        "code_end_line": 124,
        "code_key": "BenchmarkPhyRDisk",
        "code_value": "func (*masterApiServerImpl) BenchmarkPhyRDisk(ctx context.Context, req *pb.BenchmarkPhyRDiskRequest) (*pb.BenchmarkPhyRDiskResponse, error) {\n\tvar dispatcher = app.GetRegistry(ctx).Dispatcher\n\n\tcmd := &commands.CreateBenchmarkCommand{\n\t\tSerial: req.PhyId,\n\t}\n\n\tif err := dispatcher.Dispatch(ctx, cmd); err != nil {\n\t\treturn nil, err\n\t}\n\n\tresp := &pb.BenchmarkPhyRDiskResponse{}\n\tresp.TaskId = cmd.GetBenchmark().UUID.String()\n\n\treturn resp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 764,
        "code_end_line": 766,
        "code_key": "DefunctPhyRDisk",
        "code_value": "func (s *UnimplementedMaster) DefunctPhyRDisk(ctx context.Context, req *DefunctPhyRDiskRequest) (*DefunctPhyRDiskResponse, error) {\n\treturn nil, errors.New(\"rpc DefunctPhyRDisk of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1317,
        "code_end_line": 1335,
        "code_key": "DefunctPhyRDisk",
        "code_value": "func (c *MasterClientProxyImpl) DefunctPhyRDisk(ctx context.Context, req *DefunctPhyRDiskRequest, opts ...client.Option) (*DefunctPhyRDiskResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/DefunctPhyRDisk\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"DefunctPhyRDisk\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &DefunctPhyRDiskResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 189,
        "code_end_line": 195,
        "code_key": "DefunctPhyRDisk",
        "code_value": "func (m *MockMasterService) DefunctPhyRDisk(ctx context.Context, req *DefunctPhyRDiskRequest) (*DefunctPhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"DefunctPhyRDisk\", ctx, req)\n\tret0, _ := ret[0].(*DefunctPhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 198,
        "code_end_line": 201,
        "code_key": "DefunctPhyRDisk",
        "code_value": "func (mr *MockMasterServiceMockRecorder) DefunctPhyRDisk(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DefunctPhyRDisk\", reflect.TypeOf((*MockMasterService)(nil).DefunctPhyRDisk), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 637,
        "code_end_line": 647,
        "code_key": "DefunctPhyRDisk",
        "code_value": "func (m *MockMasterClientProxy) DefunctPhyRDisk(ctx context.Context, req *DefunctPhyRDiskRequest, opts ...client.Option) (*DefunctPhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"DefunctPhyRDisk\", varargs...)\n\tret0, _ := ret[0].(*DefunctPhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 650,
        "code_end_line": 654,
        "code_key": "DefunctPhyRDisk",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) DefunctPhyRDisk(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DefunctPhyRDisk\", reflect.TypeOf((*MockMasterClientProxy)(nil).DefunctPhyRDisk), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 87,
        "code_end_line": 106,
        "code_key": "DefunctPhyRDisk",
        "code_value": "func (*masterApiServerImpl) DefunctPhyRDisk(ctx context.Context, req *pb.DefunctPhyRDiskRequest) (*pb.DefunctPhyRDiskResponse, error) {\n\tvar dispatcher = app.GetRegistry(ctx).Dispatcher\n\tvar cmd = &commands.DefunctPhysicalVolumeCommand{\n\t\tSerial:         rdiskDomain.Serial(req.PhyId),\n\t\tHostIP:         net.ParseIP(req.HostIp),\n\t\tBDF:            rdiskDomain.BDF(req.BdfId),\n\t\tAuthorizeToken: req.AuthorizeToken,\n\t}\n\n\tif err := cmd.Prepare(ctx); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := dispatcher.Dispatch(ctx, cmd); err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar resp = &pb.DefunctPhyRDiskResponse{}\n\treturn resp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/tasks/update_benchmark.go",
        "code_start_line": 25,
        "code_end_line": 52,
        "code_key": "Work",
        "code_value": "func (*UpdateBenchmarkTask) Work(ctx context.Context) error {\n\tvar (\n\t\tviewer     = app.GetRegistry(ctx).Viewers.Benchmark\n\t\tdispatcher = app.GetRegistry(ctx).Dispatcher\n\t)\n\n\t// 1. Find all running benchmarks\n\trunningStatus := []benchmark.Status{benchmark.StatusRunning}\n\tbenchs, err := viewer.FindByStatus(ctx, runningStatus)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 2. Fire events to update running benchmarks\n\tlogs.Info(ctx).Int(\"count\", len(benchs)).Msg(\"starts to update benchmark data\")\n\tfor _, b := range benchs {\n\t\tcmd := &commands.UpdateBenchmarkTask{\n\t\t\tSerial:        b.DiskInfo.Serial,\n\t\t\tBenchmarkUUID: b.UUID,\n\t\t}\n\t\terr := dispatcher.Dispatch(ctx, cmd)\n\t\tif err != nil {\n\t\t\tlogs.Warn(ctx).Err(err).Str(\"uuid\", b.UUID.String()).Msg(\"update benchmark task failed\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/tasks/cleanup_defunct.go",
        "code_start_line": 27,
        "code_end_line": 69,
        "code_key": "Work",
        "code_value": "func (*CleanupDefunctTask) Work(ctx context.Context) error {\n\tvar err error\n\tvar batchSize uint64 = 1000\n\tvar defunctingVolumes []*rdiskDomain.LogicalVolume\n\tdefunctingVolumes, err = app.GetRegistry(ctx).Viewers.LogicalVolume.FindByStatus(\n\t\tctx, []rdiskDomain.LogicalVolumeState{rdiskDomain.LVSDefuncting}, rdiskDomain.Pagination{Limit: batchSize})\n\tif err != nil {\n\t\tlogs.Error(ctx).Err(err).Msg(\"failed to find defuncting volumes\")\n\t\treturn err\n\t}\n\tif len(defunctingVolumes) == 0 {\n\t\tlogs.Debug(ctx).Msg(\"no defuncting volumes found\")\n\t\treturn nil\n\t}\n\n\tlogs.Info(ctx).Int(\"count\", len(defunctingVolumes)).Msg(\"starts to cleanup defuncting volumes\")\n\n\tvar waitInterval = time.Second * 10\n\tvar dispatcher = app.GetRegistry(ctx).Dispatcher\n\tfor _, volume := range defunctingVolumes {\n\t\tif ctx.Err() != nil {\n\t\t\t// 上下文已经被取消, 退出\n\t\t\treturn ctx.Err()\n\t\t}\n\t\tfunc(volume *rdiskDomain.LogicalVolume) {\n\t\t\tlogs.Info(ctx).Stringer(\"uuid\", volume.UUID).Msg(\"cleanuping defunct volume\")\n\t\t\tsubCtx, cancel := context.WithTimeout(ctx, waitInterval)\n\t\t\tdefer cancel()\n\t\t\tcmd := &commands.CleanupDefunctCommand{UUID: volume.UUID}\n\t\t\tif err := dispatcher.Dispatch(subCtx, cmd); err != nil {\n\t\t\t\tif err == subCtx.Err() {\n\t\t\t\t\t// 等待超时了，在后台 dispatcher 会继续清理，这里直接返回\n\t\t\t\t\tlogs.Info(subCtx).Stringer(\"uuid\", volume.UUID).Msg(\"timeout waiting for cleanup defunct volume, move up to next\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlogs.Error(subCtx).Err(err).Str(\"uuid\", volume.UUID.String()).Msg(\"failed to cleanup defunct volume\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tlogs.Info(subCtx).Stringer(\"uuid\", volume.UUID).Msg(\"cleanup defunct volume done\")\n\t\t}(volume)\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/tasks/update_backup.go",
        "code_start_line": 25,
        "code_end_line": 51,
        "code_key": "Work",
        "code_value": "func (*UpdateBackupTask) Work(ctx context.Context) error {\n\tvar (\n\t\tviewer     = app.GetRegistry(ctx).Viewers.Backup\n\t\tdispatcher = app.GetRegistry(ctx).Dispatcher\n\t)\n\n\t// 1. 查询所有正在备份的备份\n\tstatusList := []backup.BackupStatus{backup.StatusRunning}\n\tbaks, err := viewer.FindByStatus(ctx, statusList)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 2. 更新备份进度\n\tlogs.Info(ctx).Int(\"count\", len(baks)).Msg(\"starts to update running backup task\")\n\tfor _, bak := range baks {\n\t\tcmd := &commands.UpdateRunningBackupTaskCommand{\n\t\t\tUUID: bak.UUID,\n\t\t}\n\t\terr := dispatcher.Dispatch(ctx, cmd)\n\t\tif err != nil {\n\t\t\tlogs.Warn(ctx).Err(err).Str(\"uuid\", bak.UUID.String()).Msg(\"update backup task failed\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/tasks/confirm_init_physical_disk.go",
        "code_start_line": 25,
        "code_end_line": 63,
        "code_key": "Work",
        "code_value": "func (*ConfirmInitPhysicalDiskTask) Work(ctx context.Context) error {\n\tvar (\n\t\tviewer     = app.GetRegistry(ctx).Viewers.PhysicalVolume\n\t\tdispatcher = app.GetRegistry(ctx).Dispatcher\n\t)\n\n\t// 1. 查询所有待初始化的物理卷\n\tcriteria := rdiskDomain.PVSearchCriteria{}\n\tcriteria.States = []rdiskDomain.PhysicalVolumeState{rdiskDomain.PVSInited}\n\tpagination := rdiskDomain.Pagination{Limit: 10}\n\n\tresults, err := viewer.Search(ctx, criteria, pagination)\n\tif err != nil {\n\t\tlogs.Warn(ctx).Err(err).Msg(\"search physical volume failed\")\n\t\treturn err\n\t}\n\n\tif len(results) == 0 {\n\t\tlogs.Debug(ctx).Msg(\"no physical volume to be initialized\")\n\t\treturn nil\n\t}\n\n\t// TODO: 是否可以增加一个退避机制，对于长时间没有成功初始化的物理卷，增加重试时间间隔\n\n\t// 2. 发起初始化\n\tlogs.Info(ctx).Int(\"count\", len(results)).Msg(\"starts to initialize disks\")\n\tfor _, vol := range results {\n\t\tcmd := &commands.ConfirmInitPhysicalVolumeCommand{\n\t\t\tSerial: string(vol.Serial),\n\t\t\tHost:   vol.IP,\n\t\t}\n\t\terr := dispatcher.Dispatch(ctx, cmd)\n\t\tif err != nil {\n\t\t\tlogs.Warn(ctx).Err(err).Str(\"serial\", string(vol.Serial)).Str(\"host_ip\", vol.IP.String()).Msg(\"confirm init physical volume failed\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/tasks/recycle_backup_data.go",
        "code_start_line": 25,
        "code_end_line": 51,
        "code_key": "Work",
        "code_value": "func (*RecycleBackupTask) Work(ctx context.Context) error {\n\tvar (\n\t\tviewer     = app.GetRegistry(ctx).Viewers.Backup\n\t\tdispatcher = app.GetRegistry(ctx).Dispatcher\n\t)\n\n\t// 1. 查询所有待删除的备份\n\tstatusList := []backup.BackupStatus{backup.StatusToDelete, backup.StatusFailed}\n\tbaks, err := viewer.FindByStatus(ctx, statusList)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 2. 发起清理数据\n\tlogs.Info(ctx).Int(\"count\", len(baks)).Msg(\"starts to recycle backup data\")\n\tfor _, bak := range baks {\n\t\tcmd := &commands.RecycleBackupDataCommand{\n\t\t\tUUID: bak.UUID,\n\t\t}\n\t\terr := dispatcher.Dispatch(ctx, cmd)\n\t\tif err != nil {\n\t\t\tlogs.Warn(ctx).Err(err).Str(\"uuid\", bak.UUID.String()).Msg(\"update backup task failed\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/easyha/model.go",
        "code_start_line": 84,
        "code_end_line": 84,
        "code_key": "Option",
        "code_value": "type Option func(*haManagerImpl)",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/dlock.go",
        "code_start_line": 75,
        "code_end_line": 81,
        "code_key": "Option",
        "code_value": "type Option struct {\n\t// RetryStrategy 允许用户自定义锁的重试策略\n\tRetryStrategy RetryStrategy\n\n\t// Token 是用于标识锁的唯一值。默认情况下，会生成一个随机的 token。使用这个选项可以提供自定义的 token。\n\tToken string\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/benchmark.go:17:29:Add": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/benchmark.go",
    "code_start_line": 17,
    "code_end_line": 29,
    "code_start_column": 43,
    "code_key": "Add",
    "code_value": "func (repo *rdiskBenchmarkRepositoryImpl) Add(ctx context.Context, bench *benchmark.Benchmark) error {\n\tdo := repo.fromModelToDO(bench)\n\tuow := getUow(ctx)\n\tdo.Created = uow.tx.NowFunc()\n\tdo.Updated = uow.tx.NowFunc()\n\tresult := uow.tx.Create(&do)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tbench.ID = do.ID\n\tuow.trackedBenchmarks.Add(bench)\n\treturn nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/infra/event_bus/bus.go",
        "code_start_line": 61,
        "code_end_line": 79,
        "code_key": "Execute",
        "code_value": "func (eb *EventBusDriver) Execute(ctx context.Context) (result *response.Result) {\n\tresult = response.DefaultResult()\n\tdefer utils.HandlePanic(ctx, &result)\n\n\tfor _, event := range eb.BlockEventQueue {\n\t\tresult = eb.ExecuteOne(ctx, event)\n\t\tif result.IsSuccess() {\n\t\t\tevent.UpdateState(ctx, Executed)\n\t\t} else {\n\t\t\tlogs.Warn(ctx).Err(result).Int(\"EventType\", int(event.GetType(ctx))).\n\t\t\t\tMsg(\"event execute failed, start rollback event bus\")\n\t\t\tif err := eb.RollbackEvents(ctx); err != nil {\n\t\t\t\tlogs.Error(ctx).Err(err).Int(\"EventType\", int(event.GetType(ctx))).Msg(\"rollback event bus failed\")\n\t\t\t}\n\t\t\treturn result\n\t\t}\n\t}\n\treturn result\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/filters/filter.go",
        "code_start_line": 26,
        "code_end_line": 46,
        "code_key": "Execute",
        "code_value": "func (f FilterChain) Execute(ctx context.Context, disks []*disk.Disk, user *account.User,\n\tcacheMap cache.RDCacheManagerInf, affinityConfig *dto.AffinityConfig) ([]*disk.Disk, response.Result) {\n\tlogs.Info(ctx).Int(\"disk_count\", len(disks)).Msg(\"DISK_COUNT_BEFORE_FILTER\")\n\tfor _, filter := range f.filters {\n\t\tdisks, result := filter.\n\t\t\tWithUser(ctx, user).\n\t\t\tWithRdCacheManager(ctx, cacheMap).\n\t\t\tWithAffinityConfig(ctx, affinityConfig).\n\t\t\tFilter(ctx, disks)\n\t\tdisks = disk.SortByScore(ctx, disks)\n\t\tlogs.Info(ctx).\n\t\t\tInt(\"disk_count\", len(disks)).\n\t\t\tStr(\"filter\", reflect.TypeOf(filter).Name()).\n\t\t\tMsg(\"LEFT_DISK_COUNT_AFTER_FILTER\")\n\t\tif result.IsFailed() {\n\t\t\treturn disks, result\n\t\t}\n\t}\n\t// 对盘的Score进行排序\n\treturn disks, response.SucResult()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_bill_compute_task.go",
        "code_start_line": 26,
        "code_end_line": 40,
        "code_key": "Execute",
        "code_value": "func (t *SnapBillComputeTask) Execute(ctx context.Context) (bool, error) {\n\tt.Ctx = ctx\n\tt.InitTask(ctx)\n\tdefer t.MqIns.Close()\n\n\t// 获取待处理的用户资源\n\tgo t.GetUserResources()\n\t// 执行Ack确认逻辑\n\tgo t.AckAppId()\n\t// 处理用户资源\n\tt.ProcessUserResources()\n\n\tlogs.Info(ctx).Msg(\"SNAP_COMPUTE_TASK_DONE\")\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_calculate_cost_locally_task.go",
        "code_start_line": 21,
        "code_end_line": 37,
        "code_key": "Execute",
        "code_value": "func (t *SnapCalculateCostLocallyTask) Execute(ctx context.Context) (bool, error) {\n\tt.ctx = ctx\n\tsnapRecSrv := measureReconciliation.NewReconciliationSrvImpl(ctx)\n\n\t// 结算上上个周期的用量\n\tnow := time.Now()\n\tstartTime := now.Truncate(time.Hour).Add(-2 * time.Hour)\n\tendTime := now.Truncate(time.Hour).Add(-1 * time.Hour).Add(-1 * time.Second)\n\tlogs.Info(t.ctx).Time(\"startTime\", startTime).Time(\"endTime\", endTime).Msg(\"START_CALCULATE_COST_LOCALLY\")\n\terr := snapRecSrv.CalculateCostLocally(startTime, endTime)\n\tif err != nil {\n\t\tlogs.Error(t.ctx).Err(err).Msg(\"CALCULATE_COST_LOCALLY_ERROR\")\n\t\treturn false, err\n\t}\n\tlogs.Info(t.ctx).Msg(\"CALCULATE_COST_LOCALLY_DONE\")\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/cbs_bill_compute_task.go",
        "code_start_line": 26,
        "code_end_line": 42,
        "code_key": "Execute",
        "code_value": "func (t *CbsBillComputeTask) Execute(ctx context.Context) (bool, error) {\n\tt.Ctx = ctx\n\tt.InitTask(ctx)\n\tdefer t.MqIns.Close()\n\n\t// 获取待处理的用户资源\n\tgo t.GetUserResources()\n\t// 执行Ack确认逻辑\n\tgo t.AckAppId()\n\t// 处理用户资源\n\tt.ProcessUserResources()\n\tt.ChargeItemProducer.Close()\n\n\tt.WG.Wait()\n\tlogs.Info(ctx).Msg(\"CBS_COMPUTE_TASK_DONE\")\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/update_ccbs_normal_rb_task.go",
        "code_start_line": 23,
        "code_end_line": 34,
        "code_key": "Execute",
        "code_value": "func (t *UpdateCCbsNormalRollbackTask) Execute(ctx context.Context) (bool, error) {\n\tt.Count += 1\n\tserv := registry.GetRegistry(ctx).DomainServices.DiskRollbackingService.(diskLogical.DiskRollbackingServiceInterface)\n\tisFinish, err := serv.UpdateCbsRollbackingPercent(ctx, t.DiskAggregate)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tlogs.Info(ctx).Int(\"Status\", t.DiskAggregate.DiskRecord.Status).\n\t\tInt(\"Percent\", t.DiskAggregate.DiskRecord.RollbackingPercent).\n\t\tInt(\"Count\", t.Count).Msg(\"FINISH_EXECUTE_TASK\")\n\treturn isFinish, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/repush_user_billing_task.go",
        "code_start_line": 53,
        "code_end_line": 61,
        "code_key": "Execute",
        "code_value": "func (t *RepushUserBillingTask) Execute(ctx context.Context) (bool, error) {\n\tt.ctx = ctx\n\tt.InitTask(ctx)\n\tdefer t.MqIns.Close()\n\n\tt.ProcessRepushDetailMsg()\n\tlogs.Info(ctx).Msg(\"REPUSH_USER_BILLING_TASK_DONE\")\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/update_create_task.go",
        "code_start_line": 31,
        "code_end_line": 69,
        "code_key": "Execute",
        "code_value": "func (t *UpdateCreateTask) Execute(ctx context.Context) (bool, error) {\n\tt.Count += 1\n\tserv := registry.GetRegistry(ctx).DomainServices.SnapCreatingService.(snapLogical.SnapCreatingServiceInterface)\n\tif t.SnapAggregate.SnapRecord.Status == ccdb.SnapCreating &&\n\t\tt.SnapAggregate.SnapRecord.LifeState == ccdb.SnapLifeStateNormal &&\n\t\tt.SnapAggregate.SnapRecord.Percent == 100 &&\n\t\tt.SnapAggregate.SnapRecord.Attribute != ccdb.SnapAttUserSnap {\n\t\t// 隐藏快照转正常快照\n\t\tlogs.Info(ctx).Msg(\"FIX_INNER_TO_NORMAL\")\n\t\terr := serv.SnapCreateTaskFollowup(ctx, t.SnapAggregate, SnapInnerFollowup)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\treturn true, nil\n\t}\n\n\tisFinish, err := serv.UpdateSnapCreatingPercent(ctx, t.SnapAggregate)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\t// 创建完成的用户快照进行后续操作，隐藏快照不进行\n\tif isFinish && t.SnapAggregate.SnapRecord.Status == ccdb.SnapNormal &&\n\t\tt.SnapAggregate.SnapRecord.LifeState == ccdb.SnapLifeStateNormal {\n\t\t// 目的端快照复制完成时，需更新源端的快照状态\n\t\t// 计算base snap size，并更新\n\t\t// merge\n\t\t// 插入计费，并更新快照大小\n\t\terr = serv.SnapCreateTaskFollowup(ctx, t.SnapAggregate, SnapNormalFollowup)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\n\tlogs.Info(ctx).Int(\"Status\", t.SnapAggregate.SnapRecord.Status).\n\t\tInt(\"Percent\", t.SnapAggregate.SnapRecord.Percent).\n\t\tInt(\"Count\", t.Count).Msg(\"FINISH_EXECUTE_TASK\")\n\treturn isFinish, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/update_image_snap_rb_task.go",
        "code_start_line": 23,
        "code_end_line": 41,
        "code_key": "Execute",
        "code_value": "func (t *UpdateImageSnapRollbackTask) Execute(ctx context.Context) (bool, error) {\n\tt.Count += 1\n\tserv := registry.GetRegistry(ctx).DomainServices.DiskRollbackingService.(diskLogical.DiskRollbackingServiceInterface)\n\tisFinish, err := serv.UpdateImageSnapRollbackingPercent(ctx, t.DiskAggregate)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif isFinish {\n\t\t// TODO：这里应该放入一个管道中，后续再优化\n\t\terr = serv.UpdateRollbackQuota(ctx, t.DiskAggregate)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\tlogs.Info(ctx).Str(\"Status\", t.DiskAggregate.ImageSnapRollbackRecord.Status).\n\t\tInt(\"Percent\", t.DiskAggregate.ImageSnapRollbackRecord.Percent).\n\t\tInt(\"Count\", t.Count).Msg(\"FINISH_EXECUTE_TASK\")\n\treturn isFinish, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/cbs_measure_send_task.go",
        "code_start_line": 30,
        "code_end_line": 54,
        "code_key": "Execute",
        "code_value": "func (t *CbsMeasureSendTask) Execute(ctx context.Context) (bool, error) {\n\t// 初始化各项配置\n\tt.Ctx = ctx\n\tt.InitTask(ctx)\n\tt.cbsSrv = cbsResource.NewCbsSrvImpl(t.Ctx)\n\tdefer t.MqIns.Close()\n\t// 根据区域分发到国内和国际两个不同channel中去处理\n\tt.ChannelDistribution()\n\n\t// MSG处理的生命周期Msg -->chargeItem -->MeasureDetails-->MeasureDetailsChannel-->Params-->Ack Msg\n\tgo t.ProcessMsgByRegion()\n\n\t// 计费详情转换成计费参数\n\tgo t.ProcessMeasureDetailToParams()\n\n\t// 执行ACK\n\tgo t.AckResourceID()\n\n\t// 根据计费参数发送计费消息\n\tt.ProcessParamsSendMeasure()\n\n\tt.WG.Wait()\n\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/cbs_rec_task.go",
        "code_start_line": 37,
        "code_end_line": 61,
        "code_key": "Execute",
        "code_value": "func (t *CbsMeasureRecTask) Execute(ctx context.Context) (bool, error) {\n\t// 初始化各项配置\n\tt.Ctx = ctx\n\tt.InitTask(ctx)\n\t// 初始化snapSrv\n\tt.cbsReSrv = measureReconciliation.NewReconciliationSrvImpl(t.Ctx)\n\tt.cbsSrv = cbsResource.NewCbsSrvImpl(t.Ctx)\n\tdefer t.MqIns.Close()\n\t// 根据区域分发到国内和国际两个不同channel中去处理\n\tt.ChannelDistribution()\n\n\t// MSG处理的生命周期Msg -->chargeItem -->subMeasureDetails-->subMeasureDetailsChannel-->db-->Ack Msg\n\tgo t.ProcessMsg()\n\n\t// 生成批次外发的计费对账数据\n\tgo t.ProcessMeasureDetailBatch()\n\n\t// 执行ACK\n\tgo t.AckResourceID()\n\n\t// 将计费数据外发到数据库\n\tt.ProcessMeasureToDb()\n\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_measure_send_task.go",
        "code_start_line": 27,
        "code_end_line": 49,
        "code_key": "Execute",
        "code_value": "func (t *SnapMeasureSendTask) Execute(ctx context.Context) (bool, error) {\n\t// 初始化各项配置\n\tt.Ctx = ctx\n\tt.InitTask(ctx)\n\tdefer t.MqIns.Close()\n\n\t// 根据区域分发到国内和国际两个不同channel中去处理\n\tt.ChannelDistribution()\n\n\t// 启动外发任务\n\tgo t.ProcessMsgByRegion()\n\n\t// 用量详情转换成计费协议\n\tgo t.ProcessMeasureDetailToParams()\n\n\t// 执行ACK\n\tgo t.AckResourceID()\n\n\t// 根据计费协议发送到计费客户端\n\tt.ProcessParamsSendMeasure()\n\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_rec_task.go",
        "code_start_line": 48,
        "code_end_line": 61,
        "code_key": "Execute",
        "code_value": "func (t *SnapMeasureReconciliationTask) Execute(ctx context.Context) (bool, error) {\n\t// 初始化各项配置\n\tt.ctx = ctx\n\tt.initTask()\n\n\t// 将数据推送到数据库\n\tvar wg sync.WaitGroup\n\tgo t.sendDbFromMsg(&wg)\n\n\t// 执行ACK\n\tgo t.AckResourceID()\n\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/base_measure/base_appId_fetch_task.go",
        "code_start_line": 38,
        "code_end_line": 61,
        "code_key": "Execute",
        "code_value": "func (t *BaseAppIdFetchTask) Execute(ctx context.Context) (bool, error) {\n\tt.ctx = ctx\n\tt.initTask()\n\n\tappIds := t.resSrv.GetAppIdsWithValidResources(t.chargeTime)\n\tfor _, appId := range appIds {\n\t\tappIdItem := measure.AppIdInfo{\n\t\t\tAppId: appId,\n\t\t}\n\t\t// Send自带Confirm机制. error为nil表示发送成功\n\t\t// Send会阻塞等待Confirm，如果需要，可以考虑放协程里跑\n\t\terr := t.client.Send(ctx, measure.BuildRabbitRequest(&appIdItem))\n\t\tif err != nil {\n\t\t\tlogs.Error(ctx).Err(err).Msg(\"SEND_MESSAGE_FAILED\")\n\t\t\treturn false, err\n\t\t}\n\t\tlogs.Info(ctx).Interface(\"appId\", appId).Msg(\"SEND_MESSAGE_SUCCESS\")\n\t}\n\n\tstopChan := make(chan struct{})\n\t_ = t.server.Close(stopChan)\n\t<-stopChan\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/managers/shm.go",
        "code_start_line": 86,
        "code_end_line": 88,
        "code_key": "ListExpiredKeys",
        "code_value": "func (s *ShmCacheManager) ListExpiredKeys(ctx context.Context) []interface{} {\n\tpanic(\"implement me\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/subgroup.go",
        "code_start_line": 46,
        "code_end_line": 54,
        "code_key": "ListExpiredKeys",
        "code_value": "func (s *SubGroupCacheManager) ListExpiredKeys(ctx context.Context) []interface{} {\n\tvar expiredKeys []interface{}\n\tfor expireTime, keys := range s.cacheMap.GetExpireTimeMap() {\n\t\tif time.Now().Add(time.Duration(SafeReserveSeconds)*time.Second).Unix() >= expireTime {\n\t\t\texpiredKeys = append(expiredKeys, keys...)\n\t\t}\n\t}\n\treturn expiredKeys\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/filters/dmg.go",
        "code_start_line": 107,
        "code_end_line": 133,
        "code_key": "filterWithHostAff",
        "code_value": "func (r RdPlacementGroupFilter) filterWithHostAff(ctx context.Context, disks []*disk.Disk) []*disk.Disk {\n\t/**\n\t检查母机置放群组亲和性\n\t\t1. 检查单母机绑定的置放群组子组数量不会超过置放群组亲和度限制\n\t    2. 置放群组是强制性装箱规则，不满足置放群组的盘被舍弃掉\n\t*/\n\tif len(disks) == 0 {\n\t\treturn disks\n\t}\n\twg := &sync.WaitGroup{}\n\twg.Add(len(disks))\n\n\tfor _, oneDisk := range disks {\n\t\tgo r.checkHostAffWithSingleDisk(ctx, oneDisk, wg)\n\t}\n\twg.Wait()\n\n\t// 对置放群组亲和性检查的盘进行过滤,打标分数小于0的过滤掉\n\tdiskSlice := make([]*disk.Disk, 0, 100000)\n\tfor _, oneDisk := range disks {\n\t\tif oneDisk.Score >= 0 {\n\t\t\tdiskSlice = append(diskSlice, oneDisk)\n\t\t}\n\t}\n\treturn diskSlice\n\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/tracker.go",
        "code_start_line": 67,
        "code_end_line": 77,
        "code_key": "Refresh",
        "code_value": "func (rdp *PhyDiskTracker) Refresh(ctx context.Context) {\n\trdp.Track(ctx)\n\tlock.RDPhyCacheGlobalLock.GetLocker(lock.RDPhyLockKeyGenerator{}).Lock()\n\trdp.Merge(ctx, rdp.OriPhyDisks)\n\tlogs.Info(ctx).\n\t\tInt(\"disk_num\", len(rdp.ToCachedPhyDisks)).\n\t\tInt(\"member_num\", len(rdp.DrgroupMembers)).\n\t\tMsg(\"CACHE_AVAILABLE_PHY_DISK_AFTER_MERGE\")\n\trdp.CacheManager.RefreshCache(ctx, rdp.ToCachedPhyDisks, rdp.DrgroupMembers)\n\tlock.RDPhyCacheGlobalLock.GetLocker(lock.RDPhyLockKeyGenerator{}).Unlock()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/set/cache/tracker.go",
        "code_start_line": 35,
        "code_end_line": 38,
        "code_key": "Refresh",
        "code_value": "func (d *DiskSetTracker) Refresh(ctx context.Context) {\n\td.Track(ctx)\n\td.CacheManager.RefreshCache(ctx, d.DiskSetEntityInf)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 644,
        "code_end_line": 674,
        "code_key": "Refresh",
        "code_value": "func (l *mysqlLock) Refresh(ctx context.Context, ttl time.Duration) error {\n\n\ttx := l.locker.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\n\n\tkeysKey := dlock.LockKeySlice(l.keys).GetKeys()\n\t// NOCA:QCloudAkCheck(误报)\n\texistingLocks, err := l.locker.fetchExistingLocksByKeysAndTokens(tx, keysKey, l.tokens)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn err\n\t}\n\n\t// Compare existing locks with the keys.\n\tif !checkStrSetEqual(existingLocks, keysKey) {\n\t\t_ = tx.Rollback()\n\t\treturn errors.Wrap(dlock.ErrLockNotHeld, \"lock is not held\")\n\t}\n\n\t// Update the expiration time.\n\tif err := l.locker.updateLocksTTLByKeysAndTokens(tx, keysKey, l.tokens, ttl); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn err\n\t}\n\n\tif result := tx.Commit(); result.Error != nil {\n\t\treturn errors.Wrap(result.Error, \"failed to commit refresh locks\")\n\t}\n\n\tl.expiration = time.Now().Add(ttl)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mem/memdlock.go",
        "code_start_line": 189,
        "code_end_line": 210,
        "code_key": "Refresh",
        "code_value": "func (l *memLock) Refresh(ctx context.Context, ttl time.Duration) error {\n\tl.locker.mutex.Lock()\n\tdefer l.locker.mutex.Unlock()\n\n\ttokens := make(map[string]struct{}, len(l.tokens))\n\tfor _, item := range l.tokens {\n\t\ttokens[item] = struct{}{}\n\t}\n\tfor _, key := range l.keys {\n\t\tif item, ok := l.locker.data[key.Key]; ok {\n\t\t\tif _, exist := tokens[item.token]; !exist {\n\t\t\t\treturn dlock.ErrLockNotHeld\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, key := range l.keys {\n\t\tl.locker.data[key.Key].ttl = time.Now().Add(ttl)\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go",
        "code_start_line": 51,
        "code_end_line": 72,
        "code_key": "Handle",
        "code_value": "func (c *CbsAppIdConsumer) Handle(ctx context.Context, delivery *rabbitmq.Delivery) error {\n\tu, chargeTime, err := c.ParseDelivery(ctx, delivery)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif u == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"USER_INFO_NOT_FOUND\")\n\t\treturn nil\n\t}\n\n\tchargeDetail := c.GetChargeDetailForSingleUser(u, chargeTime)\n\tif chargeDetail == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tUint64(\"appId\", uint64(u.AppId)).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"NO_RESOURCE_TO_CHARGE\")\n\t\treturn nil\n\t}\n\treturn c.ProcessChargeDetail(chargeDetail)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 105,
        "code_end_line": 116,
        "code_key": "Handle",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tif err := c.ensureLocks(ctx); err != nil {\n\t\treturn err\n\t}\n\tif c.lvUUID != nil {\n\t\t// 涉及到逻辑卷时，需要先标记逻辑卷为故障\n\t\treturn c.handleBindedVolume(ctx)\n\t} else {\n\t\t// 不涉及到逻辑卷时，直接标记物理卷为故障\n\t\treturn c.handleIdleVolume(ctx)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/detach_logical_volume.go",
        "code_start_line": 56,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *DetachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDetachLogicalVolume, c)\n\n\t// 如果没有挂载到指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume not attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_benchmark_task.go",
        "code_start_line": 125,
        "code_end_line": 165,
        "code_key": "Handle",
        "code_value": "func (c *CreateBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tvolSm     = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = volSm.Fire(ctx, c.relatedVolume.State, domain.PVEStartBenchmark, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark = benchmark.New(benchmark.DiskInfo{\n\t\tSerial: string(c.relatedVolume.Serial),\n\t\tHostIP: c.relatedVolume.IP,\n\t\tBDF:    string(c.relatedVolume.BDF),\n\t})\n\n\tif err = benchRepo.Add(ctx, c.relatedBenchmark); err != nil {\n\t\tdelegate := &benchmarkDelegate{cmd: c}\n\t\tif _err := delegate.TaskFinishCallback(ctx, c.relatedBenchmark); _err != nil {\n\t\t\tlogs.Warn(ctx).Err(_err).Str(\"serial\", string(c.relatedVolume.Serial)).Msg(\"failed to rollback: create bdev\")\n\t\t}\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventCreateBench,\n\t\tbenchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_logical_volume.go",
        "code_start_line": 71,
        "code_end_line": 108,
        "code_key": "Handle",
        "code_value": "func (d *DeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\td.volume, err = repo.FindByID(ctx, d.UUID)\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif e := d.volume.CheckDelete(); e != nil {\n\t\treturn e\n\t}\n\n\tif d.volume.AppID != d.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"refuse to delet: app id mismatch\")\n\t}\n\n\td.drgroup, err = app.GetRegistry(ctx).Repositories.DRGroup.FindByMember(ctx, d.AppID, d.volume.UUID.String())\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\td.drgroup = nil\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := d.checkDRGroupMatch(ctx); err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, d.volume.State, rdiskDomain.LVEMarkToRecycle, d)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_recycled_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmRecycledPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEConfirmRecycled, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_rdisk_backup.go",
        "code_start_line": 52,
        "code_end_line": 75,
        "code_key": "Handle",
        "code_value": "func (c *DeleteRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tsm   = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\tc.relatedBackup, err = repo.FindByUUID(ctx, c.BackupID.String())\n\tif err != nil || c.relatedBackup == nil || c.relatedBackup.AppID != c.AppID {\n\t\treturn errors.New(backupDomain.ErrBackupNotExist, \"backup not exists\")\n\t}\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tc.relatedBackup.Status,\n\t\tbackupDomain.EventSoftDeleteBackup,\n\t\tbackupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: c.relatedBackup})\n\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_rdisk_backup.go",
        "code_start_line": 47,
        "code_end_line": 80,
        "code_key": "Handle",
        "code_value": "func (c *CreateRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tlvSm  = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\tbakSm = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo  = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t_, err = lvSm.Fire(ctx, c.relatedVolume.State, rdiskDomain.LVEBackupStarted, c)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tlv := c.relatedVolume\n\tbackup := backupDomain.New(\n\t\tlv.AppID,\n\t\tbackupDomain.DiskInfo{\n\t\t\tVolumeUUID: lv.UUID,\n\t\t\tVolumeSize: uint64(lv.Size),\n\t\t\tHostIP:     lv.PhysicalVolume.IP,\n\t\t\tHostBDF:    string(lv.PhysicalVolume.BDF),\n\t\t\tSerial:     string(lv.PhysicalVolume.Serial),\n\t\t},\n\t)\n\tif err := repo.Add(ctx, backup); err != nil {\n\t\treturn err\n\t}\n\tc.relatedBackup = backup\n\t_, err = bakSm.Fire(ctx, backupDomain.StatusInit, backupDomain.EventStartBackup, backupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: backup})\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/attach_logical_volume.go",
        "code_start_line": 49,
        "code_end_line": 71,
        "code_key": "Handle",
        "code_value": "func (c *AttachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEAttachLogicalVolume, c)\n\n\t// 如果已经挂载到了指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeAlreadyAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume already attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_delete_logical_volume.go",
        "code_start_line": 34,
        "code_end_line": 55,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\t// 如果逻辑卷不存在，则直接返回成功\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"failed to confirm delete: app id mismatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDeleteLogicalVolume, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/offline_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OfflinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOfflinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *DeletePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\t// 如果物理卷不存在，则直接幂等返回\n\t\treturn nil\n\t}\n\n\tvar event = domain.PVEDeletePhysicalVolume\n\tif c.Force && (c.relatedVolume.State == domain.PVSDefunct) {\n\t\t// 这里的实现不太好，状态机的逻辑不应该侵入 cmd\n\t\t// 时间太赶了，后续重构优化吧\n\t\tevent = domain.PVEForceDeleteForDefunct\n\t}\n\n\tif c.relatedVolume.HasBindedPV() {\n\t\treturn errors.New(domain.ErrVolumeBusy, \"logic volume has binded to this physical volume\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, event, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_logical_volume.go",
        "code_start_line": 55,
        "code_end_line": 70,
        "code_key": "Handle",
        "code_value": "func (c *CleanupLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVECleanupLogicalVolume, c)\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_init_physical_volume.go",
        "code_start_line": 26,
        "code_end_line": 52,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmInitPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\tif c.relatedVolume.IP.String() != c.Host.String() {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume host ip mistmatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVECreatePhysicalVolumeOnHost, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_physical_volume.go",
        "code_start_line": 51,
        "code_end_line": 101,
        "code_key": "Handle",
        "code_value": "func (c *CreatePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\n\t// 获取物理卷状态机\n\tsm := app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\trepo := app.GetRegistry(ctx).Repositories.PhysicalVolume\n\n\t// 检查物理卷是否已经存在，如果存在则直接幂等返回\n\tvol1, err := repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"serial\", c.Serial).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tvol2, err := repo.FindByIPAndBDF(ctx, c.Host, domain.BDF(c.BDF))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"host\", c.Host.String()).Str(\"bdf\", c.BDF).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tfor _, vol := range []*domain.PhysicalVolume{vol1, vol2} {\n\t\texisted, err := c.checkExisting(ctx, vol)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif existed {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// 触发事件，创建物理卷\n\t_, err = sm.Fire(ctx,\n\t\tdomain.PVSUnInited,\n\t\tdomain.PVECreatePhysicalVolume,\n\t\tc,\n\t)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 创建 Bdev 以及格式化移动到创建物理卷的状态机中\n\n\t// _, err = sm.Fire(ctx,\n\t// \tc.GetPhysicalVolume().State,\n\t// \tdomain.PVECreatePhysicalVolumeOnHost,\n\t// \tc,\n\t// )\n\t// if err != nil {\n\t// \treturn err\n\t// }\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_benchmark_task.go",
        "code_start_line": 32,
        "code_end_line": 57,
        "code_key": "Handle",
        "code_value": "func (c *DeleteBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\terr       error\n\t)\n\n\tbench, err := benchRepo.FindByUUID(ctx, c.BenchmarkUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif bench.DiskInfo.Serial != c.Serial {\n\t\treturn errors.Newf(benchmark.ErrTaskNotFound, \"benchmark serial not match %s, want %s\", c.Serial, bench.DiskInfo.Serial)\n\t}\n\n\t_, err = benchSm.Fire(ctx, bench.Status, benchmark.EventDeleteBench, benchmark.Data{Benchmark: bench, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := benchRepo.Delete(ctx, bench); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_logical_volume.go",
        "code_start_line": 52,
        "code_end_line": 98,
        "code_key": "Handle",
        "code_value": "func (c *CreateLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tpvRepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tlvRepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm     = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\t// 1. 查找底层物理卷\n\tc.selectedPhysicalVolume, err = pvRepo.FindBySerial(ctx, rdiskDomain.Serial(c.PhysicalVolumeSerial))\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// 检查底层物理卷大小是否满足要求\n\tif c.selectedPhysicalVolume.Size < rdiskDomain.Size(c.DiskSize) {\n\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume size %d is smaller than requested size %d\", c.selectedPhysicalVolume.Size, c.DiskSize)\n\t}\n\n\t// 检查底层物理卷性能等级是否满足要求\n\tif c.PerformanceRank != \"\" {\n\t\tif string(c.selectedPhysicalVolume.PerformanceRank) != c.PerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not match requested rank %s\", c.selectedPhysicalVolume.PerformanceRank, c.PerformanceRank)\n\t\t}\n\t} else {\n\t\tif c.selectedPhysicalVolume.PerformanceRank != rdiskDomain.DefaultPerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not default rank %s\", c.selectedPhysicalVolume.PerformanceRank, rdiskDomain.DefaultPerformanceRank)\n\t\t}\n\t}\n\n\t// 2. 创建逻辑卷\n\tvol := rdiskDomain.NewLogicalVolume(users.AppID(c.AppID), rdiskDomain.Size(c.DiskSize), rdiskDomain.ZoneID(c.ZoneID))\n\tif c.VolumeType != \"\" {\n\t\tvol.VolumeType = rdiskDomain.VolumeType(c.VolumeType)\n\t}\n\tif c.DiskType != \"\" {\n\t\tvol.DiskType = rdiskDomain.DiskType(c.DiskType)\n\t}\n\terr = lvRepo.Add(ctx, vol)\n\tif err != nil {\n\t\treturn\n\t}\n\tc.createdLogicalVolume = vol\n\n\t// 3. 触发状态机，联动更新逻辑卷和物理卷状态\n\t_, err = sm.Fire(ctx, rdiskDomain.LVSUnInited, rdiskDomain.LVECreateLogicalVolume, c)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_running_backup_task.go",
        "code_start_line": 31,
        "code_end_line": 61,
        "code_key": "Handle",
        "code_value": "func (c *UpdateRunningBackupTaskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventUpdateBackupProgress,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_drgroup.go",
        "code_start_line": 78,
        "code_end_line": 173,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeDRGroupCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tlvView  = app.GetRegistry(ctx).Viewers.LogicalVolume\n\t\tdrgRepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t\tsm      = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\terr     error\n\t)\n\n\t// 0. 初始化\n\tc.drgroupRef = make(map[string]*drgroup.DRGroup)\n\n\t// 1. 加载所有逻辑卷所在的置放群组\n\tallVolumeUUIDs := make([]string, 0, len(c.UUIDs))\n\tfor _, _uuid := range c.UUIDs {\n\t\tallVolumeUUIDs = append(allVolumeUUIDs, _uuid.String())\n\t}\n\tif groups, err := drgRepo.FindByMembers(ctx, c.AppID, allVolumeUUIDs); err == nil {\n\t\tif err != nil {\n\t\t\tif !errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tfor _, group := range groups {\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t\tc.curDRGroupNames = append(c.curDRGroupNames, group.Name)\n\t\t}\n\t} else {\n\t\treturn err\n\t}\n\n\t// 2. 确认已上锁的置放群组和当前一致\n\tif !c.checkLockedDRGroupNames() {\n\t\treturn errors.New(drgroup.ErrGroupModified, \"drgroup changed\")\n\t}\n\n\t// 3. 加载所有逻辑卷的状态，不需要完整实体，因为不会修改 Volume\n\tc.relatedLogicalVolume, err = lvView.FindByIDs(ctx, c.AppID, c.UUIDs)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(c.relatedLogicalVolume) < len(c.UUIDs) {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t// 4. 加载所有目标置放群组，key 为 name\n\tfor _, spec := range c.Specs {\n\t\tvar group *drgroup.DRGroup\n\t\tif _, ok := c.drgroupRef[spec.Name]; ok {\n\t\t\tgroup = c.drgroupRef[spec.Name]\n\t\t} else {\n\t\t\tgroup, err = c.getOrCreateDRGroup(ctx, drgRepo, spec)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t}\n\n\t\tif spec.Affinity > 0 {\n\t\t\tgroup.Affinity = spec.Affinity\n\t\t}\n\t\tif spec.Type != \"\" {\n\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t}\n\t}\n\n\t// 5. 对所有逻辑卷执行置放群组变更事件，检查状态是否允许，\n\t//    实际的更新还是在这里执行。\n\tfor _, vol := range c.relatedLogicalVolume {\n\t\terr := sm.Check(ctx, vol.State, rdiskDomain.LVEUpdateDrGroup, c)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// 将逻辑卷从原有的置放群组中移除\n\t\tfor _, name := range c.curDRGroupNames {\n\t\t\tc.drgroupRef[name].RemoveMember(vol.UUID.String())\n\t\t}\n\t\t// 将逻辑卷添加到新的置放群组中\n\t\tfor _, spec := range c.Specs {\n\t\t\tsubGroup := spec.SubGroup\n\t\t\tif subGroup == \"\" {\n\t\t\t\t// 如果没有指定子组，则使用远端 SSD UUID 作为子组名称\n\t\t\t\t// 相当于每块盘都是一个子组，相当于没有使用子组功能\n\t\t\t\tsubGroup = vol.UUID.String()\n\t\t\t}\n\t\t\tif err := c.drgroupRef[spec.Name].AddMember(vol.UUID.String(), subGroup, vol.PhysicalVolume.IP.String()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tif c.DryRun {\n\t\treturn errors.New(errors.ErrDryRunSuccessExit, \"dry run check success\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/online_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OnlinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOnlinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_benchmark_task.go",
        "code_start_line": 34,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *UpdateBenchmarkTask) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, rdisk.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark, err = benchRepo.FindByUUID(ctx, c.BenchmarkUUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventUpdateBench, benchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_flow_ctrl.go",
        "code_start_line": 80,
        "code_end_line": 103,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeFlowControlCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not found\")\n\t}\n\n\tspec := c.volume.FlowControlSpec\n\tif !c.UpdateRequest.UpdateSpec(&spec, c.volume.GetDefaultFlowControlSpec()) {\n\t\t// 没有任何更新，直接返回成功\n\t\treturn nil\n\t}\n\tc.volume.SetFlowControlSpec(spec)\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEUpdateFlowControl, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_defunct_volume.go",
        "code_start_line": 46,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *CleanupDefunctCommand) Handle(ctx context.Context) error {\n\tvar err error\n\tc.lv, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar sm = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\tvar event = rdiskDomain.LVECleanupDefunct\n\n\tfor _, attachment := range c.lv.Attachments {\n\t\tlogs.Info(ctx).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).Msg(\"cleanup defuncting volume\")\n\t\tsubCmd := &cleanDefunctSubCommand{Parent: c, HostIP: attachment.IP}\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, subCmd)\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，因为只要有一个挂载点清理失败，其他挂载点还是需要继续清理的\n\t\t\t// 失败的挂载点会在后台继续清理\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).\n\t\t\t\tMsg(\"failed to cleanup defunct volume, retry later.\")\n\t\t}\n\t}\n\n\tif len(c.lv.Attachments) == 0 {\n\t\t// 没有挂载点，直接清理\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, &cleanDefunctSubCommand{Parent: c, HostIP: net.IP{}})\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，后续自动重试即可\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Msg(\"failed to complete cleanup defunct volume\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_drgroup_exists.go",
        "code_start_line": 28,
        "code_end_line": 53,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDRGroupExistsCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t)\n\tfor _, spec := range c.DRGroup {\n\t\t_, err := repo.FindByName(ctx, users.AppID(c.AppID), spec.Name)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\tgroup := drgroup.New(spec.Name, users.AppID(c.AppID))\n\t\t\t\tif spec.Affinity > 0 {\n\t\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t\t}\n\t\t\t\tif spec.Type != \"\" {\n\t\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t\t}\n\t\t\t\terr = repo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_physical_volume.go",
        "code_start_line": 31,
        "code_end_line": 54,
        "code_key": "Handle",
        "code_value": "func (c *UpdatePhyRDiskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEUpdatePhysicalVolume, c)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/recycle_backup_data.go",
        "code_start_line": 32,
        "code_end_line": 62,
        "code_key": "Handle",
        "code_value": "func (c *RecycleBackupDataCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventDeleteBackup,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go",
        "code_start_line": 74,
        "code_end_line": 102,
        "code_key": "ProcessChargeDetail",
        "code_value": "func (c *CbsAppIdConsumer) ProcessChargeDetail(detail *ChargeDetail) error {\n\tcbsSrv := c.ResSrv.(*measure.CbsSrv)\n\t// 不同用户的资源数是不一致的，这里顺序处理的话性能一般，需要放在协程中跑\n\t// 单个用户最多启动100个协程，避免协程过多\n\tvar wg sync.WaitGroup\n\tfor _, cbsInstanceId := range detail.ResIds {\n\t\twg.Add(1)\n\t\tgo func(cbsInstanceId measure.ResourceId) {\n\t\t\tdefer wg.Done()\n\t\t\t// 并发的控制策略: 同时处理的用户不超过t.Concurrency个，所有用户共享t.Concurrency * 100个协程\n\t\t\t// 这样设计的目的是为了规避用户资源倾斜严重的问题，同时也能保证用户的并发度较少\n\t\t\tc.ResSemaphore <- struct{}{}\n\t\t\tdefer func() {\n\t\t\t\t<-c.ResSemaphore\n\t\t\t}()\n\n\t\t\tlogs.Info(c.Ctx).\n\t\t\t\tUint64(\"appId\", uint64(detail.User.AppId)).\n\t\t\t\tStr(\"cbsInstanceId\", string(cbsInstanceId)).\n\t\t\t\tMsg(\"PROCESS_SIGNAL_DISK\")\n\n\t\t\tchargeItem := cbsSrv.BuildResChargeItem(detail.User, cbsInstanceId, detail.ChargeTime)\n\t\t\t// 单个资源失败就等下一轮，先忽略err\n\t\t\t_ = c.ProcessSingleChargeItem(detail.User, cbsInstanceId, chargeItem)\n\t\t}(cbsInstanceId)\n\t}\n\twg.Wait()\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/service.go",
        "code_start_line": 208,
        "code_end_line": 217,
        "code_key": "BuildResChargeItem",
        "code_value": "func (cbsSrv *CbsSrv) BuildResChargeItem(u *user.User, resourceId ResourceId, chargeTime time.Time) *ChargeItem {\n\tcbsMeasureRepo := cbsSrv.balanceRepo.(repositories.CbsBalanceRepoIFace)\n\tbalanceRecords, _ := cbsMeasureRepo.GetCbsBalanceRecords(cbsSrv.ctx, string(resourceId), chargeTime, false)\n\n\tif len(balanceRecords) == 0 {\n\t\treturn nil\n\t}\n\n\treturn cbsSrv.convertToChargeItem(u, resourceId, balanceRecords, chargeTime)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 133,
        "code_end_line": 236,
        "code_key": "BuildResChargeItem",
        "code_value": "func (snapSrv *SnapSrv) BuildResChargeItem(u *user.User, resourceId ResourceId, chargeTime time.Time) *ChargeItem {\n\t// 获取符合条件的balanceRecord并根据chargeTime排序\n\tbalanceRecords, _ := snapSrv.snapRepo.GetSnapBalanceRecords(snapSrv.ctx, string(resourceId), chargeTime)\n\n\t// FIXME 临时方案：用内存里的lastBalanceTime覆盖balanceRecords里的balanceTime\n\tfor _, balanceRecord := range balanceRecords {\n\t\tlastBalanceTime, ok := snapSrv.lastBalanceTimeCache[balanceRecord.ID]\n\t\tif ok {\n\t\t\tbalanceRecord.LastBalanceTime = lastBalanceTime\n\t\t}\n\t}\n\n\tif len(balanceRecords) == 0 {\n\t\treturn nil\n\t}\n\tsort.Slice(balanceRecords, func(i, j int) bool {\n\t\tif balanceRecords[i].LastBalanceTime.Equal(balanceRecords[j].LastBalanceTime) {\n\t\t\treturn balanceRecords[i].OperationType < balanceRecords[j].OperationType\n\t\t}\n\t\treturn balanceRecords[i].LastBalanceTime.Before(balanceRecords[j].LastBalanceTime)\n\t})\n\n\t// 区分国内站和国际站用户\n\tvar userArea Area\n\tif u.IsI18nUser() {\n\t\tuserArea = AreaI18n\n\t} else {\n\t\tuserArea = AreaChina\n\t}\n\tisGrayUser, err := u.CheckFeature(user.USER_FLAG_SNAP_GRAY_USER)\n\tif err != nil {\n\t\tlogs.Error(snapSrv.ctx).Err(err).Int64(\"appId\", int64(u.AppId)).Msg(\"CHECK_GRAY_USER_ERR\")\n\t\t// 出错时标记为非灰度用户，避免重复推量\n\t\tisGrayUser = false\n\t}\n\n\tchargeItem := &ChargeItem{\n\t\t// FIXME: 需要从配置文件中获取region id\n\t\tRegionId:     snapSrv.regionId,\n\t\tZoneId:       balanceRecords[0].ZoneID,\n\t\tAppId:        u.AppId,\n\t\tUin:          u.Uin,\n\t\tUserArea:     userArea,\n\t\tIsGrayUser:   isGrayUser,\n\t\tResourceId:   resourceId,\n\t\tResourceArea: snapSrv.regionArea,\n\t\tItems:        make([]*SubItem, 0, len(balanceRecords)),\n\t}\n\n\t// 虚拟计费条目，用于确定endBalanceTime\n\tendBalanceRecord := &ccdb.CSnapBalance{LastBalanceTime: chargeTime.Add(time.Second * -1)}\n\tallBalances := append(balanceRecords, endBalanceRecord)\n\n\tfor i, balanceRecord := range allBalances[1:] {\n\t\tbeginBalanceRecord := balanceRecords[i]\n\t\t// 资源欠费，不收取费用\n\t\tif beginBalanceRecord.OperationType == int(SnapOpArrearage) {\n\t\t\tlogs.Info(snapSrv.ctx).Uint64(\"appId\", uint64(u.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"RESOURCE_ARREARAGE\")\n\t\t\tcontinue\n\t\t}\n\t\t// 资源已退还。退还后还产生了计费条目，非期望行为\n\t\tif beginBalanceRecord.OperationType == int(SnapOpReturn) {\n\t\t\tlogs.Info(snapSrv.ctx).Uint64(\"appId\", uint64(u.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"SNAP_HAS_RETURNED\")\n\t\t\tbreak\n\t\t}\n\n\t\t// 资源正常\n\t\tstartTime := beginBalanceRecord.LastBalanceTime\n\t\tendTime := balanceRecord.LastBalanceTime\n\t\tcurTime := startTime\n\t\tfor endTime.After(curTime) {\n\t\t\tcurHourEnd := time.Date(curTime.Year(), curTime.Month(), curTime.Day(), curTime.Hour(), 59, 59, 0, curTime.Location())\n\t\t\tif !endTime.After(curHourEnd) {\n\t\t\t\t// 同一周期\n\t\t\t\tsubItem := &SubItem{\n\t\t\t\t\tPid:       PidSnap,\n\t\t\t\t\tStartTime: curTime,\n\t\t\t\t\tEndTime:   endTime,\n\t\t\t\t\tSubValueDetail: map[string]interface{}{\n\t\t\t\t\t\t\"Size\": beginBalanceRecord.SnapSize},\n\t\t\t\t}\n\t\t\t\tchargeItem.Items = append(chargeItem.Items, subItem)\n\t\t\t\tcurTime = endTime.Add(time.Second)\n\t\t\t} else {\n\t\t\t\t// 非同一周期，先构建这个周期的\n\t\t\t\tsubItem := &SubItem{\n\t\t\t\t\tStartTime: curTime,\n\t\t\t\t\tEndTime:   curHourEnd,\n\t\t\t\t\tSubValueDetail: map[string]interface{}{\n\t\t\t\t\t\t\"Size\": beginBalanceRecord.SnapSize,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\tchargeItem.Items = append(chargeItem.Items, subItem)\n\t\t\t\tcurTime = curHourEnd.Add(time.Second)\n\t\t\t}\n\n\t\t}\n\t}\n\tif len(chargeItem.Items) == 0 {\n\t\treturn nil\n\t}\n\n\treturn chargeItem\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 247,
        "code_end_line": 264,
        "code_key": "BuildResChargeItem",
        "code_value": "func (cbsSrv *CbsSrv) BuildResChargeItem(u *user.User, resourceId ResourceId, chargeTime time.Time) *ChargeItem {\n\tcbsMeasureRepo := cbsSrv.measureRepo.(CbsMeasureRepoIFace)\n\tbalanceRecords, _ := cbsMeasureRepo.GetCbsBalanceRecords(cbsSrv.ctx, string(resourceId), chargeTime, false)\n\n\t// FIXME 临时方案：用内存里的lastBalanceTime覆盖balanceRecords里的balanceTime\n\tfor _, balanceRecord := range balanceRecords {\n\t\tlastBalanceTime, ok := cbsSrv.lastBalanceTimeCache[balanceRecord.ID]\n\t\tif ok {\n\t\t\tbalanceRecord.LastBalanceTime = lastBalanceTime\n\t\t}\n\t}\n\n\tif len(balanceRecords) == 0 {\n\t\treturn nil\n\t}\n\n\treturn cbsSrv.convertToChargeItem(u, resourceId, balanceRecords, chargeTime)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/service.go",
        "code_start_line": 294,
        "code_end_line": 367,
        "code_key": "convertToChargeItem",
        "code_value": "func (cbsSrv *CbsSrv) convertToChargeItem(u *user.User, resourceId ResourceId, balanceRecords []*ccdb.CCbsBalance, chargeTime time.Time) *ChargeItem {\n\tsort.Slice(balanceRecords, func(i, j int) bool {\n\t\tif balanceRecords[i].LastBalanceTime.Equal(balanceRecords[j].LastBalanceTime) {\n\t\t\treturn balanceRecords[i].OperationType < balanceRecords[j].OperationType\n\t\t}\n\t\treturn balanceRecords[i].LastBalanceTime.Before(balanceRecords[j].LastBalanceTime)\n\t})\n\n\t// 区分国内站和国际站用户\n\tvar userArea Area\n\tif u.IsI18nUser() {\n\t\tuserArea = AreaI18n\n\t} else {\n\t\tuserArea = AreaChina\n\t}\n\tisGrayUser, err := u.CheckFeature(user.USER_FLAG_CBS_GRAY_USER)\n\tif err != nil {\n\t\tlogs.Error(cbsSrv.ctx).Err(err).Int64(\"appId\", int64(u.AppId)).Msg(\"CHECK_GRAY_USER_ERR\")\n\t\t// 出错时标记为非灰度用户，避免重复推量\n\t\tisGrayUser = false\n\t}\n\n\tchargeItem := &ChargeItem{\n\t\t// FIXME: 需要从配置文件中获取region id\n\t\tRegionId:     cbsSrv.regionId,\n\t\tZoneId:       balanceRecords[0].ZoneID,\n\t\tAppId:        u.AppId,\n\t\tUin:          u.Uin,\n\t\tUserArea:     userArea,\n\t\tIsGrayUser:   isGrayUser,\n\t\tResourceId:   resourceId,\n\t\tResourceArea: cbsSrv.regionArea,\n\t\tItems:        make([]*SubItem, 0, len(balanceRecords)),\n\t\tUpdateKVs:    make([]*UpdateKV, 0, len(balanceRecords)),\n\t}\n\n\t// 虚拟计费条目，用于确定endBalanceTime\n\tendBalanceRecord := &ccdb.CCbsBalance{LastBalanceTime: chargeTime.Add(time.Second * -1)}\n\tallBalances := append(balanceRecords, endBalanceRecord)\n\n\t// 获取云盘信息\n\tfor i, balanceRecord := range allBalances[1:] {\n\t\tbeginBalanceRecord := balanceRecords[i]\n\t\t// 用于组装单个BalanceRecord的subitem\n\t\tstopCharge := cbsSrv.processSingleBalanceRecords(\n\t\t\tchargeItem, beginBalanceRecord, balanceRecord, u, resourceId)\n\t\tif stopCharge {\n\t\t\t// TODO 停止计费。如果后续产生预期外的计费条目，状态也应该置为无效\n\t\t\t// 现在先不处理，避免因bug导致少收费\n\t\t\tbreak\n\t\t}\n\n\t\t// 灰度阶段使用\n\t\tif isGrayUser {\n\t\t\t// 更新balanceRecord\n\t\t\tupdateKV := &UpdateKV{\n\t\t\t\tId:              beginBalanceRecord.ID,\n\t\t\t\tLastBalanceTime: chargeTime,\n\t\t\t\tStatus:          beginBalanceRecord.Status,\n\t\t\t}\n\t\t\tif i != len(balanceRecords)-1 ||\n\t\t\t\t(beginBalanceRecord.OperationType == int(CbsOpReturn) || beginBalanceRecord.OperationType == int(CbsOpConvert)) {\n\t\t\t\tbeginBalanceRecord.Status = 0\n\t\t\t}\n\t\t\tchargeItem.UpdateKVs = append(chargeItem.UpdateKVs, updateKV)\n\t\t}\n\n\t}\n\tif len(chargeItem.Items) == 0 && len(chargeItem.UpdateKVs) == 0 {\n\t\treturn nil\n\t}\n\n\treturn chargeItem\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 341,
        "code_end_line": 414,
        "code_key": "convertToChargeItem",
        "code_value": "func (cbsSrv *CbsSrv) convertToChargeItem(u *user.User, resourceId ResourceId, balanceRecords []*ccdb.CCbsBalance, chargeTime time.Time) *ChargeItem {\n\tsort.Slice(balanceRecords, func(i, j int) bool {\n\t\tif balanceRecords[i].LastBalanceTime.Equal(balanceRecords[j].LastBalanceTime) {\n\t\t\treturn balanceRecords[i].OperationType < balanceRecords[j].OperationType\n\t\t}\n\t\treturn balanceRecords[i].LastBalanceTime.Before(balanceRecords[j].LastBalanceTime)\n\t})\n\n\t// 区分国内站和国际站用户\n\tvar userArea Area\n\tif u.IsI18nUser() {\n\t\tuserArea = AreaI18n\n\t} else {\n\t\tuserArea = AreaChina\n\t}\n\tisGrayUser, err := u.CheckFeature(user.USER_FLAG_CBS_GRAY_USER)\n\tif err != nil {\n\t\tlogs.Error(cbsSrv.ctx).Err(err).Int64(\"appId\", int64(u.AppId)).Msg(\"CHECK_GRAY_USER_ERR\")\n\t\t// 出错时标记为非灰度用户，避免重复推量\n\t\tisGrayUser = false\n\t}\n\n\tchargeItem := &ChargeItem{\n\t\t// FIXME: 需要从配置文件中获取region id\n\t\tRegionId:     cbsSrv.regionId,\n\t\tZoneId:       balanceRecords[0].ZoneID,\n\t\tAppId:        u.AppId,\n\t\tUin:          u.Uin,\n\t\tUserArea:     userArea,\n\t\tIsGrayUser:   isGrayUser,\n\t\tResourceId:   resourceId,\n\t\tResourceArea: cbsSrv.regionArea,\n\t\tItems:        make([]*SubItem, 0, len(balanceRecords)),\n\t\tUpdateKVs:    make([]*UpdateKV, 0, len(balanceRecords)),\n\t}\n\n\t// 虚拟计费条目，用于确定endBalanceTime\n\tendBalanceRecord := &ccdb.CCbsBalance{LastBalanceTime: chargeTime.Add(time.Second * -1)}\n\tallBalances := append(balanceRecords, endBalanceRecord)\n\n\t// 获取云盘信息\n\tfor i, balanceRecord := range allBalances[1:] {\n\t\tbeginBalanceRecord := balanceRecords[i]\n\t\t// 用于组装单个BalanceRecord的subitem\n\t\tstopCharge := cbsSrv.processSingleBalanceRecords(\n\t\t\tchargeItem, beginBalanceRecord, balanceRecord, u, resourceId)\n\t\tif stopCharge {\n\t\t\t// TODO 停止计费。如果后续产生预期外的计费条目，状态也应该置为无效\n\t\t\t// 现在先不处理，避免因bug导致少收费\n\t\t\tbreak\n\t\t}\n\n\t\t// 灰度阶段使用\n\t\tif isGrayUser {\n\t\t\t// 更新balanceRecord\n\t\t\tupdateKV := &UpdateKV{\n\t\t\t\tId:              beginBalanceRecord.ID,\n\t\t\t\tLastBalanceTime: chargeTime,\n\t\t\t\tStatus:          beginBalanceRecord.Status,\n\t\t\t}\n\t\t\tif i != len(balanceRecords)-1 ||\n\t\t\t\t(beginBalanceRecord.OperationType == int(CbsOpReturn) || beginBalanceRecord.OperationType == int(CbsOpConvert)) {\n\t\t\t\tbeginBalanceRecord.Status = 0\n\t\t\t}\n\t\t\tchargeItem.UpdateKVs = append(chargeItem.UpdateKVs, updateKV)\n\t\t}\n\n\t}\n\tif len(chargeItem.Items) == 0 && len(chargeItem.UpdateKVs) == 0 {\n\t\treturn nil\n\t}\n\n\treturn chargeItem\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/service.go",
        "code_start_line": 369,
        "code_end_line": 434,
        "code_key": "processSingleBalanceRecords",
        "code_value": "func (cbsSrv *CbsSrv) processSingleBalanceRecords(chargeItem *ChargeItem, beginBalanceRecord *ccdb.CCbsBalance, endBalanceRecord *ccdb.CCbsBalance, user *user.User, resourceId ResourceId) (stopCharge bool) {\n\tstopCharge = false\n\t// 资源欠费，不收取费用\n\tif beginBalanceRecord.OperationType == int(CbsOpArrearage) {\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"RESOURCE_ARREARAGE\")\n\t\treturn\n\t}\n\t// 资源退还。判断是否为预付费的性能突发场景\n\tif beginBalanceRecord.OperationType == int(CbsOpReturn) || beginBalanceRecord.OperationType == int(CbsOpConvert) {\n\t\t// 判断是否为预付费的性能突发场景.\n\t\t// 获取云盘信息。这里在循环中进行查询，但命中的应该不会很多，放在外层反而会导致每个云盘都被查询\n\t\tdisk, err := cbsSrv.diskRepo.QueryDiskInfoById(cbsSrv.ctx, string(resourceId))\n\t\tif err != nil || disk == nil {\n\t\t\tlogs.Error(cbsSrv.ctx).Err(err).Str(\"resourceId\", string(resourceId)).Msg(\"QUERY_CBS_RECORD_FAILED\")\n\t\t\t// TODO 这里先不返回资源的推量？\n\t\t\treturn true\n\t\t}\n\t\t// TODO 走diskLogical\n\t\tif disk.PayMode == \"prepay\" {\n\t\t\t// 性能突发场景，预付费用户退盘，退盘费用不计\n\t\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"MAYBE_CBS_WITH_BURST_PERFORMANCE\")\n\t\t\treturn\n\t\t}\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"CBS_HAS_RETURNED\")\n\t\treturn true\n\t}\n\n\t// 资源正常\n\tstartTime := beginBalanceRecord.LastBalanceTime\n\tendTime := endBalanceRecord.LastBalanceTime\n\tcurTime := startTime\n\tfor endTime.After(curTime) {\n\t\tcurHourEnd := time.Date(curTime.Year(), curTime.Month(), curTime.Day(), curTime.Hour(), 59, 59, 0, curTime.Location())\n\n\t\tvar config CCbsBalanceConfig\n\t\terr := json.Unmarshal([]byte(beginBalanceRecord.Config), &config)\n\t\tif err != nil {\n\t\t\tlogs.Error(cbsSrv.ctx).Err(err).Msg(\"PARSE_CONFIG_ERROR\")\n\t\t\treturn\n\t\t}\n\n\t\tcurEndTime := endTime\n\t\tcurStarTime := curTime\n\t\tif !endTime.After(curHourEnd) {\n\t\t\t// 同一周期\n\t\t\tcurTime = endTime.Add(time.Second)\n\t\t} else {\n\t\t\tcurEndTime = curHourEnd\n\t\t\tcurTime = curHourEnd.Add(time.Second)\n\t\t}\n\t\tsubItem := &SubItem{\n\t\t\tPid:       beginBalanceRecord.Pid,\n\t\t\tStartTime: curStarTime,\n\t\t\tEndTime:   curEndTime,\n\t\t\tProjectId: beginBalanceRecord.ProjectID,\n\t\t\tParams:    beginBalanceRecord.ResourceInfo,\n\t\t\tSubValueDetail: map[string]interface{}{\n\t\t\t\t// FIXME 性能突发场景待实现\n\t\t\t\t\"Size\":             config.Size,\n\t\t\t\t\"BackupPointQuota\": config.BackupPointQuota,\n\t\t\t},\n\t\t}\n\t\tchargeItem.Items = append(chargeItem.Items, subItem)\n\t}\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 416,
        "code_end_line": 481,
        "code_key": "processSingleBalanceRecords",
        "code_value": "func (cbsSrv *CbsSrv) processSingleBalanceRecords(chargeItem *ChargeItem, beginBalanceRecord *ccdb.CCbsBalance, endBalanceRecord *ccdb.CCbsBalance, user *user.User, resourceId ResourceId) (stopCharge bool) {\n\tstopCharge = false\n\t// 资源欠费，不收取费用\n\tif beginBalanceRecord.OperationType == int(CbsOpArrearage) {\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"RESOURCE_ARREARAGE\")\n\t\treturn\n\t}\n\t// 资源退还。判断是否为预付费的性能突发场景\n\tif beginBalanceRecord.OperationType == int(CbsOpReturn) || beginBalanceRecord.OperationType == int(CbsOpConvert) {\n\t\t// 判断是否为预付费的性能突发场景.\n\t\t// 获取云盘信息。这里在循环中进行查询，但命中的应该不会很多，放在外层反而会导致每个云盘都被查询\n\t\tdisk, err := cbsSrv.diskRepo.QueryDiskInfoById(cbsSrv.ctx, string(resourceId))\n\t\tif err != nil || disk == nil {\n\t\t\tlogs.Error(cbsSrv.ctx).Err(err).Str(\"resourceId\", string(resourceId)).Msg(\"QUERY_CBS_RECORD_FAILED\")\n\t\t\t// TODO 这里先不返回资源的推量？\n\t\t\treturn true\n\t\t}\n\t\t// TODO 走diskLogical\n\t\tif disk.PayMode == \"prepay\" {\n\t\t\t// 性能突发场景，预付费用户退盘，退盘费用不计\n\t\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"MAYBE_CBS_WITH_BURST_PERFORMANCE\")\n\t\t\treturn\n\t\t}\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"CBS_HAS_RETURNED\")\n\t\treturn true\n\t}\n\n\t// 资源正常\n\tstartTime := beginBalanceRecord.LastBalanceTime\n\tendTime := endBalanceRecord.LastBalanceTime\n\tcurTime := startTime\n\tfor endTime.After(curTime) {\n\t\tcurHourEnd := time.Date(curTime.Year(), curTime.Month(), curTime.Day(), curTime.Hour(), 59, 59, 0, curTime.Location())\n\n\t\tvar config CCbsBalanceConfig\n\t\terr := json.Unmarshal([]byte(beginBalanceRecord.Config), &config)\n\t\tif err != nil {\n\t\t\tlogs.Error(cbsSrv.ctx).Err(err).Msg(\"PARSE_CONFIG_ERROR\")\n\t\t\treturn\n\t\t}\n\n\t\tcurEndTime := endTime\n\t\tcurStarTime := curTime\n\t\tif !endTime.After(curHourEnd) {\n\t\t\t// 同一周期\n\t\t\tcurTime = endTime.Add(time.Second)\n\t\t} else {\n\t\t\tcurEndTime = curHourEnd\n\t\t\tcurTime = curHourEnd.Add(time.Second)\n\t\t}\n\t\tsubItem := &SubItem{\n\t\t\tPid:       beginBalanceRecord.Pid,\n\t\t\tStartTime: curStarTime,\n\t\t\tEndTime:   curEndTime,\n\t\t\tProjectId: beginBalanceRecord.ProjectID,\n\t\t\tParams:    beginBalanceRecord.ResourceInfo,\n\t\t\tSubValueDetail: map[string]interface{}{\n\t\t\t\t// FIXME 性能突发场景待实现\n\t\t\t\t\"Size\":             config.Size,\n\t\t\t\t\"BackupPointQuota\": config.BackupPointQuota,\n\t\t\t},\n\t\t}\n\t\tchargeItem.Items = append(chargeItem.Items, subItem)\n\t}\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/convertor.go",
        "code_start_line": 28,
        "code_end_line": 38,
        "code_key": "Start",
        "code_value": "func (a *Convertor) Start(ctx context.Context) error {\n\t// 启动转换器\n\tfor _, scanner := range a.scanners {\n\t\tscanner := scanner\n\t\tgo func() {\n\t\t\ta.convertToTask(ctx, scanner)\n\t\t}()\n\t}\n\tlogs.Info(ctx).Msgf(\"Convertor Start Success\")\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_rec_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *CbsMeasureReconciliationTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\t//s.resultChan <- struct{}{}\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_rec_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 35,
        "code_key": "Start",
        "code_value": "func (s *SnapMeasureReconciliationTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_compute_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *SnapComputeTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\t//s.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_measure_send_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *CbsMeasureSendTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_bill_valid_appId_fetch_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *CbsValidAppIdFetchTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_calculate_cost_locally_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 36,
        "code_key": "Start",
        "code_value": "func (s *SnapCalculateCostLocallyTaskScanner) Start(ctx context.Context) error {\n\t//s.resultChan <- struct{}{}\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_create_task_scanner.go",
        "code_start_line": 23,
        "code_end_line": 42,
        "code_key": "Start",
        "code_value": "func (s *UpdateCreateTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\trunning := true\n\t\tfor running {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\trunning = false\n\t\t\tdefault:\n\t\t\t\terr := s.FullScan(ctx)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogs.Fatal(ctx).Msgf(\"%s full scan failed!\\n\", s.name)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\ttime.Sleep(s.scanInterval)\n\t\t}\n\t}()\n\tlogs.Info(ctx).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_measure_send_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 36,
        "code_key": "Start",
        "code_value": "func (s *SnapMeasureSendTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\t//s.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/repush_user_billing_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 39,
        "code_key": "Start",
        "code_value": "func (s *RepushUserBillingTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_rollback_task_scanner.go",
        "code_start_line": 23,
        "code_end_line": 42,
        "code_key": "Start",
        "code_value": "func (s *UpdateRollbackTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\trunning := true\n\t\tfor running {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\trunning = false\n\t\t\tdefault:\n\t\t\t\terr := s.FullScan(ctx)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogs.Fatal(ctx).Msgf(\"%s full scan failed!\\n\", s.name)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\ttime.Sleep(s.scanInterval)\n\t\t}\n\t}()\n\tlogs.Info(ctx).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_valid_appId_fetch_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 36,
        "code_key": "Start",
        "code_value": "func (s *SnapValidAppIdFetchTaskScanner) Start(ctx context.Context) error {\n\t//s.resultChan <- struct{}{}\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_bill_compute_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 39,
        "code_key": "Start",
        "code_value": "func (s *CbsBillComputeTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/app/app.go",
        "code_start_line": 31,
        "code_end_line": 39,
        "code_key": "Start",
        "code_value": "func (m *PipelineManager) Start(ctx context.Context) error {\n\tfor region, pipeline := range m.Pipelines {\n\t\tregionCtx := context.WithValue(ctx, \"region\", region)\n\t\tif err := pipeline.Start(regionCtx); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/app/app.go",
        "code_start_line": 46,
        "code_end_line": 51,
        "code_key": "Start",
        "code_value": "func (app *NebulaApp) Start(ctx context.Context) error {\n\tif err := app.pipelineManager.Start(ctx); err != nil {\n\t\treturn err\n\t}\n\treturn <-app.stopChan\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/app/pipeline.go",
        "code_start_line": 20,
        "code_end_line": 46,
        "code_key": "Start",
        "code_value": "func (p *RegionPipeline) Start(ctx context.Context) error {\n\tregion := ctx.Value(\"region\").(string)\n\tscannerLogCtx := initLogger(ctx, region, \"scanner.log\")\n\tfor _, scanner := range p.scanners {\n\t\tsingleCtx := logs.AddDefaultMessage(scannerLogCtx, \"name\", scanner.GetName())\n\t\terr := scanner.Start(singleCtx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tinitMetric(scanner, region, \"scanner\", scanner.GetName())\n\t}\n\n\tconvertorLogCtx := initLogger(ctx, region, \"convertor.log\")\n\terr := p.convertor.Start(convertorLogCtx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// start scheduler\n\tschedulerLogCtx := initLogger(ctx, region, \"scheduler.log\")\n\terr = p.scheduler.Start(schedulerLogCtx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tinitMetric(p.scheduler, region, \"scheduler\", \"scheduler\")\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go",
        "code_start_line": 109,
        "code_end_line": 112,
        "code_key": "Start",
        "code_value": "func (sc *Scheduler) Start(ctx context.Context) error {\n\tgo sc.mainLoop(ctx)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/scheduler.go",
        "code_start_line": 154,
        "code_end_line": 191,
        "code_key": "Start",
        "code_value": "func (s *scheduler) Start(ctx context.Context) error {\n\twg := sync.WaitGroup{}\n\trunning := true\n\tgo s.haManager.Start(ctx)\n\tdefer s.haManager.Close(ctx)\n\tfor {\n\t\tselect {\n\t\tcase taskName := <-s.eventChan:\n\t\t\twg.Add(1)\n\t\t\tgo func(name string) {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tif task, ok := s.loads[name]; ok {\n\n\t\t\t\t\tif s.isMaster {\n\t\t\t\t\t\t_ctx := logs.With(ctx).Str(\"seqId\", uuid.New().String()).Str(\"taskName\", name).Logger().WithContext(ctx)\n\t\t\t\t\t\ttask.Work(_ctx)\n\t\t\t\t\t}\n\n\t\t\t\t\ttriggerTime := time.Now().Add(task.Interval())\n\t\t\t\t\tfor {\n\t\t\t\t\t\tif !running {\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif time.Now().After(triggerTime) {\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttime.Sleep(time.Second)\n\t\t\t\t\t}\n\t\t\t\t\ts.eventChan <- name\n\t\t\t\t}\n\t\t\t}(taskName)\n\t\tcase <-s.stopChan:\n\t\t\trunning = false\n\t\t\twg.Wait()\n\t\t\treturn nil\n\t\t}\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/easyha/model.go",
        "code_start_line": 108,
        "code_end_line": 180,
        "code_key": "Start",
        "code_value": "func (m *haManagerImpl) Start(ctx context.Context) {\n\tm.keepRunning = true\n\tm.ctx = ctx\n\tvar (\n\t\tmyIdentity            = m.delegate.GetIdentity()                                    // 当前节点的业务标识\n\t\tmyKey                 = fmt.Sprintf(\"easyhaMaster/%s\", url.PathEscape(m.namespace)) // 分布式锁的key\n\t\tmyToken               = m.encodeToken(myIdentity)                                   // 分布式锁 Token，包含业务标识和随机信息\n\t\tmyLock                dlock.Lock                                                    // 获取到的分布式锁, 用于刷新和释放\n\t\tcurrentMasterIdentity string                                                        // 当前 master 的业务标识，如果为空则是还未获取过当前 master\n\t)\n\n\t// Start slave loop.\n\tfor m.keepRunning {\n\t\t// Try observe the master lock first.\n\t\tif view, err := m.locker.Observe(ctx, myKey); err != nil {\n\t\t\tm.logger.Info().Err(err).Str(\"key\", myKey).Msg(\"failed to observe current master lock\")\n\t\t\t// Failed to observe the master lock, try to  obtain the lock.\n\t\t\tmyLock, err = m.locker.Obtain(ctx, dlock.NewWriteLockKey(myKey), m.lockExpired, &dlock.Option{Token: myToken})\n\t\t\tif err == nil {\n\t\t\t\t// Successfully obtained the lock.\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tnewIdentity, err := m.decodeToken(view.Token)\n\t\t\tif err != nil {\n\t\t\t\tm.logger.Warn().Err(err).Str(\"token\", view.Token).Msg(\"failed to decode token\")\n\t\t\t} else if currentMasterIdentity == \"\" {\n\t\t\t\t// First time to observe the master.\n\t\t\t\tcurrentMasterIdentity = newIdentity\n\t\t\t\tif err := m.delegate.OnBecomeSlave(ctx, currentMasterIdentity); err != nil {\n\t\t\t\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle become slave, force quit for safety\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if currentMasterIdentity != newIdentity {\n\t\t\t\t// Master changed. Need update.\n\t\t\t\tcurrentMasterIdentity = newIdentity\n\t\t\t\tif err := m.delegate.OnSwitchMaster(ctx, currentMasterIdentity); err != nil {\n\t\t\t\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle switch master, force quit for safety\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttime.Sleep(m.checkInterval)\n\t}\n\n\tif myLock == nil {\n\t\tm.logger.Fatal().Msg(\"myLock is nil, found bug, force quit for safety\")\n\t\treturn\n\t}\n\n\t// I am the master now.\n\tif err := m.delegate.OnBecomeMaster(ctx); err != nil {\n\t\tmyLock.Release(ctx)\n\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle become master, force quit for safety\")\n\t\treturn\n\t}\n\n\tdefer func() {\n\t\tmyLock.Release(ctx)\n\t\tif err := m.delegate.OnLostMaster(ctx); err != nil {\n\t\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle lost master, force quit for safety\")\n\t\t}\n\t}()\n\n\t// Start the master loop.\n\tfor m.keepRunning {\n\t\ttime.Sleep(m.checkInterval)\n\t\tif err := myLock.Refresh(ctx, m.lockExpired); err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_bill_compute_task.go",
        "code_start_line": 63,
        "code_end_line": 113,
        "code_key": "ProcessUserSnapResources",
        "code_value": "func (t *SnapBillComputeTask) ProcessUserSnapResources(user *user.User, snapIds []measure.ResourceId) {\n\tsnapSrv := t.ResSrv.(*measure.SnapSrv)\n\t// 不同用户的资源数是不一致的，这里顺序处理的话性能一般，需要放在协程中跑\n\t// 单个用户最多启动100个协程，避免协程过多\n\tvar wg sync.WaitGroup\n\tsemaphore := make(chan struct{}, 100)\n\tchargeTimeFromSnapshot := snapSrv.GetSnapRealChargeTimes(user.AppId, t.ChargeTime)\n\n\tfor _, snapId := range snapIds {\n\t\twg.Add(1)\n\t\tgo func(snapId measure.ResourceId) {\n\t\t\tdefer wg.Done()\n\t\t\t// 这里可以控制启动的协程数\n\t\t\tsemaphore <- struct{}{}\n\t\t\tdefer func() { <-semaphore }()\n\n\t\t\tlogs.Info(t.Ctx).\n\t\t\t\tUint64(\"app_id\", uint64(user.AppId)).\n\t\t\t\tStr(\"snap_id\", string(snapId)).\n\t\t\t\tMsg(\"PROCESS_SIGNAL_SNAP\")\n\t\t\t// 计费真正的结算时间：若快照deadline时间晚于结算时间，则结算时间=快照deadline\n\t\t\tchargeTime, ok := chargeTimeFromSnapshot[snapId]\n\t\t\tif !ok {\n\t\t\t\tchargeTime = t.ChargeTime\n\t\t\t}\n\n\t\t\tchargeItem := snapSrv.BuildResChargeItem(user, snapId, chargeTime)\n\t\t\tif chargeItem == nil {\n\t\t\t\t// 可能是资源不需要计费。这里需要把资源Id从UnConfirmedMap中删除\n\t\t\t\tt.MarkSingleResDone(user.AppId, snapId)\n\t\t\t\tlogs.Info(t.Ctx).Uint64(\"appId\", uint64(user.AppId)).\n\t\t\t\t\tStr(\"snapId\", string(snapId)).Msg(\"SKIP_SNAP\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tchargeItemMsg := mqimpl.NewMessage(mq.MSGTYPE_JSON, chargeItem)\n\t\t\terr := t.ChargeItemProducer.Publish(chargeItemMsg)\n\t\t\tlogs.Info(t.Ctx).\n\t\t\t\tUint64(\"appId\", uint64(user.AppId)).\n\t\t\t\tStr(\"snap_id\", string(snapId)).\n\t\t\t\tMsg(\"PUBLISH_CHARGE_ITEM\")\n\t\t\tif err != nil {\n\t\t\t\tlogs.Error(t.Ctx).Err(err).\n\t\t\t\t\tUint64(\"appId\", uint64(user.AppId)).\n\t\t\t\t\tStr(\"snapId\", string(snapId)).\n\t\t\t\t\tMsg(\"PUBLISH_CHARGE_ITEM_FAILED\")\n\t\t\t}\n\t\t}(snapId)\n\t}\n\twg.Wait()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/task.go",
        "code_start_line": 25,
        "code_end_line": 32,
        "code_key": "UpdateExecuteTime",
        "code_value": "func (t *Task) UpdateExecuteTime(ctx context.Context) {\n\tinterval := t.Interval * time.Duration(t.Count)\n\tif interval >= t.MaxInterval {\n\t\tinterval = t.MaxInterval\n\t}\n\t// 这里应该是执行完成的时间加上等待时间\n\tt.NextTriggerTime = time.Now().Add(time.Second * interval)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/cbs_bill_compute_task.go",
        "code_start_line": 64,
        "code_end_line": 90,
        "code_key": "ProcessUserCbsResources",
        "code_value": "func (t *CbsBillComputeTask) ProcessUserCbsResources(user *user.User, resIds []measure.ResourceId) {\n\tcbsSrv := t.ResSrv.(*measure.CbsSrv)\n\t// 不同用户的资源数是不一致的，这里顺序处理的话性能一般，需要放在协程中跑\n\t// 单个用户最多启动100个协程，避免协程过多\n\tvar wg sync.WaitGroup\n\tfor _, cbsInstanceId := range resIds {\n\t\twg.Add(1)\n\t\tgo func(cbsInstanceId measure.ResourceId) {\n\t\t\tdefer wg.Done()\n\t\t\t// 并发的控制策略: 同时处理的用户不超过t.Concurrency个，所有用户共享t.Concurrency * 100个协程\n\t\t\t// 这样设计的目的是为了规避用户资源倾斜严重的问题，同时也能保证用户的并发度较少\n\t\t\tt.ResSemaphore <- struct{}{}\n\t\t\tdefer func() {\n\t\t\t\t<-t.ResSemaphore\n\t\t\t}()\n\n\t\t\tlogs.Info(t.Ctx).\n\t\t\t\tUint64(\"appId\", uint64(user.AppId)).\n\t\t\t\tStr(\"cbsInstanceId\", string(cbsInstanceId)).\n\t\t\t\tMsg(\"PROCESS_SIGNAL_DISK\")\n\n\t\t\tchargeItem := cbsSrv.BuildResChargeItem(user, cbsInstanceId, t.ChargeTime)\n\t\t\tt.ProcessSingleChargeItem(user, cbsInstanceId, chargeItem)\n\t\t}(cbsInstanceId)\n\t}\n\twg.Wait()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/repush_user_billing_task.go",
        "code_start_line": 103,
        "code_end_line": 172,
        "code_key": "ProcessSingleRepushDetail",
        "code_value": "func (t *RepushUserBillingTask) ProcessSingleRepushDetail(detail *measure.RepushDetail) error {\n\tcbsMeasureRepo := registry.GetRegistry(t.ctx).AdapterRepos.CbsMeasureRepo.(measure.CbsMeasureRepoIFace)\n\tappIdResIdMaps := make(map[user.AppId][]measure.ResourceId)\n\tif detail.AppId > 0 {\n\t\tif len(detail.ResIds) > 0 {\n\t\t\tappIdResIdMaps[detail.AppId] = detail.ResIds\n\t\t} else {\n\t\t\tids, err := cbsMeasureRepo.GetResourceIdsByAppId(t.ctx, int64(detail.AppId), time.Time{}, true, cbsMeasureRepo.GetBalanceTableName())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tresIds := make([]measure.ResourceId, 0, len(ids))\n\t\t\tfor _, resId := range ids {\n\t\t\t\tresIds = append(resIds, measure.ResourceId(resId))\n\t\t\t}\n\t\t\tappIdResIdMaps[detail.AppId] = resIds\n\t\t}\n\t} else {\n\t\tif len(detail.ResIds) > 0 {\n\t\t\treturn fmt.Errorf(\"AppId is required when ResIds is set\")\n\t\t}\n\t\tlogs.Info(t.ctx).Msg(\"REPUSH_ALL_FOR_APPID_NOT_SET\")\n\t\tappIds, _ := cbsMeasureRepo.GetAppIdsWithResources(t.ctx, time.Time{}, true, cbsMeasureRepo.GetBalanceTableName())\n\t\tfor _, appId := range appIds {\n\t\t\t// 没有指定资源，则补量所有资源\n\t\t\tids, err := cbsMeasureRepo.GetResourceIdsByAppId(t.ctx, appId, time.Time{}, true, cbsMeasureRepo.GetBalanceTableName())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tresIds := make([]measure.ResourceId, 0, len(ids))\n\t\t\tfor _, resId := range ids {\n\t\t\t\tresIds = append(resIds, measure.ResourceId(resId))\n\t\t\t}\n\t\t\tappIdResIdMaps[user.AppId(appId)] = resIds\n\t\t}\n\n\t}\n\n\tvar repushItems []*RepushItem\n\tfor appId, resIds := range appIdResIdMaps {\n\t\tu, err := t.userSrv.GetUser(appId)\n\t\tif err != nil {\n\t\t\t// 这里可能是新注册的用户，user表里没有用户数据，可能会丢失该用户的量\n\t\t\tlogs.Error(t.ctx).Err(err).Uint64(\"appId\", uint64(appId)).Msg(\"GET_USER_ERROR\")\n\t\t\tpanic(err)\n\t\t}\n\t\tfor _, resId := range resIds {\n\t\t\tvar repushItem RepushItem\n\t\t\trepushItem.user = u\n\t\t\trepushItem.cbsInstanceId = resId\n\t\t\trepushItem.startTime = detail.StartTime\n\t\t\trepushItem.endTime = detail.EndTime\n\t\t\trepushItems = append(repushItems, &repushItem)\n\t\t}\n\t}\n\tlogs.Info(t.ctx).Int(\"count\", len(repushItems)).Msg(\"REPUSH_ITEMS_INFO\")\n\n\tvar wg sync.WaitGroup\n\tfor _, repushItem := range repushItems {\n\t\twg.Add(1)\n\t\tt.semaphore <- struct{}{}\n\t\tgo func(item *RepushItem) {\n\t\t\tdefer wg.Done()\n\t\t\tdefer func() { <-t.semaphore }()\n\t\t\tt.ProcessSingleRepushItem(item)\n\t\t}(repushItem)\n\t}\n\twg.Wait()\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/cbs_measure_send_task.go",
        "code_start_line": 56,
        "code_end_line": 81,
        "code_key": "ProcessMsgByRegion",
        "code_value": "func (t *CbsMeasureSendTask) ProcessMsgByRegion() {\n\t// 并发处理消息\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < t.Conf.Concurrency; i++ {\n\t\twg.Add(1)\n\t\tgo func(workId int) {\n\t\t\tlog.Infof(\"start work %d\", workId)\n\t\t\tdefer wg.Done()\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase msg, ok := <-t.DomesticChan:\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.ProcessMsgToMeasureDetail(msg)\n\t\t\t\tcase <-t.Ctx.Done():\n\t\t\t\t\tlogs.Info(t.Ctx).Int(\"work_id\", workId).Msg(\"STOP_WORKER\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n\t// 关闭chan\n\twg.Wait()\n\tclose(t.MeasureDetailChan)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_measure_send_task.go",
        "code_start_line": 51,
        "code_end_line": 76,
        "code_key": "ProcessMsgByRegion",
        "code_value": "func (t *SnapMeasureSendTask) ProcessMsgByRegion() {\n\t// 并发处理消息\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < t.Conf.Concurrency; i++ {\n\t\twg.Add(1)\n\t\tgo func(workId int) {\n\t\t\tlog.Infof(\"start work %d\", workId)\n\t\t\tdefer wg.Done()\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase msg, ok := <-t.DomesticChan:\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.ProcessMsgToMeasureDetail(msg)\n\t\t\t\tcase <-t.Ctx.Done():\n\t\t\t\t\tlogs.Info(t.Ctx).Int(\"work_id\", workId).Msg(\"STOP_WORKER\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n\t// 关闭chan\n\twg.Wait()\n\tclose(t.MeasureDetailChan)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/cbs_rec_task.go",
        "code_start_line": 111,
        "code_end_line": 136,
        "code_key": "ProcessMsg",
        "code_value": "func (t *CbsMeasureRecTask) ProcessMsg() {\n\t// 并发处理消息\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < t.Conf.Concurrency; i++ {\n\t\twg.Add(1)\n\t\tgo func(workId int) {\n\t\t\tlog.Infof(\"start work %d\", workId)\n\t\t\tdefer wg.Done()\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase msg, ok := <-t.DomesticChan:\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.ProcessMsgToMeasure(msg)\n\t\t\t\tcase <-t.Ctx.Done():\n\t\t\t\t\tlogs.Info(t.Ctx).Int(\"work_id\", workId).Msg(\"STOP_WORKER\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n\t// 关闭chan\n\twg.Wait()\n\tclose(t.CbsMeasureDetailChan)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_rec_task.go",
        "code_start_line": 63,
        "code_end_line": 105,
        "code_key": "sendDbFromMsg",
        "code_value": "func (t *SnapMeasureReconciliationTask) sendDbFromMsg(wg *sync.WaitGroup) {\n\t// 并发处理消息\n\n\tfor i := 0; i < t.Concurrency; i++ {\n\t\twg.Add(1)\n\t\tgo func(workId int) {\n\t\t\tlog.Infof(\"start work %d\", workId)\n\t\t\tdefer wg.Done()\n\t\t\tunConfirmedMap := make(map[measure.ResourceId]mqiface.IMessage)\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase msg := <-t.snapChargeItemForCompareConsumer.Receiving(mq.MSGTYPE_JSON):\n\t\t\t\t\tchargeItem, _ := parseChargeItem(msg)\n\t\t\t\t\tresourceId := chargeItem.ResourceId\n\t\t\t\t\tunConfirmedMap[resourceId] = msg\n\n\t\t\t\t\t// 达到指定数量后进行数据库同步\n\t\t\t\t\tif len(unConfirmedMap) == 100 {\n\t\t\t\t\t\tlog.Infof(\"unConfirmedMap num %d\", len(unConfirmedMap))\n\t\t\t\t\t\terr := t.ProcessMsgSendMeasure(t.ctx, unConfirmedMap)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tjsonData, _ := json.Marshal(unConfirmedMap)\n\t\t\t\t\t\t\tlogs.Error(t.ctx).Err(err).Str(\"process_msg_send_measure_failed\", string(jsonData)).Msg(\"BATCH_PROCESS_SEND_MEASURE_FAILED\")\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\tcase <-time.After(5 * time.Second):\n\t\t\t\t\tif len(unConfirmedMap) > 0 {\n\t\t\t\t\t\tlogs.Info(t.ctx).Int(\"time_out_process_msg_nums\", len(unConfirmedMap)).Msg(\"TIME_OUT_PROCESS_MSG\")\n\t\t\t\t\t\terr := t.ProcessMsgSendMeasure(t.ctx, unConfirmedMap)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tjsonData, _ := json.Marshal(unConfirmedMap)\n\t\t\t\t\t\t\tlogs.Error(t.ctx).Err(err).Str(\"send_fail_detail\", string(jsonData)).Msg(\"TIMEOUT_PROCESS_SEND_MEASURE_FAILED\")\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tcase <-t.ctx.Done():\n\t\t\t\t\tlogs.Info(t.ctx).Int(\"work_id\", workId).Msg(\"STOP_WORKER\")\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_rec_task.go",
        "code_start_line": 134,
        "code_end_line": 150,
        "code_key": "AckResourceID",
        "code_value": "func (t *SnapMeasureReconciliationTask) AckResourceID() {\n\t// Ack逻辑：AppId关联的所有ChargeItem全部都confirmed了才触发对AppId的Ack\n\tgo func() {\n\t\tfor {\n\t\t\tt.m.Lock()\n\t\t\tfor resourceId := range t.ResourceIdMsgMap {\n\t\t\t\tt.snapChargeItemForCompareConsumer.Ack(t.ResourceIdMsgMap[resourceId])\n\t\t\t\tdelete(t.ResourceIdMsgMap, resourceId)\n\t\t\t\tlogs.Info(t.ctx).Str(\"resource_id\", string(resourceId)).Str(\"resource_id\", string(resourceId)).Msg(\"ACK_RESOURCE_ID\")\n\t\t\t}\n\t\t\tt.m.Unlock()\n\n\t\t\ttime.Sleep(time.Microsecond * 100)\n\t\t}\n\t}()\n\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/base_measure/base_send_measure_task.go",
        "code_start_line": 140,
        "code_end_line": 159,
        "code_key": "AckResourceID",
        "code_value": "func (t *BaseSendMeasureTask) AckResourceID() {\n\t// Ack逻辑：AppId关联的所有ChargeItem全部都confirmed了才触发ACK\n\tt.WG.Add(1)\n\tdefer t.WG.Done()\n\tgo func() {\n\t\tfor {\n\t\t\tt.m.Lock()\n\t\t\tfor resourceId, msgList := range t.unConfirmedMap {\n\t\t\t\tlogs.Info(t.ctx).Str(\"resourceId\", string(resourceId)).Int(\"size\", len(msgList)).Fields(t.unConfirmedMap).Msg(\"CHECK_RESOURCE_ID_CONFIRMED\")\n\t\t\t\tif len(msgList) == 0 {\n\t\t\t\t\tdelete(t.unConfirmedMap, resourceId)\n\t\t\t\t\tt.AckMessage(string(resourceId))\n\t\t\t\t}\n\t\t\t}\n\t\t\tt.m.Unlock()\n\t\t\ttime.Sleep(time.Millisecond * 100)\n\t\t}\n\t}()\n\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/base_measure/base_send_measure_task.go",
        "code_start_line": 261,
        "code_end_line": 313,
        "code_key": "ProcessParamsSendMeasure",
        "code_value": "func (t *BaseSendMeasureTask) ProcessParamsSendMeasure() {\n\tvar wg sync.WaitGroup\n\tsemaphore := make(chan struct{}, 100) // Semaphore with a capacity of 100\n\n\tfor {\n\t\tselect {\n\t\tcase param, ok := <-t.MeasureParamChan:\n\t\t\tif !ok {\n\t\t\t\tlogs.Info(t.Ctx).Msg(\"MEASURE_DETAIL_CHAN_CLOSED\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\twg.Add(1) // Increment the WaitGroup counter\n\n\t\t\tgo func(param interface{}) {\n\t\t\t\tdefer wg.Done() // Decrement the WaitGroup counter when the goroutine completes\n\n\t\t\t\tsemaphore <- struct{}{}        // Acquire a semaphore slot\n\t\t\t\tdefer func() { <-semaphore }() // Release the semaphore slot\n\n\t\t\t\t// Convert param to paraMap\n\t\t\t\tparaMap := make(map[string]interface{})\n\t\t\t\tdata, _ := json.Marshal(param)\n\t\t\t\t_ = json.Unmarshal(data, &paraMap)\n\n\t\t\t\t_, err := t.SendMeasureData(t.Ctx, paraMap)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogs.Info(t.Ctx).Any(\"param\", paraMap).Msg(\"SEND_MEASURE_DATA_ERROR\")\n\t\t\t\t}\n\n\t\t\t\t// Process measureDetail and subMeasureDetail\n\t\t\t\tmeasureDetail := paraMap[\"measureDetail\"].([]interface{})\n\t\t\t\tfor _, measureDetail := range measureDetail {\n\t\t\t\t\tmeasureMap := measureDetail.(map[string]interface{})\n\t\t\t\t\tserialId := measureMap[\"serialId\"].(string)\n\t\t\t\t\tsubMeasureDetail := measureMap[\"subMeasureDetail\"].([]interface{})\n\n\t\t\t\t\tfor _, subMeasure := range subMeasureDetail {\n\t\t\t\t\t\tsubMeasureMap := subMeasure.(map[string]interface{})\n\t\t\t\t\t\tdosageId := subMeasureMap[\"dosageId\"].(string)\n\t\t\t\t\t\tt.MarkMeasureDetailDone(measure.ResourceId(serialId), measure.DosageId(dosageId))\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}(param)\n\n\t\tcase <-t.Ctx.Done():\n\t\t\tlogs.Info(t.Ctx).Msg(\"CTX_DONE\")\n\t\t\twg.Wait() // Wait for all goroutines to complete\n\t\t\treturn\n\t\t}\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/base_measure/base_bill_compute_task.go",
        "code_start_line": 76,
        "code_end_line": 122,
        "code_key": "GetUserResources",
        "code_value": "func (t *BaseBillComputeTask) GetUserResources() {\n\t// 启动多个worker用来处理单用户的快照资源\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < t.userConcurrency; i++ {\n\t\twg.Add(1)\n\t\tgo func(workId int) {\n\t\t\tdefer wg.Done()\n\t\t\tlogs.Info(t.ctx).Int(\"workId\", workId).Msg(\"START_WORKER\")\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase msg, ok := <-t.AppIdConsumer.Receiving(mq.MSGTYPE_TEXT):\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\tlogs.Error(t.ctx).Msg(\"STOP_WORKER\")\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tappId, _ := parseAppId(msg)\n\t\t\t\t\tu, err := t.userSrv.GetUser(appId)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t// 这里可能是新注册的用户，user表里没有用户数据，可能会丢失该用户的量\n\t\t\t\t\t\tlogs.Error(t.ctx).Err(err).Uint64(\"appId\", uint64(appId)).Msg(\"PROCESS_SIGNAL_USER_FAILED\")\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\tt.AddToAckMessage(strconv.FormatUint(uint64(appId), 10), msg)\n\t\t\t\t\terr = t.ProcessSingleUser(u)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlogs.Error(t.ctx).Err(err).Uint64(\"appId\", uint64(appId)).Msg(\"PROCESS_SIGNAL_USER_FAILED\")\n\t\t\t\t\t}\n\t\t\t\tcase <-t.ctx.Done():\n\t\t\t\t\tlogs.Info(t.ctx).Int(\"workId\", workId).Msg(\"STOP_WORKER\")\n\t\t\t\t\treturn\n\t\t\t\tcase <-time.After(time.Second * 10):\n\t\t\t\t\tlogs.Debug(t.ctx).Int(\"workId\", workId).Msg(\"WAIT_MSG_TIMEOUT\")\n\t\t\t\t\t// 队列为空，也没有待Confirm数据的数据\n\t\t\t\t\tif t.AppIdConsumer.QueueIsEmpty() && len(t.unConfirmedMap) == 0 {\n\t\t\t\t\t\tlogs.Info(t.ctx).Int(\"workId\", workId).Msg(\"STOP_WORKER_FOR_QUEUE_EMPTY\")\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}(i)\n\t}\n\t// 关闭chan\n\twg.Wait()\n\tclose(t.UserResChan)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/base_measure/base_bill_compute_task.go",
        "code_start_line": 175,
        "code_end_line": 215,
        "code_key": "AckAppId",
        "code_value": "func (t *BaseBillComputeTask) AckAppId() {\n\tt.WG.Add(1)\n\tdefer t.WG.Done()\n\t// Ack逻辑：AppId关联的所有ChargeItem全部都confirmed了才触发对AppId的Ack\n\tgo func() {\n\t\tfor {\n\t\t\tt.m.Lock()\n\t\t\tfor appId, msgList := range t.unConfirmedMap {\n\t\t\t\tlogs.Info(t.ctx).Uint64(\"appId\", uint64(appId)).Int(\"size\", len(msgList)).Fields(t.unConfirmedMap).Msg(\"CHECK_APPID_CONFIRMED\")\n\t\t\t\tif len(msgList) == 0 {\n\t\t\t\t\tt.AckMessage(strconv.FormatUint(uint64(appId), 10))\n\t\t\t\t\tdelete(t.unConfirmedMap, appId)\n\t\t\t\t}\n\t\t\t}\n\t\t\tt.m.Unlock()\n\t\t\ttime.Sleep(time.Millisecond * 100)\n\t\t}\n\t}()\n\n\t// Confirm逻辑，确认chargeItem放入队列后，将chargeItem关联的resourceId从未确认map中删除\n\tfor confirm := range t.ChargeItemProducer.Confirm() {\n\t\tt.WG.Add(1)\n\t\tchargeItem := confirm.GetData().(*measure.ChargeItem)\n\t\tif confirm.GetPublishResult() != mq.PUBLISH_RESULT_SUCCESS {\n\t\t\t// 告警出来，后期补量，部分成功不好处理\n\t\t\tlogs.Error(t.ctx).Any(\"chargeItem\", chargeItem).Msg(\"CHARGE_ITEM_PUBLISH_FAILED\")\n\t\t\tcontinue\n\t\t}\n\t\t// 到这里就代表chargeItem已经发送到队列，理论上不会漏推\n\t\t// FIXME 可能会导致重复推量\n\t\tgo func(innerChargeItem *measure.ChargeItem) {\n\t\t\tdefer t.WG.Done()\n\t\t\terr := t.ResSrv.UpdateResBalanceRecords(innerChargeItem.AppId, innerChargeItem)\n\t\t\tif err != nil {\n\t\t\t\tlogs.Error(t.Ctx).Err(err).Uint64(\"appId\", uint64(innerChargeItem.AppId)).\n\t\t\t\t\tStr(\"resourceId\", string(innerChargeItem.ResourceId)).Msg(\"UPDATE_CBS_BALANCE_RECORD_FAILED\")\n\t\t\t}\n\t\t}(chargeItem)\n\t\tt.MarkSingleResDone(chargeItem.AppId, chargeItem.ResourceId)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_rec_task_scanner.go",
        "code_start_line": 39,
        "code_end_line": 41,
        "code_key": "FullScan",
        "code_value": "func (s *CbsMeasureReconciliationTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_rec_task_scanner.go",
        "code_start_line": 37,
        "code_end_line": 39,
        "code_key": "FullScan",
        "code_value": "func (s *SnapMeasureReconciliationTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_compute_task_scanner.go",
        "code_start_line": 39,
        "code_end_line": 41,
        "code_key": "FullScan",
        "code_value": "func (s *SnapComputeTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_measure_send_task_scanner.go",
        "code_start_line": 39,
        "code_end_line": 41,
        "code_key": "FullScan",
        "code_value": "func (s *CbsMeasureSendTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_bill_valid_appId_fetch_task_scanner.go",
        "code_start_line": 39,
        "code_end_line": 41,
        "code_key": "FullScan",
        "code_value": "func (s *CbsValidAppIdFetchTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_calculate_cost_locally_task_scanner.go",
        "code_start_line": 38,
        "code_end_line": 40,
        "code_key": "FullScan",
        "code_value": "func (s *SnapCalculateCostLocallyTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_create_task_scanner.go",
        "code_start_line": 50,
        "code_end_line": 78,
        "code_key": "FullScan",
        "code_value": "func (s *UpdateCreateTaskScanner) FullScan(ctx context.Context) error {\n\tsnapRepo := registry.GetRegistry(ctx).AdapterRepos.SnapRepo.(adapter_interfaces.SnapInterface)\n\tsnapList, err := snapRepo.QueryCreatingCopyingSnapList(ctx)\n\tif err != nil {\n\t\tlogs.Error(ctx).Err(err).Msg(\"FULL_SCAN_FAILED\")\n\t\treturn err\n\t}\n\tresultCnt := 0\n\tfor _, snapRecord := range snapList {\n\t\t// 剔除快照组预生成的快照记录\n\t\tif strings.Contains(snapRecord.SnapUuid, \"temp\") {\n\t\t\tlogs.Info(ctx).Str(\"SnapId\", snapRecord.SnapInstanceId).Msgf(\"PRE_CREATED_SNAPSHOT_SKIP_UPDATE\")\n\t\t\tcontinue\n\t\t}\n\n\t\tentity := &snapLogical.Entity{\n\t\t\tSnapRecord: snapRecord,\n\t\t}\n\t\tsnapAggregate := &snapLogical.SnapCreateTaskAggregate{\n\t\t\tEntity:      entity,\n\t\t\tTaskName:    core.UpdateCreateTask,\n\t\t\tSubTaskName: core.UpdateCreateTask,\n\t\t}\n\t\ts.resultChan <- snapAggregate\n\t\tresultCnt += 1\n\t}\n\ts.resultChanMetric.Add(float64(resultCnt))\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_measure_send_task_scanner.go",
        "code_start_line": 38,
        "code_end_line": 40,
        "code_key": "FullScan",
        "code_value": "func (s *SnapMeasureSendTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/repush_user_billing_task_scanner.go",
        "code_start_line": 41,
        "code_end_line": 43,
        "code_key": "FullScan",
        "code_value": "func (s *RepushUserBillingTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_rollback_task_scanner.go",
        "code_start_line": 103,
        "code_end_line": 113,
        "code_key": "FullScan",
        "code_value": "func (s *UpdateRollbackTaskScanner) FullScan(ctx context.Context) error {\n\tif err := s.getCCbsRollbackTask(ctx); err != nil {\n\t\tlogs.Error(ctx).Err(err).Msg(\"FULL_SCAN_FAILED\")\n\t\treturn err\n\t}\n\tif err := s.getImageSnapRollbackTask(ctx); err != nil {\n\t\tlogs.Error(ctx).Err(err).Msg(\"FULL_SCAN_FAILED\")\n\t\treturn err\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_valid_appId_fetch_task_scanner.go",
        "code_start_line": 38,
        "code_end_line": 40,
        "code_key": "FullScan",
        "code_value": "func (s *SnapValidAppIdFetchTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_bill_compute_task_scanner.go",
        "code_start_line": 41,
        "code_end_line": 43,
        "code_key": "FullScan",
        "code_value": "func (s *CbsBillComputeTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/client/client.go",
        "code_start_line": 20,
        "code_end_line": 62,
        "code_key": "Request",
        "code_value": "func (c *BaseClient) Request(ctx context.Context, interfaceName string, reqJsonData []byte) ([]byte, error) {\n\tlogger := logs.With(ctx).Str(\"interface\", interfaceName).Logger()\n\tlogger.Info().Str(\"para\", string(reqJsonData)).Msg(\"NEW_REQUEST\")\n\n\tctx, cancel := context.WithTimeout(ctx, time.Second*time.Duration(c.Timeout))\n\tdefer cancel()\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPost, c.Url, bytes.NewReader(reqJsonData))\n\n\tif global.TestEnv {\n\t\treq.Header.Add(\"X-QCloud-Transaction-ID\", uuid.New().String())\n\t\treq.Header.Add(\"X-QCloud-User-ID\", global.TestUin)\n\t}\n\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"new request failed: %v\", err)\n\t}\n\theader := \"\"\n\tfor key, value := range req.Header {\n\t\theader += fmt.Sprintf(\"-H \\\"%s: %s\\\" \", key, value[0])\n\t}\n\tcurl := fmt.Sprintf(\"curl %s --connect-timeout %d -d '%s' %s\", header, c.Timeout, string(reqJsonData), c.Url)\n\tlogger.Info().Any(\"cmd\", curl).Msgf(\"SHOW_CURL_CMD\")\n\n\trsp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\tlogger.Error().Err(err).Msgf(\"RESPONSE_ERR\")\n\t\treturn nil, fmt.Errorf(\"do request failed: %v\", err)\n\t}\n\tdefer func(Body io.ReadCloser) {\n\t\t_ = Body.Close()\n\t}(rsp.Body)\n\n\tif rsp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"unexpected status code: %d\", rsp.StatusCode)\n\t}\n\tbodyData, err := io.ReadAll(rsp.Body)\n\tlogger.Info().Any(\"response\", string(bodyData)).Msgf(\"SHOW_RESPONSE\")\n\tif err != nil {\n\t\tlogger.Error().Err(err).Msgf(\"RESPONSE_ERR\")\n\t\treturn nil, err\n\t}\n\treturn bodyData, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go",
        "code_start_line": 83,
        "code_end_line": 103,
        "code_key": "AddTask",
        "code_value": "func (sc *Scheduler) AddTask(ctx context.Context, newTask interfaces.Task) {\n\tvalue, ok := sc.taskMap.Load(newTask.GetTaskId())\n\tif !ok {\n\t\tsc.syncTaskPriorityQueue.Push(newTask)\n\t\tsc.taskMap.Store(newTask.GetTaskId(), newTask)\n\t\tsc.addTimerEvent(newTask.GetTaskId())\n\t\tsc.metrics.taskCountInQueue.Add(1)\n\t} else {\n\t\t// 对于已存在的任务需要判断subTaskName是否发生变化\n\t\t// 存在任务切换的场景，如order -> trigger，需要将旧任务删除，新任务插入\n\t\ttask := value.(interfaces.Task)\n\t\tif task.GetSubTaskName() != newTask.GetSubTaskName() {\n\t\t\tlogs.Info(ctx).Str(\"TaskId\", task.GetTaskId()).Msg(\"FOUND_SUB_TASK_CHANGED\")\n\t\t\t// 更新taskMap中的task记录，并插入优先队列\n\t\t\tsc.taskMap.Store(newTask.GetTaskId(), newTask)\n\t\t\tsc.syncTaskPriorityQueue.Push(newTask)\n\t\t\tsc.addTimerEvent(newTask.GetTaskId())\n\t\t\tsc.metrics.taskCountInQueue.Add(1)\n\t\t}\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go",
        "code_start_line": 120,
        "code_end_line": 131,
        "code_key": "tryGetWorker",
        "code_value": "func (sc *Scheduler) tryGetWorker(ctx context.Context) bool {\n\tsc.mutex.Lock()\n\tdefer sc.mutex.Unlock()\n\n\tif sc.workerNum > 0 {\n\t\tsc.workerNum--\n\t\tsc.wg.Add(1)\n\t\tsc.metrics.idleWorkerNum.Set(float64(sc.workerNum))\n\t\treturn true\n\t}\n\treturn false\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go",
        "code_start_line": 217,
        "code_end_line": 221,
        "code_key": "rePushTask",
        "code_value": "func (sc *Scheduler) rePushTask(ctx context.Context, task interfaces.Task) {\n\tsc.syncTaskPriorityQueue.Push(task)\n\tsc.metrics.taskCountInQueue.Add(1)\n\tsc.addTimerEvent(task.GetTaskId())\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/mq/mqimpl/rabbitMq/producer.go",
        "code_start_line": 71,
        "code_end_line": 96,
        "code_key": "Confirm",
        "code_value": "func (p *Producer) Confirm() <-chan mqiface.IMessage {\n\t/*\n\t\tConfirm主要是用来获取消息的发送结果，并将对象的消息放入channel中\n\t\tconfirm.DeliveryTag是rabbitmq维护的channel级的唯一标识，实际的值来源于channel.published,\n\t\t但是这个变量不对外暴露，所以在publish操作中也维护了一个producer级的published变量，二者值是一致的\n\t*/\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase confirm, ok := <-p.Confirms:\n\t\t\t\tif !ok {\n\t\t\t\t\tlogs.Info(p.Ctx).Msg(\"CONFIRM_CHANNEL_CLOSED\")\n\t\t\t\t\t// 关闭p.confirmedMsgChannel\n\t\t\t\t\tp.wg.Wait()\n\t\t\t\t\tclose(p.confirmedMsgChannel)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tp.wg.Add(1)\n\t\t\t\tgo p.processConfirmation(confirm)\n\t\t\tcase <-p.Ctx.Done():\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}()\n\treturn p.confirmedMsgChannel\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/cmd/rdisk_master/run.go",
        "code_start_line": 63,
        "code_end_line": 80,
        "code_key": "runScheduler",
        "code_value": "func runScheduler(appCtx context.Context, wg *sync.WaitGroup) {\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ts := app.GlobalRegistry.Scheduler\n\t\tsignalChan := make(chan os.Signal, 10)\n\t\tsignal.Notify(signalChan, unix.SIGINT, unix.SIGTERM, unix.SIGSEGV)\n\n\t\tgo func(c chan os.Signal) {\n\t\t\t<-c\n\t\t\ts.Stop()\n\t\t}(signalChan)\n\n\t\tif err := s.Start(appCtx); err != nil {\n\t\t\tlogs.Fatal(appCtx).Err(err).Msg(\"scheduler exited\")\n\t\t}\n\t}()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/cmd/rdisk_master/run.go",
        "code_start_line": 83,
        "code_end_line": 92,
        "code_key": "runApiServer",
        "code_value": "func runApiServer(appCtx context.Context, wg *sync.WaitGroup) {\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ts := apiserver.New(appCtx)\n\t\tif err := s.Serve(); err != nil {\n\t\t\tlogs.Fatal(appCtx).Err(err).Msg(\"server exited\")\n\t\t}\n\t}()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/cmd/rdisk_master/run.go",
        "code_start_line": 172,
        "code_end_line": 182,
        "code_key": "initSchedulers",
        "code_value": "func initSchedulers(ctx context.Context) {\n\tapp.GlobalRegistry.Scheduler = scheduler.New(ctx, app.GlobalRegistry.Locker)\n\n\t// 注册定时任务\n\n\tapp.GlobalRegistry.Scheduler.Add(\"update_backup_task\", &tasks.UpdateBackupTask{})\n\tapp.GlobalRegistry.Scheduler.Add(\"recycle_backup_task\", &tasks.RecycleBackupTask{})\n\tapp.GlobalRegistry.Scheduler.Add(\"update_benchmark_task\", &tasks.UpdateBenchmarkTask{})\n\tapp.GlobalRegistry.Scheduler.Add(\"confirm_init_physicaldisk_task\", &tasks.ConfirmInitPhysicalDiskTask{})\n\tapp.GlobalRegistry.Scheduler.Add(\"cleanup_defunct_task\", &tasks.CleanupDefunctTask{})\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/dispatcher/dispatcher.go",
        "code_start_line": 33,
        "code_end_line": 103,
        "code_key": "Dispatch",
        "code_value": "func (d *dispatcherImpl) Dispatch(ctx context.Context, cmd app.Command) (err error) {\n\t// 为什么使用 backgroundCtx 而不是 ctx？\n\t// 因为 ctx 代表调用方的上下文，通常是 rpc 请求上下文。\n\t// 而执行命令的上下文，应该是一个独立的上下文，不应该受到调用方的影响\n\t// 即使由于网络抖动等原因，调用方的上下文已经超时，但是命令执行的上下文仍然应该继续执行。\n\tworkerCtx := context.WithValue(d.backgroundCtx, ctxKeyCommand, cmd)\n\tworkerCtx, cancelFunc := context.WithTimeout(workerCtx, d.workerTimeout)\n\tworkerCtx = logs.GetLogger(ctx).WithContext(workerCtx)\n\tlockKeys := cmd.LockKeys()\n\terrChan := make(chan error, 1)\n\tlockOption := &dlock.Option{\n\t\tRetryStrategy: dlock.ExponentialBackoff(100*time.Millisecond, 6*time.Second),\n\t}\n\td.wg.Add(1)\n\t// 最终打印错误\n\t// TODO: 并发控制最大能同时执行的命令数量\n\tgo func() {\n\t\tdefer d.wg.Done()\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\te, ok := err.(error)\n\t\t\t\tif !ok {\n\t\t\t\t\te = errors.Newf(ErrDispatchPanic, \"dispatcher panic: %v\", err)\n\t\t\t\t}\n\t\t\t\terrChan <- e\n\t\t\t\tlogs.Error(workerCtx).Err(e).Stack().Bytes(\"trace\", debug.Stack()).Msgf(\"command execution panic\")\n\t\t\t}\n\t\t}()\n\n\t\tdefer cancelFunc()\n\n\t\tif lockKeys != nil {\n\t\t\tlock, err := d.locker.ObtainMulti(workerCtx, lockKeys, d.workerTimeout, lockOption)\n\t\t\tif err != nil {\n\t\t\t\terrChan <- err\n\t\t\t\tlogs.Warn(workerCtx).Err(err).Msgf(\"command execution waiting locks timeout\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer lock.Release(workerCtx)\n\t\t}\n\n\t\tuow := app.GetRegistry(ctx).Repositories.UoWFactory.New()\n\t\tworkerCtx = app.GetRegistry(ctx).Repositories.UoWFactory.With(workerCtx, uow)\n\n\t\terr = cmd.Handle(workerCtx)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, errors.ErrDryRunSuccessExit) {\n\t\t\t\terr = nil\n\t\t\t} else {\n\t\t\t\tlogs.Warn(workerCtx).Err(err).Msgf(\"command execution failed\")\n\t\t\t}\n\t\t\t_err := uow.Rollback(workerCtx)\n\t\t\tif _err != nil {\n\t\t\t\tlogs.Error(workerCtx).Err(_err).Msgf(\"unit of work rollback failed\")\n\t\t\t}\n\t\t} else {\n\t\t\terr = uow.Commit(workerCtx)\n\t\t\tif err != nil {\n\t\t\t\tlogs.Error(workerCtx).Err(err).Msgf(\"unit of work commit failed\")\n\t\t\t}\n\t\t}\n\t\terrChan <- err\n\t\tclose(errChan)\n\t}()\n\tselect {\n\tcase err := <-errChan:\n\t\treturn err\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/scheduler.go",
        "code_start_line": 127,
        "code_end_line": 132,
        "code_key": "Add",
        "code_value": "func (s *scheduler) Add(name string, workload WorkLoad) {\n\ts.mutex.Lock()\n\tdefer s.mutex.Unlock()\n\ts.loads[name] = workload\n\ts.eventChan <- name\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/benchmark.go",
        "code_start_line": 17,
        "code_end_line": 29,
        "code_key": "Add",
        "code_value": "func (repo *rdiskBenchmarkRepositoryImpl) Add(ctx context.Context, bench *benchmark.Benchmark) error {\n\tdo := repo.fromModelToDO(bench)\n\tuow := getUow(ctx)\n\tdo.Created = uow.tx.NowFunc()\n\tdo.Updated = uow.tx.NowFunc()\n\tresult := uow.tx.Create(&do)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tbench.ID = do.ID\n\tuow.trackedBenchmarks.Add(bench)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/backup.go",
        "code_start_line": 19,
        "code_end_line": 31,
        "code_key": "Add",
        "code_value": "func (repo *rdiskBackupRepositoryImpl) Add(ctx context.Context, backup *backupPkg.Backup) error {\n\tuow := getUow(ctx)\n\tdo := repo.fromModelToDO(backup)\n\tdo.Created = uow.tx.NowFunc()\n\tdo.Updated = uow.tx.NowFunc()\n\tresult := uow.tx.Create(&do)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tbackup.ID = do.ID\n\tuow.trackedBackups.Add(backup)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go",
        "code_start_line": 76,
        "code_end_line": 91,
        "code_key": "Add",
        "code_value": "func (l logicalVolumeRepositoryImpl) Add(ctx context.Context, lv *rdiskDomain.LogicalVolume) error {\n\tuow := getUow(ctx)\n\tvol := fromModelToDmRDisk(lv)\n\tvol.Created = uow.tx.NowFunc()\n\tvol.Updated = uow.tx.NowFunc()\n\tresult := uow.tx.Create(&vol)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tlv.ID = vol.ID\n\tlv = uow.trackedLogicalVolumes.Add(lv)\n\tif lv.PhysicalVolume != nil {\n\t\tlv.PhysicalVolume = uow.trackedPhyVolumes.Add(lv.PhysicalVolume)\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/uow.go",
        "code_start_line": 23,
        "code_end_line": 30,
        "code_key": "Add",
        "code_value": "func (c *changeTracker[T]) Add(item T) T {\n\tif v, ok := c.items[item.GetID()]; ok {\n\t\treturn v\n\t}\n\tc.items[item.GetID()] = item\n\tc.originalStates[item.GetID()] = item.DeepCopy().(T)\n\treturn item\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go",
        "code_start_line": 59,
        "code_end_line": 71,
        "code_key": "Add",
        "code_value": "func (p *physicalVolumeRepositoryImpl) Add(ctx context.Context, pv *rdiskDomain.PhysicalVolume) error {\n\tuow := getUow(ctx)\n\tvol := fromPhysicalVolumeToDmPhyDisk(ctx, pv)\n\tvol.Created = uow.tx.NowFunc()\n\tvol.Updated = uow.tx.NowFunc()\n\tresult := uow.tx.Create(&vol)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tpv.ID = vol.ID\n\tuow.trackedPhyVolumes.Add(pv)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
        "code_start_line": 96,
        "code_end_line": 108,
        "code_key": "Add",
        "code_value": "func (d drgroupRepositoryImpl) Add(ctx context.Context, group *drgroup.DRGroup) error {\n\tuow := getUow(ctx)\n\tdo := fromModelToDmDRGroup(group)\n\tdo.Created = uow.tx.NowFunc()\n\tdo.Updated = uow.tx.NowFunc()\n\tresult := uow.tx.Clauses(clause.Insert{Modifier: \"IGNORE\"}).Create(&do)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tgroup.ID = do.ID\n\tuow.trackedDRGroups.Add(group)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 41,
        "code_end_line": 46,
        "code_key": "Add",
        "code_value": "func (m *MockLogicalVolumeRepository) Add(arg0 context.Context, arg1 *rdiskDomain.LogicalVolume) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Add\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 49,
        "code_end_line": 52,
        "code_key": "Add",
        "code_value": "func (mr *MockLogicalVolumeRepositoryMockRecorder) Add(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Add\", reflect.TypeOf((*MockLogicalVolumeRepository)(nil).Add), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 40,
        "code_end_line": 45,
        "code_key": "Add",
        "code_value": "func (m *MockPhysicalVolumeRepository) Add(arg0 context.Context, arg1 *rdiskDomain.PhysicalVolume) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Add\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 48,
        "code_end_line": 51,
        "code_key": "Add",
        "code_value": "func (mr *MockPhysicalVolumeRepositoryMockRecorder) Add(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Add\", reflect.TypeOf((*MockPhysicalVolumeRepository)(nil).Add), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 40,
        "code_end_line": 45,
        "code_key": "Add",
        "code_value": "func (m *MockRepository) Add(arg0 context.Context, arg1 *drgroup.DRGroup) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Add\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 48,
        "code_end_line": 51,
        "code_key": "Add",
        "code_value": "func (mr *MockRepositoryMockRecorder) Add(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Add\", reflect.TypeOf((*MockRepository)(nil).Add), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 763,
        "code_end_line": 781,
        "code_key": "initCustomErrorHandler",
        "code_value": "func initCustomErrorHandler() {\n\tdefaultHandler := thttp.DefaultServerCodec.ErrHandler\n\tthttp.DefaultServerCodec.ErrHandler = func(w http.ResponseWriter, r *http.Request, e *errs.Error) {\n\t\t// Add custom error message to response body\n\t\tbody := errBody{\n\t\t\tCode: e.Code,\n\t\t\tMsg:  e.Msg,\n\t\t}\n\t\tbodyData, err := json.Marshal(body)\n\t\tif err != nil {\n\t\t\t// Should never happen\n\t\t\tpanic(err)\n\t\t}\n\n\t\tw.Header().Add(\"Content-Length\", strconv.Itoa(len(bodyData)))\n\t\tdefaultHandler(w, r, e)\n\t\tw.Write(bodyData)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_drgroup.go",
        "code_start_line": 176,
        "code_end_line": 198,
        "code_key": "getOrCreateDRGroup",
        "code_value": "func (c *UpdateLogicalVolumeDRGroupCommand) getOrCreateDRGroup(ctx context.Context, drgRepo drgroup.Repository, spec *drgroup.Spec) (*drgroup.DRGroup, error) {\n\tgroup, err := drgRepo.FindByName(ctx, c.AppID, spec.Name)\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\tgroup = drgroup.New(spec.Name, c.AppID)\n\t\t\tif spec.Affinity > 0 {\n\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t}\n\t\t\tif spec.Type != \"\" {\n\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t}\n\t\t\tif !c.DryRun {\n\t\t\t\terr := drgRepo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn group, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/attach_detach.go",
        "code_start_line": 247,
        "code_end_line": 297,
        "code_key": "UpdateFlowControlOnAllInitiator",
        "code_value": "func UpdateFlowControlOnAllInitiator(ctx context.Context, source rdiskDomain.LogicalVolumeState,\n\ttarget rdiskDomain.LogicalVolumeState, stateCtx app.LogicalVolumeContext) (state rdiskDomain.LogicalVolumeState, err error) {\n\n\tlv := stateCtx.GetLogicalVolume()\n\tif len(lv.Attachments) == 0 {\n\t\tlogs.Info(ctx).Str(\"uuid\", lv.UUID.String()).Msg(\"no attachment found, skip update flow control\")\n\t\treturn target, nil\n\t}\n\n\tvar wg sync.WaitGroup\n\tvar collectedErr []error = make([]error, len(lv.Attachments))\n\n\twg.Add(len(lv.Attachments))\n\n\tfor idx, attachment := range lv.Attachments {\n\t\tgo func(idx int, attachment *rdiskDomain.VolumeAttachment) {\n\t\t\tdefer wg.Done()\n\n\t\t\tblk := app.GetRegistry(ctx).Factories.BlockAgentClient(attachment.IP.String())\n\t\t\treq := cbs_blk_flow_agent.NewUpdateRDiskFlowControlRequest(lv.UUID.String(), lv.PhysicalVolume.DiskID)\n\t\t\treq.SpdkDriver = attachment.Options.SPDKDriver\n\t\t\treq.SetRead(attachment.FlowControlSpec.MaxReadIOPS, attachment.FlowControlSpec.MaxReadMBps)\n\t\t\treq.SetWrite(attachment.FlowControlSpec.MaxWriteIOPS, attachment.FlowControlSpec.MaxWriteMBps)\n\t\t\treq.SetReadWrite(attachment.FlowControlSpec.MaxRWIOPS, attachment.FlowControlSpec.MaxRWMBps)\n\n\t\t\terr = blk.UpdateRDiskFlowControl(ctx, req)\n\t\t\tif err != nil {\n\t\t\t\tlogs.Error(ctx).Err(err).Str(\"ip\", attachment.IP.String()).Msg(\"failed to update flow control\")\n\t\t\t}\n\t\t\tcollectedErr[idx] = err\n\t\t}(idx, attachment)\n\t}\n\n\twg.Wait()\n\n\t// collect error ip and print error count\n\tvar errList []error\n\tvar errIPs []string\n\tfor idx, err := range collectedErr {\n\t\tif err != nil {\n\t\t\terrList = append(errList, err)\n\t\t\terrIPs = append(errIPs, lv.Attachments[idx].IP.String())\n\t\t}\n\t}\n\tif len(errList) > 0 {\n\t\tlogs.Warn(ctx).Errs(\"errors\", errList).Strs(\"host_ips\", errIPs).Msg(\"failed to update flow control on some initiators\")\n\t\treturn source, errors.New(rdiskDomain.ErrUpdateFlowControl, fmt.Sprintf(\"failed to update flow control on some initiators: %v, errors: %v\", errIPs, errList))\n\t}\n\n\treturn target, err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/drgroups.go",
        "code_start_line": 22,
        "code_end_line": 71,
        "code_key": "AddHostToDRGroup",
        "code_value": "func AddHostToDRGroup(ctx context.Context, source rdiskDomain.LogicalVolumeState, target rdiskDomain.LogicalVolumeState, stateCtx app.LogicalVolumeContext) (rdiskDomain.LogicalVolumeState, error) {\n\tdata := stateCtx.(CreateLogicalVolumeContext)\n\tvol := data.GetLogicalVolume()\n\tphy := data.GetPhysicalVolume()\n\tspecs := data.GetDRGroupSpecList()\n\trepo := app.GetRegistry(ctx).Repositories.DRGroup\n\tif len(specs) == 0 {\n\t\treturn target, nil\n\t}\n\tfor _, spec := range specs {\n\t\tgroup, err := repo.FindByName(ctx, vol.AppID, spec.Name)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\tgroup = drgroup.New(spec.Name, vol.AppID)\n\t\t\t\tif spec.Affinity > 0 {\n\t\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t\t}\n\t\t\t\tif spec.Type != \"\" {\n\t\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t\t}\n\t\t\t\terr = repo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn source, err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn source, err\n\t\t\t}\n\t\t}\n\t\tif spec.Affinity > 0 && group.Affinity != spec.Affinity {\n\t\t\tlogs.Info(ctx).Uint64(\"app_id\", uint64(vol.AppID)).\n\t\t\t\tStr(\"group_name\", spec.Name).\n\t\t\t\tInt(\"old_affinity\", group.Affinity).\n\t\t\t\tInt(\"new_affinity\", spec.Affinity).\n\t\t\t\tMsg(\"update affinity of drgroup\")\n\t\t\tgroup.Affinity = spec.Affinity\n\t\t}\n\t\tsubGroup := spec.SubGroup\n\t\tif subGroup == \"\" {\n\t\t\t// 如果没有指定子组，则使用远端 SSD UUID 作为子组名称\n\t\t\t// 相当于每块盘都是一个子组，相当于没有使用子组功能\n\t\t\tsubGroup = vol.UUID.String()\n\t\t}\n\t\terr = group.AddMember(vol.UUID.String(), subGroup, phy.IP.String())\n\t\tif err != nil {\n\t\t\treturn source, err\n\t\t}\n\t}\n\n\treturn target, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/create_phy_disk.go",
        "code_start_line": 32,
        "code_end_line": 70,
        "code_key": "CreatePhysicalVolumeInRepository",
        "code_value": "func CreatePhysicalVolumeInRepository(ctx context.Context, source rdiskDomain.PhysicalVolumeState, target rdiskDomain.PhysicalVolumeState, stateCtx app.PhysicalVolumeContext) (rdiskDomain.PhysicalVolumeState, error) {\n\tcreateCtx := stateCtx.(CreatePhysicalVolumeContext)\n\tphysicalVolume := createCtx.GetPhysicalVolume()\n\tspec := createCtx.GetSpec()\n\tif err := rdiskDomain.CheckSerial(spec.Serial); err != nil {\n\t\treturn source, err\n\t}\n\tif physicalVolume != nil {\n\t\t*physicalVolume = *rdiskDomain.NewPhysicalVolume(spec.Serial, spec.IP, spec.BDF, spec.Size, spec.ZoneID, spec.Cuf)\n\t} else {\n\t\tphysicalVolume = rdiskDomain.NewPhysicalVolume(spec.Serial, spec.IP, spec.BDF, spec.Size, spec.ZoneID, spec.Cuf)\n\t}\n\tphysicalVolume.DataNodeType = spec.DataTypeNode\n\tif spec.VolumeType != \"\" {\n\t\tphysicalVolume.VolumeType = spec.VolumeType\n\t}\n\tif spec.PerformanceRank != \"\" {\n\t\tphysicalVolume.PerformanceRank = spec.PerformanceRank\n\t\tif !physicalVolume.PerformanceRank.IsValid() {\n\t\t\treturn source, errors.Newf(rdiskDomain.ErrInvalidPerformanceRank, \"invalid performance rank %s\", spec.PerformanceRank)\n\t\t}\n\t}\n\tphysicalVolume.State = target\n\tlogs.Info(ctx).\n\t\tStr(\"host_ip\", physicalVolume.IP.String()).\n\t\tStr(\"bdf\", string(physicalVolume.BDF)).\n\t\tStr(\"serial\", string(physicalVolume.Serial)).\n\t\tInt(\"zone_id\", int(physicalVolume.ZoneID)).\n\t\tStr(\"volume_type\", string(physicalVolume.VolumeType)).\n\t\tStr(\"cuf\", string(physicalVolume.Cuf)).\n\t\tStr(\"performance_rank\", string(physicalVolume.PerformanceRank)).\n\t\tMsg(\"created physical volume\")\n\n\terr := app.GetRegistry(ctx).Repositories.PhysicalVolume.Add(ctx, physicalVolume)\n\tif err != nil {\n\t\treturn source, err\n\t}\n\treturn target, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 214,
        "code_end_line": 239,
        "code_key": "StepGivenAPhysicalVol",
        "code_value": "func StepGivenAPhysicalVol(registry *app.Registry, value interface{}) *rdiskDomain.PhysicalVolume {\n\tphysicalVol := &rdiskDomain.PhysicalVolume{\n\t\tEntityMixin:  rdiskDomain.EntityMixin{ID: 1},\n\t\tSerial:       \"12345\",\n\t\tIP:           net.IP{127, 0, 0, 1},\n\t\tBDF:          \"bdf\",\n\t\tDiskID:       0,\n\t\tState:        rdiskDomain.PhysicalVolumeState(value.(int)),\n\t\tSize:         1,\n\t\tVolumeType:   \"NVME\",\n\t\tZoneID:       1,\n\t\tBlockSize:    512,\n\t\tRealSize:     5120,\n\t\tPort:         1,\n\t\tDataNodeType: \"unknown\",\n\t\tCuf:          \"清远-清新-C2\",\n\t}\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\terr := registry.Repositories.PhysicalVolume.Add(workerCtx, physicalVol)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn physicalVol\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 244,
        "code_end_line": 277,
        "code_key": "StepGivenPhysicalVols",
        "code_value": "func StepGivenPhysicalVols(registry *app.Registry, value interface{}, num interface{}) []*rdiskDomain.PhysicalVolume {\n\tvar physicalVols []*rdiskDomain.PhysicalVolume\n\tfor i := 0; i < num.(int); i++ {\n\t\tphysicalVols = append(physicalVols, &rdiskDomain.PhysicalVolume{\n\t\t\tEntityMixin:  rdiskDomain.EntityMixin{},\n\t\t\tSerial:       rdiskDomain.Serial(\"111\" + strconv.Itoa(i)),\n\t\t\tIP:           net.IP{127, 0, byte(((i + 2) / 255) % 255), byte((i + 2) % 255)},\n\t\t\tBDF:          \"bdf\",\n\t\t\tDiskID:       0,\n\t\t\tState:        rdiskDomain.PhysicalVolumeState(value.(int)),\n\t\t\tSize:         1,\n\t\t\tVolumeType:   \"\",\n\t\t\tZoneID:       1,\n\t\t\tBlockSize:    512,\n\t\t\tRealSize:     5120,\n\t\t\tPort:         1,\n\t\t\tDataNodeType: \"\",\n\t\t\tCuf:          \"清远-清新-C2\",\n\t\t})\n\t}\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\tfor _, vol := range physicalVols {\n\t\terr := registry.Repositories.PhysicalVolume.Add(workerCtx, vol)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\terr := uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn physicalVols\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 282,
        "code_end_line": 304,
        "code_key": "StepGivenALogicalVol",
        "code_value": "func StepGivenALogicalVol(registry *app.Registry, physicalVol *rdiskDomain.PhysicalVolume, value interface{}) *rdiskDomain.LogicalVolume {\n\tlogicalVol := &rdiskDomain.LogicalVolume{\n\t\tEntityMixin:     rdiskDomain.EntityMixin{ID: 1},\n\t\tUUID:            uuid.Must(uuid.NewRandom()),\n\t\tState:           rdiskDomain.LogicalVolumeState(value.(int)),\n\t\tSize:            1,\n\t\tAppID:           123,\n\t\tZoneID:          1,\n\t\tDiskType:        \"\",\n\t\tVolumeType:      \"\",\n\t\tFlowControlSpec: rdiskDomain.FlowControlSpec{},\n\t\tPhysicalVolume:  physicalVol,\n\t\tAttachments:     nil,\n\t}\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\terr := registry.Repositories.LogicalVolume.Add(workerCtx, logicalVol)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn logicalVol\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 527,
        "code_end_line": 564,
        "code_key": "StepWhenCreateSomeRDiskVol",
        "code_value": "func StepWhenCreateSomeRDiskVol(ctx context.Context, req interface{}) {\n\trequests := req.([]*pb.CreateRDiskVolRequest)\n\n\t// 创建一个 WaitGroup\n\tvar wg sync.WaitGroup\n\t// 创建一个通道来接收结果\n\tresults := make(chan *pb.CreateRDiskVolResponse, len(requests))\n\terrors := make(chan error, len(requests))\n\n\t// 创建一个 API 服务器实例\n\tapiServer := apiserver.NewMasterApiServer()\n\n\tstart := time.Now()\n\t// 遍历请求列表并启动 goroutine 发送请求\n\tfor _, req := range requests {\n\t\twg.Add(1)\n\t\tgo func(req *pb.CreateRDiskVolRequest) {\n\t\t\tdefer wg.Done()\n\t\t\trsp, err := apiServer.CreateRDiskVol(ctx, req)\n\t\t\tif err != nil {\n\t\t\t\terrors <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\tresults <- rsp\n\t\t}(req)\n\t}\n\n\t// 等待所有 goroutines 完成\n\twg.Wait()\n\tclose(results)\n\tclose(errors)\n\tfmt.Println(\"time:\", time.Since(start))\n\ttime.Sleep(2 * time.Second)\n\t// 处理错误\n\tfor err := range errors {\n\t\tfmt.Println(\"Error:\", err)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/benchmark.go",
        "code_start_line": 42,
        "code_end_line": 50,
        "code_key": "FindByUUID",
        "code_value": "func (repo *rdiskBenchmarkRepositoryImpl) FindByUUID(ctx context.Context, uuid string) (*benchmark.Benchmark, error) {\n\tuow := getUow(ctx)\n\tb := &metadb.DmRdiskBenchmark{}\n\tresult := uow.tx.First(b, \"uuid = ?\", uuid)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\treturn uow.trackedBenchmarks.Add(repo.fromDoToModel(b)), nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/backup.go",
        "code_start_line": 44,
        "code_end_line": 53,
        "code_key": "FindByUUID",
        "code_value": "func (impl *rdiskBackupRepositoryImpl) FindByUUID(ctx context.Context, uuid string) (*backupPkg.Backup, error) {\n\tuow := getUow(ctx)\n\n\tb := &metadb.DmRdiskBackup{}\n\tresult := uow.tx.First(b, \"uuid = ?\", uuid)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\treturn uow.trackedBackups.Add(impl.fromDOToModel(b)), nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go",
        "code_start_line": 22,
        "code_end_line": 47,
        "code_key": "FindByAppIDAndUUID",
        "code_value": "func (logicalVolumeRepositoryImpl) FindByAppIDAndUUID(ctx context.Context, appID users.AppID, id uuid.UUID) (*rdiskDomain.LogicalVolume, error) {\n\tuow := getUow(ctx)\n\tvol := metadb.DmRdisk{}\n\tresult := uow.tx.\n\t\tPreload(\"Attachments\").\n\t\tPreload(\"DmPhyDisk\").\n\t\tFirst(&vol, \"uuid = ? AND app_id = ?\", id.String(), appID)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tlv, err := fromDmRDiskToModel(ctx, &vol)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlv = uow.trackedLogicalVolumes.Add(lv)\n\tif lv.PhysicalVolume != nil {\n\t\tlv.PhysicalVolume = uow.trackedPhyVolumes.Add(lv.PhysicalVolume)\n\t}\n\treturn lv, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 55,
        "code_end_line": 61,
        "code_key": "FindByAppIDAndUUID",
        "code_value": "func (m *MockLogicalVolumeRepository) FindByAppIDAndUUID(arg0 context.Context, arg1 users.AppID, arg2 uuid.UUID) (*rdiskDomain.LogicalVolume, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByAppIDAndUUID\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(*rdiskDomain.LogicalVolume)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 64,
        "code_end_line": 67,
        "code_key": "FindByAppIDAndUUID",
        "code_value": "func (mr *MockLogicalVolumeRepositoryMockRecorder) FindByAppIDAndUUID(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByAppIDAndUUID\", reflect.TypeOf((*MockLogicalVolumeRepository)(nil).FindByAppIDAndUUID), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go",
        "code_start_line": 49,
        "code_end_line": 74,
        "code_key": "FindByID",
        "code_value": "func (l logicalVolumeRepositoryImpl) FindByID(ctx context.Context, id uuid.UUID) (*rdiskDomain.LogicalVolume, error) {\n\tuow := getUow(ctx)\n\tvol := metadb.DmRdisk{}\n\tresult := uow.tx.\n\t\tPreload(\"Attachments\").\n\t\tPreload(\"DmPhyDisk\").\n\t\tFirst(&vol, \"uuid = ?\", id.String())\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tlv, err := fromDmRDiskToModel(ctx, &vol)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlv = uow.trackedLogicalVolumes.Add(lv)\n\tif lv.PhysicalVolume != nil {\n\t\tlv.PhysicalVolume = uow.trackedPhyVolumes.Add(lv.PhysicalVolume)\n\t}\n\treturn lv, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 70,
        "code_end_line": 76,
        "code_key": "FindByID",
        "code_value": "func (m *MockLogicalVolumeRepository) FindByID(arg0 context.Context, arg1 uuid.UUID) (*rdiskDomain.LogicalVolume, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByID\", arg0, arg1)\n\tret0, _ := ret[0].(*rdiskDomain.LogicalVolume)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 79,
        "code_end_line": 82,
        "code_key": "FindByID",
        "code_value": "func (mr *MockLogicalVolumeRepositoryMockRecorder) FindByID(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByID\", reflect.TypeOf((*MockLogicalVolumeRepository)(nil).FindByID), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go",
        "code_start_line": 21,
        "code_end_line": 38,
        "code_key": "FindBySerial",
        "code_value": "func (p *physicalVolumeRepositoryImpl) FindBySerial(ctx context.Context, serial rdiskDomain.Serial) (*rdiskDomain.PhysicalVolume, error) {\n\tuow := getUow(ctx)\n\tvar vol metadb.DmPhydisk\n\tresult := uow.tx.Where(\"serial = ?\", string(serial)).First(&vol)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\t// 覆盖 gorm 的错误\n\t\t\treturn nil, errors.New(rdiskDomain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tpv := fromDmPhyDiskToPhysicalVolume(ctx, &vol)\n\tpv = uow.trackedPhyVolumes.Add(pv)\n\treturn pv, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 83,
        "code_end_line": 89,
        "code_key": "FindBySerial",
        "code_value": "func (m *MockPhysicalVolumeRepository) FindBySerial(arg0 context.Context, arg1 rdiskDomain.Serial) (*rdiskDomain.PhysicalVolume, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindBySerial\", arg0, arg1)\n\tret0, _ := ret[0].(*rdiskDomain.PhysicalVolume)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 92,
        "code_end_line": 95,
        "code_key": "FindBySerial",
        "code_value": "func (mr *MockPhysicalVolumeRepositoryMockRecorder) FindBySerial(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindBySerial\", reflect.TypeOf((*MockPhysicalVolumeRepository)(nil).FindBySerial), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go",
        "code_start_line": 40,
        "code_end_line": 57,
        "code_key": "FindByIPAndBDF",
        "code_value": "func (p *physicalVolumeRepositoryImpl) FindByIPAndBDF(ctx context.Context, ip net.IP, bdf rdiskDomain.BDF) (*rdiskDomain.PhysicalVolume, error) {\n\tuow := getUow(ctx)\n\tvar vol metadb.DmPhydisk\n\tresult := uow.tx.Where(\"host_ip = ? AND bdf = ?\", ip.String(), string(bdf)).Find(&vol)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\t// 覆盖 gorm 的错误\n\t\t\treturn nil, errors.New(rdiskDomain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tpv := fromDmPhyDiskToPhysicalVolume(ctx, &vol)\n\tpv = uow.trackedPhyVolumes.Add(pv)\n\treturn pv, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 68,
        "code_end_line": 74,
        "code_key": "FindByIPAndBDF",
        "code_value": "func (m *MockPhysicalVolumeRepository) FindByIPAndBDF(arg0 context.Context, arg1 net.IP, arg2 rdiskDomain.BDF) (*rdiskDomain.PhysicalVolume, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByIPAndBDF\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(*rdiskDomain.PhysicalVolume)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 77,
        "code_end_line": 80,
        "code_key": "FindByIPAndBDF",
        "code_value": "func (mr *MockPhysicalVolumeRepositoryMockRecorder) FindByIPAndBDF(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByIPAndBDF\", reflect.TypeOf((*MockPhysicalVolumeRepository)(nil).FindByIPAndBDF), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
        "code_start_line": 31,
        "code_end_line": 52,
        "code_key": "FindByNames",
        "code_value": "func (d drgroupRepositoryImpl) FindByNames(ctx context.Context, appId users.AppID, names []string) ([]*drgroup.DRGroup, error) {\n\tuow := getUow(ctx)\n\tgroup := []metadb.DmDrgroup{}\n\tresult := uow.tx.\n\t\tPreload(\"Members\").\n\t\tFind(&group, \"app_id = ? and name in ?\", appId, names)\n\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"disaster recovery group not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tresults := make([]*drgroup.DRGroup, len(group))\n\tfor i := range group {\n\t\tresults[i] = uow.trackedDRGroups.Add(fromDmDRGroupToModel(&group[i]))\n\t}\n\treturn results, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 113,
        "code_end_line": 119,
        "code_key": "FindByNames",
        "code_value": "func (m *MockRepository) FindByNames(arg0 context.Context, arg1 users.AppID, arg2 []string) ([]*drgroup.DRGroup, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByNames\", arg0, arg1, arg2)\n\tret0, _ := ret[0].([]*drgroup.DRGroup)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 122,
        "code_end_line": 125,
        "code_key": "FindByNames",
        "code_value": "func (mr *MockRepositoryMockRecorder) FindByNames(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByNames\", reflect.TypeOf((*MockRepository)(nil).FindByNames), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
        "code_start_line": 58,
        "code_end_line": 94,
        "code_key": "FindByMembers",
        "code_value": "func (d drgroupRepositoryImpl) FindByMembers(ctx context.Context, appId users.AppID, members []string) ([]*drgroup.DRGroup, error) {\n\tuow := getUow(ctx)\n\tgroup := []metadb.DmDrgroup{}\n\n\tmembersResult := []metadb.DmDrgroupMembers{}\n\tresult := uow.tx.\n\t\tFind(&membersResult, \"app_id = ? and member_id in ?\", appId, members)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tnames := make([]string, 0, len(members))\n\tfor i := range membersResult {\n\t\tnames = append(names, membersResult[i].GroupName)\n\t}\n\tresult = uow.tx.\n\t\tPreload(\"Members\").\n\t\tFind(&group, \"app_id = ? and name in ?\", appId, names)\n\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"disaster recovery group not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tresults := make([]*drgroup.DRGroup, len(group))\n\tfor i := range group {\n\t\tresults[i] = fromDmDRGroupToModel(&group[i])\n\t\tresults[i] = uow.trackedDRGroups.Add(results[i])\n\t}\n\treturn results, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/drgroup.go",
        "code_start_line": 92,
        "code_end_line": 124,
        "code_key": "FindByMembers",
        "code_value": "func (d *drgroupViewerImpl) FindByMembers(ctx context.Context, appId users.AppID, members []string) ([]*drgroup.View, error) {\n\tvar (\n\t\tresultViews       []drgroup.View\n\t\tresultViewRef     []*drgroup.View\n\t\tdataObjects       []*metadb.DmDrgroup\n\t\tdataObjectMembers []*metadb.DmDrgroupMembers\n\t)\n\tresult := d.db.WithContext(ctx).Find(&dataObjectMembers, \"app_id = ? and member_id in ?\", appId, members)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"group not exist\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tgroupNames := make([]string, len(dataObjectMembers))\n\tfor i := range dataObjectMembers {\n\t\tgroupNames[i] = dataObjectMembers[i].GroupName\n\t}\n\tresult = d.db.WithContext(ctx).Find(&dataObjects, \"app_id = ? and name in ?\", appId, groupNames)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"group not exist\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tresultViews = make([]drgroup.View, len(dataObjects))\n\tresultViewRef = make([]*drgroup.View, len(dataObjects))\n\tfor i := range dataObjects {\n\t\tresultViewRef[i] = &resultViews[i]\n\t\td.translate(dataObjects[i], resultViewRef[i])\n\t}\n\treturn resultViewRef, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 83,
        "code_end_line": 89,
        "code_key": "FindByMembers",
        "code_value": "func (m *MockRepository) FindByMembers(arg0 context.Context, arg1 users.AppID, arg2 []string) ([]*drgroup.DRGroup, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByMembers\", arg0, arg1, arg2)\n\tret0, _ := ret[0].([]*drgroup.DRGroup)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 92,
        "code_end_line": 95,
        "code_key": "FindByMembers",
        "code_value": "func (mr *MockRepositoryMockRecorder) FindByMembers(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByMembers\", reflect.TypeOf((*MockRepository)(nil).FindByMembers), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/view.go",
        "code_start_line": 55,
        "code_end_line": 61,
        "code_key": "FindByMembers",
        "code_value": "func (m *MockViewer) FindByMembers(arg0 context.Context, arg1 users.AppID, arg2 []string) ([]*drgroup.View, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByMembers\", arg0, arg1, arg2)\n\tret0, _ := ret[0].([]*drgroup.View)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/view.go",
        "code_start_line": 64,
        "code_end_line": 67,
        "code_key": "FindByMembers",
        "code_value": "func (mr *MockViewerMockRecorder) FindByMembers(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByMembers\", reflect.TypeOf((*MockViewer)(nil).FindByMembers), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 178,
        "code_end_line": 233,
        "code_key": "updateReadLocks",
        "code_value": "func (l *mysqlLocker) updateReadLocks(tx *gorm.DB, ttl time.Duration, keys []string, lockTokens []string) ([]string, []string, []string, error) {\n\tif len(keys) == 0 {\n\t\treturn nil, nil, lockTokens, nil\n\t}\n\ttype Result struct {\n\t\tLock       string\n\t\tExpiration time.Time\n\t\tToken      string\n\t}\n\tvar Results []Result\n\terr := tx.Raw(\"SELECT `\"+l.lockColumn+\"` AS `lock`, `\"+l.expireColumn+\"` AS `expiration`, `\"+l.tokenColumn+\"` AS `token` FROM \"+l.tableName+\" WHERE `\"+l.lockColumn+\"` IN (?)\", keys).Scan(&Results).Error\n\tif err != nil {\n\t\treturn nil, nil, nil, errors.Wrap(err, \"fail to query locks\")\n\t}\n\n\tvar needUpdateExpirationReadKeys []string = nil\n\tvar needUpdateCountReadKeys []string = nil\n\tl.mutex.Lock()\n\tt := time.Now()\n\tfor _, r := range Results {\n\t\tif r.Token != lockTokens[0] {\n\t\t\tlockTokens = append(lockTokens, r.Token)\n\t\t}\n\t\tif readKey, exist := l.readKeysMemLock[r.Lock]; exist {\n\t\t\treadKey.count++\n\t\t\treadKey.expiration = r.Expiration\n\t\t} else {\n\t\t\tl.readKeysMemLock[r.Lock] = &readKeysMemLock{\n\t\t\t\tcount:      1,\n\t\t\t\texpiration: r.Expiration,\n\t\t\t\ttoken:      r.Token,\n\t\t\t}\n\t\t\tneedUpdateCountReadKeys = append(needUpdateCountReadKeys, r.Lock)\n\t\t}\n\t\tif l.readKeysMemLock[r.Lock].expiration.Sub(t) < ttl/3 {\n\t\t\tl.readKeysMemLock[r.Lock].expiration = t.Add(ttl)\n\t\t\tneedUpdateExpirationReadKeys = append(needUpdateExpirationReadKeys, r.Lock)\n\t\t}\n\t}\n\tl.mutex.Unlock()\n\tif len(needUpdateExpirationReadKeys) > 0 {\n\t\tresult := tx.Exec(\"UPDATE \"+l.tableName+\" SET \"+l.expireColumn+\" = NOW() + INTERVAL ? SECOND WHERE `\"+l.lockColumn+\"` IN (?)\", ttl.Seconds(), needUpdateExpirationReadKeys)\n\t\tif result.Error != nil {\n\t\t\treturn nil, needUpdateExpirationReadKeys, needUpdateCountReadKeys, errors.Wrap(result.Error, fmt.Sprintf(\"failed to update readLocks: %s\", keys))\n\t\t}\n\t}\n\n\tif len(needUpdateCountReadKeys) > 0 {\n\t\tresult := tx.Exec(\"UPDATE \"+l.tableName+\" SET \"+l.lockNumsColumn+\" = \"+l.lockNumsColumn+\" + 1 WHERE `\"+l.lockColumn+\"` IN (?)\", needUpdateCountReadKeys)\n\t\tif result.Error != nil {\n\t\t\treturn nil, needUpdateExpirationReadKeys, needUpdateCountReadKeys, errors.Wrap(result.Error, fmt.Sprintf(\"failed to update readLocks: %s\", keys))\n\t\t}\n\t}\n\n\treturn nil, nil, lockTokens, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 335,
        "code_end_line": 369,
        "code_key": "insertLocks",
        "code_value": "func (l *mysqlLocker) insertLocks(tx *gorm.DB, lockKeys []*dlock.LockKey, ttl time.Duration, lockToken []string) ([]string, error) {\n\tif len(lockKeys) <= 0 {\n\t\treturn nil, nil\n\t}\n\tstmt := strings.Builder{}\n\targs := make([]interface{}, 0, len(lockKeys)*5)\n\tt := time.Now().Add(ttl)\n\tstmt.WriteString(fmt.Sprintf(\"INSERT INTO `%s` (`%s`, `%s`, `%s`, `%s`, `%s`) VALUES \", l.tableName, l.lockColumn, l.expireColumn, l.tokenColumn, l.lockTypeColumn, l.lockNumsColumn))\n\tfor i, key := range lockKeys {\n\t\tif i > 0 {\n\t\t\tstmt.WriteString(\", \")\n\t\t}\n\t\tstmt.WriteString(\"(?, NOW() + INTERVAL ? SECOND, ?, ?, ?)\")\n\t\targs = append(args, key.Key, ttl.Seconds(), lockToken[0], int(key.Type), 1)\n\t}\n\n\tresult := tx.Exec(stmt.String(), args...)\n\tif result.Error != nil {\n\t\treturn nil, errors.Wrap(result.Error, \"failed to insert locks\")\n\t}\n\tvar needInsertReadKeys []string = nil\n\tl.mutex.Lock()\n\tfor _, key := range lockKeys {\n\t\tif key.Type == dlock.ReadLock {\n\t\t\tl.readKeysMemLock[key.Key] = &readKeysMemLock{\n\t\t\t\tcount:      1,\n\t\t\t\texpiration: t,\n\t\t\t\ttoken:      lockToken[0],\n\t\t\t}\n\t\t\tneedInsertReadKeys = append(needInsertReadKeys, key.Key)\n\t\t}\n\t}\n\tl.mutex.Unlock()\n\treturn needInsertReadKeys, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 417,
        "code_end_line": 470,
        "code_key": "tryObtainMulti",
        "code_value": "func (l *mysqlLocker) tryObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, tokens []string, opts *dlock.Option) ([]string, error) {\n\t// Starts a new transaction.\n\ttx := l.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\n\n\t// Fetch existing locks.\n\texistingReadKeys, existingWriteKeys, expiredKeys, err := l.fetchExistingLocks(tx, keys)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// If there are existing valid locks, return an error.\n\tif len(existingWriteKeys) > 0 {\n\t\t_ = tx.Rollback()\n\t\treturn nil, errors.Wrap(dlock.ErrLockNotHeld, fmt.Sprintf(\"writeKeys %v are already locked\", existingWriteKeys))\n\t}\n\n\t// Delete expired locks if exists.\n\tif err := l.deleteExpiredLocks(tx, expiredKeys); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Remove existing readLocks from insert.\n\t// NOCA:QCloudAkCheck(误报)\n\tlockKeys, err := l.removeExistingReadLocksFromInsert(tx, keys, existingReadKeys)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Insert locks into database.\n\tneedInsertReadKeys, err := l.insertLocks(tx, lockKeys, ttl, tokens)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Update readLocks.\n\tvar needUpdateExpirationReadKeys []string = nil\n\tvar needUpdateCountReadKeys []string = nil\n\tif needUpdateExpirationReadKeys, needUpdateCountReadKeys, tokens, err = l.updateReadLocks(tx, ttl, existingReadKeys, tokens); err != nil {\n\t\tl.rollback(needUpdateCountReadKeys, tokens)\n\t\tl.rollback(needUpdateExpirationReadKeys, tokens)\n\t\tl.rollback(needInsertReadKeys, tokens)\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\tif result := tx.Commit(); result.Error != nil {\n\t\treturn nil, errors.Wrap(result.Error, \"failed to commit transaction\")\n\t}\n\n\treturn tokens, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mem/memdlock.go",
        "code_start_line": 106,
        "code_end_line": 166,
        "code_key": "tryObtainMulti",
        "code_value": "func (l *memLocker) tryObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, token string) (dlock.Lock, error) {\n\tl.mutex.Lock()\n\tdefer l.mutex.Unlock()\n\tvar readLocks []*dlock.LockKey\n\tvar writeLocks []*dlock.LockKey\n\tvar insertLocks []*dlock.LockKey\n\tvar tokens []string\n\ttokens = append(tokens, token)\n\tfor _, key := range keys {\n\t\tif key.Type == dlock.WriteLock {\n\t\t\twriteLocks = append(writeLocks, key)\n\t\t} else {\n\t\t\treadLocks = append(readLocks, key)\n\t\t}\n\t}\n\tfor _, key := range writeLocks {\n\t\tif item, ok := l.data[key.Key]; ok {\n\t\t\tif time.Until(item.ttl) > 0 {\n\t\t\t\treturn nil, dlock.ErrNotObtained\n\t\t\t} else {\n\t\t\t\tinsertLocks = append(insertLocks, key)\n\t\t\t}\n\t\t} else {\n\t\t\tinsertLocks = append(insertLocks, key)\n\t\t}\n\t}\n\tfor _, key := range readLocks {\n\t\tif item, ok := l.data[key.Key]; ok {\n\t\t\tif item.lockType == dlock.ReadLock {\n\t\t\t\tif time.Until(item.ttl) > 0 {\n\t\t\t\t\titem.count++\n\t\t\t\t\titem.ttl = time.Now().Add(ttl)\n\t\t\t\t\ttokens = append(tokens, item.token)\n\t\t\t\t} else {\n\t\t\t\t\tinsertLocks = append(insertLocks, key)\n\t\t\t\t}\n\t\t\t} else if time.Until(item.ttl) > 0 {\n\t\t\t\treturn nil, dlock.ErrNotObtained\n\t\t\t}\n\t\t} else {\n\t\t\tinsertLocks = append(insertLocks, key)\n\t\t}\n\t}\n\n\tfor _, key := range insertLocks {\n\t\tl.data[key.Key] = &lockItem{\n\t\t\tkey:      key.Key,\n\t\t\tttl:      time.Now().Add(ttl),\n\t\t\ttoken:    token,\n\t\t\tlockType: key.Type,\n\t\t\tcount:    1,\n\t\t}\n\t}\n\n\tlock := &memLock{\n\t\tlocker: l,\n\t\tkeys:   keys,\n\t\ttokens: tokens,\n\t}\n\treturn lock, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 473,
        "code_end_line": 520,
        "code_key": "ObtainMulti",
        "code_value": "func (l *mysqlLocker) ObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, opts *dlock.Option) (dlock.Lock, error) {\n\tif len(keys) == 0 {\n\t\treturn nil, errors.New(\"keys cannot be empty\")\n\t}\n\tkeys = dedupAndSort(keys)\n\n\t// Get the lock token.\n\tlockToken, err := l.getOrCreateLockToken(opts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tretryStrategy := dlock.NoRetry()\n\tif opts != nil && opts.RetryStrategy != nil {\n\t\tretryStrategy = opts.RetryStrategy\n\t}\n\n\tretries := 0\n\tlogger := logs.GetLogger(ctx).With().Strs(\"keys\", dlock.LockKeySlice(keys).GetKeys()).Strs(\"tokens\", lockToken).Logger()\n\n\tfor {\n\t\t// Try to obtain the locks.\n\t\t// If the locks are not obtained, retry based on the retry strategy.\n\t\tif tokens, err := l.tryObtainMulti(ctx, keys, ttl, lockToken, opts); err != nil {\n\t\t\t// If context is canceled, return immediately.\n\t\t\tif ctx.Err() != nil {\n\t\t\t\treturn nil, errors.Wrap(dlock.ErrNotObtained, \"context is canceled\")\n\t\t\t}\n\n\t\t\t// If the lock is not obtained, retry.\n\t\t\twaitDuration := retryStrategy.NextBackoff()\n\t\t\tif waitDuration <= 0 {\n\t\t\t\tlogger.Debug().Int(\"retry\", retries).Msg(\"stop retrying lock\")\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tlogger.Debug().Int(\"retry\", retries).Msg(\"retry obtaining lock\")\n\t\t\ttime.Sleep(waitDuration)\n\t\t} else {\n\t\t\tlockToken = tokens\n\t\t\tlogger.Debug().Msg(\"lock obtained\")\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// TODO xuanzeng: 这里采用内部记录 TTL 的方式，可能和底层的数据库时间不同步，后续应该从数据库中获取过期时间。\n\tlock := &mysqlLock{keys: keys, locker: l, tokens: lockToken, expiration: time.Now().Add(ttl)}\n\treturn lock, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mem/memdlock.go",
        "code_start_line": 74,
        "code_end_line": 103,
        "code_key": "ObtainMulti",
        "code_value": "func (l *memLocker) ObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, opts *dlock.Option) (dlock.Lock, error) {\n\tvar token string\n\tif opts == nil || opts.Token == \"\" {\n\t\ttoken = uuid.New().String()\n\t} else {\n\t\ttoken = opts.Token\n\t}\n\n\tretryStrategy := dlock.NoRetry()\n\tif opts != nil && opts.RetryStrategy != nil {\n\t\tretryStrategy = opts.RetryStrategy\n\t}\n\n\tfor {\n\t\tlock, err := l.tryObtainMulti(ctx, keys, ttl, token)\n\t\tif err == nil {\n\t\t\treturn lock, nil\n\t\t}\n\n\t\tif ctx.Err() != nil {\n\t\t\treturn nil, ctx.Err()\n\t\t}\n\n\t\twaitInterval := retryStrategy.NextBackoff()\n\t\tif waitInterval <= 0 {\n\t\t\treturn nil, dlock.ErrNotObtained\n\t\t}\n\t\ttime.Sleep(waitInterval)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": []
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/backup.go:19:31:Add": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/backup.go",
    "code_start_line": 19,
    "code_end_line": 31,
    "code_start_column": 40,
    "code_key": "Add",
    "code_value": "func (repo *rdiskBackupRepositoryImpl) Add(ctx context.Context, backup *backupPkg.Backup) error {\n\tuow := getUow(ctx)\n\tdo := repo.fromModelToDO(backup)\n\tdo.Created = uow.tx.NowFunc()\n\tdo.Updated = uow.tx.NowFunc()\n\tresult := uow.tx.Create(&do)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tbackup.ID = do.ID\n\tuow.trackedBackups.Add(backup)\n\treturn nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/infra/event_bus/bus.go",
        "code_start_line": 61,
        "code_end_line": 79,
        "code_key": "Execute",
        "code_value": "func (eb *EventBusDriver) Execute(ctx context.Context) (result *response.Result) {\n\tresult = response.DefaultResult()\n\tdefer utils.HandlePanic(ctx, &result)\n\n\tfor _, event := range eb.BlockEventQueue {\n\t\tresult = eb.ExecuteOne(ctx, event)\n\t\tif result.IsSuccess() {\n\t\t\tevent.UpdateState(ctx, Executed)\n\t\t} else {\n\t\t\tlogs.Warn(ctx).Err(result).Int(\"EventType\", int(event.GetType(ctx))).\n\t\t\t\tMsg(\"event execute failed, start rollback event bus\")\n\t\t\tif err := eb.RollbackEvents(ctx); err != nil {\n\t\t\t\tlogs.Error(ctx).Err(err).Int(\"EventType\", int(event.GetType(ctx))).Msg(\"rollback event bus failed\")\n\t\t\t}\n\t\t\treturn result\n\t\t}\n\t}\n\treturn result\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/filters/filter.go",
        "code_start_line": 26,
        "code_end_line": 46,
        "code_key": "Execute",
        "code_value": "func (f FilterChain) Execute(ctx context.Context, disks []*disk.Disk, user *account.User,\n\tcacheMap cache.RDCacheManagerInf, affinityConfig *dto.AffinityConfig) ([]*disk.Disk, response.Result) {\n\tlogs.Info(ctx).Int(\"disk_count\", len(disks)).Msg(\"DISK_COUNT_BEFORE_FILTER\")\n\tfor _, filter := range f.filters {\n\t\tdisks, result := filter.\n\t\t\tWithUser(ctx, user).\n\t\t\tWithRdCacheManager(ctx, cacheMap).\n\t\t\tWithAffinityConfig(ctx, affinityConfig).\n\t\t\tFilter(ctx, disks)\n\t\tdisks = disk.SortByScore(ctx, disks)\n\t\tlogs.Info(ctx).\n\t\t\tInt(\"disk_count\", len(disks)).\n\t\t\tStr(\"filter\", reflect.TypeOf(filter).Name()).\n\t\t\tMsg(\"LEFT_DISK_COUNT_AFTER_FILTER\")\n\t\tif result.IsFailed() {\n\t\t\treturn disks, result\n\t\t}\n\t}\n\t// 对盘的Score进行排序\n\treturn disks, response.SucResult()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_bill_compute_task.go",
        "code_start_line": 26,
        "code_end_line": 40,
        "code_key": "Execute",
        "code_value": "func (t *SnapBillComputeTask) Execute(ctx context.Context) (bool, error) {\n\tt.Ctx = ctx\n\tt.InitTask(ctx)\n\tdefer t.MqIns.Close()\n\n\t// 获取待处理的用户资源\n\tgo t.GetUserResources()\n\t// 执行Ack确认逻辑\n\tgo t.AckAppId()\n\t// 处理用户资源\n\tt.ProcessUserResources()\n\n\tlogs.Info(ctx).Msg(\"SNAP_COMPUTE_TASK_DONE\")\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_calculate_cost_locally_task.go",
        "code_start_line": 21,
        "code_end_line": 37,
        "code_key": "Execute",
        "code_value": "func (t *SnapCalculateCostLocallyTask) Execute(ctx context.Context) (bool, error) {\n\tt.ctx = ctx\n\tsnapRecSrv := measureReconciliation.NewReconciliationSrvImpl(ctx)\n\n\t// 结算上上个周期的用量\n\tnow := time.Now()\n\tstartTime := now.Truncate(time.Hour).Add(-2 * time.Hour)\n\tendTime := now.Truncate(time.Hour).Add(-1 * time.Hour).Add(-1 * time.Second)\n\tlogs.Info(t.ctx).Time(\"startTime\", startTime).Time(\"endTime\", endTime).Msg(\"START_CALCULATE_COST_LOCALLY\")\n\terr := snapRecSrv.CalculateCostLocally(startTime, endTime)\n\tif err != nil {\n\t\tlogs.Error(t.ctx).Err(err).Msg(\"CALCULATE_COST_LOCALLY_ERROR\")\n\t\treturn false, err\n\t}\n\tlogs.Info(t.ctx).Msg(\"CALCULATE_COST_LOCALLY_DONE\")\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/cbs_bill_compute_task.go",
        "code_start_line": 26,
        "code_end_line": 42,
        "code_key": "Execute",
        "code_value": "func (t *CbsBillComputeTask) Execute(ctx context.Context) (bool, error) {\n\tt.Ctx = ctx\n\tt.InitTask(ctx)\n\tdefer t.MqIns.Close()\n\n\t// 获取待处理的用户资源\n\tgo t.GetUserResources()\n\t// 执行Ack确认逻辑\n\tgo t.AckAppId()\n\t// 处理用户资源\n\tt.ProcessUserResources()\n\tt.ChargeItemProducer.Close()\n\n\tt.WG.Wait()\n\tlogs.Info(ctx).Msg(\"CBS_COMPUTE_TASK_DONE\")\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/update_ccbs_normal_rb_task.go",
        "code_start_line": 23,
        "code_end_line": 34,
        "code_key": "Execute",
        "code_value": "func (t *UpdateCCbsNormalRollbackTask) Execute(ctx context.Context) (bool, error) {\n\tt.Count += 1\n\tserv := registry.GetRegistry(ctx).DomainServices.DiskRollbackingService.(diskLogical.DiskRollbackingServiceInterface)\n\tisFinish, err := serv.UpdateCbsRollbackingPercent(ctx, t.DiskAggregate)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tlogs.Info(ctx).Int(\"Status\", t.DiskAggregate.DiskRecord.Status).\n\t\tInt(\"Percent\", t.DiskAggregate.DiskRecord.RollbackingPercent).\n\t\tInt(\"Count\", t.Count).Msg(\"FINISH_EXECUTE_TASK\")\n\treturn isFinish, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/repush_user_billing_task.go",
        "code_start_line": 53,
        "code_end_line": 61,
        "code_key": "Execute",
        "code_value": "func (t *RepushUserBillingTask) Execute(ctx context.Context) (bool, error) {\n\tt.ctx = ctx\n\tt.InitTask(ctx)\n\tdefer t.MqIns.Close()\n\n\tt.ProcessRepushDetailMsg()\n\tlogs.Info(ctx).Msg(\"REPUSH_USER_BILLING_TASK_DONE\")\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/update_create_task.go",
        "code_start_line": 31,
        "code_end_line": 69,
        "code_key": "Execute",
        "code_value": "func (t *UpdateCreateTask) Execute(ctx context.Context) (bool, error) {\n\tt.Count += 1\n\tserv := registry.GetRegistry(ctx).DomainServices.SnapCreatingService.(snapLogical.SnapCreatingServiceInterface)\n\tif t.SnapAggregate.SnapRecord.Status == ccdb.SnapCreating &&\n\t\tt.SnapAggregate.SnapRecord.LifeState == ccdb.SnapLifeStateNormal &&\n\t\tt.SnapAggregate.SnapRecord.Percent == 100 &&\n\t\tt.SnapAggregate.SnapRecord.Attribute != ccdb.SnapAttUserSnap {\n\t\t// 隐藏快照转正常快照\n\t\tlogs.Info(ctx).Msg(\"FIX_INNER_TO_NORMAL\")\n\t\terr := serv.SnapCreateTaskFollowup(ctx, t.SnapAggregate, SnapInnerFollowup)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\treturn true, nil\n\t}\n\n\tisFinish, err := serv.UpdateSnapCreatingPercent(ctx, t.SnapAggregate)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\t// 创建完成的用户快照进行后续操作，隐藏快照不进行\n\tif isFinish && t.SnapAggregate.SnapRecord.Status == ccdb.SnapNormal &&\n\t\tt.SnapAggregate.SnapRecord.LifeState == ccdb.SnapLifeStateNormal {\n\t\t// 目的端快照复制完成时，需更新源端的快照状态\n\t\t// 计算base snap size，并更新\n\t\t// merge\n\t\t// 插入计费，并更新快照大小\n\t\terr = serv.SnapCreateTaskFollowup(ctx, t.SnapAggregate, SnapNormalFollowup)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\n\tlogs.Info(ctx).Int(\"Status\", t.SnapAggregate.SnapRecord.Status).\n\t\tInt(\"Percent\", t.SnapAggregate.SnapRecord.Percent).\n\t\tInt(\"Count\", t.Count).Msg(\"FINISH_EXECUTE_TASK\")\n\treturn isFinish, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/update_image_snap_rb_task.go",
        "code_start_line": 23,
        "code_end_line": 41,
        "code_key": "Execute",
        "code_value": "func (t *UpdateImageSnapRollbackTask) Execute(ctx context.Context) (bool, error) {\n\tt.Count += 1\n\tserv := registry.GetRegistry(ctx).DomainServices.DiskRollbackingService.(diskLogical.DiskRollbackingServiceInterface)\n\tisFinish, err := serv.UpdateImageSnapRollbackingPercent(ctx, t.DiskAggregate)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif isFinish {\n\t\t// TODO：这里应该放入一个管道中，后续再优化\n\t\terr = serv.UpdateRollbackQuota(ctx, t.DiskAggregate)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\tlogs.Info(ctx).Str(\"Status\", t.DiskAggregate.ImageSnapRollbackRecord.Status).\n\t\tInt(\"Percent\", t.DiskAggregate.ImageSnapRollbackRecord.Percent).\n\t\tInt(\"Count\", t.Count).Msg(\"FINISH_EXECUTE_TASK\")\n\treturn isFinish, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/cbs_measure_send_task.go",
        "code_start_line": 30,
        "code_end_line": 54,
        "code_key": "Execute",
        "code_value": "func (t *CbsMeasureSendTask) Execute(ctx context.Context) (bool, error) {\n\t// 初始化各项配置\n\tt.Ctx = ctx\n\tt.InitTask(ctx)\n\tt.cbsSrv = cbsResource.NewCbsSrvImpl(t.Ctx)\n\tdefer t.MqIns.Close()\n\t// 根据区域分发到国内和国际两个不同channel中去处理\n\tt.ChannelDistribution()\n\n\t// MSG处理的生命周期Msg -->chargeItem -->MeasureDetails-->MeasureDetailsChannel-->Params-->Ack Msg\n\tgo t.ProcessMsgByRegion()\n\n\t// 计费详情转换成计费参数\n\tgo t.ProcessMeasureDetailToParams()\n\n\t// 执行ACK\n\tgo t.AckResourceID()\n\n\t// 根据计费参数发送计费消息\n\tt.ProcessParamsSendMeasure()\n\n\tt.WG.Wait()\n\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/cbs_rec_task.go",
        "code_start_line": 37,
        "code_end_line": 61,
        "code_key": "Execute",
        "code_value": "func (t *CbsMeasureRecTask) Execute(ctx context.Context) (bool, error) {\n\t// 初始化各项配置\n\tt.Ctx = ctx\n\tt.InitTask(ctx)\n\t// 初始化snapSrv\n\tt.cbsReSrv = measureReconciliation.NewReconciliationSrvImpl(t.Ctx)\n\tt.cbsSrv = cbsResource.NewCbsSrvImpl(t.Ctx)\n\tdefer t.MqIns.Close()\n\t// 根据区域分发到国内和国际两个不同channel中去处理\n\tt.ChannelDistribution()\n\n\t// MSG处理的生命周期Msg -->chargeItem -->subMeasureDetails-->subMeasureDetailsChannel-->db-->Ack Msg\n\tgo t.ProcessMsg()\n\n\t// 生成批次外发的计费对账数据\n\tgo t.ProcessMeasureDetailBatch()\n\n\t// 执行ACK\n\tgo t.AckResourceID()\n\n\t// 将计费数据外发到数据库\n\tt.ProcessMeasureToDb()\n\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_measure_send_task.go",
        "code_start_line": 27,
        "code_end_line": 49,
        "code_key": "Execute",
        "code_value": "func (t *SnapMeasureSendTask) Execute(ctx context.Context) (bool, error) {\n\t// 初始化各项配置\n\tt.Ctx = ctx\n\tt.InitTask(ctx)\n\tdefer t.MqIns.Close()\n\n\t// 根据区域分发到国内和国际两个不同channel中去处理\n\tt.ChannelDistribution()\n\n\t// 启动外发任务\n\tgo t.ProcessMsgByRegion()\n\n\t// 用量详情转换成计费协议\n\tgo t.ProcessMeasureDetailToParams()\n\n\t// 执行ACK\n\tgo t.AckResourceID()\n\n\t// 根据计费协议发送到计费客户端\n\tt.ProcessParamsSendMeasure()\n\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_rec_task.go",
        "code_start_line": 48,
        "code_end_line": 61,
        "code_key": "Execute",
        "code_value": "func (t *SnapMeasureReconciliationTask) Execute(ctx context.Context) (bool, error) {\n\t// 初始化各项配置\n\tt.ctx = ctx\n\tt.initTask()\n\n\t// 将数据推送到数据库\n\tvar wg sync.WaitGroup\n\tgo t.sendDbFromMsg(&wg)\n\n\t// 执行ACK\n\tgo t.AckResourceID()\n\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/base_measure/base_appId_fetch_task.go",
        "code_start_line": 38,
        "code_end_line": 61,
        "code_key": "Execute",
        "code_value": "func (t *BaseAppIdFetchTask) Execute(ctx context.Context) (bool, error) {\n\tt.ctx = ctx\n\tt.initTask()\n\n\tappIds := t.resSrv.GetAppIdsWithValidResources(t.chargeTime)\n\tfor _, appId := range appIds {\n\t\tappIdItem := measure.AppIdInfo{\n\t\t\tAppId: appId,\n\t\t}\n\t\t// Send自带Confirm机制. error为nil表示发送成功\n\t\t// Send会阻塞等待Confirm，如果需要，可以考虑放协程里跑\n\t\terr := t.client.Send(ctx, measure.BuildRabbitRequest(&appIdItem))\n\t\tif err != nil {\n\t\t\tlogs.Error(ctx).Err(err).Msg(\"SEND_MESSAGE_FAILED\")\n\t\t\treturn false, err\n\t\t}\n\t\tlogs.Info(ctx).Interface(\"appId\", appId).Msg(\"SEND_MESSAGE_SUCCESS\")\n\t}\n\n\tstopChan := make(chan struct{})\n\t_ = t.server.Close(stopChan)\n\t<-stopChan\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/managers/shm.go",
        "code_start_line": 86,
        "code_end_line": 88,
        "code_key": "ListExpiredKeys",
        "code_value": "func (s *ShmCacheManager) ListExpiredKeys(ctx context.Context) []interface{} {\n\tpanic(\"implement me\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/subgroup.go",
        "code_start_line": 46,
        "code_end_line": 54,
        "code_key": "ListExpiredKeys",
        "code_value": "func (s *SubGroupCacheManager) ListExpiredKeys(ctx context.Context) []interface{} {\n\tvar expiredKeys []interface{}\n\tfor expireTime, keys := range s.cacheMap.GetExpireTimeMap() {\n\t\tif time.Now().Add(time.Duration(SafeReserveSeconds)*time.Second).Unix() >= expireTime {\n\t\t\texpiredKeys = append(expiredKeys, keys...)\n\t\t}\n\t}\n\treturn expiredKeys\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/filters/dmg.go",
        "code_start_line": 107,
        "code_end_line": 133,
        "code_key": "filterWithHostAff",
        "code_value": "func (r RdPlacementGroupFilter) filterWithHostAff(ctx context.Context, disks []*disk.Disk) []*disk.Disk {\n\t/**\n\t检查母机置放群组亲和性\n\t\t1. 检查单母机绑定的置放群组子组数量不会超过置放群组亲和度限制\n\t    2. 置放群组是强制性装箱规则，不满足置放群组的盘被舍弃掉\n\t*/\n\tif len(disks) == 0 {\n\t\treturn disks\n\t}\n\twg := &sync.WaitGroup{}\n\twg.Add(len(disks))\n\n\tfor _, oneDisk := range disks {\n\t\tgo r.checkHostAffWithSingleDisk(ctx, oneDisk, wg)\n\t}\n\twg.Wait()\n\n\t// 对置放群组亲和性检查的盘进行过滤,打标分数小于0的过滤掉\n\tdiskSlice := make([]*disk.Disk, 0, 100000)\n\tfor _, oneDisk := range disks {\n\t\tif oneDisk.Score >= 0 {\n\t\t\tdiskSlice = append(diskSlice, oneDisk)\n\t\t}\n\t}\n\treturn diskSlice\n\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/tracker.go",
        "code_start_line": 67,
        "code_end_line": 77,
        "code_key": "Refresh",
        "code_value": "func (rdp *PhyDiskTracker) Refresh(ctx context.Context) {\n\trdp.Track(ctx)\n\tlock.RDPhyCacheGlobalLock.GetLocker(lock.RDPhyLockKeyGenerator{}).Lock()\n\trdp.Merge(ctx, rdp.OriPhyDisks)\n\tlogs.Info(ctx).\n\t\tInt(\"disk_num\", len(rdp.ToCachedPhyDisks)).\n\t\tInt(\"member_num\", len(rdp.DrgroupMembers)).\n\t\tMsg(\"CACHE_AVAILABLE_PHY_DISK_AFTER_MERGE\")\n\trdp.CacheManager.RefreshCache(ctx, rdp.ToCachedPhyDisks, rdp.DrgroupMembers)\n\tlock.RDPhyCacheGlobalLock.GetLocker(lock.RDPhyLockKeyGenerator{}).Unlock()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/set/cache/tracker.go",
        "code_start_line": 35,
        "code_end_line": 38,
        "code_key": "Refresh",
        "code_value": "func (d *DiskSetTracker) Refresh(ctx context.Context) {\n\td.Track(ctx)\n\td.CacheManager.RefreshCache(ctx, d.DiskSetEntityInf)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 644,
        "code_end_line": 674,
        "code_key": "Refresh",
        "code_value": "func (l *mysqlLock) Refresh(ctx context.Context, ttl time.Duration) error {\n\n\ttx := l.locker.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\n\n\tkeysKey := dlock.LockKeySlice(l.keys).GetKeys()\n\t// NOCA:QCloudAkCheck(误报)\n\texistingLocks, err := l.locker.fetchExistingLocksByKeysAndTokens(tx, keysKey, l.tokens)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn err\n\t}\n\n\t// Compare existing locks with the keys.\n\tif !checkStrSetEqual(existingLocks, keysKey) {\n\t\t_ = tx.Rollback()\n\t\treturn errors.Wrap(dlock.ErrLockNotHeld, \"lock is not held\")\n\t}\n\n\t// Update the expiration time.\n\tif err := l.locker.updateLocksTTLByKeysAndTokens(tx, keysKey, l.tokens, ttl); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn err\n\t}\n\n\tif result := tx.Commit(); result.Error != nil {\n\t\treturn errors.Wrap(result.Error, \"failed to commit refresh locks\")\n\t}\n\n\tl.expiration = time.Now().Add(ttl)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mem/memdlock.go",
        "code_start_line": 189,
        "code_end_line": 210,
        "code_key": "Refresh",
        "code_value": "func (l *memLock) Refresh(ctx context.Context, ttl time.Duration) error {\n\tl.locker.mutex.Lock()\n\tdefer l.locker.mutex.Unlock()\n\n\ttokens := make(map[string]struct{}, len(l.tokens))\n\tfor _, item := range l.tokens {\n\t\ttokens[item] = struct{}{}\n\t}\n\tfor _, key := range l.keys {\n\t\tif item, ok := l.locker.data[key.Key]; ok {\n\t\t\tif _, exist := tokens[item.token]; !exist {\n\t\t\t\treturn dlock.ErrLockNotHeld\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, key := range l.keys {\n\t\tl.locker.data[key.Key].ttl = time.Now().Add(ttl)\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go",
        "code_start_line": 51,
        "code_end_line": 72,
        "code_key": "Handle",
        "code_value": "func (c *CbsAppIdConsumer) Handle(ctx context.Context, delivery *rabbitmq.Delivery) error {\n\tu, chargeTime, err := c.ParseDelivery(ctx, delivery)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif u == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"USER_INFO_NOT_FOUND\")\n\t\treturn nil\n\t}\n\n\tchargeDetail := c.GetChargeDetailForSingleUser(u, chargeTime)\n\tif chargeDetail == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tUint64(\"appId\", uint64(u.AppId)).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"NO_RESOURCE_TO_CHARGE\")\n\t\treturn nil\n\t}\n\treturn c.ProcessChargeDetail(chargeDetail)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 105,
        "code_end_line": 116,
        "code_key": "Handle",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tif err := c.ensureLocks(ctx); err != nil {\n\t\treturn err\n\t}\n\tif c.lvUUID != nil {\n\t\t// 涉及到逻辑卷时，需要先标记逻辑卷为故障\n\t\treturn c.handleBindedVolume(ctx)\n\t} else {\n\t\t// 不涉及到逻辑卷时，直接标记物理卷为故障\n\t\treturn c.handleIdleVolume(ctx)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/detach_logical_volume.go",
        "code_start_line": 56,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *DetachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDetachLogicalVolume, c)\n\n\t// 如果没有挂载到指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume not attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_benchmark_task.go",
        "code_start_line": 125,
        "code_end_line": 165,
        "code_key": "Handle",
        "code_value": "func (c *CreateBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tvolSm     = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = volSm.Fire(ctx, c.relatedVolume.State, domain.PVEStartBenchmark, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark = benchmark.New(benchmark.DiskInfo{\n\t\tSerial: string(c.relatedVolume.Serial),\n\t\tHostIP: c.relatedVolume.IP,\n\t\tBDF:    string(c.relatedVolume.BDF),\n\t})\n\n\tif err = benchRepo.Add(ctx, c.relatedBenchmark); err != nil {\n\t\tdelegate := &benchmarkDelegate{cmd: c}\n\t\tif _err := delegate.TaskFinishCallback(ctx, c.relatedBenchmark); _err != nil {\n\t\t\tlogs.Warn(ctx).Err(_err).Str(\"serial\", string(c.relatedVolume.Serial)).Msg(\"failed to rollback: create bdev\")\n\t\t}\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventCreateBench,\n\t\tbenchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_logical_volume.go",
        "code_start_line": 71,
        "code_end_line": 108,
        "code_key": "Handle",
        "code_value": "func (d *DeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\td.volume, err = repo.FindByID(ctx, d.UUID)\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif e := d.volume.CheckDelete(); e != nil {\n\t\treturn e\n\t}\n\n\tif d.volume.AppID != d.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"refuse to delet: app id mismatch\")\n\t}\n\n\td.drgroup, err = app.GetRegistry(ctx).Repositories.DRGroup.FindByMember(ctx, d.AppID, d.volume.UUID.String())\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\td.drgroup = nil\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := d.checkDRGroupMatch(ctx); err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, d.volume.State, rdiskDomain.LVEMarkToRecycle, d)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_recycled_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmRecycledPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEConfirmRecycled, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_rdisk_backup.go",
        "code_start_line": 52,
        "code_end_line": 75,
        "code_key": "Handle",
        "code_value": "func (c *DeleteRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tsm   = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\tc.relatedBackup, err = repo.FindByUUID(ctx, c.BackupID.String())\n\tif err != nil || c.relatedBackup == nil || c.relatedBackup.AppID != c.AppID {\n\t\treturn errors.New(backupDomain.ErrBackupNotExist, \"backup not exists\")\n\t}\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tc.relatedBackup.Status,\n\t\tbackupDomain.EventSoftDeleteBackup,\n\t\tbackupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: c.relatedBackup})\n\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_rdisk_backup.go",
        "code_start_line": 47,
        "code_end_line": 80,
        "code_key": "Handle",
        "code_value": "func (c *CreateRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tlvSm  = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\tbakSm = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo  = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t_, err = lvSm.Fire(ctx, c.relatedVolume.State, rdiskDomain.LVEBackupStarted, c)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tlv := c.relatedVolume\n\tbackup := backupDomain.New(\n\t\tlv.AppID,\n\t\tbackupDomain.DiskInfo{\n\t\t\tVolumeUUID: lv.UUID,\n\t\t\tVolumeSize: uint64(lv.Size),\n\t\t\tHostIP:     lv.PhysicalVolume.IP,\n\t\t\tHostBDF:    string(lv.PhysicalVolume.BDF),\n\t\t\tSerial:     string(lv.PhysicalVolume.Serial),\n\t\t},\n\t)\n\tif err := repo.Add(ctx, backup); err != nil {\n\t\treturn err\n\t}\n\tc.relatedBackup = backup\n\t_, err = bakSm.Fire(ctx, backupDomain.StatusInit, backupDomain.EventStartBackup, backupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: backup})\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/attach_logical_volume.go",
        "code_start_line": 49,
        "code_end_line": 71,
        "code_key": "Handle",
        "code_value": "func (c *AttachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEAttachLogicalVolume, c)\n\n\t// 如果已经挂载到了指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeAlreadyAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume already attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_delete_logical_volume.go",
        "code_start_line": 34,
        "code_end_line": 55,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\t// 如果逻辑卷不存在，则直接返回成功\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"failed to confirm delete: app id mismatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDeleteLogicalVolume, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/offline_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OfflinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOfflinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *DeletePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\t// 如果物理卷不存在，则直接幂等返回\n\t\treturn nil\n\t}\n\n\tvar event = domain.PVEDeletePhysicalVolume\n\tif c.Force && (c.relatedVolume.State == domain.PVSDefunct) {\n\t\t// 这里的实现不太好，状态机的逻辑不应该侵入 cmd\n\t\t// 时间太赶了，后续重构优化吧\n\t\tevent = domain.PVEForceDeleteForDefunct\n\t}\n\n\tif c.relatedVolume.HasBindedPV() {\n\t\treturn errors.New(domain.ErrVolumeBusy, \"logic volume has binded to this physical volume\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, event, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_logical_volume.go",
        "code_start_line": 55,
        "code_end_line": 70,
        "code_key": "Handle",
        "code_value": "func (c *CleanupLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVECleanupLogicalVolume, c)\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_init_physical_volume.go",
        "code_start_line": 26,
        "code_end_line": 52,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmInitPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\tif c.relatedVolume.IP.String() != c.Host.String() {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume host ip mistmatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVECreatePhysicalVolumeOnHost, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_physical_volume.go",
        "code_start_line": 51,
        "code_end_line": 101,
        "code_key": "Handle",
        "code_value": "func (c *CreatePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\n\t// 获取物理卷状态机\n\tsm := app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\trepo := app.GetRegistry(ctx).Repositories.PhysicalVolume\n\n\t// 检查物理卷是否已经存在，如果存在则直接幂等返回\n\tvol1, err := repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"serial\", c.Serial).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tvol2, err := repo.FindByIPAndBDF(ctx, c.Host, domain.BDF(c.BDF))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"host\", c.Host.String()).Str(\"bdf\", c.BDF).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tfor _, vol := range []*domain.PhysicalVolume{vol1, vol2} {\n\t\texisted, err := c.checkExisting(ctx, vol)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif existed {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// 触发事件，创建物理卷\n\t_, err = sm.Fire(ctx,\n\t\tdomain.PVSUnInited,\n\t\tdomain.PVECreatePhysicalVolume,\n\t\tc,\n\t)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 创建 Bdev 以及格式化移动到创建物理卷的状态机中\n\n\t// _, err = sm.Fire(ctx,\n\t// \tc.GetPhysicalVolume().State,\n\t// \tdomain.PVECreatePhysicalVolumeOnHost,\n\t// \tc,\n\t// )\n\t// if err != nil {\n\t// \treturn err\n\t// }\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_benchmark_task.go",
        "code_start_line": 32,
        "code_end_line": 57,
        "code_key": "Handle",
        "code_value": "func (c *DeleteBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\terr       error\n\t)\n\n\tbench, err := benchRepo.FindByUUID(ctx, c.BenchmarkUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif bench.DiskInfo.Serial != c.Serial {\n\t\treturn errors.Newf(benchmark.ErrTaskNotFound, \"benchmark serial not match %s, want %s\", c.Serial, bench.DiskInfo.Serial)\n\t}\n\n\t_, err = benchSm.Fire(ctx, bench.Status, benchmark.EventDeleteBench, benchmark.Data{Benchmark: bench, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := benchRepo.Delete(ctx, bench); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_logical_volume.go",
        "code_start_line": 52,
        "code_end_line": 98,
        "code_key": "Handle",
        "code_value": "func (c *CreateLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tpvRepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tlvRepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm     = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\t// 1. 查找底层物理卷\n\tc.selectedPhysicalVolume, err = pvRepo.FindBySerial(ctx, rdiskDomain.Serial(c.PhysicalVolumeSerial))\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// 检查底层物理卷大小是否满足要求\n\tif c.selectedPhysicalVolume.Size < rdiskDomain.Size(c.DiskSize) {\n\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume size %d is smaller than requested size %d\", c.selectedPhysicalVolume.Size, c.DiskSize)\n\t}\n\n\t// 检查底层物理卷性能等级是否满足要求\n\tif c.PerformanceRank != \"\" {\n\t\tif string(c.selectedPhysicalVolume.PerformanceRank) != c.PerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not match requested rank %s\", c.selectedPhysicalVolume.PerformanceRank, c.PerformanceRank)\n\t\t}\n\t} else {\n\t\tif c.selectedPhysicalVolume.PerformanceRank != rdiskDomain.DefaultPerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not default rank %s\", c.selectedPhysicalVolume.PerformanceRank, rdiskDomain.DefaultPerformanceRank)\n\t\t}\n\t}\n\n\t// 2. 创建逻辑卷\n\tvol := rdiskDomain.NewLogicalVolume(users.AppID(c.AppID), rdiskDomain.Size(c.DiskSize), rdiskDomain.ZoneID(c.ZoneID))\n\tif c.VolumeType != \"\" {\n\t\tvol.VolumeType = rdiskDomain.VolumeType(c.VolumeType)\n\t}\n\tif c.DiskType != \"\" {\n\t\tvol.DiskType = rdiskDomain.DiskType(c.DiskType)\n\t}\n\terr = lvRepo.Add(ctx, vol)\n\tif err != nil {\n\t\treturn\n\t}\n\tc.createdLogicalVolume = vol\n\n\t// 3. 触发状态机，联动更新逻辑卷和物理卷状态\n\t_, err = sm.Fire(ctx, rdiskDomain.LVSUnInited, rdiskDomain.LVECreateLogicalVolume, c)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_running_backup_task.go",
        "code_start_line": 31,
        "code_end_line": 61,
        "code_key": "Handle",
        "code_value": "func (c *UpdateRunningBackupTaskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventUpdateBackupProgress,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_drgroup.go",
        "code_start_line": 78,
        "code_end_line": 173,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeDRGroupCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tlvView  = app.GetRegistry(ctx).Viewers.LogicalVolume\n\t\tdrgRepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t\tsm      = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\terr     error\n\t)\n\n\t// 0. 初始化\n\tc.drgroupRef = make(map[string]*drgroup.DRGroup)\n\n\t// 1. 加载所有逻辑卷所在的置放群组\n\tallVolumeUUIDs := make([]string, 0, len(c.UUIDs))\n\tfor _, _uuid := range c.UUIDs {\n\t\tallVolumeUUIDs = append(allVolumeUUIDs, _uuid.String())\n\t}\n\tif groups, err := drgRepo.FindByMembers(ctx, c.AppID, allVolumeUUIDs); err == nil {\n\t\tif err != nil {\n\t\t\tif !errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tfor _, group := range groups {\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t\tc.curDRGroupNames = append(c.curDRGroupNames, group.Name)\n\t\t}\n\t} else {\n\t\treturn err\n\t}\n\n\t// 2. 确认已上锁的置放群组和当前一致\n\tif !c.checkLockedDRGroupNames() {\n\t\treturn errors.New(drgroup.ErrGroupModified, \"drgroup changed\")\n\t}\n\n\t// 3. 加载所有逻辑卷的状态，不需要完整实体，因为不会修改 Volume\n\tc.relatedLogicalVolume, err = lvView.FindByIDs(ctx, c.AppID, c.UUIDs)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(c.relatedLogicalVolume) < len(c.UUIDs) {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t// 4. 加载所有目标置放群组，key 为 name\n\tfor _, spec := range c.Specs {\n\t\tvar group *drgroup.DRGroup\n\t\tif _, ok := c.drgroupRef[spec.Name]; ok {\n\t\t\tgroup = c.drgroupRef[spec.Name]\n\t\t} else {\n\t\t\tgroup, err = c.getOrCreateDRGroup(ctx, drgRepo, spec)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t}\n\n\t\tif spec.Affinity > 0 {\n\t\t\tgroup.Affinity = spec.Affinity\n\t\t}\n\t\tif spec.Type != \"\" {\n\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t}\n\t}\n\n\t// 5. 对所有逻辑卷执行置放群组变更事件，检查状态是否允许，\n\t//    实际的更新还是在这里执行。\n\tfor _, vol := range c.relatedLogicalVolume {\n\t\terr := sm.Check(ctx, vol.State, rdiskDomain.LVEUpdateDrGroup, c)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// 将逻辑卷从原有的置放群组中移除\n\t\tfor _, name := range c.curDRGroupNames {\n\t\t\tc.drgroupRef[name].RemoveMember(vol.UUID.String())\n\t\t}\n\t\t// 将逻辑卷添加到新的置放群组中\n\t\tfor _, spec := range c.Specs {\n\t\t\tsubGroup := spec.SubGroup\n\t\t\tif subGroup == \"\" {\n\t\t\t\t// 如果没有指定子组，则使用远端 SSD UUID 作为子组名称\n\t\t\t\t// 相当于每块盘都是一个子组，相当于没有使用子组功能\n\t\t\t\tsubGroup = vol.UUID.String()\n\t\t\t}\n\t\t\tif err := c.drgroupRef[spec.Name].AddMember(vol.UUID.String(), subGroup, vol.PhysicalVolume.IP.String()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tif c.DryRun {\n\t\treturn errors.New(errors.ErrDryRunSuccessExit, \"dry run check success\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/online_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OnlinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOnlinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_benchmark_task.go",
        "code_start_line": 34,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *UpdateBenchmarkTask) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, rdisk.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark, err = benchRepo.FindByUUID(ctx, c.BenchmarkUUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventUpdateBench, benchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_flow_ctrl.go",
        "code_start_line": 80,
        "code_end_line": 103,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeFlowControlCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not found\")\n\t}\n\n\tspec := c.volume.FlowControlSpec\n\tif !c.UpdateRequest.UpdateSpec(&spec, c.volume.GetDefaultFlowControlSpec()) {\n\t\t// 没有任何更新，直接返回成功\n\t\treturn nil\n\t}\n\tc.volume.SetFlowControlSpec(spec)\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEUpdateFlowControl, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_defunct_volume.go",
        "code_start_line": 46,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *CleanupDefunctCommand) Handle(ctx context.Context) error {\n\tvar err error\n\tc.lv, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar sm = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\tvar event = rdiskDomain.LVECleanupDefunct\n\n\tfor _, attachment := range c.lv.Attachments {\n\t\tlogs.Info(ctx).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).Msg(\"cleanup defuncting volume\")\n\t\tsubCmd := &cleanDefunctSubCommand{Parent: c, HostIP: attachment.IP}\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, subCmd)\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，因为只要有一个挂载点清理失败，其他挂载点还是需要继续清理的\n\t\t\t// 失败的挂载点会在后台继续清理\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).\n\t\t\t\tMsg(\"failed to cleanup defunct volume, retry later.\")\n\t\t}\n\t}\n\n\tif len(c.lv.Attachments) == 0 {\n\t\t// 没有挂载点，直接清理\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, &cleanDefunctSubCommand{Parent: c, HostIP: net.IP{}})\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，后续自动重试即可\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Msg(\"failed to complete cleanup defunct volume\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_drgroup_exists.go",
        "code_start_line": 28,
        "code_end_line": 53,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDRGroupExistsCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t)\n\tfor _, spec := range c.DRGroup {\n\t\t_, err := repo.FindByName(ctx, users.AppID(c.AppID), spec.Name)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\tgroup := drgroup.New(spec.Name, users.AppID(c.AppID))\n\t\t\t\tif spec.Affinity > 0 {\n\t\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t\t}\n\t\t\t\tif spec.Type != \"\" {\n\t\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t\t}\n\t\t\t\terr = repo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_physical_volume.go",
        "code_start_line": 31,
        "code_end_line": 54,
        "code_key": "Handle",
        "code_value": "func (c *UpdatePhyRDiskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEUpdatePhysicalVolume, c)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/recycle_backup_data.go",
        "code_start_line": 32,
        "code_end_line": 62,
        "code_key": "Handle",
        "code_value": "func (c *RecycleBackupDataCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventDeleteBackup,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go",
        "code_start_line": 74,
        "code_end_line": 102,
        "code_key": "ProcessChargeDetail",
        "code_value": "func (c *CbsAppIdConsumer) ProcessChargeDetail(detail *ChargeDetail) error {\n\tcbsSrv := c.ResSrv.(*measure.CbsSrv)\n\t// 不同用户的资源数是不一致的，这里顺序处理的话性能一般，需要放在协程中跑\n\t// 单个用户最多启动100个协程，避免协程过多\n\tvar wg sync.WaitGroup\n\tfor _, cbsInstanceId := range detail.ResIds {\n\t\twg.Add(1)\n\t\tgo func(cbsInstanceId measure.ResourceId) {\n\t\t\tdefer wg.Done()\n\t\t\t// 并发的控制策略: 同时处理的用户不超过t.Concurrency个，所有用户共享t.Concurrency * 100个协程\n\t\t\t// 这样设计的目的是为了规避用户资源倾斜严重的问题，同时也能保证用户的并发度较少\n\t\t\tc.ResSemaphore <- struct{}{}\n\t\t\tdefer func() {\n\t\t\t\t<-c.ResSemaphore\n\t\t\t}()\n\n\t\t\tlogs.Info(c.Ctx).\n\t\t\t\tUint64(\"appId\", uint64(detail.User.AppId)).\n\t\t\t\tStr(\"cbsInstanceId\", string(cbsInstanceId)).\n\t\t\t\tMsg(\"PROCESS_SIGNAL_DISK\")\n\n\t\t\tchargeItem := cbsSrv.BuildResChargeItem(detail.User, cbsInstanceId, detail.ChargeTime)\n\t\t\t// 单个资源失败就等下一轮，先忽略err\n\t\t\t_ = c.ProcessSingleChargeItem(detail.User, cbsInstanceId, chargeItem)\n\t\t}(cbsInstanceId)\n\t}\n\twg.Wait()\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/service.go",
        "code_start_line": 208,
        "code_end_line": 217,
        "code_key": "BuildResChargeItem",
        "code_value": "func (cbsSrv *CbsSrv) BuildResChargeItem(u *user.User, resourceId ResourceId, chargeTime time.Time) *ChargeItem {\n\tcbsMeasureRepo := cbsSrv.balanceRepo.(repositories.CbsBalanceRepoIFace)\n\tbalanceRecords, _ := cbsMeasureRepo.GetCbsBalanceRecords(cbsSrv.ctx, string(resourceId), chargeTime, false)\n\n\tif len(balanceRecords) == 0 {\n\t\treturn nil\n\t}\n\n\treturn cbsSrv.convertToChargeItem(u, resourceId, balanceRecords, chargeTime)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 133,
        "code_end_line": 236,
        "code_key": "BuildResChargeItem",
        "code_value": "func (snapSrv *SnapSrv) BuildResChargeItem(u *user.User, resourceId ResourceId, chargeTime time.Time) *ChargeItem {\n\t// 获取符合条件的balanceRecord并根据chargeTime排序\n\tbalanceRecords, _ := snapSrv.snapRepo.GetSnapBalanceRecords(snapSrv.ctx, string(resourceId), chargeTime)\n\n\t// FIXME 临时方案：用内存里的lastBalanceTime覆盖balanceRecords里的balanceTime\n\tfor _, balanceRecord := range balanceRecords {\n\t\tlastBalanceTime, ok := snapSrv.lastBalanceTimeCache[balanceRecord.ID]\n\t\tif ok {\n\t\t\tbalanceRecord.LastBalanceTime = lastBalanceTime\n\t\t}\n\t}\n\n\tif len(balanceRecords) == 0 {\n\t\treturn nil\n\t}\n\tsort.Slice(balanceRecords, func(i, j int) bool {\n\t\tif balanceRecords[i].LastBalanceTime.Equal(balanceRecords[j].LastBalanceTime) {\n\t\t\treturn balanceRecords[i].OperationType < balanceRecords[j].OperationType\n\t\t}\n\t\treturn balanceRecords[i].LastBalanceTime.Before(balanceRecords[j].LastBalanceTime)\n\t})\n\n\t// 区分国内站和国际站用户\n\tvar userArea Area\n\tif u.IsI18nUser() {\n\t\tuserArea = AreaI18n\n\t} else {\n\t\tuserArea = AreaChina\n\t}\n\tisGrayUser, err := u.CheckFeature(user.USER_FLAG_SNAP_GRAY_USER)\n\tif err != nil {\n\t\tlogs.Error(snapSrv.ctx).Err(err).Int64(\"appId\", int64(u.AppId)).Msg(\"CHECK_GRAY_USER_ERR\")\n\t\t// 出错时标记为非灰度用户，避免重复推量\n\t\tisGrayUser = false\n\t}\n\n\tchargeItem := &ChargeItem{\n\t\t// FIXME: 需要从配置文件中获取region id\n\t\tRegionId:     snapSrv.regionId,\n\t\tZoneId:       balanceRecords[0].ZoneID,\n\t\tAppId:        u.AppId,\n\t\tUin:          u.Uin,\n\t\tUserArea:     userArea,\n\t\tIsGrayUser:   isGrayUser,\n\t\tResourceId:   resourceId,\n\t\tResourceArea: snapSrv.regionArea,\n\t\tItems:        make([]*SubItem, 0, len(balanceRecords)),\n\t}\n\n\t// 虚拟计费条目，用于确定endBalanceTime\n\tendBalanceRecord := &ccdb.CSnapBalance{LastBalanceTime: chargeTime.Add(time.Second * -1)}\n\tallBalances := append(balanceRecords, endBalanceRecord)\n\n\tfor i, balanceRecord := range allBalances[1:] {\n\t\tbeginBalanceRecord := balanceRecords[i]\n\t\t// 资源欠费，不收取费用\n\t\tif beginBalanceRecord.OperationType == int(SnapOpArrearage) {\n\t\t\tlogs.Info(snapSrv.ctx).Uint64(\"appId\", uint64(u.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"RESOURCE_ARREARAGE\")\n\t\t\tcontinue\n\t\t}\n\t\t// 资源已退还。退还后还产生了计费条目，非期望行为\n\t\tif beginBalanceRecord.OperationType == int(SnapOpReturn) {\n\t\t\tlogs.Info(snapSrv.ctx).Uint64(\"appId\", uint64(u.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"SNAP_HAS_RETURNED\")\n\t\t\tbreak\n\t\t}\n\n\t\t// 资源正常\n\t\tstartTime := beginBalanceRecord.LastBalanceTime\n\t\tendTime := balanceRecord.LastBalanceTime\n\t\tcurTime := startTime\n\t\tfor endTime.After(curTime) {\n\t\t\tcurHourEnd := time.Date(curTime.Year(), curTime.Month(), curTime.Day(), curTime.Hour(), 59, 59, 0, curTime.Location())\n\t\t\tif !endTime.After(curHourEnd) {\n\t\t\t\t// 同一周期\n\t\t\t\tsubItem := &SubItem{\n\t\t\t\t\tPid:       PidSnap,\n\t\t\t\t\tStartTime: curTime,\n\t\t\t\t\tEndTime:   endTime,\n\t\t\t\t\tSubValueDetail: map[string]interface{}{\n\t\t\t\t\t\t\"Size\": beginBalanceRecord.SnapSize},\n\t\t\t\t}\n\t\t\t\tchargeItem.Items = append(chargeItem.Items, subItem)\n\t\t\t\tcurTime = endTime.Add(time.Second)\n\t\t\t} else {\n\t\t\t\t// 非同一周期，先构建这个周期的\n\t\t\t\tsubItem := &SubItem{\n\t\t\t\t\tStartTime: curTime,\n\t\t\t\t\tEndTime:   curHourEnd,\n\t\t\t\t\tSubValueDetail: map[string]interface{}{\n\t\t\t\t\t\t\"Size\": beginBalanceRecord.SnapSize,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\tchargeItem.Items = append(chargeItem.Items, subItem)\n\t\t\t\tcurTime = curHourEnd.Add(time.Second)\n\t\t\t}\n\n\t\t}\n\t}\n\tif len(chargeItem.Items) == 0 {\n\t\treturn nil\n\t}\n\n\treturn chargeItem\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 247,
        "code_end_line": 264,
        "code_key": "BuildResChargeItem",
        "code_value": "func (cbsSrv *CbsSrv) BuildResChargeItem(u *user.User, resourceId ResourceId, chargeTime time.Time) *ChargeItem {\n\tcbsMeasureRepo := cbsSrv.measureRepo.(CbsMeasureRepoIFace)\n\tbalanceRecords, _ := cbsMeasureRepo.GetCbsBalanceRecords(cbsSrv.ctx, string(resourceId), chargeTime, false)\n\n\t// FIXME 临时方案：用内存里的lastBalanceTime覆盖balanceRecords里的balanceTime\n\tfor _, balanceRecord := range balanceRecords {\n\t\tlastBalanceTime, ok := cbsSrv.lastBalanceTimeCache[balanceRecord.ID]\n\t\tif ok {\n\t\t\tbalanceRecord.LastBalanceTime = lastBalanceTime\n\t\t}\n\t}\n\n\tif len(balanceRecords) == 0 {\n\t\treturn nil\n\t}\n\n\treturn cbsSrv.convertToChargeItem(u, resourceId, balanceRecords, chargeTime)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/service.go",
        "code_start_line": 294,
        "code_end_line": 367,
        "code_key": "convertToChargeItem",
        "code_value": "func (cbsSrv *CbsSrv) convertToChargeItem(u *user.User, resourceId ResourceId, balanceRecords []*ccdb.CCbsBalance, chargeTime time.Time) *ChargeItem {\n\tsort.Slice(balanceRecords, func(i, j int) bool {\n\t\tif balanceRecords[i].LastBalanceTime.Equal(balanceRecords[j].LastBalanceTime) {\n\t\t\treturn balanceRecords[i].OperationType < balanceRecords[j].OperationType\n\t\t}\n\t\treturn balanceRecords[i].LastBalanceTime.Before(balanceRecords[j].LastBalanceTime)\n\t})\n\n\t// 区分国内站和国际站用户\n\tvar userArea Area\n\tif u.IsI18nUser() {\n\t\tuserArea = AreaI18n\n\t} else {\n\t\tuserArea = AreaChina\n\t}\n\tisGrayUser, err := u.CheckFeature(user.USER_FLAG_CBS_GRAY_USER)\n\tif err != nil {\n\t\tlogs.Error(cbsSrv.ctx).Err(err).Int64(\"appId\", int64(u.AppId)).Msg(\"CHECK_GRAY_USER_ERR\")\n\t\t// 出错时标记为非灰度用户，避免重复推量\n\t\tisGrayUser = false\n\t}\n\n\tchargeItem := &ChargeItem{\n\t\t// FIXME: 需要从配置文件中获取region id\n\t\tRegionId:     cbsSrv.regionId,\n\t\tZoneId:       balanceRecords[0].ZoneID,\n\t\tAppId:        u.AppId,\n\t\tUin:          u.Uin,\n\t\tUserArea:     userArea,\n\t\tIsGrayUser:   isGrayUser,\n\t\tResourceId:   resourceId,\n\t\tResourceArea: cbsSrv.regionArea,\n\t\tItems:        make([]*SubItem, 0, len(balanceRecords)),\n\t\tUpdateKVs:    make([]*UpdateKV, 0, len(balanceRecords)),\n\t}\n\n\t// 虚拟计费条目，用于确定endBalanceTime\n\tendBalanceRecord := &ccdb.CCbsBalance{LastBalanceTime: chargeTime.Add(time.Second * -1)}\n\tallBalances := append(balanceRecords, endBalanceRecord)\n\n\t// 获取云盘信息\n\tfor i, balanceRecord := range allBalances[1:] {\n\t\tbeginBalanceRecord := balanceRecords[i]\n\t\t// 用于组装单个BalanceRecord的subitem\n\t\tstopCharge := cbsSrv.processSingleBalanceRecords(\n\t\t\tchargeItem, beginBalanceRecord, balanceRecord, u, resourceId)\n\t\tif stopCharge {\n\t\t\t// TODO 停止计费。如果后续产生预期外的计费条目，状态也应该置为无效\n\t\t\t// 现在先不处理，避免因bug导致少收费\n\t\t\tbreak\n\t\t}\n\n\t\t// 灰度阶段使用\n\t\tif isGrayUser {\n\t\t\t// 更新balanceRecord\n\t\t\tupdateKV := &UpdateKV{\n\t\t\t\tId:              beginBalanceRecord.ID,\n\t\t\t\tLastBalanceTime: chargeTime,\n\t\t\t\tStatus:          beginBalanceRecord.Status,\n\t\t\t}\n\t\t\tif i != len(balanceRecords)-1 ||\n\t\t\t\t(beginBalanceRecord.OperationType == int(CbsOpReturn) || beginBalanceRecord.OperationType == int(CbsOpConvert)) {\n\t\t\t\tbeginBalanceRecord.Status = 0\n\t\t\t}\n\t\t\tchargeItem.UpdateKVs = append(chargeItem.UpdateKVs, updateKV)\n\t\t}\n\n\t}\n\tif len(chargeItem.Items) == 0 && len(chargeItem.UpdateKVs) == 0 {\n\t\treturn nil\n\t}\n\n\treturn chargeItem\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 341,
        "code_end_line": 414,
        "code_key": "convertToChargeItem",
        "code_value": "func (cbsSrv *CbsSrv) convertToChargeItem(u *user.User, resourceId ResourceId, balanceRecords []*ccdb.CCbsBalance, chargeTime time.Time) *ChargeItem {\n\tsort.Slice(balanceRecords, func(i, j int) bool {\n\t\tif balanceRecords[i].LastBalanceTime.Equal(balanceRecords[j].LastBalanceTime) {\n\t\t\treturn balanceRecords[i].OperationType < balanceRecords[j].OperationType\n\t\t}\n\t\treturn balanceRecords[i].LastBalanceTime.Before(balanceRecords[j].LastBalanceTime)\n\t})\n\n\t// 区分国内站和国际站用户\n\tvar userArea Area\n\tif u.IsI18nUser() {\n\t\tuserArea = AreaI18n\n\t} else {\n\t\tuserArea = AreaChina\n\t}\n\tisGrayUser, err := u.CheckFeature(user.USER_FLAG_CBS_GRAY_USER)\n\tif err != nil {\n\t\tlogs.Error(cbsSrv.ctx).Err(err).Int64(\"appId\", int64(u.AppId)).Msg(\"CHECK_GRAY_USER_ERR\")\n\t\t// 出错时标记为非灰度用户，避免重复推量\n\t\tisGrayUser = false\n\t}\n\n\tchargeItem := &ChargeItem{\n\t\t// FIXME: 需要从配置文件中获取region id\n\t\tRegionId:     cbsSrv.regionId,\n\t\tZoneId:       balanceRecords[0].ZoneID,\n\t\tAppId:        u.AppId,\n\t\tUin:          u.Uin,\n\t\tUserArea:     userArea,\n\t\tIsGrayUser:   isGrayUser,\n\t\tResourceId:   resourceId,\n\t\tResourceArea: cbsSrv.regionArea,\n\t\tItems:        make([]*SubItem, 0, len(balanceRecords)),\n\t\tUpdateKVs:    make([]*UpdateKV, 0, len(balanceRecords)),\n\t}\n\n\t// 虚拟计费条目，用于确定endBalanceTime\n\tendBalanceRecord := &ccdb.CCbsBalance{LastBalanceTime: chargeTime.Add(time.Second * -1)}\n\tallBalances := append(balanceRecords, endBalanceRecord)\n\n\t// 获取云盘信息\n\tfor i, balanceRecord := range allBalances[1:] {\n\t\tbeginBalanceRecord := balanceRecords[i]\n\t\t// 用于组装单个BalanceRecord的subitem\n\t\tstopCharge := cbsSrv.processSingleBalanceRecords(\n\t\t\tchargeItem, beginBalanceRecord, balanceRecord, u, resourceId)\n\t\tif stopCharge {\n\t\t\t// TODO 停止计费。如果后续产生预期外的计费条目，状态也应该置为无效\n\t\t\t// 现在先不处理，避免因bug导致少收费\n\t\t\tbreak\n\t\t}\n\n\t\t// 灰度阶段使用\n\t\tif isGrayUser {\n\t\t\t// 更新balanceRecord\n\t\t\tupdateKV := &UpdateKV{\n\t\t\t\tId:              beginBalanceRecord.ID,\n\t\t\t\tLastBalanceTime: chargeTime,\n\t\t\t\tStatus:          beginBalanceRecord.Status,\n\t\t\t}\n\t\t\tif i != len(balanceRecords)-1 ||\n\t\t\t\t(beginBalanceRecord.OperationType == int(CbsOpReturn) || beginBalanceRecord.OperationType == int(CbsOpConvert)) {\n\t\t\t\tbeginBalanceRecord.Status = 0\n\t\t\t}\n\t\t\tchargeItem.UpdateKVs = append(chargeItem.UpdateKVs, updateKV)\n\t\t}\n\n\t}\n\tif len(chargeItem.Items) == 0 && len(chargeItem.UpdateKVs) == 0 {\n\t\treturn nil\n\t}\n\n\treturn chargeItem\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/service.go",
        "code_start_line": 369,
        "code_end_line": 434,
        "code_key": "processSingleBalanceRecords",
        "code_value": "func (cbsSrv *CbsSrv) processSingleBalanceRecords(chargeItem *ChargeItem, beginBalanceRecord *ccdb.CCbsBalance, endBalanceRecord *ccdb.CCbsBalance, user *user.User, resourceId ResourceId) (stopCharge bool) {\n\tstopCharge = false\n\t// 资源欠费，不收取费用\n\tif beginBalanceRecord.OperationType == int(CbsOpArrearage) {\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"RESOURCE_ARREARAGE\")\n\t\treturn\n\t}\n\t// 资源退还。判断是否为预付费的性能突发场景\n\tif beginBalanceRecord.OperationType == int(CbsOpReturn) || beginBalanceRecord.OperationType == int(CbsOpConvert) {\n\t\t// 判断是否为预付费的性能突发场景.\n\t\t// 获取云盘信息。这里在循环中进行查询，但命中的应该不会很多，放在外层反而会导致每个云盘都被查询\n\t\tdisk, err := cbsSrv.diskRepo.QueryDiskInfoById(cbsSrv.ctx, string(resourceId))\n\t\tif err != nil || disk == nil {\n\t\t\tlogs.Error(cbsSrv.ctx).Err(err).Str(\"resourceId\", string(resourceId)).Msg(\"QUERY_CBS_RECORD_FAILED\")\n\t\t\t// TODO 这里先不返回资源的推量？\n\t\t\treturn true\n\t\t}\n\t\t// TODO 走diskLogical\n\t\tif disk.PayMode == \"prepay\" {\n\t\t\t// 性能突发场景，预付费用户退盘，退盘费用不计\n\t\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"MAYBE_CBS_WITH_BURST_PERFORMANCE\")\n\t\t\treturn\n\t\t}\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"CBS_HAS_RETURNED\")\n\t\treturn true\n\t}\n\n\t// 资源正常\n\tstartTime := beginBalanceRecord.LastBalanceTime\n\tendTime := endBalanceRecord.LastBalanceTime\n\tcurTime := startTime\n\tfor endTime.After(curTime) {\n\t\tcurHourEnd := time.Date(curTime.Year(), curTime.Month(), curTime.Day(), curTime.Hour(), 59, 59, 0, curTime.Location())\n\n\t\tvar config CCbsBalanceConfig\n\t\terr := json.Unmarshal([]byte(beginBalanceRecord.Config), &config)\n\t\tif err != nil {\n\t\t\tlogs.Error(cbsSrv.ctx).Err(err).Msg(\"PARSE_CONFIG_ERROR\")\n\t\t\treturn\n\t\t}\n\n\t\tcurEndTime := endTime\n\t\tcurStarTime := curTime\n\t\tif !endTime.After(curHourEnd) {\n\t\t\t// 同一周期\n\t\t\tcurTime = endTime.Add(time.Second)\n\t\t} else {\n\t\t\tcurEndTime = curHourEnd\n\t\t\tcurTime = curHourEnd.Add(time.Second)\n\t\t}\n\t\tsubItem := &SubItem{\n\t\t\tPid:       beginBalanceRecord.Pid,\n\t\t\tStartTime: curStarTime,\n\t\t\tEndTime:   curEndTime,\n\t\t\tProjectId: beginBalanceRecord.ProjectID,\n\t\t\tParams:    beginBalanceRecord.ResourceInfo,\n\t\t\tSubValueDetail: map[string]interface{}{\n\t\t\t\t// FIXME 性能突发场景待实现\n\t\t\t\t\"Size\":             config.Size,\n\t\t\t\t\"BackupPointQuota\": config.BackupPointQuota,\n\t\t\t},\n\t\t}\n\t\tchargeItem.Items = append(chargeItem.Items, subItem)\n\t}\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 416,
        "code_end_line": 481,
        "code_key": "processSingleBalanceRecords",
        "code_value": "func (cbsSrv *CbsSrv) processSingleBalanceRecords(chargeItem *ChargeItem, beginBalanceRecord *ccdb.CCbsBalance, endBalanceRecord *ccdb.CCbsBalance, user *user.User, resourceId ResourceId) (stopCharge bool) {\n\tstopCharge = false\n\t// 资源欠费，不收取费用\n\tif beginBalanceRecord.OperationType == int(CbsOpArrearage) {\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"RESOURCE_ARREARAGE\")\n\t\treturn\n\t}\n\t// 资源退还。判断是否为预付费的性能突发场景\n\tif beginBalanceRecord.OperationType == int(CbsOpReturn) || beginBalanceRecord.OperationType == int(CbsOpConvert) {\n\t\t// 判断是否为预付费的性能突发场景.\n\t\t// 获取云盘信息。这里在循环中进行查询，但命中的应该不会很多，放在外层反而会导致每个云盘都被查询\n\t\tdisk, err := cbsSrv.diskRepo.QueryDiskInfoById(cbsSrv.ctx, string(resourceId))\n\t\tif err != nil || disk == nil {\n\t\t\tlogs.Error(cbsSrv.ctx).Err(err).Str(\"resourceId\", string(resourceId)).Msg(\"QUERY_CBS_RECORD_FAILED\")\n\t\t\t// TODO 这里先不返回资源的推量？\n\t\t\treturn true\n\t\t}\n\t\t// TODO 走diskLogical\n\t\tif disk.PayMode == \"prepay\" {\n\t\t\t// 性能突发场景，预付费用户退盘，退盘费用不计\n\t\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"MAYBE_CBS_WITH_BURST_PERFORMANCE\")\n\t\t\treturn\n\t\t}\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"CBS_HAS_RETURNED\")\n\t\treturn true\n\t}\n\n\t// 资源正常\n\tstartTime := beginBalanceRecord.LastBalanceTime\n\tendTime := endBalanceRecord.LastBalanceTime\n\tcurTime := startTime\n\tfor endTime.After(curTime) {\n\t\tcurHourEnd := time.Date(curTime.Year(), curTime.Month(), curTime.Day(), curTime.Hour(), 59, 59, 0, curTime.Location())\n\n\t\tvar config CCbsBalanceConfig\n\t\terr := json.Unmarshal([]byte(beginBalanceRecord.Config), &config)\n\t\tif err != nil {\n\t\t\tlogs.Error(cbsSrv.ctx).Err(err).Msg(\"PARSE_CONFIG_ERROR\")\n\t\t\treturn\n\t\t}\n\n\t\tcurEndTime := endTime\n\t\tcurStarTime := curTime\n\t\tif !endTime.After(curHourEnd) {\n\t\t\t// 同一周期\n\t\t\tcurTime = endTime.Add(time.Second)\n\t\t} else {\n\t\t\tcurEndTime = curHourEnd\n\t\t\tcurTime = curHourEnd.Add(time.Second)\n\t\t}\n\t\tsubItem := &SubItem{\n\t\t\tPid:       beginBalanceRecord.Pid,\n\t\t\tStartTime: curStarTime,\n\t\t\tEndTime:   curEndTime,\n\t\t\tProjectId: beginBalanceRecord.ProjectID,\n\t\t\tParams:    beginBalanceRecord.ResourceInfo,\n\t\t\tSubValueDetail: map[string]interface{}{\n\t\t\t\t// FIXME 性能突发场景待实现\n\t\t\t\t\"Size\":             config.Size,\n\t\t\t\t\"BackupPointQuota\": config.BackupPointQuota,\n\t\t\t},\n\t\t}\n\t\tchargeItem.Items = append(chargeItem.Items, subItem)\n\t}\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/convertor.go",
        "code_start_line": 28,
        "code_end_line": 38,
        "code_key": "Start",
        "code_value": "func (a *Convertor) Start(ctx context.Context) error {\n\t// 启动转换器\n\tfor _, scanner := range a.scanners {\n\t\tscanner := scanner\n\t\tgo func() {\n\t\t\ta.convertToTask(ctx, scanner)\n\t\t}()\n\t}\n\tlogs.Info(ctx).Msgf(\"Convertor Start Success\")\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_rec_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *CbsMeasureReconciliationTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\t//s.resultChan <- struct{}{}\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_rec_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 35,
        "code_key": "Start",
        "code_value": "func (s *SnapMeasureReconciliationTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_compute_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *SnapComputeTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\t//s.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_measure_send_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *CbsMeasureSendTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_bill_valid_appId_fetch_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *CbsValidAppIdFetchTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_calculate_cost_locally_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 36,
        "code_key": "Start",
        "code_value": "func (s *SnapCalculateCostLocallyTaskScanner) Start(ctx context.Context) error {\n\t//s.resultChan <- struct{}{}\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_create_task_scanner.go",
        "code_start_line": 23,
        "code_end_line": 42,
        "code_key": "Start",
        "code_value": "func (s *UpdateCreateTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\trunning := true\n\t\tfor running {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\trunning = false\n\t\t\tdefault:\n\t\t\t\terr := s.FullScan(ctx)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogs.Fatal(ctx).Msgf(\"%s full scan failed!\\n\", s.name)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\ttime.Sleep(s.scanInterval)\n\t\t}\n\t}()\n\tlogs.Info(ctx).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_measure_send_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 36,
        "code_key": "Start",
        "code_value": "func (s *SnapMeasureSendTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\t//s.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/repush_user_billing_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 39,
        "code_key": "Start",
        "code_value": "func (s *RepushUserBillingTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_rollback_task_scanner.go",
        "code_start_line": 23,
        "code_end_line": 42,
        "code_key": "Start",
        "code_value": "func (s *UpdateRollbackTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\trunning := true\n\t\tfor running {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\trunning = false\n\t\t\tdefault:\n\t\t\t\terr := s.FullScan(ctx)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogs.Fatal(ctx).Msgf(\"%s full scan failed!\\n\", s.name)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\ttime.Sleep(s.scanInterval)\n\t\t}\n\t}()\n\tlogs.Info(ctx).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_valid_appId_fetch_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 36,
        "code_key": "Start",
        "code_value": "func (s *SnapValidAppIdFetchTaskScanner) Start(ctx context.Context) error {\n\t//s.resultChan <- struct{}{}\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_bill_compute_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 39,
        "code_key": "Start",
        "code_value": "func (s *CbsBillComputeTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/app/app.go",
        "code_start_line": 31,
        "code_end_line": 39,
        "code_key": "Start",
        "code_value": "func (m *PipelineManager) Start(ctx context.Context) error {\n\tfor region, pipeline := range m.Pipelines {\n\t\tregionCtx := context.WithValue(ctx, \"region\", region)\n\t\tif err := pipeline.Start(regionCtx); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/app/app.go",
        "code_start_line": 46,
        "code_end_line": 51,
        "code_key": "Start",
        "code_value": "func (app *NebulaApp) Start(ctx context.Context) error {\n\tif err := app.pipelineManager.Start(ctx); err != nil {\n\t\treturn err\n\t}\n\treturn <-app.stopChan\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/app/pipeline.go",
        "code_start_line": 20,
        "code_end_line": 46,
        "code_key": "Start",
        "code_value": "func (p *RegionPipeline) Start(ctx context.Context) error {\n\tregion := ctx.Value(\"region\").(string)\n\tscannerLogCtx := initLogger(ctx, region, \"scanner.log\")\n\tfor _, scanner := range p.scanners {\n\t\tsingleCtx := logs.AddDefaultMessage(scannerLogCtx, \"name\", scanner.GetName())\n\t\terr := scanner.Start(singleCtx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tinitMetric(scanner, region, \"scanner\", scanner.GetName())\n\t}\n\n\tconvertorLogCtx := initLogger(ctx, region, \"convertor.log\")\n\terr := p.convertor.Start(convertorLogCtx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// start scheduler\n\tschedulerLogCtx := initLogger(ctx, region, \"scheduler.log\")\n\terr = p.scheduler.Start(schedulerLogCtx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tinitMetric(p.scheduler, region, \"scheduler\", \"scheduler\")\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go",
        "code_start_line": 109,
        "code_end_line": 112,
        "code_key": "Start",
        "code_value": "func (sc *Scheduler) Start(ctx context.Context) error {\n\tgo sc.mainLoop(ctx)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/scheduler.go",
        "code_start_line": 154,
        "code_end_line": 191,
        "code_key": "Start",
        "code_value": "func (s *scheduler) Start(ctx context.Context) error {\n\twg := sync.WaitGroup{}\n\trunning := true\n\tgo s.haManager.Start(ctx)\n\tdefer s.haManager.Close(ctx)\n\tfor {\n\t\tselect {\n\t\tcase taskName := <-s.eventChan:\n\t\t\twg.Add(1)\n\t\t\tgo func(name string) {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tif task, ok := s.loads[name]; ok {\n\n\t\t\t\t\tif s.isMaster {\n\t\t\t\t\t\t_ctx := logs.With(ctx).Str(\"seqId\", uuid.New().String()).Str(\"taskName\", name).Logger().WithContext(ctx)\n\t\t\t\t\t\ttask.Work(_ctx)\n\t\t\t\t\t}\n\n\t\t\t\t\ttriggerTime := time.Now().Add(task.Interval())\n\t\t\t\t\tfor {\n\t\t\t\t\t\tif !running {\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif time.Now().After(triggerTime) {\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttime.Sleep(time.Second)\n\t\t\t\t\t}\n\t\t\t\t\ts.eventChan <- name\n\t\t\t\t}\n\t\t\t}(taskName)\n\t\tcase <-s.stopChan:\n\t\t\trunning = false\n\t\t\twg.Wait()\n\t\t\treturn nil\n\t\t}\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/easyha/model.go",
        "code_start_line": 108,
        "code_end_line": 180,
        "code_key": "Start",
        "code_value": "func (m *haManagerImpl) Start(ctx context.Context) {\n\tm.keepRunning = true\n\tm.ctx = ctx\n\tvar (\n\t\tmyIdentity            = m.delegate.GetIdentity()                                    // 当前节点的业务标识\n\t\tmyKey                 = fmt.Sprintf(\"easyhaMaster/%s\", url.PathEscape(m.namespace)) // 分布式锁的key\n\t\tmyToken               = m.encodeToken(myIdentity)                                   // 分布式锁 Token，包含业务标识和随机信息\n\t\tmyLock                dlock.Lock                                                    // 获取到的分布式锁, 用于刷新和释放\n\t\tcurrentMasterIdentity string                                                        // 当前 master 的业务标识，如果为空则是还未获取过当前 master\n\t)\n\n\t// Start slave loop.\n\tfor m.keepRunning {\n\t\t// Try observe the master lock first.\n\t\tif view, err := m.locker.Observe(ctx, myKey); err != nil {\n\t\t\tm.logger.Info().Err(err).Str(\"key\", myKey).Msg(\"failed to observe current master lock\")\n\t\t\t// Failed to observe the master lock, try to  obtain the lock.\n\t\t\tmyLock, err = m.locker.Obtain(ctx, dlock.NewWriteLockKey(myKey), m.lockExpired, &dlock.Option{Token: myToken})\n\t\t\tif err == nil {\n\t\t\t\t// Successfully obtained the lock.\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tnewIdentity, err := m.decodeToken(view.Token)\n\t\t\tif err != nil {\n\t\t\t\tm.logger.Warn().Err(err).Str(\"token\", view.Token).Msg(\"failed to decode token\")\n\t\t\t} else if currentMasterIdentity == \"\" {\n\t\t\t\t// First time to observe the master.\n\t\t\t\tcurrentMasterIdentity = newIdentity\n\t\t\t\tif err := m.delegate.OnBecomeSlave(ctx, currentMasterIdentity); err != nil {\n\t\t\t\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle become slave, force quit for safety\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if currentMasterIdentity != newIdentity {\n\t\t\t\t// Master changed. Need update.\n\t\t\t\tcurrentMasterIdentity = newIdentity\n\t\t\t\tif err := m.delegate.OnSwitchMaster(ctx, currentMasterIdentity); err != nil {\n\t\t\t\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle switch master, force quit for safety\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttime.Sleep(m.checkInterval)\n\t}\n\n\tif myLock == nil {\n\t\tm.logger.Fatal().Msg(\"myLock is nil, found bug, force quit for safety\")\n\t\treturn\n\t}\n\n\t// I am the master now.\n\tif err := m.delegate.OnBecomeMaster(ctx); err != nil {\n\t\tmyLock.Release(ctx)\n\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle become master, force quit for safety\")\n\t\treturn\n\t}\n\n\tdefer func() {\n\t\tmyLock.Release(ctx)\n\t\tif err := m.delegate.OnLostMaster(ctx); err != nil {\n\t\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle lost master, force quit for safety\")\n\t\t}\n\t}()\n\n\t// Start the master loop.\n\tfor m.keepRunning {\n\t\ttime.Sleep(m.checkInterval)\n\t\tif err := myLock.Refresh(ctx, m.lockExpired); err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_bill_compute_task.go",
        "code_start_line": 63,
        "code_end_line": 113,
        "code_key": "ProcessUserSnapResources",
        "code_value": "func (t *SnapBillComputeTask) ProcessUserSnapResources(user *user.User, snapIds []measure.ResourceId) {\n\tsnapSrv := t.ResSrv.(*measure.SnapSrv)\n\t// 不同用户的资源数是不一致的，这里顺序处理的话性能一般，需要放在协程中跑\n\t// 单个用户最多启动100个协程，避免协程过多\n\tvar wg sync.WaitGroup\n\tsemaphore := make(chan struct{}, 100)\n\tchargeTimeFromSnapshot := snapSrv.GetSnapRealChargeTimes(user.AppId, t.ChargeTime)\n\n\tfor _, snapId := range snapIds {\n\t\twg.Add(1)\n\t\tgo func(snapId measure.ResourceId) {\n\t\t\tdefer wg.Done()\n\t\t\t// 这里可以控制启动的协程数\n\t\t\tsemaphore <- struct{}{}\n\t\t\tdefer func() { <-semaphore }()\n\n\t\t\tlogs.Info(t.Ctx).\n\t\t\t\tUint64(\"app_id\", uint64(user.AppId)).\n\t\t\t\tStr(\"snap_id\", string(snapId)).\n\t\t\t\tMsg(\"PROCESS_SIGNAL_SNAP\")\n\t\t\t// 计费真正的结算时间：若快照deadline时间晚于结算时间，则结算时间=快照deadline\n\t\t\tchargeTime, ok := chargeTimeFromSnapshot[snapId]\n\t\t\tif !ok {\n\t\t\t\tchargeTime = t.ChargeTime\n\t\t\t}\n\n\t\t\tchargeItem := snapSrv.BuildResChargeItem(user, snapId, chargeTime)\n\t\t\tif chargeItem == nil {\n\t\t\t\t// 可能是资源不需要计费。这里需要把资源Id从UnConfirmedMap中删除\n\t\t\t\tt.MarkSingleResDone(user.AppId, snapId)\n\t\t\t\tlogs.Info(t.Ctx).Uint64(\"appId\", uint64(user.AppId)).\n\t\t\t\t\tStr(\"snapId\", string(snapId)).Msg(\"SKIP_SNAP\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tchargeItemMsg := mqimpl.NewMessage(mq.MSGTYPE_JSON, chargeItem)\n\t\t\terr := t.ChargeItemProducer.Publish(chargeItemMsg)\n\t\t\tlogs.Info(t.Ctx).\n\t\t\t\tUint64(\"appId\", uint64(user.AppId)).\n\t\t\t\tStr(\"snap_id\", string(snapId)).\n\t\t\t\tMsg(\"PUBLISH_CHARGE_ITEM\")\n\t\t\tif err != nil {\n\t\t\t\tlogs.Error(t.Ctx).Err(err).\n\t\t\t\t\tUint64(\"appId\", uint64(user.AppId)).\n\t\t\t\t\tStr(\"snapId\", string(snapId)).\n\t\t\t\t\tMsg(\"PUBLISH_CHARGE_ITEM_FAILED\")\n\t\t\t}\n\t\t}(snapId)\n\t}\n\twg.Wait()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/task.go",
        "code_start_line": 25,
        "code_end_line": 32,
        "code_key": "UpdateExecuteTime",
        "code_value": "func (t *Task) UpdateExecuteTime(ctx context.Context) {\n\tinterval := t.Interval * time.Duration(t.Count)\n\tif interval >= t.MaxInterval {\n\t\tinterval = t.MaxInterval\n\t}\n\t// 这里应该是执行完成的时间加上等待时间\n\tt.NextTriggerTime = time.Now().Add(time.Second * interval)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/cbs_bill_compute_task.go",
        "code_start_line": 64,
        "code_end_line": 90,
        "code_key": "ProcessUserCbsResources",
        "code_value": "func (t *CbsBillComputeTask) ProcessUserCbsResources(user *user.User, resIds []measure.ResourceId) {\n\tcbsSrv := t.ResSrv.(*measure.CbsSrv)\n\t// 不同用户的资源数是不一致的，这里顺序处理的话性能一般，需要放在协程中跑\n\t// 单个用户最多启动100个协程，避免协程过多\n\tvar wg sync.WaitGroup\n\tfor _, cbsInstanceId := range resIds {\n\t\twg.Add(1)\n\t\tgo func(cbsInstanceId measure.ResourceId) {\n\t\t\tdefer wg.Done()\n\t\t\t// 并发的控制策略: 同时处理的用户不超过t.Concurrency个，所有用户共享t.Concurrency * 100个协程\n\t\t\t// 这样设计的目的是为了规避用户资源倾斜严重的问题，同时也能保证用户的并发度较少\n\t\t\tt.ResSemaphore <- struct{}{}\n\t\t\tdefer func() {\n\t\t\t\t<-t.ResSemaphore\n\t\t\t}()\n\n\t\t\tlogs.Info(t.Ctx).\n\t\t\t\tUint64(\"appId\", uint64(user.AppId)).\n\t\t\t\tStr(\"cbsInstanceId\", string(cbsInstanceId)).\n\t\t\t\tMsg(\"PROCESS_SIGNAL_DISK\")\n\n\t\t\tchargeItem := cbsSrv.BuildResChargeItem(user, cbsInstanceId, t.ChargeTime)\n\t\t\tt.ProcessSingleChargeItem(user, cbsInstanceId, chargeItem)\n\t\t}(cbsInstanceId)\n\t}\n\twg.Wait()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/repush_user_billing_task.go",
        "code_start_line": 103,
        "code_end_line": 172,
        "code_key": "ProcessSingleRepushDetail",
        "code_value": "func (t *RepushUserBillingTask) ProcessSingleRepushDetail(detail *measure.RepushDetail) error {\n\tcbsMeasureRepo := registry.GetRegistry(t.ctx).AdapterRepos.CbsMeasureRepo.(measure.CbsMeasureRepoIFace)\n\tappIdResIdMaps := make(map[user.AppId][]measure.ResourceId)\n\tif detail.AppId > 0 {\n\t\tif len(detail.ResIds) > 0 {\n\t\t\tappIdResIdMaps[detail.AppId] = detail.ResIds\n\t\t} else {\n\t\t\tids, err := cbsMeasureRepo.GetResourceIdsByAppId(t.ctx, int64(detail.AppId), time.Time{}, true, cbsMeasureRepo.GetBalanceTableName())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tresIds := make([]measure.ResourceId, 0, len(ids))\n\t\t\tfor _, resId := range ids {\n\t\t\t\tresIds = append(resIds, measure.ResourceId(resId))\n\t\t\t}\n\t\t\tappIdResIdMaps[detail.AppId] = resIds\n\t\t}\n\t} else {\n\t\tif len(detail.ResIds) > 0 {\n\t\t\treturn fmt.Errorf(\"AppId is required when ResIds is set\")\n\t\t}\n\t\tlogs.Info(t.ctx).Msg(\"REPUSH_ALL_FOR_APPID_NOT_SET\")\n\t\tappIds, _ := cbsMeasureRepo.GetAppIdsWithResources(t.ctx, time.Time{}, true, cbsMeasureRepo.GetBalanceTableName())\n\t\tfor _, appId := range appIds {\n\t\t\t// 没有指定资源，则补量所有资源\n\t\t\tids, err := cbsMeasureRepo.GetResourceIdsByAppId(t.ctx, appId, time.Time{}, true, cbsMeasureRepo.GetBalanceTableName())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tresIds := make([]measure.ResourceId, 0, len(ids))\n\t\t\tfor _, resId := range ids {\n\t\t\t\tresIds = append(resIds, measure.ResourceId(resId))\n\t\t\t}\n\t\t\tappIdResIdMaps[user.AppId(appId)] = resIds\n\t\t}\n\n\t}\n\n\tvar repushItems []*RepushItem\n\tfor appId, resIds := range appIdResIdMaps {\n\t\tu, err := t.userSrv.GetUser(appId)\n\t\tif err != nil {\n\t\t\t// 这里可能是新注册的用户，user表里没有用户数据，可能会丢失该用户的量\n\t\t\tlogs.Error(t.ctx).Err(err).Uint64(\"appId\", uint64(appId)).Msg(\"GET_USER_ERROR\")\n\t\t\tpanic(err)\n\t\t}\n\t\tfor _, resId := range resIds {\n\t\t\tvar repushItem RepushItem\n\t\t\trepushItem.user = u\n\t\t\trepushItem.cbsInstanceId = resId\n\t\t\trepushItem.startTime = detail.StartTime\n\t\t\trepushItem.endTime = detail.EndTime\n\t\t\trepushItems = append(repushItems, &repushItem)\n\t\t}\n\t}\n\tlogs.Info(t.ctx).Int(\"count\", len(repushItems)).Msg(\"REPUSH_ITEMS_INFO\")\n\n\tvar wg sync.WaitGroup\n\tfor _, repushItem := range repushItems {\n\t\twg.Add(1)\n\t\tt.semaphore <- struct{}{}\n\t\tgo func(item *RepushItem) {\n\t\t\tdefer wg.Done()\n\t\t\tdefer func() { <-t.semaphore }()\n\t\t\tt.ProcessSingleRepushItem(item)\n\t\t}(repushItem)\n\t}\n\twg.Wait()\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/cbs_measure_send_task.go",
        "code_start_line": 56,
        "code_end_line": 81,
        "code_key": "ProcessMsgByRegion",
        "code_value": "func (t *CbsMeasureSendTask) ProcessMsgByRegion() {\n\t// 并发处理消息\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < t.Conf.Concurrency; i++ {\n\t\twg.Add(1)\n\t\tgo func(workId int) {\n\t\t\tlog.Infof(\"start work %d\", workId)\n\t\t\tdefer wg.Done()\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase msg, ok := <-t.DomesticChan:\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.ProcessMsgToMeasureDetail(msg)\n\t\t\t\tcase <-t.Ctx.Done():\n\t\t\t\t\tlogs.Info(t.Ctx).Int(\"work_id\", workId).Msg(\"STOP_WORKER\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n\t// 关闭chan\n\twg.Wait()\n\tclose(t.MeasureDetailChan)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_measure_send_task.go",
        "code_start_line": 51,
        "code_end_line": 76,
        "code_key": "ProcessMsgByRegion",
        "code_value": "func (t *SnapMeasureSendTask) ProcessMsgByRegion() {\n\t// 并发处理消息\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < t.Conf.Concurrency; i++ {\n\t\twg.Add(1)\n\t\tgo func(workId int) {\n\t\t\tlog.Infof(\"start work %d\", workId)\n\t\t\tdefer wg.Done()\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase msg, ok := <-t.DomesticChan:\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.ProcessMsgToMeasureDetail(msg)\n\t\t\t\tcase <-t.Ctx.Done():\n\t\t\t\t\tlogs.Info(t.Ctx).Int(\"work_id\", workId).Msg(\"STOP_WORKER\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n\t// 关闭chan\n\twg.Wait()\n\tclose(t.MeasureDetailChan)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/cbs_rec_task.go",
        "code_start_line": 111,
        "code_end_line": 136,
        "code_key": "ProcessMsg",
        "code_value": "func (t *CbsMeasureRecTask) ProcessMsg() {\n\t// 并发处理消息\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < t.Conf.Concurrency; i++ {\n\t\twg.Add(1)\n\t\tgo func(workId int) {\n\t\t\tlog.Infof(\"start work %d\", workId)\n\t\t\tdefer wg.Done()\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase msg, ok := <-t.DomesticChan:\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.ProcessMsgToMeasure(msg)\n\t\t\t\tcase <-t.Ctx.Done():\n\t\t\t\t\tlogs.Info(t.Ctx).Int(\"work_id\", workId).Msg(\"STOP_WORKER\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n\t// 关闭chan\n\twg.Wait()\n\tclose(t.CbsMeasureDetailChan)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_rec_task.go",
        "code_start_line": 63,
        "code_end_line": 105,
        "code_key": "sendDbFromMsg",
        "code_value": "func (t *SnapMeasureReconciliationTask) sendDbFromMsg(wg *sync.WaitGroup) {\n\t// 并发处理消息\n\n\tfor i := 0; i < t.Concurrency; i++ {\n\t\twg.Add(1)\n\t\tgo func(workId int) {\n\t\t\tlog.Infof(\"start work %d\", workId)\n\t\t\tdefer wg.Done()\n\t\t\tunConfirmedMap := make(map[measure.ResourceId]mqiface.IMessage)\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase msg := <-t.snapChargeItemForCompareConsumer.Receiving(mq.MSGTYPE_JSON):\n\t\t\t\t\tchargeItem, _ := parseChargeItem(msg)\n\t\t\t\t\tresourceId := chargeItem.ResourceId\n\t\t\t\t\tunConfirmedMap[resourceId] = msg\n\n\t\t\t\t\t// 达到指定数量后进行数据库同步\n\t\t\t\t\tif len(unConfirmedMap) == 100 {\n\t\t\t\t\t\tlog.Infof(\"unConfirmedMap num %d\", len(unConfirmedMap))\n\t\t\t\t\t\terr := t.ProcessMsgSendMeasure(t.ctx, unConfirmedMap)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tjsonData, _ := json.Marshal(unConfirmedMap)\n\t\t\t\t\t\t\tlogs.Error(t.ctx).Err(err).Str(\"process_msg_send_measure_failed\", string(jsonData)).Msg(\"BATCH_PROCESS_SEND_MEASURE_FAILED\")\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\tcase <-time.After(5 * time.Second):\n\t\t\t\t\tif len(unConfirmedMap) > 0 {\n\t\t\t\t\t\tlogs.Info(t.ctx).Int(\"time_out_process_msg_nums\", len(unConfirmedMap)).Msg(\"TIME_OUT_PROCESS_MSG\")\n\t\t\t\t\t\terr := t.ProcessMsgSendMeasure(t.ctx, unConfirmedMap)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tjsonData, _ := json.Marshal(unConfirmedMap)\n\t\t\t\t\t\t\tlogs.Error(t.ctx).Err(err).Str(\"send_fail_detail\", string(jsonData)).Msg(\"TIMEOUT_PROCESS_SEND_MEASURE_FAILED\")\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tcase <-t.ctx.Done():\n\t\t\t\t\tlogs.Info(t.ctx).Int(\"work_id\", workId).Msg(\"STOP_WORKER\")\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_rec_task.go",
        "code_start_line": 134,
        "code_end_line": 150,
        "code_key": "AckResourceID",
        "code_value": "func (t *SnapMeasureReconciliationTask) AckResourceID() {\n\t// Ack逻辑：AppId关联的所有ChargeItem全部都confirmed了才触发对AppId的Ack\n\tgo func() {\n\t\tfor {\n\t\t\tt.m.Lock()\n\t\t\tfor resourceId := range t.ResourceIdMsgMap {\n\t\t\t\tt.snapChargeItemForCompareConsumer.Ack(t.ResourceIdMsgMap[resourceId])\n\t\t\t\tdelete(t.ResourceIdMsgMap, resourceId)\n\t\t\t\tlogs.Info(t.ctx).Str(\"resource_id\", string(resourceId)).Str(\"resource_id\", string(resourceId)).Msg(\"ACK_RESOURCE_ID\")\n\t\t\t}\n\t\t\tt.m.Unlock()\n\n\t\t\ttime.Sleep(time.Microsecond * 100)\n\t\t}\n\t}()\n\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/base_measure/base_send_measure_task.go",
        "code_start_line": 140,
        "code_end_line": 159,
        "code_key": "AckResourceID",
        "code_value": "func (t *BaseSendMeasureTask) AckResourceID() {\n\t// Ack逻辑：AppId关联的所有ChargeItem全部都confirmed了才触发ACK\n\tt.WG.Add(1)\n\tdefer t.WG.Done()\n\tgo func() {\n\t\tfor {\n\t\t\tt.m.Lock()\n\t\t\tfor resourceId, msgList := range t.unConfirmedMap {\n\t\t\t\tlogs.Info(t.ctx).Str(\"resourceId\", string(resourceId)).Int(\"size\", len(msgList)).Fields(t.unConfirmedMap).Msg(\"CHECK_RESOURCE_ID_CONFIRMED\")\n\t\t\t\tif len(msgList) == 0 {\n\t\t\t\t\tdelete(t.unConfirmedMap, resourceId)\n\t\t\t\t\tt.AckMessage(string(resourceId))\n\t\t\t\t}\n\t\t\t}\n\t\t\tt.m.Unlock()\n\t\t\ttime.Sleep(time.Millisecond * 100)\n\t\t}\n\t}()\n\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/base_measure/base_send_measure_task.go",
        "code_start_line": 261,
        "code_end_line": 313,
        "code_key": "ProcessParamsSendMeasure",
        "code_value": "func (t *BaseSendMeasureTask) ProcessParamsSendMeasure() {\n\tvar wg sync.WaitGroup\n\tsemaphore := make(chan struct{}, 100) // Semaphore with a capacity of 100\n\n\tfor {\n\t\tselect {\n\t\tcase param, ok := <-t.MeasureParamChan:\n\t\t\tif !ok {\n\t\t\t\tlogs.Info(t.Ctx).Msg(\"MEASURE_DETAIL_CHAN_CLOSED\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\twg.Add(1) // Increment the WaitGroup counter\n\n\t\t\tgo func(param interface{}) {\n\t\t\t\tdefer wg.Done() // Decrement the WaitGroup counter when the goroutine completes\n\n\t\t\t\tsemaphore <- struct{}{}        // Acquire a semaphore slot\n\t\t\t\tdefer func() { <-semaphore }() // Release the semaphore slot\n\n\t\t\t\t// Convert param to paraMap\n\t\t\t\tparaMap := make(map[string]interface{})\n\t\t\t\tdata, _ := json.Marshal(param)\n\t\t\t\t_ = json.Unmarshal(data, &paraMap)\n\n\t\t\t\t_, err := t.SendMeasureData(t.Ctx, paraMap)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogs.Info(t.Ctx).Any(\"param\", paraMap).Msg(\"SEND_MEASURE_DATA_ERROR\")\n\t\t\t\t}\n\n\t\t\t\t// Process measureDetail and subMeasureDetail\n\t\t\t\tmeasureDetail := paraMap[\"measureDetail\"].([]interface{})\n\t\t\t\tfor _, measureDetail := range measureDetail {\n\t\t\t\t\tmeasureMap := measureDetail.(map[string]interface{})\n\t\t\t\t\tserialId := measureMap[\"serialId\"].(string)\n\t\t\t\t\tsubMeasureDetail := measureMap[\"subMeasureDetail\"].([]interface{})\n\n\t\t\t\t\tfor _, subMeasure := range subMeasureDetail {\n\t\t\t\t\t\tsubMeasureMap := subMeasure.(map[string]interface{})\n\t\t\t\t\t\tdosageId := subMeasureMap[\"dosageId\"].(string)\n\t\t\t\t\t\tt.MarkMeasureDetailDone(measure.ResourceId(serialId), measure.DosageId(dosageId))\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}(param)\n\n\t\tcase <-t.Ctx.Done():\n\t\t\tlogs.Info(t.Ctx).Msg(\"CTX_DONE\")\n\t\t\twg.Wait() // Wait for all goroutines to complete\n\t\t\treturn\n\t\t}\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/base_measure/base_bill_compute_task.go",
        "code_start_line": 76,
        "code_end_line": 122,
        "code_key": "GetUserResources",
        "code_value": "func (t *BaseBillComputeTask) GetUserResources() {\n\t// 启动多个worker用来处理单用户的快照资源\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < t.userConcurrency; i++ {\n\t\twg.Add(1)\n\t\tgo func(workId int) {\n\t\t\tdefer wg.Done()\n\t\t\tlogs.Info(t.ctx).Int(\"workId\", workId).Msg(\"START_WORKER\")\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase msg, ok := <-t.AppIdConsumer.Receiving(mq.MSGTYPE_TEXT):\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\tlogs.Error(t.ctx).Msg(\"STOP_WORKER\")\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tappId, _ := parseAppId(msg)\n\t\t\t\t\tu, err := t.userSrv.GetUser(appId)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t// 这里可能是新注册的用户，user表里没有用户数据，可能会丢失该用户的量\n\t\t\t\t\t\tlogs.Error(t.ctx).Err(err).Uint64(\"appId\", uint64(appId)).Msg(\"PROCESS_SIGNAL_USER_FAILED\")\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\tt.AddToAckMessage(strconv.FormatUint(uint64(appId), 10), msg)\n\t\t\t\t\terr = t.ProcessSingleUser(u)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlogs.Error(t.ctx).Err(err).Uint64(\"appId\", uint64(appId)).Msg(\"PROCESS_SIGNAL_USER_FAILED\")\n\t\t\t\t\t}\n\t\t\t\tcase <-t.ctx.Done():\n\t\t\t\t\tlogs.Info(t.ctx).Int(\"workId\", workId).Msg(\"STOP_WORKER\")\n\t\t\t\t\treturn\n\t\t\t\tcase <-time.After(time.Second * 10):\n\t\t\t\t\tlogs.Debug(t.ctx).Int(\"workId\", workId).Msg(\"WAIT_MSG_TIMEOUT\")\n\t\t\t\t\t// 队列为空，也没有待Confirm数据的数据\n\t\t\t\t\tif t.AppIdConsumer.QueueIsEmpty() && len(t.unConfirmedMap) == 0 {\n\t\t\t\t\t\tlogs.Info(t.ctx).Int(\"workId\", workId).Msg(\"STOP_WORKER_FOR_QUEUE_EMPTY\")\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}(i)\n\t}\n\t// 关闭chan\n\twg.Wait()\n\tclose(t.UserResChan)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/base_measure/base_bill_compute_task.go",
        "code_start_line": 175,
        "code_end_line": 215,
        "code_key": "AckAppId",
        "code_value": "func (t *BaseBillComputeTask) AckAppId() {\n\tt.WG.Add(1)\n\tdefer t.WG.Done()\n\t// Ack逻辑：AppId关联的所有ChargeItem全部都confirmed了才触发对AppId的Ack\n\tgo func() {\n\t\tfor {\n\t\t\tt.m.Lock()\n\t\t\tfor appId, msgList := range t.unConfirmedMap {\n\t\t\t\tlogs.Info(t.ctx).Uint64(\"appId\", uint64(appId)).Int(\"size\", len(msgList)).Fields(t.unConfirmedMap).Msg(\"CHECK_APPID_CONFIRMED\")\n\t\t\t\tif len(msgList) == 0 {\n\t\t\t\t\tt.AckMessage(strconv.FormatUint(uint64(appId), 10))\n\t\t\t\t\tdelete(t.unConfirmedMap, appId)\n\t\t\t\t}\n\t\t\t}\n\t\t\tt.m.Unlock()\n\t\t\ttime.Sleep(time.Millisecond * 100)\n\t\t}\n\t}()\n\n\t// Confirm逻辑，确认chargeItem放入队列后，将chargeItem关联的resourceId从未确认map中删除\n\tfor confirm := range t.ChargeItemProducer.Confirm() {\n\t\tt.WG.Add(1)\n\t\tchargeItem := confirm.GetData().(*measure.ChargeItem)\n\t\tif confirm.GetPublishResult() != mq.PUBLISH_RESULT_SUCCESS {\n\t\t\t// 告警出来，后期补量，部分成功不好处理\n\t\t\tlogs.Error(t.ctx).Any(\"chargeItem\", chargeItem).Msg(\"CHARGE_ITEM_PUBLISH_FAILED\")\n\t\t\tcontinue\n\t\t}\n\t\t// 到这里就代表chargeItem已经发送到队列，理论上不会漏推\n\t\t// FIXME 可能会导致重复推量\n\t\tgo func(innerChargeItem *measure.ChargeItem) {\n\t\t\tdefer t.WG.Done()\n\t\t\terr := t.ResSrv.UpdateResBalanceRecords(innerChargeItem.AppId, innerChargeItem)\n\t\t\tif err != nil {\n\t\t\t\tlogs.Error(t.Ctx).Err(err).Uint64(\"appId\", uint64(innerChargeItem.AppId)).\n\t\t\t\t\tStr(\"resourceId\", string(innerChargeItem.ResourceId)).Msg(\"UPDATE_CBS_BALANCE_RECORD_FAILED\")\n\t\t\t}\n\t\t}(chargeItem)\n\t\tt.MarkSingleResDone(chargeItem.AppId, chargeItem.ResourceId)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_rec_task_scanner.go",
        "code_start_line": 39,
        "code_end_line": 41,
        "code_key": "FullScan",
        "code_value": "func (s *CbsMeasureReconciliationTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_rec_task_scanner.go",
        "code_start_line": 37,
        "code_end_line": 39,
        "code_key": "FullScan",
        "code_value": "func (s *SnapMeasureReconciliationTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_compute_task_scanner.go",
        "code_start_line": 39,
        "code_end_line": 41,
        "code_key": "FullScan",
        "code_value": "func (s *SnapComputeTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_measure_send_task_scanner.go",
        "code_start_line": 39,
        "code_end_line": 41,
        "code_key": "FullScan",
        "code_value": "func (s *CbsMeasureSendTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_bill_valid_appId_fetch_task_scanner.go",
        "code_start_line": 39,
        "code_end_line": 41,
        "code_key": "FullScan",
        "code_value": "func (s *CbsValidAppIdFetchTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_calculate_cost_locally_task_scanner.go",
        "code_start_line": 38,
        "code_end_line": 40,
        "code_key": "FullScan",
        "code_value": "func (s *SnapCalculateCostLocallyTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_create_task_scanner.go",
        "code_start_line": 50,
        "code_end_line": 78,
        "code_key": "FullScan",
        "code_value": "func (s *UpdateCreateTaskScanner) FullScan(ctx context.Context) error {\n\tsnapRepo := registry.GetRegistry(ctx).AdapterRepos.SnapRepo.(adapter_interfaces.SnapInterface)\n\tsnapList, err := snapRepo.QueryCreatingCopyingSnapList(ctx)\n\tif err != nil {\n\t\tlogs.Error(ctx).Err(err).Msg(\"FULL_SCAN_FAILED\")\n\t\treturn err\n\t}\n\tresultCnt := 0\n\tfor _, snapRecord := range snapList {\n\t\t// 剔除快照组预生成的快照记录\n\t\tif strings.Contains(snapRecord.SnapUuid, \"temp\") {\n\t\t\tlogs.Info(ctx).Str(\"SnapId\", snapRecord.SnapInstanceId).Msgf(\"PRE_CREATED_SNAPSHOT_SKIP_UPDATE\")\n\t\t\tcontinue\n\t\t}\n\n\t\tentity := &snapLogical.Entity{\n\t\t\tSnapRecord: snapRecord,\n\t\t}\n\t\tsnapAggregate := &snapLogical.SnapCreateTaskAggregate{\n\t\t\tEntity:      entity,\n\t\t\tTaskName:    core.UpdateCreateTask,\n\t\t\tSubTaskName: core.UpdateCreateTask,\n\t\t}\n\t\ts.resultChan <- snapAggregate\n\t\tresultCnt += 1\n\t}\n\ts.resultChanMetric.Add(float64(resultCnt))\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_measure_send_task_scanner.go",
        "code_start_line": 38,
        "code_end_line": 40,
        "code_key": "FullScan",
        "code_value": "func (s *SnapMeasureSendTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/repush_user_billing_task_scanner.go",
        "code_start_line": 41,
        "code_end_line": 43,
        "code_key": "FullScan",
        "code_value": "func (s *RepushUserBillingTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_rollback_task_scanner.go",
        "code_start_line": 103,
        "code_end_line": 113,
        "code_key": "FullScan",
        "code_value": "func (s *UpdateRollbackTaskScanner) FullScan(ctx context.Context) error {\n\tif err := s.getCCbsRollbackTask(ctx); err != nil {\n\t\tlogs.Error(ctx).Err(err).Msg(\"FULL_SCAN_FAILED\")\n\t\treturn err\n\t}\n\tif err := s.getImageSnapRollbackTask(ctx); err != nil {\n\t\tlogs.Error(ctx).Err(err).Msg(\"FULL_SCAN_FAILED\")\n\t\treturn err\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_valid_appId_fetch_task_scanner.go",
        "code_start_line": 38,
        "code_end_line": 40,
        "code_key": "FullScan",
        "code_value": "func (s *SnapValidAppIdFetchTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_bill_compute_task_scanner.go",
        "code_start_line": 41,
        "code_end_line": 43,
        "code_key": "FullScan",
        "code_value": "func (s *CbsBillComputeTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/client/client.go",
        "code_start_line": 20,
        "code_end_line": 62,
        "code_key": "Request",
        "code_value": "func (c *BaseClient) Request(ctx context.Context, interfaceName string, reqJsonData []byte) ([]byte, error) {\n\tlogger := logs.With(ctx).Str(\"interface\", interfaceName).Logger()\n\tlogger.Info().Str(\"para\", string(reqJsonData)).Msg(\"NEW_REQUEST\")\n\n\tctx, cancel := context.WithTimeout(ctx, time.Second*time.Duration(c.Timeout))\n\tdefer cancel()\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPost, c.Url, bytes.NewReader(reqJsonData))\n\n\tif global.TestEnv {\n\t\treq.Header.Add(\"X-QCloud-Transaction-ID\", uuid.New().String())\n\t\treq.Header.Add(\"X-QCloud-User-ID\", global.TestUin)\n\t}\n\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"new request failed: %v\", err)\n\t}\n\theader := \"\"\n\tfor key, value := range req.Header {\n\t\theader += fmt.Sprintf(\"-H \\\"%s: %s\\\" \", key, value[0])\n\t}\n\tcurl := fmt.Sprintf(\"curl %s --connect-timeout %d -d '%s' %s\", header, c.Timeout, string(reqJsonData), c.Url)\n\tlogger.Info().Any(\"cmd\", curl).Msgf(\"SHOW_CURL_CMD\")\n\n\trsp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\tlogger.Error().Err(err).Msgf(\"RESPONSE_ERR\")\n\t\treturn nil, fmt.Errorf(\"do request failed: %v\", err)\n\t}\n\tdefer func(Body io.ReadCloser) {\n\t\t_ = Body.Close()\n\t}(rsp.Body)\n\n\tif rsp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"unexpected status code: %d\", rsp.StatusCode)\n\t}\n\tbodyData, err := io.ReadAll(rsp.Body)\n\tlogger.Info().Any(\"response\", string(bodyData)).Msgf(\"SHOW_RESPONSE\")\n\tif err != nil {\n\t\tlogger.Error().Err(err).Msgf(\"RESPONSE_ERR\")\n\t\treturn nil, err\n\t}\n\treturn bodyData, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go",
        "code_start_line": 83,
        "code_end_line": 103,
        "code_key": "AddTask",
        "code_value": "func (sc *Scheduler) AddTask(ctx context.Context, newTask interfaces.Task) {\n\tvalue, ok := sc.taskMap.Load(newTask.GetTaskId())\n\tif !ok {\n\t\tsc.syncTaskPriorityQueue.Push(newTask)\n\t\tsc.taskMap.Store(newTask.GetTaskId(), newTask)\n\t\tsc.addTimerEvent(newTask.GetTaskId())\n\t\tsc.metrics.taskCountInQueue.Add(1)\n\t} else {\n\t\t// 对于已存在的任务需要判断subTaskName是否发生变化\n\t\t// 存在任务切换的场景，如order -> trigger，需要将旧任务删除，新任务插入\n\t\ttask := value.(interfaces.Task)\n\t\tif task.GetSubTaskName() != newTask.GetSubTaskName() {\n\t\t\tlogs.Info(ctx).Str(\"TaskId\", task.GetTaskId()).Msg(\"FOUND_SUB_TASK_CHANGED\")\n\t\t\t// 更新taskMap中的task记录，并插入优先队列\n\t\t\tsc.taskMap.Store(newTask.GetTaskId(), newTask)\n\t\t\tsc.syncTaskPriorityQueue.Push(newTask)\n\t\t\tsc.addTimerEvent(newTask.GetTaskId())\n\t\t\tsc.metrics.taskCountInQueue.Add(1)\n\t\t}\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go",
        "code_start_line": 120,
        "code_end_line": 131,
        "code_key": "tryGetWorker",
        "code_value": "func (sc *Scheduler) tryGetWorker(ctx context.Context) bool {\n\tsc.mutex.Lock()\n\tdefer sc.mutex.Unlock()\n\n\tif sc.workerNum > 0 {\n\t\tsc.workerNum--\n\t\tsc.wg.Add(1)\n\t\tsc.metrics.idleWorkerNum.Set(float64(sc.workerNum))\n\t\treturn true\n\t}\n\treturn false\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go",
        "code_start_line": 217,
        "code_end_line": 221,
        "code_key": "rePushTask",
        "code_value": "func (sc *Scheduler) rePushTask(ctx context.Context, task interfaces.Task) {\n\tsc.syncTaskPriorityQueue.Push(task)\n\tsc.metrics.taskCountInQueue.Add(1)\n\tsc.addTimerEvent(task.GetTaskId())\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/mq/mqimpl/rabbitMq/producer.go",
        "code_start_line": 71,
        "code_end_line": 96,
        "code_key": "Confirm",
        "code_value": "func (p *Producer) Confirm() <-chan mqiface.IMessage {\n\t/*\n\t\tConfirm主要是用来获取消息的发送结果，并将对象的消息放入channel中\n\t\tconfirm.DeliveryTag是rabbitmq维护的channel级的唯一标识，实际的值来源于channel.published,\n\t\t但是这个变量不对外暴露，所以在publish操作中也维护了一个producer级的published变量，二者值是一致的\n\t*/\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase confirm, ok := <-p.Confirms:\n\t\t\t\tif !ok {\n\t\t\t\t\tlogs.Info(p.Ctx).Msg(\"CONFIRM_CHANNEL_CLOSED\")\n\t\t\t\t\t// 关闭p.confirmedMsgChannel\n\t\t\t\t\tp.wg.Wait()\n\t\t\t\t\tclose(p.confirmedMsgChannel)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tp.wg.Add(1)\n\t\t\t\tgo p.processConfirmation(confirm)\n\t\t\tcase <-p.Ctx.Done():\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}()\n\treturn p.confirmedMsgChannel\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/cmd/rdisk_master/run.go",
        "code_start_line": 63,
        "code_end_line": 80,
        "code_key": "runScheduler",
        "code_value": "func runScheduler(appCtx context.Context, wg *sync.WaitGroup) {\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ts := app.GlobalRegistry.Scheduler\n\t\tsignalChan := make(chan os.Signal, 10)\n\t\tsignal.Notify(signalChan, unix.SIGINT, unix.SIGTERM, unix.SIGSEGV)\n\n\t\tgo func(c chan os.Signal) {\n\t\t\t<-c\n\t\t\ts.Stop()\n\t\t}(signalChan)\n\n\t\tif err := s.Start(appCtx); err != nil {\n\t\t\tlogs.Fatal(appCtx).Err(err).Msg(\"scheduler exited\")\n\t\t}\n\t}()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/cmd/rdisk_master/run.go",
        "code_start_line": 83,
        "code_end_line": 92,
        "code_key": "runApiServer",
        "code_value": "func runApiServer(appCtx context.Context, wg *sync.WaitGroup) {\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ts := apiserver.New(appCtx)\n\t\tif err := s.Serve(); err != nil {\n\t\t\tlogs.Fatal(appCtx).Err(err).Msg(\"server exited\")\n\t\t}\n\t}()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/cmd/rdisk_master/run.go",
        "code_start_line": 172,
        "code_end_line": 182,
        "code_key": "initSchedulers",
        "code_value": "func initSchedulers(ctx context.Context) {\n\tapp.GlobalRegistry.Scheduler = scheduler.New(ctx, app.GlobalRegistry.Locker)\n\n\t// 注册定时任务\n\n\tapp.GlobalRegistry.Scheduler.Add(\"update_backup_task\", &tasks.UpdateBackupTask{})\n\tapp.GlobalRegistry.Scheduler.Add(\"recycle_backup_task\", &tasks.RecycleBackupTask{})\n\tapp.GlobalRegistry.Scheduler.Add(\"update_benchmark_task\", &tasks.UpdateBenchmarkTask{})\n\tapp.GlobalRegistry.Scheduler.Add(\"confirm_init_physicaldisk_task\", &tasks.ConfirmInitPhysicalDiskTask{})\n\tapp.GlobalRegistry.Scheduler.Add(\"cleanup_defunct_task\", &tasks.CleanupDefunctTask{})\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/dispatcher/dispatcher.go",
        "code_start_line": 33,
        "code_end_line": 103,
        "code_key": "Dispatch",
        "code_value": "func (d *dispatcherImpl) Dispatch(ctx context.Context, cmd app.Command) (err error) {\n\t// 为什么使用 backgroundCtx 而不是 ctx？\n\t// 因为 ctx 代表调用方的上下文，通常是 rpc 请求上下文。\n\t// 而执行命令的上下文，应该是一个独立的上下文，不应该受到调用方的影响\n\t// 即使由于网络抖动等原因，调用方的上下文已经超时，但是命令执行的上下文仍然应该继续执行。\n\tworkerCtx := context.WithValue(d.backgroundCtx, ctxKeyCommand, cmd)\n\tworkerCtx, cancelFunc := context.WithTimeout(workerCtx, d.workerTimeout)\n\tworkerCtx = logs.GetLogger(ctx).WithContext(workerCtx)\n\tlockKeys := cmd.LockKeys()\n\terrChan := make(chan error, 1)\n\tlockOption := &dlock.Option{\n\t\tRetryStrategy: dlock.ExponentialBackoff(100*time.Millisecond, 6*time.Second),\n\t}\n\td.wg.Add(1)\n\t// 最终打印错误\n\t// TODO: 并发控制最大能同时执行的命令数量\n\tgo func() {\n\t\tdefer d.wg.Done()\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\te, ok := err.(error)\n\t\t\t\tif !ok {\n\t\t\t\t\te = errors.Newf(ErrDispatchPanic, \"dispatcher panic: %v\", err)\n\t\t\t\t}\n\t\t\t\terrChan <- e\n\t\t\t\tlogs.Error(workerCtx).Err(e).Stack().Bytes(\"trace\", debug.Stack()).Msgf(\"command execution panic\")\n\t\t\t}\n\t\t}()\n\n\t\tdefer cancelFunc()\n\n\t\tif lockKeys != nil {\n\t\t\tlock, err := d.locker.ObtainMulti(workerCtx, lockKeys, d.workerTimeout, lockOption)\n\t\t\tif err != nil {\n\t\t\t\terrChan <- err\n\t\t\t\tlogs.Warn(workerCtx).Err(err).Msgf(\"command execution waiting locks timeout\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer lock.Release(workerCtx)\n\t\t}\n\n\t\tuow := app.GetRegistry(ctx).Repositories.UoWFactory.New()\n\t\tworkerCtx = app.GetRegistry(ctx).Repositories.UoWFactory.With(workerCtx, uow)\n\n\t\terr = cmd.Handle(workerCtx)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, errors.ErrDryRunSuccessExit) {\n\t\t\t\terr = nil\n\t\t\t} else {\n\t\t\t\tlogs.Warn(workerCtx).Err(err).Msgf(\"command execution failed\")\n\t\t\t}\n\t\t\t_err := uow.Rollback(workerCtx)\n\t\t\tif _err != nil {\n\t\t\t\tlogs.Error(workerCtx).Err(_err).Msgf(\"unit of work rollback failed\")\n\t\t\t}\n\t\t} else {\n\t\t\terr = uow.Commit(workerCtx)\n\t\t\tif err != nil {\n\t\t\t\tlogs.Error(workerCtx).Err(err).Msgf(\"unit of work commit failed\")\n\t\t\t}\n\t\t}\n\t\terrChan <- err\n\t\tclose(errChan)\n\t}()\n\tselect {\n\tcase err := <-errChan:\n\t\treturn err\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/scheduler.go",
        "code_start_line": 127,
        "code_end_line": 132,
        "code_key": "Add",
        "code_value": "func (s *scheduler) Add(name string, workload WorkLoad) {\n\ts.mutex.Lock()\n\tdefer s.mutex.Unlock()\n\ts.loads[name] = workload\n\ts.eventChan <- name\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/benchmark.go",
        "code_start_line": 17,
        "code_end_line": 29,
        "code_key": "Add",
        "code_value": "func (repo *rdiskBenchmarkRepositoryImpl) Add(ctx context.Context, bench *benchmark.Benchmark) error {\n\tdo := repo.fromModelToDO(bench)\n\tuow := getUow(ctx)\n\tdo.Created = uow.tx.NowFunc()\n\tdo.Updated = uow.tx.NowFunc()\n\tresult := uow.tx.Create(&do)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tbench.ID = do.ID\n\tuow.trackedBenchmarks.Add(bench)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/backup.go",
        "code_start_line": 19,
        "code_end_line": 31,
        "code_key": "Add",
        "code_value": "func (repo *rdiskBackupRepositoryImpl) Add(ctx context.Context, backup *backupPkg.Backup) error {\n\tuow := getUow(ctx)\n\tdo := repo.fromModelToDO(backup)\n\tdo.Created = uow.tx.NowFunc()\n\tdo.Updated = uow.tx.NowFunc()\n\tresult := uow.tx.Create(&do)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tbackup.ID = do.ID\n\tuow.trackedBackups.Add(backup)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go",
        "code_start_line": 76,
        "code_end_line": 91,
        "code_key": "Add",
        "code_value": "func (l logicalVolumeRepositoryImpl) Add(ctx context.Context, lv *rdiskDomain.LogicalVolume) error {\n\tuow := getUow(ctx)\n\tvol := fromModelToDmRDisk(lv)\n\tvol.Created = uow.tx.NowFunc()\n\tvol.Updated = uow.tx.NowFunc()\n\tresult := uow.tx.Create(&vol)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tlv.ID = vol.ID\n\tlv = uow.trackedLogicalVolumes.Add(lv)\n\tif lv.PhysicalVolume != nil {\n\t\tlv.PhysicalVolume = uow.trackedPhyVolumes.Add(lv.PhysicalVolume)\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/uow.go",
        "code_start_line": 23,
        "code_end_line": 30,
        "code_key": "Add",
        "code_value": "func (c *changeTracker[T]) Add(item T) T {\n\tif v, ok := c.items[item.GetID()]; ok {\n\t\treturn v\n\t}\n\tc.items[item.GetID()] = item\n\tc.originalStates[item.GetID()] = item.DeepCopy().(T)\n\treturn item\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go",
        "code_start_line": 59,
        "code_end_line": 71,
        "code_key": "Add",
        "code_value": "func (p *physicalVolumeRepositoryImpl) Add(ctx context.Context, pv *rdiskDomain.PhysicalVolume) error {\n\tuow := getUow(ctx)\n\tvol := fromPhysicalVolumeToDmPhyDisk(ctx, pv)\n\tvol.Created = uow.tx.NowFunc()\n\tvol.Updated = uow.tx.NowFunc()\n\tresult := uow.tx.Create(&vol)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tpv.ID = vol.ID\n\tuow.trackedPhyVolumes.Add(pv)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
        "code_start_line": 96,
        "code_end_line": 108,
        "code_key": "Add",
        "code_value": "func (d drgroupRepositoryImpl) Add(ctx context.Context, group *drgroup.DRGroup) error {\n\tuow := getUow(ctx)\n\tdo := fromModelToDmDRGroup(group)\n\tdo.Created = uow.tx.NowFunc()\n\tdo.Updated = uow.tx.NowFunc()\n\tresult := uow.tx.Clauses(clause.Insert{Modifier: \"IGNORE\"}).Create(&do)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tgroup.ID = do.ID\n\tuow.trackedDRGroups.Add(group)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 41,
        "code_end_line": 46,
        "code_key": "Add",
        "code_value": "func (m *MockLogicalVolumeRepository) Add(arg0 context.Context, arg1 *rdiskDomain.LogicalVolume) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Add\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 49,
        "code_end_line": 52,
        "code_key": "Add",
        "code_value": "func (mr *MockLogicalVolumeRepositoryMockRecorder) Add(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Add\", reflect.TypeOf((*MockLogicalVolumeRepository)(nil).Add), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 40,
        "code_end_line": 45,
        "code_key": "Add",
        "code_value": "func (m *MockPhysicalVolumeRepository) Add(arg0 context.Context, arg1 *rdiskDomain.PhysicalVolume) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Add\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 48,
        "code_end_line": 51,
        "code_key": "Add",
        "code_value": "func (mr *MockPhysicalVolumeRepositoryMockRecorder) Add(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Add\", reflect.TypeOf((*MockPhysicalVolumeRepository)(nil).Add), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 40,
        "code_end_line": 45,
        "code_key": "Add",
        "code_value": "func (m *MockRepository) Add(arg0 context.Context, arg1 *drgroup.DRGroup) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Add\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 48,
        "code_end_line": 51,
        "code_key": "Add",
        "code_value": "func (mr *MockRepositoryMockRecorder) Add(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Add\", reflect.TypeOf((*MockRepository)(nil).Add), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 763,
        "code_end_line": 781,
        "code_key": "initCustomErrorHandler",
        "code_value": "func initCustomErrorHandler() {\n\tdefaultHandler := thttp.DefaultServerCodec.ErrHandler\n\tthttp.DefaultServerCodec.ErrHandler = func(w http.ResponseWriter, r *http.Request, e *errs.Error) {\n\t\t// Add custom error message to response body\n\t\tbody := errBody{\n\t\t\tCode: e.Code,\n\t\t\tMsg:  e.Msg,\n\t\t}\n\t\tbodyData, err := json.Marshal(body)\n\t\tif err != nil {\n\t\t\t// Should never happen\n\t\t\tpanic(err)\n\t\t}\n\n\t\tw.Header().Add(\"Content-Length\", strconv.Itoa(len(bodyData)))\n\t\tdefaultHandler(w, r, e)\n\t\tw.Write(bodyData)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_drgroup.go",
        "code_start_line": 176,
        "code_end_line": 198,
        "code_key": "getOrCreateDRGroup",
        "code_value": "func (c *UpdateLogicalVolumeDRGroupCommand) getOrCreateDRGroup(ctx context.Context, drgRepo drgroup.Repository, spec *drgroup.Spec) (*drgroup.DRGroup, error) {\n\tgroup, err := drgRepo.FindByName(ctx, c.AppID, spec.Name)\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\tgroup = drgroup.New(spec.Name, c.AppID)\n\t\t\tif spec.Affinity > 0 {\n\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t}\n\t\t\tif spec.Type != \"\" {\n\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t}\n\t\t\tif !c.DryRun {\n\t\t\t\terr := drgRepo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn group, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/attach_detach.go",
        "code_start_line": 247,
        "code_end_line": 297,
        "code_key": "UpdateFlowControlOnAllInitiator",
        "code_value": "func UpdateFlowControlOnAllInitiator(ctx context.Context, source rdiskDomain.LogicalVolumeState,\n\ttarget rdiskDomain.LogicalVolumeState, stateCtx app.LogicalVolumeContext) (state rdiskDomain.LogicalVolumeState, err error) {\n\n\tlv := stateCtx.GetLogicalVolume()\n\tif len(lv.Attachments) == 0 {\n\t\tlogs.Info(ctx).Str(\"uuid\", lv.UUID.String()).Msg(\"no attachment found, skip update flow control\")\n\t\treturn target, nil\n\t}\n\n\tvar wg sync.WaitGroup\n\tvar collectedErr []error = make([]error, len(lv.Attachments))\n\n\twg.Add(len(lv.Attachments))\n\n\tfor idx, attachment := range lv.Attachments {\n\t\tgo func(idx int, attachment *rdiskDomain.VolumeAttachment) {\n\t\t\tdefer wg.Done()\n\n\t\t\tblk := app.GetRegistry(ctx).Factories.BlockAgentClient(attachment.IP.String())\n\t\t\treq := cbs_blk_flow_agent.NewUpdateRDiskFlowControlRequest(lv.UUID.String(), lv.PhysicalVolume.DiskID)\n\t\t\treq.SpdkDriver = attachment.Options.SPDKDriver\n\t\t\treq.SetRead(attachment.FlowControlSpec.MaxReadIOPS, attachment.FlowControlSpec.MaxReadMBps)\n\t\t\treq.SetWrite(attachment.FlowControlSpec.MaxWriteIOPS, attachment.FlowControlSpec.MaxWriteMBps)\n\t\t\treq.SetReadWrite(attachment.FlowControlSpec.MaxRWIOPS, attachment.FlowControlSpec.MaxRWMBps)\n\n\t\t\terr = blk.UpdateRDiskFlowControl(ctx, req)\n\t\t\tif err != nil {\n\t\t\t\tlogs.Error(ctx).Err(err).Str(\"ip\", attachment.IP.String()).Msg(\"failed to update flow control\")\n\t\t\t}\n\t\t\tcollectedErr[idx] = err\n\t\t}(idx, attachment)\n\t}\n\n\twg.Wait()\n\n\t// collect error ip and print error count\n\tvar errList []error\n\tvar errIPs []string\n\tfor idx, err := range collectedErr {\n\t\tif err != nil {\n\t\t\terrList = append(errList, err)\n\t\t\terrIPs = append(errIPs, lv.Attachments[idx].IP.String())\n\t\t}\n\t}\n\tif len(errList) > 0 {\n\t\tlogs.Warn(ctx).Errs(\"errors\", errList).Strs(\"host_ips\", errIPs).Msg(\"failed to update flow control on some initiators\")\n\t\treturn source, errors.New(rdiskDomain.ErrUpdateFlowControl, fmt.Sprintf(\"failed to update flow control on some initiators: %v, errors: %v\", errIPs, errList))\n\t}\n\n\treturn target, err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/drgroups.go",
        "code_start_line": 22,
        "code_end_line": 71,
        "code_key": "AddHostToDRGroup",
        "code_value": "func AddHostToDRGroup(ctx context.Context, source rdiskDomain.LogicalVolumeState, target rdiskDomain.LogicalVolumeState, stateCtx app.LogicalVolumeContext) (rdiskDomain.LogicalVolumeState, error) {\n\tdata := stateCtx.(CreateLogicalVolumeContext)\n\tvol := data.GetLogicalVolume()\n\tphy := data.GetPhysicalVolume()\n\tspecs := data.GetDRGroupSpecList()\n\trepo := app.GetRegistry(ctx).Repositories.DRGroup\n\tif len(specs) == 0 {\n\t\treturn target, nil\n\t}\n\tfor _, spec := range specs {\n\t\tgroup, err := repo.FindByName(ctx, vol.AppID, spec.Name)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\tgroup = drgroup.New(spec.Name, vol.AppID)\n\t\t\t\tif spec.Affinity > 0 {\n\t\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t\t}\n\t\t\t\tif spec.Type != \"\" {\n\t\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t\t}\n\t\t\t\terr = repo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn source, err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn source, err\n\t\t\t}\n\t\t}\n\t\tif spec.Affinity > 0 && group.Affinity != spec.Affinity {\n\t\t\tlogs.Info(ctx).Uint64(\"app_id\", uint64(vol.AppID)).\n\t\t\t\tStr(\"group_name\", spec.Name).\n\t\t\t\tInt(\"old_affinity\", group.Affinity).\n\t\t\t\tInt(\"new_affinity\", spec.Affinity).\n\t\t\t\tMsg(\"update affinity of drgroup\")\n\t\t\tgroup.Affinity = spec.Affinity\n\t\t}\n\t\tsubGroup := spec.SubGroup\n\t\tif subGroup == \"\" {\n\t\t\t// 如果没有指定子组，则使用远端 SSD UUID 作为子组名称\n\t\t\t// 相当于每块盘都是一个子组，相当于没有使用子组功能\n\t\t\tsubGroup = vol.UUID.String()\n\t\t}\n\t\terr = group.AddMember(vol.UUID.String(), subGroup, phy.IP.String())\n\t\tif err != nil {\n\t\t\treturn source, err\n\t\t}\n\t}\n\n\treturn target, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/create_phy_disk.go",
        "code_start_line": 32,
        "code_end_line": 70,
        "code_key": "CreatePhysicalVolumeInRepository",
        "code_value": "func CreatePhysicalVolumeInRepository(ctx context.Context, source rdiskDomain.PhysicalVolumeState, target rdiskDomain.PhysicalVolumeState, stateCtx app.PhysicalVolumeContext) (rdiskDomain.PhysicalVolumeState, error) {\n\tcreateCtx := stateCtx.(CreatePhysicalVolumeContext)\n\tphysicalVolume := createCtx.GetPhysicalVolume()\n\tspec := createCtx.GetSpec()\n\tif err := rdiskDomain.CheckSerial(spec.Serial); err != nil {\n\t\treturn source, err\n\t}\n\tif physicalVolume != nil {\n\t\t*physicalVolume = *rdiskDomain.NewPhysicalVolume(spec.Serial, spec.IP, spec.BDF, spec.Size, spec.ZoneID, spec.Cuf)\n\t} else {\n\t\tphysicalVolume = rdiskDomain.NewPhysicalVolume(spec.Serial, spec.IP, spec.BDF, spec.Size, spec.ZoneID, spec.Cuf)\n\t}\n\tphysicalVolume.DataNodeType = spec.DataTypeNode\n\tif spec.VolumeType != \"\" {\n\t\tphysicalVolume.VolumeType = spec.VolumeType\n\t}\n\tif spec.PerformanceRank != \"\" {\n\t\tphysicalVolume.PerformanceRank = spec.PerformanceRank\n\t\tif !physicalVolume.PerformanceRank.IsValid() {\n\t\t\treturn source, errors.Newf(rdiskDomain.ErrInvalidPerformanceRank, \"invalid performance rank %s\", spec.PerformanceRank)\n\t\t}\n\t}\n\tphysicalVolume.State = target\n\tlogs.Info(ctx).\n\t\tStr(\"host_ip\", physicalVolume.IP.String()).\n\t\tStr(\"bdf\", string(physicalVolume.BDF)).\n\t\tStr(\"serial\", string(physicalVolume.Serial)).\n\t\tInt(\"zone_id\", int(physicalVolume.ZoneID)).\n\t\tStr(\"volume_type\", string(physicalVolume.VolumeType)).\n\t\tStr(\"cuf\", string(physicalVolume.Cuf)).\n\t\tStr(\"performance_rank\", string(physicalVolume.PerformanceRank)).\n\t\tMsg(\"created physical volume\")\n\n\terr := app.GetRegistry(ctx).Repositories.PhysicalVolume.Add(ctx, physicalVolume)\n\tif err != nil {\n\t\treturn source, err\n\t}\n\treturn target, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 214,
        "code_end_line": 239,
        "code_key": "StepGivenAPhysicalVol",
        "code_value": "func StepGivenAPhysicalVol(registry *app.Registry, value interface{}) *rdiskDomain.PhysicalVolume {\n\tphysicalVol := &rdiskDomain.PhysicalVolume{\n\t\tEntityMixin:  rdiskDomain.EntityMixin{ID: 1},\n\t\tSerial:       \"12345\",\n\t\tIP:           net.IP{127, 0, 0, 1},\n\t\tBDF:          \"bdf\",\n\t\tDiskID:       0,\n\t\tState:        rdiskDomain.PhysicalVolumeState(value.(int)),\n\t\tSize:         1,\n\t\tVolumeType:   \"NVME\",\n\t\tZoneID:       1,\n\t\tBlockSize:    512,\n\t\tRealSize:     5120,\n\t\tPort:         1,\n\t\tDataNodeType: \"unknown\",\n\t\tCuf:          \"清远-清新-C2\",\n\t}\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\terr := registry.Repositories.PhysicalVolume.Add(workerCtx, physicalVol)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn physicalVol\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 244,
        "code_end_line": 277,
        "code_key": "StepGivenPhysicalVols",
        "code_value": "func StepGivenPhysicalVols(registry *app.Registry, value interface{}, num interface{}) []*rdiskDomain.PhysicalVolume {\n\tvar physicalVols []*rdiskDomain.PhysicalVolume\n\tfor i := 0; i < num.(int); i++ {\n\t\tphysicalVols = append(physicalVols, &rdiskDomain.PhysicalVolume{\n\t\t\tEntityMixin:  rdiskDomain.EntityMixin{},\n\t\t\tSerial:       rdiskDomain.Serial(\"111\" + strconv.Itoa(i)),\n\t\t\tIP:           net.IP{127, 0, byte(((i + 2) / 255) % 255), byte((i + 2) % 255)},\n\t\t\tBDF:          \"bdf\",\n\t\t\tDiskID:       0,\n\t\t\tState:        rdiskDomain.PhysicalVolumeState(value.(int)),\n\t\t\tSize:         1,\n\t\t\tVolumeType:   \"\",\n\t\t\tZoneID:       1,\n\t\t\tBlockSize:    512,\n\t\t\tRealSize:     5120,\n\t\t\tPort:         1,\n\t\t\tDataNodeType: \"\",\n\t\t\tCuf:          \"清远-清新-C2\",\n\t\t})\n\t}\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\tfor _, vol := range physicalVols {\n\t\terr := registry.Repositories.PhysicalVolume.Add(workerCtx, vol)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\terr := uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn physicalVols\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 282,
        "code_end_line": 304,
        "code_key": "StepGivenALogicalVol",
        "code_value": "func StepGivenALogicalVol(registry *app.Registry, physicalVol *rdiskDomain.PhysicalVolume, value interface{}) *rdiskDomain.LogicalVolume {\n\tlogicalVol := &rdiskDomain.LogicalVolume{\n\t\tEntityMixin:     rdiskDomain.EntityMixin{ID: 1},\n\t\tUUID:            uuid.Must(uuid.NewRandom()),\n\t\tState:           rdiskDomain.LogicalVolumeState(value.(int)),\n\t\tSize:            1,\n\t\tAppID:           123,\n\t\tZoneID:          1,\n\t\tDiskType:        \"\",\n\t\tVolumeType:      \"\",\n\t\tFlowControlSpec: rdiskDomain.FlowControlSpec{},\n\t\tPhysicalVolume:  physicalVol,\n\t\tAttachments:     nil,\n\t}\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\terr := registry.Repositories.LogicalVolume.Add(workerCtx, logicalVol)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn logicalVol\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 527,
        "code_end_line": 564,
        "code_key": "StepWhenCreateSomeRDiskVol",
        "code_value": "func StepWhenCreateSomeRDiskVol(ctx context.Context, req interface{}) {\n\trequests := req.([]*pb.CreateRDiskVolRequest)\n\n\t// 创建一个 WaitGroup\n\tvar wg sync.WaitGroup\n\t// 创建一个通道来接收结果\n\tresults := make(chan *pb.CreateRDiskVolResponse, len(requests))\n\terrors := make(chan error, len(requests))\n\n\t// 创建一个 API 服务器实例\n\tapiServer := apiserver.NewMasterApiServer()\n\n\tstart := time.Now()\n\t// 遍历请求列表并启动 goroutine 发送请求\n\tfor _, req := range requests {\n\t\twg.Add(1)\n\t\tgo func(req *pb.CreateRDiskVolRequest) {\n\t\t\tdefer wg.Done()\n\t\t\trsp, err := apiServer.CreateRDiskVol(ctx, req)\n\t\t\tif err != nil {\n\t\t\t\terrors <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\tresults <- rsp\n\t\t}(req)\n\t}\n\n\t// 等待所有 goroutines 完成\n\twg.Wait()\n\tclose(results)\n\tclose(errors)\n\tfmt.Println(\"time:\", time.Since(start))\n\ttime.Sleep(2 * time.Second)\n\t// 处理错误\n\tfor err := range errors {\n\t\tfmt.Println(\"Error:\", err)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/benchmark.go",
        "code_start_line": 42,
        "code_end_line": 50,
        "code_key": "FindByUUID",
        "code_value": "func (repo *rdiskBenchmarkRepositoryImpl) FindByUUID(ctx context.Context, uuid string) (*benchmark.Benchmark, error) {\n\tuow := getUow(ctx)\n\tb := &metadb.DmRdiskBenchmark{}\n\tresult := uow.tx.First(b, \"uuid = ?\", uuid)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\treturn uow.trackedBenchmarks.Add(repo.fromDoToModel(b)), nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/backup.go",
        "code_start_line": 44,
        "code_end_line": 53,
        "code_key": "FindByUUID",
        "code_value": "func (impl *rdiskBackupRepositoryImpl) FindByUUID(ctx context.Context, uuid string) (*backupPkg.Backup, error) {\n\tuow := getUow(ctx)\n\n\tb := &metadb.DmRdiskBackup{}\n\tresult := uow.tx.First(b, \"uuid = ?\", uuid)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\treturn uow.trackedBackups.Add(impl.fromDOToModel(b)), nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go",
        "code_start_line": 22,
        "code_end_line": 47,
        "code_key": "FindByAppIDAndUUID",
        "code_value": "func (logicalVolumeRepositoryImpl) FindByAppIDAndUUID(ctx context.Context, appID users.AppID, id uuid.UUID) (*rdiskDomain.LogicalVolume, error) {\n\tuow := getUow(ctx)\n\tvol := metadb.DmRdisk{}\n\tresult := uow.tx.\n\t\tPreload(\"Attachments\").\n\t\tPreload(\"DmPhyDisk\").\n\t\tFirst(&vol, \"uuid = ? AND app_id = ?\", id.String(), appID)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tlv, err := fromDmRDiskToModel(ctx, &vol)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlv = uow.trackedLogicalVolumes.Add(lv)\n\tif lv.PhysicalVolume != nil {\n\t\tlv.PhysicalVolume = uow.trackedPhyVolumes.Add(lv.PhysicalVolume)\n\t}\n\treturn lv, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 55,
        "code_end_line": 61,
        "code_key": "FindByAppIDAndUUID",
        "code_value": "func (m *MockLogicalVolumeRepository) FindByAppIDAndUUID(arg0 context.Context, arg1 users.AppID, arg2 uuid.UUID) (*rdiskDomain.LogicalVolume, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByAppIDAndUUID\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(*rdiskDomain.LogicalVolume)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 64,
        "code_end_line": 67,
        "code_key": "FindByAppIDAndUUID",
        "code_value": "func (mr *MockLogicalVolumeRepositoryMockRecorder) FindByAppIDAndUUID(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByAppIDAndUUID\", reflect.TypeOf((*MockLogicalVolumeRepository)(nil).FindByAppIDAndUUID), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go",
        "code_start_line": 49,
        "code_end_line": 74,
        "code_key": "FindByID",
        "code_value": "func (l logicalVolumeRepositoryImpl) FindByID(ctx context.Context, id uuid.UUID) (*rdiskDomain.LogicalVolume, error) {\n\tuow := getUow(ctx)\n\tvol := metadb.DmRdisk{}\n\tresult := uow.tx.\n\t\tPreload(\"Attachments\").\n\t\tPreload(\"DmPhyDisk\").\n\t\tFirst(&vol, \"uuid = ?\", id.String())\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tlv, err := fromDmRDiskToModel(ctx, &vol)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlv = uow.trackedLogicalVolumes.Add(lv)\n\tif lv.PhysicalVolume != nil {\n\t\tlv.PhysicalVolume = uow.trackedPhyVolumes.Add(lv.PhysicalVolume)\n\t}\n\treturn lv, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 70,
        "code_end_line": 76,
        "code_key": "FindByID",
        "code_value": "func (m *MockLogicalVolumeRepository) FindByID(arg0 context.Context, arg1 uuid.UUID) (*rdiskDomain.LogicalVolume, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByID\", arg0, arg1)\n\tret0, _ := ret[0].(*rdiskDomain.LogicalVolume)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 79,
        "code_end_line": 82,
        "code_key": "FindByID",
        "code_value": "func (mr *MockLogicalVolumeRepositoryMockRecorder) FindByID(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByID\", reflect.TypeOf((*MockLogicalVolumeRepository)(nil).FindByID), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go",
        "code_start_line": 21,
        "code_end_line": 38,
        "code_key": "FindBySerial",
        "code_value": "func (p *physicalVolumeRepositoryImpl) FindBySerial(ctx context.Context, serial rdiskDomain.Serial) (*rdiskDomain.PhysicalVolume, error) {\n\tuow := getUow(ctx)\n\tvar vol metadb.DmPhydisk\n\tresult := uow.tx.Where(\"serial = ?\", string(serial)).First(&vol)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\t// 覆盖 gorm 的错误\n\t\t\treturn nil, errors.New(rdiskDomain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tpv := fromDmPhyDiskToPhysicalVolume(ctx, &vol)\n\tpv = uow.trackedPhyVolumes.Add(pv)\n\treturn pv, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 83,
        "code_end_line": 89,
        "code_key": "FindBySerial",
        "code_value": "func (m *MockPhysicalVolumeRepository) FindBySerial(arg0 context.Context, arg1 rdiskDomain.Serial) (*rdiskDomain.PhysicalVolume, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindBySerial\", arg0, arg1)\n\tret0, _ := ret[0].(*rdiskDomain.PhysicalVolume)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 92,
        "code_end_line": 95,
        "code_key": "FindBySerial",
        "code_value": "func (mr *MockPhysicalVolumeRepositoryMockRecorder) FindBySerial(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindBySerial\", reflect.TypeOf((*MockPhysicalVolumeRepository)(nil).FindBySerial), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go",
        "code_start_line": 40,
        "code_end_line": 57,
        "code_key": "FindByIPAndBDF",
        "code_value": "func (p *physicalVolumeRepositoryImpl) FindByIPAndBDF(ctx context.Context, ip net.IP, bdf rdiskDomain.BDF) (*rdiskDomain.PhysicalVolume, error) {\n\tuow := getUow(ctx)\n\tvar vol metadb.DmPhydisk\n\tresult := uow.tx.Where(\"host_ip = ? AND bdf = ?\", ip.String(), string(bdf)).Find(&vol)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\t// 覆盖 gorm 的错误\n\t\t\treturn nil, errors.New(rdiskDomain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tpv := fromDmPhyDiskToPhysicalVolume(ctx, &vol)\n\tpv = uow.trackedPhyVolumes.Add(pv)\n\treturn pv, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 68,
        "code_end_line": 74,
        "code_key": "FindByIPAndBDF",
        "code_value": "func (m *MockPhysicalVolumeRepository) FindByIPAndBDF(arg0 context.Context, arg1 net.IP, arg2 rdiskDomain.BDF) (*rdiskDomain.PhysicalVolume, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByIPAndBDF\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(*rdiskDomain.PhysicalVolume)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 77,
        "code_end_line": 80,
        "code_key": "FindByIPAndBDF",
        "code_value": "func (mr *MockPhysicalVolumeRepositoryMockRecorder) FindByIPAndBDF(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByIPAndBDF\", reflect.TypeOf((*MockPhysicalVolumeRepository)(nil).FindByIPAndBDF), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
        "code_start_line": 31,
        "code_end_line": 52,
        "code_key": "FindByNames",
        "code_value": "func (d drgroupRepositoryImpl) FindByNames(ctx context.Context, appId users.AppID, names []string) ([]*drgroup.DRGroup, error) {\n\tuow := getUow(ctx)\n\tgroup := []metadb.DmDrgroup{}\n\tresult := uow.tx.\n\t\tPreload(\"Members\").\n\t\tFind(&group, \"app_id = ? and name in ?\", appId, names)\n\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"disaster recovery group not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tresults := make([]*drgroup.DRGroup, len(group))\n\tfor i := range group {\n\t\tresults[i] = uow.trackedDRGroups.Add(fromDmDRGroupToModel(&group[i]))\n\t}\n\treturn results, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 113,
        "code_end_line": 119,
        "code_key": "FindByNames",
        "code_value": "func (m *MockRepository) FindByNames(arg0 context.Context, arg1 users.AppID, arg2 []string) ([]*drgroup.DRGroup, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByNames\", arg0, arg1, arg2)\n\tret0, _ := ret[0].([]*drgroup.DRGroup)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 122,
        "code_end_line": 125,
        "code_key": "FindByNames",
        "code_value": "func (mr *MockRepositoryMockRecorder) FindByNames(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByNames\", reflect.TypeOf((*MockRepository)(nil).FindByNames), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
        "code_start_line": 58,
        "code_end_line": 94,
        "code_key": "FindByMembers",
        "code_value": "func (d drgroupRepositoryImpl) FindByMembers(ctx context.Context, appId users.AppID, members []string) ([]*drgroup.DRGroup, error) {\n\tuow := getUow(ctx)\n\tgroup := []metadb.DmDrgroup{}\n\n\tmembersResult := []metadb.DmDrgroupMembers{}\n\tresult := uow.tx.\n\t\tFind(&membersResult, \"app_id = ? and member_id in ?\", appId, members)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tnames := make([]string, 0, len(members))\n\tfor i := range membersResult {\n\t\tnames = append(names, membersResult[i].GroupName)\n\t}\n\tresult = uow.tx.\n\t\tPreload(\"Members\").\n\t\tFind(&group, \"app_id = ? and name in ?\", appId, names)\n\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"disaster recovery group not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tresults := make([]*drgroup.DRGroup, len(group))\n\tfor i := range group {\n\t\tresults[i] = fromDmDRGroupToModel(&group[i])\n\t\tresults[i] = uow.trackedDRGroups.Add(results[i])\n\t}\n\treturn results, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/drgroup.go",
        "code_start_line": 92,
        "code_end_line": 124,
        "code_key": "FindByMembers",
        "code_value": "func (d *drgroupViewerImpl) FindByMembers(ctx context.Context, appId users.AppID, members []string) ([]*drgroup.View, error) {\n\tvar (\n\t\tresultViews       []drgroup.View\n\t\tresultViewRef     []*drgroup.View\n\t\tdataObjects       []*metadb.DmDrgroup\n\t\tdataObjectMembers []*metadb.DmDrgroupMembers\n\t)\n\tresult := d.db.WithContext(ctx).Find(&dataObjectMembers, \"app_id = ? and member_id in ?\", appId, members)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"group not exist\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tgroupNames := make([]string, len(dataObjectMembers))\n\tfor i := range dataObjectMembers {\n\t\tgroupNames[i] = dataObjectMembers[i].GroupName\n\t}\n\tresult = d.db.WithContext(ctx).Find(&dataObjects, \"app_id = ? and name in ?\", appId, groupNames)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"group not exist\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tresultViews = make([]drgroup.View, len(dataObjects))\n\tresultViewRef = make([]*drgroup.View, len(dataObjects))\n\tfor i := range dataObjects {\n\t\tresultViewRef[i] = &resultViews[i]\n\t\td.translate(dataObjects[i], resultViewRef[i])\n\t}\n\treturn resultViewRef, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 83,
        "code_end_line": 89,
        "code_key": "FindByMembers",
        "code_value": "func (m *MockRepository) FindByMembers(arg0 context.Context, arg1 users.AppID, arg2 []string) ([]*drgroup.DRGroup, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByMembers\", arg0, arg1, arg2)\n\tret0, _ := ret[0].([]*drgroup.DRGroup)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 92,
        "code_end_line": 95,
        "code_key": "FindByMembers",
        "code_value": "func (mr *MockRepositoryMockRecorder) FindByMembers(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByMembers\", reflect.TypeOf((*MockRepository)(nil).FindByMembers), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/view.go",
        "code_start_line": 55,
        "code_end_line": 61,
        "code_key": "FindByMembers",
        "code_value": "func (m *MockViewer) FindByMembers(arg0 context.Context, arg1 users.AppID, arg2 []string) ([]*drgroup.View, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByMembers\", arg0, arg1, arg2)\n\tret0, _ := ret[0].([]*drgroup.View)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/view.go",
        "code_start_line": 64,
        "code_end_line": 67,
        "code_key": "FindByMembers",
        "code_value": "func (mr *MockViewerMockRecorder) FindByMembers(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByMembers\", reflect.TypeOf((*MockViewer)(nil).FindByMembers), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 178,
        "code_end_line": 233,
        "code_key": "updateReadLocks",
        "code_value": "func (l *mysqlLocker) updateReadLocks(tx *gorm.DB, ttl time.Duration, keys []string, lockTokens []string) ([]string, []string, []string, error) {\n\tif len(keys) == 0 {\n\t\treturn nil, nil, lockTokens, nil\n\t}\n\ttype Result struct {\n\t\tLock       string\n\t\tExpiration time.Time\n\t\tToken      string\n\t}\n\tvar Results []Result\n\terr := tx.Raw(\"SELECT `\"+l.lockColumn+\"` AS `lock`, `\"+l.expireColumn+\"` AS `expiration`, `\"+l.tokenColumn+\"` AS `token` FROM \"+l.tableName+\" WHERE `\"+l.lockColumn+\"` IN (?)\", keys).Scan(&Results).Error\n\tif err != nil {\n\t\treturn nil, nil, nil, errors.Wrap(err, \"fail to query locks\")\n\t}\n\n\tvar needUpdateExpirationReadKeys []string = nil\n\tvar needUpdateCountReadKeys []string = nil\n\tl.mutex.Lock()\n\tt := time.Now()\n\tfor _, r := range Results {\n\t\tif r.Token != lockTokens[0] {\n\t\t\tlockTokens = append(lockTokens, r.Token)\n\t\t}\n\t\tif readKey, exist := l.readKeysMemLock[r.Lock]; exist {\n\t\t\treadKey.count++\n\t\t\treadKey.expiration = r.Expiration\n\t\t} else {\n\t\t\tl.readKeysMemLock[r.Lock] = &readKeysMemLock{\n\t\t\t\tcount:      1,\n\t\t\t\texpiration: r.Expiration,\n\t\t\t\ttoken:      r.Token,\n\t\t\t}\n\t\t\tneedUpdateCountReadKeys = append(needUpdateCountReadKeys, r.Lock)\n\t\t}\n\t\tif l.readKeysMemLock[r.Lock].expiration.Sub(t) < ttl/3 {\n\t\t\tl.readKeysMemLock[r.Lock].expiration = t.Add(ttl)\n\t\t\tneedUpdateExpirationReadKeys = append(needUpdateExpirationReadKeys, r.Lock)\n\t\t}\n\t}\n\tl.mutex.Unlock()\n\tif len(needUpdateExpirationReadKeys) > 0 {\n\t\tresult := tx.Exec(\"UPDATE \"+l.tableName+\" SET \"+l.expireColumn+\" = NOW() + INTERVAL ? SECOND WHERE `\"+l.lockColumn+\"` IN (?)\", ttl.Seconds(), needUpdateExpirationReadKeys)\n\t\tif result.Error != nil {\n\t\t\treturn nil, needUpdateExpirationReadKeys, needUpdateCountReadKeys, errors.Wrap(result.Error, fmt.Sprintf(\"failed to update readLocks: %s\", keys))\n\t\t}\n\t}\n\n\tif len(needUpdateCountReadKeys) > 0 {\n\t\tresult := tx.Exec(\"UPDATE \"+l.tableName+\" SET \"+l.lockNumsColumn+\" = \"+l.lockNumsColumn+\" + 1 WHERE `\"+l.lockColumn+\"` IN (?)\", needUpdateCountReadKeys)\n\t\tif result.Error != nil {\n\t\t\treturn nil, needUpdateExpirationReadKeys, needUpdateCountReadKeys, errors.Wrap(result.Error, fmt.Sprintf(\"failed to update readLocks: %s\", keys))\n\t\t}\n\t}\n\n\treturn nil, nil, lockTokens, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 335,
        "code_end_line": 369,
        "code_key": "insertLocks",
        "code_value": "func (l *mysqlLocker) insertLocks(tx *gorm.DB, lockKeys []*dlock.LockKey, ttl time.Duration, lockToken []string) ([]string, error) {\n\tif len(lockKeys) <= 0 {\n\t\treturn nil, nil\n\t}\n\tstmt := strings.Builder{}\n\targs := make([]interface{}, 0, len(lockKeys)*5)\n\tt := time.Now().Add(ttl)\n\tstmt.WriteString(fmt.Sprintf(\"INSERT INTO `%s` (`%s`, `%s`, `%s`, `%s`, `%s`) VALUES \", l.tableName, l.lockColumn, l.expireColumn, l.tokenColumn, l.lockTypeColumn, l.lockNumsColumn))\n\tfor i, key := range lockKeys {\n\t\tif i > 0 {\n\t\t\tstmt.WriteString(\", \")\n\t\t}\n\t\tstmt.WriteString(\"(?, NOW() + INTERVAL ? SECOND, ?, ?, ?)\")\n\t\targs = append(args, key.Key, ttl.Seconds(), lockToken[0], int(key.Type), 1)\n\t}\n\n\tresult := tx.Exec(stmt.String(), args...)\n\tif result.Error != nil {\n\t\treturn nil, errors.Wrap(result.Error, \"failed to insert locks\")\n\t}\n\tvar needInsertReadKeys []string = nil\n\tl.mutex.Lock()\n\tfor _, key := range lockKeys {\n\t\tif key.Type == dlock.ReadLock {\n\t\t\tl.readKeysMemLock[key.Key] = &readKeysMemLock{\n\t\t\t\tcount:      1,\n\t\t\t\texpiration: t,\n\t\t\t\ttoken:      lockToken[0],\n\t\t\t}\n\t\t\tneedInsertReadKeys = append(needInsertReadKeys, key.Key)\n\t\t}\n\t}\n\tl.mutex.Unlock()\n\treturn needInsertReadKeys, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 417,
        "code_end_line": 470,
        "code_key": "tryObtainMulti",
        "code_value": "func (l *mysqlLocker) tryObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, tokens []string, opts *dlock.Option) ([]string, error) {\n\t// Starts a new transaction.\n\ttx := l.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\n\n\t// Fetch existing locks.\n\texistingReadKeys, existingWriteKeys, expiredKeys, err := l.fetchExistingLocks(tx, keys)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// If there are existing valid locks, return an error.\n\tif len(existingWriteKeys) > 0 {\n\t\t_ = tx.Rollback()\n\t\treturn nil, errors.Wrap(dlock.ErrLockNotHeld, fmt.Sprintf(\"writeKeys %v are already locked\", existingWriteKeys))\n\t}\n\n\t// Delete expired locks if exists.\n\tif err := l.deleteExpiredLocks(tx, expiredKeys); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Remove existing readLocks from insert.\n\t// NOCA:QCloudAkCheck(误报)\n\tlockKeys, err := l.removeExistingReadLocksFromInsert(tx, keys, existingReadKeys)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Insert locks into database.\n\tneedInsertReadKeys, err := l.insertLocks(tx, lockKeys, ttl, tokens)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Update readLocks.\n\tvar needUpdateExpirationReadKeys []string = nil\n\tvar needUpdateCountReadKeys []string = nil\n\tif needUpdateExpirationReadKeys, needUpdateCountReadKeys, tokens, err = l.updateReadLocks(tx, ttl, existingReadKeys, tokens); err != nil {\n\t\tl.rollback(needUpdateCountReadKeys, tokens)\n\t\tl.rollback(needUpdateExpirationReadKeys, tokens)\n\t\tl.rollback(needInsertReadKeys, tokens)\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\tif result := tx.Commit(); result.Error != nil {\n\t\treturn nil, errors.Wrap(result.Error, \"failed to commit transaction\")\n\t}\n\n\treturn tokens, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mem/memdlock.go",
        "code_start_line": 106,
        "code_end_line": 166,
        "code_key": "tryObtainMulti",
        "code_value": "func (l *memLocker) tryObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, token string) (dlock.Lock, error) {\n\tl.mutex.Lock()\n\tdefer l.mutex.Unlock()\n\tvar readLocks []*dlock.LockKey\n\tvar writeLocks []*dlock.LockKey\n\tvar insertLocks []*dlock.LockKey\n\tvar tokens []string\n\ttokens = append(tokens, token)\n\tfor _, key := range keys {\n\t\tif key.Type == dlock.WriteLock {\n\t\t\twriteLocks = append(writeLocks, key)\n\t\t} else {\n\t\t\treadLocks = append(readLocks, key)\n\t\t}\n\t}\n\tfor _, key := range writeLocks {\n\t\tif item, ok := l.data[key.Key]; ok {\n\t\t\tif time.Until(item.ttl) > 0 {\n\t\t\t\treturn nil, dlock.ErrNotObtained\n\t\t\t} else {\n\t\t\t\tinsertLocks = append(insertLocks, key)\n\t\t\t}\n\t\t} else {\n\t\t\tinsertLocks = append(insertLocks, key)\n\t\t}\n\t}\n\tfor _, key := range readLocks {\n\t\tif item, ok := l.data[key.Key]; ok {\n\t\t\tif item.lockType == dlock.ReadLock {\n\t\t\t\tif time.Until(item.ttl) > 0 {\n\t\t\t\t\titem.count++\n\t\t\t\t\titem.ttl = time.Now().Add(ttl)\n\t\t\t\t\ttokens = append(tokens, item.token)\n\t\t\t\t} else {\n\t\t\t\t\tinsertLocks = append(insertLocks, key)\n\t\t\t\t}\n\t\t\t} else if time.Until(item.ttl) > 0 {\n\t\t\t\treturn nil, dlock.ErrNotObtained\n\t\t\t}\n\t\t} else {\n\t\t\tinsertLocks = append(insertLocks, key)\n\t\t}\n\t}\n\n\tfor _, key := range insertLocks {\n\t\tl.data[key.Key] = &lockItem{\n\t\t\tkey:      key.Key,\n\t\t\tttl:      time.Now().Add(ttl),\n\t\t\ttoken:    token,\n\t\t\tlockType: key.Type,\n\t\t\tcount:    1,\n\t\t}\n\t}\n\n\tlock := &memLock{\n\t\tlocker: l,\n\t\tkeys:   keys,\n\t\ttokens: tokens,\n\t}\n\treturn lock, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 473,
        "code_end_line": 520,
        "code_key": "ObtainMulti",
        "code_value": "func (l *mysqlLocker) ObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, opts *dlock.Option) (dlock.Lock, error) {\n\tif len(keys) == 0 {\n\t\treturn nil, errors.New(\"keys cannot be empty\")\n\t}\n\tkeys = dedupAndSort(keys)\n\n\t// Get the lock token.\n\tlockToken, err := l.getOrCreateLockToken(opts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tretryStrategy := dlock.NoRetry()\n\tif opts != nil && opts.RetryStrategy != nil {\n\t\tretryStrategy = opts.RetryStrategy\n\t}\n\n\tretries := 0\n\tlogger := logs.GetLogger(ctx).With().Strs(\"keys\", dlock.LockKeySlice(keys).GetKeys()).Strs(\"tokens\", lockToken).Logger()\n\n\tfor {\n\t\t// Try to obtain the locks.\n\t\t// If the locks are not obtained, retry based on the retry strategy.\n\t\tif tokens, err := l.tryObtainMulti(ctx, keys, ttl, lockToken, opts); err != nil {\n\t\t\t// If context is canceled, return immediately.\n\t\t\tif ctx.Err() != nil {\n\t\t\t\treturn nil, errors.Wrap(dlock.ErrNotObtained, \"context is canceled\")\n\t\t\t}\n\n\t\t\t// If the lock is not obtained, retry.\n\t\t\twaitDuration := retryStrategy.NextBackoff()\n\t\t\tif waitDuration <= 0 {\n\t\t\t\tlogger.Debug().Int(\"retry\", retries).Msg(\"stop retrying lock\")\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tlogger.Debug().Int(\"retry\", retries).Msg(\"retry obtaining lock\")\n\t\t\ttime.Sleep(waitDuration)\n\t\t} else {\n\t\t\tlockToken = tokens\n\t\t\tlogger.Debug().Msg(\"lock obtained\")\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// TODO xuanzeng: 这里采用内部记录 TTL 的方式，可能和底层的数据库时间不同步，后续应该从数据库中获取过期时间。\n\tlock := &mysqlLock{keys: keys, locker: l, tokens: lockToken, expiration: time.Now().Add(ttl)}\n\treturn lock, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mem/memdlock.go",
        "code_start_line": 74,
        "code_end_line": 103,
        "code_key": "ObtainMulti",
        "code_value": "func (l *memLocker) ObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, opts *dlock.Option) (dlock.Lock, error) {\n\tvar token string\n\tif opts == nil || opts.Token == \"\" {\n\t\ttoken = uuid.New().String()\n\t} else {\n\t\ttoken = opts.Token\n\t}\n\n\tretryStrategy := dlock.NoRetry()\n\tif opts != nil && opts.RetryStrategy != nil {\n\t\tretryStrategy = opts.RetryStrategy\n\t}\n\n\tfor {\n\t\tlock, err := l.tryObtainMulti(ctx, keys, ttl, token)\n\t\tif err == nil {\n\t\t\treturn lock, nil\n\t\t}\n\n\t\tif ctx.Err() != nil {\n\t\t\treturn nil, ctx.Err()\n\t\t}\n\n\t\twaitInterval := retryStrategy.NextBackoff()\n\t\tif waitInterval <= 0 {\n\t\t\treturn nil, dlock.ErrNotObtained\n\t\t}\n\t\ttime.Sleep(waitInterval)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 67,
        "code_end_line": 83,
        "code_key": "PhysicalVolume",
        "code_value": "type PhysicalVolume struct {\n\tEntityMixin\n\tSerial          Serial              // 物理卷序列号\n\tIP              net.IP              // 物理卷所在主机 IP\n\tBDF             BDF                 // 物理卷所在主机的 BDF\n\tDiskID          uint64              // 物理卷在主机上的 BDev ID\n\tState           PhysicalVolumeState // 物理卷状态\n\tSize            Size                // 物理卷对外售卖大小 GiB\n\tVolumeType      VolumeType          // 物理卷类型\n\tZoneID          ZoneID              // 物理卷所在的 Zone\n\tBlockSize       uint                // 物理卷块大小，通常为 512\n\tRealSize        uint64              // 物理卷实际大小，单位为 Byte\n\tPort            uint                // 物理卷所在主机的端口\n\tDataNodeType    DataNodeType        // 数据节点类型\n\tCuf             Cuf                 // 存储节点 CUF 信息\n\tPerformanceRank PerformanceRank     // 物理卷性能等级\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go:76:91:Add": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go",
    "code_start_line": 76,
    "code_end_line": 91,
    "code_start_column": 38,
    "code_key": "Add",
    "code_value": "func (l logicalVolumeRepositoryImpl) Add(ctx context.Context, lv *rdiskDomain.LogicalVolume) error {\n\tuow := getUow(ctx)\n\tvol := fromModelToDmRDisk(lv)\n\tvol.Created = uow.tx.NowFunc()\n\tvol.Updated = uow.tx.NowFunc()\n\tresult := uow.tx.Create(&vol)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tlv.ID = vol.ID\n\tlv = uow.trackedLogicalVolumes.Add(lv)\n\tif lv.PhysicalVolume != nil {\n\t\tlv.PhysicalVolume = uow.trackedPhyVolumes.Add(lv.PhysicalVolume)\n\t}\n\treturn nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/infra/event_bus/bus.go",
        "code_start_line": 61,
        "code_end_line": 79,
        "code_key": "Execute",
        "code_value": "func (eb *EventBusDriver) Execute(ctx context.Context) (result *response.Result) {\n\tresult = response.DefaultResult()\n\tdefer utils.HandlePanic(ctx, &result)\n\n\tfor _, event := range eb.BlockEventQueue {\n\t\tresult = eb.ExecuteOne(ctx, event)\n\t\tif result.IsSuccess() {\n\t\t\tevent.UpdateState(ctx, Executed)\n\t\t} else {\n\t\t\tlogs.Warn(ctx).Err(result).Int(\"EventType\", int(event.GetType(ctx))).\n\t\t\t\tMsg(\"event execute failed, start rollback event bus\")\n\t\t\tif err := eb.RollbackEvents(ctx); err != nil {\n\t\t\t\tlogs.Error(ctx).Err(err).Int(\"EventType\", int(event.GetType(ctx))).Msg(\"rollback event bus failed\")\n\t\t\t}\n\t\t\treturn result\n\t\t}\n\t}\n\treturn result\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/filters/filter.go",
        "code_start_line": 26,
        "code_end_line": 46,
        "code_key": "Execute",
        "code_value": "func (f FilterChain) Execute(ctx context.Context, disks []*disk.Disk, user *account.User,\n\tcacheMap cache.RDCacheManagerInf, affinityConfig *dto.AffinityConfig) ([]*disk.Disk, response.Result) {\n\tlogs.Info(ctx).Int(\"disk_count\", len(disks)).Msg(\"DISK_COUNT_BEFORE_FILTER\")\n\tfor _, filter := range f.filters {\n\t\tdisks, result := filter.\n\t\t\tWithUser(ctx, user).\n\t\t\tWithRdCacheManager(ctx, cacheMap).\n\t\t\tWithAffinityConfig(ctx, affinityConfig).\n\t\t\tFilter(ctx, disks)\n\t\tdisks = disk.SortByScore(ctx, disks)\n\t\tlogs.Info(ctx).\n\t\t\tInt(\"disk_count\", len(disks)).\n\t\t\tStr(\"filter\", reflect.TypeOf(filter).Name()).\n\t\t\tMsg(\"LEFT_DISK_COUNT_AFTER_FILTER\")\n\t\tif result.IsFailed() {\n\t\t\treturn disks, result\n\t\t}\n\t}\n\t// 对盘的Score进行排序\n\treturn disks, response.SucResult()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_bill_compute_task.go",
        "code_start_line": 26,
        "code_end_line": 40,
        "code_key": "Execute",
        "code_value": "func (t *SnapBillComputeTask) Execute(ctx context.Context) (bool, error) {\n\tt.Ctx = ctx\n\tt.InitTask(ctx)\n\tdefer t.MqIns.Close()\n\n\t// 获取待处理的用户资源\n\tgo t.GetUserResources()\n\t// 执行Ack确认逻辑\n\tgo t.AckAppId()\n\t// 处理用户资源\n\tt.ProcessUserResources()\n\n\tlogs.Info(ctx).Msg(\"SNAP_COMPUTE_TASK_DONE\")\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_calculate_cost_locally_task.go",
        "code_start_line": 21,
        "code_end_line": 37,
        "code_key": "Execute",
        "code_value": "func (t *SnapCalculateCostLocallyTask) Execute(ctx context.Context) (bool, error) {\n\tt.ctx = ctx\n\tsnapRecSrv := measureReconciliation.NewReconciliationSrvImpl(ctx)\n\n\t// 结算上上个周期的用量\n\tnow := time.Now()\n\tstartTime := now.Truncate(time.Hour).Add(-2 * time.Hour)\n\tendTime := now.Truncate(time.Hour).Add(-1 * time.Hour).Add(-1 * time.Second)\n\tlogs.Info(t.ctx).Time(\"startTime\", startTime).Time(\"endTime\", endTime).Msg(\"START_CALCULATE_COST_LOCALLY\")\n\terr := snapRecSrv.CalculateCostLocally(startTime, endTime)\n\tif err != nil {\n\t\tlogs.Error(t.ctx).Err(err).Msg(\"CALCULATE_COST_LOCALLY_ERROR\")\n\t\treturn false, err\n\t}\n\tlogs.Info(t.ctx).Msg(\"CALCULATE_COST_LOCALLY_DONE\")\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/cbs_bill_compute_task.go",
        "code_start_line": 26,
        "code_end_line": 42,
        "code_key": "Execute",
        "code_value": "func (t *CbsBillComputeTask) Execute(ctx context.Context) (bool, error) {\n\tt.Ctx = ctx\n\tt.InitTask(ctx)\n\tdefer t.MqIns.Close()\n\n\t// 获取待处理的用户资源\n\tgo t.GetUserResources()\n\t// 执行Ack确认逻辑\n\tgo t.AckAppId()\n\t// 处理用户资源\n\tt.ProcessUserResources()\n\tt.ChargeItemProducer.Close()\n\n\tt.WG.Wait()\n\tlogs.Info(ctx).Msg(\"CBS_COMPUTE_TASK_DONE\")\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/update_ccbs_normal_rb_task.go",
        "code_start_line": 23,
        "code_end_line": 34,
        "code_key": "Execute",
        "code_value": "func (t *UpdateCCbsNormalRollbackTask) Execute(ctx context.Context) (bool, error) {\n\tt.Count += 1\n\tserv := registry.GetRegistry(ctx).DomainServices.DiskRollbackingService.(diskLogical.DiskRollbackingServiceInterface)\n\tisFinish, err := serv.UpdateCbsRollbackingPercent(ctx, t.DiskAggregate)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tlogs.Info(ctx).Int(\"Status\", t.DiskAggregate.DiskRecord.Status).\n\t\tInt(\"Percent\", t.DiskAggregate.DiskRecord.RollbackingPercent).\n\t\tInt(\"Count\", t.Count).Msg(\"FINISH_EXECUTE_TASK\")\n\treturn isFinish, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/repush_user_billing_task.go",
        "code_start_line": 53,
        "code_end_line": 61,
        "code_key": "Execute",
        "code_value": "func (t *RepushUserBillingTask) Execute(ctx context.Context) (bool, error) {\n\tt.ctx = ctx\n\tt.InitTask(ctx)\n\tdefer t.MqIns.Close()\n\n\tt.ProcessRepushDetailMsg()\n\tlogs.Info(ctx).Msg(\"REPUSH_USER_BILLING_TASK_DONE\")\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/update_create_task.go",
        "code_start_line": 31,
        "code_end_line": 69,
        "code_key": "Execute",
        "code_value": "func (t *UpdateCreateTask) Execute(ctx context.Context) (bool, error) {\n\tt.Count += 1\n\tserv := registry.GetRegistry(ctx).DomainServices.SnapCreatingService.(snapLogical.SnapCreatingServiceInterface)\n\tif t.SnapAggregate.SnapRecord.Status == ccdb.SnapCreating &&\n\t\tt.SnapAggregate.SnapRecord.LifeState == ccdb.SnapLifeStateNormal &&\n\t\tt.SnapAggregate.SnapRecord.Percent == 100 &&\n\t\tt.SnapAggregate.SnapRecord.Attribute != ccdb.SnapAttUserSnap {\n\t\t// 隐藏快照转正常快照\n\t\tlogs.Info(ctx).Msg(\"FIX_INNER_TO_NORMAL\")\n\t\terr := serv.SnapCreateTaskFollowup(ctx, t.SnapAggregate, SnapInnerFollowup)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\treturn true, nil\n\t}\n\n\tisFinish, err := serv.UpdateSnapCreatingPercent(ctx, t.SnapAggregate)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\t// 创建完成的用户快照进行后续操作，隐藏快照不进行\n\tif isFinish && t.SnapAggregate.SnapRecord.Status == ccdb.SnapNormal &&\n\t\tt.SnapAggregate.SnapRecord.LifeState == ccdb.SnapLifeStateNormal {\n\t\t// 目的端快照复制完成时，需更新源端的快照状态\n\t\t// 计算base snap size，并更新\n\t\t// merge\n\t\t// 插入计费，并更新快照大小\n\t\terr = serv.SnapCreateTaskFollowup(ctx, t.SnapAggregate, SnapNormalFollowup)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\n\tlogs.Info(ctx).Int(\"Status\", t.SnapAggregate.SnapRecord.Status).\n\t\tInt(\"Percent\", t.SnapAggregate.SnapRecord.Percent).\n\t\tInt(\"Count\", t.Count).Msg(\"FINISH_EXECUTE_TASK\")\n\treturn isFinish, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/update_image_snap_rb_task.go",
        "code_start_line": 23,
        "code_end_line": 41,
        "code_key": "Execute",
        "code_value": "func (t *UpdateImageSnapRollbackTask) Execute(ctx context.Context) (bool, error) {\n\tt.Count += 1\n\tserv := registry.GetRegistry(ctx).DomainServices.DiskRollbackingService.(diskLogical.DiskRollbackingServiceInterface)\n\tisFinish, err := serv.UpdateImageSnapRollbackingPercent(ctx, t.DiskAggregate)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif isFinish {\n\t\t// TODO：这里应该放入一个管道中，后续再优化\n\t\terr = serv.UpdateRollbackQuota(ctx, t.DiskAggregate)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\tlogs.Info(ctx).Str(\"Status\", t.DiskAggregate.ImageSnapRollbackRecord.Status).\n\t\tInt(\"Percent\", t.DiskAggregate.ImageSnapRollbackRecord.Percent).\n\t\tInt(\"Count\", t.Count).Msg(\"FINISH_EXECUTE_TASK\")\n\treturn isFinish, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/cbs_measure_send_task.go",
        "code_start_line": 30,
        "code_end_line": 54,
        "code_key": "Execute",
        "code_value": "func (t *CbsMeasureSendTask) Execute(ctx context.Context) (bool, error) {\n\t// 初始化各项配置\n\tt.Ctx = ctx\n\tt.InitTask(ctx)\n\tt.cbsSrv = cbsResource.NewCbsSrvImpl(t.Ctx)\n\tdefer t.MqIns.Close()\n\t// 根据区域分发到国内和国际两个不同channel中去处理\n\tt.ChannelDistribution()\n\n\t// MSG处理的生命周期Msg -->chargeItem -->MeasureDetails-->MeasureDetailsChannel-->Params-->Ack Msg\n\tgo t.ProcessMsgByRegion()\n\n\t// 计费详情转换成计费参数\n\tgo t.ProcessMeasureDetailToParams()\n\n\t// 执行ACK\n\tgo t.AckResourceID()\n\n\t// 根据计费参数发送计费消息\n\tt.ProcessParamsSendMeasure()\n\n\tt.WG.Wait()\n\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/cbs_rec_task.go",
        "code_start_line": 37,
        "code_end_line": 61,
        "code_key": "Execute",
        "code_value": "func (t *CbsMeasureRecTask) Execute(ctx context.Context) (bool, error) {\n\t// 初始化各项配置\n\tt.Ctx = ctx\n\tt.InitTask(ctx)\n\t// 初始化snapSrv\n\tt.cbsReSrv = measureReconciliation.NewReconciliationSrvImpl(t.Ctx)\n\tt.cbsSrv = cbsResource.NewCbsSrvImpl(t.Ctx)\n\tdefer t.MqIns.Close()\n\t// 根据区域分发到国内和国际两个不同channel中去处理\n\tt.ChannelDistribution()\n\n\t// MSG处理的生命周期Msg -->chargeItem -->subMeasureDetails-->subMeasureDetailsChannel-->db-->Ack Msg\n\tgo t.ProcessMsg()\n\n\t// 生成批次外发的计费对账数据\n\tgo t.ProcessMeasureDetailBatch()\n\n\t// 执行ACK\n\tgo t.AckResourceID()\n\n\t// 将计费数据外发到数据库\n\tt.ProcessMeasureToDb()\n\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_measure_send_task.go",
        "code_start_line": 27,
        "code_end_line": 49,
        "code_key": "Execute",
        "code_value": "func (t *SnapMeasureSendTask) Execute(ctx context.Context) (bool, error) {\n\t// 初始化各项配置\n\tt.Ctx = ctx\n\tt.InitTask(ctx)\n\tdefer t.MqIns.Close()\n\n\t// 根据区域分发到国内和国际两个不同channel中去处理\n\tt.ChannelDistribution()\n\n\t// 启动外发任务\n\tgo t.ProcessMsgByRegion()\n\n\t// 用量详情转换成计费协议\n\tgo t.ProcessMeasureDetailToParams()\n\n\t// 执行ACK\n\tgo t.AckResourceID()\n\n\t// 根据计费协议发送到计费客户端\n\tt.ProcessParamsSendMeasure()\n\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_rec_task.go",
        "code_start_line": 48,
        "code_end_line": 61,
        "code_key": "Execute",
        "code_value": "func (t *SnapMeasureReconciliationTask) Execute(ctx context.Context) (bool, error) {\n\t// 初始化各项配置\n\tt.ctx = ctx\n\tt.initTask()\n\n\t// 将数据推送到数据库\n\tvar wg sync.WaitGroup\n\tgo t.sendDbFromMsg(&wg)\n\n\t// 执行ACK\n\tgo t.AckResourceID()\n\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/base_measure/base_appId_fetch_task.go",
        "code_start_line": 38,
        "code_end_line": 61,
        "code_key": "Execute",
        "code_value": "func (t *BaseAppIdFetchTask) Execute(ctx context.Context) (bool, error) {\n\tt.ctx = ctx\n\tt.initTask()\n\n\tappIds := t.resSrv.GetAppIdsWithValidResources(t.chargeTime)\n\tfor _, appId := range appIds {\n\t\tappIdItem := measure.AppIdInfo{\n\t\t\tAppId: appId,\n\t\t}\n\t\t// Send自带Confirm机制. error为nil表示发送成功\n\t\t// Send会阻塞等待Confirm，如果需要，可以考虑放协程里跑\n\t\terr := t.client.Send(ctx, measure.BuildRabbitRequest(&appIdItem))\n\t\tif err != nil {\n\t\t\tlogs.Error(ctx).Err(err).Msg(\"SEND_MESSAGE_FAILED\")\n\t\t\treturn false, err\n\t\t}\n\t\tlogs.Info(ctx).Interface(\"appId\", appId).Msg(\"SEND_MESSAGE_SUCCESS\")\n\t}\n\n\tstopChan := make(chan struct{})\n\t_ = t.server.Close(stopChan)\n\t<-stopChan\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/managers/shm.go",
        "code_start_line": 86,
        "code_end_line": 88,
        "code_key": "ListExpiredKeys",
        "code_value": "func (s *ShmCacheManager) ListExpiredKeys(ctx context.Context) []interface{} {\n\tpanic(\"implement me\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/subgroup.go",
        "code_start_line": 46,
        "code_end_line": 54,
        "code_key": "ListExpiredKeys",
        "code_value": "func (s *SubGroupCacheManager) ListExpiredKeys(ctx context.Context) []interface{} {\n\tvar expiredKeys []interface{}\n\tfor expireTime, keys := range s.cacheMap.GetExpireTimeMap() {\n\t\tif time.Now().Add(time.Duration(SafeReserveSeconds)*time.Second).Unix() >= expireTime {\n\t\t\texpiredKeys = append(expiredKeys, keys...)\n\t\t}\n\t}\n\treturn expiredKeys\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/filters/dmg.go",
        "code_start_line": 107,
        "code_end_line": 133,
        "code_key": "filterWithHostAff",
        "code_value": "func (r RdPlacementGroupFilter) filterWithHostAff(ctx context.Context, disks []*disk.Disk) []*disk.Disk {\n\t/**\n\t检查母机置放群组亲和性\n\t\t1. 检查单母机绑定的置放群组子组数量不会超过置放群组亲和度限制\n\t    2. 置放群组是强制性装箱规则，不满足置放群组的盘被舍弃掉\n\t*/\n\tif len(disks) == 0 {\n\t\treturn disks\n\t}\n\twg := &sync.WaitGroup{}\n\twg.Add(len(disks))\n\n\tfor _, oneDisk := range disks {\n\t\tgo r.checkHostAffWithSingleDisk(ctx, oneDisk, wg)\n\t}\n\twg.Wait()\n\n\t// 对置放群组亲和性检查的盘进行过滤,打标分数小于0的过滤掉\n\tdiskSlice := make([]*disk.Disk, 0, 100000)\n\tfor _, oneDisk := range disks {\n\t\tif oneDisk.Score >= 0 {\n\t\t\tdiskSlice = append(diskSlice, oneDisk)\n\t\t}\n\t}\n\treturn diskSlice\n\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/tracker.go",
        "code_start_line": 67,
        "code_end_line": 77,
        "code_key": "Refresh",
        "code_value": "func (rdp *PhyDiskTracker) Refresh(ctx context.Context) {\n\trdp.Track(ctx)\n\tlock.RDPhyCacheGlobalLock.GetLocker(lock.RDPhyLockKeyGenerator{}).Lock()\n\trdp.Merge(ctx, rdp.OriPhyDisks)\n\tlogs.Info(ctx).\n\t\tInt(\"disk_num\", len(rdp.ToCachedPhyDisks)).\n\t\tInt(\"member_num\", len(rdp.DrgroupMembers)).\n\t\tMsg(\"CACHE_AVAILABLE_PHY_DISK_AFTER_MERGE\")\n\trdp.CacheManager.RefreshCache(ctx, rdp.ToCachedPhyDisks, rdp.DrgroupMembers)\n\tlock.RDPhyCacheGlobalLock.GetLocker(lock.RDPhyLockKeyGenerator{}).Unlock()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/set/cache/tracker.go",
        "code_start_line": 35,
        "code_end_line": 38,
        "code_key": "Refresh",
        "code_value": "func (d *DiskSetTracker) Refresh(ctx context.Context) {\n\td.Track(ctx)\n\td.CacheManager.RefreshCache(ctx, d.DiskSetEntityInf)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 644,
        "code_end_line": 674,
        "code_key": "Refresh",
        "code_value": "func (l *mysqlLock) Refresh(ctx context.Context, ttl time.Duration) error {\n\n\ttx := l.locker.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\n\n\tkeysKey := dlock.LockKeySlice(l.keys).GetKeys()\n\t// NOCA:QCloudAkCheck(误报)\n\texistingLocks, err := l.locker.fetchExistingLocksByKeysAndTokens(tx, keysKey, l.tokens)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn err\n\t}\n\n\t// Compare existing locks with the keys.\n\tif !checkStrSetEqual(existingLocks, keysKey) {\n\t\t_ = tx.Rollback()\n\t\treturn errors.Wrap(dlock.ErrLockNotHeld, \"lock is not held\")\n\t}\n\n\t// Update the expiration time.\n\tif err := l.locker.updateLocksTTLByKeysAndTokens(tx, keysKey, l.tokens, ttl); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn err\n\t}\n\n\tif result := tx.Commit(); result.Error != nil {\n\t\treturn errors.Wrap(result.Error, \"failed to commit refresh locks\")\n\t}\n\n\tl.expiration = time.Now().Add(ttl)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mem/memdlock.go",
        "code_start_line": 189,
        "code_end_line": 210,
        "code_key": "Refresh",
        "code_value": "func (l *memLock) Refresh(ctx context.Context, ttl time.Duration) error {\n\tl.locker.mutex.Lock()\n\tdefer l.locker.mutex.Unlock()\n\n\ttokens := make(map[string]struct{}, len(l.tokens))\n\tfor _, item := range l.tokens {\n\t\ttokens[item] = struct{}{}\n\t}\n\tfor _, key := range l.keys {\n\t\tif item, ok := l.locker.data[key.Key]; ok {\n\t\t\tif _, exist := tokens[item.token]; !exist {\n\t\t\t\treturn dlock.ErrLockNotHeld\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, key := range l.keys {\n\t\tl.locker.data[key.Key].ttl = time.Now().Add(ttl)\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go",
        "code_start_line": 51,
        "code_end_line": 72,
        "code_key": "Handle",
        "code_value": "func (c *CbsAppIdConsumer) Handle(ctx context.Context, delivery *rabbitmq.Delivery) error {\n\tu, chargeTime, err := c.ParseDelivery(ctx, delivery)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif u == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"USER_INFO_NOT_FOUND\")\n\t\treturn nil\n\t}\n\n\tchargeDetail := c.GetChargeDetailForSingleUser(u, chargeTime)\n\tif chargeDetail == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tUint64(\"appId\", uint64(u.AppId)).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"NO_RESOURCE_TO_CHARGE\")\n\t\treturn nil\n\t}\n\treturn c.ProcessChargeDetail(chargeDetail)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 105,
        "code_end_line": 116,
        "code_key": "Handle",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tif err := c.ensureLocks(ctx); err != nil {\n\t\treturn err\n\t}\n\tif c.lvUUID != nil {\n\t\t// 涉及到逻辑卷时，需要先标记逻辑卷为故障\n\t\treturn c.handleBindedVolume(ctx)\n\t} else {\n\t\t// 不涉及到逻辑卷时，直接标记物理卷为故障\n\t\treturn c.handleIdleVolume(ctx)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/detach_logical_volume.go",
        "code_start_line": 56,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *DetachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDetachLogicalVolume, c)\n\n\t// 如果没有挂载到指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume not attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_benchmark_task.go",
        "code_start_line": 125,
        "code_end_line": 165,
        "code_key": "Handle",
        "code_value": "func (c *CreateBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tvolSm     = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = volSm.Fire(ctx, c.relatedVolume.State, domain.PVEStartBenchmark, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark = benchmark.New(benchmark.DiskInfo{\n\t\tSerial: string(c.relatedVolume.Serial),\n\t\tHostIP: c.relatedVolume.IP,\n\t\tBDF:    string(c.relatedVolume.BDF),\n\t})\n\n\tif err = benchRepo.Add(ctx, c.relatedBenchmark); err != nil {\n\t\tdelegate := &benchmarkDelegate{cmd: c}\n\t\tif _err := delegate.TaskFinishCallback(ctx, c.relatedBenchmark); _err != nil {\n\t\t\tlogs.Warn(ctx).Err(_err).Str(\"serial\", string(c.relatedVolume.Serial)).Msg(\"failed to rollback: create bdev\")\n\t\t}\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventCreateBench,\n\t\tbenchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_logical_volume.go",
        "code_start_line": 71,
        "code_end_line": 108,
        "code_key": "Handle",
        "code_value": "func (d *DeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\td.volume, err = repo.FindByID(ctx, d.UUID)\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif e := d.volume.CheckDelete(); e != nil {\n\t\treturn e\n\t}\n\n\tif d.volume.AppID != d.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"refuse to delet: app id mismatch\")\n\t}\n\n\td.drgroup, err = app.GetRegistry(ctx).Repositories.DRGroup.FindByMember(ctx, d.AppID, d.volume.UUID.String())\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\td.drgroup = nil\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := d.checkDRGroupMatch(ctx); err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, d.volume.State, rdiskDomain.LVEMarkToRecycle, d)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_recycled_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmRecycledPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEConfirmRecycled, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_rdisk_backup.go",
        "code_start_line": 52,
        "code_end_line": 75,
        "code_key": "Handle",
        "code_value": "func (c *DeleteRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tsm   = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\tc.relatedBackup, err = repo.FindByUUID(ctx, c.BackupID.String())\n\tif err != nil || c.relatedBackup == nil || c.relatedBackup.AppID != c.AppID {\n\t\treturn errors.New(backupDomain.ErrBackupNotExist, \"backup not exists\")\n\t}\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tc.relatedBackup.Status,\n\t\tbackupDomain.EventSoftDeleteBackup,\n\t\tbackupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: c.relatedBackup})\n\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_rdisk_backup.go",
        "code_start_line": 47,
        "code_end_line": 80,
        "code_key": "Handle",
        "code_value": "func (c *CreateRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tlvSm  = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\tbakSm = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo  = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t_, err = lvSm.Fire(ctx, c.relatedVolume.State, rdiskDomain.LVEBackupStarted, c)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tlv := c.relatedVolume\n\tbackup := backupDomain.New(\n\t\tlv.AppID,\n\t\tbackupDomain.DiskInfo{\n\t\t\tVolumeUUID: lv.UUID,\n\t\t\tVolumeSize: uint64(lv.Size),\n\t\t\tHostIP:     lv.PhysicalVolume.IP,\n\t\t\tHostBDF:    string(lv.PhysicalVolume.BDF),\n\t\t\tSerial:     string(lv.PhysicalVolume.Serial),\n\t\t},\n\t)\n\tif err := repo.Add(ctx, backup); err != nil {\n\t\treturn err\n\t}\n\tc.relatedBackup = backup\n\t_, err = bakSm.Fire(ctx, backupDomain.StatusInit, backupDomain.EventStartBackup, backupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: backup})\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/attach_logical_volume.go",
        "code_start_line": 49,
        "code_end_line": 71,
        "code_key": "Handle",
        "code_value": "func (c *AttachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEAttachLogicalVolume, c)\n\n\t// 如果已经挂载到了指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeAlreadyAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume already attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_delete_logical_volume.go",
        "code_start_line": 34,
        "code_end_line": 55,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\t// 如果逻辑卷不存在，则直接返回成功\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"failed to confirm delete: app id mismatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDeleteLogicalVolume, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/offline_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OfflinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOfflinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *DeletePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\t// 如果物理卷不存在，则直接幂等返回\n\t\treturn nil\n\t}\n\n\tvar event = domain.PVEDeletePhysicalVolume\n\tif c.Force && (c.relatedVolume.State == domain.PVSDefunct) {\n\t\t// 这里的实现不太好，状态机的逻辑不应该侵入 cmd\n\t\t// 时间太赶了，后续重构优化吧\n\t\tevent = domain.PVEForceDeleteForDefunct\n\t}\n\n\tif c.relatedVolume.HasBindedPV() {\n\t\treturn errors.New(domain.ErrVolumeBusy, \"logic volume has binded to this physical volume\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, event, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_logical_volume.go",
        "code_start_line": 55,
        "code_end_line": 70,
        "code_key": "Handle",
        "code_value": "func (c *CleanupLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVECleanupLogicalVolume, c)\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_init_physical_volume.go",
        "code_start_line": 26,
        "code_end_line": 52,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmInitPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\tif c.relatedVolume.IP.String() != c.Host.String() {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume host ip mistmatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVECreatePhysicalVolumeOnHost, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_physical_volume.go",
        "code_start_line": 51,
        "code_end_line": 101,
        "code_key": "Handle",
        "code_value": "func (c *CreatePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\n\t// 获取物理卷状态机\n\tsm := app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\trepo := app.GetRegistry(ctx).Repositories.PhysicalVolume\n\n\t// 检查物理卷是否已经存在，如果存在则直接幂等返回\n\tvol1, err := repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"serial\", c.Serial).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tvol2, err := repo.FindByIPAndBDF(ctx, c.Host, domain.BDF(c.BDF))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"host\", c.Host.String()).Str(\"bdf\", c.BDF).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tfor _, vol := range []*domain.PhysicalVolume{vol1, vol2} {\n\t\texisted, err := c.checkExisting(ctx, vol)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif existed {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// 触发事件，创建物理卷\n\t_, err = sm.Fire(ctx,\n\t\tdomain.PVSUnInited,\n\t\tdomain.PVECreatePhysicalVolume,\n\t\tc,\n\t)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 创建 Bdev 以及格式化移动到创建物理卷的状态机中\n\n\t// _, err = sm.Fire(ctx,\n\t// \tc.GetPhysicalVolume().State,\n\t// \tdomain.PVECreatePhysicalVolumeOnHost,\n\t// \tc,\n\t// )\n\t// if err != nil {\n\t// \treturn err\n\t// }\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_benchmark_task.go",
        "code_start_line": 32,
        "code_end_line": 57,
        "code_key": "Handle",
        "code_value": "func (c *DeleteBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\terr       error\n\t)\n\n\tbench, err := benchRepo.FindByUUID(ctx, c.BenchmarkUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif bench.DiskInfo.Serial != c.Serial {\n\t\treturn errors.Newf(benchmark.ErrTaskNotFound, \"benchmark serial not match %s, want %s\", c.Serial, bench.DiskInfo.Serial)\n\t}\n\n\t_, err = benchSm.Fire(ctx, bench.Status, benchmark.EventDeleteBench, benchmark.Data{Benchmark: bench, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := benchRepo.Delete(ctx, bench); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_logical_volume.go",
        "code_start_line": 52,
        "code_end_line": 98,
        "code_key": "Handle",
        "code_value": "func (c *CreateLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tpvRepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tlvRepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm     = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\t// 1. 查找底层物理卷\n\tc.selectedPhysicalVolume, err = pvRepo.FindBySerial(ctx, rdiskDomain.Serial(c.PhysicalVolumeSerial))\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// 检查底层物理卷大小是否满足要求\n\tif c.selectedPhysicalVolume.Size < rdiskDomain.Size(c.DiskSize) {\n\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume size %d is smaller than requested size %d\", c.selectedPhysicalVolume.Size, c.DiskSize)\n\t}\n\n\t// 检查底层物理卷性能等级是否满足要求\n\tif c.PerformanceRank != \"\" {\n\t\tif string(c.selectedPhysicalVolume.PerformanceRank) != c.PerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not match requested rank %s\", c.selectedPhysicalVolume.PerformanceRank, c.PerformanceRank)\n\t\t}\n\t} else {\n\t\tif c.selectedPhysicalVolume.PerformanceRank != rdiskDomain.DefaultPerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not default rank %s\", c.selectedPhysicalVolume.PerformanceRank, rdiskDomain.DefaultPerformanceRank)\n\t\t}\n\t}\n\n\t// 2. 创建逻辑卷\n\tvol := rdiskDomain.NewLogicalVolume(users.AppID(c.AppID), rdiskDomain.Size(c.DiskSize), rdiskDomain.ZoneID(c.ZoneID))\n\tif c.VolumeType != \"\" {\n\t\tvol.VolumeType = rdiskDomain.VolumeType(c.VolumeType)\n\t}\n\tif c.DiskType != \"\" {\n\t\tvol.DiskType = rdiskDomain.DiskType(c.DiskType)\n\t}\n\terr = lvRepo.Add(ctx, vol)\n\tif err != nil {\n\t\treturn\n\t}\n\tc.createdLogicalVolume = vol\n\n\t// 3. 触发状态机，联动更新逻辑卷和物理卷状态\n\t_, err = sm.Fire(ctx, rdiskDomain.LVSUnInited, rdiskDomain.LVECreateLogicalVolume, c)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_running_backup_task.go",
        "code_start_line": 31,
        "code_end_line": 61,
        "code_key": "Handle",
        "code_value": "func (c *UpdateRunningBackupTaskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventUpdateBackupProgress,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_drgroup.go",
        "code_start_line": 78,
        "code_end_line": 173,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeDRGroupCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tlvView  = app.GetRegistry(ctx).Viewers.LogicalVolume\n\t\tdrgRepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t\tsm      = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\terr     error\n\t)\n\n\t// 0. 初始化\n\tc.drgroupRef = make(map[string]*drgroup.DRGroup)\n\n\t// 1. 加载所有逻辑卷所在的置放群组\n\tallVolumeUUIDs := make([]string, 0, len(c.UUIDs))\n\tfor _, _uuid := range c.UUIDs {\n\t\tallVolumeUUIDs = append(allVolumeUUIDs, _uuid.String())\n\t}\n\tif groups, err := drgRepo.FindByMembers(ctx, c.AppID, allVolumeUUIDs); err == nil {\n\t\tif err != nil {\n\t\t\tif !errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tfor _, group := range groups {\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t\tc.curDRGroupNames = append(c.curDRGroupNames, group.Name)\n\t\t}\n\t} else {\n\t\treturn err\n\t}\n\n\t// 2. 确认已上锁的置放群组和当前一致\n\tif !c.checkLockedDRGroupNames() {\n\t\treturn errors.New(drgroup.ErrGroupModified, \"drgroup changed\")\n\t}\n\n\t// 3. 加载所有逻辑卷的状态，不需要完整实体，因为不会修改 Volume\n\tc.relatedLogicalVolume, err = lvView.FindByIDs(ctx, c.AppID, c.UUIDs)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(c.relatedLogicalVolume) < len(c.UUIDs) {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t// 4. 加载所有目标置放群组，key 为 name\n\tfor _, spec := range c.Specs {\n\t\tvar group *drgroup.DRGroup\n\t\tif _, ok := c.drgroupRef[spec.Name]; ok {\n\t\t\tgroup = c.drgroupRef[spec.Name]\n\t\t} else {\n\t\t\tgroup, err = c.getOrCreateDRGroup(ctx, drgRepo, spec)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t}\n\n\t\tif spec.Affinity > 0 {\n\t\t\tgroup.Affinity = spec.Affinity\n\t\t}\n\t\tif spec.Type != \"\" {\n\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t}\n\t}\n\n\t// 5. 对所有逻辑卷执行置放群组变更事件，检查状态是否允许，\n\t//    实际的更新还是在这里执行。\n\tfor _, vol := range c.relatedLogicalVolume {\n\t\terr := sm.Check(ctx, vol.State, rdiskDomain.LVEUpdateDrGroup, c)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// 将逻辑卷从原有的置放群组中移除\n\t\tfor _, name := range c.curDRGroupNames {\n\t\t\tc.drgroupRef[name].RemoveMember(vol.UUID.String())\n\t\t}\n\t\t// 将逻辑卷添加到新的置放群组中\n\t\tfor _, spec := range c.Specs {\n\t\t\tsubGroup := spec.SubGroup\n\t\t\tif subGroup == \"\" {\n\t\t\t\t// 如果没有指定子组，则使用远端 SSD UUID 作为子组名称\n\t\t\t\t// 相当于每块盘都是一个子组，相当于没有使用子组功能\n\t\t\t\tsubGroup = vol.UUID.String()\n\t\t\t}\n\t\t\tif err := c.drgroupRef[spec.Name].AddMember(vol.UUID.String(), subGroup, vol.PhysicalVolume.IP.String()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tif c.DryRun {\n\t\treturn errors.New(errors.ErrDryRunSuccessExit, \"dry run check success\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/online_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OnlinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOnlinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_benchmark_task.go",
        "code_start_line": 34,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *UpdateBenchmarkTask) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, rdisk.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark, err = benchRepo.FindByUUID(ctx, c.BenchmarkUUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventUpdateBench, benchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_flow_ctrl.go",
        "code_start_line": 80,
        "code_end_line": 103,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeFlowControlCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not found\")\n\t}\n\n\tspec := c.volume.FlowControlSpec\n\tif !c.UpdateRequest.UpdateSpec(&spec, c.volume.GetDefaultFlowControlSpec()) {\n\t\t// 没有任何更新，直接返回成功\n\t\treturn nil\n\t}\n\tc.volume.SetFlowControlSpec(spec)\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEUpdateFlowControl, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_defunct_volume.go",
        "code_start_line": 46,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *CleanupDefunctCommand) Handle(ctx context.Context) error {\n\tvar err error\n\tc.lv, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar sm = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\tvar event = rdiskDomain.LVECleanupDefunct\n\n\tfor _, attachment := range c.lv.Attachments {\n\t\tlogs.Info(ctx).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).Msg(\"cleanup defuncting volume\")\n\t\tsubCmd := &cleanDefunctSubCommand{Parent: c, HostIP: attachment.IP}\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, subCmd)\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，因为只要有一个挂载点清理失败，其他挂载点还是需要继续清理的\n\t\t\t// 失败的挂载点会在后台继续清理\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).\n\t\t\t\tMsg(\"failed to cleanup defunct volume, retry later.\")\n\t\t}\n\t}\n\n\tif len(c.lv.Attachments) == 0 {\n\t\t// 没有挂载点，直接清理\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, &cleanDefunctSubCommand{Parent: c, HostIP: net.IP{}})\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，后续自动重试即可\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Msg(\"failed to complete cleanup defunct volume\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_drgroup_exists.go",
        "code_start_line": 28,
        "code_end_line": 53,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDRGroupExistsCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t)\n\tfor _, spec := range c.DRGroup {\n\t\t_, err := repo.FindByName(ctx, users.AppID(c.AppID), spec.Name)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\tgroup := drgroup.New(spec.Name, users.AppID(c.AppID))\n\t\t\t\tif spec.Affinity > 0 {\n\t\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t\t}\n\t\t\t\tif spec.Type != \"\" {\n\t\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t\t}\n\t\t\t\terr = repo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_physical_volume.go",
        "code_start_line": 31,
        "code_end_line": 54,
        "code_key": "Handle",
        "code_value": "func (c *UpdatePhyRDiskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEUpdatePhysicalVolume, c)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/recycle_backup_data.go",
        "code_start_line": 32,
        "code_end_line": 62,
        "code_key": "Handle",
        "code_value": "func (c *RecycleBackupDataCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventDeleteBackup,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go",
        "code_start_line": 74,
        "code_end_line": 102,
        "code_key": "ProcessChargeDetail",
        "code_value": "func (c *CbsAppIdConsumer) ProcessChargeDetail(detail *ChargeDetail) error {\n\tcbsSrv := c.ResSrv.(*measure.CbsSrv)\n\t// 不同用户的资源数是不一致的，这里顺序处理的话性能一般，需要放在协程中跑\n\t// 单个用户最多启动100个协程，避免协程过多\n\tvar wg sync.WaitGroup\n\tfor _, cbsInstanceId := range detail.ResIds {\n\t\twg.Add(1)\n\t\tgo func(cbsInstanceId measure.ResourceId) {\n\t\t\tdefer wg.Done()\n\t\t\t// 并发的控制策略: 同时处理的用户不超过t.Concurrency个，所有用户共享t.Concurrency * 100个协程\n\t\t\t// 这样设计的目的是为了规避用户资源倾斜严重的问题，同时也能保证用户的并发度较少\n\t\t\tc.ResSemaphore <- struct{}{}\n\t\t\tdefer func() {\n\t\t\t\t<-c.ResSemaphore\n\t\t\t}()\n\n\t\t\tlogs.Info(c.Ctx).\n\t\t\t\tUint64(\"appId\", uint64(detail.User.AppId)).\n\t\t\t\tStr(\"cbsInstanceId\", string(cbsInstanceId)).\n\t\t\t\tMsg(\"PROCESS_SIGNAL_DISK\")\n\n\t\t\tchargeItem := cbsSrv.BuildResChargeItem(detail.User, cbsInstanceId, detail.ChargeTime)\n\t\t\t// 单个资源失败就等下一轮，先忽略err\n\t\t\t_ = c.ProcessSingleChargeItem(detail.User, cbsInstanceId, chargeItem)\n\t\t}(cbsInstanceId)\n\t}\n\twg.Wait()\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/service.go",
        "code_start_line": 208,
        "code_end_line": 217,
        "code_key": "BuildResChargeItem",
        "code_value": "func (cbsSrv *CbsSrv) BuildResChargeItem(u *user.User, resourceId ResourceId, chargeTime time.Time) *ChargeItem {\n\tcbsMeasureRepo := cbsSrv.balanceRepo.(repositories.CbsBalanceRepoIFace)\n\tbalanceRecords, _ := cbsMeasureRepo.GetCbsBalanceRecords(cbsSrv.ctx, string(resourceId), chargeTime, false)\n\n\tif len(balanceRecords) == 0 {\n\t\treturn nil\n\t}\n\n\treturn cbsSrv.convertToChargeItem(u, resourceId, balanceRecords, chargeTime)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 133,
        "code_end_line": 236,
        "code_key": "BuildResChargeItem",
        "code_value": "func (snapSrv *SnapSrv) BuildResChargeItem(u *user.User, resourceId ResourceId, chargeTime time.Time) *ChargeItem {\n\t// 获取符合条件的balanceRecord并根据chargeTime排序\n\tbalanceRecords, _ := snapSrv.snapRepo.GetSnapBalanceRecords(snapSrv.ctx, string(resourceId), chargeTime)\n\n\t// FIXME 临时方案：用内存里的lastBalanceTime覆盖balanceRecords里的balanceTime\n\tfor _, balanceRecord := range balanceRecords {\n\t\tlastBalanceTime, ok := snapSrv.lastBalanceTimeCache[balanceRecord.ID]\n\t\tif ok {\n\t\t\tbalanceRecord.LastBalanceTime = lastBalanceTime\n\t\t}\n\t}\n\n\tif len(balanceRecords) == 0 {\n\t\treturn nil\n\t}\n\tsort.Slice(balanceRecords, func(i, j int) bool {\n\t\tif balanceRecords[i].LastBalanceTime.Equal(balanceRecords[j].LastBalanceTime) {\n\t\t\treturn balanceRecords[i].OperationType < balanceRecords[j].OperationType\n\t\t}\n\t\treturn balanceRecords[i].LastBalanceTime.Before(balanceRecords[j].LastBalanceTime)\n\t})\n\n\t// 区分国内站和国际站用户\n\tvar userArea Area\n\tif u.IsI18nUser() {\n\t\tuserArea = AreaI18n\n\t} else {\n\t\tuserArea = AreaChina\n\t}\n\tisGrayUser, err := u.CheckFeature(user.USER_FLAG_SNAP_GRAY_USER)\n\tif err != nil {\n\t\tlogs.Error(snapSrv.ctx).Err(err).Int64(\"appId\", int64(u.AppId)).Msg(\"CHECK_GRAY_USER_ERR\")\n\t\t// 出错时标记为非灰度用户，避免重复推量\n\t\tisGrayUser = false\n\t}\n\n\tchargeItem := &ChargeItem{\n\t\t// FIXME: 需要从配置文件中获取region id\n\t\tRegionId:     snapSrv.regionId,\n\t\tZoneId:       balanceRecords[0].ZoneID,\n\t\tAppId:        u.AppId,\n\t\tUin:          u.Uin,\n\t\tUserArea:     userArea,\n\t\tIsGrayUser:   isGrayUser,\n\t\tResourceId:   resourceId,\n\t\tResourceArea: snapSrv.regionArea,\n\t\tItems:        make([]*SubItem, 0, len(balanceRecords)),\n\t}\n\n\t// 虚拟计费条目，用于确定endBalanceTime\n\tendBalanceRecord := &ccdb.CSnapBalance{LastBalanceTime: chargeTime.Add(time.Second * -1)}\n\tallBalances := append(balanceRecords, endBalanceRecord)\n\n\tfor i, balanceRecord := range allBalances[1:] {\n\t\tbeginBalanceRecord := balanceRecords[i]\n\t\t// 资源欠费，不收取费用\n\t\tif beginBalanceRecord.OperationType == int(SnapOpArrearage) {\n\t\t\tlogs.Info(snapSrv.ctx).Uint64(\"appId\", uint64(u.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"RESOURCE_ARREARAGE\")\n\t\t\tcontinue\n\t\t}\n\t\t// 资源已退还。退还后还产生了计费条目，非期望行为\n\t\tif beginBalanceRecord.OperationType == int(SnapOpReturn) {\n\t\t\tlogs.Info(snapSrv.ctx).Uint64(\"appId\", uint64(u.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"SNAP_HAS_RETURNED\")\n\t\t\tbreak\n\t\t}\n\n\t\t// 资源正常\n\t\tstartTime := beginBalanceRecord.LastBalanceTime\n\t\tendTime := balanceRecord.LastBalanceTime\n\t\tcurTime := startTime\n\t\tfor endTime.After(curTime) {\n\t\t\tcurHourEnd := time.Date(curTime.Year(), curTime.Month(), curTime.Day(), curTime.Hour(), 59, 59, 0, curTime.Location())\n\t\t\tif !endTime.After(curHourEnd) {\n\t\t\t\t// 同一周期\n\t\t\t\tsubItem := &SubItem{\n\t\t\t\t\tPid:       PidSnap,\n\t\t\t\t\tStartTime: curTime,\n\t\t\t\t\tEndTime:   endTime,\n\t\t\t\t\tSubValueDetail: map[string]interface{}{\n\t\t\t\t\t\t\"Size\": beginBalanceRecord.SnapSize},\n\t\t\t\t}\n\t\t\t\tchargeItem.Items = append(chargeItem.Items, subItem)\n\t\t\t\tcurTime = endTime.Add(time.Second)\n\t\t\t} else {\n\t\t\t\t// 非同一周期，先构建这个周期的\n\t\t\t\tsubItem := &SubItem{\n\t\t\t\t\tStartTime: curTime,\n\t\t\t\t\tEndTime:   curHourEnd,\n\t\t\t\t\tSubValueDetail: map[string]interface{}{\n\t\t\t\t\t\t\"Size\": beginBalanceRecord.SnapSize,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\tchargeItem.Items = append(chargeItem.Items, subItem)\n\t\t\t\tcurTime = curHourEnd.Add(time.Second)\n\t\t\t}\n\n\t\t}\n\t}\n\tif len(chargeItem.Items) == 0 {\n\t\treturn nil\n\t}\n\n\treturn chargeItem\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 247,
        "code_end_line": 264,
        "code_key": "BuildResChargeItem",
        "code_value": "func (cbsSrv *CbsSrv) BuildResChargeItem(u *user.User, resourceId ResourceId, chargeTime time.Time) *ChargeItem {\n\tcbsMeasureRepo := cbsSrv.measureRepo.(CbsMeasureRepoIFace)\n\tbalanceRecords, _ := cbsMeasureRepo.GetCbsBalanceRecords(cbsSrv.ctx, string(resourceId), chargeTime, false)\n\n\t// FIXME 临时方案：用内存里的lastBalanceTime覆盖balanceRecords里的balanceTime\n\tfor _, balanceRecord := range balanceRecords {\n\t\tlastBalanceTime, ok := cbsSrv.lastBalanceTimeCache[balanceRecord.ID]\n\t\tif ok {\n\t\t\tbalanceRecord.LastBalanceTime = lastBalanceTime\n\t\t}\n\t}\n\n\tif len(balanceRecords) == 0 {\n\t\treturn nil\n\t}\n\n\treturn cbsSrv.convertToChargeItem(u, resourceId, balanceRecords, chargeTime)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/service.go",
        "code_start_line": 294,
        "code_end_line": 367,
        "code_key": "convertToChargeItem",
        "code_value": "func (cbsSrv *CbsSrv) convertToChargeItem(u *user.User, resourceId ResourceId, balanceRecords []*ccdb.CCbsBalance, chargeTime time.Time) *ChargeItem {\n\tsort.Slice(balanceRecords, func(i, j int) bool {\n\t\tif balanceRecords[i].LastBalanceTime.Equal(balanceRecords[j].LastBalanceTime) {\n\t\t\treturn balanceRecords[i].OperationType < balanceRecords[j].OperationType\n\t\t}\n\t\treturn balanceRecords[i].LastBalanceTime.Before(balanceRecords[j].LastBalanceTime)\n\t})\n\n\t// 区分国内站和国际站用户\n\tvar userArea Area\n\tif u.IsI18nUser() {\n\t\tuserArea = AreaI18n\n\t} else {\n\t\tuserArea = AreaChina\n\t}\n\tisGrayUser, err := u.CheckFeature(user.USER_FLAG_CBS_GRAY_USER)\n\tif err != nil {\n\t\tlogs.Error(cbsSrv.ctx).Err(err).Int64(\"appId\", int64(u.AppId)).Msg(\"CHECK_GRAY_USER_ERR\")\n\t\t// 出错时标记为非灰度用户，避免重复推量\n\t\tisGrayUser = false\n\t}\n\n\tchargeItem := &ChargeItem{\n\t\t// FIXME: 需要从配置文件中获取region id\n\t\tRegionId:     cbsSrv.regionId,\n\t\tZoneId:       balanceRecords[0].ZoneID,\n\t\tAppId:        u.AppId,\n\t\tUin:          u.Uin,\n\t\tUserArea:     userArea,\n\t\tIsGrayUser:   isGrayUser,\n\t\tResourceId:   resourceId,\n\t\tResourceArea: cbsSrv.regionArea,\n\t\tItems:        make([]*SubItem, 0, len(balanceRecords)),\n\t\tUpdateKVs:    make([]*UpdateKV, 0, len(balanceRecords)),\n\t}\n\n\t// 虚拟计费条目，用于确定endBalanceTime\n\tendBalanceRecord := &ccdb.CCbsBalance{LastBalanceTime: chargeTime.Add(time.Second * -1)}\n\tallBalances := append(balanceRecords, endBalanceRecord)\n\n\t// 获取云盘信息\n\tfor i, balanceRecord := range allBalances[1:] {\n\t\tbeginBalanceRecord := balanceRecords[i]\n\t\t// 用于组装单个BalanceRecord的subitem\n\t\tstopCharge := cbsSrv.processSingleBalanceRecords(\n\t\t\tchargeItem, beginBalanceRecord, balanceRecord, u, resourceId)\n\t\tif stopCharge {\n\t\t\t// TODO 停止计费。如果后续产生预期外的计费条目，状态也应该置为无效\n\t\t\t// 现在先不处理，避免因bug导致少收费\n\t\t\tbreak\n\t\t}\n\n\t\t// 灰度阶段使用\n\t\tif isGrayUser {\n\t\t\t// 更新balanceRecord\n\t\t\tupdateKV := &UpdateKV{\n\t\t\t\tId:              beginBalanceRecord.ID,\n\t\t\t\tLastBalanceTime: chargeTime,\n\t\t\t\tStatus:          beginBalanceRecord.Status,\n\t\t\t}\n\t\t\tif i != len(balanceRecords)-1 ||\n\t\t\t\t(beginBalanceRecord.OperationType == int(CbsOpReturn) || beginBalanceRecord.OperationType == int(CbsOpConvert)) {\n\t\t\t\tbeginBalanceRecord.Status = 0\n\t\t\t}\n\t\t\tchargeItem.UpdateKVs = append(chargeItem.UpdateKVs, updateKV)\n\t\t}\n\n\t}\n\tif len(chargeItem.Items) == 0 && len(chargeItem.UpdateKVs) == 0 {\n\t\treturn nil\n\t}\n\n\treturn chargeItem\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 341,
        "code_end_line": 414,
        "code_key": "convertToChargeItem",
        "code_value": "func (cbsSrv *CbsSrv) convertToChargeItem(u *user.User, resourceId ResourceId, balanceRecords []*ccdb.CCbsBalance, chargeTime time.Time) *ChargeItem {\n\tsort.Slice(balanceRecords, func(i, j int) bool {\n\t\tif balanceRecords[i].LastBalanceTime.Equal(balanceRecords[j].LastBalanceTime) {\n\t\t\treturn balanceRecords[i].OperationType < balanceRecords[j].OperationType\n\t\t}\n\t\treturn balanceRecords[i].LastBalanceTime.Before(balanceRecords[j].LastBalanceTime)\n\t})\n\n\t// 区分国内站和国际站用户\n\tvar userArea Area\n\tif u.IsI18nUser() {\n\t\tuserArea = AreaI18n\n\t} else {\n\t\tuserArea = AreaChina\n\t}\n\tisGrayUser, err := u.CheckFeature(user.USER_FLAG_CBS_GRAY_USER)\n\tif err != nil {\n\t\tlogs.Error(cbsSrv.ctx).Err(err).Int64(\"appId\", int64(u.AppId)).Msg(\"CHECK_GRAY_USER_ERR\")\n\t\t// 出错时标记为非灰度用户，避免重复推量\n\t\tisGrayUser = false\n\t}\n\n\tchargeItem := &ChargeItem{\n\t\t// FIXME: 需要从配置文件中获取region id\n\t\tRegionId:     cbsSrv.regionId,\n\t\tZoneId:       balanceRecords[0].ZoneID,\n\t\tAppId:        u.AppId,\n\t\tUin:          u.Uin,\n\t\tUserArea:     userArea,\n\t\tIsGrayUser:   isGrayUser,\n\t\tResourceId:   resourceId,\n\t\tResourceArea: cbsSrv.regionArea,\n\t\tItems:        make([]*SubItem, 0, len(balanceRecords)),\n\t\tUpdateKVs:    make([]*UpdateKV, 0, len(balanceRecords)),\n\t}\n\n\t// 虚拟计费条目，用于确定endBalanceTime\n\tendBalanceRecord := &ccdb.CCbsBalance{LastBalanceTime: chargeTime.Add(time.Second * -1)}\n\tallBalances := append(balanceRecords, endBalanceRecord)\n\n\t// 获取云盘信息\n\tfor i, balanceRecord := range allBalances[1:] {\n\t\tbeginBalanceRecord := balanceRecords[i]\n\t\t// 用于组装单个BalanceRecord的subitem\n\t\tstopCharge := cbsSrv.processSingleBalanceRecords(\n\t\t\tchargeItem, beginBalanceRecord, balanceRecord, u, resourceId)\n\t\tif stopCharge {\n\t\t\t// TODO 停止计费。如果后续产生预期外的计费条目，状态也应该置为无效\n\t\t\t// 现在先不处理，避免因bug导致少收费\n\t\t\tbreak\n\t\t}\n\n\t\t// 灰度阶段使用\n\t\tif isGrayUser {\n\t\t\t// 更新balanceRecord\n\t\t\tupdateKV := &UpdateKV{\n\t\t\t\tId:              beginBalanceRecord.ID,\n\t\t\t\tLastBalanceTime: chargeTime,\n\t\t\t\tStatus:          beginBalanceRecord.Status,\n\t\t\t}\n\t\t\tif i != len(balanceRecords)-1 ||\n\t\t\t\t(beginBalanceRecord.OperationType == int(CbsOpReturn) || beginBalanceRecord.OperationType == int(CbsOpConvert)) {\n\t\t\t\tbeginBalanceRecord.Status = 0\n\t\t\t}\n\t\t\tchargeItem.UpdateKVs = append(chargeItem.UpdateKVs, updateKV)\n\t\t}\n\n\t}\n\tif len(chargeItem.Items) == 0 && len(chargeItem.UpdateKVs) == 0 {\n\t\treturn nil\n\t}\n\n\treturn chargeItem\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/service.go",
        "code_start_line": 369,
        "code_end_line": 434,
        "code_key": "processSingleBalanceRecords",
        "code_value": "func (cbsSrv *CbsSrv) processSingleBalanceRecords(chargeItem *ChargeItem, beginBalanceRecord *ccdb.CCbsBalance, endBalanceRecord *ccdb.CCbsBalance, user *user.User, resourceId ResourceId) (stopCharge bool) {\n\tstopCharge = false\n\t// 资源欠费，不收取费用\n\tif beginBalanceRecord.OperationType == int(CbsOpArrearage) {\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"RESOURCE_ARREARAGE\")\n\t\treturn\n\t}\n\t// 资源退还。判断是否为预付费的性能突发场景\n\tif beginBalanceRecord.OperationType == int(CbsOpReturn) || beginBalanceRecord.OperationType == int(CbsOpConvert) {\n\t\t// 判断是否为预付费的性能突发场景.\n\t\t// 获取云盘信息。这里在循环中进行查询，但命中的应该不会很多，放在外层反而会导致每个云盘都被查询\n\t\tdisk, err := cbsSrv.diskRepo.QueryDiskInfoById(cbsSrv.ctx, string(resourceId))\n\t\tif err != nil || disk == nil {\n\t\t\tlogs.Error(cbsSrv.ctx).Err(err).Str(\"resourceId\", string(resourceId)).Msg(\"QUERY_CBS_RECORD_FAILED\")\n\t\t\t// TODO 这里先不返回资源的推量？\n\t\t\treturn true\n\t\t}\n\t\t// TODO 走diskLogical\n\t\tif disk.PayMode == \"prepay\" {\n\t\t\t// 性能突发场景，预付费用户退盘，退盘费用不计\n\t\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"MAYBE_CBS_WITH_BURST_PERFORMANCE\")\n\t\t\treturn\n\t\t}\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"CBS_HAS_RETURNED\")\n\t\treturn true\n\t}\n\n\t// 资源正常\n\tstartTime := beginBalanceRecord.LastBalanceTime\n\tendTime := endBalanceRecord.LastBalanceTime\n\tcurTime := startTime\n\tfor endTime.After(curTime) {\n\t\tcurHourEnd := time.Date(curTime.Year(), curTime.Month(), curTime.Day(), curTime.Hour(), 59, 59, 0, curTime.Location())\n\n\t\tvar config CCbsBalanceConfig\n\t\terr := json.Unmarshal([]byte(beginBalanceRecord.Config), &config)\n\t\tif err != nil {\n\t\t\tlogs.Error(cbsSrv.ctx).Err(err).Msg(\"PARSE_CONFIG_ERROR\")\n\t\t\treturn\n\t\t}\n\n\t\tcurEndTime := endTime\n\t\tcurStarTime := curTime\n\t\tif !endTime.After(curHourEnd) {\n\t\t\t// 同一周期\n\t\t\tcurTime = endTime.Add(time.Second)\n\t\t} else {\n\t\t\tcurEndTime = curHourEnd\n\t\t\tcurTime = curHourEnd.Add(time.Second)\n\t\t}\n\t\tsubItem := &SubItem{\n\t\t\tPid:       beginBalanceRecord.Pid,\n\t\t\tStartTime: curStarTime,\n\t\t\tEndTime:   curEndTime,\n\t\t\tProjectId: beginBalanceRecord.ProjectID,\n\t\t\tParams:    beginBalanceRecord.ResourceInfo,\n\t\t\tSubValueDetail: map[string]interface{}{\n\t\t\t\t// FIXME 性能突发场景待实现\n\t\t\t\t\"Size\":             config.Size,\n\t\t\t\t\"BackupPointQuota\": config.BackupPointQuota,\n\t\t\t},\n\t\t}\n\t\tchargeItem.Items = append(chargeItem.Items, subItem)\n\t}\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 416,
        "code_end_line": 481,
        "code_key": "processSingleBalanceRecords",
        "code_value": "func (cbsSrv *CbsSrv) processSingleBalanceRecords(chargeItem *ChargeItem, beginBalanceRecord *ccdb.CCbsBalance, endBalanceRecord *ccdb.CCbsBalance, user *user.User, resourceId ResourceId) (stopCharge bool) {\n\tstopCharge = false\n\t// 资源欠费，不收取费用\n\tif beginBalanceRecord.OperationType == int(CbsOpArrearage) {\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"RESOURCE_ARREARAGE\")\n\t\treturn\n\t}\n\t// 资源退还。判断是否为预付费的性能突发场景\n\tif beginBalanceRecord.OperationType == int(CbsOpReturn) || beginBalanceRecord.OperationType == int(CbsOpConvert) {\n\t\t// 判断是否为预付费的性能突发场景.\n\t\t// 获取云盘信息。这里在循环中进行查询，但命中的应该不会很多，放在外层反而会导致每个云盘都被查询\n\t\tdisk, err := cbsSrv.diskRepo.QueryDiskInfoById(cbsSrv.ctx, string(resourceId))\n\t\tif err != nil || disk == nil {\n\t\t\tlogs.Error(cbsSrv.ctx).Err(err).Str(\"resourceId\", string(resourceId)).Msg(\"QUERY_CBS_RECORD_FAILED\")\n\t\t\t// TODO 这里先不返回资源的推量？\n\t\t\treturn true\n\t\t}\n\t\t// TODO 走diskLogical\n\t\tif disk.PayMode == \"prepay\" {\n\t\t\t// 性能突发场景，预付费用户退盘，退盘费用不计\n\t\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"MAYBE_CBS_WITH_BURST_PERFORMANCE\")\n\t\t\treturn\n\t\t}\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"CBS_HAS_RETURNED\")\n\t\treturn true\n\t}\n\n\t// 资源正常\n\tstartTime := beginBalanceRecord.LastBalanceTime\n\tendTime := endBalanceRecord.LastBalanceTime\n\tcurTime := startTime\n\tfor endTime.After(curTime) {\n\t\tcurHourEnd := time.Date(curTime.Year(), curTime.Month(), curTime.Day(), curTime.Hour(), 59, 59, 0, curTime.Location())\n\n\t\tvar config CCbsBalanceConfig\n\t\terr := json.Unmarshal([]byte(beginBalanceRecord.Config), &config)\n\t\tif err != nil {\n\t\t\tlogs.Error(cbsSrv.ctx).Err(err).Msg(\"PARSE_CONFIG_ERROR\")\n\t\t\treturn\n\t\t}\n\n\t\tcurEndTime := endTime\n\t\tcurStarTime := curTime\n\t\tif !endTime.After(curHourEnd) {\n\t\t\t// 同一周期\n\t\t\tcurTime = endTime.Add(time.Second)\n\t\t} else {\n\t\t\tcurEndTime = curHourEnd\n\t\t\tcurTime = curHourEnd.Add(time.Second)\n\t\t}\n\t\tsubItem := &SubItem{\n\t\t\tPid:       beginBalanceRecord.Pid,\n\t\t\tStartTime: curStarTime,\n\t\t\tEndTime:   curEndTime,\n\t\t\tProjectId: beginBalanceRecord.ProjectID,\n\t\t\tParams:    beginBalanceRecord.ResourceInfo,\n\t\t\tSubValueDetail: map[string]interface{}{\n\t\t\t\t// FIXME 性能突发场景待实现\n\t\t\t\t\"Size\":             config.Size,\n\t\t\t\t\"BackupPointQuota\": config.BackupPointQuota,\n\t\t\t},\n\t\t}\n\t\tchargeItem.Items = append(chargeItem.Items, subItem)\n\t}\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/convertor.go",
        "code_start_line": 28,
        "code_end_line": 38,
        "code_key": "Start",
        "code_value": "func (a *Convertor) Start(ctx context.Context) error {\n\t// 启动转换器\n\tfor _, scanner := range a.scanners {\n\t\tscanner := scanner\n\t\tgo func() {\n\t\t\ta.convertToTask(ctx, scanner)\n\t\t}()\n\t}\n\tlogs.Info(ctx).Msgf(\"Convertor Start Success\")\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_rec_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *CbsMeasureReconciliationTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\t//s.resultChan <- struct{}{}\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_rec_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 35,
        "code_key": "Start",
        "code_value": "func (s *SnapMeasureReconciliationTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_compute_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *SnapComputeTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\t//s.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_measure_send_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *CbsMeasureSendTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_bill_valid_appId_fetch_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *CbsValidAppIdFetchTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_calculate_cost_locally_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 36,
        "code_key": "Start",
        "code_value": "func (s *SnapCalculateCostLocallyTaskScanner) Start(ctx context.Context) error {\n\t//s.resultChan <- struct{}{}\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_create_task_scanner.go",
        "code_start_line": 23,
        "code_end_line": 42,
        "code_key": "Start",
        "code_value": "func (s *UpdateCreateTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\trunning := true\n\t\tfor running {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\trunning = false\n\t\t\tdefault:\n\t\t\t\terr := s.FullScan(ctx)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogs.Fatal(ctx).Msgf(\"%s full scan failed!\\n\", s.name)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\ttime.Sleep(s.scanInterval)\n\t\t}\n\t}()\n\tlogs.Info(ctx).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_measure_send_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 36,
        "code_key": "Start",
        "code_value": "func (s *SnapMeasureSendTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\t//s.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/repush_user_billing_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 39,
        "code_key": "Start",
        "code_value": "func (s *RepushUserBillingTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_rollback_task_scanner.go",
        "code_start_line": 23,
        "code_end_line": 42,
        "code_key": "Start",
        "code_value": "func (s *UpdateRollbackTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\trunning := true\n\t\tfor running {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\trunning = false\n\t\t\tdefault:\n\t\t\t\terr := s.FullScan(ctx)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogs.Fatal(ctx).Msgf(\"%s full scan failed!\\n\", s.name)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\ttime.Sleep(s.scanInterval)\n\t\t}\n\t}()\n\tlogs.Info(ctx).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_valid_appId_fetch_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 36,
        "code_key": "Start",
        "code_value": "func (s *SnapValidAppIdFetchTaskScanner) Start(ctx context.Context) error {\n\t//s.resultChan <- struct{}{}\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_bill_compute_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 39,
        "code_key": "Start",
        "code_value": "func (s *CbsBillComputeTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/app/app.go",
        "code_start_line": 31,
        "code_end_line": 39,
        "code_key": "Start",
        "code_value": "func (m *PipelineManager) Start(ctx context.Context) error {\n\tfor region, pipeline := range m.Pipelines {\n\t\tregionCtx := context.WithValue(ctx, \"region\", region)\n\t\tif err := pipeline.Start(regionCtx); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/app/app.go",
        "code_start_line": 46,
        "code_end_line": 51,
        "code_key": "Start",
        "code_value": "func (app *NebulaApp) Start(ctx context.Context) error {\n\tif err := app.pipelineManager.Start(ctx); err != nil {\n\t\treturn err\n\t}\n\treturn <-app.stopChan\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/app/pipeline.go",
        "code_start_line": 20,
        "code_end_line": 46,
        "code_key": "Start",
        "code_value": "func (p *RegionPipeline) Start(ctx context.Context) error {\n\tregion := ctx.Value(\"region\").(string)\n\tscannerLogCtx := initLogger(ctx, region, \"scanner.log\")\n\tfor _, scanner := range p.scanners {\n\t\tsingleCtx := logs.AddDefaultMessage(scannerLogCtx, \"name\", scanner.GetName())\n\t\terr := scanner.Start(singleCtx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tinitMetric(scanner, region, \"scanner\", scanner.GetName())\n\t}\n\n\tconvertorLogCtx := initLogger(ctx, region, \"convertor.log\")\n\terr := p.convertor.Start(convertorLogCtx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// start scheduler\n\tschedulerLogCtx := initLogger(ctx, region, \"scheduler.log\")\n\terr = p.scheduler.Start(schedulerLogCtx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tinitMetric(p.scheduler, region, \"scheduler\", \"scheduler\")\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go",
        "code_start_line": 109,
        "code_end_line": 112,
        "code_key": "Start",
        "code_value": "func (sc *Scheduler) Start(ctx context.Context) error {\n\tgo sc.mainLoop(ctx)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/scheduler.go",
        "code_start_line": 154,
        "code_end_line": 191,
        "code_key": "Start",
        "code_value": "func (s *scheduler) Start(ctx context.Context) error {\n\twg := sync.WaitGroup{}\n\trunning := true\n\tgo s.haManager.Start(ctx)\n\tdefer s.haManager.Close(ctx)\n\tfor {\n\t\tselect {\n\t\tcase taskName := <-s.eventChan:\n\t\t\twg.Add(1)\n\t\t\tgo func(name string) {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tif task, ok := s.loads[name]; ok {\n\n\t\t\t\t\tif s.isMaster {\n\t\t\t\t\t\t_ctx := logs.With(ctx).Str(\"seqId\", uuid.New().String()).Str(\"taskName\", name).Logger().WithContext(ctx)\n\t\t\t\t\t\ttask.Work(_ctx)\n\t\t\t\t\t}\n\n\t\t\t\t\ttriggerTime := time.Now().Add(task.Interval())\n\t\t\t\t\tfor {\n\t\t\t\t\t\tif !running {\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif time.Now().After(triggerTime) {\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttime.Sleep(time.Second)\n\t\t\t\t\t}\n\t\t\t\t\ts.eventChan <- name\n\t\t\t\t}\n\t\t\t}(taskName)\n\t\tcase <-s.stopChan:\n\t\t\trunning = false\n\t\t\twg.Wait()\n\t\t\treturn nil\n\t\t}\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/easyha/model.go",
        "code_start_line": 108,
        "code_end_line": 180,
        "code_key": "Start",
        "code_value": "func (m *haManagerImpl) Start(ctx context.Context) {\n\tm.keepRunning = true\n\tm.ctx = ctx\n\tvar (\n\t\tmyIdentity            = m.delegate.GetIdentity()                                    // 当前节点的业务标识\n\t\tmyKey                 = fmt.Sprintf(\"easyhaMaster/%s\", url.PathEscape(m.namespace)) // 分布式锁的key\n\t\tmyToken               = m.encodeToken(myIdentity)                                   // 分布式锁 Token，包含业务标识和随机信息\n\t\tmyLock                dlock.Lock                                                    // 获取到的分布式锁, 用于刷新和释放\n\t\tcurrentMasterIdentity string                                                        // 当前 master 的业务标识，如果为空则是还未获取过当前 master\n\t)\n\n\t// Start slave loop.\n\tfor m.keepRunning {\n\t\t// Try observe the master lock first.\n\t\tif view, err := m.locker.Observe(ctx, myKey); err != nil {\n\t\t\tm.logger.Info().Err(err).Str(\"key\", myKey).Msg(\"failed to observe current master lock\")\n\t\t\t// Failed to observe the master lock, try to  obtain the lock.\n\t\t\tmyLock, err = m.locker.Obtain(ctx, dlock.NewWriteLockKey(myKey), m.lockExpired, &dlock.Option{Token: myToken})\n\t\t\tif err == nil {\n\t\t\t\t// Successfully obtained the lock.\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tnewIdentity, err := m.decodeToken(view.Token)\n\t\t\tif err != nil {\n\t\t\t\tm.logger.Warn().Err(err).Str(\"token\", view.Token).Msg(\"failed to decode token\")\n\t\t\t} else if currentMasterIdentity == \"\" {\n\t\t\t\t// First time to observe the master.\n\t\t\t\tcurrentMasterIdentity = newIdentity\n\t\t\t\tif err := m.delegate.OnBecomeSlave(ctx, currentMasterIdentity); err != nil {\n\t\t\t\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle become slave, force quit for safety\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if currentMasterIdentity != newIdentity {\n\t\t\t\t// Master changed. Need update.\n\t\t\t\tcurrentMasterIdentity = newIdentity\n\t\t\t\tif err := m.delegate.OnSwitchMaster(ctx, currentMasterIdentity); err != nil {\n\t\t\t\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle switch master, force quit for safety\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttime.Sleep(m.checkInterval)\n\t}\n\n\tif myLock == nil {\n\t\tm.logger.Fatal().Msg(\"myLock is nil, found bug, force quit for safety\")\n\t\treturn\n\t}\n\n\t// I am the master now.\n\tif err := m.delegate.OnBecomeMaster(ctx); err != nil {\n\t\tmyLock.Release(ctx)\n\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle become master, force quit for safety\")\n\t\treturn\n\t}\n\n\tdefer func() {\n\t\tmyLock.Release(ctx)\n\t\tif err := m.delegate.OnLostMaster(ctx); err != nil {\n\t\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle lost master, force quit for safety\")\n\t\t}\n\t}()\n\n\t// Start the master loop.\n\tfor m.keepRunning {\n\t\ttime.Sleep(m.checkInterval)\n\t\tif err := myLock.Refresh(ctx, m.lockExpired); err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_bill_compute_task.go",
        "code_start_line": 63,
        "code_end_line": 113,
        "code_key": "ProcessUserSnapResources",
        "code_value": "func (t *SnapBillComputeTask) ProcessUserSnapResources(user *user.User, snapIds []measure.ResourceId) {\n\tsnapSrv := t.ResSrv.(*measure.SnapSrv)\n\t// 不同用户的资源数是不一致的，这里顺序处理的话性能一般，需要放在协程中跑\n\t// 单个用户最多启动100个协程，避免协程过多\n\tvar wg sync.WaitGroup\n\tsemaphore := make(chan struct{}, 100)\n\tchargeTimeFromSnapshot := snapSrv.GetSnapRealChargeTimes(user.AppId, t.ChargeTime)\n\n\tfor _, snapId := range snapIds {\n\t\twg.Add(1)\n\t\tgo func(snapId measure.ResourceId) {\n\t\t\tdefer wg.Done()\n\t\t\t// 这里可以控制启动的协程数\n\t\t\tsemaphore <- struct{}{}\n\t\t\tdefer func() { <-semaphore }()\n\n\t\t\tlogs.Info(t.Ctx).\n\t\t\t\tUint64(\"app_id\", uint64(user.AppId)).\n\t\t\t\tStr(\"snap_id\", string(snapId)).\n\t\t\t\tMsg(\"PROCESS_SIGNAL_SNAP\")\n\t\t\t// 计费真正的结算时间：若快照deadline时间晚于结算时间，则结算时间=快照deadline\n\t\t\tchargeTime, ok := chargeTimeFromSnapshot[snapId]\n\t\t\tif !ok {\n\t\t\t\tchargeTime = t.ChargeTime\n\t\t\t}\n\n\t\t\tchargeItem := snapSrv.BuildResChargeItem(user, snapId, chargeTime)\n\t\t\tif chargeItem == nil {\n\t\t\t\t// 可能是资源不需要计费。这里需要把资源Id从UnConfirmedMap中删除\n\t\t\t\tt.MarkSingleResDone(user.AppId, snapId)\n\t\t\t\tlogs.Info(t.Ctx).Uint64(\"appId\", uint64(user.AppId)).\n\t\t\t\t\tStr(\"snapId\", string(snapId)).Msg(\"SKIP_SNAP\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tchargeItemMsg := mqimpl.NewMessage(mq.MSGTYPE_JSON, chargeItem)\n\t\t\terr := t.ChargeItemProducer.Publish(chargeItemMsg)\n\t\t\tlogs.Info(t.Ctx).\n\t\t\t\tUint64(\"appId\", uint64(user.AppId)).\n\t\t\t\tStr(\"snap_id\", string(snapId)).\n\t\t\t\tMsg(\"PUBLISH_CHARGE_ITEM\")\n\t\t\tif err != nil {\n\t\t\t\tlogs.Error(t.Ctx).Err(err).\n\t\t\t\t\tUint64(\"appId\", uint64(user.AppId)).\n\t\t\t\t\tStr(\"snapId\", string(snapId)).\n\t\t\t\t\tMsg(\"PUBLISH_CHARGE_ITEM_FAILED\")\n\t\t\t}\n\t\t}(snapId)\n\t}\n\twg.Wait()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/task.go",
        "code_start_line": 25,
        "code_end_line": 32,
        "code_key": "UpdateExecuteTime",
        "code_value": "func (t *Task) UpdateExecuteTime(ctx context.Context) {\n\tinterval := t.Interval * time.Duration(t.Count)\n\tif interval >= t.MaxInterval {\n\t\tinterval = t.MaxInterval\n\t}\n\t// 这里应该是执行完成的时间加上等待时间\n\tt.NextTriggerTime = time.Now().Add(time.Second * interval)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/cbs_bill_compute_task.go",
        "code_start_line": 64,
        "code_end_line": 90,
        "code_key": "ProcessUserCbsResources",
        "code_value": "func (t *CbsBillComputeTask) ProcessUserCbsResources(user *user.User, resIds []measure.ResourceId) {\n\tcbsSrv := t.ResSrv.(*measure.CbsSrv)\n\t// 不同用户的资源数是不一致的，这里顺序处理的话性能一般，需要放在协程中跑\n\t// 单个用户最多启动100个协程，避免协程过多\n\tvar wg sync.WaitGroup\n\tfor _, cbsInstanceId := range resIds {\n\t\twg.Add(1)\n\t\tgo func(cbsInstanceId measure.ResourceId) {\n\t\t\tdefer wg.Done()\n\t\t\t// 并发的控制策略: 同时处理的用户不超过t.Concurrency个，所有用户共享t.Concurrency * 100个协程\n\t\t\t// 这样设计的目的是为了规避用户资源倾斜严重的问题，同时也能保证用户的并发度较少\n\t\t\tt.ResSemaphore <- struct{}{}\n\t\t\tdefer func() {\n\t\t\t\t<-t.ResSemaphore\n\t\t\t}()\n\n\t\t\tlogs.Info(t.Ctx).\n\t\t\t\tUint64(\"appId\", uint64(user.AppId)).\n\t\t\t\tStr(\"cbsInstanceId\", string(cbsInstanceId)).\n\t\t\t\tMsg(\"PROCESS_SIGNAL_DISK\")\n\n\t\t\tchargeItem := cbsSrv.BuildResChargeItem(user, cbsInstanceId, t.ChargeTime)\n\t\t\tt.ProcessSingleChargeItem(user, cbsInstanceId, chargeItem)\n\t\t}(cbsInstanceId)\n\t}\n\twg.Wait()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/repush_user_billing_task.go",
        "code_start_line": 103,
        "code_end_line": 172,
        "code_key": "ProcessSingleRepushDetail",
        "code_value": "func (t *RepushUserBillingTask) ProcessSingleRepushDetail(detail *measure.RepushDetail) error {\n\tcbsMeasureRepo := registry.GetRegistry(t.ctx).AdapterRepos.CbsMeasureRepo.(measure.CbsMeasureRepoIFace)\n\tappIdResIdMaps := make(map[user.AppId][]measure.ResourceId)\n\tif detail.AppId > 0 {\n\t\tif len(detail.ResIds) > 0 {\n\t\t\tappIdResIdMaps[detail.AppId] = detail.ResIds\n\t\t} else {\n\t\t\tids, err := cbsMeasureRepo.GetResourceIdsByAppId(t.ctx, int64(detail.AppId), time.Time{}, true, cbsMeasureRepo.GetBalanceTableName())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tresIds := make([]measure.ResourceId, 0, len(ids))\n\t\t\tfor _, resId := range ids {\n\t\t\t\tresIds = append(resIds, measure.ResourceId(resId))\n\t\t\t}\n\t\t\tappIdResIdMaps[detail.AppId] = resIds\n\t\t}\n\t} else {\n\t\tif len(detail.ResIds) > 0 {\n\t\t\treturn fmt.Errorf(\"AppId is required when ResIds is set\")\n\t\t}\n\t\tlogs.Info(t.ctx).Msg(\"REPUSH_ALL_FOR_APPID_NOT_SET\")\n\t\tappIds, _ := cbsMeasureRepo.GetAppIdsWithResources(t.ctx, time.Time{}, true, cbsMeasureRepo.GetBalanceTableName())\n\t\tfor _, appId := range appIds {\n\t\t\t// 没有指定资源，则补量所有资源\n\t\t\tids, err := cbsMeasureRepo.GetResourceIdsByAppId(t.ctx, appId, time.Time{}, true, cbsMeasureRepo.GetBalanceTableName())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tresIds := make([]measure.ResourceId, 0, len(ids))\n\t\t\tfor _, resId := range ids {\n\t\t\t\tresIds = append(resIds, measure.ResourceId(resId))\n\t\t\t}\n\t\t\tappIdResIdMaps[user.AppId(appId)] = resIds\n\t\t}\n\n\t}\n\n\tvar repushItems []*RepushItem\n\tfor appId, resIds := range appIdResIdMaps {\n\t\tu, err := t.userSrv.GetUser(appId)\n\t\tif err != nil {\n\t\t\t// 这里可能是新注册的用户，user表里没有用户数据，可能会丢失该用户的量\n\t\t\tlogs.Error(t.ctx).Err(err).Uint64(\"appId\", uint64(appId)).Msg(\"GET_USER_ERROR\")\n\t\t\tpanic(err)\n\t\t}\n\t\tfor _, resId := range resIds {\n\t\t\tvar repushItem RepushItem\n\t\t\trepushItem.user = u\n\t\t\trepushItem.cbsInstanceId = resId\n\t\t\trepushItem.startTime = detail.StartTime\n\t\t\trepushItem.endTime = detail.EndTime\n\t\t\trepushItems = append(repushItems, &repushItem)\n\t\t}\n\t}\n\tlogs.Info(t.ctx).Int(\"count\", len(repushItems)).Msg(\"REPUSH_ITEMS_INFO\")\n\n\tvar wg sync.WaitGroup\n\tfor _, repushItem := range repushItems {\n\t\twg.Add(1)\n\t\tt.semaphore <- struct{}{}\n\t\tgo func(item *RepushItem) {\n\t\t\tdefer wg.Done()\n\t\t\tdefer func() { <-t.semaphore }()\n\t\t\tt.ProcessSingleRepushItem(item)\n\t\t}(repushItem)\n\t}\n\twg.Wait()\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/cbs_measure_send_task.go",
        "code_start_line": 56,
        "code_end_line": 81,
        "code_key": "ProcessMsgByRegion",
        "code_value": "func (t *CbsMeasureSendTask) ProcessMsgByRegion() {\n\t// 并发处理消息\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < t.Conf.Concurrency; i++ {\n\t\twg.Add(1)\n\t\tgo func(workId int) {\n\t\t\tlog.Infof(\"start work %d\", workId)\n\t\t\tdefer wg.Done()\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase msg, ok := <-t.DomesticChan:\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.ProcessMsgToMeasureDetail(msg)\n\t\t\t\tcase <-t.Ctx.Done():\n\t\t\t\t\tlogs.Info(t.Ctx).Int(\"work_id\", workId).Msg(\"STOP_WORKER\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n\t// 关闭chan\n\twg.Wait()\n\tclose(t.MeasureDetailChan)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_measure_send_task.go",
        "code_start_line": 51,
        "code_end_line": 76,
        "code_key": "ProcessMsgByRegion",
        "code_value": "func (t *SnapMeasureSendTask) ProcessMsgByRegion() {\n\t// 并发处理消息\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < t.Conf.Concurrency; i++ {\n\t\twg.Add(1)\n\t\tgo func(workId int) {\n\t\t\tlog.Infof(\"start work %d\", workId)\n\t\t\tdefer wg.Done()\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase msg, ok := <-t.DomesticChan:\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.ProcessMsgToMeasureDetail(msg)\n\t\t\t\tcase <-t.Ctx.Done():\n\t\t\t\t\tlogs.Info(t.Ctx).Int(\"work_id\", workId).Msg(\"STOP_WORKER\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n\t// 关闭chan\n\twg.Wait()\n\tclose(t.MeasureDetailChan)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/cbs_rec_task.go",
        "code_start_line": 111,
        "code_end_line": 136,
        "code_key": "ProcessMsg",
        "code_value": "func (t *CbsMeasureRecTask) ProcessMsg() {\n\t// 并发处理消息\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < t.Conf.Concurrency; i++ {\n\t\twg.Add(1)\n\t\tgo func(workId int) {\n\t\t\tlog.Infof(\"start work %d\", workId)\n\t\t\tdefer wg.Done()\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase msg, ok := <-t.DomesticChan:\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.ProcessMsgToMeasure(msg)\n\t\t\t\tcase <-t.Ctx.Done():\n\t\t\t\t\tlogs.Info(t.Ctx).Int(\"work_id\", workId).Msg(\"STOP_WORKER\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n\t// 关闭chan\n\twg.Wait()\n\tclose(t.CbsMeasureDetailChan)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_rec_task.go",
        "code_start_line": 63,
        "code_end_line": 105,
        "code_key": "sendDbFromMsg",
        "code_value": "func (t *SnapMeasureReconciliationTask) sendDbFromMsg(wg *sync.WaitGroup) {\n\t// 并发处理消息\n\n\tfor i := 0; i < t.Concurrency; i++ {\n\t\twg.Add(1)\n\t\tgo func(workId int) {\n\t\t\tlog.Infof(\"start work %d\", workId)\n\t\t\tdefer wg.Done()\n\t\t\tunConfirmedMap := make(map[measure.ResourceId]mqiface.IMessage)\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase msg := <-t.snapChargeItemForCompareConsumer.Receiving(mq.MSGTYPE_JSON):\n\t\t\t\t\tchargeItem, _ := parseChargeItem(msg)\n\t\t\t\t\tresourceId := chargeItem.ResourceId\n\t\t\t\t\tunConfirmedMap[resourceId] = msg\n\n\t\t\t\t\t// 达到指定数量后进行数据库同步\n\t\t\t\t\tif len(unConfirmedMap) == 100 {\n\t\t\t\t\t\tlog.Infof(\"unConfirmedMap num %d\", len(unConfirmedMap))\n\t\t\t\t\t\terr := t.ProcessMsgSendMeasure(t.ctx, unConfirmedMap)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tjsonData, _ := json.Marshal(unConfirmedMap)\n\t\t\t\t\t\t\tlogs.Error(t.ctx).Err(err).Str(\"process_msg_send_measure_failed\", string(jsonData)).Msg(\"BATCH_PROCESS_SEND_MEASURE_FAILED\")\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\tcase <-time.After(5 * time.Second):\n\t\t\t\t\tif len(unConfirmedMap) > 0 {\n\t\t\t\t\t\tlogs.Info(t.ctx).Int(\"time_out_process_msg_nums\", len(unConfirmedMap)).Msg(\"TIME_OUT_PROCESS_MSG\")\n\t\t\t\t\t\terr := t.ProcessMsgSendMeasure(t.ctx, unConfirmedMap)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tjsonData, _ := json.Marshal(unConfirmedMap)\n\t\t\t\t\t\t\tlogs.Error(t.ctx).Err(err).Str(\"send_fail_detail\", string(jsonData)).Msg(\"TIMEOUT_PROCESS_SEND_MEASURE_FAILED\")\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tcase <-t.ctx.Done():\n\t\t\t\t\tlogs.Info(t.ctx).Int(\"work_id\", workId).Msg(\"STOP_WORKER\")\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_rec_task.go",
        "code_start_line": 134,
        "code_end_line": 150,
        "code_key": "AckResourceID",
        "code_value": "func (t *SnapMeasureReconciliationTask) AckResourceID() {\n\t// Ack逻辑：AppId关联的所有ChargeItem全部都confirmed了才触发对AppId的Ack\n\tgo func() {\n\t\tfor {\n\t\t\tt.m.Lock()\n\t\t\tfor resourceId := range t.ResourceIdMsgMap {\n\t\t\t\tt.snapChargeItemForCompareConsumer.Ack(t.ResourceIdMsgMap[resourceId])\n\t\t\t\tdelete(t.ResourceIdMsgMap, resourceId)\n\t\t\t\tlogs.Info(t.ctx).Str(\"resource_id\", string(resourceId)).Str(\"resource_id\", string(resourceId)).Msg(\"ACK_RESOURCE_ID\")\n\t\t\t}\n\t\t\tt.m.Unlock()\n\n\t\t\ttime.Sleep(time.Microsecond * 100)\n\t\t}\n\t}()\n\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/base_measure/base_send_measure_task.go",
        "code_start_line": 140,
        "code_end_line": 159,
        "code_key": "AckResourceID",
        "code_value": "func (t *BaseSendMeasureTask) AckResourceID() {\n\t// Ack逻辑：AppId关联的所有ChargeItem全部都confirmed了才触发ACK\n\tt.WG.Add(1)\n\tdefer t.WG.Done()\n\tgo func() {\n\t\tfor {\n\t\t\tt.m.Lock()\n\t\t\tfor resourceId, msgList := range t.unConfirmedMap {\n\t\t\t\tlogs.Info(t.ctx).Str(\"resourceId\", string(resourceId)).Int(\"size\", len(msgList)).Fields(t.unConfirmedMap).Msg(\"CHECK_RESOURCE_ID_CONFIRMED\")\n\t\t\t\tif len(msgList) == 0 {\n\t\t\t\t\tdelete(t.unConfirmedMap, resourceId)\n\t\t\t\t\tt.AckMessage(string(resourceId))\n\t\t\t\t}\n\t\t\t}\n\t\t\tt.m.Unlock()\n\t\t\ttime.Sleep(time.Millisecond * 100)\n\t\t}\n\t}()\n\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/base_measure/base_send_measure_task.go",
        "code_start_line": 261,
        "code_end_line": 313,
        "code_key": "ProcessParamsSendMeasure",
        "code_value": "func (t *BaseSendMeasureTask) ProcessParamsSendMeasure() {\n\tvar wg sync.WaitGroup\n\tsemaphore := make(chan struct{}, 100) // Semaphore with a capacity of 100\n\n\tfor {\n\t\tselect {\n\t\tcase param, ok := <-t.MeasureParamChan:\n\t\t\tif !ok {\n\t\t\t\tlogs.Info(t.Ctx).Msg(\"MEASURE_DETAIL_CHAN_CLOSED\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\twg.Add(1) // Increment the WaitGroup counter\n\n\t\t\tgo func(param interface{}) {\n\t\t\t\tdefer wg.Done() // Decrement the WaitGroup counter when the goroutine completes\n\n\t\t\t\tsemaphore <- struct{}{}        // Acquire a semaphore slot\n\t\t\t\tdefer func() { <-semaphore }() // Release the semaphore slot\n\n\t\t\t\t// Convert param to paraMap\n\t\t\t\tparaMap := make(map[string]interface{})\n\t\t\t\tdata, _ := json.Marshal(param)\n\t\t\t\t_ = json.Unmarshal(data, &paraMap)\n\n\t\t\t\t_, err := t.SendMeasureData(t.Ctx, paraMap)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogs.Info(t.Ctx).Any(\"param\", paraMap).Msg(\"SEND_MEASURE_DATA_ERROR\")\n\t\t\t\t}\n\n\t\t\t\t// Process measureDetail and subMeasureDetail\n\t\t\t\tmeasureDetail := paraMap[\"measureDetail\"].([]interface{})\n\t\t\t\tfor _, measureDetail := range measureDetail {\n\t\t\t\t\tmeasureMap := measureDetail.(map[string]interface{})\n\t\t\t\t\tserialId := measureMap[\"serialId\"].(string)\n\t\t\t\t\tsubMeasureDetail := measureMap[\"subMeasureDetail\"].([]interface{})\n\n\t\t\t\t\tfor _, subMeasure := range subMeasureDetail {\n\t\t\t\t\t\tsubMeasureMap := subMeasure.(map[string]interface{})\n\t\t\t\t\t\tdosageId := subMeasureMap[\"dosageId\"].(string)\n\t\t\t\t\t\tt.MarkMeasureDetailDone(measure.ResourceId(serialId), measure.DosageId(dosageId))\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}(param)\n\n\t\tcase <-t.Ctx.Done():\n\t\t\tlogs.Info(t.Ctx).Msg(\"CTX_DONE\")\n\t\t\twg.Wait() // Wait for all goroutines to complete\n\t\t\treturn\n\t\t}\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/base_measure/base_bill_compute_task.go",
        "code_start_line": 76,
        "code_end_line": 122,
        "code_key": "GetUserResources",
        "code_value": "func (t *BaseBillComputeTask) GetUserResources() {\n\t// 启动多个worker用来处理单用户的快照资源\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < t.userConcurrency; i++ {\n\t\twg.Add(1)\n\t\tgo func(workId int) {\n\t\t\tdefer wg.Done()\n\t\t\tlogs.Info(t.ctx).Int(\"workId\", workId).Msg(\"START_WORKER\")\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase msg, ok := <-t.AppIdConsumer.Receiving(mq.MSGTYPE_TEXT):\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\tlogs.Error(t.ctx).Msg(\"STOP_WORKER\")\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tappId, _ := parseAppId(msg)\n\t\t\t\t\tu, err := t.userSrv.GetUser(appId)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t// 这里可能是新注册的用户，user表里没有用户数据，可能会丢失该用户的量\n\t\t\t\t\t\tlogs.Error(t.ctx).Err(err).Uint64(\"appId\", uint64(appId)).Msg(\"PROCESS_SIGNAL_USER_FAILED\")\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\tt.AddToAckMessage(strconv.FormatUint(uint64(appId), 10), msg)\n\t\t\t\t\terr = t.ProcessSingleUser(u)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlogs.Error(t.ctx).Err(err).Uint64(\"appId\", uint64(appId)).Msg(\"PROCESS_SIGNAL_USER_FAILED\")\n\t\t\t\t\t}\n\t\t\t\tcase <-t.ctx.Done():\n\t\t\t\t\tlogs.Info(t.ctx).Int(\"workId\", workId).Msg(\"STOP_WORKER\")\n\t\t\t\t\treturn\n\t\t\t\tcase <-time.After(time.Second * 10):\n\t\t\t\t\tlogs.Debug(t.ctx).Int(\"workId\", workId).Msg(\"WAIT_MSG_TIMEOUT\")\n\t\t\t\t\t// 队列为空，也没有待Confirm数据的数据\n\t\t\t\t\tif t.AppIdConsumer.QueueIsEmpty() && len(t.unConfirmedMap) == 0 {\n\t\t\t\t\t\tlogs.Info(t.ctx).Int(\"workId\", workId).Msg(\"STOP_WORKER_FOR_QUEUE_EMPTY\")\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}(i)\n\t}\n\t// 关闭chan\n\twg.Wait()\n\tclose(t.UserResChan)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/base_measure/base_bill_compute_task.go",
        "code_start_line": 175,
        "code_end_line": 215,
        "code_key": "AckAppId",
        "code_value": "func (t *BaseBillComputeTask) AckAppId() {\n\tt.WG.Add(1)\n\tdefer t.WG.Done()\n\t// Ack逻辑：AppId关联的所有ChargeItem全部都confirmed了才触发对AppId的Ack\n\tgo func() {\n\t\tfor {\n\t\t\tt.m.Lock()\n\t\t\tfor appId, msgList := range t.unConfirmedMap {\n\t\t\t\tlogs.Info(t.ctx).Uint64(\"appId\", uint64(appId)).Int(\"size\", len(msgList)).Fields(t.unConfirmedMap).Msg(\"CHECK_APPID_CONFIRMED\")\n\t\t\t\tif len(msgList) == 0 {\n\t\t\t\t\tt.AckMessage(strconv.FormatUint(uint64(appId), 10))\n\t\t\t\t\tdelete(t.unConfirmedMap, appId)\n\t\t\t\t}\n\t\t\t}\n\t\t\tt.m.Unlock()\n\t\t\ttime.Sleep(time.Millisecond * 100)\n\t\t}\n\t}()\n\n\t// Confirm逻辑，确认chargeItem放入队列后，将chargeItem关联的resourceId从未确认map中删除\n\tfor confirm := range t.ChargeItemProducer.Confirm() {\n\t\tt.WG.Add(1)\n\t\tchargeItem := confirm.GetData().(*measure.ChargeItem)\n\t\tif confirm.GetPublishResult() != mq.PUBLISH_RESULT_SUCCESS {\n\t\t\t// 告警出来，后期补量，部分成功不好处理\n\t\t\tlogs.Error(t.ctx).Any(\"chargeItem\", chargeItem).Msg(\"CHARGE_ITEM_PUBLISH_FAILED\")\n\t\t\tcontinue\n\t\t}\n\t\t// 到这里就代表chargeItem已经发送到队列，理论上不会漏推\n\t\t// FIXME 可能会导致重复推量\n\t\tgo func(innerChargeItem *measure.ChargeItem) {\n\t\t\tdefer t.WG.Done()\n\t\t\terr := t.ResSrv.UpdateResBalanceRecords(innerChargeItem.AppId, innerChargeItem)\n\t\t\tif err != nil {\n\t\t\t\tlogs.Error(t.Ctx).Err(err).Uint64(\"appId\", uint64(innerChargeItem.AppId)).\n\t\t\t\t\tStr(\"resourceId\", string(innerChargeItem.ResourceId)).Msg(\"UPDATE_CBS_BALANCE_RECORD_FAILED\")\n\t\t\t}\n\t\t}(chargeItem)\n\t\tt.MarkSingleResDone(chargeItem.AppId, chargeItem.ResourceId)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_rec_task_scanner.go",
        "code_start_line": 39,
        "code_end_line": 41,
        "code_key": "FullScan",
        "code_value": "func (s *CbsMeasureReconciliationTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_rec_task_scanner.go",
        "code_start_line": 37,
        "code_end_line": 39,
        "code_key": "FullScan",
        "code_value": "func (s *SnapMeasureReconciliationTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_compute_task_scanner.go",
        "code_start_line": 39,
        "code_end_line": 41,
        "code_key": "FullScan",
        "code_value": "func (s *SnapComputeTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_measure_send_task_scanner.go",
        "code_start_line": 39,
        "code_end_line": 41,
        "code_key": "FullScan",
        "code_value": "func (s *CbsMeasureSendTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_bill_valid_appId_fetch_task_scanner.go",
        "code_start_line": 39,
        "code_end_line": 41,
        "code_key": "FullScan",
        "code_value": "func (s *CbsValidAppIdFetchTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_calculate_cost_locally_task_scanner.go",
        "code_start_line": 38,
        "code_end_line": 40,
        "code_key": "FullScan",
        "code_value": "func (s *SnapCalculateCostLocallyTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_create_task_scanner.go",
        "code_start_line": 50,
        "code_end_line": 78,
        "code_key": "FullScan",
        "code_value": "func (s *UpdateCreateTaskScanner) FullScan(ctx context.Context) error {\n\tsnapRepo := registry.GetRegistry(ctx).AdapterRepos.SnapRepo.(adapter_interfaces.SnapInterface)\n\tsnapList, err := snapRepo.QueryCreatingCopyingSnapList(ctx)\n\tif err != nil {\n\t\tlogs.Error(ctx).Err(err).Msg(\"FULL_SCAN_FAILED\")\n\t\treturn err\n\t}\n\tresultCnt := 0\n\tfor _, snapRecord := range snapList {\n\t\t// 剔除快照组预生成的快照记录\n\t\tif strings.Contains(snapRecord.SnapUuid, \"temp\") {\n\t\t\tlogs.Info(ctx).Str(\"SnapId\", snapRecord.SnapInstanceId).Msgf(\"PRE_CREATED_SNAPSHOT_SKIP_UPDATE\")\n\t\t\tcontinue\n\t\t}\n\n\t\tentity := &snapLogical.Entity{\n\t\t\tSnapRecord: snapRecord,\n\t\t}\n\t\tsnapAggregate := &snapLogical.SnapCreateTaskAggregate{\n\t\t\tEntity:      entity,\n\t\t\tTaskName:    core.UpdateCreateTask,\n\t\t\tSubTaskName: core.UpdateCreateTask,\n\t\t}\n\t\ts.resultChan <- snapAggregate\n\t\tresultCnt += 1\n\t}\n\ts.resultChanMetric.Add(float64(resultCnt))\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_measure_send_task_scanner.go",
        "code_start_line": 38,
        "code_end_line": 40,
        "code_key": "FullScan",
        "code_value": "func (s *SnapMeasureSendTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/repush_user_billing_task_scanner.go",
        "code_start_line": 41,
        "code_end_line": 43,
        "code_key": "FullScan",
        "code_value": "func (s *RepushUserBillingTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_rollback_task_scanner.go",
        "code_start_line": 103,
        "code_end_line": 113,
        "code_key": "FullScan",
        "code_value": "func (s *UpdateRollbackTaskScanner) FullScan(ctx context.Context) error {\n\tif err := s.getCCbsRollbackTask(ctx); err != nil {\n\t\tlogs.Error(ctx).Err(err).Msg(\"FULL_SCAN_FAILED\")\n\t\treturn err\n\t}\n\tif err := s.getImageSnapRollbackTask(ctx); err != nil {\n\t\tlogs.Error(ctx).Err(err).Msg(\"FULL_SCAN_FAILED\")\n\t\treturn err\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_valid_appId_fetch_task_scanner.go",
        "code_start_line": 38,
        "code_end_line": 40,
        "code_key": "FullScan",
        "code_value": "func (s *SnapValidAppIdFetchTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_bill_compute_task_scanner.go",
        "code_start_line": 41,
        "code_end_line": 43,
        "code_key": "FullScan",
        "code_value": "func (s *CbsBillComputeTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/client/client.go",
        "code_start_line": 20,
        "code_end_line": 62,
        "code_key": "Request",
        "code_value": "func (c *BaseClient) Request(ctx context.Context, interfaceName string, reqJsonData []byte) ([]byte, error) {\n\tlogger := logs.With(ctx).Str(\"interface\", interfaceName).Logger()\n\tlogger.Info().Str(\"para\", string(reqJsonData)).Msg(\"NEW_REQUEST\")\n\n\tctx, cancel := context.WithTimeout(ctx, time.Second*time.Duration(c.Timeout))\n\tdefer cancel()\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPost, c.Url, bytes.NewReader(reqJsonData))\n\n\tif global.TestEnv {\n\t\treq.Header.Add(\"X-QCloud-Transaction-ID\", uuid.New().String())\n\t\treq.Header.Add(\"X-QCloud-User-ID\", global.TestUin)\n\t}\n\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"new request failed: %v\", err)\n\t}\n\theader := \"\"\n\tfor key, value := range req.Header {\n\t\theader += fmt.Sprintf(\"-H \\\"%s: %s\\\" \", key, value[0])\n\t}\n\tcurl := fmt.Sprintf(\"curl %s --connect-timeout %d -d '%s' %s\", header, c.Timeout, string(reqJsonData), c.Url)\n\tlogger.Info().Any(\"cmd\", curl).Msgf(\"SHOW_CURL_CMD\")\n\n\trsp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\tlogger.Error().Err(err).Msgf(\"RESPONSE_ERR\")\n\t\treturn nil, fmt.Errorf(\"do request failed: %v\", err)\n\t}\n\tdefer func(Body io.ReadCloser) {\n\t\t_ = Body.Close()\n\t}(rsp.Body)\n\n\tif rsp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"unexpected status code: %d\", rsp.StatusCode)\n\t}\n\tbodyData, err := io.ReadAll(rsp.Body)\n\tlogger.Info().Any(\"response\", string(bodyData)).Msgf(\"SHOW_RESPONSE\")\n\tif err != nil {\n\t\tlogger.Error().Err(err).Msgf(\"RESPONSE_ERR\")\n\t\treturn nil, err\n\t}\n\treturn bodyData, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go",
        "code_start_line": 83,
        "code_end_line": 103,
        "code_key": "AddTask",
        "code_value": "func (sc *Scheduler) AddTask(ctx context.Context, newTask interfaces.Task) {\n\tvalue, ok := sc.taskMap.Load(newTask.GetTaskId())\n\tif !ok {\n\t\tsc.syncTaskPriorityQueue.Push(newTask)\n\t\tsc.taskMap.Store(newTask.GetTaskId(), newTask)\n\t\tsc.addTimerEvent(newTask.GetTaskId())\n\t\tsc.metrics.taskCountInQueue.Add(1)\n\t} else {\n\t\t// 对于已存在的任务需要判断subTaskName是否发生变化\n\t\t// 存在任务切换的场景，如order -> trigger，需要将旧任务删除，新任务插入\n\t\ttask := value.(interfaces.Task)\n\t\tif task.GetSubTaskName() != newTask.GetSubTaskName() {\n\t\t\tlogs.Info(ctx).Str(\"TaskId\", task.GetTaskId()).Msg(\"FOUND_SUB_TASK_CHANGED\")\n\t\t\t// 更新taskMap中的task记录，并插入优先队列\n\t\t\tsc.taskMap.Store(newTask.GetTaskId(), newTask)\n\t\t\tsc.syncTaskPriorityQueue.Push(newTask)\n\t\t\tsc.addTimerEvent(newTask.GetTaskId())\n\t\t\tsc.metrics.taskCountInQueue.Add(1)\n\t\t}\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go",
        "code_start_line": 120,
        "code_end_line": 131,
        "code_key": "tryGetWorker",
        "code_value": "func (sc *Scheduler) tryGetWorker(ctx context.Context) bool {\n\tsc.mutex.Lock()\n\tdefer sc.mutex.Unlock()\n\n\tif sc.workerNum > 0 {\n\t\tsc.workerNum--\n\t\tsc.wg.Add(1)\n\t\tsc.metrics.idleWorkerNum.Set(float64(sc.workerNum))\n\t\treturn true\n\t}\n\treturn false\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go",
        "code_start_line": 217,
        "code_end_line": 221,
        "code_key": "rePushTask",
        "code_value": "func (sc *Scheduler) rePushTask(ctx context.Context, task interfaces.Task) {\n\tsc.syncTaskPriorityQueue.Push(task)\n\tsc.metrics.taskCountInQueue.Add(1)\n\tsc.addTimerEvent(task.GetTaskId())\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/mq/mqimpl/rabbitMq/producer.go",
        "code_start_line": 71,
        "code_end_line": 96,
        "code_key": "Confirm",
        "code_value": "func (p *Producer) Confirm() <-chan mqiface.IMessage {\n\t/*\n\t\tConfirm主要是用来获取消息的发送结果，并将对象的消息放入channel中\n\t\tconfirm.DeliveryTag是rabbitmq维护的channel级的唯一标识，实际的值来源于channel.published,\n\t\t但是这个变量不对外暴露，所以在publish操作中也维护了一个producer级的published变量，二者值是一致的\n\t*/\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase confirm, ok := <-p.Confirms:\n\t\t\t\tif !ok {\n\t\t\t\t\tlogs.Info(p.Ctx).Msg(\"CONFIRM_CHANNEL_CLOSED\")\n\t\t\t\t\t// 关闭p.confirmedMsgChannel\n\t\t\t\t\tp.wg.Wait()\n\t\t\t\t\tclose(p.confirmedMsgChannel)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tp.wg.Add(1)\n\t\t\t\tgo p.processConfirmation(confirm)\n\t\t\tcase <-p.Ctx.Done():\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}()\n\treturn p.confirmedMsgChannel\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/cmd/rdisk_master/run.go",
        "code_start_line": 63,
        "code_end_line": 80,
        "code_key": "runScheduler",
        "code_value": "func runScheduler(appCtx context.Context, wg *sync.WaitGroup) {\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ts := app.GlobalRegistry.Scheduler\n\t\tsignalChan := make(chan os.Signal, 10)\n\t\tsignal.Notify(signalChan, unix.SIGINT, unix.SIGTERM, unix.SIGSEGV)\n\n\t\tgo func(c chan os.Signal) {\n\t\t\t<-c\n\t\t\ts.Stop()\n\t\t}(signalChan)\n\n\t\tif err := s.Start(appCtx); err != nil {\n\t\t\tlogs.Fatal(appCtx).Err(err).Msg(\"scheduler exited\")\n\t\t}\n\t}()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/cmd/rdisk_master/run.go",
        "code_start_line": 83,
        "code_end_line": 92,
        "code_key": "runApiServer",
        "code_value": "func runApiServer(appCtx context.Context, wg *sync.WaitGroup) {\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ts := apiserver.New(appCtx)\n\t\tif err := s.Serve(); err != nil {\n\t\t\tlogs.Fatal(appCtx).Err(err).Msg(\"server exited\")\n\t\t}\n\t}()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/cmd/rdisk_master/run.go",
        "code_start_line": 172,
        "code_end_line": 182,
        "code_key": "initSchedulers",
        "code_value": "func initSchedulers(ctx context.Context) {\n\tapp.GlobalRegistry.Scheduler = scheduler.New(ctx, app.GlobalRegistry.Locker)\n\n\t// 注册定时任务\n\n\tapp.GlobalRegistry.Scheduler.Add(\"update_backup_task\", &tasks.UpdateBackupTask{})\n\tapp.GlobalRegistry.Scheduler.Add(\"recycle_backup_task\", &tasks.RecycleBackupTask{})\n\tapp.GlobalRegistry.Scheduler.Add(\"update_benchmark_task\", &tasks.UpdateBenchmarkTask{})\n\tapp.GlobalRegistry.Scheduler.Add(\"confirm_init_physicaldisk_task\", &tasks.ConfirmInitPhysicalDiskTask{})\n\tapp.GlobalRegistry.Scheduler.Add(\"cleanup_defunct_task\", &tasks.CleanupDefunctTask{})\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/dispatcher/dispatcher.go",
        "code_start_line": 33,
        "code_end_line": 103,
        "code_key": "Dispatch",
        "code_value": "func (d *dispatcherImpl) Dispatch(ctx context.Context, cmd app.Command) (err error) {\n\t// 为什么使用 backgroundCtx 而不是 ctx？\n\t// 因为 ctx 代表调用方的上下文，通常是 rpc 请求上下文。\n\t// 而执行命令的上下文，应该是一个独立的上下文，不应该受到调用方的影响\n\t// 即使由于网络抖动等原因，调用方的上下文已经超时，但是命令执行的上下文仍然应该继续执行。\n\tworkerCtx := context.WithValue(d.backgroundCtx, ctxKeyCommand, cmd)\n\tworkerCtx, cancelFunc := context.WithTimeout(workerCtx, d.workerTimeout)\n\tworkerCtx = logs.GetLogger(ctx).WithContext(workerCtx)\n\tlockKeys := cmd.LockKeys()\n\terrChan := make(chan error, 1)\n\tlockOption := &dlock.Option{\n\t\tRetryStrategy: dlock.ExponentialBackoff(100*time.Millisecond, 6*time.Second),\n\t}\n\td.wg.Add(1)\n\t// 最终打印错误\n\t// TODO: 并发控制最大能同时执行的命令数量\n\tgo func() {\n\t\tdefer d.wg.Done()\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\te, ok := err.(error)\n\t\t\t\tif !ok {\n\t\t\t\t\te = errors.Newf(ErrDispatchPanic, \"dispatcher panic: %v\", err)\n\t\t\t\t}\n\t\t\t\terrChan <- e\n\t\t\t\tlogs.Error(workerCtx).Err(e).Stack().Bytes(\"trace\", debug.Stack()).Msgf(\"command execution panic\")\n\t\t\t}\n\t\t}()\n\n\t\tdefer cancelFunc()\n\n\t\tif lockKeys != nil {\n\t\t\tlock, err := d.locker.ObtainMulti(workerCtx, lockKeys, d.workerTimeout, lockOption)\n\t\t\tif err != nil {\n\t\t\t\terrChan <- err\n\t\t\t\tlogs.Warn(workerCtx).Err(err).Msgf(\"command execution waiting locks timeout\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer lock.Release(workerCtx)\n\t\t}\n\n\t\tuow := app.GetRegistry(ctx).Repositories.UoWFactory.New()\n\t\tworkerCtx = app.GetRegistry(ctx).Repositories.UoWFactory.With(workerCtx, uow)\n\n\t\terr = cmd.Handle(workerCtx)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, errors.ErrDryRunSuccessExit) {\n\t\t\t\terr = nil\n\t\t\t} else {\n\t\t\t\tlogs.Warn(workerCtx).Err(err).Msgf(\"command execution failed\")\n\t\t\t}\n\t\t\t_err := uow.Rollback(workerCtx)\n\t\t\tif _err != nil {\n\t\t\t\tlogs.Error(workerCtx).Err(_err).Msgf(\"unit of work rollback failed\")\n\t\t\t}\n\t\t} else {\n\t\t\terr = uow.Commit(workerCtx)\n\t\t\tif err != nil {\n\t\t\t\tlogs.Error(workerCtx).Err(err).Msgf(\"unit of work commit failed\")\n\t\t\t}\n\t\t}\n\t\terrChan <- err\n\t\tclose(errChan)\n\t}()\n\tselect {\n\tcase err := <-errChan:\n\t\treturn err\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/scheduler.go",
        "code_start_line": 127,
        "code_end_line": 132,
        "code_key": "Add",
        "code_value": "func (s *scheduler) Add(name string, workload WorkLoad) {\n\ts.mutex.Lock()\n\tdefer s.mutex.Unlock()\n\ts.loads[name] = workload\n\ts.eventChan <- name\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/benchmark.go",
        "code_start_line": 17,
        "code_end_line": 29,
        "code_key": "Add",
        "code_value": "func (repo *rdiskBenchmarkRepositoryImpl) Add(ctx context.Context, bench *benchmark.Benchmark) error {\n\tdo := repo.fromModelToDO(bench)\n\tuow := getUow(ctx)\n\tdo.Created = uow.tx.NowFunc()\n\tdo.Updated = uow.tx.NowFunc()\n\tresult := uow.tx.Create(&do)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tbench.ID = do.ID\n\tuow.trackedBenchmarks.Add(bench)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/backup.go",
        "code_start_line": 19,
        "code_end_line": 31,
        "code_key": "Add",
        "code_value": "func (repo *rdiskBackupRepositoryImpl) Add(ctx context.Context, backup *backupPkg.Backup) error {\n\tuow := getUow(ctx)\n\tdo := repo.fromModelToDO(backup)\n\tdo.Created = uow.tx.NowFunc()\n\tdo.Updated = uow.tx.NowFunc()\n\tresult := uow.tx.Create(&do)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tbackup.ID = do.ID\n\tuow.trackedBackups.Add(backup)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go",
        "code_start_line": 76,
        "code_end_line": 91,
        "code_key": "Add",
        "code_value": "func (l logicalVolumeRepositoryImpl) Add(ctx context.Context, lv *rdiskDomain.LogicalVolume) error {\n\tuow := getUow(ctx)\n\tvol := fromModelToDmRDisk(lv)\n\tvol.Created = uow.tx.NowFunc()\n\tvol.Updated = uow.tx.NowFunc()\n\tresult := uow.tx.Create(&vol)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tlv.ID = vol.ID\n\tlv = uow.trackedLogicalVolumes.Add(lv)\n\tif lv.PhysicalVolume != nil {\n\t\tlv.PhysicalVolume = uow.trackedPhyVolumes.Add(lv.PhysicalVolume)\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/uow.go",
        "code_start_line": 23,
        "code_end_line": 30,
        "code_key": "Add",
        "code_value": "func (c *changeTracker[T]) Add(item T) T {\n\tif v, ok := c.items[item.GetID()]; ok {\n\t\treturn v\n\t}\n\tc.items[item.GetID()] = item\n\tc.originalStates[item.GetID()] = item.DeepCopy().(T)\n\treturn item\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go",
        "code_start_line": 59,
        "code_end_line": 71,
        "code_key": "Add",
        "code_value": "func (p *physicalVolumeRepositoryImpl) Add(ctx context.Context, pv *rdiskDomain.PhysicalVolume) error {\n\tuow := getUow(ctx)\n\tvol := fromPhysicalVolumeToDmPhyDisk(ctx, pv)\n\tvol.Created = uow.tx.NowFunc()\n\tvol.Updated = uow.tx.NowFunc()\n\tresult := uow.tx.Create(&vol)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tpv.ID = vol.ID\n\tuow.trackedPhyVolumes.Add(pv)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
        "code_start_line": 96,
        "code_end_line": 108,
        "code_key": "Add",
        "code_value": "func (d drgroupRepositoryImpl) Add(ctx context.Context, group *drgroup.DRGroup) error {\n\tuow := getUow(ctx)\n\tdo := fromModelToDmDRGroup(group)\n\tdo.Created = uow.tx.NowFunc()\n\tdo.Updated = uow.tx.NowFunc()\n\tresult := uow.tx.Clauses(clause.Insert{Modifier: \"IGNORE\"}).Create(&do)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tgroup.ID = do.ID\n\tuow.trackedDRGroups.Add(group)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 41,
        "code_end_line": 46,
        "code_key": "Add",
        "code_value": "func (m *MockLogicalVolumeRepository) Add(arg0 context.Context, arg1 *rdiskDomain.LogicalVolume) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Add\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 49,
        "code_end_line": 52,
        "code_key": "Add",
        "code_value": "func (mr *MockLogicalVolumeRepositoryMockRecorder) Add(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Add\", reflect.TypeOf((*MockLogicalVolumeRepository)(nil).Add), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 40,
        "code_end_line": 45,
        "code_key": "Add",
        "code_value": "func (m *MockPhysicalVolumeRepository) Add(arg0 context.Context, arg1 *rdiskDomain.PhysicalVolume) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Add\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 48,
        "code_end_line": 51,
        "code_key": "Add",
        "code_value": "func (mr *MockPhysicalVolumeRepositoryMockRecorder) Add(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Add\", reflect.TypeOf((*MockPhysicalVolumeRepository)(nil).Add), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 40,
        "code_end_line": 45,
        "code_key": "Add",
        "code_value": "func (m *MockRepository) Add(arg0 context.Context, arg1 *drgroup.DRGroup) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Add\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 48,
        "code_end_line": 51,
        "code_key": "Add",
        "code_value": "func (mr *MockRepositoryMockRecorder) Add(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Add\", reflect.TypeOf((*MockRepository)(nil).Add), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 763,
        "code_end_line": 781,
        "code_key": "initCustomErrorHandler",
        "code_value": "func initCustomErrorHandler() {\n\tdefaultHandler := thttp.DefaultServerCodec.ErrHandler\n\tthttp.DefaultServerCodec.ErrHandler = func(w http.ResponseWriter, r *http.Request, e *errs.Error) {\n\t\t// Add custom error message to response body\n\t\tbody := errBody{\n\t\t\tCode: e.Code,\n\t\t\tMsg:  e.Msg,\n\t\t}\n\t\tbodyData, err := json.Marshal(body)\n\t\tif err != nil {\n\t\t\t// Should never happen\n\t\t\tpanic(err)\n\t\t}\n\n\t\tw.Header().Add(\"Content-Length\", strconv.Itoa(len(bodyData)))\n\t\tdefaultHandler(w, r, e)\n\t\tw.Write(bodyData)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_drgroup.go",
        "code_start_line": 176,
        "code_end_line": 198,
        "code_key": "getOrCreateDRGroup",
        "code_value": "func (c *UpdateLogicalVolumeDRGroupCommand) getOrCreateDRGroup(ctx context.Context, drgRepo drgroup.Repository, spec *drgroup.Spec) (*drgroup.DRGroup, error) {\n\tgroup, err := drgRepo.FindByName(ctx, c.AppID, spec.Name)\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\tgroup = drgroup.New(spec.Name, c.AppID)\n\t\t\tif spec.Affinity > 0 {\n\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t}\n\t\t\tif spec.Type != \"\" {\n\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t}\n\t\t\tif !c.DryRun {\n\t\t\t\terr := drgRepo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn group, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/attach_detach.go",
        "code_start_line": 247,
        "code_end_line": 297,
        "code_key": "UpdateFlowControlOnAllInitiator",
        "code_value": "func UpdateFlowControlOnAllInitiator(ctx context.Context, source rdiskDomain.LogicalVolumeState,\n\ttarget rdiskDomain.LogicalVolumeState, stateCtx app.LogicalVolumeContext) (state rdiskDomain.LogicalVolumeState, err error) {\n\n\tlv := stateCtx.GetLogicalVolume()\n\tif len(lv.Attachments) == 0 {\n\t\tlogs.Info(ctx).Str(\"uuid\", lv.UUID.String()).Msg(\"no attachment found, skip update flow control\")\n\t\treturn target, nil\n\t}\n\n\tvar wg sync.WaitGroup\n\tvar collectedErr []error = make([]error, len(lv.Attachments))\n\n\twg.Add(len(lv.Attachments))\n\n\tfor idx, attachment := range lv.Attachments {\n\t\tgo func(idx int, attachment *rdiskDomain.VolumeAttachment) {\n\t\t\tdefer wg.Done()\n\n\t\t\tblk := app.GetRegistry(ctx).Factories.BlockAgentClient(attachment.IP.String())\n\t\t\treq := cbs_blk_flow_agent.NewUpdateRDiskFlowControlRequest(lv.UUID.String(), lv.PhysicalVolume.DiskID)\n\t\t\treq.SpdkDriver = attachment.Options.SPDKDriver\n\t\t\treq.SetRead(attachment.FlowControlSpec.MaxReadIOPS, attachment.FlowControlSpec.MaxReadMBps)\n\t\t\treq.SetWrite(attachment.FlowControlSpec.MaxWriteIOPS, attachment.FlowControlSpec.MaxWriteMBps)\n\t\t\treq.SetReadWrite(attachment.FlowControlSpec.MaxRWIOPS, attachment.FlowControlSpec.MaxRWMBps)\n\n\t\t\terr = blk.UpdateRDiskFlowControl(ctx, req)\n\t\t\tif err != nil {\n\t\t\t\tlogs.Error(ctx).Err(err).Str(\"ip\", attachment.IP.String()).Msg(\"failed to update flow control\")\n\t\t\t}\n\t\t\tcollectedErr[idx] = err\n\t\t}(idx, attachment)\n\t}\n\n\twg.Wait()\n\n\t// collect error ip and print error count\n\tvar errList []error\n\tvar errIPs []string\n\tfor idx, err := range collectedErr {\n\t\tif err != nil {\n\t\t\terrList = append(errList, err)\n\t\t\terrIPs = append(errIPs, lv.Attachments[idx].IP.String())\n\t\t}\n\t}\n\tif len(errList) > 0 {\n\t\tlogs.Warn(ctx).Errs(\"errors\", errList).Strs(\"host_ips\", errIPs).Msg(\"failed to update flow control on some initiators\")\n\t\treturn source, errors.New(rdiskDomain.ErrUpdateFlowControl, fmt.Sprintf(\"failed to update flow control on some initiators: %v, errors: %v\", errIPs, errList))\n\t}\n\n\treturn target, err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/drgroups.go",
        "code_start_line": 22,
        "code_end_line": 71,
        "code_key": "AddHostToDRGroup",
        "code_value": "func AddHostToDRGroup(ctx context.Context, source rdiskDomain.LogicalVolumeState, target rdiskDomain.LogicalVolumeState, stateCtx app.LogicalVolumeContext) (rdiskDomain.LogicalVolumeState, error) {\n\tdata := stateCtx.(CreateLogicalVolumeContext)\n\tvol := data.GetLogicalVolume()\n\tphy := data.GetPhysicalVolume()\n\tspecs := data.GetDRGroupSpecList()\n\trepo := app.GetRegistry(ctx).Repositories.DRGroup\n\tif len(specs) == 0 {\n\t\treturn target, nil\n\t}\n\tfor _, spec := range specs {\n\t\tgroup, err := repo.FindByName(ctx, vol.AppID, spec.Name)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\tgroup = drgroup.New(spec.Name, vol.AppID)\n\t\t\t\tif spec.Affinity > 0 {\n\t\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t\t}\n\t\t\t\tif spec.Type != \"\" {\n\t\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t\t}\n\t\t\t\terr = repo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn source, err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn source, err\n\t\t\t}\n\t\t}\n\t\tif spec.Affinity > 0 && group.Affinity != spec.Affinity {\n\t\t\tlogs.Info(ctx).Uint64(\"app_id\", uint64(vol.AppID)).\n\t\t\t\tStr(\"group_name\", spec.Name).\n\t\t\t\tInt(\"old_affinity\", group.Affinity).\n\t\t\t\tInt(\"new_affinity\", spec.Affinity).\n\t\t\t\tMsg(\"update affinity of drgroup\")\n\t\t\tgroup.Affinity = spec.Affinity\n\t\t}\n\t\tsubGroup := spec.SubGroup\n\t\tif subGroup == \"\" {\n\t\t\t// 如果没有指定子组，则使用远端 SSD UUID 作为子组名称\n\t\t\t// 相当于每块盘都是一个子组，相当于没有使用子组功能\n\t\t\tsubGroup = vol.UUID.String()\n\t\t}\n\t\terr = group.AddMember(vol.UUID.String(), subGroup, phy.IP.String())\n\t\tif err != nil {\n\t\t\treturn source, err\n\t\t}\n\t}\n\n\treturn target, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/create_phy_disk.go",
        "code_start_line": 32,
        "code_end_line": 70,
        "code_key": "CreatePhysicalVolumeInRepository",
        "code_value": "func CreatePhysicalVolumeInRepository(ctx context.Context, source rdiskDomain.PhysicalVolumeState, target rdiskDomain.PhysicalVolumeState, stateCtx app.PhysicalVolumeContext) (rdiskDomain.PhysicalVolumeState, error) {\n\tcreateCtx := stateCtx.(CreatePhysicalVolumeContext)\n\tphysicalVolume := createCtx.GetPhysicalVolume()\n\tspec := createCtx.GetSpec()\n\tif err := rdiskDomain.CheckSerial(spec.Serial); err != nil {\n\t\treturn source, err\n\t}\n\tif physicalVolume != nil {\n\t\t*physicalVolume = *rdiskDomain.NewPhysicalVolume(spec.Serial, spec.IP, spec.BDF, spec.Size, spec.ZoneID, spec.Cuf)\n\t} else {\n\t\tphysicalVolume = rdiskDomain.NewPhysicalVolume(spec.Serial, spec.IP, spec.BDF, spec.Size, spec.ZoneID, spec.Cuf)\n\t}\n\tphysicalVolume.DataNodeType = spec.DataTypeNode\n\tif spec.VolumeType != \"\" {\n\t\tphysicalVolume.VolumeType = spec.VolumeType\n\t}\n\tif spec.PerformanceRank != \"\" {\n\t\tphysicalVolume.PerformanceRank = spec.PerformanceRank\n\t\tif !physicalVolume.PerformanceRank.IsValid() {\n\t\t\treturn source, errors.Newf(rdiskDomain.ErrInvalidPerformanceRank, \"invalid performance rank %s\", spec.PerformanceRank)\n\t\t}\n\t}\n\tphysicalVolume.State = target\n\tlogs.Info(ctx).\n\t\tStr(\"host_ip\", physicalVolume.IP.String()).\n\t\tStr(\"bdf\", string(physicalVolume.BDF)).\n\t\tStr(\"serial\", string(physicalVolume.Serial)).\n\t\tInt(\"zone_id\", int(physicalVolume.ZoneID)).\n\t\tStr(\"volume_type\", string(physicalVolume.VolumeType)).\n\t\tStr(\"cuf\", string(physicalVolume.Cuf)).\n\t\tStr(\"performance_rank\", string(physicalVolume.PerformanceRank)).\n\t\tMsg(\"created physical volume\")\n\n\terr := app.GetRegistry(ctx).Repositories.PhysicalVolume.Add(ctx, physicalVolume)\n\tif err != nil {\n\t\treturn source, err\n\t}\n\treturn target, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 214,
        "code_end_line": 239,
        "code_key": "StepGivenAPhysicalVol",
        "code_value": "func StepGivenAPhysicalVol(registry *app.Registry, value interface{}) *rdiskDomain.PhysicalVolume {\n\tphysicalVol := &rdiskDomain.PhysicalVolume{\n\t\tEntityMixin:  rdiskDomain.EntityMixin{ID: 1},\n\t\tSerial:       \"12345\",\n\t\tIP:           net.IP{127, 0, 0, 1},\n\t\tBDF:          \"bdf\",\n\t\tDiskID:       0,\n\t\tState:        rdiskDomain.PhysicalVolumeState(value.(int)),\n\t\tSize:         1,\n\t\tVolumeType:   \"NVME\",\n\t\tZoneID:       1,\n\t\tBlockSize:    512,\n\t\tRealSize:     5120,\n\t\tPort:         1,\n\t\tDataNodeType: \"unknown\",\n\t\tCuf:          \"清远-清新-C2\",\n\t}\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\terr := registry.Repositories.PhysicalVolume.Add(workerCtx, physicalVol)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn physicalVol\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 244,
        "code_end_line": 277,
        "code_key": "StepGivenPhysicalVols",
        "code_value": "func StepGivenPhysicalVols(registry *app.Registry, value interface{}, num interface{}) []*rdiskDomain.PhysicalVolume {\n\tvar physicalVols []*rdiskDomain.PhysicalVolume\n\tfor i := 0; i < num.(int); i++ {\n\t\tphysicalVols = append(physicalVols, &rdiskDomain.PhysicalVolume{\n\t\t\tEntityMixin:  rdiskDomain.EntityMixin{},\n\t\t\tSerial:       rdiskDomain.Serial(\"111\" + strconv.Itoa(i)),\n\t\t\tIP:           net.IP{127, 0, byte(((i + 2) / 255) % 255), byte((i + 2) % 255)},\n\t\t\tBDF:          \"bdf\",\n\t\t\tDiskID:       0,\n\t\t\tState:        rdiskDomain.PhysicalVolumeState(value.(int)),\n\t\t\tSize:         1,\n\t\t\tVolumeType:   \"\",\n\t\t\tZoneID:       1,\n\t\t\tBlockSize:    512,\n\t\t\tRealSize:     5120,\n\t\t\tPort:         1,\n\t\t\tDataNodeType: \"\",\n\t\t\tCuf:          \"清远-清新-C2\",\n\t\t})\n\t}\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\tfor _, vol := range physicalVols {\n\t\terr := registry.Repositories.PhysicalVolume.Add(workerCtx, vol)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\terr := uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn physicalVols\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 282,
        "code_end_line": 304,
        "code_key": "StepGivenALogicalVol",
        "code_value": "func StepGivenALogicalVol(registry *app.Registry, physicalVol *rdiskDomain.PhysicalVolume, value interface{}) *rdiskDomain.LogicalVolume {\n\tlogicalVol := &rdiskDomain.LogicalVolume{\n\t\tEntityMixin:     rdiskDomain.EntityMixin{ID: 1},\n\t\tUUID:            uuid.Must(uuid.NewRandom()),\n\t\tState:           rdiskDomain.LogicalVolumeState(value.(int)),\n\t\tSize:            1,\n\t\tAppID:           123,\n\t\tZoneID:          1,\n\t\tDiskType:        \"\",\n\t\tVolumeType:      \"\",\n\t\tFlowControlSpec: rdiskDomain.FlowControlSpec{},\n\t\tPhysicalVolume:  physicalVol,\n\t\tAttachments:     nil,\n\t}\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\terr := registry.Repositories.LogicalVolume.Add(workerCtx, logicalVol)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn logicalVol\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 527,
        "code_end_line": 564,
        "code_key": "StepWhenCreateSomeRDiskVol",
        "code_value": "func StepWhenCreateSomeRDiskVol(ctx context.Context, req interface{}) {\n\trequests := req.([]*pb.CreateRDiskVolRequest)\n\n\t// 创建一个 WaitGroup\n\tvar wg sync.WaitGroup\n\t// 创建一个通道来接收结果\n\tresults := make(chan *pb.CreateRDiskVolResponse, len(requests))\n\terrors := make(chan error, len(requests))\n\n\t// 创建一个 API 服务器实例\n\tapiServer := apiserver.NewMasterApiServer()\n\n\tstart := time.Now()\n\t// 遍历请求列表并启动 goroutine 发送请求\n\tfor _, req := range requests {\n\t\twg.Add(1)\n\t\tgo func(req *pb.CreateRDiskVolRequest) {\n\t\t\tdefer wg.Done()\n\t\t\trsp, err := apiServer.CreateRDiskVol(ctx, req)\n\t\t\tif err != nil {\n\t\t\t\terrors <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\tresults <- rsp\n\t\t}(req)\n\t}\n\n\t// 等待所有 goroutines 完成\n\twg.Wait()\n\tclose(results)\n\tclose(errors)\n\tfmt.Println(\"time:\", time.Since(start))\n\ttime.Sleep(2 * time.Second)\n\t// 处理错误\n\tfor err := range errors {\n\t\tfmt.Println(\"Error:\", err)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/benchmark.go",
        "code_start_line": 42,
        "code_end_line": 50,
        "code_key": "FindByUUID",
        "code_value": "func (repo *rdiskBenchmarkRepositoryImpl) FindByUUID(ctx context.Context, uuid string) (*benchmark.Benchmark, error) {\n\tuow := getUow(ctx)\n\tb := &metadb.DmRdiskBenchmark{}\n\tresult := uow.tx.First(b, \"uuid = ?\", uuid)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\treturn uow.trackedBenchmarks.Add(repo.fromDoToModel(b)), nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/backup.go",
        "code_start_line": 44,
        "code_end_line": 53,
        "code_key": "FindByUUID",
        "code_value": "func (impl *rdiskBackupRepositoryImpl) FindByUUID(ctx context.Context, uuid string) (*backupPkg.Backup, error) {\n\tuow := getUow(ctx)\n\n\tb := &metadb.DmRdiskBackup{}\n\tresult := uow.tx.First(b, \"uuid = ?\", uuid)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\treturn uow.trackedBackups.Add(impl.fromDOToModel(b)), nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go",
        "code_start_line": 22,
        "code_end_line": 47,
        "code_key": "FindByAppIDAndUUID",
        "code_value": "func (logicalVolumeRepositoryImpl) FindByAppIDAndUUID(ctx context.Context, appID users.AppID, id uuid.UUID) (*rdiskDomain.LogicalVolume, error) {\n\tuow := getUow(ctx)\n\tvol := metadb.DmRdisk{}\n\tresult := uow.tx.\n\t\tPreload(\"Attachments\").\n\t\tPreload(\"DmPhyDisk\").\n\t\tFirst(&vol, \"uuid = ? AND app_id = ?\", id.String(), appID)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tlv, err := fromDmRDiskToModel(ctx, &vol)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlv = uow.trackedLogicalVolumes.Add(lv)\n\tif lv.PhysicalVolume != nil {\n\t\tlv.PhysicalVolume = uow.trackedPhyVolumes.Add(lv.PhysicalVolume)\n\t}\n\treturn lv, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 55,
        "code_end_line": 61,
        "code_key": "FindByAppIDAndUUID",
        "code_value": "func (m *MockLogicalVolumeRepository) FindByAppIDAndUUID(arg0 context.Context, arg1 users.AppID, arg2 uuid.UUID) (*rdiskDomain.LogicalVolume, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByAppIDAndUUID\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(*rdiskDomain.LogicalVolume)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 64,
        "code_end_line": 67,
        "code_key": "FindByAppIDAndUUID",
        "code_value": "func (mr *MockLogicalVolumeRepositoryMockRecorder) FindByAppIDAndUUID(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByAppIDAndUUID\", reflect.TypeOf((*MockLogicalVolumeRepository)(nil).FindByAppIDAndUUID), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go",
        "code_start_line": 49,
        "code_end_line": 74,
        "code_key": "FindByID",
        "code_value": "func (l logicalVolumeRepositoryImpl) FindByID(ctx context.Context, id uuid.UUID) (*rdiskDomain.LogicalVolume, error) {\n\tuow := getUow(ctx)\n\tvol := metadb.DmRdisk{}\n\tresult := uow.tx.\n\t\tPreload(\"Attachments\").\n\t\tPreload(\"DmPhyDisk\").\n\t\tFirst(&vol, \"uuid = ?\", id.String())\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tlv, err := fromDmRDiskToModel(ctx, &vol)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlv = uow.trackedLogicalVolumes.Add(lv)\n\tif lv.PhysicalVolume != nil {\n\t\tlv.PhysicalVolume = uow.trackedPhyVolumes.Add(lv.PhysicalVolume)\n\t}\n\treturn lv, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 70,
        "code_end_line": 76,
        "code_key": "FindByID",
        "code_value": "func (m *MockLogicalVolumeRepository) FindByID(arg0 context.Context, arg1 uuid.UUID) (*rdiskDomain.LogicalVolume, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByID\", arg0, arg1)\n\tret0, _ := ret[0].(*rdiskDomain.LogicalVolume)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 79,
        "code_end_line": 82,
        "code_key": "FindByID",
        "code_value": "func (mr *MockLogicalVolumeRepositoryMockRecorder) FindByID(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByID\", reflect.TypeOf((*MockLogicalVolumeRepository)(nil).FindByID), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go",
        "code_start_line": 21,
        "code_end_line": 38,
        "code_key": "FindBySerial",
        "code_value": "func (p *physicalVolumeRepositoryImpl) FindBySerial(ctx context.Context, serial rdiskDomain.Serial) (*rdiskDomain.PhysicalVolume, error) {\n\tuow := getUow(ctx)\n\tvar vol metadb.DmPhydisk\n\tresult := uow.tx.Where(\"serial = ?\", string(serial)).First(&vol)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\t// 覆盖 gorm 的错误\n\t\t\treturn nil, errors.New(rdiskDomain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tpv := fromDmPhyDiskToPhysicalVolume(ctx, &vol)\n\tpv = uow.trackedPhyVolumes.Add(pv)\n\treturn pv, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 83,
        "code_end_line": 89,
        "code_key": "FindBySerial",
        "code_value": "func (m *MockPhysicalVolumeRepository) FindBySerial(arg0 context.Context, arg1 rdiskDomain.Serial) (*rdiskDomain.PhysicalVolume, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindBySerial\", arg0, arg1)\n\tret0, _ := ret[0].(*rdiskDomain.PhysicalVolume)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 92,
        "code_end_line": 95,
        "code_key": "FindBySerial",
        "code_value": "func (mr *MockPhysicalVolumeRepositoryMockRecorder) FindBySerial(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindBySerial\", reflect.TypeOf((*MockPhysicalVolumeRepository)(nil).FindBySerial), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go",
        "code_start_line": 40,
        "code_end_line": 57,
        "code_key": "FindByIPAndBDF",
        "code_value": "func (p *physicalVolumeRepositoryImpl) FindByIPAndBDF(ctx context.Context, ip net.IP, bdf rdiskDomain.BDF) (*rdiskDomain.PhysicalVolume, error) {\n\tuow := getUow(ctx)\n\tvar vol metadb.DmPhydisk\n\tresult := uow.tx.Where(\"host_ip = ? AND bdf = ?\", ip.String(), string(bdf)).Find(&vol)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\t// 覆盖 gorm 的错误\n\t\t\treturn nil, errors.New(rdiskDomain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tpv := fromDmPhyDiskToPhysicalVolume(ctx, &vol)\n\tpv = uow.trackedPhyVolumes.Add(pv)\n\treturn pv, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 68,
        "code_end_line": 74,
        "code_key": "FindByIPAndBDF",
        "code_value": "func (m *MockPhysicalVolumeRepository) FindByIPAndBDF(arg0 context.Context, arg1 net.IP, arg2 rdiskDomain.BDF) (*rdiskDomain.PhysicalVolume, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByIPAndBDF\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(*rdiskDomain.PhysicalVolume)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 77,
        "code_end_line": 80,
        "code_key": "FindByIPAndBDF",
        "code_value": "func (mr *MockPhysicalVolumeRepositoryMockRecorder) FindByIPAndBDF(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByIPAndBDF\", reflect.TypeOf((*MockPhysicalVolumeRepository)(nil).FindByIPAndBDF), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
        "code_start_line": 31,
        "code_end_line": 52,
        "code_key": "FindByNames",
        "code_value": "func (d drgroupRepositoryImpl) FindByNames(ctx context.Context, appId users.AppID, names []string) ([]*drgroup.DRGroup, error) {\n\tuow := getUow(ctx)\n\tgroup := []metadb.DmDrgroup{}\n\tresult := uow.tx.\n\t\tPreload(\"Members\").\n\t\tFind(&group, \"app_id = ? and name in ?\", appId, names)\n\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"disaster recovery group not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tresults := make([]*drgroup.DRGroup, len(group))\n\tfor i := range group {\n\t\tresults[i] = uow.trackedDRGroups.Add(fromDmDRGroupToModel(&group[i]))\n\t}\n\treturn results, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 113,
        "code_end_line": 119,
        "code_key": "FindByNames",
        "code_value": "func (m *MockRepository) FindByNames(arg0 context.Context, arg1 users.AppID, arg2 []string) ([]*drgroup.DRGroup, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByNames\", arg0, arg1, arg2)\n\tret0, _ := ret[0].([]*drgroup.DRGroup)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 122,
        "code_end_line": 125,
        "code_key": "FindByNames",
        "code_value": "func (mr *MockRepositoryMockRecorder) FindByNames(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByNames\", reflect.TypeOf((*MockRepository)(nil).FindByNames), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
        "code_start_line": 58,
        "code_end_line": 94,
        "code_key": "FindByMembers",
        "code_value": "func (d drgroupRepositoryImpl) FindByMembers(ctx context.Context, appId users.AppID, members []string) ([]*drgroup.DRGroup, error) {\n\tuow := getUow(ctx)\n\tgroup := []metadb.DmDrgroup{}\n\n\tmembersResult := []metadb.DmDrgroupMembers{}\n\tresult := uow.tx.\n\t\tFind(&membersResult, \"app_id = ? and member_id in ?\", appId, members)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tnames := make([]string, 0, len(members))\n\tfor i := range membersResult {\n\t\tnames = append(names, membersResult[i].GroupName)\n\t}\n\tresult = uow.tx.\n\t\tPreload(\"Members\").\n\t\tFind(&group, \"app_id = ? and name in ?\", appId, names)\n\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"disaster recovery group not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tresults := make([]*drgroup.DRGroup, len(group))\n\tfor i := range group {\n\t\tresults[i] = fromDmDRGroupToModel(&group[i])\n\t\tresults[i] = uow.trackedDRGroups.Add(results[i])\n\t}\n\treturn results, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/drgroup.go",
        "code_start_line": 92,
        "code_end_line": 124,
        "code_key": "FindByMembers",
        "code_value": "func (d *drgroupViewerImpl) FindByMembers(ctx context.Context, appId users.AppID, members []string) ([]*drgroup.View, error) {\n\tvar (\n\t\tresultViews       []drgroup.View\n\t\tresultViewRef     []*drgroup.View\n\t\tdataObjects       []*metadb.DmDrgroup\n\t\tdataObjectMembers []*metadb.DmDrgroupMembers\n\t)\n\tresult := d.db.WithContext(ctx).Find(&dataObjectMembers, \"app_id = ? and member_id in ?\", appId, members)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"group not exist\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tgroupNames := make([]string, len(dataObjectMembers))\n\tfor i := range dataObjectMembers {\n\t\tgroupNames[i] = dataObjectMembers[i].GroupName\n\t}\n\tresult = d.db.WithContext(ctx).Find(&dataObjects, \"app_id = ? and name in ?\", appId, groupNames)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"group not exist\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tresultViews = make([]drgroup.View, len(dataObjects))\n\tresultViewRef = make([]*drgroup.View, len(dataObjects))\n\tfor i := range dataObjects {\n\t\tresultViewRef[i] = &resultViews[i]\n\t\td.translate(dataObjects[i], resultViewRef[i])\n\t}\n\treturn resultViewRef, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 83,
        "code_end_line": 89,
        "code_key": "FindByMembers",
        "code_value": "func (m *MockRepository) FindByMembers(arg0 context.Context, arg1 users.AppID, arg2 []string) ([]*drgroup.DRGroup, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByMembers\", arg0, arg1, arg2)\n\tret0, _ := ret[0].([]*drgroup.DRGroup)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 92,
        "code_end_line": 95,
        "code_key": "FindByMembers",
        "code_value": "func (mr *MockRepositoryMockRecorder) FindByMembers(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByMembers\", reflect.TypeOf((*MockRepository)(nil).FindByMembers), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/view.go",
        "code_start_line": 55,
        "code_end_line": 61,
        "code_key": "FindByMembers",
        "code_value": "func (m *MockViewer) FindByMembers(arg0 context.Context, arg1 users.AppID, arg2 []string) ([]*drgroup.View, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByMembers\", arg0, arg1, arg2)\n\tret0, _ := ret[0].([]*drgroup.View)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/view.go",
        "code_start_line": 64,
        "code_end_line": 67,
        "code_key": "FindByMembers",
        "code_value": "func (mr *MockViewerMockRecorder) FindByMembers(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByMembers\", reflect.TypeOf((*MockViewer)(nil).FindByMembers), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 178,
        "code_end_line": 233,
        "code_key": "updateReadLocks",
        "code_value": "func (l *mysqlLocker) updateReadLocks(tx *gorm.DB, ttl time.Duration, keys []string, lockTokens []string) ([]string, []string, []string, error) {\n\tif len(keys) == 0 {\n\t\treturn nil, nil, lockTokens, nil\n\t}\n\ttype Result struct {\n\t\tLock       string\n\t\tExpiration time.Time\n\t\tToken      string\n\t}\n\tvar Results []Result\n\terr := tx.Raw(\"SELECT `\"+l.lockColumn+\"` AS `lock`, `\"+l.expireColumn+\"` AS `expiration`, `\"+l.tokenColumn+\"` AS `token` FROM \"+l.tableName+\" WHERE `\"+l.lockColumn+\"` IN (?)\", keys).Scan(&Results).Error\n\tif err != nil {\n\t\treturn nil, nil, nil, errors.Wrap(err, \"fail to query locks\")\n\t}\n\n\tvar needUpdateExpirationReadKeys []string = nil\n\tvar needUpdateCountReadKeys []string = nil\n\tl.mutex.Lock()\n\tt := time.Now()\n\tfor _, r := range Results {\n\t\tif r.Token != lockTokens[0] {\n\t\t\tlockTokens = append(lockTokens, r.Token)\n\t\t}\n\t\tif readKey, exist := l.readKeysMemLock[r.Lock]; exist {\n\t\t\treadKey.count++\n\t\t\treadKey.expiration = r.Expiration\n\t\t} else {\n\t\t\tl.readKeysMemLock[r.Lock] = &readKeysMemLock{\n\t\t\t\tcount:      1,\n\t\t\t\texpiration: r.Expiration,\n\t\t\t\ttoken:      r.Token,\n\t\t\t}\n\t\t\tneedUpdateCountReadKeys = append(needUpdateCountReadKeys, r.Lock)\n\t\t}\n\t\tif l.readKeysMemLock[r.Lock].expiration.Sub(t) < ttl/3 {\n\t\t\tl.readKeysMemLock[r.Lock].expiration = t.Add(ttl)\n\t\t\tneedUpdateExpirationReadKeys = append(needUpdateExpirationReadKeys, r.Lock)\n\t\t}\n\t}\n\tl.mutex.Unlock()\n\tif len(needUpdateExpirationReadKeys) > 0 {\n\t\tresult := tx.Exec(\"UPDATE \"+l.tableName+\" SET \"+l.expireColumn+\" = NOW() + INTERVAL ? SECOND WHERE `\"+l.lockColumn+\"` IN (?)\", ttl.Seconds(), needUpdateExpirationReadKeys)\n\t\tif result.Error != nil {\n\t\t\treturn nil, needUpdateExpirationReadKeys, needUpdateCountReadKeys, errors.Wrap(result.Error, fmt.Sprintf(\"failed to update readLocks: %s\", keys))\n\t\t}\n\t}\n\n\tif len(needUpdateCountReadKeys) > 0 {\n\t\tresult := tx.Exec(\"UPDATE \"+l.tableName+\" SET \"+l.lockNumsColumn+\" = \"+l.lockNumsColumn+\" + 1 WHERE `\"+l.lockColumn+\"` IN (?)\", needUpdateCountReadKeys)\n\t\tif result.Error != nil {\n\t\t\treturn nil, needUpdateExpirationReadKeys, needUpdateCountReadKeys, errors.Wrap(result.Error, fmt.Sprintf(\"failed to update readLocks: %s\", keys))\n\t\t}\n\t}\n\n\treturn nil, nil, lockTokens, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 335,
        "code_end_line": 369,
        "code_key": "insertLocks",
        "code_value": "func (l *mysqlLocker) insertLocks(tx *gorm.DB, lockKeys []*dlock.LockKey, ttl time.Duration, lockToken []string) ([]string, error) {\n\tif len(lockKeys) <= 0 {\n\t\treturn nil, nil\n\t}\n\tstmt := strings.Builder{}\n\targs := make([]interface{}, 0, len(lockKeys)*5)\n\tt := time.Now().Add(ttl)\n\tstmt.WriteString(fmt.Sprintf(\"INSERT INTO `%s` (`%s`, `%s`, `%s`, `%s`, `%s`) VALUES \", l.tableName, l.lockColumn, l.expireColumn, l.tokenColumn, l.lockTypeColumn, l.lockNumsColumn))\n\tfor i, key := range lockKeys {\n\t\tif i > 0 {\n\t\t\tstmt.WriteString(\", \")\n\t\t}\n\t\tstmt.WriteString(\"(?, NOW() + INTERVAL ? SECOND, ?, ?, ?)\")\n\t\targs = append(args, key.Key, ttl.Seconds(), lockToken[0], int(key.Type), 1)\n\t}\n\n\tresult := tx.Exec(stmt.String(), args...)\n\tif result.Error != nil {\n\t\treturn nil, errors.Wrap(result.Error, \"failed to insert locks\")\n\t}\n\tvar needInsertReadKeys []string = nil\n\tl.mutex.Lock()\n\tfor _, key := range lockKeys {\n\t\tif key.Type == dlock.ReadLock {\n\t\t\tl.readKeysMemLock[key.Key] = &readKeysMemLock{\n\t\t\t\tcount:      1,\n\t\t\t\texpiration: t,\n\t\t\t\ttoken:      lockToken[0],\n\t\t\t}\n\t\t\tneedInsertReadKeys = append(needInsertReadKeys, key.Key)\n\t\t}\n\t}\n\tl.mutex.Unlock()\n\treturn needInsertReadKeys, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 417,
        "code_end_line": 470,
        "code_key": "tryObtainMulti",
        "code_value": "func (l *mysqlLocker) tryObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, tokens []string, opts *dlock.Option) ([]string, error) {\n\t// Starts a new transaction.\n\ttx := l.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\n\n\t// Fetch existing locks.\n\texistingReadKeys, existingWriteKeys, expiredKeys, err := l.fetchExistingLocks(tx, keys)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// If there are existing valid locks, return an error.\n\tif len(existingWriteKeys) > 0 {\n\t\t_ = tx.Rollback()\n\t\treturn nil, errors.Wrap(dlock.ErrLockNotHeld, fmt.Sprintf(\"writeKeys %v are already locked\", existingWriteKeys))\n\t}\n\n\t// Delete expired locks if exists.\n\tif err := l.deleteExpiredLocks(tx, expiredKeys); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Remove existing readLocks from insert.\n\t// NOCA:QCloudAkCheck(误报)\n\tlockKeys, err := l.removeExistingReadLocksFromInsert(tx, keys, existingReadKeys)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Insert locks into database.\n\tneedInsertReadKeys, err := l.insertLocks(tx, lockKeys, ttl, tokens)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Update readLocks.\n\tvar needUpdateExpirationReadKeys []string = nil\n\tvar needUpdateCountReadKeys []string = nil\n\tif needUpdateExpirationReadKeys, needUpdateCountReadKeys, tokens, err = l.updateReadLocks(tx, ttl, existingReadKeys, tokens); err != nil {\n\t\tl.rollback(needUpdateCountReadKeys, tokens)\n\t\tl.rollback(needUpdateExpirationReadKeys, tokens)\n\t\tl.rollback(needInsertReadKeys, tokens)\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\tif result := tx.Commit(); result.Error != nil {\n\t\treturn nil, errors.Wrap(result.Error, \"failed to commit transaction\")\n\t}\n\n\treturn tokens, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mem/memdlock.go",
        "code_start_line": 106,
        "code_end_line": 166,
        "code_key": "tryObtainMulti",
        "code_value": "func (l *memLocker) tryObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, token string) (dlock.Lock, error) {\n\tl.mutex.Lock()\n\tdefer l.mutex.Unlock()\n\tvar readLocks []*dlock.LockKey\n\tvar writeLocks []*dlock.LockKey\n\tvar insertLocks []*dlock.LockKey\n\tvar tokens []string\n\ttokens = append(tokens, token)\n\tfor _, key := range keys {\n\t\tif key.Type == dlock.WriteLock {\n\t\t\twriteLocks = append(writeLocks, key)\n\t\t} else {\n\t\t\treadLocks = append(readLocks, key)\n\t\t}\n\t}\n\tfor _, key := range writeLocks {\n\t\tif item, ok := l.data[key.Key]; ok {\n\t\t\tif time.Until(item.ttl) > 0 {\n\t\t\t\treturn nil, dlock.ErrNotObtained\n\t\t\t} else {\n\t\t\t\tinsertLocks = append(insertLocks, key)\n\t\t\t}\n\t\t} else {\n\t\t\tinsertLocks = append(insertLocks, key)\n\t\t}\n\t}\n\tfor _, key := range readLocks {\n\t\tif item, ok := l.data[key.Key]; ok {\n\t\t\tif item.lockType == dlock.ReadLock {\n\t\t\t\tif time.Until(item.ttl) > 0 {\n\t\t\t\t\titem.count++\n\t\t\t\t\titem.ttl = time.Now().Add(ttl)\n\t\t\t\t\ttokens = append(tokens, item.token)\n\t\t\t\t} else {\n\t\t\t\t\tinsertLocks = append(insertLocks, key)\n\t\t\t\t}\n\t\t\t} else if time.Until(item.ttl) > 0 {\n\t\t\t\treturn nil, dlock.ErrNotObtained\n\t\t\t}\n\t\t} else {\n\t\t\tinsertLocks = append(insertLocks, key)\n\t\t}\n\t}\n\n\tfor _, key := range insertLocks {\n\t\tl.data[key.Key] = &lockItem{\n\t\t\tkey:      key.Key,\n\t\t\tttl:      time.Now().Add(ttl),\n\t\t\ttoken:    token,\n\t\t\tlockType: key.Type,\n\t\t\tcount:    1,\n\t\t}\n\t}\n\n\tlock := &memLock{\n\t\tlocker: l,\n\t\tkeys:   keys,\n\t\ttokens: tokens,\n\t}\n\treturn lock, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 473,
        "code_end_line": 520,
        "code_key": "ObtainMulti",
        "code_value": "func (l *mysqlLocker) ObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, opts *dlock.Option) (dlock.Lock, error) {\n\tif len(keys) == 0 {\n\t\treturn nil, errors.New(\"keys cannot be empty\")\n\t}\n\tkeys = dedupAndSort(keys)\n\n\t// Get the lock token.\n\tlockToken, err := l.getOrCreateLockToken(opts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tretryStrategy := dlock.NoRetry()\n\tif opts != nil && opts.RetryStrategy != nil {\n\t\tretryStrategy = opts.RetryStrategy\n\t}\n\n\tretries := 0\n\tlogger := logs.GetLogger(ctx).With().Strs(\"keys\", dlock.LockKeySlice(keys).GetKeys()).Strs(\"tokens\", lockToken).Logger()\n\n\tfor {\n\t\t// Try to obtain the locks.\n\t\t// If the locks are not obtained, retry based on the retry strategy.\n\t\tif tokens, err := l.tryObtainMulti(ctx, keys, ttl, lockToken, opts); err != nil {\n\t\t\t// If context is canceled, return immediately.\n\t\t\tif ctx.Err() != nil {\n\t\t\t\treturn nil, errors.Wrap(dlock.ErrNotObtained, \"context is canceled\")\n\t\t\t}\n\n\t\t\t// If the lock is not obtained, retry.\n\t\t\twaitDuration := retryStrategy.NextBackoff()\n\t\t\tif waitDuration <= 0 {\n\t\t\t\tlogger.Debug().Int(\"retry\", retries).Msg(\"stop retrying lock\")\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tlogger.Debug().Int(\"retry\", retries).Msg(\"retry obtaining lock\")\n\t\t\ttime.Sleep(waitDuration)\n\t\t} else {\n\t\t\tlockToken = tokens\n\t\t\tlogger.Debug().Msg(\"lock obtained\")\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// TODO xuanzeng: 这里采用内部记录 TTL 的方式，可能和底层的数据库时间不同步，后续应该从数据库中获取过期时间。\n\tlock := &mysqlLock{keys: keys, locker: l, tokens: lockToken, expiration: time.Now().Add(ttl)}\n\treturn lock, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mem/memdlock.go",
        "code_start_line": 74,
        "code_end_line": 103,
        "code_key": "ObtainMulti",
        "code_value": "func (l *memLocker) ObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, opts *dlock.Option) (dlock.Lock, error) {\n\tvar token string\n\tif opts == nil || opts.Token == \"\" {\n\t\ttoken = uuid.New().String()\n\t} else {\n\t\ttoken = opts.Token\n\t}\n\n\tretryStrategy := dlock.NoRetry()\n\tif opts != nil && opts.RetryStrategy != nil {\n\t\tretryStrategy = opts.RetryStrategy\n\t}\n\n\tfor {\n\t\tlock, err := l.tryObtainMulti(ctx, keys, ttl, token)\n\t\tif err == nil {\n\t\t\treturn lock, nil\n\t\t}\n\n\t\tif ctx.Err() != nil {\n\t\t\treturn nil, ctx.Err()\n\t\t}\n\n\t\twaitInterval := retryStrategy.NextBackoff()\n\t\tif waitInterval <= 0 {\n\t\t\treturn nil, dlock.ErrNotObtained\n\t\t}\n\t\ttime.Sleep(waitInterval)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": []
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go:59:71:Add": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go",
    "code_start_line": 59,
    "code_end_line": 71,
    "code_start_column": 40,
    "code_key": "Add",
    "code_value": "func (p *physicalVolumeRepositoryImpl) Add(ctx context.Context, pv *rdiskDomain.PhysicalVolume) error {\n\tuow := getUow(ctx)\n\tvol := fromPhysicalVolumeToDmPhyDisk(ctx, pv)\n\tvol.Created = uow.tx.NowFunc()\n\tvol.Updated = uow.tx.NowFunc()\n\tresult := uow.tx.Create(&vol)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tpv.ID = vol.ID\n\tuow.trackedPhyVolumes.Add(pv)\n\treturn nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/infra/event_bus/bus.go",
        "code_start_line": 61,
        "code_end_line": 79,
        "code_key": "Execute",
        "code_value": "func (eb *EventBusDriver) Execute(ctx context.Context) (result *response.Result) {\n\tresult = response.DefaultResult()\n\tdefer utils.HandlePanic(ctx, &result)\n\n\tfor _, event := range eb.BlockEventQueue {\n\t\tresult = eb.ExecuteOne(ctx, event)\n\t\tif result.IsSuccess() {\n\t\t\tevent.UpdateState(ctx, Executed)\n\t\t} else {\n\t\t\tlogs.Warn(ctx).Err(result).Int(\"EventType\", int(event.GetType(ctx))).\n\t\t\t\tMsg(\"event execute failed, start rollback event bus\")\n\t\t\tif err := eb.RollbackEvents(ctx); err != nil {\n\t\t\t\tlogs.Error(ctx).Err(err).Int(\"EventType\", int(event.GetType(ctx))).Msg(\"rollback event bus failed\")\n\t\t\t}\n\t\t\treturn result\n\t\t}\n\t}\n\treturn result\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/filters/filter.go",
        "code_start_line": 26,
        "code_end_line": 46,
        "code_key": "Execute",
        "code_value": "func (f FilterChain) Execute(ctx context.Context, disks []*disk.Disk, user *account.User,\n\tcacheMap cache.RDCacheManagerInf, affinityConfig *dto.AffinityConfig) ([]*disk.Disk, response.Result) {\n\tlogs.Info(ctx).Int(\"disk_count\", len(disks)).Msg(\"DISK_COUNT_BEFORE_FILTER\")\n\tfor _, filter := range f.filters {\n\t\tdisks, result := filter.\n\t\t\tWithUser(ctx, user).\n\t\t\tWithRdCacheManager(ctx, cacheMap).\n\t\t\tWithAffinityConfig(ctx, affinityConfig).\n\t\t\tFilter(ctx, disks)\n\t\tdisks = disk.SortByScore(ctx, disks)\n\t\tlogs.Info(ctx).\n\t\t\tInt(\"disk_count\", len(disks)).\n\t\t\tStr(\"filter\", reflect.TypeOf(filter).Name()).\n\t\t\tMsg(\"LEFT_DISK_COUNT_AFTER_FILTER\")\n\t\tif result.IsFailed() {\n\t\t\treturn disks, result\n\t\t}\n\t}\n\t// 对盘的Score进行排序\n\treturn disks, response.SucResult()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_bill_compute_task.go",
        "code_start_line": 26,
        "code_end_line": 40,
        "code_key": "Execute",
        "code_value": "func (t *SnapBillComputeTask) Execute(ctx context.Context) (bool, error) {\n\tt.Ctx = ctx\n\tt.InitTask(ctx)\n\tdefer t.MqIns.Close()\n\n\t// 获取待处理的用户资源\n\tgo t.GetUserResources()\n\t// 执行Ack确认逻辑\n\tgo t.AckAppId()\n\t// 处理用户资源\n\tt.ProcessUserResources()\n\n\tlogs.Info(ctx).Msg(\"SNAP_COMPUTE_TASK_DONE\")\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_calculate_cost_locally_task.go",
        "code_start_line": 21,
        "code_end_line": 37,
        "code_key": "Execute",
        "code_value": "func (t *SnapCalculateCostLocallyTask) Execute(ctx context.Context) (bool, error) {\n\tt.ctx = ctx\n\tsnapRecSrv := measureReconciliation.NewReconciliationSrvImpl(ctx)\n\n\t// 结算上上个周期的用量\n\tnow := time.Now()\n\tstartTime := now.Truncate(time.Hour).Add(-2 * time.Hour)\n\tendTime := now.Truncate(time.Hour).Add(-1 * time.Hour).Add(-1 * time.Second)\n\tlogs.Info(t.ctx).Time(\"startTime\", startTime).Time(\"endTime\", endTime).Msg(\"START_CALCULATE_COST_LOCALLY\")\n\terr := snapRecSrv.CalculateCostLocally(startTime, endTime)\n\tif err != nil {\n\t\tlogs.Error(t.ctx).Err(err).Msg(\"CALCULATE_COST_LOCALLY_ERROR\")\n\t\treturn false, err\n\t}\n\tlogs.Info(t.ctx).Msg(\"CALCULATE_COST_LOCALLY_DONE\")\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/cbs_bill_compute_task.go",
        "code_start_line": 26,
        "code_end_line": 42,
        "code_key": "Execute",
        "code_value": "func (t *CbsBillComputeTask) Execute(ctx context.Context) (bool, error) {\n\tt.Ctx = ctx\n\tt.InitTask(ctx)\n\tdefer t.MqIns.Close()\n\n\t// 获取待处理的用户资源\n\tgo t.GetUserResources()\n\t// 执行Ack确认逻辑\n\tgo t.AckAppId()\n\t// 处理用户资源\n\tt.ProcessUserResources()\n\tt.ChargeItemProducer.Close()\n\n\tt.WG.Wait()\n\tlogs.Info(ctx).Msg(\"CBS_COMPUTE_TASK_DONE\")\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/update_ccbs_normal_rb_task.go",
        "code_start_line": 23,
        "code_end_line": 34,
        "code_key": "Execute",
        "code_value": "func (t *UpdateCCbsNormalRollbackTask) Execute(ctx context.Context) (bool, error) {\n\tt.Count += 1\n\tserv := registry.GetRegistry(ctx).DomainServices.DiskRollbackingService.(diskLogical.DiskRollbackingServiceInterface)\n\tisFinish, err := serv.UpdateCbsRollbackingPercent(ctx, t.DiskAggregate)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tlogs.Info(ctx).Int(\"Status\", t.DiskAggregate.DiskRecord.Status).\n\t\tInt(\"Percent\", t.DiskAggregate.DiskRecord.RollbackingPercent).\n\t\tInt(\"Count\", t.Count).Msg(\"FINISH_EXECUTE_TASK\")\n\treturn isFinish, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/repush_user_billing_task.go",
        "code_start_line": 53,
        "code_end_line": 61,
        "code_key": "Execute",
        "code_value": "func (t *RepushUserBillingTask) Execute(ctx context.Context) (bool, error) {\n\tt.ctx = ctx\n\tt.InitTask(ctx)\n\tdefer t.MqIns.Close()\n\n\tt.ProcessRepushDetailMsg()\n\tlogs.Info(ctx).Msg(\"REPUSH_USER_BILLING_TASK_DONE\")\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/update_create_task.go",
        "code_start_line": 31,
        "code_end_line": 69,
        "code_key": "Execute",
        "code_value": "func (t *UpdateCreateTask) Execute(ctx context.Context) (bool, error) {\n\tt.Count += 1\n\tserv := registry.GetRegistry(ctx).DomainServices.SnapCreatingService.(snapLogical.SnapCreatingServiceInterface)\n\tif t.SnapAggregate.SnapRecord.Status == ccdb.SnapCreating &&\n\t\tt.SnapAggregate.SnapRecord.LifeState == ccdb.SnapLifeStateNormal &&\n\t\tt.SnapAggregate.SnapRecord.Percent == 100 &&\n\t\tt.SnapAggregate.SnapRecord.Attribute != ccdb.SnapAttUserSnap {\n\t\t// 隐藏快照转正常快照\n\t\tlogs.Info(ctx).Msg(\"FIX_INNER_TO_NORMAL\")\n\t\terr := serv.SnapCreateTaskFollowup(ctx, t.SnapAggregate, SnapInnerFollowup)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\treturn true, nil\n\t}\n\n\tisFinish, err := serv.UpdateSnapCreatingPercent(ctx, t.SnapAggregate)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\t// 创建完成的用户快照进行后续操作，隐藏快照不进行\n\tif isFinish && t.SnapAggregate.SnapRecord.Status == ccdb.SnapNormal &&\n\t\tt.SnapAggregate.SnapRecord.LifeState == ccdb.SnapLifeStateNormal {\n\t\t// 目的端快照复制完成时，需更新源端的快照状态\n\t\t// 计算base snap size，并更新\n\t\t// merge\n\t\t// 插入计费，并更新快照大小\n\t\terr = serv.SnapCreateTaskFollowup(ctx, t.SnapAggregate, SnapNormalFollowup)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\n\tlogs.Info(ctx).Int(\"Status\", t.SnapAggregate.SnapRecord.Status).\n\t\tInt(\"Percent\", t.SnapAggregate.SnapRecord.Percent).\n\t\tInt(\"Count\", t.Count).Msg(\"FINISH_EXECUTE_TASK\")\n\treturn isFinish, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/update_image_snap_rb_task.go",
        "code_start_line": 23,
        "code_end_line": 41,
        "code_key": "Execute",
        "code_value": "func (t *UpdateImageSnapRollbackTask) Execute(ctx context.Context) (bool, error) {\n\tt.Count += 1\n\tserv := registry.GetRegistry(ctx).DomainServices.DiskRollbackingService.(diskLogical.DiskRollbackingServiceInterface)\n\tisFinish, err := serv.UpdateImageSnapRollbackingPercent(ctx, t.DiskAggregate)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif isFinish {\n\t\t// TODO：这里应该放入一个管道中，后续再优化\n\t\terr = serv.UpdateRollbackQuota(ctx, t.DiskAggregate)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\tlogs.Info(ctx).Str(\"Status\", t.DiskAggregate.ImageSnapRollbackRecord.Status).\n\t\tInt(\"Percent\", t.DiskAggregate.ImageSnapRollbackRecord.Percent).\n\t\tInt(\"Count\", t.Count).Msg(\"FINISH_EXECUTE_TASK\")\n\treturn isFinish, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/cbs_measure_send_task.go",
        "code_start_line": 30,
        "code_end_line": 54,
        "code_key": "Execute",
        "code_value": "func (t *CbsMeasureSendTask) Execute(ctx context.Context) (bool, error) {\n\t// 初始化各项配置\n\tt.Ctx = ctx\n\tt.InitTask(ctx)\n\tt.cbsSrv = cbsResource.NewCbsSrvImpl(t.Ctx)\n\tdefer t.MqIns.Close()\n\t// 根据区域分发到国内和国际两个不同channel中去处理\n\tt.ChannelDistribution()\n\n\t// MSG处理的生命周期Msg -->chargeItem -->MeasureDetails-->MeasureDetailsChannel-->Params-->Ack Msg\n\tgo t.ProcessMsgByRegion()\n\n\t// 计费详情转换成计费参数\n\tgo t.ProcessMeasureDetailToParams()\n\n\t// 执行ACK\n\tgo t.AckResourceID()\n\n\t// 根据计费参数发送计费消息\n\tt.ProcessParamsSendMeasure()\n\n\tt.WG.Wait()\n\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/cbs_rec_task.go",
        "code_start_line": 37,
        "code_end_line": 61,
        "code_key": "Execute",
        "code_value": "func (t *CbsMeasureRecTask) Execute(ctx context.Context) (bool, error) {\n\t// 初始化各项配置\n\tt.Ctx = ctx\n\tt.InitTask(ctx)\n\t// 初始化snapSrv\n\tt.cbsReSrv = measureReconciliation.NewReconciliationSrvImpl(t.Ctx)\n\tt.cbsSrv = cbsResource.NewCbsSrvImpl(t.Ctx)\n\tdefer t.MqIns.Close()\n\t// 根据区域分发到国内和国际两个不同channel中去处理\n\tt.ChannelDistribution()\n\n\t// MSG处理的生命周期Msg -->chargeItem -->subMeasureDetails-->subMeasureDetailsChannel-->db-->Ack Msg\n\tgo t.ProcessMsg()\n\n\t// 生成批次外发的计费对账数据\n\tgo t.ProcessMeasureDetailBatch()\n\n\t// 执行ACK\n\tgo t.AckResourceID()\n\n\t// 将计费数据外发到数据库\n\tt.ProcessMeasureToDb()\n\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_measure_send_task.go",
        "code_start_line": 27,
        "code_end_line": 49,
        "code_key": "Execute",
        "code_value": "func (t *SnapMeasureSendTask) Execute(ctx context.Context) (bool, error) {\n\t// 初始化各项配置\n\tt.Ctx = ctx\n\tt.InitTask(ctx)\n\tdefer t.MqIns.Close()\n\n\t// 根据区域分发到国内和国际两个不同channel中去处理\n\tt.ChannelDistribution()\n\n\t// 启动外发任务\n\tgo t.ProcessMsgByRegion()\n\n\t// 用量详情转换成计费协议\n\tgo t.ProcessMeasureDetailToParams()\n\n\t// 执行ACK\n\tgo t.AckResourceID()\n\n\t// 根据计费协议发送到计费客户端\n\tt.ProcessParamsSendMeasure()\n\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_rec_task.go",
        "code_start_line": 48,
        "code_end_line": 61,
        "code_key": "Execute",
        "code_value": "func (t *SnapMeasureReconciliationTask) Execute(ctx context.Context) (bool, error) {\n\t// 初始化各项配置\n\tt.ctx = ctx\n\tt.initTask()\n\n\t// 将数据推送到数据库\n\tvar wg sync.WaitGroup\n\tgo t.sendDbFromMsg(&wg)\n\n\t// 执行ACK\n\tgo t.AckResourceID()\n\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/base_measure/base_appId_fetch_task.go",
        "code_start_line": 38,
        "code_end_line": 61,
        "code_key": "Execute",
        "code_value": "func (t *BaseAppIdFetchTask) Execute(ctx context.Context) (bool, error) {\n\tt.ctx = ctx\n\tt.initTask()\n\n\tappIds := t.resSrv.GetAppIdsWithValidResources(t.chargeTime)\n\tfor _, appId := range appIds {\n\t\tappIdItem := measure.AppIdInfo{\n\t\t\tAppId: appId,\n\t\t}\n\t\t// Send自带Confirm机制. error为nil表示发送成功\n\t\t// Send会阻塞等待Confirm，如果需要，可以考虑放协程里跑\n\t\terr := t.client.Send(ctx, measure.BuildRabbitRequest(&appIdItem))\n\t\tif err != nil {\n\t\t\tlogs.Error(ctx).Err(err).Msg(\"SEND_MESSAGE_FAILED\")\n\t\t\treturn false, err\n\t\t}\n\t\tlogs.Info(ctx).Interface(\"appId\", appId).Msg(\"SEND_MESSAGE_SUCCESS\")\n\t}\n\n\tstopChan := make(chan struct{})\n\t_ = t.server.Close(stopChan)\n\t<-stopChan\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/managers/shm.go",
        "code_start_line": 86,
        "code_end_line": 88,
        "code_key": "ListExpiredKeys",
        "code_value": "func (s *ShmCacheManager) ListExpiredKeys(ctx context.Context) []interface{} {\n\tpanic(\"implement me\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/subgroup.go",
        "code_start_line": 46,
        "code_end_line": 54,
        "code_key": "ListExpiredKeys",
        "code_value": "func (s *SubGroupCacheManager) ListExpiredKeys(ctx context.Context) []interface{} {\n\tvar expiredKeys []interface{}\n\tfor expireTime, keys := range s.cacheMap.GetExpireTimeMap() {\n\t\tif time.Now().Add(time.Duration(SafeReserveSeconds)*time.Second).Unix() >= expireTime {\n\t\t\texpiredKeys = append(expiredKeys, keys...)\n\t\t}\n\t}\n\treturn expiredKeys\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/filters/dmg.go",
        "code_start_line": 107,
        "code_end_line": 133,
        "code_key": "filterWithHostAff",
        "code_value": "func (r RdPlacementGroupFilter) filterWithHostAff(ctx context.Context, disks []*disk.Disk) []*disk.Disk {\n\t/**\n\t检查母机置放群组亲和性\n\t\t1. 检查单母机绑定的置放群组子组数量不会超过置放群组亲和度限制\n\t    2. 置放群组是强制性装箱规则，不满足置放群组的盘被舍弃掉\n\t*/\n\tif len(disks) == 0 {\n\t\treturn disks\n\t}\n\twg := &sync.WaitGroup{}\n\twg.Add(len(disks))\n\n\tfor _, oneDisk := range disks {\n\t\tgo r.checkHostAffWithSingleDisk(ctx, oneDisk, wg)\n\t}\n\twg.Wait()\n\n\t// 对置放群组亲和性检查的盘进行过滤,打标分数小于0的过滤掉\n\tdiskSlice := make([]*disk.Disk, 0, 100000)\n\tfor _, oneDisk := range disks {\n\t\tif oneDisk.Score >= 0 {\n\t\t\tdiskSlice = append(diskSlice, oneDisk)\n\t\t}\n\t}\n\treturn diskSlice\n\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/tracker.go",
        "code_start_line": 67,
        "code_end_line": 77,
        "code_key": "Refresh",
        "code_value": "func (rdp *PhyDiskTracker) Refresh(ctx context.Context) {\n\trdp.Track(ctx)\n\tlock.RDPhyCacheGlobalLock.GetLocker(lock.RDPhyLockKeyGenerator{}).Lock()\n\trdp.Merge(ctx, rdp.OriPhyDisks)\n\tlogs.Info(ctx).\n\t\tInt(\"disk_num\", len(rdp.ToCachedPhyDisks)).\n\t\tInt(\"member_num\", len(rdp.DrgroupMembers)).\n\t\tMsg(\"CACHE_AVAILABLE_PHY_DISK_AFTER_MERGE\")\n\trdp.CacheManager.RefreshCache(ctx, rdp.ToCachedPhyDisks, rdp.DrgroupMembers)\n\tlock.RDPhyCacheGlobalLock.GetLocker(lock.RDPhyLockKeyGenerator{}).Unlock()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/set/cache/tracker.go",
        "code_start_line": 35,
        "code_end_line": 38,
        "code_key": "Refresh",
        "code_value": "func (d *DiskSetTracker) Refresh(ctx context.Context) {\n\td.Track(ctx)\n\td.CacheManager.RefreshCache(ctx, d.DiskSetEntityInf)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 644,
        "code_end_line": 674,
        "code_key": "Refresh",
        "code_value": "func (l *mysqlLock) Refresh(ctx context.Context, ttl time.Duration) error {\n\n\ttx := l.locker.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\n\n\tkeysKey := dlock.LockKeySlice(l.keys).GetKeys()\n\t// NOCA:QCloudAkCheck(误报)\n\texistingLocks, err := l.locker.fetchExistingLocksByKeysAndTokens(tx, keysKey, l.tokens)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn err\n\t}\n\n\t// Compare existing locks with the keys.\n\tif !checkStrSetEqual(existingLocks, keysKey) {\n\t\t_ = tx.Rollback()\n\t\treturn errors.Wrap(dlock.ErrLockNotHeld, \"lock is not held\")\n\t}\n\n\t// Update the expiration time.\n\tif err := l.locker.updateLocksTTLByKeysAndTokens(tx, keysKey, l.tokens, ttl); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn err\n\t}\n\n\tif result := tx.Commit(); result.Error != nil {\n\t\treturn errors.Wrap(result.Error, \"failed to commit refresh locks\")\n\t}\n\n\tl.expiration = time.Now().Add(ttl)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mem/memdlock.go",
        "code_start_line": 189,
        "code_end_line": 210,
        "code_key": "Refresh",
        "code_value": "func (l *memLock) Refresh(ctx context.Context, ttl time.Duration) error {\n\tl.locker.mutex.Lock()\n\tdefer l.locker.mutex.Unlock()\n\n\ttokens := make(map[string]struct{}, len(l.tokens))\n\tfor _, item := range l.tokens {\n\t\ttokens[item] = struct{}{}\n\t}\n\tfor _, key := range l.keys {\n\t\tif item, ok := l.locker.data[key.Key]; ok {\n\t\t\tif _, exist := tokens[item.token]; !exist {\n\t\t\t\treturn dlock.ErrLockNotHeld\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, key := range l.keys {\n\t\tl.locker.data[key.Key].ttl = time.Now().Add(ttl)\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go",
        "code_start_line": 51,
        "code_end_line": 72,
        "code_key": "Handle",
        "code_value": "func (c *CbsAppIdConsumer) Handle(ctx context.Context, delivery *rabbitmq.Delivery) error {\n\tu, chargeTime, err := c.ParseDelivery(ctx, delivery)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif u == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"USER_INFO_NOT_FOUND\")\n\t\treturn nil\n\t}\n\n\tchargeDetail := c.GetChargeDetailForSingleUser(u, chargeTime)\n\tif chargeDetail == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tUint64(\"appId\", uint64(u.AppId)).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"NO_RESOURCE_TO_CHARGE\")\n\t\treturn nil\n\t}\n\treturn c.ProcessChargeDetail(chargeDetail)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 105,
        "code_end_line": 116,
        "code_key": "Handle",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tif err := c.ensureLocks(ctx); err != nil {\n\t\treturn err\n\t}\n\tif c.lvUUID != nil {\n\t\t// 涉及到逻辑卷时，需要先标记逻辑卷为故障\n\t\treturn c.handleBindedVolume(ctx)\n\t} else {\n\t\t// 不涉及到逻辑卷时，直接标记物理卷为故障\n\t\treturn c.handleIdleVolume(ctx)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/detach_logical_volume.go",
        "code_start_line": 56,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *DetachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDetachLogicalVolume, c)\n\n\t// 如果没有挂载到指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume not attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_benchmark_task.go",
        "code_start_line": 125,
        "code_end_line": 165,
        "code_key": "Handle",
        "code_value": "func (c *CreateBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tvolSm     = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = volSm.Fire(ctx, c.relatedVolume.State, domain.PVEStartBenchmark, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark = benchmark.New(benchmark.DiskInfo{\n\t\tSerial: string(c.relatedVolume.Serial),\n\t\tHostIP: c.relatedVolume.IP,\n\t\tBDF:    string(c.relatedVolume.BDF),\n\t})\n\n\tif err = benchRepo.Add(ctx, c.relatedBenchmark); err != nil {\n\t\tdelegate := &benchmarkDelegate{cmd: c}\n\t\tif _err := delegate.TaskFinishCallback(ctx, c.relatedBenchmark); _err != nil {\n\t\t\tlogs.Warn(ctx).Err(_err).Str(\"serial\", string(c.relatedVolume.Serial)).Msg(\"failed to rollback: create bdev\")\n\t\t}\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventCreateBench,\n\t\tbenchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_logical_volume.go",
        "code_start_line": 71,
        "code_end_line": 108,
        "code_key": "Handle",
        "code_value": "func (d *DeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\td.volume, err = repo.FindByID(ctx, d.UUID)\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif e := d.volume.CheckDelete(); e != nil {\n\t\treturn e\n\t}\n\n\tif d.volume.AppID != d.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"refuse to delet: app id mismatch\")\n\t}\n\n\td.drgroup, err = app.GetRegistry(ctx).Repositories.DRGroup.FindByMember(ctx, d.AppID, d.volume.UUID.String())\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\td.drgroup = nil\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := d.checkDRGroupMatch(ctx); err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, d.volume.State, rdiskDomain.LVEMarkToRecycle, d)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_recycled_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmRecycledPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEConfirmRecycled, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_rdisk_backup.go",
        "code_start_line": 52,
        "code_end_line": 75,
        "code_key": "Handle",
        "code_value": "func (c *DeleteRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tsm   = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\tc.relatedBackup, err = repo.FindByUUID(ctx, c.BackupID.String())\n\tif err != nil || c.relatedBackup == nil || c.relatedBackup.AppID != c.AppID {\n\t\treturn errors.New(backupDomain.ErrBackupNotExist, \"backup not exists\")\n\t}\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tc.relatedBackup.Status,\n\t\tbackupDomain.EventSoftDeleteBackup,\n\t\tbackupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: c.relatedBackup})\n\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_rdisk_backup.go",
        "code_start_line": 47,
        "code_end_line": 80,
        "code_key": "Handle",
        "code_value": "func (c *CreateRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tlvSm  = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\tbakSm = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo  = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t_, err = lvSm.Fire(ctx, c.relatedVolume.State, rdiskDomain.LVEBackupStarted, c)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tlv := c.relatedVolume\n\tbackup := backupDomain.New(\n\t\tlv.AppID,\n\t\tbackupDomain.DiskInfo{\n\t\t\tVolumeUUID: lv.UUID,\n\t\t\tVolumeSize: uint64(lv.Size),\n\t\t\tHostIP:     lv.PhysicalVolume.IP,\n\t\t\tHostBDF:    string(lv.PhysicalVolume.BDF),\n\t\t\tSerial:     string(lv.PhysicalVolume.Serial),\n\t\t},\n\t)\n\tif err := repo.Add(ctx, backup); err != nil {\n\t\treturn err\n\t}\n\tc.relatedBackup = backup\n\t_, err = bakSm.Fire(ctx, backupDomain.StatusInit, backupDomain.EventStartBackup, backupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: backup})\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/attach_logical_volume.go",
        "code_start_line": 49,
        "code_end_line": 71,
        "code_key": "Handle",
        "code_value": "func (c *AttachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEAttachLogicalVolume, c)\n\n\t// 如果已经挂载到了指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeAlreadyAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume already attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_delete_logical_volume.go",
        "code_start_line": 34,
        "code_end_line": 55,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\t// 如果逻辑卷不存在，则直接返回成功\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"failed to confirm delete: app id mismatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDeleteLogicalVolume, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/offline_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OfflinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOfflinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *DeletePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\t// 如果物理卷不存在，则直接幂等返回\n\t\treturn nil\n\t}\n\n\tvar event = domain.PVEDeletePhysicalVolume\n\tif c.Force && (c.relatedVolume.State == domain.PVSDefunct) {\n\t\t// 这里的实现不太好，状态机的逻辑不应该侵入 cmd\n\t\t// 时间太赶了，后续重构优化吧\n\t\tevent = domain.PVEForceDeleteForDefunct\n\t}\n\n\tif c.relatedVolume.HasBindedPV() {\n\t\treturn errors.New(domain.ErrVolumeBusy, \"logic volume has binded to this physical volume\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, event, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_logical_volume.go",
        "code_start_line": 55,
        "code_end_line": 70,
        "code_key": "Handle",
        "code_value": "func (c *CleanupLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVECleanupLogicalVolume, c)\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_init_physical_volume.go",
        "code_start_line": 26,
        "code_end_line": 52,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmInitPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\tif c.relatedVolume.IP.String() != c.Host.String() {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume host ip mistmatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVECreatePhysicalVolumeOnHost, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_physical_volume.go",
        "code_start_line": 51,
        "code_end_line": 101,
        "code_key": "Handle",
        "code_value": "func (c *CreatePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\n\t// 获取物理卷状态机\n\tsm := app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\trepo := app.GetRegistry(ctx).Repositories.PhysicalVolume\n\n\t// 检查物理卷是否已经存在，如果存在则直接幂等返回\n\tvol1, err := repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"serial\", c.Serial).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tvol2, err := repo.FindByIPAndBDF(ctx, c.Host, domain.BDF(c.BDF))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"host\", c.Host.String()).Str(\"bdf\", c.BDF).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tfor _, vol := range []*domain.PhysicalVolume{vol1, vol2} {\n\t\texisted, err := c.checkExisting(ctx, vol)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif existed {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// 触发事件，创建物理卷\n\t_, err = sm.Fire(ctx,\n\t\tdomain.PVSUnInited,\n\t\tdomain.PVECreatePhysicalVolume,\n\t\tc,\n\t)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 创建 Bdev 以及格式化移动到创建物理卷的状态机中\n\n\t// _, err = sm.Fire(ctx,\n\t// \tc.GetPhysicalVolume().State,\n\t// \tdomain.PVECreatePhysicalVolumeOnHost,\n\t// \tc,\n\t// )\n\t// if err != nil {\n\t// \treturn err\n\t// }\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_benchmark_task.go",
        "code_start_line": 32,
        "code_end_line": 57,
        "code_key": "Handle",
        "code_value": "func (c *DeleteBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\terr       error\n\t)\n\n\tbench, err := benchRepo.FindByUUID(ctx, c.BenchmarkUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif bench.DiskInfo.Serial != c.Serial {\n\t\treturn errors.Newf(benchmark.ErrTaskNotFound, \"benchmark serial not match %s, want %s\", c.Serial, bench.DiskInfo.Serial)\n\t}\n\n\t_, err = benchSm.Fire(ctx, bench.Status, benchmark.EventDeleteBench, benchmark.Data{Benchmark: bench, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := benchRepo.Delete(ctx, bench); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_logical_volume.go",
        "code_start_line": 52,
        "code_end_line": 98,
        "code_key": "Handle",
        "code_value": "func (c *CreateLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tpvRepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tlvRepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm     = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\t// 1. 查找底层物理卷\n\tc.selectedPhysicalVolume, err = pvRepo.FindBySerial(ctx, rdiskDomain.Serial(c.PhysicalVolumeSerial))\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// 检查底层物理卷大小是否满足要求\n\tif c.selectedPhysicalVolume.Size < rdiskDomain.Size(c.DiskSize) {\n\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume size %d is smaller than requested size %d\", c.selectedPhysicalVolume.Size, c.DiskSize)\n\t}\n\n\t// 检查底层物理卷性能等级是否满足要求\n\tif c.PerformanceRank != \"\" {\n\t\tif string(c.selectedPhysicalVolume.PerformanceRank) != c.PerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not match requested rank %s\", c.selectedPhysicalVolume.PerformanceRank, c.PerformanceRank)\n\t\t}\n\t} else {\n\t\tif c.selectedPhysicalVolume.PerformanceRank != rdiskDomain.DefaultPerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not default rank %s\", c.selectedPhysicalVolume.PerformanceRank, rdiskDomain.DefaultPerformanceRank)\n\t\t}\n\t}\n\n\t// 2. 创建逻辑卷\n\tvol := rdiskDomain.NewLogicalVolume(users.AppID(c.AppID), rdiskDomain.Size(c.DiskSize), rdiskDomain.ZoneID(c.ZoneID))\n\tif c.VolumeType != \"\" {\n\t\tvol.VolumeType = rdiskDomain.VolumeType(c.VolumeType)\n\t}\n\tif c.DiskType != \"\" {\n\t\tvol.DiskType = rdiskDomain.DiskType(c.DiskType)\n\t}\n\terr = lvRepo.Add(ctx, vol)\n\tif err != nil {\n\t\treturn\n\t}\n\tc.createdLogicalVolume = vol\n\n\t// 3. 触发状态机，联动更新逻辑卷和物理卷状态\n\t_, err = sm.Fire(ctx, rdiskDomain.LVSUnInited, rdiskDomain.LVECreateLogicalVolume, c)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_running_backup_task.go",
        "code_start_line": 31,
        "code_end_line": 61,
        "code_key": "Handle",
        "code_value": "func (c *UpdateRunningBackupTaskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventUpdateBackupProgress,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_drgroup.go",
        "code_start_line": 78,
        "code_end_line": 173,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeDRGroupCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tlvView  = app.GetRegistry(ctx).Viewers.LogicalVolume\n\t\tdrgRepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t\tsm      = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\terr     error\n\t)\n\n\t// 0. 初始化\n\tc.drgroupRef = make(map[string]*drgroup.DRGroup)\n\n\t// 1. 加载所有逻辑卷所在的置放群组\n\tallVolumeUUIDs := make([]string, 0, len(c.UUIDs))\n\tfor _, _uuid := range c.UUIDs {\n\t\tallVolumeUUIDs = append(allVolumeUUIDs, _uuid.String())\n\t}\n\tif groups, err := drgRepo.FindByMembers(ctx, c.AppID, allVolumeUUIDs); err == nil {\n\t\tif err != nil {\n\t\t\tif !errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tfor _, group := range groups {\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t\tc.curDRGroupNames = append(c.curDRGroupNames, group.Name)\n\t\t}\n\t} else {\n\t\treturn err\n\t}\n\n\t// 2. 确认已上锁的置放群组和当前一致\n\tif !c.checkLockedDRGroupNames() {\n\t\treturn errors.New(drgroup.ErrGroupModified, \"drgroup changed\")\n\t}\n\n\t// 3. 加载所有逻辑卷的状态，不需要完整实体，因为不会修改 Volume\n\tc.relatedLogicalVolume, err = lvView.FindByIDs(ctx, c.AppID, c.UUIDs)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(c.relatedLogicalVolume) < len(c.UUIDs) {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t// 4. 加载所有目标置放群组，key 为 name\n\tfor _, spec := range c.Specs {\n\t\tvar group *drgroup.DRGroup\n\t\tif _, ok := c.drgroupRef[spec.Name]; ok {\n\t\t\tgroup = c.drgroupRef[spec.Name]\n\t\t} else {\n\t\t\tgroup, err = c.getOrCreateDRGroup(ctx, drgRepo, spec)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t}\n\n\t\tif spec.Affinity > 0 {\n\t\t\tgroup.Affinity = spec.Affinity\n\t\t}\n\t\tif spec.Type != \"\" {\n\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t}\n\t}\n\n\t// 5. 对所有逻辑卷执行置放群组变更事件，检查状态是否允许，\n\t//    实际的更新还是在这里执行。\n\tfor _, vol := range c.relatedLogicalVolume {\n\t\terr := sm.Check(ctx, vol.State, rdiskDomain.LVEUpdateDrGroup, c)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// 将逻辑卷从原有的置放群组中移除\n\t\tfor _, name := range c.curDRGroupNames {\n\t\t\tc.drgroupRef[name].RemoveMember(vol.UUID.String())\n\t\t}\n\t\t// 将逻辑卷添加到新的置放群组中\n\t\tfor _, spec := range c.Specs {\n\t\t\tsubGroup := spec.SubGroup\n\t\t\tif subGroup == \"\" {\n\t\t\t\t// 如果没有指定子组，则使用远端 SSD UUID 作为子组名称\n\t\t\t\t// 相当于每块盘都是一个子组，相当于没有使用子组功能\n\t\t\t\tsubGroup = vol.UUID.String()\n\t\t\t}\n\t\t\tif err := c.drgroupRef[spec.Name].AddMember(vol.UUID.String(), subGroup, vol.PhysicalVolume.IP.String()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tif c.DryRun {\n\t\treturn errors.New(errors.ErrDryRunSuccessExit, \"dry run check success\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/online_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OnlinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOnlinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_benchmark_task.go",
        "code_start_line": 34,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *UpdateBenchmarkTask) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, rdisk.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark, err = benchRepo.FindByUUID(ctx, c.BenchmarkUUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventUpdateBench, benchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_flow_ctrl.go",
        "code_start_line": 80,
        "code_end_line": 103,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeFlowControlCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not found\")\n\t}\n\n\tspec := c.volume.FlowControlSpec\n\tif !c.UpdateRequest.UpdateSpec(&spec, c.volume.GetDefaultFlowControlSpec()) {\n\t\t// 没有任何更新，直接返回成功\n\t\treturn nil\n\t}\n\tc.volume.SetFlowControlSpec(spec)\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEUpdateFlowControl, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_defunct_volume.go",
        "code_start_line": 46,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *CleanupDefunctCommand) Handle(ctx context.Context) error {\n\tvar err error\n\tc.lv, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar sm = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\tvar event = rdiskDomain.LVECleanupDefunct\n\n\tfor _, attachment := range c.lv.Attachments {\n\t\tlogs.Info(ctx).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).Msg(\"cleanup defuncting volume\")\n\t\tsubCmd := &cleanDefunctSubCommand{Parent: c, HostIP: attachment.IP}\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, subCmd)\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，因为只要有一个挂载点清理失败，其他挂载点还是需要继续清理的\n\t\t\t// 失败的挂载点会在后台继续清理\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).\n\t\t\t\tMsg(\"failed to cleanup defunct volume, retry later.\")\n\t\t}\n\t}\n\n\tif len(c.lv.Attachments) == 0 {\n\t\t// 没有挂载点，直接清理\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, &cleanDefunctSubCommand{Parent: c, HostIP: net.IP{}})\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，后续自动重试即可\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Msg(\"failed to complete cleanup defunct volume\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_drgroup_exists.go",
        "code_start_line": 28,
        "code_end_line": 53,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDRGroupExistsCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t)\n\tfor _, spec := range c.DRGroup {\n\t\t_, err := repo.FindByName(ctx, users.AppID(c.AppID), spec.Name)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\tgroup := drgroup.New(spec.Name, users.AppID(c.AppID))\n\t\t\t\tif spec.Affinity > 0 {\n\t\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t\t}\n\t\t\t\tif spec.Type != \"\" {\n\t\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t\t}\n\t\t\t\terr = repo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_physical_volume.go",
        "code_start_line": 31,
        "code_end_line": 54,
        "code_key": "Handle",
        "code_value": "func (c *UpdatePhyRDiskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEUpdatePhysicalVolume, c)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/recycle_backup_data.go",
        "code_start_line": 32,
        "code_end_line": 62,
        "code_key": "Handle",
        "code_value": "func (c *RecycleBackupDataCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventDeleteBackup,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go",
        "code_start_line": 74,
        "code_end_line": 102,
        "code_key": "ProcessChargeDetail",
        "code_value": "func (c *CbsAppIdConsumer) ProcessChargeDetail(detail *ChargeDetail) error {\n\tcbsSrv := c.ResSrv.(*measure.CbsSrv)\n\t// 不同用户的资源数是不一致的，这里顺序处理的话性能一般，需要放在协程中跑\n\t// 单个用户最多启动100个协程，避免协程过多\n\tvar wg sync.WaitGroup\n\tfor _, cbsInstanceId := range detail.ResIds {\n\t\twg.Add(1)\n\t\tgo func(cbsInstanceId measure.ResourceId) {\n\t\t\tdefer wg.Done()\n\t\t\t// 并发的控制策略: 同时处理的用户不超过t.Concurrency个，所有用户共享t.Concurrency * 100个协程\n\t\t\t// 这样设计的目的是为了规避用户资源倾斜严重的问题，同时也能保证用户的并发度较少\n\t\t\tc.ResSemaphore <- struct{}{}\n\t\t\tdefer func() {\n\t\t\t\t<-c.ResSemaphore\n\t\t\t}()\n\n\t\t\tlogs.Info(c.Ctx).\n\t\t\t\tUint64(\"appId\", uint64(detail.User.AppId)).\n\t\t\t\tStr(\"cbsInstanceId\", string(cbsInstanceId)).\n\t\t\t\tMsg(\"PROCESS_SIGNAL_DISK\")\n\n\t\t\tchargeItem := cbsSrv.BuildResChargeItem(detail.User, cbsInstanceId, detail.ChargeTime)\n\t\t\t// 单个资源失败就等下一轮，先忽略err\n\t\t\t_ = c.ProcessSingleChargeItem(detail.User, cbsInstanceId, chargeItem)\n\t\t}(cbsInstanceId)\n\t}\n\twg.Wait()\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/service.go",
        "code_start_line": 208,
        "code_end_line": 217,
        "code_key": "BuildResChargeItem",
        "code_value": "func (cbsSrv *CbsSrv) BuildResChargeItem(u *user.User, resourceId ResourceId, chargeTime time.Time) *ChargeItem {\n\tcbsMeasureRepo := cbsSrv.balanceRepo.(repositories.CbsBalanceRepoIFace)\n\tbalanceRecords, _ := cbsMeasureRepo.GetCbsBalanceRecords(cbsSrv.ctx, string(resourceId), chargeTime, false)\n\n\tif len(balanceRecords) == 0 {\n\t\treturn nil\n\t}\n\n\treturn cbsSrv.convertToChargeItem(u, resourceId, balanceRecords, chargeTime)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 133,
        "code_end_line": 236,
        "code_key": "BuildResChargeItem",
        "code_value": "func (snapSrv *SnapSrv) BuildResChargeItem(u *user.User, resourceId ResourceId, chargeTime time.Time) *ChargeItem {\n\t// 获取符合条件的balanceRecord并根据chargeTime排序\n\tbalanceRecords, _ := snapSrv.snapRepo.GetSnapBalanceRecords(snapSrv.ctx, string(resourceId), chargeTime)\n\n\t// FIXME 临时方案：用内存里的lastBalanceTime覆盖balanceRecords里的balanceTime\n\tfor _, balanceRecord := range balanceRecords {\n\t\tlastBalanceTime, ok := snapSrv.lastBalanceTimeCache[balanceRecord.ID]\n\t\tif ok {\n\t\t\tbalanceRecord.LastBalanceTime = lastBalanceTime\n\t\t}\n\t}\n\n\tif len(balanceRecords) == 0 {\n\t\treturn nil\n\t}\n\tsort.Slice(balanceRecords, func(i, j int) bool {\n\t\tif balanceRecords[i].LastBalanceTime.Equal(balanceRecords[j].LastBalanceTime) {\n\t\t\treturn balanceRecords[i].OperationType < balanceRecords[j].OperationType\n\t\t}\n\t\treturn balanceRecords[i].LastBalanceTime.Before(balanceRecords[j].LastBalanceTime)\n\t})\n\n\t// 区分国内站和国际站用户\n\tvar userArea Area\n\tif u.IsI18nUser() {\n\t\tuserArea = AreaI18n\n\t} else {\n\t\tuserArea = AreaChina\n\t}\n\tisGrayUser, err := u.CheckFeature(user.USER_FLAG_SNAP_GRAY_USER)\n\tif err != nil {\n\t\tlogs.Error(snapSrv.ctx).Err(err).Int64(\"appId\", int64(u.AppId)).Msg(\"CHECK_GRAY_USER_ERR\")\n\t\t// 出错时标记为非灰度用户，避免重复推量\n\t\tisGrayUser = false\n\t}\n\n\tchargeItem := &ChargeItem{\n\t\t// FIXME: 需要从配置文件中获取region id\n\t\tRegionId:     snapSrv.regionId,\n\t\tZoneId:       balanceRecords[0].ZoneID,\n\t\tAppId:        u.AppId,\n\t\tUin:          u.Uin,\n\t\tUserArea:     userArea,\n\t\tIsGrayUser:   isGrayUser,\n\t\tResourceId:   resourceId,\n\t\tResourceArea: snapSrv.regionArea,\n\t\tItems:        make([]*SubItem, 0, len(balanceRecords)),\n\t}\n\n\t// 虚拟计费条目，用于确定endBalanceTime\n\tendBalanceRecord := &ccdb.CSnapBalance{LastBalanceTime: chargeTime.Add(time.Second * -1)}\n\tallBalances := append(balanceRecords, endBalanceRecord)\n\n\tfor i, balanceRecord := range allBalances[1:] {\n\t\tbeginBalanceRecord := balanceRecords[i]\n\t\t// 资源欠费，不收取费用\n\t\tif beginBalanceRecord.OperationType == int(SnapOpArrearage) {\n\t\t\tlogs.Info(snapSrv.ctx).Uint64(\"appId\", uint64(u.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"RESOURCE_ARREARAGE\")\n\t\t\tcontinue\n\t\t}\n\t\t// 资源已退还。退还后还产生了计费条目，非期望行为\n\t\tif beginBalanceRecord.OperationType == int(SnapOpReturn) {\n\t\t\tlogs.Info(snapSrv.ctx).Uint64(\"appId\", uint64(u.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"SNAP_HAS_RETURNED\")\n\t\t\tbreak\n\t\t}\n\n\t\t// 资源正常\n\t\tstartTime := beginBalanceRecord.LastBalanceTime\n\t\tendTime := balanceRecord.LastBalanceTime\n\t\tcurTime := startTime\n\t\tfor endTime.After(curTime) {\n\t\t\tcurHourEnd := time.Date(curTime.Year(), curTime.Month(), curTime.Day(), curTime.Hour(), 59, 59, 0, curTime.Location())\n\t\t\tif !endTime.After(curHourEnd) {\n\t\t\t\t// 同一周期\n\t\t\t\tsubItem := &SubItem{\n\t\t\t\t\tPid:       PidSnap,\n\t\t\t\t\tStartTime: curTime,\n\t\t\t\t\tEndTime:   endTime,\n\t\t\t\t\tSubValueDetail: map[string]interface{}{\n\t\t\t\t\t\t\"Size\": beginBalanceRecord.SnapSize},\n\t\t\t\t}\n\t\t\t\tchargeItem.Items = append(chargeItem.Items, subItem)\n\t\t\t\tcurTime = endTime.Add(time.Second)\n\t\t\t} else {\n\t\t\t\t// 非同一周期，先构建这个周期的\n\t\t\t\tsubItem := &SubItem{\n\t\t\t\t\tStartTime: curTime,\n\t\t\t\t\tEndTime:   curHourEnd,\n\t\t\t\t\tSubValueDetail: map[string]interface{}{\n\t\t\t\t\t\t\"Size\": beginBalanceRecord.SnapSize,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\tchargeItem.Items = append(chargeItem.Items, subItem)\n\t\t\t\tcurTime = curHourEnd.Add(time.Second)\n\t\t\t}\n\n\t\t}\n\t}\n\tif len(chargeItem.Items) == 0 {\n\t\treturn nil\n\t}\n\n\treturn chargeItem\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 247,
        "code_end_line": 264,
        "code_key": "BuildResChargeItem",
        "code_value": "func (cbsSrv *CbsSrv) BuildResChargeItem(u *user.User, resourceId ResourceId, chargeTime time.Time) *ChargeItem {\n\tcbsMeasureRepo := cbsSrv.measureRepo.(CbsMeasureRepoIFace)\n\tbalanceRecords, _ := cbsMeasureRepo.GetCbsBalanceRecords(cbsSrv.ctx, string(resourceId), chargeTime, false)\n\n\t// FIXME 临时方案：用内存里的lastBalanceTime覆盖balanceRecords里的balanceTime\n\tfor _, balanceRecord := range balanceRecords {\n\t\tlastBalanceTime, ok := cbsSrv.lastBalanceTimeCache[balanceRecord.ID]\n\t\tif ok {\n\t\t\tbalanceRecord.LastBalanceTime = lastBalanceTime\n\t\t}\n\t}\n\n\tif len(balanceRecords) == 0 {\n\t\treturn nil\n\t}\n\n\treturn cbsSrv.convertToChargeItem(u, resourceId, balanceRecords, chargeTime)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/service.go",
        "code_start_line": 294,
        "code_end_line": 367,
        "code_key": "convertToChargeItem",
        "code_value": "func (cbsSrv *CbsSrv) convertToChargeItem(u *user.User, resourceId ResourceId, balanceRecords []*ccdb.CCbsBalance, chargeTime time.Time) *ChargeItem {\n\tsort.Slice(balanceRecords, func(i, j int) bool {\n\t\tif balanceRecords[i].LastBalanceTime.Equal(balanceRecords[j].LastBalanceTime) {\n\t\t\treturn balanceRecords[i].OperationType < balanceRecords[j].OperationType\n\t\t}\n\t\treturn balanceRecords[i].LastBalanceTime.Before(balanceRecords[j].LastBalanceTime)\n\t})\n\n\t// 区分国内站和国际站用户\n\tvar userArea Area\n\tif u.IsI18nUser() {\n\t\tuserArea = AreaI18n\n\t} else {\n\t\tuserArea = AreaChina\n\t}\n\tisGrayUser, err := u.CheckFeature(user.USER_FLAG_CBS_GRAY_USER)\n\tif err != nil {\n\t\tlogs.Error(cbsSrv.ctx).Err(err).Int64(\"appId\", int64(u.AppId)).Msg(\"CHECK_GRAY_USER_ERR\")\n\t\t// 出错时标记为非灰度用户，避免重复推量\n\t\tisGrayUser = false\n\t}\n\n\tchargeItem := &ChargeItem{\n\t\t// FIXME: 需要从配置文件中获取region id\n\t\tRegionId:     cbsSrv.regionId,\n\t\tZoneId:       balanceRecords[0].ZoneID,\n\t\tAppId:        u.AppId,\n\t\tUin:          u.Uin,\n\t\tUserArea:     userArea,\n\t\tIsGrayUser:   isGrayUser,\n\t\tResourceId:   resourceId,\n\t\tResourceArea: cbsSrv.regionArea,\n\t\tItems:        make([]*SubItem, 0, len(balanceRecords)),\n\t\tUpdateKVs:    make([]*UpdateKV, 0, len(balanceRecords)),\n\t}\n\n\t// 虚拟计费条目，用于确定endBalanceTime\n\tendBalanceRecord := &ccdb.CCbsBalance{LastBalanceTime: chargeTime.Add(time.Second * -1)}\n\tallBalances := append(balanceRecords, endBalanceRecord)\n\n\t// 获取云盘信息\n\tfor i, balanceRecord := range allBalances[1:] {\n\t\tbeginBalanceRecord := balanceRecords[i]\n\t\t// 用于组装单个BalanceRecord的subitem\n\t\tstopCharge := cbsSrv.processSingleBalanceRecords(\n\t\t\tchargeItem, beginBalanceRecord, balanceRecord, u, resourceId)\n\t\tif stopCharge {\n\t\t\t// TODO 停止计费。如果后续产生预期外的计费条目，状态也应该置为无效\n\t\t\t// 现在先不处理，避免因bug导致少收费\n\t\t\tbreak\n\t\t}\n\n\t\t// 灰度阶段使用\n\t\tif isGrayUser {\n\t\t\t// 更新balanceRecord\n\t\t\tupdateKV := &UpdateKV{\n\t\t\t\tId:              beginBalanceRecord.ID,\n\t\t\t\tLastBalanceTime: chargeTime,\n\t\t\t\tStatus:          beginBalanceRecord.Status,\n\t\t\t}\n\t\t\tif i != len(balanceRecords)-1 ||\n\t\t\t\t(beginBalanceRecord.OperationType == int(CbsOpReturn) || beginBalanceRecord.OperationType == int(CbsOpConvert)) {\n\t\t\t\tbeginBalanceRecord.Status = 0\n\t\t\t}\n\t\t\tchargeItem.UpdateKVs = append(chargeItem.UpdateKVs, updateKV)\n\t\t}\n\n\t}\n\tif len(chargeItem.Items) == 0 && len(chargeItem.UpdateKVs) == 0 {\n\t\treturn nil\n\t}\n\n\treturn chargeItem\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 341,
        "code_end_line": 414,
        "code_key": "convertToChargeItem",
        "code_value": "func (cbsSrv *CbsSrv) convertToChargeItem(u *user.User, resourceId ResourceId, balanceRecords []*ccdb.CCbsBalance, chargeTime time.Time) *ChargeItem {\n\tsort.Slice(balanceRecords, func(i, j int) bool {\n\t\tif balanceRecords[i].LastBalanceTime.Equal(balanceRecords[j].LastBalanceTime) {\n\t\t\treturn balanceRecords[i].OperationType < balanceRecords[j].OperationType\n\t\t}\n\t\treturn balanceRecords[i].LastBalanceTime.Before(balanceRecords[j].LastBalanceTime)\n\t})\n\n\t// 区分国内站和国际站用户\n\tvar userArea Area\n\tif u.IsI18nUser() {\n\t\tuserArea = AreaI18n\n\t} else {\n\t\tuserArea = AreaChina\n\t}\n\tisGrayUser, err := u.CheckFeature(user.USER_FLAG_CBS_GRAY_USER)\n\tif err != nil {\n\t\tlogs.Error(cbsSrv.ctx).Err(err).Int64(\"appId\", int64(u.AppId)).Msg(\"CHECK_GRAY_USER_ERR\")\n\t\t// 出错时标记为非灰度用户，避免重复推量\n\t\tisGrayUser = false\n\t}\n\n\tchargeItem := &ChargeItem{\n\t\t// FIXME: 需要从配置文件中获取region id\n\t\tRegionId:     cbsSrv.regionId,\n\t\tZoneId:       balanceRecords[0].ZoneID,\n\t\tAppId:        u.AppId,\n\t\tUin:          u.Uin,\n\t\tUserArea:     userArea,\n\t\tIsGrayUser:   isGrayUser,\n\t\tResourceId:   resourceId,\n\t\tResourceArea: cbsSrv.regionArea,\n\t\tItems:        make([]*SubItem, 0, len(balanceRecords)),\n\t\tUpdateKVs:    make([]*UpdateKV, 0, len(balanceRecords)),\n\t}\n\n\t// 虚拟计费条目，用于确定endBalanceTime\n\tendBalanceRecord := &ccdb.CCbsBalance{LastBalanceTime: chargeTime.Add(time.Second * -1)}\n\tallBalances := append(balanceRecords, endBalanceRecord)\n\n\t// 获取云盘信息\n\tfor i, balanceRecord := range allBalances[1:] {\n\t\tbeginBalanceRecord := balanceRecords[i]\n\t\t// 用于组装单个BalanceRecord的subitem\n\t\tstopCharge := cbsSrv.processSingleBalanceRecords(\n\t\t\tchargeItem, beginBalanceRecord, balanceRecord, u, resourceId)\n\t\tif stopCharge {\n\t\t\t// TODO 停止计费。如果后续产生预期外的计费条目，状态也应该置为无效\n\t\t\t// 现在先不处理，避免因bug导致少收费\n\t\t\tbreak\n\t\t}\n\n\t\t// 灰度阶段使用\n\t\tif isGrayUser {\n\t\t\t// 更新balanceRecord\n\t\t\tupdateKV := &UpdateKV{\n\t\t\t\tId:              beginBalanceRecord.ID,\n\t\t\t\tLastBalanceTime: chargeTime,\n\t\t\t\tStatus:          beginBalanceRecord.Status,\n\t\t\t}\n\t\t\tif i != len(balanceRecords)-1 ||\n\t\t\t\t(beginBalanceRecord.OperationType == int(CbsOpReturn) || beginBalanceRecord.OperationType == int(CbsOpConvert)) {\n\t\t\t\tbeginBalanceRecord.Status = 0\n\t\t\t}\n\t\t\tchargeItem.UpdateKVs = append(chargeItem.UpdateKVs, updateKV)\n\t\t}\n\n\t}\n\tif len(chargeItem.Items) == 0 && len(chargeItem.UpdateKVs) == 0 {\n\t\treturn nil\n\t}\n\n\treturn chargeItem\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/service.go",
        "code_start_line": 369,
        "code_end_line": 434,
        "code_key": "processSingleBalanceRecords",
        "code_value": "func (cbsSrv *CbsSrv) processSingleBalanceRecords(chargeItem *ChargeItem, beginBalanceRecord *ccdb.CCbsBalance, endBalanceRecord *ccdb.CCbsBalance, user *user.User, resourceId ResourceId) (stopCharge bool) {\n\tstopCharge = false\n\t// 资源欠费，不收取费用\n\tif beginBalanceRecord.OperationType == int(CbsOpArrearage) {\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"RESOURCE_ARREARAGE\")\n\t\treturn\n\t}\n\t// 资源退还。判断是否为预付费的性能突发场景\n\tif beginBalanceRecord.OperationType == int(CbsOpReturn) || beginBalanceRecord.OperationType == int(CbsOpConvert) {\n\t\t// 判断是否为预付费的性能突发场景.\n\t\t// 获取云盘信息。这里在循环中进行查询，但命中的应该不会很多，放在外层反而会导致每个云盘都被查询\n\t\tdisk, err := cbsSrv.diskRepo.QueryDiskInfoById(cbsSrv.ctx, string(resourceId))\n\t\tif err != nil || disk == nil {\n\t\t\tlogs.Error(cbsSrv.ctx).Err(err).Str(\"resourceId\", string(resourceId)).Msg(\"QUERY_CBS_RECORD_FAILED\")\n\t\t\t// TODO 这里先不返回资源的推量？\n\t\t\treturn true\n\t\t}\n\t\t// TODO 走diskLogical\n\t\tif disk.PayMode == \"prepay\" {\n\t\t\t// 性能突发场景，预付费用户退盘，退盘费用不计\n\t\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"MAYBE_CBS_WITH_BURST_PERFORMANCE\")\n\t\t\treturn\n\t\t}\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"CBS_HAS_RETURNED\")\n\t\treturn true\n\t}\n\n\t// 资源正常\n\tstartTime := beginBalanceRecord.LastBalanceTime\n\tendTime := endBalanceRecord.LastBalanceTime\n\tcurTime := startTime\n\tfor endTime.After(curTime) {\n\t\tcurHourEnd := time.Date(curTime.Year(), curTime.Month(), curTime.Day(), curTime.Hour(), 59, 59, 0, curTime.Location())\n\n\t\tvar config CCbsBalanceConfig\n\t\terr := json.Unmarshal([]byte(beginBalanceRecord.Config), &config)\n\t\tif err != nil {\n\t\t\tlogs.Error(cbsSrv.ctx).Err(err).Msg(\"PARSE_CONFIG_ERROR\")\n\t\t\treturn\n\t\t}\n\n\t\tcurEndTime := endTime\n\t\tcurStarTime := curTime\n\t\tif !endTime.After(curHourEnd) {\n\t\t\t// 同一周期\n\t\t\tcurTime = endTime.Add(time.Second)\n\t\t} else {\n\t\t\tcurEndTime = curHourEnd\n\t\t\tcurTime = curHourEnd.Add(time.Second)\n\t\t}\n\t\tsubItem := &SubItem{\n\t\t\tPid:       beginBalanceRecord.Pid,\n\t\t\tStartTime: curStarTime,\n\t\t\tEndTime:   curEndTime,\n\t\t\tProjectId: beginBalanceRecord.ProjectID,\n\t\t\tParams:    beginBalanceRecord.ResourceInfo,\n\t\t\tSubValueDetail: map[string]interface{}{\n\t\t\t\t// FIXME 性能突发场景待实现\n\t\t\t\t\"Size\":             config.Size,\n\t\t\t\t\"BackupPointQuota\": config.BackupPointQuota,\n\t\t\t},\n\t\t}\n\t\tchargeItem.Items = append(chargeItem.Items, subItem)\n\t}\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 416,
        "code_end_line": 481,
        "code_key": "processSingleBalanceRecords",
        "code_value": "func (cbsSrv *CbsSrv) processSingleBalanceRecords(chargeItem *ChargeItem, beginBalanceRecord *ccdb.CCbsBalance, endBalanceRecord *ccdb.CCbsBalance, user *user.User, resourceId ResourceId) (stopCharge bool) {\n\tstopCharge = false\n\t// 资源欠费，不收取费用\n\tif beginBalanceRecord.OperationType == int(CbsOpArrearage) {\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"RESOURCE_ARREARAGE\")\n\t\treturn\n\t}\n\t// 资源退还。判断是否为预付费的性能突发场景\n\tif beginBalanceRecord.OperationType == int(CbsOpReturn) || beginBalanceRecord.OperationType == int(CbsOpConvert) {\n\t\t// 判断是否为预付费的性能突发场景.\n\t\t// 获取云盘信息。这里在循环中进行查询，但命中的应该不会很多，放在外层反而会导致每个云盘都被查询\n\t\tdisk, err := cbsSrv.diskRepo.QueryDiskInfoById(cbsSrv.ctx, string(resourceId))\n\t\tif err != nil || disk == nil {\n\t\t\tlogs.Error(cbsSrv.ctx).Err(err).Str(\"resourceId\", string(resourceId)).Msg(\"QUERY_CBS_RECORD_FAILED\")\n\t\t\t// TODO 这里先不返回资源的推量？\n\t\t\treturn true\n\t\t}\n\t\t// TODO 走diskLogical\n\t\tif disk.PayMode == \"prepay\" {\n\t\t\t// 性能突发场景，预付费用户退盘，退盘费用不计\n\t\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"MAYBE_CBS_WITH_BURST_PERFORMANCE\")\n\t\t\treturn\n\t\t}\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"CBS_HAS_RETURNED\")\n\t\treturn true\n\t}\n\n\t// 资源正常\n\tstartTime := beginBalanceRecord.LastBalanceTime\n\tendTime := endBalanceRecord.LastBalanceTime\n\tcurTime := startTime\n\tfor endTime.After(curTime) {\n\t\tcurHourEnd := time.Date(curTime.Year(), curTime.Month(), curTime.Day(), curTime.Hour(), 59, 59, 0, curTime.Location())\n\n\t\tvar config CCbsBalanceConfig\n\t\terr := json.Unmarshal([]byte(beginBalanceRecord.Config), &config)\n\t\tif err != nil {\n\t\t\tlogs.Error(cbsSrv.ctx).Err(err).Msg(\"PARSE_CONFIG_ERROR\")\n\t\t\treturn\n\t\t}\n\n\t\tcurEndTime := endTime\n\t\tcurStarTime := curTime\n\t\tif !endTime.After(curHourEnd) {\n\t\t\t// 同一周期\n\t\t\tcurTime = endTime.Add(time.Second)\n\t\t} else {\n\t\t\tcurEndTime = curHourEnd\n\t\t\tcurTime = curHourEnd.Add(time.Second)\n\t\t}\n\t\tsubItem := &SubItem{\n\t\t\tPid:       beginBalanceRecord.Pid,\n\t\t\tStartTime: curStarTime,\n\t\t\tEndTime:   curEndTime,\n\t\t\tProjectId: beginBalanceRecord.ProjectID,\n\t\t\tParams:    beginBalanceRecord.ResourceInfo,\n\t\t\tSubValueDetail: map[string]interface{}{\n\t\t\t\t// FIXME 性能突发场景待实现\n\t\t\t\t\"Size\":             config.Size,\n\t\t\t\t\"BackupPointQuota\": config.BackupPointQuota,\n\t\t\t},\n\t\t}\n\t\tchargeItem.Items = append(chargeItem.Items, subItem)\n\t}\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/convertor.go",
        "code_start_line": 28,
        "code_end_line": 38,
        "code_key": "Start",
        "code_value": "func (a *Convertor) Start(ctx context.Context) error {\n\t// 启动转换器\n\tfor _, scanner := range a.scanners {\n\t\tscanner := scanner\n\t\tgo func() {\n\t\t\ta.convertToTask(ctx, scanner)\n\t\t}()\n\t}\n\tlogs.Info(ctx).Msgf(\"Convertor Start Success\")\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_rec_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *CbsMeasureReconciliationTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\t//s.resultChan <- struct{}{}\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_rec_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 35,
        "code_key": "Start",
        "code_value": "func (s *SnapMeasureReconciliationTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_compute_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *SnapComputeTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\t//s.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_measure_send_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *CbsMeasureSendTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_bill_valid_appId_fetch_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *CbsValidAppIdFetchTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_calculate_cost_locally_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 36,
        "code_key": "Start",
        "code_value": "func (s *SnapCalculateCostLocallyTaskScanner) Start(ctx context.Context) error {\n\t//s.resultChan <- struct{}{}\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_create_task_scanner.go",
        "code_start_line": 23,
        "code_end_line": 42,
        "code_key": "Start",
        "code_value": "func (s *UpdateCreateTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\trunning := true\n\t\tfor running {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\trunning = false\n\t\t\tdefault:\n\t\t\t\terr := s.FullScan(ctx)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogs.Fatal(ctx).Msgf(\"%s full scan failed!\\n\", s.name)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\ttime.Sleep(s.scanInterval)\n\t\t}\n\t}()\n\tlogs.Info(ctx).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_measure_send_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 36,
        "code_key": "Start",
        "code_value": "func (s *SnapMeasureSendTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\t//s.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/repush_user_billing_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 39,
        "code_key": "Start",
        "code_value": "func (s *RepushUserBillingTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_rollback_task_scanner.go",
        "code_start_line": 23,
        "code_end_line": 42,
        "code_key": "Start",
        "code_value": "func (s *UpdateRollbackTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\trunning := true\n\t\tfor running {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\trunning = false\n\t\t\tdefault:\n\t\t\t\terr := s.FullScan(ctx)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogs.Fatal(ctx).Msgf(\"%s full scan failed!\\n\", s.name)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\ttime.Sleep(s.scanInterval)\n\t\t}\n\t}()\n\tlogs.Info(ctx).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_valid_appId_fetch_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 36,
        "code_key": "Start",
        "code_value": "func (s *SnapValidAppIdFetchTaskScanner) Start(ctx context.Context) error {\n\t//s.resultChan <- struct{}{}\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_bill_compute_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 39,
        "code_key": "Start",
        "code_value": "func (s *CbsBillComputeTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/app/app.go",
        "code_start_line": 31,
        "code_end_line": 39,
        "code_key": "Start",
        "code_value": "func (m *PipelineManager) Start(ctx context.Context) error {\n\tfor region, pipeline := range m.Pipelines {\n\t\tregionCtx := context.WithValue(ctx, \"region\", region)\n\t\tif err := pipeline.Start(regionCtx); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/app/app.go",
        "code_start_line": 46,
        "code_end_line": 51,
        "code_key": "Start",
        "code_value": "func (app *NebulaApp) Start(ctx context.Context) error {\n\tif err := app.pipelineManager.Start(ctx); err != nil {\n\t\treturn err\n\t}\n\treturn <-app.stopChan\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/app/pipeline.go",
        "code_start_line": 20,
        "code_end_line": 46,
        "code_key": "Start",
        "code_value": "func (p *RegionPipeline) Start(ctx context.Context) error {\n\tregion := ctx.Value(\"region\").(string)\n\tscannerLogCtx := initLogger(ctx, region, \"scanner.log\")\n\tfor _, scanner := range p.scanners {\n\t\tsingleCtx := logs.AddDefaultMessage(scannerLogCtx, \"name\", scanner.GetName())\n\t\terr := scanner.Start(singleCtx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tinitMetric(scanner, region, \"scanner\", scanner.GetName())\n\t}\n\n\tconvertorLogCtx := initLogger(ctx, region, \"convertor.log\")\n\terr := p.convertor.Start(convertorLogCtx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// start scheduler\n\tschedulerLogCtx := initLogger(ctx, region, \"scheduler.log\")\n\terr = p.scheduler.Start(schedulerLogCtx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tinitMetric(p.scheduler, region, \"scheduler\", \"scheduler\")\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go",
        "code_start_line": 109,
        "code_end_line": 112,
        "code_key": "Start",
        "code_value": "func (sc *Scheduler) Start(ctx context.Context) error {\n\tgo sc.mainLoop(ctx)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/scheduler.go",
        "code_start_line": 154,
        "code_end_line": 191,
        "code_key": "Start",
        "code_value": "func (s *scheduler) Start(ctx context.Context) error {\n\twg := sync.WaitGroup{}\n\trunning := true\n\tgo s.haManager.Start(ctx)\n\tdefer s.haManager.Close(ctx)\n\tfor {\n\t\tselect {\n\t\tcase taskName := <-s.eventChan:\n\t\t\twg.Add(1)\n\t\t\tgo func(name string) {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tif task, ok := s.loads[name]; ok {\n\n\t\t\t\t\tif s.isMaster {\n\t\t\t\t\t\t_ctx := logs.With(ctx).Str(\"seqId\", uuid.New().String()).Str(\"taskName\", name).Logger().WithContext(ctx)\n\t\t\t\t\t\ttask.Work(_ctx)\n\t\t\t\t\t}\n\n\t\t\t\t\ttriggerTime := time.Now().Add(task.Interval())\n\t\t\t\t\tfor {\n\t\t\t\t\t\tif !running {\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif time.Now().After(triggerTime) {\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttime.Sleep(time.Second)\n\t\t\t\t\t}\n\t\t\t\t\ts.eventChan <- name\n\t\t\t\t}\n\t\t\t}(taskName)\n\t\tcase <-s.stopChan:\n\t\t\trunning = false\n\t\t\twg.Wait()\n\t\t\treturn nil\n\t\t}\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/easyha/model.go",
        "code_start_line": 108,
        "code_end_line": 180,
        "code_key": "Start",
        "code_value": "func (m *haManagerImpl) Start(ctx context.Context) {\n\tm.keepRunning = true\n\tm.ctx = ctx\n\tvar (\n\t\tmyIdentity            = m.delegate.GetIdentity()                                    // 当前节点的业务标识\n\t\tmyKey                 = fmt.Sprintf(\"easyhaMaster/%s\", url.PathEscape(m.namespace)) // 分布式锁的key\n\t\tmyToken               = m.encodeToken(myIdentity)                                   // 分布式锁 Token，包含业务标识和随机信息\n\t\tmyLock                dlock.Lock                                                    // 获取到的分布式锁, 用于刷新和释放\n\t\tcurrentMasterIdentity string                                                        // 当前 master 的业务标识，如果为空则是还未获取过当前 master\n\t)\n\n\t// Start slave loop.\n\tfor m.keepRunning {\n\t\t// Try observe the master lock first.\n\t\tif view, err := m.locker.Observe(ctx, myKey); err != nil {\n\t\t\tm.logger.Info().Err(err).Str(\"key\", myKey).Msg(\"failed to observe current master lock\")\n\t\t\t// Failed to observe the master lock, try to  obtain the lock.\n\t\t\tmyLock, err = m.locker.Obtain(ctx, dlock.NewWriteLockKey(myKey), m.lockExpired, &dlock.Option{Token: myToken})\n\t\t\tif err == nil {\n\t\t\t\t// Successfully obtained the lock.\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tnewIdentity, err := m.decodeToken(view.Token)\n\t\t\tif err != nil {\n\t\t\t\tm.logger.Warn().Err(err).Str(\"token\", view.Token).Msg(\"failed to decode token\")\n\t\t\t} else if currentMasterIdentity == \"\" {\n\t\t\t\t// First time to observe the master.\n\t\t\t\tcurrentMasterIdentity = newIdentity\n\t\t\t\tif err := m.delegate.OnBecomeSlave(ctx, currentMasterIdentity); err != nil {\n\t\t\t\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle become slave, force quit for safety\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if currentMasterIdentity != newIdentity {\n\t\t\t\t// Master changed. Need update.\n\t\t\t\tcurrentMasterIdentity = newIdentity\n\t\t\t\tif err := m.delegate.OnSwitchMaster(ctx, currentMasterIdentity); err != nil {\n\t\t\t\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle switch master, force quit for safety\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttime.Sleep(m.checkInterval)\n\t}\n\n\tif myLock == nil {\n\t\tm.logger.Fatal().Msg(\"myLock is nil, found bug, force quit for safety\")\n\t\treturn\n\t}\n\n\t// I am the master now.\n\tif err := m.delegate.OnBecomeMaster(ctx); err != nil {\n\t\tmyLock.Release(ctx)\n\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle become master, force quit for safety\")\n\t\treturn\n\t}\n\n\tdefer func() {\n\t\tmyLock.Release(ctx)\n\t\tif err := m.delegate.OnLostMaster(ctx); err != nil {\n\t\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle lost master, force quit for safety\")\n\t\t}\n\t}()\n\n\t// Start the master loop.\n\tfor m.keepRunning {\n\t\ttime.Sleep(m.checkInterval)\n\t\tif err := myLock.Refresh(ctx, m.lockExpired); err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_bill_compute_task.go",
        "code_start_line": 63,
        "code_end_line": 113,
        "code_key": "ProcessUserSnapResources",
        "code_value": "func (t *SnapBillComputeTask) ProcessUserSnapResources(user *user.User, snapIds []measure.ResourceId) {\n\tsnapSrv := t.ResSrv.(*measure.SnapSrv)\n\t// 不同用户的资源数是不一致的，这里顺序处理的话性能一般，需要放在协程中跑\n\t// 单个用户最多启动100个协程，避免协程过多\n\tvar wg sync.WaitGroup\n\tsemaphore := make(chan struct{}, 100)\n\tchargeTimeFromSnapshot := snapSrv.GetSnapRealChargeTimes(user.AppId, t.ChargeTime)\n\n\tfor _, snapId := range snapIds {\n\t\twg.Add(1)\n\t\tgo func(snapId measure.ResourceId) {\n\t\t\tdefer wg.Done()\n\t\t\t// 这里可以控制启动的协程数\n\t\t\tsemaphore <- struct{}{}\n\t\t\tdefer func() { <-semaphore }()\n\n\t\t\tlogs.Info(t.Ctx).\n\t\t\t\tUint64(\"app_id\", uint64(user.AppId)).\n\t\t\t\tStr(\"snap_id\", string(snapId)).\n\t\t\t\tMsg(\"PROCESS_SIGNAL_SNAP\")\n\t\t\t// 计费真正的结算时间：若快照deadline时间晚于结算时间，则结算时间=快照deadline\n\t\t\tchargeTime, ok := chargeTimeFromSnapshot[snapId]\n\t\t\tif !ok {\n\t\t\t\tchargeTime = t.ChargeTime\n\t\t\t}\n\n\t\t\tchargeItem := snapSrv.BuildResChargeItem(user, snapId, chargeTime)\n\t\t\tif chargeItem == nil {\n\t\t\t\t// 可能是资源不需要计费。这里需要把资源Id从UnConfirmedMap中删除\n\t\t\t\tt.MarkSingleResDone(user.AppId, snapId)\n\t\t\t\tlogs.Info(t.Ctx).Uint64(\"appId\", uint64(user.AppId)).\n\t\t\t\t\tStr(\"snapId\", string(snapId)).Msg(\"SKIP_SNAP\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tchargeItemMsg := mqimpl.NewMessage(mq.MSGTYPE_JSON, chargeItem)\n\t\t\terr := t.ChargeItemProducer.Publish(chargeItemMsg)\n\t\t\tlogs.Info(t.Ctx).\n\t\t\t\tUint64(\"appId\", uint64(user.AppId)).\n\t\t\t\tStr(\"snap_id\", string(snapId)).\n\t\t\t\tMsg(\"PUBLISH_CHARGE_ITEM\")\n\t\t\tif err != nil {\n\t\t\t\tlogs.Error(t.Ctx).Err(err).\n\t\t\t\t\tUint64(\"appId\", uint64(user.AppId)).\n\t\t\t\t\tStr(\"snapId\", string(snapId)).\n\t\t\t\t\tMsg(\"PUBLISH_CHARGE_ITEM_FAILED\")\n\t\t\t}\n\t\t}(snapId)\n\t}\n\twg.Wait()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/task.go",
        "code_start_line": 25,
        "code_end_line": 32,
        "code_key": "UpdateExecuteTime",
        "code_value": "func (t *Task) UpdateExecuteTime(ctx context.Context) {\n\tinterval := t.Interval * time.Duration(t.Count)\n\tif interval >= t.MaxInterval {\n\t\tinterval = t.MaxInterval\n\t}\n\t// 这里应该是执行完成的时间加上等待时间\n\tt.NextTriggerTime = time.Now().Add(time.Second * interval)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/cbs_bill_compute_task.go",
        "code_start_line": 64,
        "code_end_line": 90,
        "code_key": "ProcessUserCbsResources",
        "code_value": "func (t *CbsBillComputeTask) ProcessUserCbsResources(user *user.User, resIds []measure.ResourceId) {\n\tcbsSrv := t.ResSrv.(*measure.CbsSrv)\n\t// 不同用户的资源数是不一致的，这里顺序处理的话性能一般，需要放在协程中跑\n\t// 单个用户最多启动100个协程，避免协程过多\n\tvar wg sync.WaitGroup\n\tfor _, cbsInstanceId := range resIds {\n\t\twg.Add(1)\n\t\tgo func(cbsInstanceId measure.ResourceId) {\n\t\t\tdefer wg.Done()\n\t\t\t// 并发的控制策略: 同时处理的用户不超过t.Concurrency个，所有用户共享t.Concurrency * 100个协程\n\t\t\t// 这样设计的目的是为了规避用户资源倾斜严重的问题，同时也能保证用户的并发度较少\n\t\t\tt.ResSemaphore <- struct{}{}\n\t\t\tdefer func() {\n\t\t\t\t<-t.ResSemaphore\n\t\t\t}()\n\n\t\t\tlogs.Info(t.Ctx).\n\t\t\t\tUint64(\"appId\", uint64(user.AppId)).\n\t\t\t\tStr(\"cbsInstanceId\", string(cbsInstanceId)).\n\t\t\t\tMsg(\"PROCESS_SIGNAL_DISK\")\n\n\t\t\tchargeItem := cbsSrv.BuildResChargeItem(user, cbsInstanceId, t.ChargeTime)\n\t\t\tt.ProcessSingleChargeItem(user, cbsInstanceId, chargeItem)\n\t\t}(cbsInstanceId)\n\t}\n\twg.Wait()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/repush_user_billing_task.go",
        "code_start_line": 103,
        "code_end_line": 172,
        "code_key": "ProcessSingleRepushDetail",
        "code_value": "func (t *RepushUserBillingTask) ProcessSingleRepushDetail(detail *measure.RepushDetail) error {\n\tcbsMeasureRepo := registry.GetRegistry(t.ctx).AdapterRepos.CbsMeasureRepo.(measure.CbsMeasureRepoIFace)\n\tappIdResIdMaps := make(map[user.AppId][]measure.ResourceId)\n\tif detail.AppId > 0 {\n\t\tif len(detail.ResIds) > 0 {\n\t\t\tappIdResIdMaps[detail.AppId] = detail.ResIds\n\t\t} else {\n\t\t\tids, err := cbsMeasureRepo.GetResourceIdsByAppId(t.ctx, int64(detail.AppId), time.Time{}, true, cbsMeasureRepo.GetBalanceTableName())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tresIds := make([]measure.ResourceId, 0, len(ids))\n\t\t\tfor _, resId := range ids {\n\t\t\t\tresIds = append(resIds, measure.ResourceId(resId))\n\t\t\t}\n\t\t\tappIdResIdMaps[detail.AppId] = resIds\n\t\t}\n\t} else {\n\t\tif len(detail.ResIds) > 0 {\n\t\t\treturn fmt.Errorf(\"AppId is required when ResIds is set\")\n\t\t}\n\t\tlogs.Info(t.ctx).Msg(\"REPUSH_ALL_FOR_APPID_NOT_SET\")\n\t\tappIds, _ := cbsMeasureRepo.GetAppIdsWithResources(t.ctx, time.Time{}, true, cbsMeasureRepo.GetBalanceTableName())\n\t\tfor _, appId := range appIds {\n\t\t\t// 没有指定资源，则补量所有资源\n\t\t\tids, err := cbsMeasureRepo.GetResourceIdsByAppId(t.ctx, appId, time.Time{}, true, cbsMeasureRepo.GetBalanceTableName())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tresIds := make([]measure.ResourceId, 0, len(ids))\n\t\t\tfor _, resId := range ids {\n\t\t\t\tresIds = append(resIds, measure.ResourceId(resId))\n\t\t\t}\n\t\t\tappIdResIdMaps[user.AppId(appId)] = resIds\n\t\t}\n\n\t}\n\n\tvar repushItems []*RepushItem\n\tfor appId, resIds := range appIdResIdMaps {\n\t\tu, err := t.userSrv.GetUser(appId)\n\t\tif err != nil {\n\t\t\t// 这里可能是新注册的用户，user表里没有用户数据，可能会丢失该用户的量\n\t\t\tlogs.Error(t.ctx).Err(err).Uint64(\"appId\", uint64(appId)).Msg(\"GET_USER_ERROR\")\n\t\t\tpanic(err)\n\t\t}\n\t\tfor _, resId := range resIds {\n\t\t\tvar repushItem RepushItem\n\t\t\trepushItem.user = u\n\t\t\trepushItem.cbsInstanceId = resId\n\t\t\trepushItem.startTime = detail.StartTime\n\t\t\trepushItem.endTime = detail.EndTime\n\t\t\trepushItems = append(repushItems, &repushItem)\n\t\t}\n\t}\n\tlogs.Info(t.ctx).Int(\"count\", len(repushItems)).Msg(\"REPUSH_ITEMS_INFO\")\n\n\tvar wg sync.WaitGroup\n\tfor _, repushItem := range repushItems {\n\t\twg.Add(1)\n\t\tt.semaphore <- struct{}{}\n\t\tgo func(item *RepushItem) {\n\t\t\tdefer wg.Done()\n\t\t\tdefer func() { <-t.semaphore }()\n\t\t\tt.ProcessSingleRepushItem(item)\n\t\t}(repushItem)\n\t}\n\twg.Wait()\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/cbs_measure_send_task.go",
        "code_start_line": 56,
        "code_end_line": 81,
        "code_key": "ProcessMsgByRegion",
        "code_value": "func (t *CbsMeasureSendTask) ProcessMsgByRegion() {\n\t// 并发处理消息\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < t.Conf.Concurrency; i++ {\n\t\twg.Add(1)\n\t\tgo func(workId int) {\n\t\t\tlog.Infof(\"start work %d\", workId)\n\t\t\tdefer wg.Done()\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase msg, ok := <-t.DomesticChan:\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.ProcessMsgToMeasureDetail(msg)\n\t\t\t\tcase <-t.Ctx.Done():\n\t\t\t\t\tlogs.Info(t.Ctx).Int(\"work_id\", workId).Msg(\"STOP_WORKER\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n\t// 关闭chan\n\twg.Wait()\n\tclose(t.MeasureDetailChan)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_measure_send_task.go",
        "code_start_line": 51,
        "code_end_line": 76,
        "code_key": "ProcessMsgByRegion",
        "code_value": "func (t *SnapMeasureSendTask) ProcessMsgByRegion() {\n\t// 并发处理消息\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < t.Conf.Concurrency; i++ {\n\t\twg.Add(1)\n\t\tgo func(workId int) {\n\t\t\tlog.Infof(\"start work %d\", workId)\n\t\t\tdefer wg.Done()\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase msg, ok := <-t.DomesticChan:\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.ProcessMsgToMeasureDetail(msg)\n\t\t\t\tcase <-t.Ctx.Done():\n\t\t\t\t\tlogs.Info(t.Ctx).Int(\"work_id\", workId).Msg(\"STOP_WORKER\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n\t// 关闭chan\n\twg.Wait()\n\tclose(t.MeasureDetailChan)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/cbs_rec_task.go",
        "code_start_line": 111,
        "code_end_line": 136,
        "code_key": "ProcessMsg",
        "code_value": "func (t *CbsMeasureRecTask) ProcessMsg() {\n\t// 并发处理消息\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < t.Conf.Concurrency; i++ {\n\t\twg.Add(1)\n\t\tgo func(workId int) {\n\t\t\tlog.Infof(\"start work %d\", workId)\n\t\t\tdefer wg.Done()\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase msg, ok := <-t.DomesticChan:\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.ProcessMsgToMeasure(msg)\n\t\t\t\tcase <-t.Ctx.Done():\n\t\t\t\t\tlogs.Info(t.Ctx).Int(\"work_id\", workId).Msg(\"STOP_WORKER\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n\t// 关闭chan\n\twg.Wait()\n\tclose(t.CbsMeasureDetailChan)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_rec_task.go",
        "code_start_line": 63,
        "code_end_line": 105,
        "code_key": "sendDbFromMsg",
        "code_value": "func (t *SnapMeasureReconciliationTask) sendDbFromMsg(wg *sync.WaitGroup) {\n\t// 并发处理消息\n\n\tfor i := 0; i < t.Concurrency; i++ {\n\t\twg.Add(1)\n\t\tgo func(workId int) {\n\t\t\tlog.Infof(\"start work %d\", workId)\n\t\t\tdefer wg.Done()\n\t\t\tunConfirmedMap := make(map[measure.ResourceId]mqiface.IMessage)\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase msg := <-t.snapChargeItemForCompareConsumer.Receiving(mq.MSGTYPE_JSON):\n\t\t\t\t\tchargeItem, _ := parseChargeItem(msg)\n\t\t\t\t\tresourceId := chargeItem.ResourceId\n\t\t\t\t\tunConfirmedMap[resourceId] = msg\n\n\t\t\t\t\t// 达到指定数量后进行数据库同步\n\t\t\t\t\tif len(unConfirmedMap) == 100 {\n\t\t\t\t\t\tlog.Infof(\"unConfirmedMap num %d\", len(unConfirmedMap))\n\t\t\t\t\t\terr := t.ProcessMsgSendMeasure(t.ctx, unConfirmedMap)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tjsonData, _ := json.Marshal(unConfirmedMap)\n\t\t\t\t\t\t\tlogs.Error(t.ctx).Err(err).Str(\"process_msg_send_measure_failed\", string(jsonData)).Msg(\"BATCH_PROCESS_SEND_MEASURE_FAILED\")\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\tcase <-time.After(5 * time.Second):\n\t\t\t\t\tif len(unConfirmedMap) > 0 {\n\t\t\t\t\t\tlogs.Info(t.ctx).Int(\"time_out_process_msg_nums\", len(unConfirmedMap)).Msg(\"TIME_OUT_PROCESS_MSG\")\n\t\t\t\t\t\terr := t.ProcessMsgSendMeasure(t.ctx, unConfirmedMap)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tjsonData, _ := json.Marshal(unConfirmedMap)\n\t\t\t\t\t\t\tlogs.Error(t.ctx).Err(err).Str(\"send_fail_detail\", string(jsonData)).Msg(\"TIMEOUT_PROCESS_SEND_MEASURE_FAILED\")\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tcase <-t.ctx.Done():\n\t\t\t\t\tlogs.Info(t.ctx).Int(\"work_id\", workId).Msg(\"STOP_WORKER\")\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_rec_task.go",
        "code_start_line": 134,
        "code_end_line": 150,
        "code_key": "AckResourceID",
        "code_value": "func (t *SnapMeasureReconciliationTask) AckResourceID() {\n\t// Ack逻辑：AppId关联的所有ChargeItem全部都confirmed了才触发对AppId的Ack\n\tgo func() {\n\t\tfor {\n\t\t\tt.m.Lock()\n\t\t\tfor resourceId := range t.ResourceIdMsgMap {\n\t\t\t\tt.snapChargeItemForCompareConsumer.Ack(t.ResourceIdMsgMap[resourceId])\n\t\t\t\tdelete(t.ResourceIdMsgMap, resourceId)\n\t\t\t\tlogs.Info(t.ctx).Str(\"resource_id\", string(resourceId)).Str(\"resource_id\", string(resourceId)).Msg(\"ACK_RESOURCE_ID\")\n\t\t\t}\n\t\t\tt.m.Unlock()\n\n\t\t\ttime.Sleep(time.Microsecond * 100)\n\t\t}\n\t}()\n\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/base_measure/base_send_measure_task.go",
        "code_start_line": 140,
        "code_end_line": 159,
        "code_key": "AckResourceID",
        "code_value": "func (t *BaseSendMeasureTask) AckResourceID() {\n\t// Ack逻辑：AppId关联的所有ChargeItem全部都confirmed了才触发ACK\n\tt.WG.Add(1)\n\tdefer t.WG.Done()\n\tgo func() {\n\t\tfor {\n\t\t\tt.m.Lock()\n\t\t\tfor resourceId, msgList := range t.unConfirmedMap {\n\t\t\t\tlogs.Info(t.ctx).Str(\"resourceId\", string(resourceId)).Int(\"size\", len(msgList)).Fields(t.unConfirmedMap).Msg(\"CHECK_RESOURCE_ID_CONFIRMED\")\n\t\t\t\tif len(msgList) == 0 {\n\t\t\t\t\tdelete(t.unConfirmedMap, resourceId)\n\t\t\t\t\tt.AckMessage(string(resourceId))\n\t\t\t\t}\n\t\t\t}\n\t\t\tt.m.Unlock()\n\t\t\ttime.Sleep(time.Millisecond * 100)\n\t\t}\n\t}()\n\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/base_measure/base_send_measure_task.go",
        "code_start_line": 261,
        "code_end_line": 313,
        "code_key": "ProcessParamsSendMeasure",
        "code_value": "func (t *BaseSendMeasureTask) ProcessParamsSendMeasure() {\n\tvar wg sync.WaitGroup\n\tsemaphore := make(chan struct{}, 100) // Semaphore with a capacity of 100\n\n\tfor {\n\t\tselect {\n\t\tcase param, ok := <-t.MeasureParamChan:\n\t\t\tif !ok {\n\t\t\t\tlogs.Info(t.Ctx).Msg(\"MEASURE_DETAIL_CHAN_CLOSED\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\twg.Add(1) // Increment the WaitGroup counter\n\n\t\t\tgo func(param interface{}) {\n\t\t\t\tdefer wg.Done() // Decrement the WaitGroup counter when the goroutine completes\n\n\t\t\t\tsemaphore <- struct{}{}        // Acquire a semaphore slot\n\t\t\t\tdefer func() { <-semaphore }() // Release the semaphore slot\n\n\t\t\t\t// Convert param to paraMap\n\t\t\t\tparaMap := make(map[string]interface{})\n\t\t\t\tdata, _ := json.Marshal(param)\n\t\t\t\t_ = json.Unmarshal(data, &paraMap)\n\n\t\t\t\t_, err := t.SendMeasureData(t.Ctx, paraMap)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogs.Info(t.Ctx).Any(\"param\", paraMap).Msg(\"SEND_MEASURE_DATA_ERROR\")\n\t\t\t\t}\n\n\t\t\t\t// Process measureDetail and subMeasureDetail\n\t\t\t\tmeasureDetail := paraMap[\"measureDetail\"].([]interface{})\n\t\t\t\tfor _, measureDetail := range measureDetail {\n\t\t\t\t\tmeasureMap := measureDetail.(map[string]interface{})\n\t\t\t\t\tserialId := measureMap[\"serialId\"].(string)\n\t\t\t\t\tsubMeasureDetail := measureMap[\"subMeasureDetail\"].([]interface{})\n\n\t\t\t\t\tfor _, subMeasure := range subMeasureDetail {\n\t\t\t\t\t\tsubMeasureMap := subMeasure.(map[string]interface{})\n\t\t\t\t\t\tdosageId := subMeasureMap[\"dosageId\"].(string)\n\t\t\t\t\t\tt.MarkMeasureDetailDone(measure.ResourceId(serialId), measure.DosageId(dosageId))\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}(param)\n\n\t\tcase <-t.Ctx.Done():\n\t\t\tlogs.Info(t.Ctx).Msg(\"CTX_DONE\")\n\t\t\twg.Wait() // Wait for all goroutines to complete\n\t\t\treturn\n\t\t}\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/base_measure/base_bill_compute_task.go",
        "code_start_line": 76,
        "code_end_line": 122,
        "code_key": "GetUserResources",
        "code_value": "func (t *BaseBillComputeTask) GetUserResources() {\n\t// 启动多个worker用来处理单用户的快照资源\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < t.userConcurrency; i++ {\n\t\twg.Add(1)\n\t\tgo func(workId int) {\n\t\t\tdefer wg.Done()\n\t\t\tlogs.Info(t.ctx).Int(\"workId\", workId).Msg(\"START_WORKER\")\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase msg, ok := <-t.AppIdConsumer.Receiving(mq.MSGTYPE_TEXT):\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\tlogs.Error(t.ctx).Msg(\"STOP_WORKER\")\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tappId, _ := parseAppId(msg)\n\t\t\t\t\tu, err := t.userSrv.GetUser(appId)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t// 这里可能是新注册的用户，user表里没有用户数据，可能会丢失该用户的量\n\t\t\t\t\t\tlogs.Error(t.ctx).Err(err).Uint64(\"appId\", uint64(appId)).Msg(\"PROCESS_SIGNAL_USER_FAILED\")\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\tt.AddToAckMessage(strconv.FormatUint(uint64(appId), 10), msg)\n\t\t\t\t\terr = t.ProcessSingleUser(u)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlogs.Error(t.ctx).Err(err).Uint64(\"appId\", uint64(appId)).Msg(\"PROCESS_SIGNAL_USER_FAILED\")\n\t\t\t\t\t}\n\t\t\t\tcase <-t.ctx.Done():\n\t\t\t\t\tlogs.Info(t.ctx).Int(\"workId\", workId).Msg(\"STOP_WORKER\")\n\t\t\t\t\treturn\n\t\t\t\tcase <-time.After(time.Second * 10):\n\t\t\t\t\tlogs.Debug(t.ctx).Int(\"workId\", workId).Msg(\"WAIT_MSG_TIMEOUT\")\n\t\t\t\t\t// 队列为空，也没有待Confirm数据的数据\n\t\t\t\t\tif t.AppIdConsumer.QueueIsEmpty() && len(t.unConfirmedMap) == 0 {\n\t\t\t\t\t\tlogs.Info(t.ctx).Int(\"workId\", workId).Msg(\"STOP_WORKER_FOR_QUEUE_EMPTY\")\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}(i)\n\t}\n\t// 关闭chan\n\twg.Wait()\n\tclose(t.UserResChan)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/base_measure/base_bill_compute_task.go",
        "code_start_line": 175,
        "code_end_line": 215,
        "code_key": "AckAppId",
        "code_value": "func (t *BaseBillComputeTask) AckAppId() {\n\tt.WG.Add(1)\n\tdefer t.WG.Done()\n\t// Ack逻辑：AppId关联的所有ChargeItem全部都confirmed了才触发对AppId的Ack\n\tgo func() {\n\t\tfor {\n\t\t\tt.m.Lock()\n\t\t\tfor appId, msgList := range t.unConfirmedMap {\n\t\t\t\tlogs.Info(t.ctx).Uint64(\"appId\", uint64(appId)).Int(\"size\", len(msgList)).Fields(t.unConfirmedMap).Msg(\"CHECK_APPID_CONFIRMED\")\n\t\t\t\tif len(msgList) == 0 {\n\t\t\t\t\tt.AckMessage(strconv.FormatUint(uint64(appId), 10))\n\t\t\t\t\tdelete(t.unConfirmedMap, appId)\n\t\t\t\t}\n\t\t\t}\n\t\t\tt.m.Unlock()\n\t\t\ttime.Sleep(time.Millisecond * 100)\n\t\t}\n\t}()\n\n\t// Confirm逻辑，确认chargeItem放入队列后，将chargeItem关联的resourceId从未确认map中删除\n\tfor confirm := range t.ChargeItemProducer.Confirm() {\n\t\tt.WG.Add(1)\n\t\tchargeItem := confirm.GetData().(*measure.ChargeItem)\n\t\tif confirm.GetPublishResult() != mq.PUBLISH_RESULT_SUCCESS {\n\t\t\t// 告警出来，后期补量，部分成功不好处理\n\t\t\tlogs.Error(t.ctx).Any(\"chargeItem\", chargeItem).Msg(\"CHARGE_ITEM_PUBLISH_FAILED\")\n\t\t\tcontinue\n\t\t}\n\t\t// 到这里就代表chargeItem已经发送到队列，理论上不会漏推\n\t\t// FIXME 可能会导致重复推量\n\t\tgo func(innerChargeItem *measure.ChargeItem) {\n\t\t\tdefer t.WG.Done()\n\t\t\terr := t.ResSrv.UpdateResBalanceRecords(innerChargeItem.AppId, innerChargeItem)\n\t\t\tif err != nil {\n\t\t\t\tlogs.Error(t.Ctx).Err(err).Uint64(\"appId\", uint64(innerChargeItem.AppId)).\n\t\t\t\t\tStr(\"resourceId\", string(innerChargeItem.ResourceId)).Msg(\"UPDATE_CBS_BALANCE_RECORD_FAILED\")\n\t\t\t}\n\t\t}(chargeItem)\n\t\tt.MarkSingleResDone(chargeItem.AppId, chargeItem.ResourceId)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_rec_task_scanner.go",
        "code_start_line": 39,
        "code_end_line": 41,
        "code_key": "FullScan",
        "code_value": "func (s *CbsMeasureReconciliationTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_rec_task_scanner.go",
        "code_start_line": 37,
        "code_end_line": 39,
        "code_key": "FullScan",
        "code_value": "func (s *SnapMeasureReconciliationTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_compute_task_scanner.go",
        "code_start_line": 39,
        "code_end_line": 41,
        "code_key": "FullScan",
        "code_value": "func (s *SnapComputeTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_measure_send_task_scanner.go",
        "code_start_line": 39,
        "code_end_line": 41,
        "code_key": "FullScan",
        "code_value": "func (s *CbsMeasureSendTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_bill_valid_appId_fetch_task_scanner.go",
        "code_start_line": 39,
        "code_end_line": 41,
        "code_key": "FullScan",
        "code_value": "func (s *CbsValidAppIdFetchTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_calculate_cost_locally_task_scanner.go",
        "code_start_line": 38,
        "code_end_line": 40,
        "code_key": "FullScan",
        "code_value": "func (s *SnapCalculateCostLocallyTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_create_task_scanner.go",
        "code_start_line": 50,
        "code_end_line": 78,
        "code_key": "FullScan",
        "code_value": "func (s *UpdateCreateTaskScanner) FullScan(ctx context.Context) error {\n\tsnapRepo := registry.GetRegistry(ctx).AdapterRepos.SnapRepo.(adapter_interfaces.SnapInterface)\n\tsnapList, err := snapRepo.QueryCreatingCopyingSnapList(ctx)\n\tif err != nil {\n\t\tlogs.Error(ctx).Err(err).Msg(\"FULL_SCAN_FAILED\")\n\t\treturn err\n\t}\n\tresultCnt := 0\n\tfor _, snapRecord := range snapList {\n\t\t// 剔除快照组预生成的快照记录\n\t\tif strings.Contains(snapRecord.SnapUuid, \"temp\") {\n\t\t\tlogs.Info(ctx).Str(\"SnapId\", snapRecord.SnapInstanceId).Msgf(\"PRE_CREATED_SNAPSHOT_SKIP_UPDATE\")\n\t\t\tcontinue\n\t\t}\n\n\t\tentity := &snapLogical.Entity{\n\t\t\tSnapRecord: snapRecord,\n\t\t}\n\t\tsnapAggregate := &snapLogical.SnapCreateTaskAggregate{\n\t\t\tEntity:      entity,\n\t\t\tTaskName:    core.UpdateCreateTask,\n\t\t\tSubTaskName: core.UpdateCreateTask,\n\t\t}\n\t\ts.resultChan <- snapAggregate\n\t\tresultCnt += 1\n\t}\n\ts.resultChanMetric.Add(float64(resultCnt))\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_measure_send_task_scanner.go",
        "code_start_line": 38,
        "code_end_line": 40,
        "code_key": "FullScan",
        "code_value": "func (s *SnapMeasureSendTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/repush_user_billing_task_scanner.go",
        "code_start_line": 41,
        "code_end_line": 43,
        "code_key": "FullScan",
        "code_value": "func (s *RepushUserBillingTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_rollback_task_scanner.go",
        "code_start_line": 103,
        "code_end_line": 113,
        "code_key": "FullScan",
        "code_value": "func (s *UpdateRollbackTaskScanner) FullScan(ctx context.Context) error {\n\tif err := s.getCCbsRollbackTask(ctx); err != nil {\n\t\tlogs.Error(ctx).Err(err).Msg(\"FULL_SCAN_FAILED\")\n\t\treturn err\n\t}\n\tif err := s.getImageSnapRollbackTask(ctx); err != nil {\n\t\tlogs.Error(ctx).Err(err).Msg(\"FULL_SCAN_FAILED\")\n\t\treturn err\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_valid_appId_fetch_task_scanner.go",
        "code_start_line": 38,
        "code_end_line": 40,
        "code_key": "FullScan",
        "code_value": "func (s *SnapValidAppIdFetchTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_bill_compute_task_scanner.go",
        "code_start_line": 41,
        "code_end_line": 43,
        "code_key": "FullScan",
        "code_value": "func (s *CbsBillComputeTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/client/client.go",
        "code_start_line": 20,
        "code_end_line": 62,
        "code_key": "Request",
        "code_value": "func (c *BaseClient) Request(ctx context.Context, interfaceName string, reqJsonData []byte) ([]byte, error) {\n\tlogger := logs.With(ctx).Str(\"interface\", interfaceName).Logger()\n\tlogger.Info().Str(\"para\", string(reqJsonData)).Msg(\"NEW_REQUEST\")\n\n\tctx, cancel := context.WithTimeout(ctx, time.Second*time.Duration(c.Timeout))\n\tdefer cancel()\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPost, c.Url, bytes.NewReader(reqJsonData))\n\n\tif global.TestEnv {\n\t\treq.Header.Add(\"X-QCloud-Transaction-ID\", uuid.New().String())\n\t\treq.Header.Add(\"X-QCloud-User-ID\", global.TestUin)\n\t}\n\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"new request failed: %v\", err)\n\t}\n\theader := \"\"\n\tfor key, value := range req.Header {\n\t\theader += fmt.Sprintf(\"-H \\\"%s: %s\\\" \", key, value[0])\n\t}\n\tcurl := fmt.Sprintf(\"curl %s --connect-timeout %d -d '%s' %s\", header, c.Timeout, string(reqJsonData), c.Url)\n\tlogger.Info().Any(\"cmd\", curl).Msgf(\"SHOW_CURL_CMD\")\n\n\trsp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\tlogger.Error().Err(err).Msgf(\"RESPONSE_ERR\")\n\t\treturn nil, fmt.Errorf(\"do request failed: %v\", err)\n\t}\n\tdefer func(Body io.ReadCloser) {\n\t\t_ = Body.Close()\n\t}(rsp.Body)\n\n\tif rsp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"unexpected status code: %d\", rsp.StatusCode)\n\t}\n\tbodyData, err := io.ReadAll(rsp.Body)\n\tlogger.Info().Any(\"response\", string(bodyData)).Msgf(\"SHOW_RESPONSE\")\n\tif err != nil {\n\t\tlogger.Error().Err(err).Msgf(\"RESPONSE_ERR\")\n\t\treturn nil, err\n\t}\n\treturn bodyData, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go",
        "code_start_line": 83,
        "code_end_line": 103,
        "code_key": "AddTask",
        "code_value": "func (sc *Scheduler) AddTask(ctx context.Context, newTask interfaces.Task) {\n\tvalue, ok := sc.taskMap.Load(newTask.GetTaskId())\n\tif !ok {\n\t\tsc.syncTaskPriorityQueue.Push(newTask)\n\t\tsc.taskMap.Store(newTask.GetTaskId(), newTask)\n\t\tsc.addTimerEvent(newTask.GetTaskId())\n\t\tsc.metrics.taskCountInQueue.Add(1)\n\t} else {\n\t\t// 对于已存在的任务需要判断subTaskName是否发生变化\n\t\t// 存在任务切换的场景，如order -> trigger，需要将旧任务删除，新任务插入\n\t\ttask := value.(interfaces.Task)\n\t\tif task.GetSubTaskName() != newTask.GetSubTaskName() {\n\t\t\tlogs.Info(ctx).Str(\"TaskId\", task.GetTaskId()).Msg(\"FOUND_SUB_TASK_CHANGED\")\n\t\t\t// 更新taskMap中的task记录，并插入优先队列\n\t\t\tsc.taskMap.Store(newTask.GetTaskId(), newTask)\n\t\t\tsc.syncTaskPriorityQueue.Push(newTask)\n\t\t\tsc.addTimerEvent(newTask.GetTaskId())\n\t\t\tsc.metrics.taskCountInQueue.Add(1)\n\t\t}\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go",
        "code_start_line": 120,
        "code_end_line": 131,
        "code_key": "tryGetWorker",
        "code_value": "func (sc *Scheduler) tryGetWorker(ctx context.Context) bool {\n\tsc.mutex.Lock()\n\tdefer sc.mutex.Unlock()\n\n\tif sc.workerNum > 0 {\n\t\tsc.workerNum--\n\t\tsc.wg.Add(1)\n\t\tsc.metrics.idleWorkerNum.Set(float64(sc.workerNum))\n\t\treturn true\n\t}\n\treturn false\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go",
        "code_start_line": 217,
        "code_end_line": 221,
        "code_key": "rePushTask",
        "code_value": "func (sc *Scheduler) rePushTask(ctx context.Context, task interfaces.Task) {\n\tsc.syncTaskPriorityQueue.Push(task)\n\tsc.metrics.taskCountInQueue.Add(1)\n\tsc.addTimerEvent(task.GetTaskId())\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/mq/mqimpl/rabbitMq/producer.go",
        "code_start_line": 71,
        "code_end_line": 96,
        "code_key": "Confirm",
        "code_value": "func (p *Producer) Confirm() <-chan mqiface.IMessage {\n\t/*\n\t\tConfirm主要是用来获取消息的发送结果，并将对象的消息放入channel中\n\t\tconfirm.DeliveryTag是rabbitmq维护的channel级的唯一标识，实际的值来源于channel.published,\n\t\t但是这个变量不对外暴露，所以在publish操作中也维护了一个producer级的published变量，二者值是一致的\n\t*/\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase confirm, ok := <-p.Confirms:\n\t\t\t\tif !ok {\n\t\t\t\t\tlogs.Info(p.Ctx).Msg(\"CONFIRM_CHANNEL_CLOSED\")\n\t\t\t\t\t// 关闭p.confirmedMsgChannel\n\t\t\t\t\tp.wg.Wait()\n\t\t\t\t\tclose(p.confirmedMsgChannel)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tp.wg.Add(1)\n\t\t\t\tgo p.processConfirmation(confirm)\n\t\t\tcase <-p.Ctx.Done():\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}()\n\treturn p.confirmedMsgChannel\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/cmd/rdisk_master/run.go",
        "code_start_line": 63,
        "code_end_line": 80,
        "code_key": "runScheduler",
        "code_value": "func runScheduler(appCtx context.Context, wg *sync.WaitGroup) {\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ts := app.GlobalRegistry.Scheduler\n\t\tsignalChan := make(chan os.Signal, 10)\n\t\tsignal.Notify(signalChan, unix.SIGINT, unix.SIGTERM, unix.SIGSEGV)\n\n\t\tgo func(c chan os.Signal) {\n\t\t\t<-c\n\t\t\ts.Stop()\n\t\t}(signalChan)\n\n\t\tif err := s.Start(appCtx); err != nil {\n\t\t\tlogs.Fatal(appCtx).Err(err).Msg(\"scheduler exited\")\n\t\t}\n\t}()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/cmd/rdisk_master/run.go",
        "code_start_line": 83,
        "code_end_line": 92,
        "code_key": "runApiServer",
        "code_value": "func runApiServer(appCtx context.Context, wg *sync.WaitGroup) {\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ts := apiserver.New(appCtx)\n\t\tif err := s.Serve(); err != nil {\n\t\t\tlogs.Fatal(appCtx).Err(err).Msg(\"server exited\")\n\t\t}\n\t}()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/cmd/rdisk_master/run.go",
        "code_start_line": 172,
        "code_end_line": 182,
        "code_key": "initSchedulers",
        "code_value": "func initSchedulers(ctx context.Context) {\n\tapp.GlobalRegistry.Scheduler = scheduler.New(ctx, app.GlobalRegistry.Locker)\n\n\t// 注册定时任务\n\n\tapp.GlobalRegistry.Scheduler.Add(\"update_backup_task\", &tasks.UpdateBackupTask{})\n\tapp.GlobalRegistry.Scheduler.Add(\"recycle_backup_task\", &tasks.RecycleBackupTask{})\n\tapp.GlobalRegistry.Scheduler.Add(\"update_benchmark_task\", &tasks.UpdateBenchmarkTask{})\n\tapp.GlobalRegistry.Scheduler.Add(\"confirm_init_physicaldisk_task\", &tasks.ConfirmInitPhysicalDiskTask{})\n\tapp.GlobalRegistry.Scheduler.Add(\"cleanup_defunct_task\", &tasks.CleanupDefunctTask{})\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/dispatcher/dispatcher.go",
        "code_start_line": 33,
        "code_end_line": 103,
        "code_key": "Dispatch",
        "code_value": "func (d *dispatcherImpl) Dispatch(ctx context.Context, cmd app.Command) (err error) {\n\t// 为什么使用 backgroundCtx 而不是 ctx？\n\t// 因为 ctx 代表调用方的上下文，通常是 rpc 请求上下文。\n\t// 而执行命令的上下文，应该是一个独立的上下文，不应该受到调用方的影响\n\t// 即使由于网络抖动等原因，调用方的上下文已经超时，但是命令执行的上下文仍然应该继续执行。\n\tworkerCtx := context.WithValue(d.backgroundCtx, ctxKeyCommand, cmd)\n\tworkerCtx, cancelFunc := context.WithTimeout(workerCtx, d.workerTimeout)\n\tworkerCtx = logs.GetLogger(ctx).WithContext(workerCtx)\n\tlockKeys := cmd.LockKeys()\n\terrChan := make(chan error, 1)\n\tlockOption := &dlock.Option{\n\t\tRetryStrategy: dlock.ExponentialBackoff(100*time.Millisecond, 6*time.Second),\n\t}\n\td.wg.Add(1)\n\t// 最终打印错误\n\t// TODO: 并发控制最大能同时执行的命令数量\n\tgo func() {\n\t\tdefer d.wg.Done()\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\te, ok := err.(error)\n\t\t\t\tif !ok {\n\t\t\t\t\te = errors.Newf(ErrDispatchPanic, \"dispatcher panic: %v\", err)\n\t\t\t\t}\n\t\t\t\terrChan <- e\n\t\t\t\tlogs.Error(workerCtx).Err(e).Stack().Bytes(\"trace\", debug.Stack()).Msgf(\"command execution panic\")\n\t\t\t}\n\t\t}()\n\n\t\tdefer cancelFunc()\n\n\t\tif lockKeys != nil {\n\t\t\tlock, err := d.locker.ObtainMulti(workerCtx, lockKeys, d.workerTimeout, lockOption)\n\t\t\tif err != nil {\n\t\t\t\terrChan <- err\n\t\t\t\tlogs.Warn(workerCtx).Err(err).Msgf(\"command execution waiting locks timeout\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer lock.Release(workerCtx)\n\t\t}\n\n\t\tuow := app.GetRegistry(ctx).Repositories.UoWFactory.New()\n\t\tworkerCtx = app.GetRegistry(ctx).Repositories.UoWFactory.With(workerCtx, uow)\n\n\t\terr = cmd.Handle(workerCtx)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, errors.ErrDryRunSuccessExit) {\n\t\t\t\terr = nil\n\t\t\t} else {\n\t\t\t\tlogs.Warn(workerCtx).Err(err).Msgf(\"command execution failed\")\n\t\t\t}\n\t\t\t_err := uow.Rollback(workerCtx)\n\t\t\tif _err != nil {\n\t\t\t\tlogs.Error(workerCtx).Err(_err).Msgf(\"unit of work rollback failed\")\n\t\t\t}\n\t\t} else {\n\t\t\terr = uow.Commit(workerCtx)\n\t\t\tif err != nil {\n\t\t\t\tlogs.Error(workerCtx).Err(err).Msgf(\"unit of work commit failed\")\n\t\t\t}\n\t\t}\n\t\terrChan <- err\n\t\tclose(errChan)\n\t}()\n\tselect {\n\tcase err := <-errChan:\n\t\treturn err\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/scheduler.go",
        "code_start_line": 127,
        "code_end_line": 132,
        "code_key": "Add",
        "code_value": "func (s *scheduler) Add(name string, workload WorkLoad) {\n\ts.mutex.Lock()\n\tdefer s.mutex.Unlock()\n\ts.loads[name] = workload\n\ts.eventChan <- name\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/benchmark.go",
        "code_start_line": 17,
        "code_end_line": 29,
        "code_key": "Add",
        "code_value": "func (repo *rdiskBenchmarkRepositoryImpl) Add(ctx context.Context, bench *benchmark.Benchmark) error {\n\tdo := repo.fromModelToDO(bench)\n\tuow := getUow(ctx)\n\tdo.Created = uow.tx.NowFunc()\n\tdo.Updated = uow.tx.NowFunc()\n\tresult := uow.tx.Create(&do)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tbench.ID = do.ID\n\tuow.trackedBenchmarks.Add(bench)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/backup.go",
        "code_start_line": 19,
        "code_end_line": 31,
        "code_key": "Add",
        "code_value": "func (repo *rdiskBackupRepositoryImpl) Add(ctx context.Context, backup *backupPkg.Backup) error {\n\tuow := getUow(ctx)\n\tdo := repo.fromModelToDO(backup)\n\tdo.Created = uow.tx.NowFunc()\n\tdo.Updated = uow.tx.NowFunc()\n\tresult := uow.tx.Create(&do)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tbackup.ID = do.ID\n\tuow.trackedBackups.Add(backup)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go",
        "code_start_line": 76,
        "code_end_line": 91,
        "code_key": "Add",
        "code_value": "func (l logicalVolumeRepositoryImpl) Add(ctx context.Context, lv *rdiskDomain.LogicalVolume) error {\n\tuow := getUow(ctx)\n\tvol := fromModelToDmRDisk(lv)\n\tvol.Created = uow.tx.NowFunc()\n\tvol.Updated = uow.tx.NowFunc()\n\tresult := uow.tx.Create(&vol)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tlv.ID = vol.ID\n\tlv = uow.trackedLogicalVolumes.Add(lv)\n\tif lv.PhysicalVolume != nil {\n\t\tlv.PhysicalVolume = uow.trackedPhyVolumes.Add(lv.PhysicalVolume)\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/uow.go",
        "code_start_line": 23,
        "code_end_line": 30,
        "code_key": "Add",
        "code_value": "func (c *changeTracker[T]) Add(item T) T {\n\tif v, ok := c.items[item.GetID()]; ok {\n\t\treturn v\n\t}\n\tc.items[item.GetID()] = item\n\tc.originalStates[item.GetID()] = item.DeepCopy().(T)\n\treturn item\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go",
        "code_start_line": 59,
        "code_end_line": 71,
        "code_key": "Add",
        "code_value": "func (p *physicalVolumeRepositoryImpl) Add(ctx context.Context, pv *rdiskDomain.PhysicalVolume) error {\n\tuow := getUow(ctx)\n\tvol := fromPhysicalVolumeToDmPhyDisk(ctx, pv)\n\tvol.Created = uow.tx.NowFunc()\n\tvol.Updated = uow.tx.NowFunc()\n\tresult := uow.tx.Create(&vol)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tpv.ID = vol.ID\n\tuow.trackedPhyVolumes.Add(pv)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
        "code_start_line": 96,
        "code_end_line": 108,
        "code_key": "Add",
        "code_value": "func (d drgroupRepositoryImpl) Add(ctx context.Context, group *drgroup.DRGroup) error {\n\tuow := getUow(ctx)\n\tdo := fromModelToDmDRGroup(group)\n\tdo.Created = uow.tx.NowFunc()\n\tdo.Updated = uow.tx.NowFunc()\n\tresult := uow.tx.Clauses(clause.Insert{Modifier: \"IGNORE\"}).Create(&do)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tgroup.ID = do.ID\n\tuow.trackedDRGroups.Add(group)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 41,
        "code_end_line": 46,
        "code_key": "Add",
        "code_value": "func (m *MockLogicalVolumeRepository) Add(arg0 context.Context, arg1 *rdiskDomain.LogicalVolume) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Add\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 49,
        "code_end_line": 52,
        "code_key": "Add",
        "code_value": "func (mr *MockLogicalVolumeRepositoryMockRecorder) Add(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Add\", reflect.TypeOf((*MockLogicalVolumeRepository)(nil).Add), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 40,
        "code_end_line": 45,
        "code_key": "Add",
        "code_value": "func (m *MockPhysicalVolumeRepository) Add(arg0 context.Context, arg1 *rdiskDomain.PhysicalVolume) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Add\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 48,
        "code_end_line": 51,
        "code_key": "Add",
        "code_value": "func (mr *MockPhysicalVolumeRepositoryMockRecorder) Add(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Add\", reflect.TypeOf((*MockPhysicalVolumeRepository)(nil).Add), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 40,
        "code_end_line": 45,
        "code_key": "Add",
        "code_value": "func (m *MockRepository) Add(arg0 context.Context, arg1 *drgroup.DRGroup) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Add\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 48,
        "code_end_line": 51,
        "code_key": "Add",
        "code_value": "func (mr *MockRepositoryMockRecorder) Add(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Add\", reflect.TypeOf((*MockRepository)(nil).Add), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 763,
        "code_end_line": 781,
        "code_key": "initCustomErrorHandler",
        "code_value": "func initCustomErrorHandler() {\n\tdefaultHandler := thttp.DefaultServerCodec.ErrHandler\n\tthttp.DefaultServerCodec.ErrHandler = func(w http.ResponseWriter, r *http.Request, e *errs.Error) {\n\t\t// Add custom error message to response body\n\t\tbody := errBody{\n\t\t\tCode: e.Code,\n\t\t\tMsg:  e.Msg,\n\t\t}\n\t\tbodyData, err := json.Marshal(body)\n\t\tif err != nil {\n\t\t\t// Should never happen\n\t\t\tpanic(err)\n\t\t}\n\n\t\tw.Header().Add(\"Content-Length\", strconv.Itoa(len(bodyData)))\n\t\tdefaultHandler(w, r, e)\n\t\tw.Write(bodyData)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_drgroup.go",
        "code_start_line": 176,
        "code_end_line": 198,
        "code_key": "getOrCreateDRGroup",
        "code_value": "func (c *UpdateLogicalVolumeDRGroupCommand) getOrCreateDRGroup(ctx context.Context, drgRepo drgroup.Repository, spec *drgroup.Spec) (*drgroup.DRGroup, error) {\n\tgroup, err := drgRepo.FindByName(ctx, c.AppID, spec.Name)\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\tgroup = drgroup.New(spec.Name, c.AppID)\n\t\t\tif spec.Affinity > 0 {\n\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t}\n\t\t\tif spec.Type != \"\" {\n\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t}\n\t\t\tif !c.DryRun {\n\t\t\t\terr := drgRepo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn group, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/attach_detach.go",
        "code_start_line": 247,
        "code_end_line": 297,
        "code_key": "UpdateFlowControlOnAllInitiator",
        "code_value": "func UpdateFlowControlOnAllInitiator(ctx context.Context, source rdiskDomain.LogicalVolumeState,\n\ttarget rdiskDomain.LogicalVolumeState, stateCtx app.LogicalVolumeContext) (state rdiskDomain.LogicalVolumeState, err error) {\n\n\tlv := stateCtx.GetLogicalVolume()\n\tif len(lv.Attachments) == 0 {\n\t\tlogs.Info(ctx).Str(\"uuid\", lv.UUID.String()).Msg(\"no attachment found, skip update flow control\")\n\t\treturn target, nil\n\t}\n\n\tvar wg sync.WaitGroup\n\tvar collectedErr []error = make([]error, len(lv.Attachments))\n\n\twg.Add(len(lv.Attachments))\n\n\tfor idx, attachment := range lv.Attachments {\n\t\tgo func(idx int, attachment *rdiskDomain.VolumeAttachment) {\n\t\t\tdefer wg.Done()\n\n\t\t\tblk := app.GetRegistry(ctx).Factories.BlockAgentClient(attachment.IP.String())\n\t\t\treq := cbs_blk_flow_agent.NewUpdateRDiskFlowControlRequest(lv.UUID.String(), lv.PhysicalVolume.DiskID)\n\t\t\treq.SpdkDriver = attachment.Options.SPDKDriver\n\t\t\treq.SetRead(attachment.FlowControlSpec.MaxReadIOPS, attachment.FlowControlSpec.MaxReadMBps)\n\t\t\treq.SetWrite(attachment.FlowControlSpec.MaxWriteIOPS, attachment.FlowControlSpec.MaxWriteMBps)\n\t\t\treq.SetReadWrite(attachment.FlowControlSpec.MaxRWIOPS, attachment.FlowControlSpec.MaxRWMBps)\n\n\t\t\terr = blk.UpdateRDiskFlowControl(ctx, req)\n\t\t\tif err != nil {\n\t\t\t\tlogs.Error(ctx).Err(err).Str(\"ip\", attachment.IP.String()).Msg(\"failed to update flow control\")\n\t\t\t}\n\t\t\tcollectedErr[idx] = err\n\t\t}(idx, attachment)\n\t}\n\n\twg.Wait()\n\n\t// collect error ip and print error count\n\tvar errList []error\n\tvar errIPs []string\n\tfor idx, err := range collectedErr {\n\t\tif err != nil {\n\t\t\terrList = append(errList, err)\n\t\t\terrIPs = append(errIPs, lv.Attachments[idx].IP.String())\n\t\t}\n\t}\n\tif len(errList) > 0 {\n\t\tlogs.Warn(ctx).Errs(\"errors\", errList).Strs(\"host_ips\", errIPs).Msg(\"failed to update flow control on some initiators\")\n\t\treturn source, errors.New(rdiskDomain.ErrUpdateFlowControl, fmt.Sprintf(\"failed to update flow control on some initiators: %v, errors: %v\", errIPs, errList))\n\t}\n\n\treturn target, err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/drgroups.go",
        "code_start_line": 22,
        "code_end_line": 71,
        "code_key": "AddHostToDRGroup",
        "code_value": "func AddHostToDRGroup(ctx context.Context, source rdiskDomain.LogicalVolumeState, target rdiskDomain.LogicalVolumeState, stateCtx app.LogicalVolumeContext) (rdiskDomain.LogicalVolumeState, error) {\n\tdata := stateCtx.(CreateLogicalVolumeContext)\n\tvol := data.GetLogicalVolume()\n\tphy := data.GetPhysicalVolume()\n\tspecs := data.GetDRGroupSpecList()\n\trepo := app.GetRegistry(ctx).Repositories.DRGroup\n\tif len(specs) == 0 {\n\t\treturn target, nil\n\t}\n\tfor _, spec := range specs {\n\t\tgroup, err := repo.FindByName(ctx, vol.AppID, spec.Name)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\tgroup = drgroup.New(spec.Name, vol.AppID)\n\t\t\t\tif spec.Affinity > 0 {\n\t\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t\t}\n\t\t\t\tif spec.Type != \"\" {\n\t\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t\t}\n\t\t\t\terr = repo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn source, err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn source, err\n\t\t\t}\n\t\t}\n\t\tif spec.Affinity > 0 && group.Affinity != spec.Affinity {\n\t\t\tlogs.Info(ctx).Uint64(\"app_id\", uint64(vol.AppID)).\n\t\t\t\tStr(\"group_name\", spec.Name).\n\t\t\t\tInt(\"old_affinity\", group.Affinity).\n\t\t\t\tInt(\"new_affinity\", spec.Affinity).\n\t\t\t\tMsg(\"update affinity of drgroup\")\n\t\t\tgroup.Affinity = spec.Affinity\n\t\t}\n\t\tsubGroup := spec.SubGroup\n\t\tif subGroup == \"\" {\n\t\t\t// 如果没有指定子组，则使用远端 SSD UUID 作为子组名称\n\t\t\t// 相当于每块盘都是一个子组，相当于没有使用子组功能\n\t\t\tsubGroup = vol.UUID.String()\n\t\t}\n\t\terr = group.AddMember(vol.UUID.String(), subGroup, phy.IP.String())\n\t\tif err != nil {\n\t\t\treturn source, err\n\t\t}\n\t}\n\n\treturn target, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/create_phy_disk.go",
        "code_start_line": 32,
        "code_end_line": 70,
        "code_key": "CreatePhysicalVolumeInRepository",
        "code_value": "func CreatePhysicalVolumeInRepository(ctx context.Context, source rdiskDomain.PhysicalVolumeState, target rdiskDomain.PhysicalVolumeState, stateCtx app.PhysicalVolumeContext) (rdiskDomain.PhysicalVolumeState, error) {\n\tcreateCtx := stateCtx.(CreatePhysicalVolumeContext)\n\tphysicalVolume := createCtx.GetPhysicalVolume()\n\tspec := createCtx.GetSpec()\n\tif err := rdiskDomain.CheckSerial(spec.Serial); err != nil {\n\t\treturn source, err\n\t}\n\tif physicalVolume != nil {\n\t\t*physicalVolume = *rdiskDomain.NewPhysicalVolume(spec.Serial, spec.IP, spec.BDF, spec.Size, spec.ZoneID, spec.Cuf)\n\t} else {\n\t\tphysicalVolume = rdiskDomain.NewPhysicalVolume(spec.Serial, spec.IP, spec.BDF, spec.Size, spec.ZoneID, spec.Cuf)\n\t}\n\tphysicalVolume.DataNodeType = spec.DataTypeNode\n\tif spec.VolumeType != \"\" {\n\t\tphysicalVolume.VolumeType = spec.VolumeType\n\t}\n\tif spec.PerformanceRank != \"\" {\n\t\tphysicalVolume.PerformanceRank = spec.PerformanceRank\n\t\tif !physicalVolume.PerformanceRank.IsValid() {\n\t\t\treturn source, errors.Newf(rdiskDomain.ErrInvalidPerformanceRank, \"invalid performance rank %s\", spec.PerformanceRank)\n\t\t}\n\t}\n\tphysicalVolume.State = target\n\tlogs.Info(ctx).\n\t\tStr(\"host_ip\", physicalVolume.IP.String()).\n\t\tStr(\"bdf\", string(physicalVolume.BDF)).\n\t\tStr(\"serial\", string(physicalVolume.Serial)).\n\t\tInt(\"zone_id\", int(physicalVolume.ZoneID)).\n\t\tStr(\"volume_type\", string(physicalVolume.VolumeType)).\n\t\tStr(\"cuf\", string(physicalVolume.Cuf)).\n\t\tStr(\"performance_rank\", string(physicalVolume.PerformanceRank)).\n\t\tMsg(\"created physical volume\")\n\n\terr := app.GetRegistry(ctx).Repositories.PhysicalVolume.Add(ctx, physicalVolume)\n\tif err != nil {\n\t\treturn source, err\n\t}\n\treturn target, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 214,
        "code_end_line": 239,
        "code_key": "StepGivenAPhysicalVol",
        "code_value": "func StepGivenAPhysicalVol(registry *app.Registry, value interface{}) *rdiskDomain.PhysicalVolume {\n\tphysicalVol := &rdiskDomain.PhysicalVolume{\n\t\tEntityMixin:  rdiskDomain.EntityMixin{ID: 1},\n\t\tSerial:       \"12345\",\n\t\tIP:           net.IP{127, 0, 0, 1},\n\t\tBDF:          \"bdf\",\n\t\tDiskID:       0,\n\t\tState:        rdiskDomain.PhysicalVolumeState(value.(int)),\n\t\tSize:         1,\n\t\tVolumeType:   \"NVME\",\n\t\tZoneID:       1,\n\t\tBlockSize:    512,\n\t\tRealSize:     5120,\n\t\tPort:         1,\n\t\tDataNodeType: \"unknown\",\n\t\tCuf:          \"清远-清新-C2\",\n\t}\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\terr := registry.Repositories.PhysicalVolume.Add(workerCtx, physicalVol)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn physicalVol\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 244,
        "code_end_line": 277,
        "code_key": "StepGivenPhysicalVols",
        "code_value": "func StepGivenPhysicalVols(registry *app.Registry, value interface{}, num interface{}) []*rdiskDomain.PhysicalVolume {\n\tvar physicalVols []*rdiskDomain.PhysicalVolume\n\tfor i := 0; i < num.(int); i++ {\n\t\tphysicalVols = append(physicalVols, &rdiskDomain.PhysicalVolume{\n\t\t\tEntityMixin:  rdiskDomain.EntityMixin{},\n\t\t\tSerial:       rdiskDomain.Serial(\"111\" + strconv.Itoa(i)),\n\t\t\tIP:           net.IP{127, 0, byte(((i + 2) / 255) % 255), byte((i + 2) % 255)},\n\t\t\tBDF:          \"bdf\",\n\t\t\tDiskID:       0,\n\t\t\tState:        rdiskDomain.PhysicalVolumeState(value.(int)),\n\t\t\tSize:         1,\n\t\t\tVolumeType:   \"\",\n\t\t\tZoneID:       1,\n\t\t\tBlockSize:    512,\n\t\t\tRealSize:     5120,\n\t\t\tPort:         1,\n\t\t\tDataNodeType: \"\",\n\t\t\tCuf:          \"清远-清新-C2\",\n\t\t})\n\t}\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\tfor _, vol := range physicalVols {\n\t\terr := registry.Repositories.PhysicalVolume.Add(workerCtx, vol)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\terr := uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn physicalVols\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 282,
        "code_end_line": 304,
        "code_key": "StepGivenALogicalVol",
        "code_value": "func StepGivenALogicalVol(registry *app.Registry, physicalVol *rdiskDomain.PhysicalVolume, value interface{}) *rdiskDomain.LogicalVolume {\n\tlogicalVol := &rdiskDomain.LogicalVolume{\n\t\tEntityMixin:     rdiskDomain.EntityMixin{ID: 1},\n\t\tUUID:            uuid.Must(uuid.NewRandom()),\n\t\tState:           rdiskDomain.LogicalVolumeState(value.(int)),\n\t\tSize:            1,\n\t\tAppID:           123,\n\t\tZoneID:          1,\n\t\tDiskType:        \"\",\n\t\tVolumeType:      \"\",\n\t\tFlowControlSpec: rdiskDomain.FlowControlSpec{},\n\t\tPhysicalVolume:  physicalVol,\n\t\tAttachments:     nil,\n\t}\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\terr := registry.Repositories.LogicalVolume.Add(workerCtx, logicalVol)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn logicalVol\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 527,
        "code_end_line": 564,
        "code_key": "StepWhenCreateSomeRDiskVol",
        "code_value": "func StepWhenCreateSomeRDiskVol(ctx context.Context, req interface{}) {\n\trequests := req.([]*pb.CreateRDiskVolRequest)\n\n\t// 创建一个 WaitGroup\n\tvar wg sync.WaitGroup\n\t// 创建一个通道来接收结果\n\tresults := make(chan *pb.CreateRDiskVolResponse, len(requests))\n\terrors := make(chan error, len(requests))\n\n\t// 创建一个 API 服务器实例\n\tapiServer := apiserver.NewMasterApiServer()\n\n\tstart := time.Now()\n\t// 遍历请求列表并启动 goroutine 发送请求\n\tfor _, req := range requests {\n\t\twg.Add(1)\n\t\tgo func(req *pb.CreateRDiskVolRequest) {\n\t\t\tdefer wg.Done()\n\t\t\trsp, err := apiServer.CreateRDiskVol(ctx, req)\n\t\t\tif err != nil {\n\t\t\t\terrors <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\tresults <- rsp\n\t\t}(req)\n\t}\n\n\t// 等待所有 goroutines 完成\n\twg.Wait()\n\tclose(results)\n\tclose(errors)\n\tfmt.Println(\"time:\", time.Since(start))\n\ttime.Sleep(2 * time.Second)\n\t// 处理错误\n\tfor err := range errors {\n\t\tfmt.Println(\"Error:\", err)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/benchmark.go",
        "code_start_line": 42,
        "code_end_line": 50,
        "code_key": "FindByUUID",
        "code_value": "func (repo *rdiskBenchmarkRepositoryImpl) FindByUUID(ctx context.Context, uuid string) (*benchmark.Benchmark, error) {\n\tuow := getUow(ctx)\n\tb := &metadb.DmRdiskBenchmark{}\n\tresult := uow.tx.First(b, \"uuid = ?\", uuid)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\treturn uow.trackedBenchmarks.Add(repo.fromDoToModel(b)), nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/backup.go",
        "code_start_line": 44,
        "code_end_line": 53,
        "code_key": "FindByUUID",
        "code_value": "func (impl *rdiskBackupRepositoryImpl) FindByUUID(ctx context.Context, uuid string) (*backupPkg.Backup, error) {\n\tuow := getUow(ctx)\n\n\tb := &metadb.DmRdiskBackup{}\n\tresult := uow.tx.First(b, \"uuid = ?\", uuid)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\treturn uow.trackedBackups.Add(impl.fromDOToModel(b)), nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go",
        "code_start_line": 22,
        "code_end_line": 47,
        "code_key": "FindByAppIDAndUUID",
        "code_value": "func (logicalVolumeRepositoryImpl) FindByAppIDAndUUID(ctx context.Context, appID users.AppID, id uuid.UUID) (*rdiskDomain.LogicalVolume, error) {\n\tuow := getUow(ctx)\n\tvol := metadb.DmRdisk{}\n\tresult := uow.tx.\n\t\tPreload(\"Attachments\").\n\t\tPreload(\"DmPhyDisk\").\n\t\tFirst(&vol, \"uuid = ? AND app_id = ?\", id.String(), appID)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tlv, err := fromDmRDiskToModel(ctx, &vol)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlv = uow.trackedLogicalVolumes.Add(lv)\n\tif lv.PhysicalVolume != nil {\n\t\tlv.PhysicalVolume = uow.trackedPhyVolumes.Add(lv.PhysicalVolume)\n\t}\n\treturn lv, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 55,
        "code_end_line": 61,
        "code_key": "FindByAppIDAndUUID",
        "code_value": "func (m *MockLogicalVolumeRepository) FindByAppIDAndUUID(arg0 context.Context, arg1 users.AppID, arg2 uuid.UUID) (*rdiskDomain.LogicalVolume, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByAppIDAndUUID\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(*rdiskDomain.LogicalVolume)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 64,
        "code_end_line": 67,
        "code_key": "FindByAppIDAndUUID",
        "code_value": "func (mr *MockLogicalVolumeRepositoryMockRecorder) FindByAppIDAndUUID(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByAppIDAndUUID\", reflect.TypeOf((*MockLogicalVolumeRepository)(nil).FindByAppIDAndUUID), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go",
        "code_start_line": 49,
        "code_end_line": 74,
        "code_key": "FindByID",
        "code_value": "func (l logicalVolumeRepositoryImpl) FindByID(ctx context.Context, id uuid.UUID) (*rdiskDomain.LogicalVolume, error) {\n\tuow := getUow(ctx)\n\tvol := metadb.DmRdisk{}\n\tresult := uow.tx.\n\t\tPreload(\"Attachments\").\n\t\tPreload(\"DmPhyDisk\").\n\t\tFirst(&vol, \"uuid = ?\", id.String())\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tlv, err := fromDmRDiskToModel(ctx, &vol)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlv = uow.trackedLogicalVolumes.Add(lv)\n\tif lv.PhysicalVolume != nil {\n\t\tlv.PhysicalVolume = uow.trackedPhyVolumes.Add(lv.PhysicalVolume)\n\t}\n\treturn lv, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 70,
        "code_end_line": 76,
        "code_key": "FindByID",
        "code_value": "func (m *MockLogicalVolumeRepository) FindByID(arg0 context.Context, arg1 uuid.UUID) (*rdiskDomain.LogicalVolume, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByID\", arg0, arg1)\n\tret0, _ := ret[0].(*rdiskDomain.LogicalVolume)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 79,
        "code_end_line": 82,
        "code_key": "FindByID",
        "code_value": "func (mr *MockLogicalVolumeRepositoryMockRecorder) FindByID(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByID\", reflect.TypeOf((*MockLogicalVolumeRepository)(nil).FindByID), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go",
        "code_start_line": 21,
        "code_end_line": 38,
        "code_key": "FindBySerial",
        "code_value": "func (p *physicalVolumeRepositoryImpl) FindBySerial(ctx context.Context, serial rdiskDomain.Serial) (*rdiskDomain.PhysicalVolume, error) {\n\tuow := getUow(ctx)\n\tvar vol metadb.DmPhydisk\n\tresult := uow.tx.Where(\"serial = ?\", string(serial)).First(&vol)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\t// 覆盖 gorm 的错误\n\t\t\treturn nil, errors.New(rdiskDomain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tpv := fromDmPhyDiskToPhysicalVolume(ctx, &vol)\n\tpv = uow.trackedPhyVolumes.Add(pv)\n\treturn pv, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 83,
        "code_end_line": 89,
        "code_key": "FindBySerial",
        "code_value": "func (m *MockPhysicalVolumeRepository) FindBySerial(arg0 context.Context, arg1 rdiskDomain.Serial) (*rdiskDomain.PhysicalVolume, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindBySerial\", arg0, arg1)\n\tret0, _ := ret[0].(*rdiskDomain.PhysicalVolume)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 92,
        "code_end_line": 95,
        "code_key": "FindBySerial",
        "code_value": "func (mr *MockPhysicalVolumeRepositoryMockRecorder) FindBySerial(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindBySerial\", reflect.TypeOf((*MockPhysicalVolumeRepository)(nil).FindBySerial), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go",
        "code_start_line": 40,
        "code_end_line": 57,
        "code_key": "FindByIPAndBDF",
        "code_value": "func (p *physicalVolumeRepositoryImpl) FindByIPAndBDF(ctx context.Context, ip net.IP, bdf rdiskDomain.BDF) (*rdiskDomain.PhysicalVolume, error) {\n\tuow := getUow(ctx)\n\tvar vol metadb.DmPhydisk\n\tresult := uow.tx.Where(\"host_ip = ? AND bdf = ?\", ip.String(), string(bdf)).Find(&vol)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\t// 覆盖 gorm 的错误\n\t\t\treturn nil, errors.New(rdiskDomain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tpv := fromDmPhyDiskToPhysicalVolume(ctx, &vol)\n\tpv = uow.trackedPhyVolumes.Add(pv)\n\treturn pv, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 68,
        "code_end_line": 74,
        "code_key": "FindByIPAndBDF",
        "code_value": "func (m *MockPhysicalVolumeRepository) FindByIPAndBDF(arg0 context.Context, arg1 net.IP, arg2 rdiskDomain.BDF) (*rdiskDomain.PhysicalVolume, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByIPAndBDF\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(*rdiskDomain.PhysicalVolume)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 77,
        "code_end_line": 80,
        "code_key": "FindByIPAndBDF",
        "code_value": "func (mr *MockPhysicalVolumeRepositoryMockRecorder) FindByIPAndBDF(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByIPAndBDF\", reflect.TypeOf((*MockPhysicalVolumeRepository)(nil).FindByIPAndBDF), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
        "code_start_line": 31,
        "code_end_line": 52,
        "code_key": "FindByNames",
        "code_value": "func (d drgroupRepositoryImpl) FindByNames(ctx context.Context, appId users.AppID, names []string) ([]*drgroup.DRGroup, error) {\n\tuow := getUow(ctx)\n\tgroup := []metadb.DmDrgroup{}\n\tresult := uow.tx.\n\t\tPreload(\"Members\").\n\t\tFind(&group, \"app_id = ? and name in ?\", appId, names)\n\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"disaster recovery group not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tresults := make([]*drgroup.DRGroup, len(group))\n\tfor i := range group {\n\t\tresults[i] = uow.trackedDRGroups.Add(fromDmDRGroupToModel(&group[i]))\n\t}\n\treturn results, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 113,
        "code_end_line": 119,
        "code_key": "FindByNames",
        "code_value": "func (m *MockRepository) FindByNames(arg0 context.Context, arg1 users.AppID, arg2 []string) ([]*drgroup.DRGroup, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByNames\", arg0, arg1, arg2)\n\tret0, _ := ret[0].([]*drgroup.DRGroup)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 122,
        "code_end_line": 125,
        "code_key": "FindByNames",
        "code_value": "func (mr *MockRepositoryMockRecorder) FindByNames(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByNames\", reflect.TypeOf((*MockRepository)(nil).FindByNames), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
        "code_start_line": 58,
        "code_end_line": 94,
        "code_key": "FindByMembers",
        "code_value": "func (d drgroupRepositoryImpl) FindByMembers(ctx context.Context, appId users.AppID, members []string) ([]*drgroup.DRGroup, error) {\n\tuow := getUow(ctx)\n\tgroup := []metadb.DmDrgroup{}\n\n\tmembersResult := []metadb.DmDrgroupMembers{}\n\tresult := uow.tx.\n\t\tFind(&membersResult, \"app_id = ? and member_id in ?\", appId, members)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tnames := make([]string, 0, len(members))\n\tfor i := range membersResult {\n\t\tnames = append(names, membersResult[i].GroupName)\n\t}\n\tresult = uow.tx.\n\t\tPreload(\"Members\").\n\t\tFind(&group, \"app_id = ? and name in ?\", appId, names)\n\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"disaster recovery group not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tresults := make([]*drgroup.DRGroup, len(group))\n\tfor i := range group {\n\t\tresults[i] = fromDmDRGroupToModel(&group[i])\n\t\tresults[i] = uow.trackedDRGroups.Add(results[i])\n\t}\n\treturn results, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/drgroup.go",
        "code_start_line": 92,
        "code_end_line": 124,
        "code_key": "FindByMembers",
        "code_value": "func (d *drgroupViewerImpl) FindByMembers(ctx context.Context, appId users.AppID, members []string) ([]*drgroup.View, error) {\n\tvar (\n\t\tresultViews       []drgroup.View\n\t\tresultViewRef     []*drgroup.View\n\t\tdataObjects       []*metadb.DmDrgroup\n\t\tdataObjectMembers []*metadb.DmDrgroupMembers\n\t)\n\tresult := d.db.WithContext(ctx).Find(&dataObjectMembers, \"app_id = ? and member_id in ?\", appId, members)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"group not exist\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tgroupNames := make([]string, len(dataObjectMembers))\n\tfor i := range dataObjectMembers {\n\t\tgroupNames[i] = dataObjectMembers[i].GroupName\n\t}\n\tresult = d.db.WithContext(ctx).Find(&dataObjects, \"app_id = ? and name in ?\", appId, groupNames)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"group not exist\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tresultViews = make([]drgroup.View, len(dataObjects))\n\tresultViewRef = make([]*drgroup.View, len(dataObjects))\n\tfor i := range dataObjects {\n\t\tresultViewRef[i] = &resultViews[i]\n\t\td.translate(dataObjects[i], resultViewRef[i])\n\t}\n\treturn resultViewRef, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 83,
        "code_end_line": 89,
        "code_key": "FindByMembers",
        "code_value": "func (m *MockRepository) FindByMembers(arg0 context.Context, arg1 users.AppID, arg2 []string) ([]*drgroup.DRGroup, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByMembers\", arg0, arg1, arg2)\n\tret0, _ := ret[0].([]*drgroup.DRGroup)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 92,
        "code_end_line": 95,
        "code_key": "FindByMembers",
        "code_value": "func (mr *MockRepositoryMockRecorder) FindByMembers(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByMembers\", reflect.TypeOf((*MockRepository)(nil).FindByMembers), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/view.go",
        "code_start_line": 55,
        "code_end_line": 61,
        "code_key": "FindByMembers",
        "code_value": "func (m *MockViewer) FindByMembers(arg0 context.Context, arg1 users.AppID, arg2 []string) ([]*drgroup.View, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByMembers\", arg0, arg1, arg2)\n\tret0, _ := ret[0].([]*drgroup.View)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/view.go",
        "code_start_line": 64,
        "code_end_line": 67,
        "code_key": "FindByMembers",
        "code_value": "func (mr *MockViewerMockRecorder) FindByMembers(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByMembers\", reflect.TypeOf((*MockViewer)(nil).FindByMembers), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 178,
        "code_end_line": 233,
        "code_key": "updateReadLocks",
        "code_value": "func (l *mysqlLocker) updateReadLocks(tx *gorm.DB, ttl time.Duration, keys []string, lockTokens []string) ([]string, []string, []string, error) {\n\tif len(keys) == 0 {\n\t\treturn nil, nil, lockTokens, nil\n\t}\n\ttype Result struct {\n\t\tLock       string\n\t\tExpiration time.Time\n\t\tToken      string\n\t}\n\tvar Results []Result\n\terr := tx.Raw(\"SELECT `\"+l.lockColumn+\"` AS `lock`, `\"+l.expireColumn+\"` AS `expiration`, `\"+l.tokenColumn+\"` AS `token` FROM \"+l.tableName+\" WHERE `\"+l.lockColumn+\"` IN (?)\", keys).Scan(&Results).Error\n\tif err != nil {\n\t\treturn nil, nil, nil, errors.Wrap(err, \"fail to query locks\")\n\t}\n\n\tvar needUpdateExpirationReadKeys []string = nil\n\tvar needUpdateCountReadKeys []string = nil\n\tl.mutex.Lock()\n\tt := time.Now()\n\tfor _, r := range Results {\n\t\tif r.Token != lockTokens[0] {\n\t\t\tlockTokens = append(lockTokens, r.Token)\n\t\t}\n\t\tif readKey, exist := l.readKeysMemLock[r.Lock]; exist {\n\t\t\treadKey.count++\n\t\t\treadKey.expiration = r.Expiration\n\t\t} else {\n\t\t\tl.readKeysMemLock[r.Lock] = &readKeysMemLock{\n\t\t\t\tcount:      1,\n\t\t\t\texpiration: r.Expiration,\n\t\t\t\ttoken:      r.Token,\n\t\t\t}\n\t\t\tneedUpdateCountReadKeys = append(needUpdateCountReadKeys, r.Lock)\n\t\t}\n\t\tif l.readKeysMemLock[r.Lock].expiration.Sub(t) < ttl/3 {\n\t\t\tl.readKeysMemLock[r.Lock].expiration = t.Add(ttl)\n\t\t\tneedUpdateExpirationReadKeys = append(needUpdateExpirationReadKeys, r.Lock)\n\t\t}\n\t}\n\tl.mutex.Unlock()\n\tif len(needUpdateExpirationReadKeys) > 0 {\n\t\tresult := tx.Exec(\"UPDATE \"+l.tableName+\" SET \"+l.expireColumn+\" = NOW() + INTERVAL ? SECOND WHERE `\"+l.lockColumn+\"` IN (?)\", ttl.Seconds(), needUpdateExpirationReadKeys)\n\t\tif result.Error != nil {\n\t\t\treturn nil, needUpdateExpirationReadKeys, needUpdateCountReadKeys, errors.Wrap(result.Error, fmt.Sprintf(\"failed to update readLocks: %s\", keys))\n\t\t}\n\t}\n\n\tif len(needUpdateCountReadKeys) > 0 {\n\t\tresult := tx.Exec(\"UPDATE \"+l.tableName+\" SET \"+l.lockNumsColumn+\" = \"+l.lockNumsColumn+\" + 1 WHERE `\"+l.lockColumn+\"` IN (?)\", needUpdateCountReadKeys)\n\t\tif result.Error != nil {\n\t\t\treturn nil, needUpdateExpirationReadKeys, needUpdateCountReadKeys, errors.Wrap(result.Error, fmt.Sprintf(\"failed to update readLocks: %s\", keys))\n\t\t}\n\t}\n\n\treturn nil, nil, lockTokens, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 335,
        "code_end_line": 369,
        "code_key": "insertLocks",
        "code_value": "func (l *mysqlLocker) insertLocks(tx *gorm.DB, lockKeys []*dlock.LockKey, ttl time.Duration, lockToken []string) ([]string, error) {\n\tif len(lockKeys) <= 0 {\n\t\treturn nil, nil\n\t}\n\tstmt := strings.Builder{}\n\targs := make([]interface{}, 0, len(lockKeys)*5)\n\tt := time.Now().Add(ttl)\n\tstmt.WriteString(fmt.Sprintf(\"INSERT INTO `%s` (`%s`, `%s`, `%s`, `%s`, `%s`) VALUES \", l.tableName, l.lockColumn, l.expireColumn, l.tokenColumn, l.lockTypeColumn, l.lockNumsColumn))\n\tfor i, key := range lockKeys {\n\t\tif i > 0 {\n\t\t\tstmt.WriteString(\", \")\n\t\t}\n\t\tstmt.WriteString(\"(?, NOW() + INTERVAL ? SECOND, ?, ?, ?)\")\n\t\targs = append(args, key.Key, ttl.Seconds(), lockToken[0], int(key.Type), 1)\n\t}\n\n\tresult := tx.Exec(stmt.String(), args...)\n\tif result.Error != nil {\n\t\treturn nil, errors.Wrap(result.Error, \"failed to insert locks\")\n\t}\n\tvar needInsertReadKeys []string = nil\n\tl.mutex.Lock()\n\tfor _, key := range lockKeys {\n\t\tif key.Type == dlock.ReadLock {\n\t\t\tl.readKeysMemLock[key.Key] = &readKeysMemLock{\n\t\t\t\tcount:      1,\n\t\t\t\texpiration: t,\n\t\t\t\ttoken:      lockToken[0],\n\t\t\t}\n\t\t\tneedInsertReadKeys = append(needInsertReadKeys, key.Key)\n\t\t}\n\t}\n\tl.mutex.Unlock()\n\treturn needInsertReadKeys, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 417,
        "code_end_line": 470,
        "code_key": "tryObtainMulti",
        "code_value": "func (l *mysqlLocker) tryObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, tokens []string, opts *dlock.Option) ([]string, error) {\n\t// Starts a new transaction.\n\ttx := l.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\n\n\t// Fetch existing locks.\n\texistingReadKeys, existingWriteKeys, expiredKeys, err := l.fetchExistingLocks(tx, keys)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// If there are existing valid locks, return an error.\n\tif len(existingWriteKeys) > 0 {\n\t\t_ = tx.Rollback()\n\t\treturn nil, errors.Wrap(dlock.ErrLockNotHeld, fmt.Sprintf(\"writeKeys %v are already locked\", existingWriteKeys))\n\t}\n\n\t// Delete expired locks if exists.\n\tif err := l.deleteExpiredLocks(tx, expiredKeys); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Remove existing readLocks from insert.\n\t// NOCA:QCloudAkCheck(误报)\n\tlockKeys, err := l.removeExistingReadLocksFromInsert(tx, keys, existingReadKeys)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Insert locks into database.\n\tneedInsertReadKeys, err := l.insertLocks(tx, lockKeys, ttl, tokens)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Update readLocks.\n\tvar needUpdateExpirationReadKeys []string = nil\n\tvar needUpdateCountReadKeys []string = nil\n\tif needUpdateExpirationReadKeys, needUpdateCountReadKeys, tokens, err = l.updateReadLocks(tx, ttl, existingReadKeys, tokens); err != nil {\n\t\tl.rollback(needUpdateCountReadKeys, tokens)\n\t\tl.rollback(needUpdateExpirationReadKeys, tokens)\n\t\tl.rollback(needInsertReadKeys, tokens)\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\tif result := tx.Commit(); result.Error != nil {\n\t\treturn nil, errors.Wrap(result.Error, \"failed to commit transaction\")\n\t}\n\n\treturn tokens, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mem/memdlock.go",
        "code_start_line": 106,
        "code_end_line": 166,
        "code_key": "tryObtainMulti",
        "code_value": "func (l *memLocker) tryObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, token string) (dlock.Lock, error) {\n\tl.mutex.Lock()\n\tdefer l.mutex.Unlock()\n\tvar readLocks []*dlock.LockKey\n\tvar writeLocks []*dlock.LockKey\n\tvar insertLocks []*dlock.LockKey\n\tvar tokens []string\n\ttokens = append(tokens, token)\n\tfor _, key := range keys {\n\t\tif key.Type == dlock.WriteLock {\n\t\t\twriteLocks = append(writeLocks, key)\n\t\t} else {\n\t\t\treadLocks = append(readLocks, key)\n\t\t}\n\t}\n\tfor _, key := range writeLocks {\n\t\tif item, ok := l.data[key.Key]; ok {\n\t\t\tif time.Until(item.ttl) > 0 {\n\t\t\t\treturn nil, dlock.ErrNotObtained\n\t\t\t} else {\n\t\t\t\tinsertLocks = append(insertLocks, key)\n\t\t\t}\n\t\t} else {\n\t\t\tinsertLocks = append(insertLocks, key)\n\t\t}\n\t}\n\tfor _, key := range readLocks {\n\t\tif item, ok := l.data[key.Key]; ok {\n\t\t\tif item.lockType == dlock.ReadLock {\n\t\t\t\tif time.Until(item.ttl) > 0 {\n\t\t\t\t\titem.count++\n\t\t\t\t\titem.ttl = time.Now().Add(ttl)\n\t\t\t\t\ttokens = append(tokens, item.token)\n\t\t\t\t} else {\n\t\t\t\t\tinsertLocks = append(insertLocks, key)\n\t\t\t\t}\n\t\t\t} else if time.Until(item.ttl) > 0 {\n\t\t\t\treturn nil, dlock.ErrNotObtained\n\t\t\t}\n\t\t} else {\n\t\t\tinsertLocks = append(insertLocks, key)\n\t\t}\n\t}\n\n\tfor _, key := range insertLocks {\n\t\tl.data[key.Key] = &lockItem{\n\t\t\tkey:      key.Key,\n\t\t\tttl:      time.Now().Add(ttl),\n\t\t\ttoken:    token,\n\t\t\tlockType: key.Type,\n\t\t\tcount:    1,\n\t\t}\n\t}\n\n\tlock := &memLock{\n\t\tlocker: l,\n\t\tkeys:   keys,\n\t\ttokens: tokens,\n\t}\n\treturn lock, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 473,
        "code_end_line": 520,
        "code_key": "ObtainMulti",
        "code_value": "func (l *mysqlLocker) ObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, opts *dlock.Option) (dlock.Lock, error) {\n\tif len(keys) == 0 {\n\t\treturn nil, errors.New(\"keys cannot be empty\")\n\t}\n\tkeys = dedupAndSort(keys)\n\n\t// Get the lock token.\n\tlockToken, err := l.getOrCreateLockToken(opts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tretryStrategy := dlock.NoRetry()\n\tif opts != nil && opts.RetryStrategy != nil {\n\t\tretryStrategy = opts.RetryStrategy\n\t}\n\n\tretries := 0\n\tlogger := logs.GetLogger(ctx).With().Strs(\"keys\", dlock.LockKeySlice(keys).GetKeys()).Strs(\"tokens\", lockToken).Logger()\n\n\tfor {\n\t\t// Try to obtain the locks.\n\t\t// If the locks are not obtained, retry based on the retry strategy.\n\t\tif tokens, err := l.tryObtainMulti(ctx, keys, ttl, lockToken, opts); err != nil {\n\t\t\t// If context is canceled, return immediately.\n\t\t\tif ctx.Err() != nil {\n\t\t\t\treturn nil, errors.Wrap(dlock.ErrNotObtained, \"context is canceled\")\n\t\t\t}\n\n\t\t\t// If the lock is not obtained, retry.\n\t\t\twaitDuration := retryStrategy.NextBackoff()\n\t\t\tif waitDuration <= 0 {\n\t\t\t\tlogger.Debug().Int(\"retry\", retries).Msg(\"stop retrying lock\")\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tlogger.Debug().Int(\"retry\", retries).Msg(\"retry obtaining lock\")\n\t\t\ttime.Sleep(waitDuration)\n\t\t} else {\n\t\t\tlockToken = tokens\n\t\t\tlogger.Debug().Msg(\"lock obtained\")\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// TODO xuanzeng: 这里采用内部记录 TTL 的方式，可能和底层的数据库时间不同步，后续应该从数据库中获取过期时间。\n\tlock := &mysqlLock{keys: keys, locker: l, tokens: lockToken, expiration: time.Now().Add(ttl)}\n\treturn lock, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mem/memdlock.go",
        "code_start_line": 74,
        "code_end_line": 103,
        "code_key": "ObtainMulti",
        "code_value": "func (l *memLocker) ObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, opts *dlock.Option) (dlock.Lock, error) {\n\tvar token string\n\tif opts == nil || opts.Token == \"\" {\n\t\ttoken = uuid.New().String()\n\t} else {\n\t\ttoken = opts.Token\n\t}\n\n\tretryStrategy := dlock.NoRetry()\n\tif opts != nil && opts.RetryStrategy != nil {\n\t\tretryStrategy = opts.RetryStrategy\n\t}\n\n\tfor {\n\t\tlock, err := l.tryObtainMulti(ctx, keys, ttl, token)\n\t\tif err == nil {\n\t\t\treturn lock, nil\n\t\t}\n\n\t\tif ctx.Err() != nil {\n\t\t\treturn nil, ctx.Err()\n\t\t}\n\n\t\twaitInterval := retryStrategy.NextBackoff()\n\t\tif waitInterval <= 0 {\n\t\t\treturn nil, dlock.ErrNotObtained\n\t\t}\n\t\ttime.Sleep(waitInterval)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": []
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go:96:108:Add": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
    "code_start_line": 96,
    "code_end_line": 108,
    "code_start_column": 32,
    "code_key": "Add",
    "code_value": "func (d drgroupRepositoryImpl) Add(ctx context.Context, group *drgroup.DRGroup) error {\n\tuow := getUow(ctx)\n\tdo := fromModelToDmDRGroup(group)\n\tdo.Created = uow.tx.NowFunc()\n\tdo.Updated = uow.tx.NowFunc()\n\tresult := uow.tx.Clauses(clause.Insert{Modifier: \"IGNORE\"}).Create(&do)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tgroup.ID = do.ID\n\tuow.trackedDRGroups.Add(group)\n\treturn nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/infra/event_bus/bus.go",
        "code_start_line": 61,
        "code_end_line": 79,
        "code_key": "Execute",
        "code_value": "func (eb *EventBusDriver) Execute(ctx context.Context) (result *response.Result) {\n\tresult = response.DefaultResult()\n\tdefer utils.HandlePanic(ctx, &result)\n\n\tfor _, event := range eb.BlockEventQueue {\n\t\tresult = eb.ExecuteOne(ctx, event)\n\t\tif result.IsSuccess() {\n\t\t\tevent.UpdateState(ctx, Executed)\n\t\t} else {\n\t\t\tlogs.Warn(ctx).Err(result).Int(\"EventType\", int(event.GetType(ctx))).\n\t\t\t\tMsg(\"event execute failed, start rollback event bus\")\n\t\t\tif err := eb.RollbackEvents(ctx); err != nil {\n\t\t\t\tlogs.Error(ctx).Err(err).Int(\"EventType\", int(event.GetType(ctx))).Msg(\"rollback event bus failed\")\n\t\t\t}\n\t\t\treturn result\n\t\t}\n\t}\n\treturn result\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/filters/filter.go",
        "code_start_line": 26,
        "code_end_line": 46,
        "code_key": "Execute",
        "code_value": "func (f FilterChain) Execute(ctx context.Context, disks []*disk.Disk, user *account.User,\n\tcacheMap cache.RDCacheManagerInf, affinityConfig *dto.AffinityConfig) ([]*disk.Disk, response.Result) {\n\tlogs.Info(ctx).Int(\"disk_count\", len(disks)).Msg(\"DISK_COUNT_BEFORE_FILTER\")\n\tfor _, filter := range f.filters {\n\t\tdisks, result := filter.\n\t\t\tWithUser(ctx, user).\n\t\t\tWithRdCacheManager(ctx, cacheMap).\n\t\t\tWithAffinityConfig(ctx, affinityConfig).\n\t\t\tFilter(ctx, disks)\n\t\tdisks = disk.SortByScore(ctx, disks)\n\t\tlogs.Info(ctx).\n\t\t\tInt(\"disk_count\", len(disks)).\n\t\t\tStr(\"filter\", reflect.TypeOf(filter).Name()).\n\t\t\tMsg(\"LEFT_DISK_COUNT_AFTER_FILTER\")\n\t\tif result.IsFailed() {\n\t\t\treturn disks, result\n\t\t}\n\t}\n\t// 对盘的Score进行排序\n\treturn disks, response.SucResult()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_bill_compute_task.go",
        "code_start_line": 26,
        "code_end_line": 40,
        "code_key": "Execute",
        "code_value": "func (t *SnapBillComputeTask) Execute(ctx context.Context) (bool, error) {\n\tt.Ctx = ctx\n\tt.InitTask(ctx)\n\tdefer t.MqIns.Close()\n\n\t// 获取待处理的用户资源\n\tgo t.GetUserResources()\n\t// 执行Ack确认逻辑\n\tgo t.AckAppId()\n\t// 处理用户资源\n\tt.ProcessUserResources()\n\n\tlogs.Info(ctx).Msg(\"SNAP_COMPUTE_TASK_DONE\")\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_calculate_cost_locally_task.go",
        "code_start_line": 21,
        "code_end_line": 37,
        "code_key": "Execute",
        "code_value": "func (t *SnapCalculateCostLocallyTask) Execute(ctx context.Context) (bool, error) {\n\tt.ctx = ctx\n\tsnapRecSrv := measureReconciliation.NewReconciliationSrvImpl(ctx)\n\n\t// 结算上上个周期的用量\n\tnow := time.Now()\n\tstartTime := now.Truncate(time.Hour).Add(-2 * time.Hour)\n\tendTime := now.Truncate(time.Hour).Add(-1 * time.Hour).Add(-1 * time.Second)\n\tlogs.Info(t.ctx).Time(\"startTime\", startTime).Time(\"endTime\", endTime).Msg(\"START_CALCULATE_COST_LOCALLY\")\n\terr := snapRecSrv.CalculateCostLocally(startTime, endTime)\n\tif err != nil {\n\t\tlogs.Error(t.ctx).Err(err).Msg(\"CALCULATE_COST_LOCALLY_ERROR\")\n\t\treturn false, err\n\t}\n\tlogs.Info(t.ctx).Msg(\"CALCULATE_COST_LOCALLY_DONE\")\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/cbs_bill_compute_task.go",
        "code_start_line": 26,
        "code_end_line": 42,
        "code_key": "Execute",
        "code_value": "func (t *CbsBillComputeTask) Execute(ctx context.Context) (bool, error) {\n\tt.Ctx = ctx\n\tt.InitTask(ctx)\n\tdefer t.MqIns.Close()\n\n\t// 获取待处理的用户资源\n\tgo t.GetUserResources()\n\t// 执行Ack确认逻辑\n\tgo t.AckAppId()\n\t// 处理用户资源\n\tt.ProcessUserResources()\n\tt.ChargeItemProducer.Close()\n\n\tt.WG.Wait()\n\tlogs.Info(ctx).Msg(\"CBS_COMPUTE_TASK_DONE\")\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/update_ccbs_normal_rb_task.go",
        "code_start_line": 23,
        "code_end_line": 34,
        "code_key": "Execute",
        "code_value": "func (t *UpdateCCbsNormalRollbackTask) Execute(ctx context.Context) (bool, error) {\n\tt.Count += 1\n\tserv := registry.GetRegistry(ctx).DomainServices.DiskRollbackingService.(diskLogical.DiskRollbackingServiceInterface)\n\tisFinish, err := serv.UpdateCbsRollbackingPercent(ctx, t.DiskAggregate)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tlogs.Info(ctx).Int(\"Status\", t.DiskAggregate.DiskRecord.Status).\n\t\tInt(\"Percent\", t.DiskAggregate.DiskRecord.RollbackingPercent).\n\t\tInt(\"Count\", t.Count).Msg(\"FINISH_EXECUTE_TASK\")\n\treturn isFinish, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/repush_user_billing_task.go",
        "code_start_line": 53,
        "code_end_line": 61,
        "code_key": "Execute",
        "code_value": "func (t *RepushUserBillingTask) Execute(ctx context.Context) (bool, error) {\n\tt.ctx = ctx\n\tt.InitTask(ctx)\n\tdefer t.MqIns.Close()\n\n\tt.ProcessRepushDetailMsg()\n\tlogs.Info(ctx).Msg(\"REPUSH_USER_BILLING_TASK_DONE\")\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/update_create_task.go",
        "code_start_line": 31,
        "code_end_line": 69,
        "code_key": "Execute",
        "code_value": "func (t *UpdateCreateTask) Execute(ctx context.Context) (bool, error) {\n\tt.Count += 1\n\tserv := registry.GetRegistry(ctx).DomainServices.SnapCreatingService.(snapLogical.SnapCreatingServiceInterface)\n\tif t.SnapAggregate.SnapRecord.Status == ccdb.SnapCreating &&\n\t\tt.SnapAggregate.SnapRecord.LifeState == ccdb.SnapLifeStateNormal &&\n\t\tt.SnapAggregate.SnapRecord.Percent == 100 &&\n\t\tt.SnapAggregate.SnapRecord.Attribute != ccdb.SnapAttUserSnap {\n\t\t// 隐藏快照转正常快照\n\t\tlogs.Info(ctx).Msg(\"FIX_INNER_TO_NORMAL\")\n\t\terr := serv.SnapCreateTaskFollowup(ctx, t.SnapAggregate, SnapInnerFollowup)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\treturn true, nil\n\t}\n\n\tisFinish, err := serv.UpdateSnapCreatingPercent(ctx, t.SnapAggregate)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\t// 创建完成的用户快照进行后续操作，隐藏快照不进行\n\tif isFinish && t.SnapAggregate.SnapRecord.Status == ccdb.SnapNormal &&\n\t\tt.SnapAggregate.SnapRecord.LifeState == ccdb.SnapLifeStateNormal {\n\t\t// 目的端快照复制完成时，需更新源端的快照状态\n\t\t// 计算base snap size，并更新\n\t\t// merge\n\t\t// 插入计费，并更新快照大小\n\t\terr = serv.SnapCreateTaskFollowup(ctx, t.SnapAggregate, SnapNormalFollowup)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\n\tlogs.Info(ctx).Int(\"Status\", t.SnapAggregate.SnapRecord.Status).\n\t\tInt(\"Percent\", t.SnapAggregate.SnapRecord.Percent).\n\t\tInt(\"Count\", t.Count).Msg(\"FINISH_EXECUTE_TASK\")\n\treturn isFinish, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/update_image_snap_rb_task.go",
        "code_start_line": 23,
        "code_end_line": 41,
        "code_key": "Execute",
        "code_value": "func (t *UpdateImageSnapRollbackTask) Execute(ctx context.Context) (bool, error) {\n\tt.Count += 1\n\tserv := registry.GetRegistry(ctx).DomainServices.DiskRollbackingService.(diskLogical.DiskRollbackingServiceInterface)\n\tisFinish, err := serv.UpdateImageSnapRollbackingPercent(ctx, t.DiskAggregate)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif isFinish {\n\t\t// TODO：这里应该放入一个管道中，后续再优化\n\t\terr = serv.UpdateRollbackQuota(ctx, t.DiskAggregate)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\tlogs.Info(ctx).Str(\"Status\", t.DiskAggregate.ImageSnapRollbackRecord.Status).\n\t\tInt(\"Percent\", t.DiskAggregate.ImageSnapRollbackRecord.Percent).\n\t\tInt(\"Count\", t.Count).Msg(\"FINISH_EXECUTE_TASK\")\n\treturn isFinish, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/cbs_measure_send_task.go",
        "code_start_line": 30,
        "code_end_line": 54,
        "code_key": "Execute",
        "code_value": "func (t *CbsMeasureSendTask) Execute(ctx context.Context) (bool, error) {\n\t// 初始化各项配置\n\tt.Ctx = ctx\n\tt.InitTask(ctx)\n\tt.cbsSrv = cbsResource.NewCbsSrvImpl(t.Ctx)\n\tdefer t.MqIns.Close()\n\t// 根据区域分发到国内和国际两个不同channel中去处理\n\tt.ChannelDistribution()\n\n\t// MSG处理的生命周期Msg -->chargeItem -->MeasureDetails-->MeasureDetailsChannel-->Params-->Ack Msg\n\tgo t.ProcessMsgByRegion()\n\n\t// 计费详情转换成计费参数\n\tgo t.ProcessMeasureDetailToParams()\n\n\t// 执行ACK\n\tgo t.AckResourceID()\n\n\t// 根据计费参数发送计费消息\n\tt.ProcessParamsSendMeasure()\n\n\tt.WG.Wait()\n\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/cbs_rec_task.go",
        "code_start_line": 37,
        "code_end_line": 61,
        "code_key": "Execute",
        "code_value": "func (t *CbsMeasureRecTask) Execute(ctx context.Context) (bool, error) {\n\t// 初始化各项配置\n\tt.Ctx = ctx\n\tt.InitTask(ctx)\n\t// 初始化snapSrv\n\tt.cbsReSrv = measureReconciliation.NewReconciliationSrvImpl(t.Ctx)\n\tt.cbsSrv = cbsResource.NewCbsSrvImpl(t.Ctx)\n\tdefer t.MqIns.Close()\n\t// 根据区域分发到国内和国际两个不同channel中去处理\n\tt.ChannelDistribution()\n\n\t// MSG处理的生命周期Msg -->chargeItem -->subMeasureDetails-->subMeasureDetailsChannel-->db-->Ack Msg\n\tgo t.ProcessMsg()\n\n\t// 生成批次外发的计费对账数据\n\tgo t.ProcessMeasureDetailBatch()\n\n\t// 执行ACK\n\tgo t.AckResourceID()\n\n\t// 将计费数据外发到数据库\n\tt.ProcessMeasureToDb()\n\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_measure_send_task.go",
        "code_start_line": 27,
        "code_end_line": 49,
        "code_key": "Execute",
        "code_value": "func (t *SnapMeasureSendTask) Execute(ctx context.Context) (bool, error) {\n\t// 初始化各项配置\n\tt.Ctx = ctx\n\tt.InitTask(ctx)\n\tdefer t.MqIns.Close()\n\n\t// 根据区域分发到国内和国际两个不同channel中去处理\n\tt.ChannelDistribution()\n\n\t// 启动外发任务\n\tgo t.ProcessMsgByRegion()\n\n\t// 用量详情转换成计费协议\n\tgo t.ProcessMeasureDetailToParams()\n\n\t// 执行ACK\n\tgo t.AckResourceID()\n\n\t// 根据计费协议发送到计费客户端\n\tt.ProcessParamsSendMeasure()\n\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_rec_task.go",
        "code_start_line": 48,
        "code_end_line": 61,
        "code_key": "Execute",
        "code_value": "func (t *SnapMeasureReconciliationTask) Execute(ctx context.Context) (bool, error) {\n\t// 初始化各项配置\n\tt.ctx = ctx\n\tt.initTask()\n\n\t// 将数据推送到数据库\n\tvar wg sync.WaitGroup\n\tgo t.sendDbFromMsg(&wg)\n\n\t// 执行ACK\n\tgo t.AckResourceID()\n\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/base_measure/base_appId_fetch_task.go",
        "code_start_line": 38,
        "code_end_line": 61,
        "code_key": "Execute",
        "code_value": "func (t *BaseAppIdFetchTask) Execute(ctx context.Context) (bool, error) {\n\tt.ctx = ctx\n\tt.initTask()\n\n\tappIds := t.resSrv.GetAppIdsWithValidResources(t.chargeTime)\n\tfor _, appId := range appIds {\n\t\tappIdItem := measure.AppIdInfo{\n\t\t\tAppId: appId,\n\t\t}\n\t\t// Send自带Confirm机制. error为nil表示发送成功\n\t\t// Send会阻塞等待Confirm，如果需要，可以考虑放协程里跑\n\t\terr := t.client.Send(ctx, measure.BuildRabbitRequest(&appIdItem))\n\t\tif err != nil {\n\t\t\tlogs.Error(ctx).Err(err).Msg(\"SEND_MESSAGE_FAILED\")\n\t\t\treturn false, err\n\t\t}\n\t\tlogs.Info(ctx).Interface(\"appId\", appId).Msg(\"SEND_MESSAGE_SUCCESS\")\n\t}\n\n\tstopChan := make(chan struct{})\n\t_ = t.server.Close(stopChan)\n\t<-stopChan\n\treturn true, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/cache/managers/shm.go",
        "code_start_line": 86,
        "code_end_line": 88,
        "code_key": "ListExpiredKeys",
        "code_value": "func (s *ShmCacheManager) ListExpiredKeys(ctx context.Context) []interface{} {\n\tpanic(\"implement me\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/subgroup.go",
        "code_start_line": 46,
        "code_end_line": 54,
        "code_key": "ListExpiredKeys",
        "code_value": "func (s *SubGroupCacheManager) ListExpiredKeys(ctx context.Context) []interface{} {\n\tvar expiredKeys []interface{}\n\tfor expireTime, keys := range s.cacheMap.GetExpireTimeMap() {\n\t\tif time.Now().Add(time.Duration(SafeReserveSeconds)*time.Second).Unix() >= expireTime {\n\t\t\texpiredKeys = append(expiredKeys, keys...)\n\t\t}\n\t}\n\treturn expiredKeys\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/filters/dmg.go",
        "code_start_line": 107,
        "code_end_line": 133,
        "code_key": "filterWithHostAff",
        "code_value": "func (r RdPlacementGroupFilter) filterWithHostAff(ctx context.Context, disks []*disk.Disk) []*disk.Disk {\n\t/**\n\t检查母机置放群组亲和性\n\t\t1. 检查单母机绑定的置放群组子组数量不会超过置放群组亲和度限制\n\t    2. 置放群组是强制性装箱规则，不满足置放群组的盘被舍弃掉\n\t*/\n\tif len(disks) == 0 {\n\t\treturn disks\n\t}\n\twg := &sync.WaitGroup{}\n\twg.Add(len(disks))\n\n\tfor _, oneDisk := range disks {\n\t\tgo r.checkHostAffWithSingleDisk(ctx, oneDisk, wg)\n\t}\n\twg.Wait()\n\n\t// 对置放群组亲和性检查的盘进行过滤,打标分数小于0的过滤掉\n\tdiskSlice := make([]*disk.Disk, 0, 100000)\n\tfor _, oneDisk := range disks {\n\t\tif oneDisk.Score >= 0 {\n\t\t\tdiskSlice = append(diskSlice, oneDisk)\n\t\t}\n\t}\n\treturn diskSlice\n\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/tracker.go",
        "code_start_line": 67,
        "code_end_line": 77,
        "code_key": "Refresh",
        "code_value": "func (rdp *PhyDiskTracker) Refresh(ctx context.Context) {\n\trdp.Track(ctx)\n\tlock.RDPhyCacheGlobalLock.GetLocker(lock.RDPhyLockKeyGenerator{}).Lock()\n\trdp.Merge(ctx, rdp.OriPhyDisks)\n\tlogs.Info(ctx).\n\t\tInt(\"disk_num\", len(rdp.ToCachedPhyDisks)).\n\t\tInt(\"member_num\", len(rdp.DrgroupMembers)).\n\t\tMsg(\"CACHE_AVAILABLE_PHY_DISK_AFTER_MERGE\")\n\trdp.CacheManager.RefreshCache(ctx, rdp.ToCachedPhyDisks, rdp.DrgroupMembers)\n\tlock.RDPhyCacheGlobalLock.GetLocker(lock.RDPhyLockKeyGenerator{}).Unlock()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/set/cache/tracker.go",
        "code_start_line": 35,
        "code_end_line": 38,
        "code_key": "Refresh",
        "code_value": "func (d *DiskSetTracker) Refresh(ctx context.Context) {\n\td.Track(ctx)\n\td.CacheManager.RefreshCache(ctx, d.DiskSetEntityInf)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 644,
        "code_end_line": 674,
        "code_key": "Refresh",
        "code_value": "func (l *mysqlLock) Refresh(ctx context.Context, ttl time.Duration) error {\n\n\ttx := l.locker.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\n\n\tkeysKey := dlock.LockKeySlice(l.keys).GetKeys()\n\t// NOCA:QCloudAkCheck(误报)\n\texistingLocks, err := l.locker.fetchExistingLocksByKeysAndTokens(tx, keysKey, l.tokens)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn err\n\t}\n\n\t// Compare existing locks with the keys.\n\tif !checkStrSetEqual(existingLocks, keysKey) {\n\t\t_ = tx.Rollback()\n\t\treturn errors.Wrap(dlock.ErrLockNotHeld, \"lock is not held\")\n\t}\n\n\t// Update the expiration time.\n\tif err := l.locker.updateLocksTTLByKeysAndTokens(tx, keysKey, l.tokens, ttl); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn err\n\t}\n\n\tif result := tx.Commit(); result.Error != nil {\n\t\treturn errors.Wrap(result.Error, \"failed to commit refresh locks\")\n\t}\n\n\tl.expiration = time.Now().Add(ttl)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mem/memdlock.go",
        "code_start_line": 189,
        "code_end_line": 210,
        "code_key": "Refresh",
        "code_value": "func (l *memLock) Refresh(ctx context.Context, ttl time.Duration) error {\n\tl.locker.mutex.Lock()\n\tdefer l.locker.mutex.Unlock()\n\n\ttokens := make(map[string]struct{}, len(l.tokens))\n\tfor _, item := range l.tokens {\n\t\ttokens[item] = struct{}{}\n\t}\n\tfor _, key := range l.keys {\n\t\tif item, ok := l.locker.data[key.Key]; ok {\n\t\t\tif _, exist := tokens[item.token]; !exist {\n\t\t\t\treturn dlock.ErrLockNotHeld\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, key := range l.keys {\n\t\tl.locker.data[key.Key].ttl = time.Now().Add(ttl)\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go",
        "code_start_line": 51,
        "code_end_line": 72,
        "code_key": "Handle",
        "code_value": "func (c *CbsAppIdConsumer) Handle(ctx context.Context, delivery *rabbitmq.Delivery) error {\n\tu, chargeTime, err := c.ParseDelivery(ctx, delivery)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif u == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"USER_INFO_NOT_FOUND\")\n\t\treturn nil\n\t}\n\n\tchargeDetail := c.GetChargeDetailForSingleUser(u, chargeTime)\n\tif chargeDetail == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tUint64(\"appId\", uint64(u.AppId)).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"NO_RESOURCE_TO_CHARGE\")\n\t\treturn nil\n\t}\n\treturn c.ProcessChargeDetail(chargeDetail)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 105,
        "code_end_line": 116,
        "code_key": "Handle",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tif err := c.ensureLocks(ctx); err != nil {\n\t\treturn err\n\t}\n\tif c.lvUUID != nil {\n\t\t// 涉及到逻辑卷时，需要先标记逻辑卷为故障\n\t\treturn c.handleBindedVolume(ctx)\n\t} else {\n\t\t// 不涉及到逻辑卷时，直接标记物理卷为故障\n\t\treturn c.handleIdleVolume(ctx)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/detach_logical_volume.go",
        "code_start_line": 56,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *DetachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDetachLogicalVolume, c)\n\n\t// 如果没有挂载到指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume not attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_benchmark_task.go",
        "code_start_line": 125,
        "code_end_line": 165,
        "code_key": "Handle",
        "code_value": "func (c *CreateBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tvolSm     = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = volSm.Fire(ctx, c.relatedVolume.State, domain.PVEStartBenchmark, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark = benchmark.New(benchmark.DiskInfo{\n\t\tSerial: string(c.relatedVolume.Serial),\n\t\tHostIP: c.relatedVolume.IP,\n\t\tBDF:    string(c.relatedVolume.BDF),\n\t})\n\n\tif err = benchRepo.Add(ctx, c.relatedBenchmark); err != nil {\n\t\tdelegate := &benchmarkDelegate{cmd: c}\n\t\tif _err := delegate.TaskFinishCallback(ctx, c.relatedBenchmark); _err != nil {\n\t\t\tlogs.Warn(ctx).Err(_err).Str(\"serial\", string(c.relatedVolume.Serial)).Msg(\"failed to rollback: create bdev\")\n\t\t}\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventCreateBench,\n\t\tbenchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_logical_volume.go",
        "code_start_line": 71,
        "code_end_line": 108,
        "code_key": "Handle",
        "code_value": "func (d *DeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\td.volume, err = repo.FindByID(ctx, d.UUID)\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif e := d.volume.CheckDelete(); e != nil {\n\t\treturn e\n\t}\n\n\tif d.volume.AppID != d.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"refuse to delet: app id mismatch\")\n\t}\n\n\td.drgroup, err = app.GetRegistry(ctx).Repositories.DRGroup.FindByMember(ctx, d.AppID, d.volume.UUID.String())\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\td.drgroup = nil\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := d.checkDRGroupMatch(ctx); err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, d.volume.State, rdiskDomain.LVEMarkToRecycle, d)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_recycled_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmRecycledPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEConfirmRecycled, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_rdisk_backup.go",
        "code_start_line": 52,
        "code_end_line": 75,
        "code_key": "Handle",
        "code_value": "func (c *DeleteRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tsm   = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\tc.relatedBackup, err = repo.FindByUUID(ctx, c.BackupID.String())\n\tif err != nil || c.relatedBackup == nil || c.relatedBackup.AppID != c.AppID {\n\t\treturn errors.New(backupDomain.ErrBackupNotExist, \"backup not exists\")\n\t}\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tc.relatedBackup.Status,\n\t\tbackupDomain.EventSoftDeleteBackup,\n\t\tbackupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: c.relatedBackup})\n\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_rdisk_backup.go",
        "code_start_line": 47,
        "code_end_line": 80,
        "code_key": "Handle",
        "code_value": "func (c *CreateRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tlvSm  = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\tbakSm = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo  = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t_, err = lvSm.Fire(ctx, c.relatedVolume.State, rdiskDomain.LVEBackupStarted, c)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tlv := c.relatedVolume\n\tbackup := backupDomain.New(\n\t\tlv.AppID,\n\t\tbackupDomain.DiskInfo{\n\t\t\tVolumeUUID: lv.UUID,\n\t\t\tVolumeSize: uint64(lv.Size),\n\t\t\tHostIP:     lv.PhysicalVolume.IP,\n\t\t\tHostBDF:    string(lv.PhysicalVolume.BDF),\n\t\t\tSerial:     string(lv.PhysicalVolume.Serial),\n\t\t},\n\t)\n\tif err := repo.Add(ctx, backup); err != nil {\n\t\treturn err\n\t}\n\tc.relatedBackup = backup\n\t_, err = bakSm.Fire(ctx, backupDomain.StatusInit, backupDomain.EventStartBackup, backupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: backup})\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/attach_logical_volume.go",
        "code_start_line": 49,
        "code_end_line": 71,
        "code_key": "Handle",
        "code_value": "func (c *AttachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEAttachLogicalVolume, c)\n\n\t// 如果已经挂载到了指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeAlreadyAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume already attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_delete_logical_volume.go",
        "code_start_line": 34,
        "code_end_line": 55,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\t// 如果逻辑卷不存在，则直接返回成功\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"failed to confirm delete: app id mismatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDeleteLogicalVolume, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/offline_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OfflinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOfflinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *DeletePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\t// 如果物理卷不存在，则直接幂等返回\n\t\treturn nil\n\t}\n\n\tvar event = domain.PVEDeletePhysicalVolume\n\tif c.Force && (c.relatedVolume.State == domain.PVSDefunct) {\n\t\t// 这里的实现不太好，状态机的逻辑不应该侵入 cmd\n\t\t// 时间太赶了，后续重构优化吧\n\t\tevent = domain.PVEForceDeleteForDefunct\n\t}\n\n\tif c.relatedVolume.HasBindedPV() {\n\t\treturn errors.New(domain.ErrVolumeBusy, \"logic volume has binded to this physical volume\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, event, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_logical_volume.go",
        "code_start_line": 55,
        "code_end_line": 70,
        "code_key": "Handle",
        "code_value": "func (c *CleanupLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVECleanupLogicalVolume, c)\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_init_physical_volume.go",
        "code_start_line": 26,
        "code_end_line": 52,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmInitPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\tif c.relatedVolume.IP.String() != c.Host.String() {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume host ip mistmatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVECreatePhysicalVolumeOnHost, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_physical_volume.go",
        "code_start_line": 51,
        "code_end_line": 101,
        "code_key": "Handle",
        "code_value": "func (c *CreatePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\n\t// 获取物理卷状态机\n\tsm := app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\trepo := app.GetRegistry(ctx).Repositories.PhysicalVolume\n\n\t// 检查物理卷是否已经存在，如果存在则直接幂等返回\n\tvol1, err := repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"serial\", c.Serial).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tvol2, err := repo.FindByIPAndBDF(ctx, c.Host, domain.BDF(c.BDF))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"host\", c.Host.String()).Str(\"bdf\", c.BDF).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tfor _, vol := range []*domain.PhysicalVolume{vol1, vol2} {\n\t\texisted, err := c.checkExisting(ctx, vol)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif existed {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// 触发事件，创建物理卷\n\t_, err = sm.Fire(ctx,\n\t\tdomain.PVSUnInited,\n\t\tdomain.PVECreatePhysicalVolume,\n\t\tc,\n\t)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 创建 Bdev 以及格式化移动到创建物理卷的状态机中\n\n\t// _, err = sm.Fire(ctx,\n\t// \tc.GetPhysicalVolume().State,\n\t// \tdomain.PVECreatePhysicalVolumeOnHost,\n\t// \tc,\n\t// )\n\t// if err != nil {\n\t// \treturn err\n\t// }\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_benchmark_task.go",
        "code_start_line": 32,
        "code_end_line": 57,
        "code_key": "Handle",
        "code_value": "func (c *DeleteBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\terr       error\n\t)\n\n\tbench, err := benchRepo.FindByUUID(ctx, c.BenchmarkUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif bench.DiskInfo.Serial != c.Serial {\n\t\treturn errors.Newf(benchmark.ErrTaskNotFound, \"benchmark serial not match %s, want %s\", c.Serial, bench.DiskInfo.Serial)\n\t}\n\n\t_, err = benchSm.Fire(ctx, bench.Status, benchmark.EventDeleteBench, benchmark.Data{Benchmark: bench, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := benchRepo.Delete(ctx, bench); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_logical_volume.go",
        "code_start_line": 52,
        "code_end_line": 98,
        "code_key": "Handle",
        "code_value": "func (c *CreateLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tpvRepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tlvRepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm     = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\t// 1. 查找底层物理卷\n\tc.selectedPhysicalVolume, err = pvRepo.FindBySerial(ctx, rdiskDomain.Serial(c.PhysicalVolumeSerial))\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// 检查底层物理卷大小是否满足要求\n\tif c.selectedPhysicalVolume.Size < rdiskDomain.Size(c.DiskSize) {\n\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume size %d is smaller than requested size %d\", c.selectedPhysicalVolume.Size, c.DiskSize)\n\t}\n\n\t// 检查底层物理卷性能等级是否满足要求\n\tif c.PerformanceRank != \"\" {\n\t\tif string(c.selectedPhysicalVolume.PerformanceRank) != c.PerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not match requested rank %s\", c.selectedPhysicalVolume.PerformanceRank, c.PerformanceRank)\n\t\t}\n\t} else {\n\t\tif c.selectedPhysicalVolume.PerformanceRank != rdiskDomain.DefaultPerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not default rank %s\", c.selectedPhysicalVolume.PerformanceRank, rdiskDomain.DefaultPerformanceRank)\n\t\t}\n\t}\n\n\t// 2. 创建逻辑卷\n\tvol := rdiskDomain.NewLogicalVolume(users.AppID(c.AppID), rdiskDomain.Size(c.DiskSize), rdiskDomain.ZoneID(c.ZoneID))\n\tif c.VolumeType != \"\" {\n\t\tvol.VolumeType = rdiskDomain.VolumeType(c.VolumeType)\n\t}\n\tif c.DiskType != \"\" {\n\t\tvol.DiskType = rdiskDomain.DiskType(c.DiskType)\n\t}\n\terr = lvRepo.Add(ctx, vol)\n\tif err != nil {\n\t\treturn\n\t}\n\tc.createdLogicalVolume = vol\n\n\t// 3. 触发状态机，联动更新逻辑卷和物理卷状态\n\t_, err = sm.Fire(ctx, rdiskDomain.LVSUnInited, rdiskDomain.LVECreateLogicalVolume, c)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_running_backup_task.go",
        "code_start_line": 31,
        "code_end_line": 61,
        "code_key": "Handle",
        "code_value": "func (c *UpdateRunningBackupTaskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventUpdateBackupProgress,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_drgroup.go",
        "code_start_line": 78,
        "code_end_line": 173,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeDRGroupCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tlvView  = app.GetRegistry(ctx).Viewers.LogicalVolume\n\t\tdrgRepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t\tsm      = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\terr     error\n\t)\n\n\t// 0. 初始化\n\tc.drgroupRef = make(map[string]*drgroup.DRGroup)\n\n\t// 1. 加载所有逻辑卷所在的置放群组\n\tallVolumeUUIDs := make([]string, 0, len(c.UUIDs))\n\tfor _, _uuid := range c.UUIDs {\n\t\tallVolumeUUIDs = append(allVolumeUUIDs, _uuid.String())\n\t}\n\tif groups, err := drgRepo.FindByMembers(ctx, c.AppID, allVolumeUUIDs); err == nil {\n\t\tif err != nil {\n\t\t\tif !errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tfor _, group := range groups {\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t\tc.curDRGroupNames = append(c.curDRGroupNames, group.Name)\n\t\t}\n\t} else {\n\t\treturn err\n\t}\n\n\t// 2. 确认已上锁的置放群组和当前一致\n\tif !c.checkLockedDRGroupNames() {\n\t\treturn errors.New(drgroup.ErrGroupModified, \"drgroup changed\")\n\t}\n\n\t// 3. 加载所有逻辑卷的状态，不需要完整实体，因为不会修改 Volume\n\tc.relatedLogicalVolume, err = lvView.FindByIDs(ctx, c.AppID, c.UUIDs)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(c.relatedLogicalVolume) < len(c.UUIDs) {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t// 4. 加载所有目标置放群组，key 为 name\n\tfor _, spec := range c.Specs {\n\t\tvar group *drgroup.DRGroup\n\t\tif _, ok := c.drgroupRef[spec.Name]; ok {\n\t\t\tgroup = c.drgroupRef[spec.Name]\n\t\t} else {\n\t\t\tgroup, err = c.getOrCreateDRGroup(ctx, drgRepo, spec)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t}\n\n\t\tif spec.Affinity > 0 {\n\t\t\tgroup.Affinity = spec.Affinity\n\t\t}\n\t\tif spec.Type != \"\" {\n\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t}\n\t}\n\n\t// 5. 对所有逻辑卷执行置放群组变更事件，检查状态是否允许，\n\t//    实际的更新还是在这里执行。\n\tfor _, vol := range c.relatedLogicalVolume {\n\t\terr := sm.Check(ctx, vol.State, rdiskDomain.LVEUpdateDrGroup, c)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// 将逻辑卷从原有的置放群组中移除\n\t\tfor _, name := range c.curDRGroupNames {\n\t\t\tc.drgroupRef[name].RemoveMember(vol.UUID.String())\n\t\t}\n\t\t// 将逻辑卷添加到新的置放群组中\n\t\tfor _, spec := range c.Specs {\n\t\t\tsubGroup := spec.SubGroup\n\t\t\tif subGroup == \"\" {\n\t\t\t\t// 如果没有指定子组，则使用远端 SSD UUID 作为子组名称\n\t\t\t\t// 相当于每块盘都是一个子组，相当于没有使用子组功能\n\t\t\t\tsubGroup = vol.UUID.String()\n\t\t\t}\n\t\t\tif err := c.drgroupRef[spec.Name].AddMember(vol.UUID.String(), subGroup, vol.PhysicalVolume.IP.String()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tif c.DryRun {\n\t\treturn errors.New(errors.ErrDryRunSuccessExit, \"dry run check success\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/online_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OnlinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOnlinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_benchmark_task.go",
        "code_start_line": 34,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *UpdateBenchmarkTask) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, rdisk.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark, err = benchRepo.FindByUUID(ctx, c.BenchmarkUUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventUpdateBench, benchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_flow_ctrl.go",
        "code_start_line": 80,
        "code_end_line": 103,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeFlowControlCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not found\")\n\t}\n\n\tspec := c.volume.FlowControlSpec\n\tif !c.UpdateRequest.UpdateSpec(&spec, c.volume.GetDefaultFlowControlSpec()) {\n\t\t// 没有任何更新，直接返回成功\n\t\treturn nil\n\t}\n\tc.volume.SetFlowControlSpec(spec)\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEUpdateFlowControl, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_defunct_volume.go",
        "code_start_line": 46,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *CleanupDefunctCommand) Handle(ctx context.Context) error {\n\tvar err error\n\tc.lv, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar sm = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\tvar event = rdiskDomain.LVECleanupDefunct\n\n\tfor _, attachment := range c.lv.Attachments {\n\t\tlogs.Info(ctx).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).Msg(\"cleanup defuncting volume\")\n\t\tsubCmd := &cleanDefunctSubCommand{Parent: c, HostIP: attachment.IP}\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, subCmd)\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，因为只要有一个挂载点清理失败，其他挂载点还是需要继续清理的\n\t\t\t// 失败的挂载点会在后台继续清理\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).\n\t\t\t\tMsg(\"failed to cleanup defunct volume, retry later.\")\n\t\t}\n\t}\n\n\tif len(c.lv.Attachments) == 0 {\n\t\t// 没有挂载点，直接清理\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, &cleanDefunctSubCommand{Parent: c, HostIP: net.IP{}})\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，后续自动重试即可\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Msg(\"failed to complete cleanup defunct volume\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_drgroup_exists.go",
        "code_start_line": 28,
        "code_end_line": 53,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDRGroupExistsCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t)\n\tfor _, spec := range c.DRGroup {\n\t\t_, err := repo.FindByName(ctx, users.AppID(c.AppID), spec.Name)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\tgroup := drgroup.New(spec.Name, users.AppID(c.AppID))\n\t\t\t\tif spec.Affinity > 0 {\n\t\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t\t}\n\t\t\t\tif spec.Type != \"\" {\n\t\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t\t}\n\t\t\t\terr = repo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_physical_volume.go",
        "code_start_line": 31,
        "code_end_line": 54,
        "code_key": "Handle",
        "code_value": "func (c *UpdatePhyRDiskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEUpdatePhysicalVolume, c)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/recycle_backup_data.go",
        "code_start_line": 32,
        "code_end_line": 62,
        "code_key": "Handle",
        "code_value": "func (c *RecycleBackupDataCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventDeleteBackup,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go",
        "code_start_line": 74,
        "code_end_line": 102,
        "code_key": "ProcessChargeDetail",
        "code_value": "func (c *CbsAppIdConsumer) ProcessChargeDetail(detail *ChargeDetail) error {\n\tcbsSrv := c.ResSrv.(*measure.CbsSrv)\n\t// 不同用户的资源数是不一致的，这里顺序处理的话性能一般，需要放在协程中跑\n\t// 单个用户最多启动100个协程，避免协程过多\n\tvar wg sync.WaitGroup\n\tfor _, cbsInstanceId := range detail.ResIds {\n\t\twg.Add(1)\n\t\tgo func(cbsInstanceId measure.ResourceId) {\n\t\t\tdefer wg.Done()\n\t\t\t// 并发的控制策略: 同时处理的用户不超过t.Concurrency个，所有用户共享t.Concurrency * 100个协程\n\t\t\t// 这样设计的目的是为了规避用户资源倾斜严重的问题，同时也能保证用户的并发度较少\n\t\t\tc.ResSemaphore <- struct{}{}\n\t\t\tdefer func() {\n\t\t\t\t<-c.ResSemaphore\n\t\t\t}()\n\n\t\t\tlogs.Info(c.Ctx).\n\t\t\t\tUint64(\"appId\", uint64(detail.User.AppId)).\n\t\t\t\tStr(\"cbsInstanceId\", string(cbsInstanceId)).\n\t\t\t\tMsg(\"PROCESS_SIGNAL_DISK\")\n\n\t\t\tchargeItem := cbsSrv.BuildResChargeItem(detail.User, cbsInstanceId, detail.ChargeTime)\n\t\t\t// 单个资源失败就等下一轮，先忽略err\n\t\t\t_ = c.ProcessSingleChargeItem(detail.User, cbsInstanceId, chargeItem)\n\t\t}(cbsInstanceId)\n\t}\n\twg.Wait()\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/service.go",
        "code_start_line": 208,
        "code_end_line": 217,
        "code_key": "BuildResChargeItem",
        "code_value": "func (cbsSrv *CbsSrv) BuildResChargeItem(u *user.User, resourceId ResourceId, chargeTime time.Time) *ChargeItem {\n\tcbsMeasureRepo := cbsSrv.balanceRepo.(repositories.CbsBalanceRepoIFace)\n\tbalanceRecords, _ := cbsMeasureRepo.GetCbsBalanceRecords(cbsSrv.ctx, string(resourceId), chargeTime, false)\n\n\tif len(balanceRecords) == 0 {\n\t\treturn nil\n\t}\n\n\treturn cbsSrv.convertToChargeItem(u, resourceId, balanceRecords, chargeTime)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 133,
        "code_end_line": 236,
        "code_key": "BuildResChargeItem",
        "code_value": "func (snapSrv *SnapSrv) BuildResChargeItem(u *user.User, resourceId ResourceId, chargeTime time.Time) *ChargeItem {\n\t// 获取符合条件的balanceRecord并根据chargeTime排序\n\tbalanceRecords, _ := snapSrv.snapRepo.GetSnapBalanceRecords(snapSrv.ctx, string(resourceId), chargeTime)\n\n\t// FIXME 临时方案：用内存里的lastBalanceTime覆盖balanceRecords里的balanceTime\n\tfor _, balanceRecord := range balanceRecords {\n\t\tlastBalanceTime, ok := snapSrv.lastBalanceTimeCache[balanceRecord.ID]\n\t\tif ok {\n\t\t\tbalanceRecord.LastBalanceTime = lastBalanceTime\n\t\t}\n\t}\n\n\tif len(balanceRecords) == 0 {\n\t\treturn nil\n\t}\n\tsort.Slice(balanceRecords, func(i, j int) bool {\n\t\tif balanceRecords[i].LastBalanceTime.Equal(balanceRecords[j].LastBalanceTime) {\n\t\t\treturn balanceRecords[i].OperationType < balanceRecords[j].OperationType\n\t\t}\n\t\treturn balanceRecords[i].LastBalanceTime.Before(balanceRecords[j].LastBalanceTime)\n\t})\n\n\t// 区分国内站和国际站用户\n\tvar userArea Area\n\tif u.IsI18nUser() {\n\t\tuserArea = AreaI18n\n\t} else {\n\t\tuserArea = AreaChina\n\t}\n\tisGrayUser, err := u.CheckFeature(user.USER_FLAG_SNAP_GRAY_USER)\n\tif err != nil {\n\t\tlogs.Error(snapSrv.ctx).Err(err).Int64(\"appId\", int64(u.AppId)).Msg(\"CHECK_GRAY_USER_ERR\")\n\t\t// 出错时标记为非灰度用户，避免重复推量\n\t\tisGrayUser = false\n\t}\n\n\tchargeItem := &ChargeItem{\n\t\t// FIXME: 需要从配置文件中获取region id\n\t\tRegionId:     snapSrv.regionId,\n\t\tZoneId:       balanceRecords[0].ZoneID,\n\t\tAppId:        u.AppId,\n\t\tUin:          u.Uin,\n\t\tUserArea:     userArea,\n\t\tIsGrayUser:   isGrayUser,\n\t\tResourceId:   resourceId,\n\t\tResourceArea: snapSrv.regionArea,\n\t\tItems:        make([]*SubItem, 0, len(balanceRecords)),\n\t}\n\n\t// 虚拟计费条目，用于确定endBalanceTime\n\tendBalanceRecord := &ccdb.CSnapBalance{LastBalanceTime: chargeTime.Add(time.Second * -1)}\n\tallBalances := append(balanceRecords, endBalanceRecord)\n\n\tfor i, balanceRecord := range allBalances[1:] {\n\t\tbeginBalanceRecord := balanceRecords[i]\n\t\t// 资源欠费，不收取费用\n\t\tif beginBalanceRecord.OperationType == int(SnapOpArrearage) {\n\t\t\tlogs.Info(snapSrv.ctx).Uint64(\"appId\", uint64(u.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"RESOURCE_ARREARAGE\")\n\t\t\tcontinue\n\t\t}\n\t\t// 资源已退还。退还后还产生了计费条目，非期望行为\n\t\tif beginBalanceRecord.OperationType == int(SnapOpReturn) {\n\t\t\tlogs.Info(snapSrv.ctx).Uint64(\"appId\", uint64(u.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"SNAP_HAS_RETURNED\")\n\t\t\tbreak\n\t\t}\n\n\t\t// 资源正常\n\t\tstartTime := beginBalanceRecord.LastBalanceTime\n\t\tendTime := balanceRecord.LastBalanceTime\n\t\tcurTime := startTime\n\t\tfor endTime.After(curTime) {\n\t\t\tcurHourEnd := time.Date(curTime.Year(), curTime.Month(), curTime.Day(), curTime.Hour(), 59, 59, 0, curTime.Location())\n\t\t\tif !endTime.After(curHourEnd) {\n\t\t\t\t// 同一周期\n\t\t\t\tsubItem := &SubItem{\n\t\t\t\t\tPid:       PidSnap,\n\t\t\t\t\tStartTime: curTime,\n\t\t\t\t\tEndTime:   endTime,\n\t\t\t\t\tSubValueDetail: map[string]interface{}{\n\t\t\t\t\t\t\"Size\": beginBalanceRecord.SnapSize},\n\t\t\t\t}\n\t\t\t\tchargeItem.Items = append(chargeItem.Items, subItem)\n\t\t\t\tcurTime = endTime.Add(time.Second)\n\t\t\t} else {\n\t\t\t\t// 非同一周期，先构建这个周期的\n\t\t\t\tsubItem := &SubItem{\n\t\t\t\t\tStartTime: curTime,\n\t\t\t\t\tEndTime:   curHourEnd,\n\t\t\t\t\tSubValueDetail: map[string]interface{}{\n\t\t\t\t\t\t\"Size\": beginBalanceRecord.SnapSize,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\tchargeItem.Items = append(chargeItem.Items, subItem)\n\t\t\t\tcurTime = curHourEnd.Add(time.Second)\n\t\t\t}\n\n\t\t}\n\t}\n\tif len(chargeItem.Items) == 0 {\n\t\treturn nil\n\t}\n\n\treturn chargeItem\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 247,
        "code_end_line": 264,
        "code_key": "BuildResChargeItem",
        "code_value": "func (cbsSrv *CbsSrv) BuildResChargeItem(u *user.User, resourceId ResourceId, chargeTime time.Time) *ChargeItem {\n\tcbsMeasureRepo := cbsSrv.measureRepo.(CbsMeasureRepoIFace)\n\tbalanceRecords, _ := cbsMeasureRepo.GetCbsBalanceRecords(cbsSrv.ctx, string(resourceId), chargeTime, false)\n\n\t// FIXME 临时方案：用内存里的lastBalanceTime覆盖balanceRecords里的balanceTime\n\tfor _, balanceRecord := range balanceRecords {\n\t\tlastBalanceTime, ok := cbsSrv.lastBalanceTimeCache[balanceRecord.ID]\n\t\tif ok {\n\t\t\tbalanceRecord.LastBalanceTime = lastBalanceTime\n\t\t}\n\t}\n\n\tif len(balanceRecords) == 0 {\n\t\treturn nil\n\t}\n\n\treturn cbsSrv.convertToChargeItem(u, resourceId, balanceRecords, chargeTime)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/service.go",
        "code_start_line": 294,
        "code_end_line": 367,
        "code_key": "convertToChargeItem",
        "code_value": "func (cbsSrv *CbsSrv) convertToChargeItem(u *user.User, resourceId ResourceId, balanceRecords []*ccdb.CCbsBalance, chargeTime time.Time) *ChargeItem {\n\tsort.Slice(balanceRecords, func(i, j int) bool {\n\t\tif balanceRecords[i].LastBalanceTime.Equal(balanceRecords[j].LastBalanceTime) {\n\t\t\treturn balanceRecords[i].OperationType < balanceRecords[j].OperationType\n\t\t}\n\t\treturn balanceRecords[i].LastBalanceTime.Before(balanceRecords[j].LastBalanceTime)\n\t})\n\n\t// 区分国内站和国际站用户\n\tvar userArea Area\n\tif u.IsI18nUser() {\n\t\tuserArea = AreaI18n\n\t} else {\n\t\tuserArea = AreaChina\n\t}\n\tisGrayUser, err := u.CheckFeature(user.USER_FLAG_CBS_GRAY_USER)\n\tif err != nil {\n\t\tlogs.Error(cbsSrv.ctx).Err(err).Int64(\"appId\", int64(u.AppId)).Msg(\"CHECK_GRAY_USER_ERR\")\n\t\t// 出错时标记为非灰度用户，避免重复推量\n\t\tisGrayUser = false\n\t}\n\n\tchargeItem := &ChargeItem{\n\t\t// FIXME: 需要从配置文件中获取region id\n\t\tRegionId:     cbsSrv.regionId,\n\t\tZoneId:       balanceRecords[0].ZoneID,\n\t\tAppId:        u.AppId,\n\t\tUin:          u.Uin,\n\t\tUserArea:     userArea,\n\t\tIsGrayUser:   isGrayUser,\n\t\tResourceId:   resourceId,\n\t\tResourceArea: cbsSrv.regionArea,\n\t\tItems:        make([]*SubItem, 0, len(balanceRecords)),\n\t\tUpdateKVs:    make([]*UpdateKV, 0, len(balanceRecords)),\n\t}\n\n\t// 虚拟计费条目，用于确定endBalanceTime\n\tendBalanceRecord := &ccdb.CCbsBalance{LastBalanceTime: chargeTime.Add(time.Second * -1)}\n\tallBalances := append(balanceRecords, endBalanceRecord)\n\n\t// 获取云盘信息\n\tfor i, balanceRecord := range allBalances[1:] {\n\t\tbeginBalanceRecord := balanceRecords[i]\n\t\t// 用于组装单个BalanceRecord的subitem\n\t\tstopCharge := cbsSrv.processSingleBalanceRecords(\n\t\t\tchargeItem, beginBalanceRecord, balanceRecord, u, resourceId)\n\t\tif stopCharge {\n\t\t\t// TODO 停止计费。如果后续产生预期外的计费条目，状态也应该置为无效\n\t\t\t// 现在先不处理，避免因bug导致少收费\n\t\t\tbreak\n\t\t}\n\n\t\t// 灰度阶段使用\n\t\tif isGrayUser {\n\t\t\t// 更新balanceRecord\n\t\t\tupdateKV := &UpdateKV{\n\t\t\t\tId:              beginBalanceRecord.ID,\n\t\t\t\tLastBalanceTime: chargeTime,\n\t\t\t\tStatus:          beginBalanceRecord.Status,\n\t\t\t}\n\t\t\tif i != len(balanceRecords)-1 ||\n\t\t\t\t(beginBalanceRecord.OperationType == int(CbsOpReturn) || beginBalanceRecord.OperationType == int(CbsOpConvert)) {\n\t\t\t\tbeginBalanceRecord.Status = 0\n\t\t\t}\n\t\t\tchargeItem.UpdateKVs = append(chargeItem.UpdateKVs, updateKV)\n\t\t}\n\n\t}\n\tif len(chargeItem.Items) == 0 && len(chargeItem.UpdateKVs) == 0 {\n\t\treturn nil\n\t}\n\n\treturn chargeItem\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 341,
        "code_end_line": 414,
        "code_key": "convertToChargeItem",
        "code_value": "func (cbsSrv *CbsSrv) convertToChargeItem(u *user.User, resourceId ResourceId, balanceRecords []*ccdb.CCbsBalance, chargeTime time.Time) *ChargeItem {\n\tsort.Slice(balanceRecords, func(i, j int) bool {\n\t\tif balanceRecords[i].LastBalanceTime.Equal(balanceRecords[j].LastBalanceTime) {\n\t\t\treturn balanceRecords[i].OperationType < balanceRecords[j].OperationType\n\t\t}\n\t\treturn balanceRecords[i].LastBalanceTime.Before(balanceRecords[j].LastBalanceTime)\n\t})\n\n\t// 区分国内站和国际站用户\n\tvar userArea Area\n\tif u.IsI18nUser() {\n\t\tuserArea = AreaI18n\n\t} else {\n\t\tuserArea = AreaChina\n\t}\n\tisGrayUser, err := u.CheckFeature(user.USER_FLAG_CBS_GRAY_USER)\n\tif err != nil {\n\t\tlogs.Error(cbsSrv.ctx).Err(err).Int64(\"appId\", int64(u.AppId)).Msg(\"CHECK_GRAY_USER_ERR\")\n\t\t// 出错时标记为非灰度用户，避免重复推量\n\t\tisGrayUser = false\n\t}\n\n\tchargeItem := &ChargeItem{\n\t\t// FIXME: 需要从配置文件中获取region id\n\t\tRegionId:     cbsSrv.regionId,\n\t\tZoneId:       balanceRecords[0].ZoneID,\n\t\tAppId:        u.AppId,\n\t\tUin:          u.Uin,\n\t\tUserArea:     userArea,\n\t\tIsGrayUser:   isGrayUser,\n\t\tResourceId:   resourceId,\n\t\tResourceArea: cbsSrv.regionArea,\n\t\tItems:        make([]*SubItem, 0, len(balanceRecords)),\n\t\tUpdateKVs:    make([]*UpdateKV, 0, len(balanceRecords)),\n\t}\n\n\t// 虚拟计费条目，用于确定endBalanceTime\n\tendBalanceRecord := &ccdb.CCbsBalance{LastBalanceTime: chargeTime.Add(time.Second * -1)}\n\tallBalances := append(balanceRecords, endBalanceRecord)\n\n\t// 获取云盘信息\n\tfor i, balanceRecord := range allBalances[1:] {\n\t\tbeginBalanceRecord := balanceRecords[i]\n\t\t// 用于组装单个BalanceRecord的subitem\n\t\tstopCharge := cbsSrv.processSingleBalanceRecords(\n\t\t\tchargeItem, beginBalanceRecord, balanceRecord, u, resourceId)\n\t\tif stopCharge {\n\t\t\t// TODO 停止计费。如果后续产生预期外的计费条目，状态也应该置为无效\n\t\t\t// 现在先不处理，避免因bug导致少收费\n\t\t\tbreak\n\t\t}\n\n\t\t// 灰度阶段使用\n\t\tif isGrayUser {\n\t\t\t// 更新balanceRecord\n\t\t\tupdateKV := &UpdateKV{\n\t\t\t\tId:              beginBalanceRecord.ID,\n\t\t\t\tLastBalanceTime: chargeTime,\n\t\t\t\tStatus:          beginBalanceRecord.Status,\n\t\t\t}\n\t\t\tif i != len(balanceRecords)-1 ||\n\t\t\t\t(beginBalanceRecord.OperationType == int(CbsOpReturn) || beginBalanceRecord.OperationType == int(CbsOpConvert)) {\n\t\t\t\tbeginBalanceRecord.Status = 0\n\t\t\t}\n\t\t\tchargeItem.UpdateKVs = append(chargeItem.UpdateKVs, updateKV)\n\t\t}\n\n\t}\n\tif len(chargeItem.Items) == 0 && len(chargeItem.UpdateKVs) == 0 {\n\t\treturn nil\n\t}\n\n\treturn chargeItem\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/domain/measure/service.go",
        "code_start_line": 369,
        "code_end_line": 434,
        "code_key": "processSingleBalanceRecords",
        "code_value": "func (cbsSrv *CbsSrv) processSingleBalanceRecords(chargeItem *ChargeItem, beginBalanceRecord *ccdb.CCbsBalance, endBalanceRecord *ccdb.CCbsBalance, user *user.User, resourceId ResourceId) (stopCharge bool) {\n\tstopCharge = false\n\t// 资源欠费，不收取费用\n\tif beginBalanceRecord.OperationType == int(CbsOpArrearage) {\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"RESOURCE_ARREARAGE\")\n\t\treturn\n\t}\n\t// 资源退还。判断是否为预付费的性能突发场景\n\tif beginBalanceRecord.OperationType == int(CbsOpReturn) || beginBalanceRecord.OperationType == int(CbsOpConvert) {\n\t\t// 判断是否为预付费的性能突发场景.\n\t\t// 获取云盘信息。这里在循环中进行查询，但命中的应该不会很多，放在外层反而会导致每个云盘都被查询\n\t\tdisk, err := cbsSrv.diskRepo.QueryDiskInfoById(cbsSrv.ctx, string(resourceId))\n\t\tif err != nil || disk == nil {\n\t\t\tlogs.Error(cbsSrv.ctx).Err(err).Str(\"resourceId\", string(resourceId)).Msg(\"QUERY_CBS_RECORD_FAILED\")\n\t\t\t// TODO 这里先不返回资源的推量？\n\t\t\treturn true\n\t\t}\n\t\t// TODO 走diskLogical\n\t\tif disk.PayMode == \"prepay\" {\n\t\t\t// 性能突发场景，预付费用户退盘，退盘费用不计\n\t\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"MAYBE_CBS_WITH_BURST_PERFORMANCE\")\n\t\t\treturn\n\t\t}\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"CBS_HAS_RETURNED\")\n\t\treturn true\n\t}\n\n\t// 资源正常\n\tstartTime := beginBalanceRecord.LastBalanceTime\n\tendTime := endBalanceRecord.LastBalanceTime\n\tcurTime := startTime\n\tfor endTime.After(curTime) {\n\t\tcurHourEnd := time.Date(curTime.Year(), curTime.Month(), curTime.Day(), curTime.Hour(), 59, 59, 0, curTime.Location())\n\n\t\tvar config CCbsBalanceConfig\n\t\terr := json.Unmarshal([]byte(beginBalanceRecord.Config), &config)\n\t\tif err != nil {\n\t\t\tlogs.Error(cbsSrv.ctx).Err(err).Msg(\"PARSE_CONFIG_ERROR\")\n\t\t\treturn\n\t\t}\n\n\t\tcurEndTime := endTime\n\t\tcurStarTime := curTime\n\t\tif !endTime.After(curHourEnd) {\n\t\t\t// 同一周期\n\t\t\tcurTime = endTime.Add(time.Second)\n\t\t} else {\n\t\t\tcurEndTime = curHourEnd\n\t\t\tcurTime = curHourEnd.Add(time.Second)\n\t\t}\n\t\tsubItem := &SubItem{\n\t\t\tPid:       beginBalanceRecord.Pid,\n\t\t\tStartTime: curStarTime,\n\t\t\tEndTime:   curEndTime,\n\t\t\tProjectId: beginBalanceRecord.ProjectID,\n\t\t\tParams:    beginBalanceRecord.ResourceInfo,\n\t\t\tSubValueDetail: map[string]interface{}{\n\t\t\t\t// FIXME 性能突发场景待实现\n\t\t\t\t\"Size\":             config.Size,\n\t\t\t\t\"BackupPointQuota\": config.BackupPointQuota,\n\t\t\t},\n\t\t}\n\t\tchargeItem.Items = append(chargeItem.Items, subItem)\n\t}\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/domain/measure/service.go",
        "code_start_line": 416,
        "code_end_line": 481,
        "code_key": "processSingleBalanceRecords",
        "code_value": "func (cbsSrv *CbsSrv) processSingleBalanceRecords(chargeItem *ChargeItem, beginBalanceRecord *ccdb.CCbsBalance, endBalanceRecord *ccdb.CCbsBalance, user *user.User, resourceId ResourceId) (stopCharge bool) {\n\tstopCharge = false\n\t// 资源欠费，不收取费用\n\tif beginBalanceRecord.OperationType == int(CbsOpArrearage) {\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"RESOURCE_ARREARAGE\")\n\t\treturn\n\t}\n\t// 资源退还。判断是否为预付费的性能突发场景\n\tif beginBalanceRecord.OperationType == int(CbsOpReturn) || beginBalanceRecord.OperationType == int(CbsOpConvert) {\n\t\t// 判断是否为预付费的性能突发场景.\n\t\t// 获取云盘信息。这里在循环中进行查询，但命中的应该不会很多，放在外层反而会导致每个云盘都被查询\n\t\tdisk, err := cbsSrv.diskRepo.QueryDiskInfoById(cbsSrv.ctx, string(resourceId))\n\t\tif err != nil || disk == nil {\n\t\t\tlogs.Error(cbsSrv.ctx).Err(err).Str(\"resourceId\", string(resourceId)).Msg(\"QUERY_CBS_RECORD_FAILED\")\n\t\t\t// TODO 这里先不返回资源的推量？\n\t\t\treturn true\n\t\t}\n\t\t// TODO 走diskLogical\n\t\tif disk.PayMode == \"prepay\" {\n\t\t\t// 性能突发场景，预付费用户退盘，退盘费用不计\n\t\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"MAYBE_CBS_WITH_BURST_PERFORMANCE\")\n\t\t\treturn\n\t\t}\n\t\tlogs.Info(cbsSrv.ctx).Uint64(\"appId\", uint64(user.AppId)).Str(\"resourceId\", string(resourceId)).Msg(\"CBS_HAS_RETURNED\")\n\t\treturn true\n\t}\n\n\t// 资源正常\n\tstartTime := beginBalanceRecord.LastBalanceTime\n\tendTime := endBalanceRecord.LastBalanceTime\n\tcurTime := startTime\n\tfor endTime.After(curTime) {\n\t\tcurHourEnd := time.Date(curTime.Year(), curTime.Month(), curTime.Day(), curTime.Hour(), 59, 59, 0, curTime.Location())\n\n\t\tvar config CCbsBalanceConfig\n\t\terr := json.Unmarshal([]byte(beginBalanceRecord.Config), &config)\n\t\tif err != nil {\n\t\t\tlogs.Error(cbsSrv.ctx).Err(err).Msg(\"PARSE_CONFIG_ERROR\")\n\t\t\treturn\n\t\t}\n\n\t\tcurEndTime := endTime\n\t\tcurStarTime := curTime\n\t\tif !endTime.After(curHourEnd) {\n\t\t\t// 同一周期\n\t\t\tcurTime = endTime.Add(time.Second)\n\t\t} else {\n\t\t\tcurEndTime = curHourEnd\n\t\t\tcurTime = curHourEnd.Add(time.Second)\n\t\t}\n\t\tsubItem := &SubItem{\n\t\t\tPid:       beginBalanceRecord.Pid,\n\t\t\tStartTime: curStarTime,\n\t\t\tEndTime:   curEndTime,\n\t\t\tProjectId: beginBalanceRecord.ProjectID,\n\t\t\tParams:    beginBalanceRecord.ResourceInfo,\n\t\t\tSubValueDetail: map[string]interface{}{\n\t\t\t\t// FIXME 性能突发场景待实现\n\t\t\t\t\"Size\":             config.Size,\n\t\t\t\t\"BackupPointQuota\": config.BackupPointQuota,\n\t\t\t},\n\t\t}\n\t\tchargeItem.Items = append(chargeItem.Items, subItem)\n\t}\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/convertor.go",
        "code_start_line": 28,
        "code_end_line": 38,
        "code_key": "Start",
        "code_value": "func (a *Convertor) Start(ctx context.Context) error {\n\t// 启动转换器\n\tfor _, scanner := range a.scanners {\n\t\tscanner := scanner\n\t\tgo func() {\n\t\t\ta.convertToTask(ctx, scanner)\n\t\t}()\n\t}\n\tlogs.Info(ctx).Msgf(\"Convertor Start Success\")\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_rec_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *CbsMeasureReconciliationTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\t//s.resultChan <- struct{}{}\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_rec_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 35,
        "code_key": "Start",
        "code_value": "func (s *SnapMeasureReconciliationTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_compute_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *SnapComputeTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\t//s.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_measure_send_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *CbsMeasureSendTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_bill_valid_appId_fetch_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *CbsValidAppIdFetchTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_calculate_cost_locally_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 36,
        "code_key": "Start",
        "code_value": "func (s *SnapCalculateCostLocallyTaskScanner) Start(ctx context.Context) error {\n\t//s.resultChan <- struct{}{}\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_create_task_scanner.go",
        "code_start_line": 23,
        "code_end_line": 42,
        "code_key": "Start",
        "code_value": "func (s *UpdateCreateTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\trunning := true\n\t\tfor running {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\trunning = false\n\t\t\tdefault:\n\t\t\t\terr := s.FullScan(ctx)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogs.Fatal(ctx).Msgf(\"%s full scan failed!\\n\", s.name)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\ttime.Sleep(s.scanInterval)\n\t\t}\n\t}()\n\tlogs.Info(ctx).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_measure_send_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 36,
        "code_key": "Start",
        "code_value": "func (s *SnapMeasureSendTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\t//s.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/repush_user_billing_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 39,
        "code_key": "Start",
        "code_value": "func (s *RepushUserBillingTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_rollback_task_scanner.go",
        "code_start_line": 23,
        "code_end_line": 42,
        "code_key": "Start",
        "code_value": "func (s *UpdateRollbackTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\trunning := true\n\t\tfor running {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\trunning = false\n\t\t\tdefault:\n\t\t\t\terr := s.FullScan(ctx)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogs.Fatal(ctx).Msgf(\"%s full scan failed!\\n\", s.name)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\ttime.Sleep(s.scanInterval)\n\t\t}\n\t}()\n\tlogs.Info(ctx).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_valid_appId_fetch_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 36,
        "code_key": "Start",
        "code_value": "func (s *SnapValidAppIdFetchTaskScanner) Start(ctx context.Context) error {\n\t//s.resultChan <- struct{}{}\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_bill_compute_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 39,
        "code_key": "Start",
        "code_value": "func (s *CbsBillComputeTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/app/app.go",
        "code_start_line": 31,
        "code_end_line": 39,
        "code_key": "Start",
        "code_value": "func (m *PipelineManager) Start(ctx context.Context) error {\n\tfor region, pipeline := range m.Pipelines {\n\t\tregionCtx := context.WithValue(ctx, \"region\", region)\n\t\tif err := pipeline.Start(regionCtx); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/app/app.go",
        "code_start_line": 46,
        "code_end_line": 51,
        "code_key": "Start",
        "code_value": "func (app *NebulaApp) Start(ctx context.Context) error {\n\tif err := app.pipelineManager.Start(ctx); err != nil {\n\t\treturn err\n\t}\n\treturn <-app.stopChan\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/app/pipeline.go",
        "code_start_line": 20,
        "code_end_line": 46,
        "code_key": "Start",
        "code_value": "func (p *RegionPipeline) Start(ctx context.Context) error {\n\tregion := ctx.Value(\"region\").(string)\n\tscannerLogCtx := initLogger(ctx, region, \"scanner.log\")\n\tfor _, scanner := range p.scanners {\n\t\tsingleCtx := logs.AddDefaultMessage(scannerLogCtx, \"name\", scanner.GetName())\n\t\terr := scanner.Start(singleCtx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tinitMetric(scanner, region, \"scanner\", scanner.GetName())\n\t}\n\n\tconvertorLogCtx := initLogger(ctx, region, \"convertor.log\")\n\terr := p.convertor.Start(convertorLogCtx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// start scheduler\n\tschedulerLogCtx := initLogger(ctx, region, \"scheduler.log\")\n\terr = p.scheduler.Start(schedulerLogCtx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tinitMetric(p.scheduler, region, \"scheduler\", \"scheduler\")\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go",
        "code_start_line": 109,
        "code_end_line": 112,
        "code_key": "Start",
        "code_value": "func (sc *Scheduler) Start(ctx context.Context) error {\n\tgo sc.mainLoop(ctx)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/scheduler.go",
        "code_start_line": 154,
        "code_end_line": 191,
        "code_key": "Start",
        "code_value": "func (s *scheduler) Start(ctx context.Context) error {\n\twg := sync.WaitGroup{}\n\trunning := true\n\tgo s.haManager.Start(ctx)\n\tdefer s.haManager.Close(ctx)\n\tfor {\n\t\tselect {\n\t\tcase taskName := <-s.eventChan:\n\t\t\twg.Add(1)\n\t\t\tgo func(name string) {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tif task, ok := s.loads[name]; ok {\n\n\t\t\t\t\tif s.isMaster {\n\t\t\t\t\t\t_ctx := logs.With(ctx).Str(\"seqId\", uuid.New().String()).Str(\"taskName\", name).Logger().WithContext(ctx)\n\t\t\t\t\t\ttask.Work(_ctx)\n\t\t\t\t\t}\n\n\t\t\t\t\ttriggerTime := time.Now().Add(task.Interval())\n\t\t\t\t\tfor {\n\t\t\t\t\t\tif !running {\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif time.Now().After(triggerTime) {\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttime.Sleep(time.Second)\n\t\t\t\t\t}\n\t\t\t\t\ts.eventChan <- name\n\t\t\t\t}\n\t\t\t}(taskName)\n\t\tcase <-s.stopChan:\n\t\t\trunning = false\n\t\t\twg.Wait()\n\t\t\treturn nil\n\t\t}\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/easyha/model.go",
        "code_start_line": 108,
        "code_end_line": 180,
        "code_key": "Start",
        "code_value": "func (m *haManagerImpl) Start(ctx context.Context) {\n\tm.keepRunning = true\n\tm.ctx = ctx\n\tvar (\n\t\tmyIdentity            = m.delegate.GetIdentity()                                    // 当前节点的业务标识\n\t\tmyKey                 = fmt.Sprintf(\"easyhaMaster/%s\", url.PathEscape(m.namespace)) // 分布式锁的key\n\t\tmyToken               = m.encodeToken(myIdentity)                                   // 分布式锁 Token，包含业务标识和随机信息\n\t\tmyLock                dlock.Lock                                                    // 获取到的分布式锁, 用于刷新和释放\n\t\tcurrentMasterIdentity string                                                        // 当前 master 的业务标识，如果为空则是还未获取过当前 master\n\t)\n\n\t// Start slave loop.\n\tfor m.keepRunning {\n\t\t// Try observe the master lock first.\n\t\tif view, err := m.locker.Observe(ctx, myKey); err != nil {\n\t\t\tm.logger.Info().Err(err).Str(\"key\", myKey).Msg(\"failed to observe current master lock\")\n\t\t\t// Failed to observe the master lock, try to  obtain the lock.\n\t\t\tmyLock, err = m.locker.Obtain(ctx, dlock.NewWriteLockKey(myKey), m.lockExpired, &dlock.Option{Token: myToken})\n\t\t\tif err == nil {\n\t\t\t\t// Successfully obtained the lock.\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tnewIdentity, err := m.decodeToken(view.Token)\n\t\t\tif err != nil {\n\t\t\t\tm.logger.Warn().Err(err).Str(\"token\", view.Token).Msg(\"failed to decode token\")\n\t\t\t} else if currentMasterIdentity == \"\" {\n\t\t\t\t// First time to observe the master.\n\t\t\t\tcurrentMasterIdentity = newIdentity\n\t\t\t\tif err := m.delegate.OnBecomeSlave(ctx, currentMasterIdentity); err != nil {\n\t\t\t\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle become slave, force quit for safety\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if currentMasterIdentity != newIdentity {\n\t\t\t\t// Master changed. Need update.\n\t\t\t\tcurrentMasterIdentity = newIdentity\n\t\t\t\tif err := m.delegate.OnSwitchMaster(ctx, currentMasterIdentity); err != nil {\n\t\t\t\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle switch master, force quit for safety\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttime.Sleep(m.checkInterval)\n\t}\n\n\tif myLock == nil {\n\t\tm.logger.Fatal().Msg(\"myLock is nil, found bug, force quit for safety\")\n\t\treturn\n\t}\n\n\t// I am the master now.\n\tif err := m.delegate.OnBecomeMaster(ctx); err != nil {\n\t\tmyLock.Release(ctx)\n\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle become master, force quit for safety\")\n\t\treturn\n\t}\n\n\tdefer func() {\n\t\tmyLock.Release(ctx)\n\t\tif err := m.delegate.OnLostMaster(ctx); err != nil {\n\t\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle lost master, force quit for safety\")\n\t\t}\n\t}()\n\n\t// Start the master loop.\n\tfor m.keepRunning {\n\t\ttime.Sleep(m.checkInterval)\n\t\tif err := myLock.Refresh(ctx, m.lockExpired); err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_bill_compute_task.go",
        "code_start_line": 63,
        "code_end_line": 113,
        "code_key": "ProcessUserSnapResources",
        "code_value": "func (t *SnapBillComputeTask) ProcessUserSnapResources(user *user.User, snapIds []measure.ResourceId) {\n\tsnapSrv := t.ResSrv.(*measure.SnapSrv)\n\t// 不同用户的资源数是不一致的，这里顺序处理的话性能一般，需要放在协程中跑\n\t// 单个用户最多启动100个协程，避免协程过多\n\tvar wg sync.WaitGroup\n\tsemaphore := make(chan struct{}, 100)\n\tchargeTimeFromSnapshot := snapSrv.GetSnapRealChargeTimes(user.AppId, t.ChargeTime)\n\n\tfor _, snapId := range snapIds {\n\t\twg.Add(1)\n\t\tgo func(snapId measure.ResourceId) {\n\t\t\tdefer wg.Done()\n\t\t\t// 这里可以控制启动的协程数\n\t\t\tsemaphore <- struct{}{}\n\t\t\tdefer func() { <-semaphore }()\n\n\t\t\tlogs.Info(t.Ctx).\n\t\t\t\tUint64(\"app_id\", uint64(user.AppId)).\n\t\t\t\tStr(\"snap_id\", string(snapId)).\n\t\t\t\tMsg(\"PROCESS_SIGNAL_SNAP\")\n\t\t\t// 计费真正的结算时间：若快照deadline时间晚于结算时间，则结算时间=快照deadline\n\t\t\tchargeTime, ok := chargeTimeFromSnapshot[snapId]\n\t\t\tif !ok {\n\t\t\t\tchargeTime = t.ChargeTime\n\t\t\t}\n\n\t\t\tchargeItem := snapSrv.BuildResChargeItem(user, snapId, chargeTime)\n\t\t\tif chargeItem == nil {\n\t\t\t\t// 可能是资源不需要计费。这里需要把资源Id从UnConfirmedMap中删除\n\t\t\t\tt.MarkSingleResDone(user.AppId, snapId)\n\t\t\t\tlogs.Info(t.Ctx).Uint64(\"appId\", uint64(user.AppId)).\n\t\t\t\t\tStr(\"snapId\", string(snapId)).Msg(\"SKIP_SNAP\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tchargeItemMsg := mqimpl.NewMessage(mq.MSGTYPE_JSON, chargeItem)\n\t\t\terr := t.ChargeItemProducer.Publish(chargeItemMsg)\n\t\t\tlogs.Info(t.Ctx).\n\t\t\t\tUint64(\"appId\", uint64(user.AppId)).\n\t\t\t\tStr(\"snap_id\", string(snapId)).\n\t\t\t\tMsg(\"PUBLISH_CHARGE_ITEM\")\n\t\t\tif err != nil {\n\t\t\t\tlogs.Error(t.Ctx).Err(err).\n\t\t\t\t\tUint64(\"appId\", uint64(user.AppId)).\n\t\t\t\t\tStr(\"snapId\", string(snapId)).\n\t\t\t\t\tMsg(\"PUBLISH_CHARGE_ITEM_FAILED\")\n\t\t\t}\n\t\t}(snapId)\n\t}\n\twg.Wait()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/task.go",
        "code_start_line": 25,
        "code_end_line": 32,
        "code_key": "UpdateExecuteTime",
        "code_value": "func (t *Task) UpdateExecuteTime(ctx context.Context) {\n\tinterval := t.Interval * time.Duration(t.Count)\n\tif interval >= t.MaxInterval {\n\t\tinterval = t.MaxInterval\n\t}\n\t// 这里应该是执行完成的时间加上等待时间\n\tt.NextTriggerTime = time.Now().Add(time.Second * interval)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/cbs_bill_compute_task.go",
        "code_start_line": 64,
        "code_end_line": 90,
        "code_key": "ProcessUserCbsResources",
        "code_value": "func (t *CbsBillComputeTask) ProcessUserCbsResources(user *user.User, resIds []measure.ResourceId) {\n\tcbsSrv := t.ResSrv.(*measure.CbsSrv)\n\t// 不同用户的资源数是不一致的，这里顺序处理的话性能一般，需要放在协程中跑\n\t// 单个用户最多启动100个协程，避免协程过多\n\tvar wg sync.WaitGroup\n\tfor _, cbsInstanceId := range resIds {\n\t\twg.Add(1)\n\t\tgo func(cbsInstanceId measure.ResourceId) {\n\t\t\tdefer wg.Done()\n\t\t\t// 并发的控制策略: 同时处理的用户不超过t.Concurrency个，所有用户共享t.Concurrency * 100个协程\n\t\t\t// 这样设计的目的是为了规避用户资源倾斜严重的问题，同时也能保证用户的并发度较少\n\t\t\tt.ResSemaphore <- struct{}{}\n\t\t\tdefer func() {\n\t\t\t\t<-t.ResSemaphore\n\t\t\t}()\n\n\t\t\tlogs.Info(t.Ctx).\n\t\t\t\tUint64(\"appId\", uint64(user.AppId)).\n\t\t\t\tStr(\"cbsInstanceId\", string(cbsInstanceId)).\n\t\t\t\tMsg(\"PROCESS_SIGNAL_DISK\")\n\n\t\t\tchargeItem := cbsSrv.BuildResChargeItem(user, cbsInstanceId, t.ChargeTime)\n\t\t\tt.ProcessSingleChargeItem(user, cbsInstanceId, chargeItem)\n\t\t}(cbsInstanceId)\n\t}\n\twg.Wait()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/repush_user_billing_task.go",
        "code_start_line": 103,
        "code_end_line": 172,
        "code_key": "ProcessSingleRepushDetail",
        "code_value": "func (t *RepushUserBillingTask) ProcessSingleRepushDetail(detail *measure.RepushDetail) error {\n\tcbsMeasureRepo := registry.GetRegistry(t.ctx).AdapterRepos.CbsMeasureRepo.(measure.CbsMeasureRepoIFace)\n\tappIdResIdMaps := make(map[user.AppId][]measure.ResourceId)\n\tif detail.AppId > 0 {\n\t\tif len(detail.ResIds) > 0 {\n\t\t\tappIdResIdMaps[detail.AppId] = detail.ResIds\n\t\t} else {\n\t\t\tids, err := cbsMeasureRepo.GetResourceIdsByAppId(t.ctx, int64(detail.AppId), time.Time{}, true, cbsMeasureRepo.GetBalanceTableName())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tresIds := make([]measure.ResourceId, 0, len(ids))\n\t\t\tfor _, resId := range ids {\n\t\t\t\tresIds = append(resIds, measure.ResourceId(resId))\n\t\t\t}\n\t\t\tappIdResIdMaps[detail.AppId] = resIds\n\t\t}\n\t} else {\n\t\tif len(detail.ResIds) > 0 {\n\t\t\treturn fmt.Errorf(\"AppId is required when ResIds is set\")\n\t\t}\n\t\tlogs.Info(t.ctx).Msg(\"REPUSH_ALL_FOR_APPID_NOT_SET\")\n\t\tappIds, _ := cbsMeasureRepo.GetAppIdsWithResources(t.ctx, time.Time{}, true, cbsMeasureRepo.GetBalanceTableName())\n\t\tfor _, appId := range appIds {\n\t\t\t// 没有指定资源，则补量所有资源\n\t\t\tids, err := cbsMeasureRepo.GetResourceIdsByAppId(t.ctx, appId, time.Time{}, true, cbsMeasureRepo.GetBalanceTableName())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tresIds := make([]measure.ResourceId, 0, len(ids))\n\t\t\tfor _, resId := range ids {\n\t\t\t\tresIds = append(resIds, measure.ResourceId(resId))\n\t\t\t}\n\t\t\tappIdResIdMaps[user.AppId(appId)] = resIds\n\t\t}\n\n\t}\n\n\tvar repushItems []*RepushItem\n\tfor appId, resIds := range appIdResIdMaps {\n\t\tu, err := t.userSrv.GetUser(appId)\n\t\tif err != nil {\n\t\t\t// 这里可能是新注册的用户，user表里没有用户数据，可能会丢失该用户的量\n\t\t\tlogs.Error(t.ctx).Err(err).Uint64(\"appId\", uint64(appId)).Msg(\"GET_USER_ERROR\")\n\t\t\tpanic(err)\n\t\t}\n\t\tfor _, resId := range resIds {\n\t\t\tvar repushItem RepushItem\n\t\t\trepushItem.user = u\n\t\t\trepushItem.cbsInstanceId = resId\n\t\t\trepushItem.startTime = detail.StartTime\n\t\t\trepushItem.endTime = detail.EndTime\n\t\t\trepushItems = append(repushItems, &repushItem)\n\t\t}\n\t}\n\tlogs.Info(t.ctx).Int(\"count\", len(repushItems)).Msg(\"REPUSH_ITEMS_INFO\")\n\n\tvar wg sync.WaitGroup\n\tfor _, repushItem := range repushItems {\n\t\twg.Add(1)\n\t\tt.semaphore <- struct{}{}\n\t\tgo func(item *RepushItem) {\n\t\t\tdefer wg.Done()\n\t\t\tdefer func() { <-t.semaphore }()\n\t\t\tt.ProcessSingleRepushItem(item)\n\t\t}(repushItem)\n\t}\n\twg.Wait()\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/cbs_measure_send_task.go",
        "code_start_line": 56,
        "code_end_line": 81,
        "code_key": "ProcessMsgByRegion",
        "code_value": "func (t *CbsMeasureSendTask) ProcessMsgByRegion() {\n\t// 并发处理消息\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < t.Conf.Concurrency; i++ {\n\t\twg.Add(1)\n\t\tgo func(workId int) {\n\t\t\tlog.Infof(\"start work %d\", workId)\n\t\t\tdefer wg.Done()\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase msg, ok := <-t.DomesticChan:\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.ProcessMsgToMeasureDetail(msg)\n\t\t\t\tcase <-t.Ctx.Done():\n\t\t\t\t\tlogs.Info(t.Ctx).Int(\"work_id\", workId).Msg(\"STOP_WORKER\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n\t// 关闭chan\n\twg.Wait()\n\tclose(t.MeasureDetailChan)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_measure_send_task.go",
        "code_start_line": 51,
        "code_end_line": 76,
        "code_key": "ProcessMsgByRegion",
        "code_value": "func (t *SnapMeasureSendTask) ProcessMsgByRegion() {\n\t// 并发处理消息\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < t.Conf.Concurrency; i++ {\n\t\twg.Add(1)\n\t\tgo func(workId int) {\n\t\t\tlog.Infof(\"start work %d\", workId)\n\t\t\tdefer wg.Done()\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase msg, ok := <-t.DomesticChan:\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.ProcessMsgToMeasureDetail(msg)\n\t\t\t\tcase <-t.Ctx.Done():\n\t\t\t\t\tlogs.Info(t.Ctx).Int(\"work_id\", workId).Msg(\"STOP_WORKER\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n\t// 关闭chan\n\twg.Wait()\n\tclose(t.MeasureDetailChan)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/cbs_rec_task.go",
        "code_start_line": 111,
        "code_end_line": 136,
        "code_key": "ProcessMsg",
        "code_value": "func (t *CbsMeasureRecTask) ProcessMsg() {\n\t// 并发处理消息\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < t.Conf.Concurrency; i++ {\n\t\twg.Add(1)\n\t\tgo func(workId int) {\n\t\t\tlog.Infof(\"start work %d\", workId)\n\t\t\tdefer wg.Done()\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase msg, ok := <-t.DomesticChan:\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.ProcessMsgToMeasure(msg)\n\t\t\t\tcase <-t.Ctx.Done():\n\t\t\t\t\tlogs.Info(t.Ctx).Int(\"work_id\", workId).Msg(\"STOP_WORKER\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n\t// 关闭chan\n\twg.Wait()\n\tclose(t.CbsMeasureDetailChan)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_rec_task.go",
        "code_start_line": 63,
        "code_end_line": 105,
        "code_key": "sendDbFromMsg",
        "code_value": "func (t *SnapMeasureReconciliationTask) sendDbFromMsg(wg *sync.WaitGroup) {\n\t// 并发处理消息\n\n\tfor i := 0; i < t.Concurrency; i++ {\n\t\twg.Add(1)\n\t\tgo func(workId int) {\n\t\t\tlog.Infof(\"start work %d\", workId)\n\t\t\tdefer wg.Done()\n\t\t\tunConfirmedMap := make(map[measure.ResourceId]mqiface.IMessage)\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase msg := <-t.snapChargeItemForCompareConsumer.Receiving(mq.MSGTYPE_JSON):\n\t\t\t\t\tchargeItem, _ := parseChargeItem(msg)\n\t\t\t\t\tresourceId := chargeItem.ResourceId\n\t\t\t\t\tunConfirmedMap[resourceId] = msg\n\n\t\t\t\t\t// 达到指定数量后进行数据库同步\n\t\t\t\t\tif len(unConfirmedMap) == 100 {\n\t\t\t\t\t\tlog.Infof(\"unConfirmedMap num %d\", len(unConfirmedMap))\n\t\t\t\t\t\terr := t.ProcessMsgSendMeasure(t.ctx, unConfirmedMap)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tjsonData, _ := json.Marshal(unConfirmedMap)\n\t\t\t\t\t\t\tlogs.Error(t.ctx).Err(err).Str(\"process_msg_send_measure_failed\", string(jsonData)).Msg(\"BATCH_PROCESS_SEND_MEASURE_FAILED\")\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\tcase <-time.After(5 * time.Second):\n\t\t\t\t\tif len(unConfirmedMap) > 0 {\n\t\t\t\t\t\tlogs.Info(t.ctx).Int(\"time_out_process_msg_nums\", len(unConfirmedMap)).Msg(\"TIME_OUT_PROCESS_MSG\")\n\t\t\t\t\t\terr := t.ProcessMsgSendMeasure(t.ctx, unConfirmedMap)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tjsonData, _ := json.Marshal(unConfirmedMap)\n\t\t\t\t\t\t\tlogs.Error(t.ctx).Err(err).Str(\"send_fail_detail\", string(jsonData)).Msg(\"TIMEOUT_PROCESS_SEND_MEASURE_FAILED\")\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tcase <-t.ctx.Done():\n\t\t\t\t\tlogs.Info(t.ctx).Int(\"work_id\", workId).Msg(\"STOP_WORKER\")\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/snap_rec_task.go",
        "code_start_line": 134,
        "code_end_line": 150,
        "code_key": "AckResourceID",
        "code_value": "func (t *SnapMeasureReconciliationTask) AckResourceID() {\n\t// Ack逻辑：AppId关联的所有ChargeItem全部都confirmed了才触发对AppId的Ack\n\tgo func() {\n\t\tfor {\n\t\t\tt.m.Lock()\n\t\t\tfor resourceId := range t.ResourceIdMsgMap {\n\t\t\t\tt.snapChargeItemForCompareConsumer.Ack(t.ResourceIdMsgMap[resourceId])\n\t\t\t\tdelete(t.ResourceIdMsgMap, resourceId)\n\t\t\t\tlogs.Info(t.ctx).Str(\"resource_id\", string(resourceId)).Str(\"resource_id\", string(resourceId)).Msg(\"ACK_RESOURCE_ID\")\n\t\t\t}\n\t\t\tt.m.Unlock()\n\n\t\t\ttime.Sleep(time.Microsecond * 100)\n\t\t}\n\t}()\n\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/base_measure/base_send_measure_task.go",
        "code_start_line": 140,
        "code_end_line": 159,
        "code_key": "AckResourceID",
        "code_value": "func (t *BaseSendMeasureTask) AckResourceID() {\n\t// Ack逻辑：AppId关联的所有ChargeItem全部都confirmed了才触发ACK\n\tt.WG.Add(1)\n\tdefer t.WG.Done()\n\tgo func() {\n\t\tfor {\n\t\t\tt.m.Lock()\n\t\t\tfor resourceId, msgList := range t.unConfirmedMap {\n\t\t\t\tlogs.Info(t.ctx).Str(\"resourceId\", string(resourceId)).Int(\"size\", len(msgList)).Fields(t.unConfirmedMap).Msg(\"CHECK_RESOURCE_ID_CONFIRMED\")\n\t\t\t\tif len(msgList) == 0 {\n\t\t\t\t\tdelete(t.unConfirmedMap, resourceId)\n\t\t\t\t\tt.AckMessage(string(resourceId))\n\t\t\t\t}\n\t\t\t}\n\t\t\tt.m.Unlock()\n\t\t\ttime.Sleep(time.Millisecond * 100)\n\t\t}\n\t}()\n\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/base_measure/base_send_measure_task.go",
        "code_start_line": 261,
        "code_end_line": 313,
        "code_key": "ProcessParamsSendMeasure",
        "code_value": "func (t *BaseSendMeasureTask) ProcessParamsSendMeasure() {\n\tvar wg sync.WaitGroup\n\tsemaphore := make(chan struct{}, 100) // Semaphore with a capacity of 100\n\n\tfor {\n\t\tselect {\n\t\tcase param, ok := <-t.MeasureParamChan:\n\t\t\tif !ok {\n\t\t\t\tlogs.Info(t.Ctx).Msg(\"MEASURE_DETAIL_CHAN_CLOSED\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\twg.Add(1) // Increment the WaitGroup counter\n\n\t\t\tgo func(param interface{}) {\n\t\t\t\tdefer wg.Done() // Decrement the WaitGroup counter when the goroutine completes\n\n\t\t\t\tsemaphore <- struct{}{}        // Acquire a semaphore slot\n\t\t\t\tdefer func() { <-semaphore }() // Release the semaphore slot\n\n\t\t\t\t// Convert param to paraMap\n\t\t\t\tparaMap := make(map[string]interface{})\n\t\t\t\tdata, _ := json.Marshal(param)\n\t\t\t\t_ = json.Unmarshal(data, &paraMap)\n\n\t\t\t\t_, err := t.SendMeasureData(t.Ctx, paraMap)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogs.Info(t.Ctx).Any(\"param\", paraMap).Msg(\"SEND_MEASURE_DATA_ERROR\")\n\t\t\t\t}\n\n\t\t\t\t// Process measureDetail and subMeasureDetail\n\t\t\t\tmeasureDetail := paraMap[\"measureDetail\"].([]interface{})\n\t\t\t\tfor _, measureDetail := range measureDetail {\n\t\t\t\t\tmeasureMap := measureDetail.(map[string]interface{})\n\t\t\t\t\tserialId := measureMap[\"serialId\"].(string)\n\t\t\t\t\tsubMeasureDetail := measureMap[\"subMeasureDetail\"].([]interface{})\n\n\t\t\t\t\tfor _, subMeasure := range subMeasureDetail {\n\t\t\t\t\t\tsubMeasureMap := subMeasure.(map[string]interface{})\n\t\t\t\t\t\tdosageId := subMeasureMap[\"dosageId\"].(string)\n\t\t\t\t\t\tt.MarkMeasureDetailDone(measure.ResourceId(serialId), measure.DosageId(dosageId))\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}(param)\n\n\t\tcase <-t.Ctx.Done():\n\t\t\tlogs.Info(t.Ctx).Msg(\"CTX_DONE\")\n\t\t\twg.Wait() // Wait for all goroutines to complete\n\t\t\treturn\n\t\t}\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/base_measure/base_bill_compute_task.go",
        "code_start_line": 76,
        "code_end_line": 122,
        "code_key": "GetUserResources",
        "code_value": "func (t *BaseBillComputeTask) GetUserResources() {\n\t// 启动多个worker用来处理单用户的快照资源\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < t.userConcurrency; i++ {\n\t\twg.Add(1)\n\t\tgo func(workId int) {\n\t\t\tdefer wg.Done()\n\t\t\tlogs.Info(t.ctx).Int(\"workId\", workId).Msg(\"START_WORKER\")\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase msg, ok := <-t.AppIdConsumer.Receiving(mq.MSGTYPE_TEXT):\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\tlogs.Error(t.ctx).Msg(\"STOP_WORKER\")\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tappId, _ := parseAppId(msg)\n\t\t\t\t\tu, err := t.userSrv.GetUser(appId)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t// 这里可能是新注册的用户，user表里没有用户数据，可能会丢失该用户的量\n\t\t\t\t\t\tlogs.Error(t.ctx).Err(err).Uint64(\"appId\", uint64(appId)).Msg(\"PROCESS_SIGNAL_USER_FAILED\")\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\tt.AddToAckMessage(strconv.FormatUint(uint64(appId), 10), msg)\n\t\t\t\t\terr = t.ProcessSingleUser(u)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlogs.Error(t.ctx).Err(err).Uint64(\"appId\", uint64(appId)).Msg(\"PROCESS_SIGNAL_USER_FAILED\")\n\t\t\t\t\t}\n\t\t\t\tcase <-t.ctx.Done():\n\t\t\t\t\tlogs.Info(t.ctx).Int(\"workId\", workId).Msg(\"STOP_WORKER\")\n\t\t\t\t\treturn\n\t\t\t\tcase <-time.After(time.Second * 10):\n\t\t\t\t\tlogs.Debug(t.ctx).Int(\"workId\", workId).Msg(\"WAIT_MSG_TIMEOUT\")\n\t\t\t\t\t// 队列为空，也没有待Confirm数据的数据\n\t\t\t\t\tif t.AppIdConsumer.QueueIsEmpty() && len(t.unConfirmedMap) == 0 {\n\t\t\t\t\t\tlogs.Info(t.ctx).Int(\"workId\", workId).Msg(\"STOP_WORKER_FOR_QUEUE_EMPTY\")\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}(i)\n\t}\n\t// 关闭chan\n\twg.Wait()\n\tclose(t.UserResChan)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/task/base_measure/base_bill_compute_task.go",
        "code_start_line": 175,
        "code_end_line": 215,
        "code_key": "AckAppId",
        "code_value": "func (t *BaseBillComputeTask) AckAppId() {\n\tt.WG.Add(1)\n\tdefer t.WG.Done()\n\t// Ack逻辑：AppId关联的所有ChargeItem全部都confirmed了才触发对AppId的Ack\n\tgo func() {\n\t\tfor {\n\t\t\tt.m.Lock()\n\t\t\tfor appId, msgList := range t.unConfirmedMap {\n\t\t\t\tlogs.Info(t.ctx).Uint64(\"appId\", uint64(appId)).Int(\"size\", len(msgList)).Fields(t.unConfirmedMap).Msg(\"CHECK_APPID_CONFIRMED\")\n\t\t\t\tif len(msgList) == 0 {\n\t\t\t\t\tt.AckMessage(strconv.FormatUint(uint64(appId), 10))\n\t\t\t\t\tdelete(t.unConfirmedMap, appId)\n\t\t\t\t}\n\t\t\t}\n\t\t\tt.m.Unlock()\n\t\t\ttime.Sleep(time.Millisecond * 100)\n\t\t}\n\t}()\n\n\t// Confirm逻辑，确认chargeItem放入队列后，将chargeItem关联的resourceId从未确认map中删除\n\tfor confirm := range t.ChargeItemProducer.Confirm() {\n\t\tt.WG.Add(1)\n\t\tchargeItem := confirm.GetData().(*measure.ChargeItem)\n\t\tif confirm.GetPublishResult() != mq.PUBLISH_RESULT_SUCCESS {\n\t\t\t// 告警出来，后期补量，部分成功不好处理\n\t\t\tlogs.Error(t.ctx).Any(\"chargeItem\", chargeItem).Msg(\"CHARGE_ITEM_PUBLISH_FAILED\")\n\t\t\tcontinue\n\t\t}\n\t\t// 到这里就代表chargeItem已经发送到队列，理论上不会漏推\n\t\t// FIXME 可能会导致重复推量\n\t\tgo func(innerChargeItem *measure.ChargeItem) {\n\t\t\tdefer t.WG.Done()\n\t\t\terr := t.ResSrv.UpdateResBalanceRecords(innerChargeItem.AppId, innerChargeItem)\n\t\t\tif err != nil {\n\t\t\t\tlogs.Error(t.Ctx).Err(err).Uint64(\"appId\", uint64(innerChargeItem.AppId)).\n\t\t\t\t\tStr(\"resourceId\", string(innerChargeItem.ResourceId)).Msg(\"UPDATE_CBS_BALANCE_RECORD_FAILED\")\n\t\t\t}\n\t\t}(chargeItem)\n\t\tt.MarkSingleResDone(chargeItem.AppId, chargeItem.ResourceId)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_rec_task_scanner.go",
        "code_start_line": 39,
        "code_end_line": 41,
        "code_key": "FullScan",
        "code_value": "func (s *CbsMeasureReconciliationTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_rec_task_scanner.go",
        "code_start_line": 37,
        "code_end_line": 39,
        "code_key": "FullScan",
        "code_value": "func (s *SnapMeasureReconciliationTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_compute_task_scanner.go",
        "code_start_line": 39,
        "code_end_line": 41,
        "code_key": "FullScan",
        "code_value": "func (s *SnapComputeTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_measure_send_task_scanner.go",
        "code_start_line": 39,
        "code_end_line": 41,
        "code_key": "FullScan",
        "code_value": "func (s *CbsMeasureSendTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_bill_valid_appId_fetch_task_scanner.go",
        "code_start_line": 39,
        "code_end_line": 41,
        "code_key": "FullScan",
        "code_value": "func (s *CbsValidAppIdFetchTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_calculate_cost_locally_task_scanner.go",
        "code_start_line": 38,
        "code_end_line": 40,
        "code_key": "FullScan",
        "code_value": "func (s *SnapCalculateCostLocallyTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_create_task_scanner.go",
        "code_start_line": 50,
        "code_end_line": 78,
        "code_key": "FullScan",
        "code_value": "func (s *UpdateCreateTaskScanner) FullScan(ctx context.Context) error {\n\tsnapRepo := registry.GetRegistry(ctx).AdapterRepos.SnapRepo.(adapter_interfaces.SnapInterface)\n\tsnapList, err := snapRepo.QueryCreatingCopyingSnapList(ctx)\n\tif err != nil {\n\t\tlogs.Error(ctx).Err(err).Msg(\"FULL_SCAN_FAILED\")\n\t\treturn err\n\t}\n\tresultCnt := 0\n\tfor _, snapRecord := range snapList {\n\t\t// 剔除快照组预生成的快照记录\n\t\tif strings.Contains(snapRecord.SnapUuid, \"temp\") {\n\t\t\tlogs.Info(ctx).Str(\"SnapId\", snapRecord.SnapInstanceId).Msgf(\"PRE_CREATED_SNAPSHOT_SKIP_UPDATE\")\n\t\t\tcontinue\n\t\t}\n\n\t\tentity := &snapLogical.Entity{\n\t\t\tSnapRecord: snapRecord,\n\t\t}\n\t\tsnapAggregate := &snapLogical.SnapCreateTaskAggregate{\n\t\t\tEntity:      entity,\n\t\t\tTaskName:    core.UpdateCreateTask,\n\t\t\tSubTaskName: core.UpdateCreateTask,\n\t\t}\n\t\ts.resultChan <- snapAggregate\n\t\tresultCnt += 1\n\t}\n\ts.resultChanMetric.Add(float64(resultCnt))\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_measure_send_task_scanner.go",
        "code_start_line": 38,
        "code_end_line": 40,
        "code_key": "FullScan",
        "code_value": "func (s *SnapMeasureSendTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/repush_user_billing_task_scanner.go",
        "code_start_line": 41,
        "code_end_line": 43,
        "code_key": "FullScan",
        "code_value": "func (s *RepushUserBillingTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_rollback_task_scanner.go",
        "code_start_line": 103,
        "code_end_line": 113,
        "code_key": "FullScan",
        "code_value": "func (s *UpdateRollbackTaskScanner) FullScan(ctx context.Context) error {\n\tif err := s.getCCbsRollbackTask(ctx); err != nil {\n\t\tlogs.Error(ctx).Err(err).Msg(\"FULL_SCAN_FAILED\")\n\t\treturn err\n\t}\n\tif err := s.getImageSnapRollbackTask(ctx); err != nil {\n\t\tlogs.Error(ctx).Err(err).Msg(\"FULL_SCAN_FAILED\")\n\t\treturn err\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_valid_appId_fetch_task_scanner.go",
        "code_start_line": 38,
        "code_end_line": 40,
        "code_key": "FullScan",
        "code_value": "func (s *SnapValidAppIdFetchTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_bill_compute_task_scanner.go",
        "code_start_line": 41,
        "code_end_line": 43,
        "code_key": "FullScan",
        "code_value": "func (s *CbsBillComputeTaskScanner) FullScan(ctx context.Context) error {\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/client/client.go",
        "code_start_line": 20,
        "code_end_line": 62,
        "code_key": "Request",
        "code_value": "func (c *BaseClient) Request(ctx context.Context, interfaceName string, reqJsonData []byte) ([]byte, error) {\n\tlogger := logs.With(ctx).Str(\"interface\", interfaceName).Logger()\n\tlogger.Info().Str(\"para\", string(reqJsonData)).Msg(\"NEW_REQUEST\")\n\n\tctx, cancel := context.WithTimeout(ctx, time.Second*time.Duration(c.Timeout))\n\tdefer cancel()\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPost, c.Url, bytes.NewReader(reqJsonData))\n\n\tif global.TestEnv {\n\t\treq.Header.Add(\"X-QCloud-Transaction-ID\", uuid.New().String())\n\t\treq.Header.Add(\"X-QCloud-User-ID\", global.TestUin)\n\t}\n\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"new request failed: %v\", err)\n\t}\n\theader := \"\"\n\tfor key, value := range req.Header {\n\t\theader += fmt.Sprintf(\"-H \\\"%s: %s\\\" \", key, value[0])\n\t}\n\tcurl := fmt.Sprintf(\"curl %s --connect-timeout %d -d '%s' %s\", header, c.Timeout, string(reqJsonData), c.Url)\n\tlogger.Info().Any(\"cmd\", curl).Msgf(\"SHOW_CURL_CMD\")\n\n\trsp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\tlogger.Error().Err(err).Msgf(\"RESPONSE_ERR\")\n\t\treturn nil, fmt.Errorf(\"do request failed: %v\", err)\n\t}\n\tdefer func(Body io.ReadCloser) {\n\t\t_ = Body.Close()\n\t}(rsp.Body)\n\n\tif rsp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"unexpected status code: %d\", rsp.StatusCode)\n\t}\n\tbodyData, err := io.ReadAll(rsp.Body)\n\tlogger.Info().Any(\"response\", string(bodyData)).Msgf(\"SHOW_RESPONSE\")\n\tif err != nil {\n\t\tlogger.Error().Err(err).Msgf(\"RESPONSE_ERR\")\n\t\treturn nil, err\n\t}\n\treturn bodyData, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go",
        "code_start_line": 83,
        "code_end_line": 103,
        "code_key": "AddTask",
        "code_value": "func (sc *Scheduler) AddTask(ctx context.Context, newTask interfaces.Task) {\n\tvalue, ok := sc.taskMap.Load(newTask.GetTaskId())\n\tif !ok {\n\t\tsc.syncTaskPriorityQueue.Push(newTask)\n\t\tsc.taskMap.Store(newTask.GetTaskId(), newTask)\n\t\tsc.addTimerEvent(newTask.GetTaskId())\n\t\tsc.metrics.taskCountInQueue.Add(1)\n\t} else {\n\t\t// 对于已存在的任务需要判断subTaskName是否发生变化\n\t\t// 存在任务切换的场景，如order -> trigger，需要将旧任务删除，新任务插入\n\t\ttask := value.(interfaces.Task)\n\t\tif task.GetSubTaskName() != newTask.GetSubTaskName() {\n\t\t\tlogs.Info(ctx).Str(\"TaskId\", task.GetTaskId()).Msg(\"FOUND_SUB_TASK_CHANGED\")\n\t\t\t// 更新taskMap中的task记录，并插入优先队列\n\t\t\tsc.taskMap.Store(newTask.GetTaskId(), newTask)\n\t\t\tsc.syncTaskPriorityQueue.Push(newTask)\n\t\t\tsc.addTimerEvent(newTask.GetTaskId())\n\t\t\tsc.metrics.taskCountInQueue.Add(1)\n\t\t}\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go",
        "code_start_line": 120,
        "code_end_line": 131,
        "code_key": "tryGetWorker",
        "code_value": "func (sc *Scheduler) tryGetWorker(ctx context.Context) bool {\n\tsc.mutex.Lock()\n\tdefer sc.mutex.Unlock()\n\n\tif sc.workerNum > 0 {\n\t\tsc.workerNum--\n\t\tsc.wg.Add(1)\n\t\tsc.metrics.idleWorkerNum.Set(float64(sc.workerNum))\n\t\treturn true\n\t}\n\treturn false\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go",
        "code_start_line": 217,
        "code_end_line": 221,
        "code_key": "rePushTask",
        "code_value": "func (sc *Scheduler) rePushTask(ctx context.Context, task interfaces.Task) {\n\tsc.syncTaskPriorityQueue.Push(task)\n\tsc.metrics.taskCountInQueue.Add(1)\n\tsc.addTimerEvent(task.GetTaskId())\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/mq/mqimpl/rabbitMq/producer.go",
        "code_start_line": 71,
        "code_end_line": 96,
        "code_key": "Confirm",
        "code_value": "func (p *Producer) Confirm() <-chan mqiface.IMessage {\n\t/*\n\t\tConfirm主要是用来获取消息的发送结果，并将对象的消息放入channel中\n\t\tconfirm.DeliveryTag是rabbitmq维护的channel级的唯一标识，实际的值来源于channel.published,\n\t\t但是这个变量不对外暴露，所以在publish操作中也维护了一个producer级的published变量，二者值是一致的\n\t*/\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase confirm, ok := <-p.Confirms:\n\t\t\t\tif !ok {\n\t\t\t\t\tlogs.Info(p.Ctx).Msg(\"CONFIRM_CHANNEL_CLOSED\")\n\t\t\t\t\t// 关闭p.confirmedMsgChannel\n\t\t\t\t\tp.wg.Wait()\n\t\t\t\t\tclose(p.confirmedMsgChannel)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tp.wg.Add(1)\n\t\t\t\tgo p.processConfirmation(confirm)\n\t\t\tcase <-p.Ctx.Done():\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}()\n\treturn p.confirmedMsgChannel\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/cmd/rdisk_master/run.go",
        "code_start_line": 63,
        "code_end_line": 80,
        "code_key": "runScheduler",
        "code_value": "func runScheduler(appCtx context.Context, wg *sync.WaitGroup) {\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ts := app.GlobalRegistry.Scheduler\n\t\tsignalChan := make(chan os.Signal, 10)\n\t\tsignal.Notify(signalChan, unix.SIGINT, unix.SIGTERM, unix.SIGSEGV)\n\n\t\tgo func(c chan os.Signal) {\n\t\t\t<-c\n\t\t\ts.Stop()\n\t\t}(signalChan)\n\n\t\tif err := s.Start(appCtx); err != nil {\n\t\t\tlogs.Fatal(appCtx).Err(err).Msg(\"scheduler exited\")\n\t\t}\n\t}()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/cmd/rdisk_master/run.go",
        "code_start_line": 83,
        "code_end_line": 92,
        "code_key": "runApiServer",
        "code_value": "func runApiServer(appCtx context.Context, wg *sync.WaitGroup) {\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ts := apiserver.New(appCtx)\n\t\tif err := s.Serve(); err != nil {\n\t\t\tlogs.Fatal(appCtx).Err(err).Msg(\"server exited\")\n\t\t}\n\t}()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/cmd/rdisk_master/run.go",
        "code_start_line": 172,
        "code_end_line": 182,
        "code_key": "initSchedulers",
        "code_value": "func initSchedulers(ctx context.Context) {\n\tapp.GlobalRegistry.Scheduler = scheduler.New(ctx, app.GlobalRegistry.Locker)\n\n\t// 注册定时任务\n\n\tapp.GlobalRegistry.Scheduler.Add(\"update_backup_task\", &tasks.UpdateBackupTask{})\n\tapp.GlobalRegistry.Scheduler.Add(\"recycle_backup_task\", &tasks.RecycleBackupTask{})\n\tapp.GlobalRegistry.Scheduler.Add(\"update_benchmark_task\", &tasks.UpdateBenchmarkTask{})\n\tapp.GlobalRegistry.Scheduler.Add(\"confirm_init_physicaldisk_task\", &tasks.ConfirmInitPhysicalDiskTask{})\n\tapp.GlobalRegistry.Scheduler.Add(\"cleanup_defunct_task\", &tasks.CleanupDefunctTask{})\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/dispatcher/dispatcher.go",
        "code_start_line": 33,
        "code_end_line": 103,
        "code_key": "Dispatch",
        "code_value": "func (d *dispatcherImpl) Dispatch(ctx context.Context, cmd app.Command) (err error) {\n\t// 为什么使用 backgroundCtx 而不是 ctx？\n\t// 因为 ctx 代表调用方的上下文，通常是 rpc 请求上下文。\n\t// 而执行命令的上下文，应该是一个独立的上下文，不应该受到调用方的影响\n\t// 即使由于网络抖动等原因，调用方的上下文已经超时，但是命令执行的上下文仍然应该继续执行。\n\tworkerCtx := context.WithValue(d.backgroundCtx, ctxKeyCommand, cmd)\n\tworkerCtx, cancelFunc := context.WithTimeout(workerCtx, d.workerTimeout)\n\tworkerCtx = logs.GetLogger(ctx).WithContext(workerCtx)\n\tlockKeys := cmd.LockKeys()\n\terrChan := make(chan error, 1)\n\tlockOption := &dlock.Option{\n\t\tRetryStrategy: dlock.ExponentialBackoff(100*time.Millisecond, 6*time.Second),\n\t}\n\td.wg.Add(1)\n\t// 最终打印错误\n\t// TODO: 并发控制最大能同时执行的命令数量\n\tgo func() {\n\t\tdefer d.wg.Done()\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\te, ok := err.(error)\n\t\t\t\tif !ok {\n\t\t\t\t\te = errors.Newf(ErrDispatchPanic, \"dispatcher panic: %v\", err)\n\t\t\t\t}\n\t\t\t\terrChan <- e\n\t\t\t\tlogs.Error(workerCtx).Err(e).Stack().Bytes(\"trace\", debug.Stack()).Msgf(\"command execution panic\")\n\t\t\t}\n\t\t}()\n\n\t\tdefer cancelFunc()\n\n\t\tif lockKeys != nil {\n\t\t\tlock, err := d.locker.ObtainMulti(workerCtx, lockKeys, d.workerTimeout, lockOption)\n\t\t\tif err != nil {\n\t\t\t\terrChan <- err\n\t\t\t\tlogs.Warn(workerCtx).Err(err).Msgf(\"command execution waiting locks timeout\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer lock.Release(workerCtx)\n\t\t}\n\n\t\tuow := app.GetRegistry(ctx).Repositories.UoWFactory.New()\n\t\tworkerCtx = app.GetRegistry(ctx).Repositories.UoWFactory.With(workerCtx, uow)\n\n\t\terr = cmd.Handle(workerCtx)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, errors.ErrDryRunSuccessExit) {\n\t\t\t\terr = nil\n\t\t\t} else {\n\t\t\t\tlogs.Warn(workerCtx).Err(err).Msgf(\"command execution failed\")\n\t\t\t}\n\t\t\t_err := uow.Rollback(workerCtx)\n\t\t\tif _err != nil {\n\t\t\t\tlogs.Error(workerCtx).Err(_err).Msgf(\"unit of work rollback failed\")\n\t\t\t}\n\t\t} else {\n\t\t\terr = uow.Commit(workerCtx)\n\t\t\tif err != nil {\n\t\t\t\tlogs.Error(workerCtx).Err(err).Msgf(\"unit of work commit failed\")\n\t\t\t}\n\t\t}\n\t\terrChan <- err\n\t\tclose(errChan)\n\t}()\n\tselect {\n\tcase err := <-errChan:\n\t\treturn err\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/scheduler.go",
        "code_start_line": 127,
        "code_end_line": 132,
        "code_key": "Add",
        "code_value": "func (s *scheduler) Add(name string, workload WorkLoad) {\n\ts.mutex.Lock()\n\tdefer s.mutex.Unlock()\n\ts.loads[name] = workload\n\ts.eventChan <- name\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/benchmark.go",
        "code_start_line": 17,
        "code_end_line": 29,
        "code_key": "Add",
        "code_value": "func (repo *rdiskBenchmarkRepositoryImpl) Add(ctx context.Context, bench *benchmark.Benchmark) error {\n\tdo := repo.fromModelToDO(bench)\n\tuow := getUow(ctx)\n\tdo.Created = uow.tx.NowFunc()\n\tdo.Updated = uow.tx.NowFunc()\n\tresult := uow.tx.Create(&do)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tbench.ID = do.ID\n\tuow.trackedBenchmarks.Add(bench)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/backup.go",
        "code_start_line": 19,
        "code_end_line": 31,
        "code_key": "Add",
        "code_value": "func (repo *rdiskBackupRepositoryImpl) Add(ctx context.Context, backup *backupPkg.Backup) error {\n\tuow := getUow(ctx)\n\tdo := repo.fromModelToDO(backup)\n\tdo.Created = uow.tx.NowFunc()\n\tdo.Updated = uow.tx.NowFunc()\n\tresult := uow.tx.Create(&do)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tbackup.ID = do.ID\n\tuow.trackedBackups.Add(backup)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go",
        "code_start_line": 76,
        "code_end_line": 91,
        "code_key": "Add",
        "code_value": "func (l logicalVolumeRepositoryImpl) Add(ctx context.Context, lv *rdiskDomain.LogicalVolume) error {\n\tuow := getUow(ctx)\n\tvol := fromModelToDmRDisk(lv)\n\tvol.Created = uow.tx.NowFunc()\n\tvol.Updated = uow.tx.NowFunc()\n\tresult := uow.tx.Create(&vol)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tlv.ID = vol.ID\n\tlv = uow.trackedLogicalVolumes.Add(lv)\n\tif lv.PhysicalVolume != nil {\n\t\tlv.PhysicalVolume = uow.trackedPhyVolumes.Add(lv.PhysicalVolume)\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/uow.go",
        "code_start_line": 23,
        "code_end_line": 30,
        "code_key": "Add",
        "code_value": "func (c *changeTracker[T]) Add(item T) T {\n\tif v, ok := c.items[item.GetID()]; ok {\n\t\treturn v\n\t}\n\tc.items[item.GetID()] = item\n\tc.originalStates[item.GetID()] = item.DeepCopy().(T)\n\treturn item\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go",
        "code_start_line": 59,
        "code_end_line": 71,
        "code_key": "Add",
        "code_value": "func (p *physicalVolumeRepositoryImpl) Add(ctx context.Context, pv *rdiskDomain.PhysicalVolume) error {\n\tuow := getUow(ctx)\n\tvol := fromPhysicalVolumeToDmPhyDisk(ctx, pv)\n\tvol.Created = uow.tx.NowFunc()\n\tvol.Updated = uow.tx.NowFunc()\n\tresult := uow.tx.Create(&vol)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tpv.ID = vol.ID\n\tuow.trackedPhyVolumes.Add(pv)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
        "code_start_line": 96,
        "code_end_line": 108,
        "code_key": "Add",
        "code_value": "func (d drgroupRepositoryImpl) Add(ctx context.Context, group *drgroup.DRGroup) error {\n\tuow := getUow(ctx)\n\tdo := fromModelToDmDRGroup(group)\n\tdo.Created = uow.tx.NowFunc()\n\tdo.Updated = uow.tx.NowFunc()\n\tresult := uow.tx.Clauses(clause.Insert{Modifier: \"IGNORE\"}).Create(&do)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tgroup.ID = do.ID\n\tuow.trackedDRGroups.Add(group)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 41,
        "code_end_line": 46,
        "code_key": "Add",
        "code_value": "func (m *MockLogicalVolumeRepository) Add(arg0 context.Context, arg1 *rdiskDomain.LogicalVolume) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Add\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 49,
        "code_end_line": 52,
        "code_key": "Add",
        "code_value": "func (mr *MockLogicalVolumeRepositoryMockRecorder) Add(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Add\", reflect.TypeOf((*MockLogicalVolumeRepository)(nil).Add), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 40,
        "code_end_line": 45,
        "code_key": "Add",
        "code_value": "func (m *MockPhysicalVolumeRepository) Add(arg0 context.Context, arg1 *rdiskDomain.PhysicalVolume) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Add\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 48,
        "code_end_line": 51,
        "code_key": "Add",
        "code_value": "func (mr *MockPhysicalVolumeRepositoryMockRecorder) Add(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Add\", reflect.TypeOf((*MockPhysicalVolumeRepository)(nil).Add), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 40,
        "code_end_line": 45,
        "code_key": "Add",
        "code_value": "func (m *MockRepository) Add(arg0 context.Context, arg1 *drgroup.DRGroup) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Add\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 48,
        "code_end_line": 51,
        "code_key": "Add",
        "code_value": "func (mr *MockRepositoryMockRecorder) Add(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Add\", reflect.TypeOf((*MockRepository)(nil).Add), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 763,
        "code_end_line": 781,
        "code_key": "initCustomErrorHandler",
        "code_value": "func initCustomErrorHandler() {\n\tdefaultHandler := thttp.DefaultServerCodec.ErrHandler\n\tthttp.DefaultServerCodec.ErrHandler = func(w http.ResponseWriter, r *http.Request, e *errs.Error) {\n\t\t// Add custom error message to response body\n\t\tbody := errBody{\n\t\t\tCode: e.Code,\n\t\t\tMsg:  e.Msg,\n\t\t}\n\t\tbodyData, err := json.Marshal(body)\n\t\tif err != nil {\n\t\t\t// Should never happen\n\t\t\tpanic(err)\n\t\t}\n\n\t\tw.Header().Add(\"Content-Length\", strconv.Itoa(len(bodyData)))\n\t\tdefaultHandler(w, r, e)\n\t\tw.Write(bodyData)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_drgroup.go",
        "code_start_line": 176,
        "code_end_line": 198,
        "code_key": "getOrCreateDRGroup",
        "code_value": "func (c *UpdateLogicalVolumeDRGroupCommand) getOrCreateDRGroup(ctx context.Context, drgRepo drgroup.Repository, spec *drgroup.Spec) (*drgroup.DRGroup, error) {\n\tgroup, err := drgRepo.FindByName(ctx, c.AppID, spec.Name)\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\tgroup = drgroup.New(spec.Name, c.AppID)\n\t\t\tif spec.Affinity > 0 {\n\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t}\n\t\t\tif spec.Type != \"\" {\n\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t}\n\t\t\tif !c.DryRun {\n\t\t\t\terr := drgRepo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn group, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/attach_detach.go",
        "code_start_line": 247,
        "code_end_line": 297,
        "code_key": "UpdateFlowControlOnAllInitiator",
        "code_value": "func UpdateFlowControlOnAllInitiator(ctx context.Context, source rdiskDomain.LogicalVolumeState,\n\ttarget rdiskDomain.LogicalVolumeState, stateCtx app.LogicalVolumeContext) (state rdiskDomain.LogicalVolumeState, err error) {\n\n\tlv := stateCtx.GetLogicalVolume()\n\tif len(lv.Attachments) == 0 {\n\t\tlogs.Info(ctx).Str(\"uuid\", lv.UUID.String()).Msg(\"no attachment found, skip update flow control\")\n\t\treturn target, nil\n\t}\n\n\tvar wg sync.WaitGroup\n\tvar collectedErr []error = make([]error, len(lv.Attachments))\n\n\twg.Add(len(lv.Attachments))\n\n\tfor idx, attachment := range lv.Attachments {\n\t\tgo func(idx int, attachment *rdiskDomain.VolumeAttachment) {\n\t\t\tdefer wg.Done()\n\n\t\t\tblk := app.GetRegistry(ctx).Factories.BlockAgentClient(attachment.IP.String())\n\t\t\treq := cbs_blk_flow_agent.NewUpdateRDiskFlowControlRequest(lv.UUID.String(), lv.PhysicalVolume.DiskID)\n\t\t\treq.SpdkDriver = attachment.Options.SPDKDriver\n\t\t\treq.SetRead(attachment.FlowControlSpec.MaxReadIOPS, attachment.FlowControlSpec.MaxReadMBps)\n\t\t\treq.SetWrite(attachment.FlowControlSpec.MaxWriteIOPS, attachment.FlowControlSpec.MaxWriteMBps)\n\t\t\treq.SetReadWrite(attachment.FlowControlSpec.MaxRWIOPS, attachment.FlowControlSpec.MaxRWMBps)\n\n\t\t\terr = blk.UpdateRDiskFlowControl(ctx, req)\n\t\t\tif err != nil {\n\t\t\t\tlogs.Error(ctx).Err(err).Str(\"ip\", attachment.IP.String()).Msg(\"failed to update flow control\")\n\t\t\t}\n\t\t\tcollectedErr[idx] = err\n\t\t}(idx, attachment)\n\t}\n\n\twg.Wait()\n\n\t// collect error ip and print error count\n\tvar errList []error\n\tvar errIPs []string\n\tfor idx, err := range collectedErr {\n\t\tif err != nil {\n\t\t\terrList = append(errList, err)\n\t\t\terrIPs = append(errIPs, lv.Attachments[idx].IP.String())\n\t\t}\n\t}\n\tif len(errList) > 0 {\n\t\tlogs.Warn(ctx).Errs(\"errors\", errList).Strs(\"host_ips\", errIPs).Msg(\"failed to update flow control on some initiators\")\n\t\treturn source, errors.New(rdiskDomain.ErrUpdateFlowControl, fmt.Sprintf(\"failed to update flow control on some initiators: %v, errors: %v\", errIPs, errList))\n\t}\n\n\treturn target, err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/drgroups.go",
        "code_start_line": 22,
        "code_end_line": 71,
        "code_key": "AddHostToDRGroup",
        "code_value": "func AddHostToDRGroup(ctx context.Context, source rdiskDomain.LogicalVolumeState, target rdiskDomain.LogicalVolumeState, stateCtx app.LogicalVolumeContext) (rdiskDomain.LogicalVolumeState, error) {\n\tdata := stateCtx.(CreateLogicalVolumeContext)\n\tvol := data.GetLogicalVolume()\n\tphy := data.GetPhysicalVolume()\n\tspecs := data.GetDRGroupSpecList()\n\trepo := app.GetRegistry(ctx).Repositories.DRGroup\n\tif len(specs) == 0 {\n\t\treturn target, nil\n\t}\n\tfor _, spec := range specs {\n\t\tgroup, err := repo.FindByName(ctx, vol.AppID, spec.Name)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\tgroup = drgroup.New(spec.Name, vol.AppID)\n\t\t\t\tif spec.Affinity > 0 {\n\t\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t\t}\n\t\t\t\tif spec.Type != \"\" {\n\t\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t\t}\n\t\t\t\terr = repo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn source, err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn source, err\n\t\t\t}\n\t\t}\n\t\tif spec.Affinity > 0 && group.Affinity != spec.Affinity {\n\t\t\tlogs.Info(ctx).Uint64(\"app_id\", uint64(vol.AppID)).\n\t\t\t\tStr(\"group_name\", spec.Name).\n\t\t\t\tInt(\"old_affinity\", group.Affinity).\n\t\t\t\tInt(\"new_affinity\", spec.Affinity).\n\t\t\t\tMsg(\"update affinity of drgroup\")\n\t\t\tgroup.Affinity = spec.Affinity\n\t\t}\n\t\tsubGroup := spec.SubGroup\n\t\tif subGroup == \"\" {\n\t\t\t// 如果没有指定子组，则使用远端 SSD UUID 作为子组名称\n\t\t\t// 相当于每块盘都是一个子组，相当于没有使用子组功能\n\t\t\tsubGroup = vol.UUID.String()\n\t\t}\n\t\terr = group.AddMember(vol.UUID.String(), subGroup, phy.IP.String())\n\t\tif err != nil {\n\t\t\treturn source, err\n\t\t}\n\t}\n\n\treturn target, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/create_phy_disk.go",
        "code_start_line": 32,
        "code_end_line": 70,
        "code_key": "CreatePhysicalVolumeInRepository",
        "code_value": "func CreatePhysicalVolumeInRepository(ctx context.Context, source rdiskDomain.PhysicalVolumeState, target rdiskDomain.PhysicalVolumeState, stateCtx app.PhysicalVolumeContext) (rdiskDomain.PhysicalVolumeState, error) {\n\tcreateCtx := stateCtx.(CreatePhysicalVolumeContext)\n\tphysicalVolume := createCtx.GetPhysicalVolume()\n\tspec := createCtx.GetSpec()\n\tif err := rdiskDomain.CheckSerial(spec.Serial); err != nil {\n\t\treturn source, err\n\t}\n\tif physicalVolume != nil {\n\t\t*physicalVolume = *rdiskDomain.NewPhysicalVolume(spec.Serial, spec.IP, spec.BDF, spec.Size, spec.ZoneID, spec.Cuf)\n\t} else {\n\t\tphysicalVolume = rdiskDomain.NewPhysicalVolume(spec.Serial, spec.IP, spec.BDF, spec.Size, spec.ZoneID, spec.Cuf)\n\t}\n\tphysicalVolume.DataNodeType = spec.DataTypeNode\n\tif spec.VolumeType != \"\" {\n\t\tphysicalVolume.VolumeType = spec.VolumeType\n\t}\n\tif spec.PerformanceRank != \"\" {\n\t\tphysicalVolume.PerformanceRank = spec.PerformanceRank\n\t\tif !physicalVolume.PerformanceRank.IsValid() {\n\t\t\treturn source, errors.Newf(rdiskDomain.ErrInvalidPerformanceRank, \"invalid performance rank %s\", spec.PerformanceRank)\n\t\t}\n\t}\n\tphysicalVolume.State = target\n\tlogs.Info(ctx).\n\t\tStr(\"host_ip\", physicalVolume.IP.String()).\n\t\tStr(\"bdf\", string(physicalVolume.BDF)).\n\t\tStr(\"serial\", string(physicalVolume.Serial)).\n\t\tInt(\"zone_id\", int(physicalVolume.ZoneID)).\n\t\tStr(\"volume_type\", string(physicalVolume.VolumeType)).\n\t\tStr(\"cuf\", string(physicalVolume.Cuf)).\n\t\tStr(\"performance_rank\", string(physicalVolume.PerformanceRank)).\n\t\tMsg(\"created physical volume\")\n\n\terr := app.GetRegistry(ctx).Repositories.PhysicalVolume.Add(ctx, physicalVolume)\n\tif err != nil {\n\t\treturn source, err\n\t}\n\treturn target, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 214,
        "code_end_line": 239,
        "code_key": "StepGivenAPhysicalVol",
        "code_value": "func StepGivenAPhysicalVol(registry *app.Registry, value interface{}) *rdiskDomain.PhysicalVolume {\n\tphysicalVol := &rdiskDomain.PhysicalVolume{\n\t\tEntityMixin:  rdiskDomain.EntityMixin{ID: 1},\n\t\tSerial:       \"12345\",\n\t\tIP:           net.IP{127, 0, 0, 1},\n\t\tBDF:          \"bdf\",\n\t\tDiskID:       0,\n\t\tState:        rdiskDomain.PhysicalVolumeState(value.(int)),\n\t\tSize:         1,\n\t\tVolumeType:   \"NVME\",\n\t\tZoneID:       1,\n\t\tBlockSize:    512,\n\t\tRealSize:     5120,\n\t\tPort:         1,\n\t\tDataNodeType: \"unknown\",\n\t\tCuf:          \"清远-清新-C2\",\n\t}\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\terr := registry.Repositories.PhysicalVolume.Add(workerCtx, physicalVol)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn physicalVol\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 244,
        "code_end_line": 277,
        "code_key": "StepGivenPhysicalVols",
        "code_value": "func StepGivenPhysicalVols(registry *app.Registry, value interface{}, num interface{}) []*rdiskDomain.PhysicalVolume {\n\tvar physicalVols []*rdiskDomain.PhysicalVolume\n\tfor i := 0; i < num.(int); i++ {\n\t\tphysicalVols = append(physicalVols, &rdiskDomain.PhysicalVolume{\n\t\t\tEntityMixin:  rdiskDomain.EntityMixin{},\n\t\t\tSerial:       rdiskDomain.Serial(\"111\" + strconv.Itoa(i)),\n\t\t\tIP:           net.IP{127, 0, byte(((i + 2) / 255) % 255), byte((i + 2) % 255)},\n\t\t\tBDF:          \"bdf\",\n\t\t\tDiskID:       0,\n\t\t\tState:        rdiskDomain.PhysicalVolumeState(value.(int)),\n\t\t\tSize:         1,\n\t\t\tVolumeType:   \"\",\n\t\t\tZoneID:       1,\n\t\t\tBlockSize:    512,\n\t\t\tRealSize:     5120,\n\t\t\tPort:         1,\n\t\t\tDataNodeType: \"\",\n\t\t\tCuf:          \"清远-清新-C2\",\n\t\t})\n\t}\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\tfor _, vol := range physicalVols {\n\t\terr := registry.Repositories.PhysicalVolume.Add(workerCtx, vol)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\terr := uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn physicalVols\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 282,
        "code_end_line": 304,
        "code_key": "StepGivenALogicalVol",
        "code_value": "func StepGivenALogicalVol(registry *app.Registry, physicalVol *rdiskDomain.PhysicalVolume, value interface{}) *rdiskDomain.LogicalVolume {\n\tlogicalVol := &rdiskDomain.LogicalVolume{\n\t\tEntityMixin:     rdiskDomain.EntityMixin{ID: 1},\n\t\tUUID:            uuid.Must(uuid.NewRandom()),\n\t\tState:           rdiskDomain.LogicalVolumeState(value.(int)),\n\t\tSize:            1,\n\t\tAppID:           123,\n\t\tZoneID:          1,\n\t\tDiskType:        \"\",\n\t\tVolumeType:      \"\",\n\t\tFlowControlSpec: rdiskDomain.FlowControlSpec{},\n\t\tPhysicalVolume:  physicalVol,\n\t\tAttachments:     nil,\n\t}\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\terr := registry.Repositories.LogicalVolume.Add(workerCtx, logicalVol)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn logicalVol\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 527,
        "code_end_line": 564,
        "code_key": "StepWhenCreateSomeRDiskVol",
        "code_value": "func StepWhenCreateSomeRDiskVol(ctx context.Context, req interface{}) {\n\trequests := req.([]*pb.CreateRDiskVolRequest)\n\n\t// 创建一个 WaitGroup\n\tvar wg sync.WaitGroup\n\t// 创建一个通道来接收结果\n\tresults := make(chan *pb.CreateRDiskVolResponse, len(requests))\n\terrors := make(chan error, len(requests))\n\n\t// 创建一个 API 服务器实例\n\tapiServer := apiserver.NewMasterApiServer()\n\n\tstart := time.Now()\n\t// 遍历请求列表并启动 goroutine 发送请求\n\tfor _, req := range requests {\n\t\twg.Add(1)\n\t\tgo func(req *pb.CreateRDiskVolRequest) {\n\t\t\tdefer wg.Done()\n\t\t\trsp, err := apiServer.CreateRDiskVol(ctx, req)\n\t\t\tif err != nil {\n\t\t\t\terrors <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\tresults <- rsp\n\t\t}(req)\n\t}\n\n\t// 等待所有 goroutines 完成\n\twg.Wait()\n\tclose(results)\n\tclose(errors)\n\tfmt.Println(\"time:\", time.Since(start))\n\ttime.Sleep(2 * time.Second)\n\t// 处理错误\n\tfor err := range errors {\n\t\tfmt.Println(\"Error:\", err)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/benchmark.go",
        "code_start_line": 42,
        "code_end_line": 50,
        "code_key": "FindByUUID",
        "code_value": "func (repo *rdiskBenchmarkRepositoryImpl) FindByUUID(ctx context.Context, uuid string) (*benchmark.Benchmark, error) {\n\tuow := getUow(ctx)\n\tb := &metadb.DmRdiskBenchmark{}\n\tresult := uow.tx.First(b, \"uuid = ?\", uuid)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\treturn uow.trackedBenchmarks.Add(repo.fromDoToModel(b)), nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/backup.go",
        "code_start_line": 44,
        "code_end_line": 53,
        "code_key": "FindByUUID",
        "code_value": "func (impl *rdiskBackupRepositoryImpl) FindByUUID(ctx context.Context, uuid string) (*backupPkg.Backup, error) {\n\tuow := getUow(ctx)\n\n\tb := &metadb.DmRdiskBackup{}\n\tresult := uow.tx.First(b, \"uuid = ?\", uuid)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\treturn uow.trackedBackups.Add(impl.fromDOToModel(b)), nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go",
        "code_start_line": 22,
        "code_end_line": 47,
        "code_key": "FindByAppIDAndUUID",
        "code_value": "func (logicalVolumeRepositoryImpl) FindByAppIDAndUUID(ctx context.Context, appID users.AppID, id uuid.UUID) (*rdiskDomain.LogicalVolume, error) {\n\tuow := getUow(ctx)\n\tvol := metadb.DmRdisk{}\n\tresult := uow.tx.\n\t\tPreload(\"Attachments\").\n\t\tPreload(\"DmPhyDisk\").\n\t\tFirst(&vol, \"uuid = ? AND app_id = ?\", id.String(), appID)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tlv, err := fromDmRDiskToModel(ctx, &vol)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlv = uow.trackedLogicalVolumes.Add(lv)\n\tif lv.PhysicalVolume != nil {\n\t\tlv.PhysicalVolume = uow.trackedPhyVolumes.Add(lv.PhysicalVolume)\n\t}\n\treturn lv, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 55,
        "code_end_line": 61,
        "code_key": "FindByAppIDAndUUID",
        "code_value": "func (m *MockLogicalVolumeRepository) FindByAppIDAndUUID(arg0 context.Context, arg1 users.AppID, arg2 uuid.UUID) (*rdiskDomain.LogicalVolume, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByAppIDAndUUID\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(*rdiskDomain.LogicalVolume)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 64,
        "code_end_line": 67,
        "code_key": "FindByAppIDAndUUID",
        "code_value": "func (mr *MockLogicalVolumeRepositoryMockRecorder) FindByAppIDAndUUID(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByAppIDAndUUID\", reflect.TypeOf((*MockLogicalVolumeRepository)(nil).FindByAppIDAndUUID), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go",
        "code_start_line": 49,
        "code_end_line": 74,
        "code_key": "FindByID",
        "code_value": "func (l logicalVolumeRepositoryImpl) FindByID(ctx context.Context, id uuid.UUID) (*rdiskDomain.LogicalVolume, error) {\n\tuow := getUow(ctx)\n\tvol := metadb.DmRdisk{}\n\tresult := uow.tx.\n\t\tPreload(\"Attachments\").\n\t\tPreload(\"DmPhyDisk\").\n\t\tFirst(&vol, \"uuid = ?\", id.String())\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tlv, err := fromDmRDiskToModel(ctx, &vol)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlv = uow.trackedLogicalVolumes.Add(lv)\n\tif lv.PhysicalVolume != nil {\n\t\tlv.PhysicalVolume = uow.trackedPhyVolumes.Add(lv.PhysicalVolume)\n\t}\n\treturn lv, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 70,
        "code_end_line": 76,
        "code_key": "FindByID",
        "code_value": "func (m *MockLogicalVolumeRepository) FindByID(arg0 context.Context, arg1 uuid.UUID) (*rdiskDomain.LogicalVolume, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByID\", arg0, arg1)\n\tret0, _ := ret[0].(*rdiskDomain.LogicalVolume)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/logi_repo.go",
        "code_start_line": 79,
        "code_end_line": 82,
        "code_key": "FindByID",
        "code_value": "func (mr *MockLogicalVolumeRepositoryMockRecorder) FindByID(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByID\", reflect.TypeOf((*MockLogicalVolumeRepository)(nil).FindByID), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go",
        "code_start_line": 21,
        "code_end_line": 38,
        "code_key": "FindBySerial",
        "code_value": "func (p *physicalVolumeRepositoryImpl) FindBySerial(ctx context.Context, serial rdiskDomain.Serial) (*rdiskDomain.PhysicalVolume, error) {\n\tuow := getUow(ctx)\n\tvar vol metadb.DmPhydisk\n\tresult := uow.tx.Where(\"serial = ?\", string(serial)).First(&vol)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\t// 覆盖 gorm 的错误\n\t\t\treturn nil, errors.New(rdiskDomain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tpv := fromDmPhyDiskToPhysicalVolume(ctx, &vol)\n\tpv = uow.trackedPhyVolumes.Add(pv)\n\treturn pv, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 83,
        "code_end_line": 89,
        "code_key": "FindBySerial",
        "code_value": "func (m *MockPhysicalVolumeRepository) FindBySerial(arg0 context.Context, arg1 rdiskDomain.Serial) (*rdiskDomain.PhysicalVolume, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindBySerial\", arg0, arg1)\n\tret0, _ := ret[0].(*rdiskDomain.PhysicalVolume)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 92,
        "code_end_line": 95,
        "code_key": "FindBySerial",
        "code_value": "func (mr *MockPhysicalVolumeRepositoryMockRecorder) FindBySerial(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindBySerial\", reflect.TypeOf((*MockPhysicalVolumeRepository)(nil).FindBySerial), arg0, arg1)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go",
        "code_start_line": 40,
        "code_end_line": 57,
        "code_key": "FindByIPAndBDF",
        "code_value": "func (p *physicalVolumeRepositoryImpl) FindByIPAndBDF(ctx context.Context, ip net.IP, bdf rdiskDomain.BDF) (*rdiskDomain.PhysicalVolume, error) {\n\tuow := getUow(ctx)\n\tvar vol metadb.DmPhydisk\n\tresult := uow.tx.Where(\"host_ip = ? AND bdf = ?\", ip.String(), string(bdf)).Find(&vol)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\t// 覆盖 gorm 的错误\n\t\t\treturn nil, errors.New(rdiskDomain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tpv := fromDmPhyDiskToPhysicalVolume(ctx, &vol)\n\tpv = uow.trackedPhyVolumes.Add(pv)\n\treturn pv, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 68,
        "code_end_line": 74,
        "code_key": "FindByIPAndBDF",
        "code_value": "func (m *MockPhysicalVolumeRepository) FindByIPAndBDF(arg0 context.Context, arg1 net.IP, arg2 rdiskDomain.BDF) (*rdiskDomain.PhysicalVolume, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByIPAndBDF\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(*rdiskDomain.PhysicalVolume)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/mocks/phy_repo.go",
        "code_start_line": 77,
        "code_end_line": 80,
        "code_key": "FindByIPAndBDF",
        "code_value": "func (mr *MockPhysicalVolumeRepositoryMockRecorder) FindByIPAndBDF(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByIPAndBDF\", reflect.TypeOf((*MockPhysicalVolumeRepository)(nil).FindByIPAndBDF), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
        "code_start_line": 31,
        "code_end_line": 52,
        "code_key": "FindByNames",
        "code_value": "func (d drgroupRepositoryImpl) FindByNames(ctx context.Context, appId users.AppID, names []string) ([]*drgroup.DRGroup, error) {\n\tuow := getUow(ctx)\n\tgroup := []metadb.DmDrgroup{}\n\tresult := uow.tx.\n\t\tPreload(\"Members\").\n\t\tFind(&group, \"app_id = ? and name in ?\", appId, names)\n\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"disaster recovery group not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tresults := make([]*drgroup.DRGroup, len(group))\n\tfor i := range group {\n\t\tresults[i] = uow.trackedDRGroups.Add(fromDmDRGroupToModel(&group[i]))\n\t}\n\treturn results, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 113,
        "code_end_line": 119,
        "code_key": "FindByNames",
        "code_value": "func (m *MockRepository) FindByNames(arg0 context.Context, arg1 users.AppID, arg2 []string) ([]*drgroup.DRGroup, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByNames\", arg0, arg1, arg2)\n\tret0, _ := ret[0].([]*drgroup.DRGroup)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 122,
        "code_end_line": 125,
        "code_key": "FindByNames",
        "code_value": "func (mr *MockRepositoryMockRecorder) FindByNames(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByNames\", reflect.TypeOf((*MockRepository)(nil).FindByNames), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
        "code_start_line": 58,
        "code_end_line": 94,
        "code_key": "FindByMembers",
        "code_value": "func (d drgroupRepositoryImpl) FindByMembers(ctx context.Context, appId users.AppID, members []string) ([]*drgroup.DRGroup, error) {\n\tuow := getUow(ctx)\n\tgroup := []metadb.DmDrgroup{}\n\n\tmembersResult := []metadb.DmDrgroupMembers{}\n\tresult := uow.tx.\n\t\tFind(&membersResult, \"app_id = ? and member_id in ?\", appId, members)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tnames := make([]string, 0, len(members))\n\tfor i := range membersResult {\n\t\tnames = append(names, membersResult[i].GroupName)\n\t}\n\tresult = uow.tx.\n\t\tPreload(\"Members\").\n\t\tFind(&group, \"app_id = ? and name in ?\", appId, names)\n\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"disaster recovery group not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tresults := make([]*drgroup.DRGroup, len(group))\n\tfor i := range group {\n\t\tresults[i] = fromDmDRGroupToModel(&group[i])\n\t\tresults[i] = uow.trackedDRGroups.Add(results[i])\n\t}\n\treturn results, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/drgroup.go",
        "code_start_line": 92,
        "code_end_line": 124,
        "code_key": "FindByMembers",
        "code_value": "func (d *drgroupViewerImpl) FindByMembers(ctx context.Context, appId users.AppID, members []string) ([]*drgroup.View, error) {\n\tvar (\n\t\tresultViews       []drgroup.View\n\t\tresultViewRef     []*drgroup.View\n\t\tdataObjects       []*metadb.DmDrgroup\n\t\tdataObjectMembers []*metadb.DmDrgroupMembers\n\t)\n\tresult := d.db.WithContext(ctx).Find(&dataObjectMembers, \"app_id = ? and member_id in ?\", appId, members)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"group not exist\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tgroupNames := make([]string, len(dataObjectMembers))\n\tfor i := range dataObjectMembers {\n\t\tgroupNames[i] = dataObjectMembers[i].GroupName\n\t}\n\tresult = d.db.WithContext(ctx).Find(&dataObjects, \"app_id = ? and name in ?\", appId, groupNames)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"group not exist\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tresultViews = make([]drgroup.View, len(dataObjects))\n\tresultViewRef = make([]*drgroup.View, len(dataObjects))\n\tfor i := range dataObjects {\n\t\tresultViewRef[i] = &resultViews[i]\n\t\td.translate(dataObjects[i], resultViewRef[i])\n\t}\n\treturn resultViewRef, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 83,
        "code_end_line": 89,
        "code_key": "FindByMembers",
        "code_value": "func (m *MockRepository) FindByMembers(arg0 context.Context, arg1 users.AppID, arg2 []string) ([]*drgroup.DRGroup, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByMembers\", arg0, arg1, arg2)\n\tret0, _ := ret[0].([]*drgroup.DRGroup)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 92,
        "code_end_line": 95,
        "code_key": "FindByMembers",
        "code_value": "func (mr *MockRepositoryMockRecorder) FindByMembers(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByMembers\", reflect.TypeOf((*MockRepository)(nil).FindByMembers), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/view.go",
        "code_start_line": 55,
        "code_end_line": 61,
        "code_key": "FindByMembers",
        "code_value": "func (m *MockViewer) FindByMembers(arg0 context.Context, arg1 users.AppID, arg2 []string) ([]*drgroup.View, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByMembers\", arg0, arg1, arg2)\n\tret0, _ := ret[0].([]*drgroup.View)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/view.go",
        "code_start_line": 64,
        "code_end_line": 67,
        "code_key": "FindByMembers",
        "code_value": "func (mr *MockViewerMockRecorder) FindByMembers(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByMembers\", reflect.TypeOf((*MockViewer)(nil).FindByMembers), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 178,
        "code_end_line": 233,
        "code_key": "updateReadLocks",
        "code_value": "func (l *mysqlLocker) updateReadLocks(tx *gorm.DB, ttl time.Duration, keys []string, lockTokens []string) ([]string, []string, []string, error) {\n\tif len(keys) == 0 {\n\t\treturn nil, nil, lockTokens, nil\n\t}\n\ttype Result struct {\n\t\tLock       string\n\t\tExpiration time.Time\n\t\tToken      string\n\t}\n\tvar Results []Result\n\terr := tx.Raw(\"SELECT `\"+l.lockColumn+\"` AS `lock`, `\"+l.expireColumn+\"` AS `expiration`, `\"+l.tokenColumn+\"` AS `token` FROM \"+l.tableName+\" WHERE `\"+l.lockColumn+\"` IN (?)\", keys).Scan(&Results).Error\n\tif err != nil {\n\t\treturn nil, nil, nil, errors.Wrap(err, \"fail to query locks\")\n\t}\n\n\tvar needUpdateExpirationReadKeys []string = nil\n\tvar needUpdateCountReadKeys []string = nil\n\tl.mutex.Lock()\n\tt := time.Now()\n\tfor _, r := range Results {\n\t\tif r.Token != lockTokens[0] {\n\t\t\tlockTokens = append(lockTokens, r.Token)\n\t\t}\n\t\tif readKey, exist := l.readKeysMemLock[r.Lock]; exist {\n\t\t\treadKey.count++\n\t\t\treadKey.expiration = r.Expiration\n\t\t} else {\n\t\t\tl.readKeysMemLock[r.Lock] = &readKeysMemLock{\n\t\t\t\tcount:      1,\n\t\t\t\texpiration: r.Expiration,\n\t\t\t\ttoken:      r.Token,\n\t\t\t}\n\t\t\tneedUpdateCountReadKeys = append(needUpdateCountReadKeys, r.Lock)\n\t\t}\n\t\tif l.readKeysMemLock[r.Lock].expiration.Sub(t) < ttl/3 {\n\t\t\tl.readKeysMemLock[r.Lock].expiration = t.Add(ttl)\n\t\t\tneedUpdateExpirationReadKeys = append(needUpdateExpirationReadKeys, r.Lock)\n\t\t}\n\t}\n\tl.mutex.Unlock()\n\tif len(needUpdateExpirationReadKeys) > 0 {\n\t\tresult := tx.Exec(\"UPDATE \"+l.tableName+\" SET \"+l.expireColumn+\" = NOW() + INTERVAL ? SECOND WHERE `\"+l.lockColumn+\"` IN (?)\", ttl.Seconds(), needUpdateExpirationReadKeys)\n\t\tif result.Error != nil {\n\t\t\treturn nil, needUpdateExpirationReadKeys, needUpdateCountReadKeys, errors.Wrap(result.Error, fmt.Sprintf(\"failed to update readLocks: %s\", keys))\n\t\t}\n\t}\n\n\tif len(needUpdateCountReadKeys) > 0 {\n\t\tresult := tx.Exec(\"UPDATE \"+l.tableName+\" SET \"+l.lockNumsColumn+\" = \"+l.lockNumsColumn+\" + 1 WHERE `\"+l.lockColumn+\"` IN (?)\", needUpdateCountReadKeys)\n\t\tif result.Error != nil {\n\t\t\treturn nil, needUpdateExpirationReadKeys, needUpdateCountReadKeys, errors.Wrap(result.Error, fmt.Sprintf(\"failed to update readLocks: %s\", keys))\n\t\t}\n\t}\n\n\treturn nil, nil, lockTokens, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 335,
        "code_end_line": 369,
        "code_key": "insertLocks",
        "code_value": "func (l *mysqlLocker) insertLocks(tx *gorm.DB, lockKeys []*dlock.LockKey, ttl time.Duration, lockToken []string) ([]string, error) {\n\tif len(lockKeys) <= 0 {\n\t\treturn nil, nil\n\t}\n\tstmt := strings.Builder{}\n\targs := make([]interface{}, 0, len(lockKeys)*5)\n\tt := time.Now().Add(ttl)\n\tstmt.WriteString(fmt.Sprintf(\"INSERT INTO `%s` (`%s`, `%s`, `%s`, `%s`, `%s`) VALUES \", l.tableName, l.lockColumn, l.expireColumn, l.tokenColumn, l.lockTypeColumn, l.lockNumsColumn))\n\tfor i, key := range lockKeys {\n\t\tif i > 0 {\n\t\t\tstmt.WriteString(\", \")\n\t\t}\n\t\tstmt.WriteString(\"(?, NOW() + INTERVAL ? SECOND, ?, ?, ?)\")\n\t\targs = append(args, key.Key, ttl.Seconds(), lockToken[0], int(key.Type), 1)\n\t}\n\n\tresult := tx.Exec(stmt.String(), args...)\n\tif result.Error != nil {\n\t\treturn nil, errors.Wrap(result.Error, \"failed to insert locks\")\n\t}\n\tvar needInsertReadKeys []string = nil\n\tl.mutex.Lock()\n\tfor _, key := range lockKeys {\n\t\tif key.Type == dlock.ReadLock {\n\t\t\tl.readKeysMemLock[key.Key] = &readKeysMemLock{\n\t\t\t\tcount:      1,\n\t\t\t\texpiration: t,\n\t\t\t\ttoken:      lockToken[0],\n\t\t\t}\n\t\t\tneedInsertReadKeys = append(needInsertReadKeys, key.Key)\n\t\t}\n\t}\n\tl.mutex.Unlock()\n\treturn needInsertReadKeys, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 417,
        "code_end_line": 470,
        "code_key": "tryObtainMulti",
        "code_value": "func (l *mysqlLocker) tryObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, tokens []string, opts *dlock.Option) ([]string, error) {\n\t// Starts a new transaction.\n\ttx := l.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\n\n\t// Fetch existing locks.\n\texistingReadKeys, existingWriteKeys, expiredKeys, err := l.fetchExistingLocks(tx, keys)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// If there are existing valid locks, return an error.\n\tif len(existingWriteKeys) > 0 {\n\t\t_ = tx.Rollback()\n\t\treturn nil, errors.Wrap(dlock.ErrLockNotHeld, fmt.Sprintf(\"writeKeys %v are already locked\", existingWriteKeys))\n\t}\n\n\t// Delete expired locks if exists.\n\tif err := l.deleteExpiredLocks(tx, expiredKeys); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Remove existing readLocks from insert.\n\t// NOCA:QCloudAkCheck(误报)\n\tlockKeys, err := l.removeExistingReadLocksFromInsert(tx, keys, existingReadKeys)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Insert locks into database.\n\tneedInsertReadKeys, err := l.insertLocks(tx, lockKeys, ttl, tokens)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Update readLocks.\n\tvar needUpdateExpirationReadKeys []string = nil\n\tvar needUpdateCountReadKeys []string = nil\n\tif needUpdateExpirationReadKeys, needUpdateCountReadKeys, tokens, err = l.updateReadLocks(tx, ttl, existingReadKeys, tokens); err != nil {\n\t\tl.rollback(needUpdateCountReadKeys, tokens)\n\t\tl.rollback(needUpdateExpirationReadKeys, tokens)\n\t\tl.rollback(needInsertReadKeys, tokens)\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\tif result := tx.Commit(); result.Error != nil {\n\t\treturn nil, errors.Wrap(result.Error, \"failed to commit transaction\")\n\t}\n\n\treturn tokens, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mem/memdlock.go",
        "code_start_line": 106,
        "code_end_line": 166,
        "code_key": "tryObtainMulti",
        "code_value": "func (l *memLocker) tryObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, token string) (dlock.Lock, error) {\n\tl.mutex.Lock()\n\tdefer l.mutex.Unlock()\n\tvar readLocks []*dlock.LockKey\n\tvar writeLocks []*dlock.LockKey\n\tvar insertLocks []*dlock.LockKey\n\tvar tokens []string\n\ttokens = append(tokens, token)\n\tfor _, key := range keys {\n\t\tif key.Type == dlock.WriteLock {\n\t\t\twriteLocks = append(writeLocks, key)\n\t\t} else {\n\t\t\treadLocks = append(readLocks, key)\n\t\t}\n\t}\n\tfor _, key := range writeLocks {\n\t\tif item, ok := l.data[key.Key]; ok {\n\t\t\tif time.Until(item.ttl) > 0 {\n\t\t\t\treturn nil, dlock.ErrNotObtained\n\t\t\t} else {\n\t\t\t\tinsertLocks = append(insertLocks, key)\n\t\t\t}\n\t\t} else {\n\t\t\tinsertLocks = append(insertLocks, key)\n\t\t}\n\t}\n\tfor _, key := range readLocks {\n\t\tif item, ok := l.data[key.Key]; ok {\n\t\t\tif item.lockType == dlock.ReadLock {\n\t\t\t\tif time.Until(item.ttl) > 0 {\n\t\t\t\t\titem.count++\n\t\t\t\t\titem.ttl = time.Now().Add(ttl)\n\t\t\t\t\ttokens = append(tokens, item.token)\n\t\t\t\t} else {\n\t\t\t\t\tinsertLocks = append(insertLocks, key)\n\t\t\t\t}\n\t\t\t} else if time.Until(item.ttl) > 0 {\n\t\t\t\treturn nil, dlock.ErrNotObtained\n\t\t\t}\n\t\t} else {\n\t\t\tinsertLocks = append(insertLocks, key)\n\t\t}\n\t}\n\n\tfor _, key := range insertLocks {\n\t\tl.data[key.Key] = &lockItem{\n\t\t\tkey:      key.Key,\n\t\t\tttl:      time.Now().Add(ttl),\n\t\t\ttoken:    token,\n\t\t\tlockType: key.Type,\n\t\t\tcount:    1,\n\t\t}\n\t}\n\n\tlock := &memLock{\n\t\tlocker: l,\n\t\tkeys:   keys,\n\t\ttokens: tokens,\n\t}\n\treturn lock, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 473,
        "code_end_line": 520,
        "code_key": "ObtainMulti",
        "code_value": "func (l *mysqlLocker) ObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, opts *dlock.Option) (dlock.Lock, error) {\n\tif len(keys) == 0 {\n\t\treturn nil, errors.New(\"keys cannot be empty\")\n\t}\n\tkeys = dedupAndSort(keys)\n\n\t// Get the lock token.\n\tlockToken, err := l.getOrCreateLockToken(opts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tretryStrategy := dlock.NoRetry()\n\tif opts != nil && opts.RetryStrategy != nil {\n\t\tretryStrategy = opts.RetryStrategy\n\t}\n\n\tretries := 0\n\tlogger := logs.GetLogger(ctx).With().Strs(\"keys\", dlock.LockKeySlice(keys).GetKeys()).Strs(\"tokens\", lockToken).Logger()\n\n\tfor {\n\t\t// Try to obtain the locks.\n\t\t// If the locks are not obtained, retry based on the retry strategy.\n\t\tif tokens, err := l.tryObtainMulti(ctx, keys, ttl, lockToken, opts); err != nil {\n\t\t\t// If context is canceled, return immediately.\n\t\t\tif ctx.Err() != nil {\n\t\t\t\treturn nil, errors.Wrap(dlock.ErrNotObtained, \"context is canceled\")\n\t\t\t}\n\n\t\t\t// If the lock is not obtained, retry.\n\t\t\twaitDuration := retryStrategy.NextBackoff()\n\t\t\tif waitDuration <= 0 {\n\t\t\t\tlogger.Debug().Int(\"retry\", retries).Msg(\"stop retrying lock\")\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tlogger.Debug().Int(\"retry\", retries).Msg(\"retry obtaining lock\")\n\t\t\ttime.Sleep(waitDuration)\n\t\t} else {\n\t\t\tlockToken = tokens\n\t\t\tlogger.Debug().Msg(\"lock obtained\")\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// TODO xuanzeng: 这里采用内部记录 TTL 的方式，可能和底层的数据库时间不同步，后续应该从数据库中获取过期时间。\n\tlock := &mysqlLock{keys: keys, locker: l, tokens: lockToken, expiration: time.Now().Add(ttl)}\n\treturn lock, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mem/memdlock.go",
        "code_start_line": 74,
        "code_end_line": 103,
        "code_key": "ObtainMulti",
        "code_value": "func (l *memLocker) ObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, opts *dlock.Option) (dlock.Lock, error) {\n\tvar token string\n\tif opts == nil || opts.Token == \"\" {\n\t\ttoken = uuid.New().String()\n\t} else {\n\t\ttoken = opts.Token\n\t}\n\n\tretryStrategy := dlock.NoRetry()\n\tif opts != nil && opts.RetryStrategy != nil {\n\t\tretryStrategy = opts.RetryStrategy\n\t}\n\n\tfor {\n\t\tlock, err := l.tryObtainMulti(ctx, keys, ttl, token)\n\t\tif err == nil {\n\t\t\treturn lock, nil\n\t\t}\n\n\t\tif ctx.Err() != nil {\n\t\t\treturn nil, ctx.Err()\n\t\t}\n\n\t\twaitInterval := retryStrategy.NextBackoff()\n\t\tif waitInterval <= 0 {\n\t\t\treturn nil, dlock.ErrNotObtained\n\t\t}\n\t\ttime.Sleep(waitInterval)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": []
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_physical_volume.go:113:131:checkExisting": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_physical_volume.go",
    "code_start_line": 113,
    "code_end_line": 131,
    "code_start_column": 39,
    "code_key": "checkExisting",
    "code_value": "func (c *CreatePhysicalVolumeCommand) checkExisting(ctx context.Context, vol *domain.PhysicalVolume) (existed bool, err error) {\n\tif vol == nil {\n\t\treturn false, nil\n\t}\n\tif vol.Deleted() {\n\t\terr := app.GetRegistry(ctx).Repositories.PhysicalVolume.Delete(ctx, vol)\n\t\tif err != nil {\n\t\t\treturn false, errors.Newf(domain.ErrConflictVolume, \"failed to delete conflict physical volume: %v\", err)\n\t\t}\n\t\treturn false, nil\n\t}\n\tif string(vol.Serial) != c.Serial {\n\t\treturn false, errors.Newf(domain.ErrConflictVolume, \"host %s bdf %s has been taken by %s\", vol.IP, vol.BDF, vol.Serial)\n\t}\n\tif !vol.IP.Equal(c.Host) || string(vol.BDF) != c.BDF {\n\t\treturn false, errors.Newf(domain.ErrConflictVolume, \"volume %s has been assigned to host %s bdf %s\", vol.Serial, vol.IP, vol.BDF)\n\t}\n\treturn true, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go",
        "code_start_line": 51,
        "code_end_line": 72,
        "code_key": "Handle",
        "code_value": "func (c *CbsAppIdConsumer) Handle(ctx context.Context, delivery *rabbitmq.Delivery) error {\n\tu, chargeTime, err := c.ParseDelivery(ctx, delivery)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif u == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"USER_INFO_NOT_FOUND\")\n\t\treturn nil\n\t}\n\n\tchargeDetail := c.GetChargeDetailForSingleUser(u, chargeTime)\n\tif chargeDetail == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tUint64(\"appId\", uint64(u.AppId)).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"NO_RESOURCE_TO_CHARGE\")\n\t\treturn nil\n\t}\n\treturn c.ProcessChargeDetail(chargeDetail)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 105,
        "code_end_line": 116,
        "code_key": "Handle",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tif err := c.ensureLocks(ctx); err != nil {\n\t\treturn err\n\t}\n\tif c.lvUUID != nil {\n\t\t// 涉及到逻辑卷时，需要先标记逻辑卷为故障\n\t\treturn c.handleBindedVolume(ctx)\n\t} else {\n\t\t// 不涉及到逻辑卷时，直接标记物理卷为故障\n\t\treturn c.handleIdleVolume(ctx)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/detach_logical_volume.go",
        "code_start_line": 56,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *DetachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDetachLogicalVolume, c)\n\n\t// 如果没有挂载到指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume not attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_benchmark_task.go",
        "code_start_line": 125,
        "code_end_line": 165,
        "code_key": "Handle",
        "code_value": "func (c *CreateBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tvolSm     = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = volSm.Fire(ctx, c.relatedVolume.State, domain.PVEStartBenchmark, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark = benchmark.New(benchmark.DiskInfo{\n\t\tSerial: string(c.relatedVolume.Serial),\n\t\tHostIP: c.relatedVolume.IP,\n\t\tBDF:    string(c.relatedVolume.BDF),\n\t})\n\n\tif err = benchRepo.Add(ctx, c.relatedBenchmark); err != nil {\n\t\tdelegate := &benchmarkDelegate{cmd: c}\n\t\tif _err := delegate.TaskFinishCallback(ctx, c.relatedBenchmark); _err != nil {\n\t\t\tlogs.Warn(ctx).Err(_err).Str(\"serial\", string(c.relatedVolume.Serial)).Msg(\"failed to rollback: create bdev\")\n\t\t}\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventCreateBench,\n\t\tbenchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_logical_volume.go",
        "code_start_line": 71,
        "code_end_line": 108,
        "code_key": "Handle",
        "code_value": "func (d *DeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\td.volume, err = repo.FindByID(ctx, d.UUID)\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif e := d.volume.CheckDelete(); e != nil {\n\t\treturn e\n\t}\n\n\tif d.volume.AppID != d.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"refuse to delet: app id mismatch\")\n\t}\n\n\td.drgroup, err = app.GetRegistry(ctx).Repositories.DRGroup.FindByMember(ctx, d.AppID, d.volume.UUID.String())\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\td.drgroup = nil\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := d.checkDRGroupMatch(ctx); err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, d.volume.State, rdiskDomain.LVEMarkToRecycle, d)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_recycled_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmRecycledPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEConfirmRecycled, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_rdisk_backup.go",
        "code_start_line": 52,
        "code_end_line": 75,
        "code_key": "Handle",
        "code_value": "func (c *DeleteRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tsm   = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\tc.relatedBackup, err = repo.FindByUUID(ctx, c.BackupID.String())\n\tif err != nil || c.relatedBackup == nil || c.relatedBackup.AppID != c.AppID {\n\t\treturn errors.New(backupDomain.ErrBackupNotExist, \"backup not exists\")\n\t}\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tc.relatedBackup.Status,\n\t\tbackupDomain.EventSoftDeleteBackup,\n\t\tbackupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: c.relatedBackup})\n\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_rdisk_backup.go",
        "code_start_line": 47,
        "code_end_line": 80,
        "code_key": "Handle",
        "code_value": "func (c *CreateRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tlvSm  = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\tbakSm = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo  = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t_, err = lvSm.Fire(ctx, c.relatedVolume.State, rdiskDomain.LVEBackupStarted, c)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tlv := c.relatedVolume\n\tbackup := backupDomain.New(\n\t\tlv.AppID,\n\t\tbackupDomain.DiskInfo{\n\t\t\tVolumeUUID: lv.UUID,\n\t\t\tVolumeSize: uint64(lv.Size),\n\t\t\tHostIP:     lv.PhysicalVolume.IP,\n\t\t\tHostBDF:    string(lv.PhysicalVolume.BDF),\n\t\t\tSerial:     string(lv.PhysicalVolume.Serial),\n\t\t},\n\t)\n\tif err := repo.Add(ctx, backup); err != nil {\n\t\treturn err\n\t}\n\tc.relatedBackup = backup\n\t_, err = bakSm.Fire(ctx, backupDomain.StatusInit, backupDomain.EventStartBackup, backupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: backup})\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/attach_logical_volume.go",
        "code_start_line": 49,
        "code_end_line": 71,
        "code_key": "Handle",
        "code_value": "func (c *AttachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEAttachLogicalVolume, c)\n\n\t// 如果已经挂载到了指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeAlreadyAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume already attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_delete_logical_volume.go",
        "code_start_line": 34,
        "code_end_line": 55,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\t// 如果逻辑卷不存在，则直接返回成功\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"failed to confirm delete: app id mismatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDeleteLogicalVolume, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/offline_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OfflinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOfflinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *DeletePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\t// 如果物理卷不存在，则直接幂等返回\n\t\treturn nil\n\t}\n\n\tvar event = domain.PVEDeletePhysicalVolume\n\tif c.Force && (c.relatedVolume.State == domain.PVSDefunct) {\n\t\t// 这里的实现不太好，状态机的逻辑不应该侵入 cmd\n\t\t// 时间太赶了，后续重构优化吧\n\t\tevent = domain.PVEForceDeleteForDefunct\n\t}\n\n\tif c.relatedVolume.HasBindedPV() {\n\t\treturn errors.New(domain.ErrVolumeBusy, \"logic volume has binded to this physical volume\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, event, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_logical_volume.go",
        "code_start_line": 55,
        "code_end_line": 70,
        "code_key": "Handle",
        "code_value": "func (c *CleanupLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVECleanupLogicalVolume, c)\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_init_physical_volume.go",
        "code_start_line": 26,
        "code_end_line": 52,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmInitPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\tif c.relatedVolume.IP.String() != c.Host.String() {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume host ip mistmatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVECreatePhysicalVolumeOnHost, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_physical_volume.go",
        "code_start_line": 51,
        "code_end_line": 101,
        "code_key": "Handle",
        "code_value": "func (c *CreatePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\n\t// 获取物理卷状态机\n\tsm := app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\trepo := app.GetRegistry(ctx).Repositories.PhysicalVolume\n\n\t// 检查物理卷是否已经存在，如果存在则直接幂等返回\n\tvol1, err := repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"serial\", c.Serial).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tvol2, err := repo.FindByIPAndBDF(ctx, c.Host, domain.BDF(c.BDF))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"host\", c.Host.String()).Str(\"bdf\", c.BDF).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tfor _, vol := range []*domain.PhysicalVolume{vol1, vol2} {\n\t\texisted, err := c.checkExisting(ctx, vol)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif existed {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// 触发事件，创建物理卷\n\t_, err = sm.Fire(ctx,\n\t\tdomain.PVSUnInited,\n\t\tdomain.PVECreatePhysicalVolume,\n\t\tc,\n\t)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 创建 Bdev 以及格式化移动到创建物理卷的状态机中\n\n\t// _, err = sm.Fire(ctx,\n\t// \tc.GetPhysicalVolume().State,\n\t// \tdomain.PVECreatePhysicalVolumeOnHost,\n\t// \tc,\n\t// )\n\t// if err != nil {\n\t// \treturn err\n\t// }\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_benchmark_task.go",
        "code_start_line": 32,
        "code_end_line": 57,
        "code_key": "Handle",
        "code_value": "func (c *DeleteBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\terr       error\n\t)\n\n\tbench, err := benchRepo.FindByUUID(ctx, c.BenchmarkUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif bench.DiskInfo.Serial != c.Serial {\n\t\treturn errors.Newf(benchmark.ErrTaskNotFound, \"benchmark serial not match %s, want %s\", c.Serial, bench.DiskInfo.Serial)\n\t}\n\n\t_, err = benchSm.Fire(ctx, bench.Status, benchmark.EventDeleteBench, benchmark.Data{Benchmark: bench, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := benchRepo.Delete(ctx, bench); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_logical_volume.go",
        "code_start_line": 52,
        "code_end_line": 98,
        "code_key": "Handle",
        "code_value": "func (c *CreateLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tpvRepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tlvRepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm     = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\t// 1. 查找底层物理卷\n\tc.selectedPhysicalVolume, err = pvRepo.FindBySerial(ctx, rdiskDomain.Serial(c.PhysicalVolumeSerial))\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// 检查底层物理卷大小是否满足要求\n\tif c.selectedPhysicalVolume.Size < rdiskDomain.Size(c.DiskSize) {\n\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume size %d is smaller than requested size %d\", c.selectedPhysicalVolume.Size, c.DiskSize)\n\t}\n\n\t// 检查底层物理卷性能等级是否满足要求\n\tif c.PerformanceRank != \"\" {\n\t\tif string(c.selectedPhysicalVolume.PerformanceRank) != c.PerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not match requested rank %s\", c.selectedPhysicalVolume.PerformanceRank, c.PerformanceRank)\n\t\t}\n\t} else {\n\t\tif c.selectedPhysicalVolume.PerformanceRank != rdiskDomain.DefaultPerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not default rank %s\", c.selectedPhysicalVolume.PerformanceRank, rdiskDomain.DefaultPerformanceRank)\n\t\t}\n\t}\n\n\t// 2. 创建逻辑卷\n\tvol := rdiskDomain.NewLogicalVolume(users.AppID(c.AppID), rdiskDomain.Size(c.DiskSize), rdiskDomain.ZoneID(c.ZoneID))\n\tif c.VolumeType != \"\" {\n\t\tvol.VolumeType = rdiskDomain.VolumeType(c.VolumeType)\n\t}\n\tif c.DiskType != \"\" {\n\t\tvol.DiskType = rdiskDomain.DiskType(c.DiskType)\n\t}\n\terr = lvRepo.Add(ctx, vol)\n\tif err != nil {\n\t\treturn\n\t}\n\tc.createdLogicalVolume = vol\n\n\t// 3. 触发状态机，联动更新逻辑卷和物理卷状态\n\t_, err = sm.Fire(ctx, rdiskDomain.LVSUnInited, rdiskDomain.LVECreateLogicalVolume, c)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_running_backup_task.go",
        "code_start_line": 31,
        "code_end_line": 61,
        "code_key": "Handle",
        "code_value": "func (c *UpdateRunningBackupTaskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventUpdateBackupProgress,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_drgroup.go",
        "code_start_line": 78,
        "code_end_line": 173,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeDRGroupCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tlvView  = app.GetRegistry(ctx).Viewers.LogicalVolume\n\t\tdrgRepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t\tsm      = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\terr     error\n\t)\n\n\t// 0. 初始化\n\tc.drgroupRef = make(map[string]*drgroup.DRGroup)\n\n\t// 1. 加载所有逻辑卷所在的置放群组\n\tallVolumeUUIDs := make([]string, 0, len(c.UUIDs))\n\tfor _, _uuid := range c.UUIDs {\n\t\tallVolumeUUIDs = append(allVolumeUUIDs, _uuid.String())\n\t}\n\tif groups, err := drgRepo.FindByMembers(ctx, c.AppID, allVolumeUUIDs); err == nil {\n\t\tif err != nil {\n\t\t\tif !errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tfor _, group := range groups {\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t\tc.curDRGroupNames = append(c.curDRGroupNames, group.Name)\n\t\t}\n\t} else {\n\t\treturn err\n\t}\n\n\t// 2. 确认已上锁的置放群组和当前一致\n\tif !c.checkLockedDRGroupNames() {\n\t\treturn errors.New(drgroup.ErrGroupModified, \"drgroup changed\")\n\t}\n\n\t// 3. 加载所有逻辑卷的状态，不需要完整实体，因为不会修改 Volume\n\tc.relatedLogicalVolume, err = lvView.FindByIDs(ctx, c.AppID, c.UUIDs)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(c.relatedLogicalVolume) < len(c.UUIDs) {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t// 4. 加载所有目标置放群组，key 为 name\n\tfor _, spec := range c.Specs {\n\t\tvar group *drgroup.DRGroup\n\t\tif _, ok := c.drgroupRef[spec.Name]; ok {\n\t\t\tgroup = c.drgroupRef[spec.Name]\n\t\t} else {\n\t\t\tgroup, err = c.getOrCreateDRGroup(ctx, drgRepo, spec)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t}\n\n\t\tif spec.Affinity > 0 {\n\t\t\tgroup.Affinity = spec.Affinity\n\t\t}\n\t\tif spec.Type != \"\" {\n\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t}\n\t}\n\n\t// 5. 对所有逻辑卷执行置放群组变更事件，检查状态是否允许，\n\t//    实际的更新还是在这里执行。\n\tfor _, vol := range c.relatedLogicalVolume {\n\t\terr := sm.Check(ctx, vol.State, rdiskDomain.LVEUpdateDrGroup, c)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// 将逻辑卷从原有的置放群组中移除\n\t\tfor _, name := range c.curDRGroupNames {\n\t\t\tc.drgroupRef[name].RemoveMember(vol.UUID.String())\n\t\t}\n\t\t// 将逻辑卷添加到新的置放群组中\n\t\tfor _, spec := range c.Specs {\n\t\t\tsubGroup := spec.SubGroup\n\t\t\tif subGroup == \"\" {\n\t\t\t\t// 如果没有指定子组，则使用远端 SSD UUID 作为子组名称\n\t\t\t\t// 相当于每块盘都是一个子组，相当于没有使用子组功能\n\t\t\t\tsubGroup = vol.UUID.String()\n\t\t\t}\n\t\t\tif err := c.drgroupRef[spec.Name].AddMember(vol.UUID.String(), subGroup, vol.PhysicalVolume.IP.String()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tif c.DryRun {\n\t\treturn errors.New(errors.ErrDryRunSuccessExit, \"dry run check success\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/online_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OnlinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOnlinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_benchmark_task.go",
        "code_start_line": 34,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *UpdateBenchmarkTask) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, rdisk.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark, err = benchRepo.FindByUUID(ctx, c.BenchmarkUUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventUpdateBench, benchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_flow_ctrl.go",
        "code_start_line": 80,
        "code_end_line": 103,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeFlowControlCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not found\")\n\t}\n\n\tspec := c.volume.FlowControlSpec\n\tif !c.UpdateRequest.UpdateSpec(&spec, c.volume.GetDefaultFlowControlSpec()) {\n\t\t// 没有任何更新，直接返回成功\n\t\treturn nil\n\t}\n\tc.volume.SetFlowControlSpec(spec)\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEUpdateFlowControl, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_defunct_volume.go",
        "code_start_line": 46,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *CleanupDefunctCommand) Handle(ctx context.Context) error {\n\tvar err error\n\tc.lv, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar sm = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\tvar event = rdiskDomain.LVECleanupDefunct\n\n\tfor _, attachment := range c.lv.Attachments {\n\t\tlogs.Info(ctx).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).Msg(\"cleanup defuncting volume\")\n\t\tsubCmd := &cleanDefunctSubCommand{Parent: c, HostIP: attachment.IP}\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, subCmd)\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，因为只要有一个挂载点清理失败，其他挂载点还是需要继续清理的\n\t\t\t// 失败的挂载点会在后台继续清理\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).\n\t\t\t\tMsg(\"failed to cleanup defunct volume, retry later.\")\n\t\t}\n\t}\n\n\tif len(c.lv.Attachments) == 0 {\n\t\t// 没有挂载点，直接清理\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, &cleanDefunctSubCommand{Parent: c, HostIP: net.IP{}})\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，后续自动重试即可\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Msg(\"failed to complete cleanup defunct volume\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_drgroup_exists.go",
        "code_start_line": 28,
        "code_end_line": 53,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDRGroupExistsCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t)\n\tfor _, spec := range c.DRGroup {\n\t\t_, err := repo.FindByName(ctx, users.AppID(c.AppID), spec.Name)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\tgroup := drgroup.New(spec.Name, users.AppID(c.AppID))\n\t\t\t\tif spec.Affinity > 0 {\n\t\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t\t}\n\t\t\t\tif spec.Type != \"\" {\n\t\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t\t}\n\t\t\t\terr = repo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_physical_volume.go",
        "code_start_line": 31,
        "code_end_line": 54,
        "code_key": "Handle",
        "code_value": "func (c *UpdatePhyRDiskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEUpdatePhysicalVolume, c)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/recycle_backup_data.go",
        "code_start_line": 32,
        "code_end_line": 62,
        "code_key": "Handle",
        "code_value": "func (c *RecycleBackupDataCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventDeleteBackup,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 67,
        "code_end_line": 83,
        "code_key": "PhysicalVolume",
        "code_value": "type PhysicalVolume struct {\n\tEntityMixin\n\tSerial          Serial              // 物理卷序列号\n\tIP              net.IP              // 物理卷所在主机 IP\n\tBDF             BDF                 // 物理卷所在主机的 BDF\n\tDiskID          uint64              // 物理卷在主机上的 BDev ID\n\tState           PhysicalVolumeState // 物理卷状态\n\tSize            Size                // 物理卷对外售卖大小 GiB\n\tVolumeType      VolumeType          // 物理卷类型\n\tZoneID          ZoneID              // 物理卷所在的 Zone\n\tBlockSize       uint                // 物理卷块大小，通常为 512\n\tRealSize        uint64              // 物理卷实际大小，单位为 Byte\n\tPort            uint                // 物理卷所在主机的端口\n\tDataNodeType    DataNodeType        // 数据节点类型\n\tCuf             Cuf                 // 存储节点 CUF 信息\n\tPerformanceRank PerformanceRank     // 物理卷性能等级\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/create_logic_disk.go:61:63:InvokeDeleteLogicalVolume": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/create_logic_disk.go",
    "code_start_line": 61,
    "code_end_line": 63,
    "code_start_column": 6,
    "code_key": "InvokeDeleteLogicalVolume",
    "code_value": "func InvokeDeleteLogicalVolume(ctx context.Context, source rdiskDomain.LogicalVolumeState, target rdiskDomain.LogicalVolumeState, stateCtx app.LogicalVolumeContext) (rdiskDomain.LogicalVolumeState, error) {\n\treturn target, stateCtx.GetLogicalVolume().Delete()\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [],
    "code_meta_data": []
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go:48:132:StepGivenInitDB": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
    "code_start_line": 48,
    "code_end_line": 132,
    "code_start_column": 6,
    "code_key": "StepGivenInitDB",
    "code_value": "func StepGivenInitDB(t *testing.T) (*gorm.DB, string) {\n\tmysqlUrl := os.Getenv(\"CBS_TEST_MYSQL_URL\")\n\tif mysqlUrl == \"\" {\n\t\t// 默认使用这个配置，用 DOCKER 启动一个 MySQL 服务:\n\t\t// docker run -d --rm -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7\n\t\tuser := \"root\"\n\t\tpasswd := \"123456\"\n\t\thost := \"9.134.233.30\"\n\t\tport := 4567\n\t\tmysqlUrl = fmt.Sprintf(\"%s:%s@tcp(%s:%d)/?charset=utf8mb4&parseTime=True&loc=Local\",\n\t\t\tuser, passwd, host, port)\n\t}\n\tdatabase := os.Getenv(\"CBS_TEST_MYSQL_DATABASE\")\n\tif database == \"\" {\n\t\tdatabase = fmt.Sprintf(\"test-singularity-%d-%d\", 0, 0)\n\t}\n\n\tdb, err := gorm.Open(mysql.Open(mysqlUrl), &gorm.Config{})\n\tif err != nil {\n\t\tt.Skipf(\"failed to connect to mysql server: %s\", err)\n\t}\n\tassert.NoError(t, db.Exec(fmt.Sprintf(\"DROP DATABASE IF EXISTS `%s`\", database)).Error, \"failed to drop database\")\n\tassert.NoError(t, db.Exec(fmt.Sprintf(\"CREATE DATABASE `%s`\", database)).Error, \"failed to create database\")\n\n\t// 查找 `/?` 的位置\n\tindex := strings.Index(mysqlUrl, \"/?\")\n\tif index == -1 {\n\t\tfmt.Println(\"Invalid MySQL URL format\")\n\t}\n\t// 在 `/?` 之前插入数据库名称\n\tmysqlUrlWithDB := mysqlUrl[:index+1] + database + mysqlUrl[index+1:]\n\tdb, err = gorm.Open(mysql.Open(mysqlUrlWithDB), &gorm.Config{\n\t\tLogger: logger.Default.LogMode(logger.Silent),\n\t})\n\tif err != nil {\n\t\tt.Skipf(\"failed to connect to mysql server: %s\", err)\n\t}\n\tsqlDB, err := db.DB()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tsqlDB.SetMaxOpenConns(32)\n\n\tpath := \"../../../../changelog/db/metadb\"\n\tcontent := strings.Builder{}\n\terr = filepath.Walk(path, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !info.IsDir() {\n\t\t\tmatched, err := filepath.Match(\"*.sql\", info.Name())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif matched {\n\t\t\t\tsqlcontent, err := os.ReadFile(path)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tcontent.Write(sqlcontent)\n\t\t\t\tcontent.WriteString(\"\\n\")\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tpanic(fmt.Errorf(\"failed to read db file: %s\", err))\n\t}\n\tstmts := strings.Split(string(content.String()), \";\\n\")\n\tfor _, stmt := range stmts {\n\t\tstmt = strings.Trim(stmt, \" \\n\")\n\t\tif stmt == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tif strings.HasPrefix(stmt, \"USE \") {\n\t\t\t// Ignore USE statement\n\t\t\tcontinue\n\t\t}\n\t\terr = db.Exec(stmt).Error\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\treturn db, database\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 3,
    "callers": [],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/registry/registry.go",
        "code_start_line": 20,
        "code_end_line": 25,
        "code_key": "Config",
        "code_value": "type Config struct {\n\tRegion         map[string]*RegionInfo `mapstructure:\"region\" json:\"region\" yaml:\"region\" toml:\"region\"`\n\tLog            *logs.Config           `mapstructure:\"log\" json:\"log\" yaml:\"log\" toml:\"log\"`\n\tDatabases      *DatabaseConfig        `mapstructure:\"database\" json:\"database\" yaml:\"database\" toml:\"database\"`\n\tConsumerConfig map[string]interface{} `mapstructure:\"consumer\" json:\"consumer\" yaml:\"consumer\" toml:\"consumer\"`\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/config/config.go",
        "code_start_line": 24,
        "code_end_line": 28,
        "code_key": "Config",
        "code_value": "type Config struct {\n\tGlobal          *GlobalConfig\n\tMainLogConfig   *logs.Config\n\tRegionPipelines map[string]*regionPipelineConfig\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/clients/trade_client/trade_api.go",
        "code_start_line": 28,
        "code_end_line": 33,
        "code_key": "Config",
        "code_value": "type Config struct {\n\tProductCode string\n\tURL         string\n\tSecretID    string\n\tSecretKey   string\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/clients/cos/client.go",
        "code_start_line": 22,
        "code_end_line": 31,
        "code_key": "Config",
        "code_value": "type Config struct {\n\tAppID     int64  // 腾讯云 AppID\n\tSecretID  string // 腾讯云 SecretID，可以是临时密钥，也可以是永久密钥\n\tSecretKey string // 腾讯云 SecretKey，可以是临时密钥，也可以是永久密钥\n\tRegion    string // 腾讯云 COS 区域，默认为 ap-guangzhou\n\tBucket    string // 腾讯云 COS Bucket 名称\n\tDomain    string // 自定义域名，如果不传入则使用默认域名\n\tToken     string // 临时密钥 Token，如果使用永久密钥则不需要传入此字段\n\tStsDomain string // Sts 自定义域名\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/logs/log.go",
        "code_start_line": 17,
        "code_end_line": 26,
        "code_key": "Config",
        "code_value": "type Config struct {\n\tLevel               string `mapstructure:\"level\"`                 // 日志级别\n\tEnableConsoleLogger bool   `mapstructure:\"enable_console_logger\"` // 是否启用控制台日志\n\tEnableFileLogger    bool   `mapstructure:\"enable_file_logger\"`    // 是否启用文件日志\n\tLogFileDir          string `mapstructure:\"log_file_dir\"`          // 日志文件目录\n\tLogFileName         string `mapstructure:\"log_file_name\"`         // 日志文件名\n\tLogFileMaxBackups   int    `mapstructure:\"log_file_max_backups\"`  // 日志文件最大备份数\n\tLogFileMaxAge       int    `mapstructure:\"log_file_max_age\"`      // 日志文件最大保存天数\n\tLogFileMaxSize      int    `mapstructure:\"log_file_max_size\"`     // 日志文件最大大小，单位 MB\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/mq/mqimpl/rabbitMq/config.go",
        "code_start_line": 35,
        "code_end_line": 39,
        "code_key": "Config",
        "code_value": "type Config struct {\n\tUrl       string           `mapstructure:\"url\"`\n\tConsumers []ConsumerConfig `mapstructure:\"consumers\"`\n\tProducers []ProducerConfig `mapstructure:\"producers\"`\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/registry.go",
        "code_start_line": 20,
        "code_end_line": 24,
        "code_key": "Config",
        "code_value": "type Config struct {\n\tLog            logs.Config                 `mapstructure:\"log\" json:\"log\" yaml:\"log\"`\n\tMetaDB         configs.MySQLConfig         `mapstructure:\"metadb\" json:\"metadb\" yaml:\"metadb\"`\n\tCOSCredentials backupDomain.COSCredentials `mapstructure:\"cos_credentials\" json:\"cos_credentials\" yaml:\"cos_credentials\"`\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 32,
        "code_end_line": 39,
        "code_key": "Config",
        "code_value": "type Config struct {\n\tTableName      string\n\tLockColumn     string\n\tExpireColumn   string\n\tTokenColumn    string\n\tLockTypeColumn string\n\tLockNumsColumn string\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go:214:239:StepGivenAPhysicalVol": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
    "code_start_line": 214,
    "code_end_line": 239,
    "code_start_column": 6,
    "code_key": "StepGivenAPhysicalVol",
    "code_value": "func StepGivenAPhysicalVol(registry *app.Registry, value interface{}) *rdiskDomain.PhysicalVolume {\n\tphysicalVol := &rdiskDomain.PhysicalVolume{\n\t\tEntityMixin:  rdiskDomain.EntityMixin{ID: 1},\n\t\tSerial:       \"12345\",\n\t\tIP:           net.IP{127, 0, 0, 1},\n\t\tBDF:          \"bdf\",\n\t\tDiskID:       0,\n\t\tState:        rdiskDomain.PhysicalVolumeState(value.(int)),\n\t\tSize:         1,\n\t\tVolumeType:   \"NVME\",\n\t\tZoneID:       1,\n\t\tBlockSize:    512,\n\t\tRealSize:     5120,\n\t\tPort:         1,\n\t\tDataNodeType: \"unknown\",\n\t\tCuf:          \"清远-清新-C2\",\n\t}\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\terr := registry.Repositories.PhysicalVolume.Add(workerCtx, physicalVol)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn physicalVol\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 67,
        "code_end_line": 83,
        "code_key": "PhysicalVolume",
        "code_value": "type PhysicalVolume struct {\n\tEntityMixin\n\tSerial          Serial              // 物理卷序列号\n\tIP              net.IP              // 物理卷所在主机 IP\n\tBDF             BDF                 // 物理卷所在主机的 BDF\n\tDiskID          uint64              // 物理卷在主机上的 BDev ID\n\tState           PhysicalVolumeState // 物理卷状态\n\tSize            Size                // 物理卷对外售卖大小 GiB\n\tVolumeType      VolumeType          // 物理卷类型\n\tZoneID          ZoneID              // 物理卷所在的 Zone\n\tBlockSize       uint                // 物理卷块大小，通常为 512\n\tRealSize        uint64              // 物理卷实际大小，单位为 Byte\n\tPort            uint                // 物理卷所在主机的端口\n\tDataNodeType    DataNodeType        // 数据节点类型\n\tCuf             Cuf                 // 存储节点 CUF 信息\n\tPerformanceRank PerformanceRank     // 物理卷性能等级\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 16,
        "code_end_line": 18,
        "code_key": "EntityMixin",
        "code_value": "type EntityMixin struct {\n\tID uint64\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go:244:277:StepGivenPhysicalVols": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
    "code_start_line": 244,
    "code_end_line": 277,
    "code_start_column": 6,
    "code_key": "StepGivenPhysicalVols",
    "code_value": "func StepGivenPhysicalVols(registry *app.Registry, value interface{}, num interface{}) []*rdiskDomain.PhysicalVolume {\n\tvar physicalVols []*rdiskDomain.PhysicalVolume\n\tfor i := 0; i < num.(int); i++ {\n\t\tphysicalVols = append(physicalVols, &rdiskDomain.PhysicalVolume{\n\t\t\tEntityMixin:  rdiskDomain.EntityMixin{},\n\t\t\tSerial:       rdiskDomain.Serial(\"111\" + strconv.Itoa(i)),\n\t\t\tIP:           net.IP{127, 0, byte(((i + 2) / 255) % 255), byte((i + 2) % 255)},\n\t\t\tBDF:          \"bdf\",\n\t\t\tDiskID:       0,\n\t\t\tState:        rdiskDomain.PhysicalVolumeState(value.(int)),\n\t\t\tSize:         1,\n\t\t\tVolumeType:   \"\",\n\t\t\tZoneID:       1,\n\t\t\tBlockSize:    512,\n\t\t\tRealSize:     5120,\n\t\t\tPort:         1,\n\t\t\tDataNodeType: \"\",\n\t\t\tCuf:          \"清远-清新-C2\",\n\t\t})\n\t}\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\tfor _, vol := range physicalVols {\n\t\terr := registry.Repositories.PhysicalVolume.Add(workerCtx, vol)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\terr := uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn physicalVols\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 67,
        "code_end_line": 83,
        "code_key": "PhysicalVolume",
        "code_value": "type PhysicalVolume struct {\n\tEntityMixin\n\tSerial          Serial              // 物理卷序列号\n\tIP              net.IP              // 物理卷所在主机 IP\n\tBDF             BDF                 // 物理卷所在主机的 BDF\n\tDiskID          uint64              // 物理卷在主机上的 BDev ID\n\tState           PhysicalVolumeState // 物理卷状态\n\tSize            Size                // 物理卷对外售卖大小 GiB\n\tVolumeType      VolumeType          // 物理卷类型\n\tZoneID          ZoneID              // 物理卷所在的 Zone\n\tBlockSize       uint                // 物理卷块大小，通常为 512\n\tRealSize        uint64              // 物理卷实际大小，单位为 Byte\n\tPort            uint                // 物理卷所在主机的端口\n\tDataNodeType    DataNodeType        // 数据节点类型\n\tCuf             Cuf                 // 存储节点 CUF 信息\n\tPerformanceRank PerformanceRank     // 物理卷性能等级\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 16,
        "code_end_line": 18,
        "code_key": "EntityMixin",
        "code_value": "type EntityMixin struct {\n\tID uint64\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go:282:304:StepGivenALogicalVol": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
    "code_start_line": 282,
    "code_end_line": 304,
    "code_start_column": 6,
    "code_key": "StepGivenALogicalVol",
    "code_value": "func StepGivenALogicalVol(registry *app.Registry, physicalVol *rdiskDomain.PhysicalVolume, value interface{}) *rdiskDomain.LogicalVolume {\n\tlogicalVol := &rdiskDomain.LogicalVolume{\n\t\tEntityMixin:     rdiskDomain.EntityMixin{ID: 1},\n\t\tUUID:            uuid.Must(uuid.NewRandom()),\n\t\tState:           rdiskDomain.LogicalVolumeState(value.(int)),\n\t\tSize:            1,\n\t\tAppID:           123,\n\t\tZoneID:          1,\n\t\tDiskType:        \"\",\n\t\tVolumeType:      \"\",\n\t\tFlowControlSpec: rdiskDomain.FlowControlSpec{},\n\t\tPhysicalVolume:  physicalVol,\n\t\tAttachments:     nil,\n\t}\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\terr := registry.Repositories.LogicalVolume.Add(workerCtx, logicalVol)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn logicalVol\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 178,
        "code_end_line": 190,
        "code_key": "LogicalVolume",
        "code_value": "type LogicalVolume struct {\n\tEntityMixin\n\tUUID            uuid.UUID\n\tState           LogicalVolumeState\n\tSize            Size\n\tAppID           users.AppID\n\tZoneID          ZoneID\n\tDiskType        DiskType\n\tVolumeType      VolumeType\n\tFlowControlSpec FlowControlSpec\n\tPhysicalVolume  *PhysicalVolume\n\tAttachments     []*VolumeAttachment\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 16,
        "code_end_line": 18,
        "code_key": "EntityMixin",
        "code_value": "type EntityMixin struct {\n\tID uint64\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 417,
        "code_end_line": 424,
        "code_key": "FlowControlSpec",
        "code_value": "type FlowControlSpec struct {\n\tMaxReadMBps  int64 // 最大读带宽\n\tMaxReadIOPS  int64 // 最大读 IOPS\n\tMaxWriteMBps int64 // 最大写带宽\n\tMaxWriteIOPS int64 // 最大写 IOPS\n\tMaxRWMBps    int64 // 最大读写带宽\n\tMaxRWIOPS    int64 // 最大读写 IOPS\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go:351:364:StepThenLogicalVolStateShouldBe": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
    "code_start_line": 351,
    "code_end_line": 364,
    "code_start_column": 6,
    "code_key": "StepThenLogicalVolStateShouldBe",
    "code_value": "func StepThenLogicalVolStateShouldBe(logicalVol *rdiskDomain.LogicalVolume, registry *app.Registry, db *gorm.DB, database string, value interface{}) *rdiskDomain.LogicalVolume {\n\tdb.Exec(fmt.Sprintf(\"USE `%s`\", database))\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\tnewLogicalVol, err := registry.Repositories.LogicalVolume.FindByAppIDAndUUID(workerCtx, logicalVol.AppID, logicalVol.UUID)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif newLogicalVol.State != rdiskDomain.LogicalVolumeState(value.(int)) {\n\t\tpanic(\"LogicalVol state error\")\n\t}\n\treturn newLogicalVol\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 2,
    "callers": [],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 178,
        "code_end_line": 190,
        "code_key": "LogicalVolume",
        "code_value": "type LogicalVolume struct {\n\tEntityMixin\n\tUUID            uuid.UUID\n\tState           LogicalVolumeState\n\tSize            Size\n\tAppID           users.AppID\n\tZoneID          ZoneID\n\tDiskType        DiskType\n\tVolumeType      VolumeType\n\tFlowControlSpec FlowControlSpec\n\tPhysicalVolume  *PhysicalVolume\n\tAttachments     []*VolumeAttachment\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go:433:449:StepThenPhysicalVolShouldBe": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
    "code_start_line": 433,
    "code_end_line": 449,
    "code_start_column": 6,
    "code_key": "StepThenPhysicalVolShouldBe",
    "code_value": "func StepThenPhysicalVolShouldBe(physicalVol *rdiskDomain.PhysicalVolume, registry *app.Registry, db *gorm.DB, database string, field string, value interface{}) *rdiskDomain.PhysicalVolume {\n\tdb.Exec(fmt.Sprintf(\"USE `%s`\", database))\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\tnewPhysicalVol, err := registry.Repositories.PhysicalVolume.FindBySerial(workerCtx, physicalVol.Serial)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tswitch field {\n\tcase \"cuf\":\n\t\tif newPhysicalVol.Cuf != rdiskDomain.Cuf(value.(string)) {\n\t\t\tpanic(\"Result error\")\n\t\t}\n\t}\n\treturn newPhysicalVol\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 2,
    "callers": [],
    "code_meta_data": []
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go:618:630:StepThenPhysicalVolShouldBeRight": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
    "code_start_line": 618,
    "code_end_line": 630,
    "code_start_column": 6,
    "code_key": "StepThenPhysicalVolShouldBeRight",
    "code_value": "func StepThenPhysicalVolShouldBeRight(physicalVol *rdiskDomain.PhysicalVolume, registry *app.Registry, t *testing.T) {\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\tnewPhysicalVol, err := registry.Repositories.PhysicalVolume.FindBySerial(workerCtx, physicalVol.Serial)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif physicalVol.BDF != newPhysicalVol.BDF || physicalVol.Cuf != newPhysicalVol.Cuf || rdiskDomain.PVSInited != newPhysicalVol.State || physicalVol.DataNodeType != newPhysicalVol.DataNodeType ||\n\t\t!physicalVol.IP.Equal(newPhysicalVol.IP) || physicalVol.VolumeType != newPhysicalVol.VolumeType || physicalVol.Size != newPhysicalVol.Size {\n\t\tpanic(\"data error\")\n\t}\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [],
    "code_meta_data": []
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/benchmark.go:42:50:FindByUUID": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/benchmark.go",
    "code_start_line": 42,
    "code_end_line": 50,
    "code_start_column": 43,
    "code_key": "FindByUUID",
    "code_value": "func (repo *rdiskBenchmarkRepositoryImpl) FindByUUID(ctx context.Context, uuid string) (*benchmark.Benchmark, error) {\n\tuow := getUow(ctx)\n\tb := &metadb.DmRdiskBenchmark{}\n\tresult := uow.tx.First(b, \"uuid = ?\", uuid)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\treturn uow.trackedBenchmarks.Add(repo.fromDoToModel(b)), nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go",
        "code_start_line": 51,
        "code_end_line": 72,
        "code_key": "Handle",
        "code_value": "func (c *CbsAppIdConsumer) Handle(ctx context.Context, delivery *rabbitmq.Delivery) error {\n\tu, chargeTime, err := c.ParseDelivery(ctx, delivery)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif u == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"USER_INFO_NOT_FOUND\")\n\t\treturn nil\n\t}\n\n\tchargeDetail := c.GetChargeDetailForSingleUser(u, chargeTime)\n\tif chargeDetail == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tUint64(\"appId\", uint64(u.AppId)).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"NO_RESOURCE_TO_CHARGE\")\n\t\treturn nil\n\t}\n\treturn c.ProcessChargeDetail(chargeDetail)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 105,
        "code_end_line": 116,
        "code_key": "Handle",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tif err := c.ensureLocks(ctx); err != nil {\n\t\treturn err\n\t}\n\tif c.lvUUID != nil {\n\t\t// 涉及到逻辑卷时，需要先标记逻辑卷为故障\n\t\treturn c.handleBindedVolume(ctx)\n\t} else {\n\t\t// 不涉及到逻辑卷时，直接标记物理卷为故障\n\t\treturn c.handleIdleVolume(ctx)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/detach_logical_volume.go",
        "code_start_line": 56,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *DetachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDetachLogicalVolume, c)\n\n\t// 如果没有挂载到指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume not attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_benchmark_task.go",
        "code_start_line": 125,
        "code_end_line": 165,
        "code_key": "Handle",
        "code_value": "func (c *CreateBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tvolSm     = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = volSm.Fire(ctx, c.relatedVolume.State, domain.PVEStartBenchmark, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark = benchmark.New(benchmark.DiskInfo{\n\t\tSerial: string(c.relatedVolume.Serial),\n\t\tHostIP: c.relatedVolume.IP,\n\t\tBDF:    string(c.relatedVolume.BDF),\n\t})\n\n\tif err = benchRepo.Add(ctx, c.relatedBenchmark); err != nil {\n\t\tdelegate := &benchmarkDelegate{cmd: c}\n\t\tif _err := delegate.TaskFinishCallback(ctx, c.relatedBenchmark); _err != nil {\n\t\t\tlogs.Warn(ctx).Err(_err).Str(\"serial\", string(c.relatedVolume.Serial)).Msg(\"failed to rollback: create bdev\")\n\t\t}\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventCreateBench,\n\t\tbenchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_logical_volume.go",
        "code_start_line": 71,
        "code_end_line": 108,
        "code_key": "Handle",
        "code_value": "func (d *DeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\td.volume, err = repo.FindByID(ctx, d.UUID)\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif e := d.volume.CheckDelete(); e != nil {\n\t\treturn e\n\t}\n\n\tif d.volume.AppID != d.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"refuse to delet: app id mismatch\")\n\t}\n\n\td.drgroup, err = app.GetRegistry(ctx).Repositories.DRGroup.FindByMember(ctx, d.AppID, d.volume.UUID.String())\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\td.drgroup = nil\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := d.checkDRGroupMatch(ctx); err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, d.volume.State, rdiskDomain.LVEMarkToRecycle, d)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_recycled_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmRecycledPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEConfirmRecycled, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_rdisk_backup.go",
        "code_start_line": 52,
        "code_end_line": 75,
        "code_key": "Handle",
        "code_value": "func (c *DeleteRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tsm   = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\tc.relatedBackup, err = repo.FindByUUID(ctx, c.BackupID.String())\n\tif err != nil || c.relatedBackup == nil || c.relatedBackup.AppID != c.AppID {\n\t\treturn errors.New(backupDomain.ErrBackupNotExist, \"backup not exists\")\n\t}\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tc.relatedBackup.Status,\n\t\tbackupDomain.EventSoftDeleteBackup,\n\t\tbackupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: c.relatedBackup})\n\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_rdisk_backup.go",
        "code_start_line": 47,
        "code_end_line": 80,
        "code_key": "Handle",
        "code_value": "func (c *CreateRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tlvSm  = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\tbakSm = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo  = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t_, err = lvSm.Fire(ctx, c.relatedVolume.State, rdiskDomain.LVEBackupStarted, c)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tlv := c.relatedVolume\n\tbackup := backupDomain.New(\n\t\tlv.AppID,\n\t\tbackupDomain.DiskInfo{\n\t\t\tVolumeUUID: lv.UUID,\n\t\t\tVolumeSize: uint64(lv.Size),\n\t\t\tHostIP:     lv.PhysicalVolume.IP,\n\t\t\tHostBDF:    string(lv.PhysicalVolume.BDF),\n\t\t\tSerial:     string(lv.PhysicalVolume.Serial),\n\t\t},\n\t)\n\tif err := repo.Add(ctx, backup); err != nil {\n\t\treturn err\n\t}\n\tc.relatedBackup = backup\n\t_, err = bakSm.Fire(ctx, backupDomain.StatusInit, backupDomain.EventStartBackup, backupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: backup})\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/attach_logical_volume.go",
        "code_start_line": 49,
        "code_end_line": 71,
        "code_key": "Handle",
        "code_value": "func (c *AttachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEAttachLogicalVolume, c)\n\n\t// 如果已经挂载到了指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeAlreadyAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume already attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_delete_logical_volume.go",
        "code_start_line": 34,
        "code_end_line": 55,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\t// 如果逻辑卷不存在，则直接返回成功\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"failed to confirm delete: app id mismatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDeleteLogicalVolume, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/offline_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OfflinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOfflinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *DeletePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\t// 如果物理卷不存在，则直接幂等返回\n\t\treturn nil\n\t}\n\n\tvar event = domain.PVEDeletePhysicalVolume\n\tif c.Force && (c.relatedVolume.State == domain.PVSDefunct) {\n\t\t// 这里的实现不太好，状态机的逻辑不应该侵入 cmd\n\t\t// 时间太赶了，后续重构优化吧\n\t\tevent = domain.PVEForceDeleteForDefunct\n\t}\n\n\tif c.relatedVolume.HasBindedPV() {\n\t\treturn errors.New(domain.ErrVolumeBusy, \"logic volume has binded to this physical volume\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, event, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_logical_volume.go",
        "code_start_line": 55,
        "code_end_line": 70,
        "code_key": "Handle",
        "code_value": "func (c *CleanupLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVECleanupLogicalVolume, c)\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_init_physical_volume.go",
        "code_start_line": 26,
        "code_end_line": 52,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmInitPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\tif c.relatedVolume.IP.String() != c.Host.String() {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume host ip mistmatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVECreatePhysicalVolumeOnHost, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_physical_volume.go",
        "code_start_line": 51,
        "code_end_line": 101,
        "code_key": "Handle",
        "code_value": "func (c *CreatePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\n\t// 获取物理卷状态机\n\tsm := app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\trepo := app.GetRegistry(ctx).Repositories.PhysicalVolume\n\n\t// 检查物理卷是否已经存在，如果存在则直接幂等返回\n\tvol1, err := repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"serial\", c.Serial).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tvol2, err := repo.FindByIPAndBDF(ctx, c.Host, domain.BDF(c.BDF))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"host\", c.Host.String()).Str(\"bdf\", c.BDF).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tfor _, vol := range []*domain.PhysicalVolume{vol1, vol2} {\n\t\texisted, err := c.checkExisting(ctx, vol)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif existed {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// 触发事件，创建物理卷\n\t_, err = sm.Fire(ctx,\n\t\tdomain.PVSUnInited,\n\t\tdomain.PVECreatePhysicalVolume,\n\t\tc,\n\t)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 创建 Bdev 以及格式化移动到创建物理卷的状态机中\n\n\t// _, err = sm.Fire(ctx,\n\t// \tc.GetPhysicalVolume().State,\n\t// \tdomain.PVECreatePhysicalVolumeOnHost,\n\t// \tc,\n\t// )\n\t// if err != nil {\n\t// \treturn err\n\t// }\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_benchmark_task.go",
        "code_start_line": 32,
        "code_end_line": 57,
        "code_key": "Handle",
        "code_value": "func (c *DeleteBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\terr       error\n\t)\n\n\tbench, err := benchRepo.FindByUUID(ctx, c.BenchmarkUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif bench.DiskInfo.Serial != c.Serial {\n\t\treturn errors.Newf(benchmark.ErrTaskNotFound, \"benchmark serial not match %s, want %s\", c.Serial, bench.DiskInfo.Serial)\n\t}\n\n\t_, err = benchSm.Fire(ctx, bench.Status, benchmark.EventDeleteBench, benchmark.Data{Benchmark: bench, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := benchRepo.Delete(ctx, bench); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_logical_volume.go",
        "code_start_line": 52,
        "code_end_line": 98,
        "code_key": "Handle",
        "code_value": "func (c *CreateLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tpvRepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tlvRepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm     = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\t// 1. 查找底层物理卷\n\tc.selectedPhysicalVolume, err = pvRepo.FindBySerial(ctx, rdiskDomain.Serial(c.PhysicalVolumeSerial))\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// 检查底层物理卷大小是否满足要求\n\tif c.selectedPhysicalVolume.Size < rdiskDomain.Size(c.DiskSize) {\n\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume size %d is smaller than requested size %d\", c.selectedPhysicalVolume.Size, c.DiskSize)\n\t}\n\n\t// 检查底层物理卷性能等级是否满足要求\n\tif c.PerformanceRank != \"\" {\n\t\tif string(c.selectedPhysicalVolume.PerformanceRank) != c.PerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not match requested rank %s\", c.selectedPhysicalVolume.PerformanceRank, c.PerformanceRank)\n\t\t}\n\t} else {\n\t\tif c.selectedPhysicalVolume.PerformanceRank != rdiskDomain.DefaultPerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not default rank %s\", c.selectedPhysicalVolume.PerformanceRank, rdiskDomain.DefaultPerformanceRank)\n\t\t}\n\t}\n\n\t// 2. 创建逻辑卷\n\tvol := rdiskDomain.NewLogicalVolume(users.AppID(c.AppID), rdiskDomain.Size(c.DiskSize), rdiskDomain.ZoneID(c.ZoneID))\n\tif c.VolumeType != \"\" {\n\t\tvol.VolumeType = rdiskDomain.VolumeType(c.VolumeType)\n\t}\n\tif c.DiskType != \"\" {\n\t\tvol.DiskType = rdiskDomain.DiskType(c.DiskType)\n\t}\n\terr = lvRepo.Add(ctx, vol)\n\tif err != nil {\n\t\treturn\n\t}\n\tc.createdLogicalVolume = vol\n\n\t// 3. 触发状态机，联动更新逻辑卷和物理卷状态\n\t_, err = sm.Fire(ctx, rdiskDomain.LVSUnInited, rdiskDomain.LVECreateLogicalVolume, c)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_running_backup_task.go",
        "code_start_line": 31,
        "code_end_line": 61,
        "code_key": "Handle",
        "code_value": "func (c *UpdateRunningBackupTaskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventUpdateBackupProgress,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_drgroup.go",
        "code_start_line": 78,
        "code_end_line": 173,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeDRGroupCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tlvView  = app.GetRegistry(ctx).Viewers.LogicalVolume\n\t\tdrgRepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t\tsm      = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\terr     error\n\t)\n\n\t// 0. 初始化\n\tc.drgroupRef = make(map[string]*drgroup.DRGroup)\n\n\t// 1. 加载所有逻辑卷所在的置放群组\n\tallVolumeUUIDs := make([]string, 0, len(c.UUIDs))\n\tfor _, _uuid := range c.UUIDs {\n\t\tallVolumeUUIDs = append(allVolumeUUIDs, _uuid.String())\n\t}\n\tif groups, err := drgRepo.FindByMembers(ctx, c.AppID, allVolumeUUIDs); err == nil {\n\t\tif err != nil {\n\t\t\tif !errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tfor _, group := range groups {\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t\tc.curDRGroupNames = append(c.curDRGroupNames, group.Name)\n\t\t}\n\t} else {\n\t\treturn err\n\t}\n\n\t// 2. 确认已上锁的置放群组和当前一致\n\tif !c.checkLockedDRGroupNames() {\n\t\treturn errors.New(drgroup.ErrGroupModified, \"drgroup changed\")\n\t}\n\n\t// 3. 加载所有逻辑卷的状态，不需要完整实体，因为不会修改 Volume\n\tc.relatedLogicalVolume, err = lvView.FindByIDs(ctx, c.AppID, c.UUIDs)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(c.relatedLogicalVolume) < len(c.UUIDs) {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t// 4. 加载所有目标置放群组，key 为 name\n\tfor _, spec := range c.Specs {\n\t\tvar group *drgroup.DRGroup\n\t\tif _, ok := c.drgroupRef[spec.Name]; ok {\n\t\t\tgroup = c.drgroupRef[spec.Name]\n\t\t} else {\n\t\t\tgroup, err = c.getOrCreateDRGroup(ctx, drgRepo, spec)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t}\n\n\t\tif spec.Affinity > 0 {\n\t\t\tgroup.Affinity = spec.Affinity\n\t\t}\n\t\tif spec.Type != \"\" {\n\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t}\n\t}\n\n\t// 5. 对所有逻辑卷执行置放群组变更事件，检查状态是否允许，\n\t//    实际的更新还是在这里执行。\n\tfor _, vol := range c.relatedLogicalVolume {\n\t\terr := sm.Check(ctx, vol.State, rdiskDomain.LVEUpdateDrGroup, c)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// 将逻辑卷从原有的置放群组中移除\n\t\tfor _, name := range c.curDRGroupNames {\n\t\t\tc.drgroupRef[name].RemoveMember(vol.UUID.String())\n\t\t}\n\t\t// 将逻辑卷添加到新的置放群组中\n\t\tfor _, spec := range c.Specs {\n\t\t\tsubGroup := spec.SubGroup\n\t\t\tif subGroup == \"\" {\n\t\t\t\t// 如果没有指定子组，则使用远端 SSD UUID 作为子组名称\n\t\t\t\t// 相当于每块盘都是一个子组，相当于没有使用子组功能\n\t\t\t\tsubGroup = vol.UUID.String()\n\t\t\t}\n\t\t\tif err := c.drgroupRef[spec.Name].AddMember(vol.UUID.String(), subGroup, vol.PhysicalVolume.IP.String()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tif c.DryRun {\n\t\treturn errors.New(errors.ErrDryRunSuccessExit, \"dry run check success\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/online_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OnlinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOnlinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_benchmark_task.go",
        "code_start_line": 34,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *UpdateBenchmarkTask) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, rdisk.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark, err = benchRepo.FindByUUID(ctx, c.BenchmarkUUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventUpdateBench, benchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_flow_ctrl.go",
        "code_start_line": 80,
        "code_end_line": 103,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeFlowControlCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not found\")\n\t}\n\n\tspec := c.volume.FlowControlSpec\n\tif !c.UpdateRequest.UpdateSpec(&spec, c.volume.GetDefaultFlowControlSpec()) {\n\t\t// 没有任何更新，直接返回成功\n\t\treturn nil\n\t}\n\tc.volume.SetFlowControlSpec(spec)\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEUpdateFlowControl, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_defunct_volume.go",
        "code_start_line": 46,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *CleanupDefunctCommand) Handle(ctx context.Context) error {\n\tvar err error\n\tc.lv, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar sm = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\tvar event = rdiskDomain.LVECleanupDefunct\n\n\tfor _, attachment := range c.lv.Attachments {\n\t\tlogs.Info(ctx).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).Msg(\"cleanup defuncting volume\")\n\t\tsubCmd := &cleanDefunctSubCommand{Parent: c, HostIP: attachment.IP}\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, subCmd)\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，因为只要有一个挂载点清理失败，其他挂载点还是需要继续清理的\n\t\t\t// 失败的挂载点会在后台继续清理\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).\n\t\t\t\tMsg(\"failed to cleanup defunct volume, retry later.\")\n\t\t}\n\t}\n\n\tif len(c.lv.Attachments) == 0 {\n\t\t// 没有挂载点，直接清理\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, &cleanDefunctSubCommand{Parent: c, HostIP: net.IP{}})\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，后续自动重试即可\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Msg(\"failed to complete cleanup defunct volume\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_drgroup_exists.go",
        "code_start_line": 28,
        "code_end_line": 53,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDRGroupExistsCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t)\n\tfor _, spec := range c.DRGroup {\n\t\t_, err := repo.FindByName(ctx, users.AppID(c.AppID), spec.Name)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\tgroup := drgroup.New(spec.Name, users.AppID(c.AppID))\n\t\t\t\tif spec.Affinity > 0 {\n\t\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t\t}\n\t\t\t\tif spec.Type != \"\" {\n\t\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t\t}\n\t\t\t\terr = repo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_physical_volume.go",
        "code_start_line": 31,
        "code_end_line": 54,
        "code_key": "Handle",
        "code_value": "func (c *UpdatePhyRDiskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEUpdatePhysicalVolume, c)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/recycle_backup_data.go",
        "code_start_line": 32,
        "code_end_line": 62,
        "code_key": "Handle",
        "code_value": "func (c *RecycleBackupDataCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventDeleteBackup,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/defunct.go",
        "code_start_line": 40,
        "code_end_line": 74,
        "code_key": "FireCancelBackupEventForDefunct",
        "code_value": "func FireCancelBackupEventForDefunct(ctx context.Context, source rdiskDomain.LogicalVolumeState, target rdiskDomain.LogicalVolumeState, stateCtx app.LogicalVolumeContext) (rdiskDomain.LogicalVolumeState, error) {\n\tvar (\n\t\terr          error\n\t\tstateMachine = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo         = app.GetRegistry(ctx).Repositories.Backup\n\t\tview         = app.GetRegistry(ctx).Viewers.Backup\n\t\tevent        = backup.EventForceSoftDeleteBackup\n\t)\n\n\tbackupViews, err := view.FindByDiskUUIDs(ctx, []string{stateCtx.GetLogicalVolume().UUID.String()})\n\tif err != nil {\n\t\treturn source, err\n\t}\n\trunningBackupUuid := lo.FilterMap(backupViews, func(backupView *backup.View, _ int) (string, bool) {\n\t\tif backupView.Status == backup.StatusRunning {\n\t\t\treturn backupView.UUID.String(), true\n\t\t}\n\t\treturn \"\", false\n\t})\n\n\tfor _, u := range runningBackupUuid {\n\t\tb, err := repo.FindByUUID(ctx, u)\n\t\tif err != nil {\n\t\t\tlogs.Warn(ctx).Str(\"uuid\", u).Msg(\"find backup by uuid failed\")\n\t\t\tcontinue\n\t\t}\n\t\t_, err = stateMachine.Fire(ctx, b.Status, event, backup.Data{Backup: b, Delegate: &backupDelegate{}})\n\t\tif err != nil {\n\t\t\tlogs.Warn(ctx).Err(err).Str(\"uuid\", u).Msg(\"fire cancel backup event failed\")\n\t\t\treturn source, err\n\t\t}\n\t}\n\n\treturn target, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 176,
        "code_end_line": 193,
        "code_key": "DmRdiskBenchmark",
        "code_value": "type DmRdiskBenchmark struct {\n\tID             uint64    `gorm:\"column:id;primaryKey\"`   // 主键 ID\n\tUUID           string    `gorm:\"column:uuid\"`            // 备份 UUID\n\tPhyID          string    `gorm:\"column:phy_id\"`          // 物理卷 Serial\n\tBDF            string    `gorm:\"column:host_bdf\"`        // 物理盘 BDF 号\n\tError          string    `gorm:\"column:error\"`           // 错误信息\n\tTaskID         int64     `gorm:\"column:task_id\"`         // BlockAgent 任务 ID\n\tHostIP         string    `gorm:\"column:host_ip\"`         // 主机 IP\n\tStatus         int       `gorm:\"column:status\"`          // 备份状态\n\tReadBandwidth  float64   `gorm:\"column:read_bandwidth\"`  // 最大读带宽 in MBps\n\tWriteBandwidth float64   `gorm:\"column:write_bandwidth\"` // 最大写带宽 in MBps\n\tReadLatency    float64   `gorm:\"column:read_latency\"`    // 最大读延迟 in micro second\n\tWriteLatency   float64   `gorm:\"column:write_latency\"`   // 最大写延迟 in micro second\n\tCreated        time.Time `gorm:\"column:created\"`         // 压测创建时间\n\tFinished       time.Time `gorm:\"column:finished\"`        // 压测结束时间\n\tUpdated        time.Time `gorm:\"column:updated\"`         // 数据更新时间\n\tExtra          string    `gorm:\"column:extra\"`           // 额外信息\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 195,
        "code_end_line": 197,
        "code_key": "TableName",
        "code_value": "func (DmRdiskBenchmark) TableName() string {\n\treturn \"dm_phydisk_benchmark\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/backup.go:44:53:FindByUUID": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/backup.go",
    "code_start_line": 44,
    "code_end_line": 53,
    "code_start_column": 40,
    "code_key": "FindByUUID",
    "code_value": "func (impl *rdiskBackupRepositoryImpl) FindByUUID(ctx context.Context, uuid string) (*backupPkg.Backup, error) {\n\tuow := getUow(ctx)\n\n\tb := &metadb.DmRdiskBackup{}\n\tresult := uow.tx.First(b, \"uuid = ?\", uuid)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\treturn uow.trackedBackups.Add(impl.fromDOToModel(b)), nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go",
        "code_start_line": 51,
        "code_end_line": 72,
        "code_key": "Handle",
        "code_value": "func (c *CbsAppIdConsumer) Handle(ctx context.Context, delivery *rabbitmq.Delivery) error {\n\tu, chargeTime, err := c.ParseDelivery(ctx, delivery)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif u == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"USER_INFO_NOT_FOUND\")\n\t\treturn nil\n\t}\n\n\tchargeDetail := c.GetChargeDetailForSingleUser(u, chargeTime)\n\tif chargeDetail == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tUint64(\"appId\", uint64(u.AppId)).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"NO_RESOURCE_TO_CHARGE\")\n\t\treturn nil\n\t}\n\treturn c.ProcessChargeDetail(chargeDetail)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 105,
        "code_end_line": 116,
        "code_key": "Handle",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tif err := c.ensureLocks(ctx); err != nil {\n\t\treturn err\n\t}\n\tif c.lvUUID != nil {\n\t\t// 涉及到逻辑卷时，需要先标记逻辑卷为故障\n\t\treturn c.handleBindedVolume(ctx)\n\t} else {\n\t\t// 不涉及到逻辑卷时，直接标记物理卷为故障\n\t\treturn c.handleIdleVolume(ctx)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/detach_logical_volume.go",
        "code_start_line": 56,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *DetachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDetachLogicalVolume, c)\n\n\t// 如果没有挂载到指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume not attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_benchmark_task.go",
        "code_start_line": 125,
        "code_end_line": 165,
        "code_key": "Handle",
        "code_value": "func (c *CreateBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tvolSm     = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = volSm.Fire(ctx, c.relatedVolume.State, domain.PVEStartBenchmark, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark = benchmark.New(benchmark.DiskInfo{\n\t\tSerial: string(c.relatedVolume.Serial),\n\t\tHostIP: c.relatedVolume.IP,\n\t\tBDF:    string(c.relatedVolume.BDF),\n\t})\n\n\tif err = benchRepo.Add(ctx, c.relatedBenchmark); err != nil {\n\t\tdelegate := &benchmarkDelegate{cmd: c}\n\t\tif _err := delegate.TaskFinishCallback(ctx, c.relatedBenchmark); _err != nil {\n\t\t\tlogs.Warn(ctx).Err(_err).Str(\"serial\", string(c.relatedVolume.Serial)).Msg(\"failed to rollback: create bdev\")\n\t\t}\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventCreateBench,\n\t\tbenchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_logical_volume.go",
        "code_start_line": 71,
        "code_end_line": 108,
        "code_key": "Handle",
        "code_value": "func (d *DeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\td.volume, err = repo.FindByID(ctx, d.UUID)\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif e := d.volume.CheckDelete(); e != nil {\n\t\treturn e\n\t}\n\n\tif d.volume.AppID != d.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"refuse to delet: app id mismatch\")\n\t}\n\n\td.drgroup, err = app.GetRegistry(ctx).Repositories.DRGroup.FindByMember(ctx, d.AppID, d.volume.UUID.String())\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\td.drgroup = nil\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := d.checkDRGroupMatch(ctx); err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, d.volume.State, rdiskDomain.LVEMarkToRecycle, d)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_recycled_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmRecycledPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEConfirmRecycled, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_rdisk_backup.go",
        "code_start_line": 52,
        "code_end_line": 75,
        "code_key": "Handle",
        "code_value": "func (c *DeleteRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tsm   = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\tc.relatedBackup, err = repo.FindByUUID(ctx, c.BackupID.String())\n\tif err != nil || c.relatedBackup == nil || c.relatedBackup.AppID != c.AppID {\n\t\treturn errors.New(backupDomain.ErrBackupNotExist, \"backup not exists\")\n\t}\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tc.relatedBackup.Status,\n\t\tbackupDomain.EventSoftDeleteBackup,\n\t\tbackupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: c.relatedBackup})\n\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_rdisk_backup.go",
        "code_start_line": 47,
        "code_end_line": 80,
        "code_key": "Handle",
        "code_value": "func (c *CreateRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tlvSm  = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\tbakSm = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo  = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t_, err = lvSm.Fire(ctx, c.relatedVolume.State, rdiskDomain.LVEBackupStarted, c)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tlv := c.relatedVolume\n\tbackup := backupDomain.New(\n\t\tlv.AppID,\n\t\tbackupDomain.DiskInfo{\n\t\t\tVolumeUUID: lv.UUID,\n\t\t\tVolumeSize: uint64(lv.Size),\n\t\t\tHostIP:     lv.PhysicalVolume.IP,\n\t\t\tHostBDF:    string(lv.PhysicalVolume.BDF),\n\t\t\tSerial:     string(lv.PhysicalVolume.Serial),\n\t\t},\n\t)\n\tif err := repo.Add(ctx, backup); err != nil {\n\t\treturn err\n\t}\n\tc.relatedBackup = backup\n\t_, err = bakSm.Fire(ctx, backupDomain.StatusInit, backupDomain.EventStartBackup, backupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: backup})\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/attach_logical_volume.go",
        "code_start_line": 49,
        "code_end_line": 71,
        "code_key": "Handle",
        "code_value": "func (c *AttachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEAttachLogicalVolume, c)\n\n\t// 如果已经挂载到了指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeAlreadyAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume already attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_delete_logical_volume.go",
        "code_start_line": 34,
        "code_end_line": 55,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\t// 如果逻辑卷不存在，则直接返回成功\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"failed to confirm delete: app id mismatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDeleteLogicalVolume, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/offline_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OfflinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOfflinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *DeletePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\t// 如果物理卷不存在，则直接幂等返回\n\t\treturn nil\n\t}\n\n\tvar event = domain.PVEDeletePhysicalVolume\n\tif c.Force && (c.relatedVolume.State == domain.PVSDefunct) {\n\t\t// 这里的实现不太好，状态机的逻辑不应该侵入 cmd\n\t\t// 时间太赶了，后续重构优化吧\n\t\tevent = domain.PVEForceDeleteForDefunct\n\t}\n\n\tif c.relatedVolume.HasBindedPV() {\n\t\treturn errors.New(domain.ErrVolumeBusy, \"logic volume has binded to this physical volume\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, event, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_logical_volume.go",
        "code_start_line": 55,
        "code_end_line": 70,
        "code_key": "Handle",
        "code_value": "func (c *CleanupLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVECleanupLogicalVolume, c)\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_init_physical_volume.go",
        "code_start_line": 26,
        "code_end_line": 52,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmInitPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\tif c.relatedVolume.IP.String() != c.Host.String() {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume host ip mistmatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVECreatePhysicalVolumeOnHost, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_physical_volume.go",
        "code_start_line": 51,
        "code_end_line": 101,
        "code_key": "Handle",
        "code_value": "func (c *CreatePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\n\t// 获取物理卷状态机\n\tsm := app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\trepo := app.GetRegistry(ctx).Repositories.PhysicalVolume\n\n\t// 检查物理卷是否已经存在，如果存在则直接幂等返回\n\tvol1, err := repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"serial\", c.Serial).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tvol2, err := repo.FindByIPAndBDF(ctx, c.Host, domain.BDF(c.BDF))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"host\", c.Host.String()).Str(\"bdf\", c.BDF).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tfor _, vol := range []*domain.PhysicalVolume{vol1, vol2} {\n\t\texisted, err := c.checkExisting(ctx, vol)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif existed {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// 触发事件，创建物理卷\n\t_, err = sm.Fire(ctx,\n\t\tdomain.PVSUnInited,\n\t\tdomain.PVECreatePhysicalVolume,\n\t\tc,\n\t)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 创建 Bdev 以及格式化移动到创建物理卷的状态机中\n\n\t// _, err = sm.Fire(ctx,\n\t// \tc.GetPhysicalVolume().State,\n\t// \tdomain.PVECreatePhysicalVolumeOnHost,\n\t// \tc,\n\t// )\n\t// if err != nil {\n\t// \treturn err\n\t// }\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_benchmark_task.go",
        "code_start_line": 32,
        "code_end_line": 57,
        "code_key": "Handle",
        "code_value": "func (c *DeleteBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\terr       error\n\t)\n\n\tbench, err := benchRepo.FindByUUID(ctx, c.BenchmarkUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif bench.DiskInfo.Serial != c.Serial {\n\t\treturn errors.Newf(benchmark.ErrTaskNotFound, \"benchmark serial not match %s, want %s\", c.Serial, bench.DiskInfo.Serial)\n\t}\n\n\t_, err = benchSm.Fire(ctx, bench.Status, benchmark.EventDeleteBench, benchmark.Data{Benchmark: bench, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := benchRepo.Delete(ctx, bench); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_logical_volume.go",
        "code_start_line": 52,
        "code_end_line": 98,
        "code_key": "Handle",
        "code_value": "func (c *CreateLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tpvRepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tlvRepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm     = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\t// 1. 查找底层物理卷\n\tc.selectedPhysicalVolume, err = pvRepo.FindBySerial(ctx, rdiskDomain.Serial(c.PhysicalVolumeSerial))\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// 检查底层物理卷大小是否满足要求\n\tif c.selectedPhysicalVolume.Size < rdiskDomain.Size(c.DiskSize) {\n\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume size %d is smaller than requested size %d\", c.selectedPhysicalVolume.Size, c.DiskSize)\n\t}\n\n\t// 检查底层物理卷性能等级是否满足要求\n\tif c.PerformanceRank != \"\" {\n\t\tif string(c.selectedPhysicalVolume.PerformanceRank) != c.PerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not match requested rank %s\", c.selectedPhysicalVolume.PerformanceRank, c.PerformanceRank)\n\t\t}\n\t} else {\n\t\tif c.selectedPhysicalVolume.PerformanceRank != rdiskDomain.DefaultPerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not default rank %s\", c.selectedPhysicalVolume.PerformanceRank, rdiskDomain.DefaultPerformanceRank)\n\t\t}\n\t}\n\n\t// 2. 创建逻辑卷\n\tvol := rdiskDomain.NewLogicalVolume(users.AppID(c.AppID), rdiskDomain.Size(c.DiskSize), rdiskDomain.ZoneID(c.ZoneID))\n\tif c.VolumeType != \"\" {\n\t\tvol.VolumeType = rdiskDomain.VolumeType(c.VolumeType)\n\t}\n\tif c.DiskType != \"\" {\n\t\tvol.DiskType = rdiskDomain.DiskType(c.DiskType)\n\t}\n\terr = lvRepo.Add(ctx, vol)\n\tif err != nil {\n\t\treturn\n\t}\n\tc.createdLogicalVolume = vol\n\n\t// 3. 触发状态机，联动更新逻辑卷和物理卷状态\n\t_, err = sm.Fire(ctx, rdiskDomain.LVSUnInited, rdiskDomain.LVECreateLogicalVolume, c)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_running_backup_task.go",
        "code_start_line": 31,
        "code_end_line": 61,
        "code_key": "Handle",
        "code_value": "func (c *UpdateRunningBackupTaskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventUpdateBackupProgress,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_drgroup.go",
        "code_start_line": 78,
        "code_end_line": 173,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeDRGroupCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tlvView  = app.GetRegistry(ctx).Viewers.LogicalVolume\n\t\tdrgRepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t\tsm      = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\terr     error\n\t)\n\n\t// 0. 初始化\n\tc.drgroupRef = make(map[string]*drgroup.DRGroup)\n\n\t// 1. 加载所有逻辑卷所在的置放群组\n\tallVolumeUUIDs := make([]string, 0, len(c.UUIDs))\n\tfor _, _uuid := range c.UUIDs {\n\t\tallVolumeUUIDs = append(allVolumeUUIDs, _uuid.String())\n\t}\n\tif groups, err := drgRepo.FindByMembers(ctx, c.AppID, allVolumeUUIDs); err == nil {\n\t\tif err != nil {\n\t\t\tif !errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tfor _, group := range groups {\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t\tc.curDRGroupNames = append(c.curDRGroupNames, group.Name)\n\t\t}\n\t} else {\n\t\treturn err\n\t}\n\n\t// 2. 确认已上锁的置放群组和当前一致\n\tif !c.checkLockedDRGroupNames() {\n\t\treturn errors.New(drgroup.ErrGroupModified, \"drgroup changed\")\n\t}\n\n\t// 3. 加载所有逻辑卷的状态，不需要完整实体，因为不会修改 Volume\n\tc.relatedLogicalVolume, err = lvView.FindByIDs(ctx, c.AppID, c.UUIDs)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(c.relatedLogicalVolume) < len(c.UUIDs) {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t// 4. 加载所有目标置放群组，key 为 name\n\tfor _, spec := range c.Specs {\n\t\tvar group *drgroup.DRGroup\n\t\tif _, ok := c.drgroupRef[spec.Name]; ok {\n\t\t\tgroup = c.drgroupRef[spec.Name]\n\t\t} else {\n\t\t\tgroup, err = c.getOrCreateDRGroup(ctx, drgRepo, spec)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t}\n\n\t\tif spec.Affinity > 0 {\n\t\t\tgroup.Affinity = spec.Affinity\n\t\t}\n\t\tif spec.Type != \"\" {\n\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t}\n\t}\n\n\t// 5. 对所有逻辑卷执行置放群组变更事件，检查状态是否允许，\n\t//    实际的更新还是在这里执行。\n\tfor _, vol := range c.relatedLogicalVolume {\n\t\terr := sm.Check(ctx, vol.State, rdiskDomain.LVEUpdateDrGroup, c)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// 将逻辑卷从原有的置放群组中移除\n\t\tfor _, name := range c.curDRGroupNames {\n\t\t\tc.drgroupRef[name].RemoveMember(vol.UUID.String())\n\t\t}\n\t\t// 将逻辑卷添加到新的置放群组中\n\t\tfor _, spec := range c.Specs {\n\t\t\tsubGroup := spec.SubGroup\n\t\t\tif subGroup == \"\" {\n\t\t\t\t// 如果没有指定子组，则使用远端 SSD UUID 作为子组名称\n\t\t\t\t// 相当于每块盘都是一个子组，相当于没有使用子组功能\n\t\t\t\tsubGroup = vol.UUID.String()\n\t\t\t}\n\t\t\tif err := c.drgroupRef[spec.Name].AddMember(vol.UUID.String(), subGroup, vol.PhysicalVolume.IP.String()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tif c.DryRun {\n\t\treturn errors.New(errors.ErrDryRunSuccessExit, \"dry run check success\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/online_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OnlinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOnlinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_benchmark_task.go",
        "code_start_line": 34,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *UpdateBenchmarkTask) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, rdisk.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark, err = benchRepo.FindByUUID(ctx, c.BenchmarkUUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventUpdateBench, benchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_flow_ctrl.go",
        "code_start_line": 80,
        "code_end_line": 103,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeFlowControlCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not found\")\n\t}\n\n\tspec := c.volume.FlowControlSpec\n\tif !c.UpdateRequest.UpdateSpec(&spec, c.volume.GetDefaultFlowControlSpec()) {\n\t\t// 没有任何更新，直接返回成功\n\t\treturn nil\n\t}\n\tc.volume.SetFlowControlSpec(spec)\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEUpdateFlowControl, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_defunct_volume.go",
        "code_start_line": 46,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *CleanupDefunctCommand) Handle(ctx context.Context) error {\n\tvar err error\n\tc.lv, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar sm = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\tvar event = rdiskDomain.LVECleanupDefunct\n\n\tfor _, attachment := range c.lv.Attachments {\n\t\tlogs.Info(ctx).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).Msg(\"cleanup defuncting volume\")\n\t\tsubCmd := &cleanDefunctSubCommand{Parent: c, HostIP: attachment.IP}\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, subCmd)\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，因为只要有一个挂载点清理失败，其他挂载点还是需要继续清理的\n\t\t\t// 失败的挂载点会在后台继续清理\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).\n\t\t\t\tMsg(\"failed to cleanup defunct volume, retry later.\")\n\t\t}\n\t}\n\n\tif len(c.lv.Attachments) == 0 {\n\t\t// 没有挂载点，直接清理\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, &cleanDefunctSubCommand{Parent: c, HostIP: net.IP{}})\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，后续自动重试即可\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Msg(\"failed to complete cleanup defunct volume\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_drgroup_exists.go",
        "code_start_line": 28,
        "code_end_line": 53,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDRGroupExistsCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t)\n\tfor _, spec := range c.DRGroup {\n\t\t_, err := repo.FindByName(ctx, users.AppID(c.AppID), spec.Name)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\tgroup := drgroup.New(spec.Name, users.AppID(c.AppID))\n\t\t\t\tif spec.Affinity > 0 {\n\t\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t\t}\n\t\t\t\tif spec.Type != \"\" {\n\t\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t\t}\n\t\t\t\terr = repo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_physical_volume.go",
        "code_start_line": 31,
        "code_end_line": 54,
        "code_key": "Handle",
        "code_value": "func (c *UpdatePhyRDiskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEUpdatePhysicalVolume, c)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/recycle_backup_data.go",
        "code_start_line": 32,
        "code_end_line": 62,
        "code_key": "Handle",
        "code_value": "func (c *RecycleBackupDataCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventDeleteBackup,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/defunct.go",
        "code_start_line": 40,
        "code_end_line": 74,
        "code_key": "FireCancelBackupEventForDefunct",
        "code_value": "func FireCancelBackupEventForDefunct(ctx context.Context, source rdiskDomain.LogicalVolumeState, target rdiskDomain.LogicalVolumeState, stateCtx app.LogicalVolumeContext) (rdiskDomain.LogicalVolumeState, error) {\n\tvar (\n\t\terr          error\n\t\tstateMachine = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo         = app.GetRegistry(ctx).Repositories.Backup\n\t\tview         = app.GetRegistry(ctx).Viewers.Backup\n\t\tevent        = backup.EventForceSoftDeleteBackup\n\t)\n\n\tbackupViews, err := view.FindByDiskUUIDs(ctx, []string{stateCtx.GetLogicalVolume().UUID.String()})\n\tif err != nil {\n\t\treturn source, err\n\t}\n\trunningBackupUuid := lo.FilterMap(backupViews, func(backupView *backup.View, _ int) (string, bool) {\n\t\tif backupView.Status == backup.StatusRunning {\n\t\t\treturn backupView.UUID.String(), true\n\t\t}\n\t\treturn \"\", false\n\t})\n\n\tfor _, u := range runningBackupUuid {\n\t\tb, err := repo.FindByUUID(ctx, u)\n\t\tif err != nil {\n\t\t\tlogs.Warn(ctx).Str(\"uuid\", u).Msg(\"find backup by uuid failed\")\n\t\t\tcontinue\n\t\t}\n\t\t_, err = stateMachine.Fire(ctx, b.Status, event, backup.Data{Backup: b, Delegate: &backupDelegate{}})\n\t\tif err != nil {\n\t\t\tlogs.Warn(ctx).Err(err).Str(\"uuid\", u).Msg(\"fire cancel backup event failed\")\n\t\t\treturn source, err\n\t\t}\n\t}\n\n\treturn target, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 151,
        "code_end_line": 169,
        "code_key": "DmRdiskBackup",
        "code_value": "type DmRdiskBackup struct {\n\tID        uint64    `gorm:\"column:id;primaryKey\"` // 主键 ID\n\tAppID     int64     `gorm:\"column:app_id;\"`       // AppID\n\tUUID      string    `gorm:\"column:uuid;\"`         // 备份 UUID\n\tDiskUUID  string    `gorm:\"column:rdisk_uuid\"`    // RDisk UUID\n\tStatus    int       `gorm:\"column:status\"`        // 备份状态\n\tSize      uint64    `gorm:\"column:size\"`          // 远端 SSD 大小 in GiB\n\tPhyID     string    `gorm:\"column:phy_id\"`        // 物理卷 Serial\n\tHostIP    string    `gorm:\"column:host_ip\"`       // 主机 IP\n\tHostBDF   string    `gorm:\"column:host_bdf\"`      // 主机上物理盘 BDF 号\n\tCosAppId  int64     `gorm:\"column:cos_appid\"`     // COS AppId\n\tCosRegion string    `gorm:\"column:cos_region\"`    // COS 所在的地域，例如 gz\n\tCosBucket string    `gorm:\"column:cos_bucket\"`    // COS Bucket\n\tCosPath   string    `gorm:\"column:cos_path\"`      // COS Path\n\tPercent   int       `gorm:\"column:percent\"`       // 备份进度\n\tExtra     string    `gorm:\"column:extra\"`         // 额外信息\n\tCreated   time.Time `gorm:\"column:created\"`       // 备份创建时间\n\tUpdated   time.Time `gorm:\"column:updated\"`       // 备份更新时间\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 171,
        "code_end_line": 173,
        "code_key": "TableName",
        "code_value": "func (DmRdiskBackup) TableName() string {\n\treturn \"dm_rdisk_backup\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/benchmark.go:100:137:updateBenchmark": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/benchmark.go",
    "code_start_line": 100,
    "code_end_line": 137,
    "code_start_column": 6,
    "code_key": "updateBenchmark",
    "code_value": "func updateBenchmark(ctx context.Context, item, originalState *benchmark.Benchmark) error {\n\tuow := getUow(ctx)\n\timpl := rdiskBenchmarkRepositoryImpl{}\n\tcurDO := impl.fromModelToDO(item)\n\toriDO := impl.fromModelToDO(originalState)\n\tchanges := make(map[string]interface{})\n\tcheckChange := func(field string, cur interface{}, original interface{}) {\n\t\tif cur != original {\n\t\t\tchanges[field] = cur\n\t\t}\n\t}\n\n\tcheckChange(\"uuid\", curDO.UUID, oriDO.UUID)\n\tcheckChange(\"phy_id\", curDO.PhyID, oriDO.PhyID)\n\tcheckChange(\"host_bdf\", curDO.BDF, oriDO.BDF)\n\tcheckChange(\"host_ip\", curDO.HostIP, oriDO.HostIP)\n\tcheckChange(\"error\", curDO.Error, oriDO.Error)\n\tcheckChange(\"status\", curDO.Status, oriDO.Status)\n\tcheckChange(\"task_id\", curDO.TaskID, oriDO.TaskID)\n\tcheckChange(\"read_bandwidth\", curDO.ReadBandwidth, oriDO.ReadBandwidth)\n\tcheckChange(\"write_bandwidth\", curDO.WriteBandwidth, oriDO.WriteBandwidth)\n\tcheckChange(\"read_latency\", curDO.ReadLatency, oriDO.ReadLatency)\n\tcheckChange(\"write_latency\", curDO.WriteLatency, oriDO.WriteLatency)\n\tcheckChange(\"created\", curDO.Created, oriDO.Created)\n\tcheckChange(\"finished\", curDO.Finished, oriDO.Finished)\n\n\tif len(changes) == 0 {\n\t\treturn nil\n\t}\n\n\tchanges[\"updated\"] = uow.tx.NowFunc()\n\tresult := uow.tx.Model(curDO).Where(\"id = ?\", curDO.ID).Updates(changes)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\n\treturn nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/benchmark.go",
        "code_start_line": 12,
        "code_end_line": 12,
        "code_key": "rdiskBenchmarkRepositoryImpl",
        "code_value": "type rdiskBenchmarkRepositoryImpl struct{}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/model.go",
        "code_start_line": 10,
        "code_end_line": 12,
        "code_key": "Model",
        "code_value": "type Model struct {\n\tId ID `json:\"id\" gorm:\"primaryKey;autoIncrement;comment:主键\"`\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/backup.go:97:135:updateBackup": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/backup.go",
    "code_start_line": 97,
    "code_end_line": 135,
    "code_start_column": 6,
    "code_key": "updateBackup",
    "code_value": "func updateBackup(ctx context.Context, backup, originalState *backupPkg.Backup) error {\n\tuow := getUow(ctx)\n\timpl := rdiskBackupRepositoryImpl{}\n\tcurDO := impl.fromModelToDO(backup)\n\toriginDO := impl.fromModelToDO(originalState)\n\tchanges := make(map[string]interface{})\n\tcheckChange := func(field string, cur interface{}, original interface{}) {\n\t\tif cur != original {\n\t\t\tchanges[field] = cur\n\t\t}\n\t}\n\n\tcheckChange(\"app_id\", curDO.AppID, originDO.AppID)\n\tcheckChange(\"status\", curDO.Status, originDO.Status)\n\tcheckChange(\"size\", curDO.Size, originDO.Size)\n\tcheckChange(\"uuid\", curDO.UUID, originDO.UUID)\n\tcheckChange(\"rdisk_uuid\", curDO.DiskUUID, originDO.DiskUUID)\n\tcheckChange(\"phy_id\", curDO.PhyID, originDO.PhyID)\n\tcheckChange(\"host_ip\", curDO.HostIP, originDO.HostIP)\n\tcheckChange(\"host_bdf\", curDO.HostBDF, originDO.HostBDF)\n\tcheckChange(\"cos_appid\", curDO.CosAppId, originDO.CosAppId)\n\tcheckChange(\"cos_region\", curDO.CosRegion, originDO.CosRegion)\n\tcheckChange(\"cos_bucket\", curDO.CosBucket, originDO.CosBucket)\n\tcheckChange(\"cos_path\", curDO.CosPath, originDO.CosPath)\n\tcheckChange(\"percent\", curDO.Percent, originDO.Percent)\n\tcheckChange(\"extra\", curDO.Extra, originDO.Extra)\n\n\tif len(changes) == 0 {\n\t\treturn nil\n\t}\n\n\tchanges[\"updated\"] = uow.tx.NowFunc()\n\tresult := uow.tx.Model(curDO).Where(\"id = ?\", curDO.ID).Updates(changes)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\n\treturn nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/backup.go",
        "code_start_line": 13,
        "code_end_line": 14,
        "code_key": "rdiskBackupRepositoryImpl",
        "code_value": "type rdiskBackupRepositoryImpl struct {\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 67,
        "code_end_line": 83,
        "code_key": "PhysicalVolume",
        "code_value": "type PhysicalVolume struct {\n\tEntityMixin\n\tSerial          Serial              // 物理卷序列号\n\tIP              net.IP              // 物理卷所在主机 IP\n\tBDF             BDF                 // 物理卷所在主机的 BDF\n\tDiskID          uint64              // 物理卷在主机上的 BDev ID\n\tState           PhysicalVolumeState // 物理卷状态\n\tSize            Size                // 物理卷对外售卖大小 GiB\n\tVolumeType      VolumeType          // 物理卷类型\n\tZoneID          ZoneID              // 物理卷所在的 Zone\n\tBlockSize       uint                // 物理卷块大小，通常为 512\n\tRealSize        uint64              // 物理卷实际大小，单位为 Byte\n\tPort            uint                // 物理卷所在主机的端口\n\tDataNodeType    DataNodeType        // 数据节点类型\n\tCuf             Cuf                 // 存储节点 CUF 信息\n\tPerformanceRank PerformanceRank     // 物理卷性能等级\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/model.go",
        "code_start_line": 10,
        "code_end_line": 12,
        "code_key": "Model",
        "code_value": "type Model struct {\n\tId ID `json:\"id\" gorm:\"primaryKey;autoIncrement;comment:主键\"`\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go:22:47:FindByAppIDAndUUID": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go",
    "code_start_line": 22,
    "code_end_line": 47,
    "code_start_column": 36,
    "code_key": "FindByAppIDAndUUID",
    "code_value": "func (logicalVolumeRepositoryImpl) FindByAppIDAndUUID(ctx context.Context, appID users.AppID, id uuid.UUID) (*rdiskDomain.LogicalVolume, error) {\n\tuow := getUow(ctx)\n\tvol := metadb.DmRdisk{}\n\tresult := uow.tx.\n\t\tPreload(\"Attachments\").\n\t\tPreload(\"DmPhyDisk\").\n\t\tFirst(&vol, \"uuid = ? AND app_id = ?\", id.String(), appID)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tlv, err := fromDmRDiskToModel(ctx, &vol)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlv = uow.trackedLogicalVolumes.Add(lv)\n\tif lv.PhysicalVolume != nil {\n\t\tlv.PhysicalVolume = uow.trackedPhyVolumes.Add(lv.PhysicalVolume)\n\t}\n\treturn lv, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go",
        "code_start_line": 51,
        "code_end_line": 72,
        "code_key": "Handle",
        "code_value": "func (c *CbsAppIdConsumer) Handle(ctx context.Context, delivery *rabbitmq.Delivery) error {\n\tu, chargeTime, err := c.ParseDelivery(ctx, delivery)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif u == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"USER_INFO_NOT_FOUND\")\n\t\treturn nil\n\t}\n\n\tchargeDetail := c.GetChargeDetailForSingleUser(u, chargeTime)\n\tif chargeDetail == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tUint64(\"appId\", uint64(u.AppId)).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"NO_RESOURCE_TO_CHARGE\")\n\t\treturn nil\n\t}\n\treturn c.ProcessChargeDetail(chargeDetail)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 105,
        "code_end_line": 116,
        "code_key": "Handle",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tif err := c.ensureLocks(ctx); err != nil {\n\t\treturn err\n\t}\n\tif c.lvUUID != nil {\n\t\t// 涉及到逻辑卷时，需要先标记逻辑卷为故障\n\t\treturn c.handleBindedVolume(ctx)\n\t} else {\n\t\t// 不涉及到逻辑卷时，直接标记物理卷为故障\n\t\treturn c.handleIdleVolume(ctx)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/detach_logical_volume.go",
        "code_start_line": 56,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *DetachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDetachLogicalVolume, c)\n\n\t// 如果没有挂载到指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume not attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_benchmark_task.go",
        "code_start_line": 125,
        "code_end_line": 165,
        "code_key": "Handle",
        "code_value": "func (c *CreateBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tvolSm     = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = volSm.Fire(ctx, c.relatedVolume.State, domain.PVEStartBenchmark, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark = benchmark.New(benchmark.DiskInfo{\n\t\tSerial: string(c.relatedVolume.Serial),\n\t\tHostIP: c.relatedVolume.IP,\n\t\tBDF:    string(c.relatedVolume.BDF),\n\t})\n\n\tif err = benchRepo.Add(ctx, c.relatedBenchmark); err != nil {\n\t\tdelegate := &benchmarkDelegate{cmd: c}\n\t\tif _err := delegate.TaskFinishCallback(ctx, c.relatedBenchmark); _err != nil {\n\t\t\tlogs.Warn(ctx).Err(_err).Str(\"serial\", string(c.relatedVolume.Serial)).Msg(\"failed to rollback: create bdev\")\n\t\t}\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventCreateBench,\n\t\tbenchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_logical_volume.go",
        "code_start_line": 71,
        "code_end_line": 108,
        "code_key": "Handle",
        "code_value": "func (d *DeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\td.volume, err = repo.FindByID(ctx, d.UUID)\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif e := d.volume.CheckDelete(); e != nil {\n\t\treturn e\n\t}\n\n\tif d.volume.AppID != d.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"refuse to delet: app id mismatch\")\n\t}\n\n\td.drgroup, err = app.GetRegistry(ctx).Repositories.DRGroup.FindByMember(ctx, d.AppID, d.volume.UUID.String())\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\td.drgroup = nil\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := d.checkDRGroupMatch(ctx); err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, d.volume.State, rdiskDomain.LVEMarkToRecycle, d)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_recycled_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmRecycledPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEConfirmRecycled, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_rdisk_backup.go",
        "code_start_line": 52,
        "code_end_line": 75,
        "code_key": "Handle",
        "code_value": "func (c *DeleteRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tsm   = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\tc.relatedBackup, err = repo.FindByUUID(ctx, c.BackupID.String())\n\tif err != nil || c.relatedBackup == nil || c.relatedBackup.AppID != c.AppID {\n\t\treturn errors.New(backupDomain.ErrBackupNotExist, \"backup not exists\")\n\t}\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tc.relatedBackup.Status,\n\t\tbackupDomain.EventSoftDeleteBackup,\n\t\tbackupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: c.relatedBackup})\n\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_rdisk_backup.go",
        "code_start_line": 47,
        "code_end_line": 80,
        "code_key": "Handle",
        "code_value": "func (c *CreateRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tlvSm  = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\tbakSm = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo  = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t_, err = lvSm.Fire(ctx, c.relatedVolume.State, rdiskDomain.LVEBackupStarted, c)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tlv := c.relatedVolume\n\tbackup := backupDomain.New(\n\t\tlv.AppID,\n\t\tbackupDomain.DiskInfo{\n\t\t\tVolumeUUID: lv.UUID,\n\t\t\tVolumeSize: uint64(lv.Size),\n\t\t\tHostIP:     lv.PhysicalVolume.IP,\n\t\t\tHostBDF:    string(lv.PhysicalVolume.BDF),\n\t\t\tSerial:     string(lv.PhysicalVolume.Serial),\n\t\t},\n\t)\n\tif err := repo.Add(ctx, backup); err != nil {\n\t\treturn err\n\t}\n\tc.relatedBackup = backup\n\t_, err = bakSm.Fire(ctx, backupDomain.StatusInit, backupDomain.EventStartBackup, backupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: backup})\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/attach_logical_volume.go",
        "code_start_line": 49,
        "code_end_line": 71,
        "code_key": "Handle",
        "code_value": "func (c *AttachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEAttachLogicalVolume, c)\n\n\t// 如果已经挂载到了指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeAlreadyAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume already attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_delete_logical_volume.go",
        "code_start_line": 34,
        "code_end_line": 55,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\t// 如果逻辑卷不存在，则直接返回成功\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"failed to confirm delete: app id mismatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDeleteLogicalVolume, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/offline_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OfflinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOfflinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *DeletePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\t// 如果物理卷不存在，则直接幂等返回\n\t\treturn nil\n\t}\n\n\tvar event = domain.PVEDeletePhysicalVolume\n\tif c.Force && (c.relatedVolume.State == domain.PVSDefunct) {\n\t\t// 这里的实现不太好，状态机的逻辑不应该侵入 cmd\n\t\t// 时间太赶了，后续重构优化吧\n\t\tevent = domain.PVEForceDeleteForDefunct\n\t}\n\n\tif c.relatedVolume.HasBindedPV() {\n\t\treturn errors.New(domain.ErrVolumeBusy, \"logic volume has binded to this physical volume\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, event, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_logical_volume.go",
        "code_start_line": 55,
        "code_end_line": 70,
        "code_key": "Handle",
        "code_value": "func (c *CleanupLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVECleanupLogicalVolume, c)\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_init_physical_volume.go",
        "code_start_line": 26,
        "code_end_line": 52,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmInitPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\tif c.relatedVolume.IP.String() != c.Host.String() {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume host ip mistmatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVECreatePhysicalVolumeOnHost, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_physical_volume.go",
        "code_start_line": 51,
        "code_end_line": 101,
        "code_key": "Handle",
        "code_value": "func (c *CreatePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\n\t// 获取物理卷状态机\n\tsm := app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\trepo := app.GetRegistry(ctx).Repositories.PhysicalVolume\n\n\t// 检查物理卷是否已经存在，如果存在则直接幂等返回\n\tvol1, err := repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"serial\", c.Serial).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tvol2, err := repo.FindByIPAndBDF(ctx, c.Host, domain.BDF(c.BDF))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"host\", c.Host.String()).Str(\"bdf\", c.BDF).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tfor _, vol := range []*domain.PhysicalVolume{vol1, vol2} {\n\t\texisted, err := c.checkExisting(ctx, vol)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif existed {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// 触发事件，创建物理卷\n\t_, err = sm.Fire(ctx,\n\t\tdomain.PVSUnInited,\n\t\tdomain.PVECreatePhysicalVolume,\n\t\tc,\n\t)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 创建 Bdev 以及格式化移动到创建物理卷的状态机中\n\n\t// _, err = sm.Fire(ctx,\n\t// \tc.GetPhysicalVolume().State,\n\t// \tdomain.PVECreatePhysicalVolumeOnHost,\n\t// \tc,\n\t// )\n\t// if err != nil {\n\t// \treturn err\n\t// }\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_benchmark_task.go",
        "code_start_line": 32,
        "code_end_line": 57,
        "code_key": "Handle",
        "code_value": "func (c *DeleteBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\terr       error\n\t)\n\n\tbench, err := benchRepo.FindByUUID(ctx, c.BenchmarkUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif bench.DiskInfo.Serial != c.Serial {\n\t\treturn errors.Newf(benchmark.ErrTaskNotFound, \"benchmark serial not match %s, want %s\", c.Serial, bench.DiskInfo.Serial)\n\t}\n\n\t_, err = benchSm.Fire(ctx, bench.Status, benchmark.EventDeleteBench, benchmark.Data{Benchmark: bench, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := benchRepo.Delete(ctx, bench); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_logical_volume.go",
        "code_start_line": 52,
        "code_end_line": 98,
        "code_key": "Handle",
        "code_value": "func (c *CreateLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tpvRepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tlvRepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm     = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\t// 1. 查找底层物理卷\n\tc.selectedPhysicalVolume, err = pvRepo.FindBySerial(ctx, rdiskDomain.Serial(c.PhysicalVolumeSerial))\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// 检查底层物理卷大小是否满足要求\n\tif c.selectedPhysicalVolume.Size < rdiskDomain.Size(c.DiskSize) {\n\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume size %d is smaller than requested size %d\", c.selectedPhysicalVolume.Size, c.DiskSize)\n\t}\n\n\t// 检查底层物理卷性能等级是否满足要求\n\tif c.PerformanceRank != \"\" {\n\t\tif string(c.selectedPhysicalVolume.PerformanceRank) != c.PerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not match requested rank %s\", c.selectedPhysicalVolume.PerformanceRank, c.PerformanceRank)\n\t\t}\n\t} else {\n\t\tif c.selectedPhysicalVolume.PerformanceRank != rdiskDomain.DefaultPerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not default rank %s\", c.selectedPhysicalVolume.PerformanceRank, rdiskDomain.DefaultPerformanceRank)\n\t\t}\n\t}\n\n\t// 2. 创建逻辑卷\n\tvol := rdiskDomain.NewLogicalVolume(users.AppID(c.AppID), rdiskDomain.Size(c.DiskSize), rdiskDomain.ZoneID(c.ZoneID))\n\tif c.VolumeType != \"\" {\n\t\tvol.VolumeType = rdiskDomain.VolumeType(c.VolumeType)\n\t}\n\tif c.DiskType != \"\" {\n\t\tvol.DiskType = rdiskDomain.DiskType(c.DiskType)\n\t}\n\terr = lvRepo.Add(ctx, vol)\n\tif err != nil {\n\t\treturn\n\t}\n\tc.createdLogicalVolume = vol\n\n\t// 3. 触发状态机，联动更新逻辑卷和物理卷状态\n\t_, err = sm.Fire(ctx, rdiskDomain.LVSUnInited, rdiskDomain.LVECreateLogicalVolume, c)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_running_backup_task.go",
        "code_start_line": 31,
        "code_end_line": 61,
        "code_key": "Handle",
        "code_value": "func (c *UpdateRunningBackupTaskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventUpdateBackupProgress,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_drgroup.go",
        "code_start_line": 78,
        "code_end_line": 173,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeDRGroupCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tlvView  = app.GetRegistry(ctx).Viewers.LogicalVolume\n\t\tdrgRepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t\tsm      = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\terr     error\n\t)\n\n\t// 0. 初始化\n\tc.drgroupRef = make(map[string]*drgroup.DRGroup)\n\n\t// 1. 加载所有逻辑卷所在的置放群组\n\tallVolumeUUIDs := make([]string, 0, len(c.UUIDs))\n\tfor _, _uuid := range c.UUIDs {\n\t\tallVolumeUUIDs = append(allVolumeUUIDs, _uuid.String())\n\t}\n\tif groups, err := drgRepo.FindByMembers(ctx, c.AppID, allVolumeUUIDs); err == nil {\n\t\tif err != nil {\n\t\t\tif !errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tfor _, group := range groups {\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t\tc.curDRGroupNames = append(c.curDRGroupNames, group.Name)\n\t\t}\n\t} else {\n\t\treturn err\n\t}\n\n\t// 2. 确认已上锁的置放群组和当前一致\n\tif !c.checkLockedDRGroupNames() {\n\t\treturn errors.New(drgroup.ErrGroupModified, \"drgroup changed\")\n\t}\n\n\t// 3. 加载所有逻辑卷的状态，不需要完整实体，因为不会修改 Volume\n\tc.relatedLogicalVolume, err = lvView.FindByIDs(ctx, c.AppID, c.UUIDs)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(c.relatedLogicalVolume) < len(c.UUIDs) {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t// 4. 加载所有目标置放群组，key 为 name\n\tfor _, spec := range c.Specs {\n\t\tvar group *drgroup.DRGroup\n\t\tif _, ok := c.drgroupRef[spec.Name]; ok {\n\t\t\tgroup = c.drgroupRef[spec.Name]\n\t\t} else {\n\t\t\tgroup, err = c.getOrCreateDRGroup(ctx, drgRepo, spec)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t}\n\n\t\tif spec.Affinity > 0 {\n\t\t\tgroup.Affinity = spec.Affinity\n\t\t}\n\t\tif spec.Type != \"\" {\n\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t}\n\t}\n\n\t// 5. 对所有逻辑卷执行置放群组变更事件，检查状态是否允许，\n\t//    实际的更新还是在这里执行。\n\tfor _, vol := range c.relatedLogicalVolume {\n\t\terr := sm.Check(ctx, vol.State, rdiskDomain.LVEUpdateDrGroup, c)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// 将逻辑卷从原有的置放群组中移除\n\t\tfor _, name := range c.curDRGroupNames {\n\t\t\tc.drgroupRef[name].RemoveMember(vol.UUID.String())\n\t\t}\n\t\t// 将逻辑卷添加到新的置放群组中\n\t\tfor _, spec := range c.Specs {\n\t\t\tsubGroup := spec.SubGroup\n\t\t\tif subGroup == \"\" {\n\t\t\t\t// 如果没有指定子组，则使用远端 SSD UUID 作为子组名称\n\t\t\t\t// 相当于每块盘都是一个子组，相当于没有使用子组功能\n\t\t\t\tsubGroup = vol.UUID.String()\n\t\t\t}\n\t\t\tif err := c.drgroupRef[spec.Name].AddMember(vol.UUID.String(), subGroup, vol.PhysicalVolume.IP.String()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tif c.DryRun {\n\t\treturn errors.New(errors.ErrDryRunSuccessExit, \"dry run check success\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/online_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OnlinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOnlinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_benchmark_task.go",
        "code_start_line": 34,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *UpdateBenchmarkTask) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, rdisk.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark, err = benchRepo.FindByUUID(ctx, c.BenchmarkUUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventUpdateBench, benchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_flow_ctrl.go",
        "code_start_line": 80,
        "code_end_line": 103,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeFlowControlCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not found\")\n\t}\n\n\tspec := c.volume.FlowControlSpec\n\tif !c.UpdateRequest.UpdateSpec(&spec, c.volume.GetDefaultFlowControlSpec()) {\n\t\t// 没有任何更新，直接返回成功\n\t\treturn nil\n\t}\n\tc.volume.SetFlowControlSpec(spec)\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEUpdateFlowControl, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_defunct_volume.go",
        "code_start_line": 46,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *CleanupDefunctCommand) Handle(ctx context.Context) error {\n\tvar err error\n\tc.lv, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar sm = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\tvar event = rdiskDomain.LVECleanupDefunct\n\n\tfor _, attachment := range c.lv.Attachments {\n\t\tlogs.Info(ctx).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).Msg(\"cleanup defuncting volume\")\n\t\tsubCmd := &cleanDefunctSubCommand{Parent: c, HostIP: attachment.IP}\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, subCmd)\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，因为只要有一个挂载点清理失败，其他挂载点还是需要继续清理的\n\t\t\t// 失败的挂载点会在后台继续清理\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).\n\t\t\t\tMsg(\"failed to cleanup defunct volume, retry later.\")\n\t\t}\n\t}\n\n\tif len(c.lv.Attachments) == 0 {\n\t\t// 没有挂载点，直接清理\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, &cleanDefunctSubCommand{Parent: c, HostIP: net.IP{}})\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，后续自动重试即可\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Msg(\"failed to complete cleanup defunct volume\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_drgroup_exists.go",
        "code_start_line": 28,
        "code_end_line": 53,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDRGroupExistsCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t)\n\tfor _, spec := range c.DRGroup {\n\t\t_, err := repo.FindByName(ctx, users.AppID(c.AppID), spec.Name)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\tgroup := drgroup.New(spec.Name, users.AppID(c.AppID))\n\t\t\t\tif spec.Affinity > 0 {\n\t\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t\t}\n\t\t\t\tif spec.Type != \"\" {\n\t\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t\t}\n\t\t\t\terr = repo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_physical_volume.go",
        "code_start_line": 31,
        "code_end_line": 54,
        "code_key": "Handle",
        "code_value": "func (c *UpdatePhyRDiskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEUpdatePhysicalVolume, c)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/recycle_backup_data.go",
        "code_start_line": 32,
        "code_end_line": 62,
        "code_key": "Handle",
        "code_value": "func (c *RecycleBackupDataCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventDeleteBackup,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 143,
        "code_end_line": 190,
        "code_key": "handleBindedVolume",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) handleBindedVolume(ctx context.Context) error {\n\tlogicalVolume, err := app.GetRegistry(ctx).Repositories.LogicalVolume.FindByAppIDAndUUID(ctx, *c.appId, *c.lvUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif logicalVolume.PhysicalVolume.Serial != c.Serial {\n\t\treturn errors.New(\n\t\t\trdiskDomain.ErrInvalidSerial,\n\t\t\tfmt.Sprintf(\"serial not match %s != %s\", string(logicalVolume.PhysicalVolume.Serial), c.Serial))\n\t}\n\n\tif logicalVolume.MustDefunctWithAuthorization() && !c.validateAuthorizeToken(ctx) {\n\t\treturn errors.New(rdiskDomain.ErrUnAuthorizedDefunct, \"unauthorized defunct, vol is binded to a account disk\")\n\t}\n\n\tc.lv = logicalVolume\n\tc.pv = logicalVolume.PhysicalVolume\n\tif err := c.checkPhysicalVolume(ctx); err != nil {\n\t\treturn err\n\t}\n\tc.drgroups, err = app.GetRegistry(ctx).Repositories.DRGroup.FindByMember(ctx, c.lv.AppID, c.lv.UUID.String())\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\tc.drgroups = nil\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tlogs.Warn(ctx).Str(\"token\", c.AuthorizeToken).\n\t\tStr(\"serial\", string(c.Serial)).\n\t\tStr(\"uuid\", c.lvUUID.String()).\n\t\tInt64(\"app_id\", int64(*c.appId)).\n\t\tMsg(\"authorized defunct binded volume\")\n\n\tif _, err := app.GetRegistry(ctx).StateMachines.LogicalVolume.Fire(ctx, c.lv.State,\n\t\trdiskDomain.LVEMarkDefunct, c); err != nil {\n\n\t\tlogs.Error(ctx).Err(err).\n\t\t\tStringer(\"serial\", c.Serial).\n\t\t\tInt64(\"app_id\", int64(*c.appId)).\n\t\t\tStringer(\"uuid\", c.lvUUID).\n\t\t\tMsg(\"failed to mark logical volume as defunct\")\n\t\treturn err\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 351,
        "code_end_line": 364,
        "code_key": "StepThenLogicalVolStateShouldBe",
        "code_value": "func StepThenLogicalVolStateShouldBe(logicalVol *rdiskDomain.LogicalVolume, registry *app.Registry, db *gorm.DB, database string, value interface{}) *rdiskDomain.LogicalVolume {\n\tdb.Exec(fmt.Sprintf(\"USE `%s`\", database))\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\tnewLogicalVol, err := registry.Repositories.LogicalVolume.FindByAppIDAndUUID(workerCtx, logicalVol.AppID, logicalVol.UUID)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif newLogicalVol.State != rdiskDomain.LogicalVolumeState(value.(int)) {\n\t\tpanic(\"LogicalVol state error\")\n\t}\n\treturn newLogicalVol\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 5,
        "code_end_line": 27,
        "code_key": "DmRdisk",
        "code_value": "type DmRdisk struct {\n\tID                 uint64    `gorm:\"column:id;primaryKey\"`\n\tUUID               string    `gorm:\"column:uuid;unique\"`\n\tStatus             int       `gorm:\"column:status\"`\n\tAppID              int64     `gorm:\"column:app_id\"`\n\tSize               int64     `gorm:\"column:size\"`\n\tPhydiskSerial      string    `gorm:\"column:phydisk_serial\"`\n\tExtra              string    `gorm:\"column:extra\"`\n\tZoneID             int64     `gorm:\"column:zone_id\"`\n\tVolumeType         string    `gorm:\"column:volume_type\"`\n\tDiskType           string    `gorm:\"column:disk_type\"`\n\tReadIOPS           int64     `gorm:\"column:read_iops\"`\n\tReadBandwidth      int64     `gorm:\"column:read_bandwidth\"`\n\tWriteIOPS          int64     `gorm:\"column:write_iops\"`\n\tWriteBandwidth     int64     `gorm:\"column:write_bandwidth\"`\n\tReadWriteIOPS      int64     `gorm:\"column:rw_iops\"`\n\tReadWriteBandwidth int64     `gorm:\"column:rw_bandwidth\"`\n\tCreated            time.Time `gorm:\"column:created\"`\n\tUpdated            time.Time `gorm:\"column:updated\"`\n\n\tDmPhyDisk   *DmPhydisk          `gorm:\"foreignKey:Serial;references:PhydiskSerial\"`\n\tAttachments []DmRdiskAttachment `gorm:\"foreignKey:UUID;references:UUID\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 29,
        "code_end_line": 31,
        "code_key": "TableName",
        "code_value": "func (DmRdisk) TableName() string {\n\treturn \"dm_rdisk\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go:49:74:FindByID": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go",
    "code_start_line": 49,
    "code_end_line": 74,
    "code_start_column": 38,
    "code_key": "FindByID",
    "code_value": "func (l logicalVolumeRepositoryImpl) FindByID(ctx context.Context, id uuid.UUID) (*rdiskDomain.LogicalVolume, error) {\n\tuow := getUow(ctx)\n\tvol := metadb.DmRdisk{}\n\tresult := uow.tx.\n\t\tPreload(\"Attachments\").\n\t\tPreload(\"DmPhyDisk\").\n\t\tFirst(&vol, \"uuid = ?\", id.String())\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tlv, err := fromDmRDiskToModel(ctx, &vol)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlv = uow.trackedLogicalVolumes.Add(lv)\n\tif lv.PhysicalVolume != nil {\n\t\tlv.PhysicalVolume = uow.trackedPhyVolumes.Add(lv.PhysicalVolume)\n\t}\n\treturn lv, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go",
        "code_start_line": 51,
        "code_end_line": 72,
        "code_key": "Handle",
        "code_value": "func (c *CbsAppIdConsumer) Handle(ctx context.Context, delivery *rabbitmq.Delivery) error {\n\tu, chargeTime, err := c.ParseDelivery(ctx, delivery)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif u == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"USER_INFO_NOT_FOUND\")\n\t\treturn nil\n\t}\n\n\tchargeDetail := c.GetChargeDetailForSingleUser(u, chargeTime)\n\tif chargeDetail == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tUint64(\"appId\", uint64(u.AppId)).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"NO_RESOURCE_TO_CHARGE\")\n\t\treturn nil\n\t}\n\treturn c.ProcessChargeDetail(chargeDetail)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 105,
        "code_end_line": 116,
        "code_key": "Handle",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tif err := c.ensureLocks(ctx); err != nil {\n\t\treturn err\n\t}\n\tif c.lvUUID != nil {\n\t\t// 涉及到逻辑卷时，需要先标记逻辑卷为故障\n\t\treturn c.handleBindedVolume(ctx)\n\t} else {\n\t\t// 不涉及到逻辑卷时，直接标记物理卷为故障\n\t\treturn c.handleIdleVolume(ctx)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/detach_logical_volume.go",
        "code_start_line": 56,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *DetachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDetachLogicalVolume, c)\n\n\t// 如果没有挂载到指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume not attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_benchmark_task.go",
        "code_start_line": 125,
        "code_end_line": 165,
        "code_key": "Handle",
        "code_value": "func (c *CreateBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tvolSm     = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = volSm.Fire(ctx, c.relatedVolume.State, domain.PVEStartBenchmark, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark = benchmark.New(benchmark.DiskInfo{\n\t\tSerial: string(c.relatedVolume.Serial),\n\t\tHostIP: c.relatedVolume.IP,\n\t\tBDF:    string(c.relatedVolume.BDF),\n\t})\n\n\tif err = benchRepo.Add(ctx, c.relatedBenchmark); err != nil {\n\t\tdelegate := &benchmarkDelegate{cmd: c}\n\t\tif _err := delegate.TaskFinishCallback(ctx, c.relatedBenchmark); _err != nil {\n\t\t\tlogs.Warn(ctx).Err(_err).Str(\"serial\", string(c.relatedVolume.Serial)).Msg(\"failed to rollback: create bdev\")\n\t\t}\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventCreateBench,\n\t\tbenchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_logical_volume.go",
        "code_start_line": 71,
        "code_end_line": 108,
        "code_key": "Handle",
        "code_value": "func (d *DeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\td.volume, err = repo.FindByID(ctx, d.UUID)\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif e := d.volume.CheckDelete(); e != nil {\n\t\treturn e\n\t}\n\n\tif d.volume.AppID != d.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"refuse to delet: app id mismatch\")\n\t}\n\n\td.drgroup, err = app.GetRegistry(ctx).Repositories.DRGroup.FindByMember(ctx, d.AppID, d.volume.UUID.String())\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\td.drgroup = nil\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := d.checkDRGroupMatch(ctx); err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, d.volume.State, rdiskDomain.LVEMarkToRecycle, d)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_recycled_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmRecycledPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEConfirmRecycled, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_rdisk_backup.go",
        "code_start_line": 52,
        "code_end_line": 75,
        "code_key": "Handle",
        "code_value": "func (c *DeleteRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tsm   = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\tc.relatedBackup, err = repo.FindByUUID(ctx, c.BackupID.String())\n\tif err != nil || c.relatedBackup == nil || c.relatedBackup.AppID != c.AppID {\n\t\treturn errors.New(backupDomain.ErrBackupNotExist, \"backup not exists\")\n\t}\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tc.relatedBackup.Status,\n\t\tbackupDomain.EventSoftDeleteBackup,\n\t\tbackupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: c.relatedBackup})\n\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_rdisk_backup.go",
        "code_start_line": 47,
        "code_end_line": 80,
        "code_key": "Handle",
        "code_value": "func (c *CreateRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tlvSm  = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\tbakSm = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo  = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t_, err = lvSm.Fire(ctx, c.relatedVolume.State, rdiskDomain.LVEBackupStarted, c)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tlv := c.relatedVolume\n\tbackup := backupDomain.New(\n\t\tlv.AppID,\n\t\tbackupDomain.DiskInfo{\n\t\t\tVolumeUUID: lv.UUID,\n\t\t\tVolumeSize: uint64(lv.Size),\n\t\t\tHostIP:     lv.PhysicalVolume.IP,\n\t\t\tHostBDF:    string(lv.PhysicalVolume.BDF),\n\t\t\tSerial:     string(lv.PhysicalVolume.Serial),\n\t\t},\n\t)\n\tif err := repo.Add(ctx, backup); err != nil {\n\t\treturn err\n\t}\n\tc.relatedBackup = backup\n\t_, err = bakSm.Fire(ctx, backupDomain.StatusInit, backupDomain.EventStartBackup, backupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: backup})\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/attach_logical_volume.go",
        "code_start_line": 49,
        "code_end_line": 71,
        "code_key": "Handle",
        "code_value": "func (c *AttachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEAttachLogicalVolume, c)\n\n\t// 如果已经挂载到了指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeAlreadyAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume already attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_delete_logical_volume.go",
        "code_start_line": 34,
        "code_end_line": 55,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\t// 如果逻辑卷不存在，则直接返回成功\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"failed to confirm delete: app id mismatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDeleteLogicalVolume, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/offline_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OfflinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOfflinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *DeletePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\t// 如果物理卷不存在，则直接幂等返回\n\t\treturn nil\n\t}\n\n\tvar event = domain.PVEDeletePhysicalVolume\n\tif c.Force && (c.relatedVolume.State == domain.PVSDefunct) {\n\t\t// 这里的实现不太好，状态机的逻辑不应该侵入 cmd\n\t\t// 时间太赶了，后续重构优化吧\n\t\tevent = domain.PVEForceDeleteForDefunct\n\t}\n\n\tif c.relatedVolume.HasBindedPV() {\n\t\treturn errors.New(domain.ErrVolumeBusy, \"logic volume has binded to this physical volume\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, event, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_logical_volume.go",
        "code_start_line": 55,
        "code_end_line": 70,
        "code_key": "Handle",
        "code_value": "func (c *CleanupLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVECleanupLogicalVolume, c)\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_init_physical_volume.go",
        "code_start_line": 26,
        "code_end_line": 52,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmInitPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\tif c.relatedVolume.IP.String() != c.Host.String() {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume host ip mistmatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVECreatePhysicalVolumeOnHost, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_physical_volume.go",
        "code_start_line": 51,
        "code_end_line": 101,
        "code_key": "Handle",
        "code_value": "func (c *CreatePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\n\t// 获取物理卷状态机\n\tsm := app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\trepo := app.GetRegistry(ctx).Repositories.PhysicalVolume\n\n\t// 检查物理卷是否已经存在，如果存在则直接幂等返回\n\tvol1, err := repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"serial\", c.Serial).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tvol2, err := repo.FindByIPAndBDF(ctx, c.Host, domain.BDF(c.BDF))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"host\", c.Host.String()).Str(\"bdf\", c.BDF).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tfor _, vol := range []*domain.PhysicalVolume{vol1, vol2} {\n\t\texisted, err := c.checkExisting(ctx, vol)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif existed {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// 触发事件，创建物理卷\n\t_, err = sm.Fire(ctx,\n\t\tdomain.PVSUnInited,\n\t\tdomain.PVECreatePhysicalVolume,\n\t\tc,\n\t)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 创建 Bdev 以及格式化移动到创建物理卷的状态机中\n\n\t// _, err = sm.Fire(ctx,\n\t// \tc.GetPhysicalVolume().State,\n\t// \tdomain.PVECreatePhysicalVolumeOnHost,\n\t// \tc,\n\t// )\n\t// if err != nil {\n\t// \treturn err\n\t// }\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_benchmark_task.go",
        "code_start_line": 32,
        "code_end_line": 57,
        "code_key": "Handle",
        "code_value": "func (c *DeleteBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\terr       error\n\t)\n\n\tbench, err := benchRepo.FindByUUID(ctx, c.BenchmarkUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif bench.DiskInfo.Serial != c.Serial {\n\t\treturn errors.Newf(benchmark.ErrTaskNotFound, \"benchmark serial not match %s, want %s\", c.Serial, bench.DiskInfo.Serial)\n\t}\n\n\t_, err = benchSm.Fire(ctx, bench.Status, benchmark.EventDeleteBench, benchmark.Data{Benchmark: bench, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := benchRepo.Delete(ctx, bench); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_logical_volume.go",
        "code_start_line": 52,
        "code_end_line": 98,
        "code_key": "Handle",
        "code_value": "func (c *CreateLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tpvRepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tlvRepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm     = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\t// 1. 查找底层物理卷\n\tc.selectedPhysicalVolume, err = pvRepo.FindBySerial(ctx, rdiskDomain.Serial(c.PhysicalVolumeSerial))\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// 检查底层物理卷大小是否满足要求\n\tif c.selectedPhysicalVolume.Size < rdiskDomain.Size(c.DiskSize) {\n\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume size %d is smaller than requested size %d\", c.selectedPhysicalVolume.Size, c.DiskSize)\n\t}\n\n\t// 检查底层物理卷性能等级是否满足要求\n\tif c.PerformanceRank != \"\" {\n\t\tif string(c.selectedPhysicalVolume.PerformanceRank) != c.PerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not match requested rank %s\", c.selectedPhysicalVolume.PerformanceRank, c.PerformanceRank)\n\t\t}\n\t} else {\n\t\tif c.selectedPhysicalVolume.PerformanceRank != rdiskDomain.DefaultPerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not default rank %s\", c.selectedPhysicalVolume.PerformanceRank, rdiskDomain.DefaultPerformanceRank)\n\t\t}\n\t}\n\n\t// 2. 创建逻辑卷\n\tvol := rdiskDomain.NewLogicalVolume(users.AppID(c.AppID), rdiskDomain.Size(c.DiskSize), rdiskDomain.ZoneID(c.ZoneID))\n\tif c.VolumeType != \"\" {\n\t\tvol.VolumeType = rdiskDomain.VolumeType(c.VolumeType)\n\t}\n\tif c.DiskType != \"\" {\n\t\tvol.DiskType = rdiskDomain.DiskType(c.DiskType)\n\t}\n\terr = lvRepo.Add(ctx, vol)\n\tif err != nil {\n\t\treturn\n\t}\n\tc.createdLogicalVolume = vol\n\n\t// 3. 触发状态机，联动更新逻辑卷和物理卷状态\n\t_, err = sm.Fire(ctx, rdiskDomain.LVSUnInited, rdiskDomain.LVECreateLogicalVolume, c)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_running_backup_task.go",
        "code_start_line": 31,
        "code_end_line": 61,
        "code_key": "Handle",
        "code_value": "func (c *UpdateRunningBackupTaskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventUpdateBackupProgress,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_drgroup.go",
        "code_start_line": 78,
        "code_end_line": 173,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeDRGroupCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tlvView  = app.GetRegistry(ctx).Viewers.LogicalVolume\n\t\tdrgRepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t\tsm      = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\terr     error\n\t)\n\n\t// 0. 初始化\n\tc.drgroupRef = make(map[string]*drgroup.DRGroup)\n\n\t// 1. 加载所有逻辑卷所在的置放群组\n\tallVolumeUUIDs := make([]string, 0, len(c.UUIDs))\n\tfor _, _uuid := range c.UUIDs {\n\t\tallVolumeUUIDs = append(allVolumeUUIDs, _uuid.String())\n\t}\n\tif groups, err := drgRepo.FindByMembers(ctx, c.AppID, allVolumeUUIDs); err == nil {\n\t\tif err != nil {\n\t\t\tif !errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tfor _, group := range groups {\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t\tc.curDRGroupNames = append(c.curDRGroupNames, group.Name)\n\t\t}\n\t} else {\n\t\treturn err\n\t}\n\n\t// 2. 确认已上锁的置放群组和当前一致\n\tif !c.checkLockedDRGroupNames() {\n\t\treturn errors.New(drgroup.ErrGroupModified, \"drgroup changed\")\n\t}\n\n\t// 3. 加载所有逻辑卷的状态，不需要完整实体，因为不会修改 Volume\n\tc.relatedLogicalVolume, err = lvView.FindByIDs(ctx, c.AppID, c.UUIDs)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(c.relatedLogicalVolume) < len(c.UUIDs) {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t// 4. 加载所有目标置放群组，key 为 name\n\tfor _, spec := range c.Specs {\n\t\tvar group *drgroup.DRGroup\n\t\tif _, ok := c.drgroupRef[spec.Name]; ok {\n\t\t\tgroup = c.drgroupRef[spec.Name]\n\t\t} else {\n\t\t\tgroup, err = c.getOrCreateDRGroup(ctx, drgRepo, spec)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t}\n\n\t\tif spec.Affinity > 0 {\n\t\t\tgroup.Affinity = spec.Affinity\n\t\t}\n\t\tif spec.Type != \"\" {\n\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t}\n\t}\n\n\t// 5. 对所有逻辑卷执行置放群组变更事件，检查状态是否允许，\n\t//    实际的更新还是在这里执行。\n\tfor _, vol := range c.relatedLogicalVolume {\n\t\terr := sm.Check(ctx, vol.State, rdiskDomain.LVEUpdateDrGroup, c)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// 将逻辑卷从原有的置放群组中移除\n\t\tfor _, name := range c.curDRGroupNames {\n\t\t\tc.drgroupRef[name].RemoveMember(vol.UUID.String())\n\t\t}\n\t\t// 将逻辑卷添加到新的置放群组中\n\t\tfor _, spec := range c.Specs {\n\t\t\tsubGroup := spec.SubGroup\n\t\t\tif subGroup == \"\" {\n\t\t\t\t// 如果没有指定子组，则使用远端 SSD UUID 作为子组名称\n\t\t\t\t// 相当于每块盘都是一个子组，相当于没有使用子组功能\n\t\t\t\tsubGroup = vol.UUID.String()\n\t\t\t}\n\t\t\tif err := c.drgroupRef[spec.Name].AddMember(vol.UUID.String(), subGroup, vol.PhysicalVolume.IP.String()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tif c.DryRun {\n\t\treturn errors.New(errors.ErrDryRunSuccessExit, \"dry run check success\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/online_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OnlinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOnlinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_benchmark_task.go",
        "code_start_line": 34,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *UpdateBenchmarkTask) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, rdisk.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark, err = benchRepo.FindByUUID(ctx, c.BenchmarkUUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventUpdateBench, benchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_flow_ctrl.go",
        "code_start_line": 80,
        "code_end_line": 103,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeFlowControlCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not found\")\n\t}\n\n\tspec := c.volume.FlowControlSpec\n\tif !c.UpdateRequest.UpdateSpec(&spec, c.volume.GetDefaultFlowControlSpec()) {\n\t\t// 没有任何更新，直接返回成功\n\t\treturn nil\n\t}\n\tc.volume.SetFlowControlSpec(spec)\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEUpdateFlowControl, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_defunct_volume.go",
        "code_start_line": 46,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *CleanupDefunctCommand) Handle(ctx context.Context) error {\n\tvar err error\n\tc.lv, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar sm = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\tvar event = rdiskDomain.LVECleanupDefunct\n\n\tfor _, attachment := range c.lv.Attachments {\n\t\tlogs.Info(ctx).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).Msg(\"cleanup defuncting volume\")\n\t\tsubCmd := &cleanDefunctSubCommand{Parent: c, HostIP: attachment.IP}\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, subCmd)\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，因为只要有一个挂载点清理失败，其他挂载点还是需要继续清理的\n\t\t\t// 失败的挂载点会在后台继续清理\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).\n\t\t\t\tMsg(\"failed to cleanup defunct volume, retry later.\")\n\t\t}\n\t}\n\n\tif len(c.lv.Attachments) == 0 {\n\t\t// 没有挂载点，直接清理\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, &cleanDefunctSubCommand{Parent: c, HostIP: net.IP{}})\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，后续自动重试即可\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Msg(\"failed to complete cleanup defunct volume\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_drgroup_exists.go",
        "code_start_line": 28,
        "code_end_line": 53,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDRGroupExistsCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t)\n\tfor _, spec := range c.DRGroup {\n\t\t_, err := repo.FindByName(ctx, users.AppID(c.AppID), spec.Name)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\tgroup := drgroup.New(spec.Name, users.AppID(c.AppID))\n\t\t\t\tif spec.Affinity > 0 {\n\t\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t\t}\n\t\t\t\tif spec.Type != \"\" {\n\t\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t\t}\n\t\t\t\terr = repo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_physical_volume.go",
        "code_start_line": 31,
        "code_end_line": 54,
        "code_key": "Handle",
        "code_value": "func (c *UpdatePhyRDiskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEUpdatePhysicalVolume, c)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/recycle_backup_data.go",
        "code_start_line": 32,
        "code_end_line": 62,
        "code_key": "Handle",
        "code_value": "func (c *RecycleBackupDataCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventDeleteBackup,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 5,
        "code_end_line": 27,
        "code_key": "DmRdisk",
        "code_value": "type DmRdisk struct {\n\tID                 uint64    `gorm:\"column:id;primaryKey\"`\n\tUUID               string    `gorm:\"column:uuid;unique\"`\n\tStatus             int       `gorm:\"column:status\"`\n\tAppID              int64     `gorm:\"column:app_id\"`\n\tSize               int64     `gorm:\"column:size\"`\n\tPhydiskSerial      string    `gorm:\"column:phydisk_serial\"`\n\tExtra              string    `gorm:\"column:extra\"`\n\tZoneID             int64     `gorm:\"column:zone_id\"`\n\tVolumeType         string    `gorm:\"column:volume_type\"`\n\tDiskType           string    `gorm:\"column:disk_type\"`\n\tReadIOPS           int64     `gorm:\"column:read_iops\"`\n\tReadBandwidth      int64     `gorm:\"column:read_bandwidth\"`\n\tWriteIOPS          int64     `gorm:\"column:write_iops\"`\n\tWriteBandwidth     int64     `gorm:\"column:write_bandwidth\"`\n\tReadWriteIOPS      int64     `gorm:\"column:rw_iops\"`\n\tReadWriteBandwidth int64     `gorm:\"column:rw_bandwidth\"`\n\tCreated            time.Time `gorm:\"column:created\"`\n\tUpdated            time.Time `gorm:\"column:updated\"`\n\n\tDmPhyDisk   *DmPhydisk          `gorm:\"foreignKey:Serial;references:PhydiskSerial\"`\n\tAttachments []DmRdiskAttachment `gorm:\"foreignKey:UUID;references:UUID\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 29,
        "code_end_line": 31,
        "code_key": "TableName",
        "code_value": "func (DmRdisk) TableName() string {\n\treturn \"dm_rdisk\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go:199:305:updateLogicalVolume": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/logical_disk.go",
    "code_start_line": 199,
    "code_end_line": 305,
    "code_start_column": 6,
    "code_key": "updateLogicalVolume",
    "code_value": "func updateLogicalVolume(ctx context.Context, item, originalState *rdiskDomain.LogicalVolume) error {\n\tuow := getUow(ctx)\n\tcurDO := fromModelToDmRDisk(item)\n\toriginalDO := fromModelToDmRDisk(originalState)\n\tchanges := make(map[string]interface{})\n\tcheckChange := func(field string, cur interface{}, original interface{}) {\n\t\tif cur != original {\n\t\t\tchanges[field] = cur\n\t\t}\n\t}\n\tcheckChange(\"uuid\", curDO.UUID, originalDO.UUID)\n\tcheckChange(\"status\", curDO.Status, originalDO.Status)\n\tcheckChange(\"app_id\", curDO.AppID, originalDO.AppID)\n\tcheckChange(\"size\", curDO.Size, originalDO.Size)\n\tcheckChange(\"phydisk_serial\", curDO.PhydiskSerial, originalDO.PhydiskSerial)\n\tcheckChange(\"zone_id\", curDO.ZoneID, originalDO.ZoneID)\n\tcheckChange(\"volume_type\", curDO.VolumeType, originalDO.VolumeType)\n\tcheckChange(\"disk_type\", curDO.DiskType, originalDO.DiskType)\n\tcheckChange(\"read_iops\", curDO.ReadIOPS, originalDO.ReadIOPS)\n\tcheckChange(\"write_iops\", curDO.WriteIOPS, originalDO.WriteIOPS)\n\tcheckChange(\"rw_iops\", curDO.ReadWriteIOPS, originalDO.ReadWriteIOPS)\n\tcheckChange(\"read_bandwidth\", curDO.ReadBandwidth, originalDO.ReadBandwidth)\n\tcheckChange(\"write_bandwidth\", curDO.WriteBandwidth, originalDO.WriteBandwidth)\n\tcheckChange(\"rw_bandwidth\", curDO.ReadWriteBandwidth, originalDO.ReadWriteBandwidth)\n\n\tif len(changes) != 0 {\n\t\tchanges[\"updated\"] = uow.tx.NowFunc()\n\n\t\tresult := uow.tx.Model(curDO).Where(\"id = ?\", curDO.ID).Updates(changes)\n\t\tif result.Error != nil {\n\t\t\treturn result.Error\n\t\t}\n\t}\n\n\t// 更新挂载信息\n\n\tallHosts := make(map[string]struct{})\n\toriginHosts := make(map[string]*rdiskDomain.VolumeAttachment)\n\tcurHosts := make(map[string]*rdiskDomain.VolumeAttachment)\n\tfor _, a := range item.Attachments {\n\t\tallHosts[a.IP.String()] = struct{}{}\n\t\tcurHosts[a.IP.String()] = a\n\t}\n\tfor _, a := range originalState.Attachments {\n\t\tallHosts[a.IP.String()] = struct{}{}\n\t\toriginHosts[a.IP.String()] = a\n\t}\n\n\tfor hostIp := range allHosts {\n\t\tcurAttachment, _ := curHosts[hostIp]\n\t\toriginAttachment, _ := originHosts[hostIp]\n\t\tif originAttachment == nil && curAttachment != nil {\n\t\t\t// 新增挂载\n\t\t\tdo := fromModelToDmRDiskAttachment(curAttachment)\n\t\t\tdo.UUID = curDO.UUID\n\t\t\tdo.Created = uow.tx.NowFunc()\n\t\t\tdo.Updated = uow.tx.NowFunc()\n\t\t\terr := uow.tx.Model(curDO).Association(\"Attachments\").Append(do)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else if originAttachment != nil && curAttachment == nil {\n\t\t\t// 删除挂载\n\t\t\tdo := fromModelToDmRDiskAttachment(originAttachment)\n\t\t\tdo.UUID = curDO.UUID\n\t\t\tresult := uow.tx.Where(\"host_ip = ? and uuid = ?\", do.IP, do.UUID).Delete(do)\n\t\t\tif result.Error != nil {\n\t\t\t\treturn result.Error\n\t\t\t}\n\t\t} else if originAttachment != nil && curAttachment != nil {\n\t\t\t// 更新挂载\n\t\t\tdo := fromModelToDmRDiskAttachment(curAttachment)\n\t\t\tdo.UUID = curDO.UUID\n\t\t\toriginDo := fromModelToDmRDiskAttachment(originAttachment)\n\t\t\toriginDo.UUID = curDO.UUID\n\t\t\tchanges := make(map[string]interface{})\n\t\t\tcheckChange := func(field string, cur interface{}, original interface{}) {\n\t\t\t\tif cur != original {\n\t\t\t\t\tchanges[field] = cur\n\t\t\t\t}\n\t\t\t}\n\t\t\tcheckChange(\"mode\", do.Mode, originDo.Mode)\n\t\t\tcheckChange(\"read_iops\", do.ReadIOPS, originDo.ReadIOPS)\n\t\t\tcheckChange(\"write_iops\", do.WriteIOPS, originDo.WriteIOPS)\n\t\t\tcheckChange(\"rw_iops\", do.ReadWriteIOPS, originDo.ReadWriteIOPS)\n\t\t\tcheckChange(\"read_bandwidth\", do.ReadBandwidth, originDo.ReadBandwidth)\n\t\t\tcheckChange(\"write_bandwidth\", do.WriteBandwidth, originDo.WriteBandwidth)\n\t\t\tcheckChange(\"rw_bandwidth\", do.ReadWriteBandwidth, originDo.ReadWriteBandwidth)\n\t\t\tcheckChange(\"num_queue\", do.NumQueue, originDo.NumQueue)\n\t\t\tcheckChange(\"serial\", do.Serial, originDo.Serial)\n\t\t\tcheckChange(\"vcpu\", do.VCPU, originDo.VCPU)\n\t\t\tcheckChange(\"spdk_driver\", do.SPDKDriver, originDo.SPDKDriver)\n\n\t\t\tif len(changes) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tchanges[\"updated\"] = uow.tx.NowFunc()\n\t\t\tresult := uow.tx.Model(do).Where(\"host_ip = ? and uuid = ?\", do.IP, do.UUID).Updates(changes)\n\t\t\tif result.Error != nil {\n\t\t\t\treturn result.Error\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 3,
    "callers": [],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/model.go",
        "code_start_line": 10,
        "code_end_line": 12,
        "code_key": "Model",
        "code_value": "type Model struct {\n\tId ID `json:\"id\" gorm:\"primaryKey;autoIncrement;comment:主键\"`\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 443,
        "code_end_line": 448,
        "code_key": "VolumeAttachment",
        "code_value": "type VolumeAttachment struct {\n\tIP              net.IP               // 挂载到的主机 IP\n\tMode            VolumeAttachmentMode // 挂载模式\n\tFlowControlSpec FlowControlSpec      // 流控规格\n\tOptions         AttachmentOption     // 挂载选项\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/uow.go:59:81:Commit": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/uow.go",
    "code_start_line": 59,
    "code_end_line": 81,
    "code_start_column": 22,
    "code_key": "Commit",
    "code_value": "func (u *unitOfWork) Commit(ctx context.Context) error {\n\terr := u.trackedPhyVolumes.Update(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = u.trackedLogicalVolumes.Update(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = u.trackedDRGroups.Update(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = u.trackedBackups.Update(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = u.trackedBenchmarks.Update(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn u.tx.Commit().Error\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 6,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/tracker.go",
        "code_start_line": 67,
        "code_end_line": 77,
        "code_key": "Refresh",
        "code_value": "func (rdp *PhyDiskTracker) Refresh(ctx context.Context) {\n\trdp.Track(ctx)\n\tlock.RDPhyCacheGlobalLock.GetLocker(lock.RDPhyLockKeyGenerator{}).Lock()\n\trdp.Merge(ctx, rdp.OriPhyDisks)\n\tlogs.Info(ctx).\n\t\tInt(\"disk_num\", len(rdp.ToCachedPhyDisks)).\n\t\tInt(\"member_num\", len(rdp.DrgroupMembers)).\n\t\tMsg(\"CACHE_AVAILABLE_PHY_DISK_AFTER_MERGE\")\n\trdp.CacheManager.RefreshCache(ctx, rdp.ToCachedPhyDisks, rdp.DrgroupMembers)\n\tlock.RDPhyCacheGlobalLock.GetLocker(lock.RDPhyLockKeyGenerator{}).Unlock()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/set/cache/tracker.go",
        "code_start_line": 35,
        "code_end_line": 38,
        "code_key": "Refresh",
        "code_value": "func (d *DiskSetTracker) Refresh(ctx context.Context) {\n\td.Track(ctx)\n\td.CacheManager.RefreshCache(ctx, d.DiskSetEntityInf)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 644,
        "code_end_line": 674,
        "code_key": "Refresh",
        "code_value": "func (l *mysqlLock) Refresh(ctx context.Context, ttl time.Duration) error {\n\n\ttx := l.locker.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\n\n\tkeysKey := dlock.LockKeySlice(l.keys).GetKeys()\n\t// NOCA:QCloudAkCheck(误报)\n\texistingLocks, err := l.locker.fetchExistingLocksByKeysAndTokens(tx, keysKey, l.tokens)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn err\n\t}\n\n\t// Compare existing locks with the keys.\n\tif !checkStrSetEqual(existingLocks, keysKey) {\n\t\t_ = tx.Rollback()\n\t\treturn errors.Wrap(dlock.ErrLockNotHeld, \"lock is not held\")\n\t}\n\n\t// Update the expiration time.\n\tif err := l.locker.updateLocksTTLByKeysAndTokens(tx, keysKey, l.tokens, ttl); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn err\n\t}\n\n\tif result := tx.Commit(); result.Error != nil {\n\t\treturn errors.Wrap(result.Error, \"failed to commit refresh locks\")\n\t}\n\n\tl.expiration = time.Now().Add(ttl)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mem/memdlock.go",
        "code_start_line": 189,
        "code_end_line": 210,
        "code_key": "Refresh",
        "code_value": "func (l *memLock) Refresh(ctx context.Context, ttl time.Duration) error {\n\tl.locker.mutex.Lock()\n\tdefer l.locker.mutex.Unlock()\n\n\ttokens := make(map[string]struct{}, len(l.tokens))\n\tfor _, item := range l.tokens {\n\t\ttokens[item] = struct{}{}\n\t}\n\tfor _, key := range l.keys {\n\t\tif item, ok := l.locker.data[key.Key]; ok {\n\t\t\tif _, exist := tokens[item.token]; !exist {\n\t\t\t\treturn dlock.ErrLockNotHeld\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, key := range l.keys {\n\t\tl.locker.data[key.Key].ttl = time.Now().Add(ttl)\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/test_utils/initdb.go",
        "code_start_line": 53,
        "code_end_line": 58,
        "code_key": "Release",
        "code_value": "func (p *dbPool) Release(idx int) {\n\tp.lock.Lock()\n\tdefer p.lock.Unlock()\n\tdelete(p.busyIdx, idx)\n\tp.freeIdx[idx] = struct{}{}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/testutil/db.go",
        "code_start_line": 59,
        "code_end_line": 64,
        "code_key": "Release",
        "code_value": "func (p *dbPool) Release(idx int) {\n\tp.lock.Lock()\n\tdefer p.lock.Unlock()\n\tdelete(p.busyIdx, idx)\n\tp.freeIdx[idx] = struct{}{}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 677,
        "code_end_line": 710,
        "code_key": "Release",
        "code_value": "func (l *mysqlLock) Release(ctx context.Context) error {\n\tif atomic.LoadInt32(&l.released) == 1 {\n\t\t// fast path\n\t\treturn nil\n\t}\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\n\t// slow path\n\tif l.released == 1 {\n\t\treturn nil\n\t}\n\n\ttx := l.locker.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\n\n\treadLocks, writeLocks := l.locker.getReadLocksAndWriteLocks(tx, l.keys)\n\n\tif err := l.locker.deleteLocksByKeysAndToken(tx, dlock.LockKeySlice(writeLocks).GetKeys(), l.tokens); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn errors.Wrap(err, \"failed to release locks\")\n\t}\n\n\tif err := l.locker.releaseReadLocks(tx, dlock.LockKeySlice(readLocks).GetKeys(), l.tokens); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn errors.Wrap(err, \"failed to release locks\")\n\t}\n\n\tif result := tx.Commit(); result.Error != nil {\n\t\treturn errors.Wrap(result.Error, \"failed to commit release locks\")\n\t}\n\tl.expiration = time.Now()\n\tatomic.StoreInt32(&l.released, 1)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mem/memdlock.go",
        "code_start_line": 213,
        "code_end_line": 246,
        "code_key": "Release",
        "code_value": "func (l *memLock) Release(ctx context.Context) error {\n\tif atomic.LoadInt32(&l.released) == 1 {\n\t\t// fast path\n\t\treturn nil\n\t}\n\tl.locker.mutex.Lock()\n\tdefer l.locker.mutex.Unlock()\n\n\t// slow path\n\tif l.released == 1 {\n\t\treturn nil\n\t}\n\n\ttokens := make(map[string]struct{}, len(l.tokens))\n\tfor _, item := range l.tokens {\n\t\ttokens[item] = struct{}{}\n\t}\n\tfor _, key := range l.keys {\n\t\tif item, ok := l.locker.data[key.Key]; ok {\n\t\t\tif _, exist := tokens[item.token]; !exist {\n\t\t\t\tcontinue\n\t\t\t} else {\n\t\t\t\tif item.lockType == dlock.ReadLock && item.count > 1 {\n\t\t\t\t\titem.count--\n\t\t\t\t} else {\n\t\t\t\t\tdelete(l.locker.data, key.Key)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tatomic.StoreInt32(&l.released, 1)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/dispatcher/dispatcher.go",
        "code_start_line": 33,
        "code_end_line": 103,
        "code_key": "Dispatch",
        "code_value": "func (d *dispatcherImpl) Dispatch(ctx context.Context, cmd app.Command) (err error) {\n\t// 为什么使用 backgroundCtx 而不是 ctx？\n\t// 因为 ctx 代表调用方的上下文，通常是 rpc 请求上下文。\n\t// 而执行命令的上下文，应该是一个独立的上下文，不应该受到调用方的影响\n\t// 即使由于网络抖动等原因，调用方的上下文已经超时，但是命令执行的上下文仍然应该继续执行。\n\tworkerCtx := context.WithValue(d.backgroundCtx, ctxKeyCommand, cmd)\n\tworkerCtx, cancelFunc := context.WithTimeout(workerCtx, d.workerTimeout)\n\tworkerCtx = logs.GetLogger(ctx).WithContext(workerCtx)\n\tlockKeys := cmd.LockKeys()\n\terrChan := make(chan error, 1)\n\tlockOption := &dlock.Option{\n\t\tRetryStrategy: dlock.ExponentialBackoff(100*time.Millisecond, 6*time.Second),\n\t}\n\td.wg.Add(1)\n\t// 最终打印错误\n\t// TODO: 并发控制最大能同时执行的命令数量\n\tgo func() {\n\t\tdefer d.wg.Done()\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\te, ok := err.(error)\n\t\t\t\tif !ok {\n\t\t\t\t\te = errors.Newf(ErrDispatchPanic, \"dispatcher panic: %v\", err)\n\t\t\t\t}\n\t\t\t\terrChan <- e\n\t\t\t\tlogs.Error(workerCtx).Err(e).Stack().Bytes(\"trace\", debug.Stack()).Msgf(\"command execution panic\")\n\t\t\t}\n\t\t}()\n\n\t\tdefer cancelFunc()\n\n\t\tif lockKeys != nil {\n\t\t\tlock, err := d.locker.ObtainMulti(workerCtx, lockKeys, d.workerTimeout, lockOption)\n\t\t\tif err != nil {\n\t\t\t\terrChan <- err\n\t\t\t\tlogs.Warn(workerCtx).Err(err).Msgf(\"command execution waiting locks timeout\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer lock.Release(workerCtx)\n\t\t}\n\n\t\tuow := app.GetRegistry(ctx).Repositories.UoWFactory.New()\n\t\tworkerCtx = app.GetRegistry(ctx).Repositories.UoWFactory.With(workerCtx, uow)\n\n\t\terr = cmd.Handle(workerCtx)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, errors.ErrDryRunSuccessExit) {\n\t\t\t\terr = nil\n\t\t\t} else {\n\t\t\t\tlogs.Warn(workerCtx).Err(err).Msgf(\"command execution failed\")\n\t\t\t}\n\t\t\t_err := uow.Rollback(workerCtx)\n\t\t\tif _err != nil {\n\t\t\t\tlogs.Error(workerCtx).Err(_err).Msgf(\"unit of work rollback failed\")\n\t\t\t}\n\t\t} else {\n\t\t\terr = uow.Commit(workerCtx)\n\t\t\tif err != nil {\n\t\t\t\tlogs.Error(workerCtx).Err(err).Msgf(\"unit of work commit failed\")\n\t\t\t}\n\t\t}\n\t\terrChan <- err\n\t\tclose(errChan)\n\t}()\n\tselect {\n\tcase err := <-errChan:\n\t\treturn err\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 214,
        "code_end_line": 239,
        "code_key": "StepGivenAPhysicalVol",
        "code_value": "func StepGivenAPhysicalVol(registry *app.Registry, value interface{}) *rdiskDomain.PhysicalVolume {\n\tphysicalVol := &rdiskDomain.PhysicalVolume{\n\t\tEntityMixin:  rdiskDomain.EntityMixin{ID: 1},\n\t\tSerial:       \"12345\",\n\t\tIP:           net.IP{127, 0, 0, 1},\n\t\tBDF:          \"bdf\",\n\t\tDiskID:       0,\n\t\tState:        rdiskDomain.PhysicalVolumeState(value.(int)),\n\t\tSize:         1,\n\t\tVolumeType:   \"NVME\",\n\t\tZoneID:       1,\n\t\tBlockSize:    512,\n\t\tRealSize:     5120,\n\t\tPort:         1,\n\t\tDataNodeType: \"unknown\",\n\t\tCuf:          \"清远-清新-C2\",\n\t}\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\terr := registry.Repositories.PhysicalVolume.Add(workerCtx, physicalVol)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn physicalVol\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 244,
        "code_end_line": 277,
        "code_key": "StepGivenPhysicalVols",
        "code_value": "func StepGivenPhysicalVols(registry *app.Registry, value interface{}, num interface{}) []*rdiskDomain.PhysicalVolume {\n\tvar physicalVols []*rdiskDomain.PhysicalVolume\n\tfor i := 0; i < num.(int); i++ {\n\t\tphysicalVols = append(physicalVols, &rdiskDomain.PhysicalVolume{\n\t\t\tEntityMixin:  rdiskDomain.EntityMixin{},\n\t\t\tSerial:       rdiskDomain.Serial(\"111\" + strconv.Itoa(i)),\n\t\t\tIP:           net.IP{127, 0, byte(((i + 2) / 255) % 255), byte((i + 2) % 255)},\n\t\t\tBDF:          \"bdf\",\n\t\t\tDiskID:       0,\n\t\t\tState:        rdiskDomain.PhysicalVolumeState(value.(int)),\n\t\t\tSize:         1,\n\t\t\tVolumeType:   \"\",\n\t\t\tZoneID:       1,\n\t\t\tBlockSize:    512,\n\t\t\tRealSize:     5120,\n\t\t\tPort:         1,\n\t\t\tDataNodeType: \"\",\n\t\t\tCuf:          \"清远-清新-C2\",\n\t\t})\n\t}\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\tfor _, vol := range physicalVols {\n\t\terr := registry.Repositories.PhysicalVolume.Add(workerCtx, vol)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\terr := uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn physicalVols\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 282,
        "code_end_line": 304,
        "code_key": "StepGivenALogicalVol",
        "code_value": "func StepGivenALogicalVol(registry *app.Registry, physicalVol *rdiskDomain.PhysicalVolume, value interface{}) *rdiskDomain.LogicalVolume {\n\tlogicalVol := &rdiskDomain.LogicalVolume{\n\t\tEntityMixin:     rdiskDomain.EntityMixin{ID: 1},\n\t\tUUID:            uuid.Must(uuid.NewRandom()),\n\t\tState:           rdiskDomain.LogicalVolumeState(value.(int)),\n\t\tSize:            1,\n\t\tAppID:           123,\n\t\tZoneID:          1,\n\t\tDiskType:        \"\",\n\t\tVolumeType:      \"\",\n\t\tFlowControlSpec: rdiskDomain.FlowControlSpec{},\n\t\tPhysicalVolume:  physicalVol,\n\t\tAttachments:     nil,\n\t}\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\terr := registry.Repositories.LogicalVolume.Add(workerCtx, logicalVol)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn logicalVol\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 351,
        "code_end_line": 364,
        "code_key": "StepThenLogicalVolStateShouldBe",
        "code_value": "func StepThenLogicalVolStateShouldBe(logicalVol *rdiskDomain.LogicalVolume, registry *app.Registry, db *gorm.DB, database string, value interface{}) *rdiskDomain.LogicalVolume {\n\tdb.Exec(fmt.Sprintf(\"USE `%s`\", database))\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\tnewLogicalVol, err := registry.Repositories.LogicalVolume.FindByAppIDAndUUID(workerCtx, logicalVol.AppID, logicalVol.UUID)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif newLogicalVol.State != rdiskDomain.LogicalVolumeState(value.(int)) {\n\t\tpanic(\"LogicalVol state error\")\n\t}\n\treturn newLogicalVol\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 433,
        "code_end_line": 449,
        "code_key": "StepThenPhysicalVolShouldBe",
        "code_value": "func StepThenPhysicalVolShouldBe(physicalVol *rdiskDomain.PhysicalVolume, registry *app.Registry, db *gorm.DB, database string, field string, value interface{}) *rdiskDomain.PhysicalVolume {\n\tdb.Exec(fmt.Sprintf(\"USE `%s`\", database))\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\tnewPhysicalVol, err := registry.Repositories.PhysicalVolume.FindBySerial(workerCtx, physicalVol.Serial)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tswitch field {\n\tcase \"cuf\":\n\t\tif newPhysicalVol.Cuf != rdiskDomain.Cuf(value.(string)) {\n\t\t\tpanic(\"Result error\")\n\t\t}\n\t}\n\treturn newPhysicalVol\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 618,
        "code_end_line": 630,
        "code_key": "StepThenPhysicalVolShouldBeRight",
        "code_value": "func StepThenPhysicalVolShouldBeRight(physicalVol *rdiskDomain.PhysicalVolume, registry *app.Registry, t *testing.T) {\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\tnewPhysicalVol, err := registry.Repositories.PhysicalVolume.FindBySerial(workerCtx, physicalVol.Serial)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif physicalVol.BDF != newPhysicalVol.BDF || physicalVol.Cuf != newPhysicalVol.Cuf || rdiskDomain.PVSInited != newPhysicalVol.State || physicalVol.DataNodeType != newPhysicalVol.DataNodeType ||\n\t\t!physicalVol.IP.Equal(newPhysicalVol.IP) || physicalVol.VolumeType != newPhysicalVol.VolumeType || physicalVol.Size != newPhysicalVol.Size {\n\t\tpanic(\"data error\")\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/uow.go",
        "code_start_line": 59,
        "code_end_line": 81,
        "code_key": "Commit",
        "code_value": "func (u *unitOfWork) Commit(ctx context.Context) error {\n\terr := u.trackedPhyVolumes.Update(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = u.trackedLogicalVolumes.Update(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = u.trackedDRGroups.Update(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = u.trackedBackups.Update(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = u.trackedBenchmarks.Update(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn u.tx.Commit().Error\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 417,
        "code_end_line": 470,
        "code_key": "tryObtainMulti",
        "code_value": "func (l *mysqlLocker) tryObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, tokens []string, opts *dlock.Option) ([]string, error) {\n\t// Starts a new transaction.\n\ttx := l.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\n\n\t// Fetch existing locks.\n\texistingReadKeys, existingWriteKeys, expiredKeys, err := l.fetchExistingLocks(tx, keys)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// If there are existing valid locks, return an error.\n\tif len(existingWriteKeys) > 0 {\n\t\t_ = tx.Rollback()\n\t\treturn nil, errors.Wrap(dlock.ErrLockNotHeld, fmt.Sprintf(\"writeKeys %v are already locked\", existingWriteKeys))\n\t}\n\n\t// Delete expired locks if exists.\n\tif err := l.deleteExpiredLocks(tx, expiredKeys); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Remove existing readLocks from insert.\n\t// NOCA:QCloudAkCheck(误报)\n\tlockKeys, err := l.removeExistingReadLocksFromInsert(tx, keys, existingReadKeys)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Insert locks into database.\n\tneedInsertReadKeys, err := l.insertLocks(tx, lockKeys, ttl, tokens)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Update readLocks.\n\tvar needUpdateExpirationReadKeys []string = nil\n\tvar needUpdateCountReadKeys []string = nil\n\tif needUpdateExpirationReadKeys, needUpdateCountReadKeys, tokens, err = l.updateReadLocks(tx, ttl, existingReadKeys, tokens); err != nil {\n\t\tl.rollback(needUpdateCountReadKeys, tokens)\n\t\tl.rollback(needUpdateExpirationReadKeys, tokens)\n\t\tl.rollback(needInsertReadKeys, tokens)\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\tif result := tx.Commit(); result.Error != nil {\n\t\treturn nil, errors.Wrap(result.Error, \"failed to commit transaction\")\n\t}\n\n\treturn tokens, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mem/memdlock.go",
        "code_start_line": 106,
        "code_end_line": 166,
        "code_key": "tryObtainMulti",
        "code_value": "func (l *memLocker) tryObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, token string) (dlock.Lock, error) {\n\tl.mutex.Lock()\n\tdefer l.mutex.Unlock()\n\tvar readLocks []*dlock.LockKey\n\tvar writeLocks []*dlock.LockKey\n\tvar insertLocks []*dlock.LockKey\n\tvar tokens []string\n\ttokens = append(tokens, token)\n\tfor _, key := range keys {\n\t\tif key.Type == dlock.WriteLock {\n\t\t\twriteLocks = append(writeLocks, key)\n\t\t} else {\n\t\t\treadLocks = append(readLocks, key)\n\t\t}\n\t}\n\tfor _, key := range writeLocks {\n\t\tif item, ok := l.data[key.Key]; ok {\n\t\t\tif time.Until(item.ttl) > 0 {\n\t\t\t\treturn nil, dlock.ErrNotObtained\n\t\t\t} else {\n\t\t\t\tinsertLocks = append(insertLocks, key)\n\t\t\t}\n\t\t} else {\n\t\t\tinsertLocks = append(insertLocks, key)\n\t\t}\n\t}\n\tfor _, key := range readLocks {\n\t\tif item, ok := l.data[key.Key]; ok {\n\t\t\tif item.lockType == dlock.ReadLock {\n\t\t\t\tif time.Until(item.ttl) > 0 {\n\t\t\t\t\titem.count++\n\t\t\t\t\titem.ttl = time.Now().Add(ttl)\n\t\t\t\t\ttokens = append(tokens, item.token)\n\t\t\t\t} else {\n\t\t\t\t\tinsertLocks = append(insertLocks, key)\n\t\t\t\t}\n\t\t\t} else if time.Until(item.ttl) > 0 {\n\t\t\t\treturn nil, dlock.ErrNotObtained\n\t\t\t}\n\t\t} else {\n\t\t\tinsertLocks = append(insertLocks, key)\n\t\t}\n\t}\n\n\tfor _, key := range insertLocks {\n\t\tl.data[key.Key] = &lockItem{\n\t\t\tkey:      key.Key,\n\t\t\tttl:      time.Now().Add(ttl),\n\t\t\ttoken:    token,\n\t\t\tlockType: key.Type,\n\t\t\tcount:    1,\n\t\t}\n\t}\n\n\tlock := &memLock{\n\t\tlocker: l,\n\t\tkeys:   keys,\n\t\ttokens: tokens,\n\t}\n\treturn lock, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": []
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go:21:38:FindBySerial": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go",
    "code_start_line": 21,
    "code_end_line": 38,
    "code_start_column": 40,
    "code_key": "FindBySerial",
    "code_value": "func (p *physicalVolumeRepositoryImpl) FindBySerial(ctx context.Context, serial rdiskDomain.Serial) (*rdiskDomain.PhysicalVolume, error) {\n\tuow := getUow(ctx)\n\tvar vol metadb.DmPhydisk\n\tresult := uow.tx.Where(\"serial = ?\", string(serial)).First(&vol)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\t// 覆盖 gorm 的错误\n\t\t\treturn nil, errors.New(rdiskDomain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tpv := fromDmPhyDiskToPhysicalVolume(ctx, &vol)\n\tpv = uow.trackedPhyVolumes.Add(pv)\n\treturn pv, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go",
        "code_start_line": 51,
        "code_end_line": 72,
        "code_key": "Handle",
        "code_value": "func (c *CbsAppIdConsumer) Handle(ctx context.Context, delivery *rabbitmq.Delivery) error {\n\tu, chargeTime, err := c.ParseDelivery(ctx, delivery)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif u == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"USER_INFO_NOT_FOUND\")\n\t\treturn nil\n\t}\n\n\tchargeDetail := c.GetChargeDetailForSingleUser(u, chargeTime)\n\tif chargeDetail == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tUint64(\"appId\", uint64(u.AppId)).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"NO_RESOURCE_TO_CHARGE\")\n\t\treturn nil\n\t}\n\treturn c.ProcessChargeDetail(chargeDetail)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 105,
        "code_end_line": 116,
        "code_key": "Handle",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tif err := c.ensureLocks(ctx); err != nil {\n\t\treturn err\n\t}\n\tif c.lvUUID != nil {\n\t\t// 涉及到逻辑卷时，需要先标记逻辑卷为故障\n\t\treturn c.handleBindedVolume(ctx)\n\t} else {\n\t\t// 不涉及到逻辑卷时，直接标记物理卷为故障\n\t\treturn c.handleIdleVolume(ctx)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/detach_logical_volume.go",
        "code_start_line": 56,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *DetachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDetachLogicalVolume, c)\n\n\t// 如果没有挂载到指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume not attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_benchmark_task.go",
        "code_start_line": 125,
        "code_end_line": 165,
        "code_key": "Handle",
        "code_value": "func (c *CreateBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tvolSm     = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = volSm.Fire(ctx, c.relatedVolume.State, domain.PVEStartBenchmark, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark = benchmark.New(benchmark.DiskInfo{\n\t\tSerial: string(c.relatedVolume.Serial),\n\t\tHostIP: c.relatedVolume.IP,\n\t\tBDF:    string(c.relatedVolume.BDF),\n\t})\n\n\tif err = benchRepo.Add(ctx, c.relatedBenchmark); err != nil {\n\t\tdelegate := &benchmarkDelegate{cmd: c}\n\t\tif _err := delegate.TaskFinishCallback(ctx, c.relatedBenchmark); _err != nil {\n\t\t\tlogs.Warn(ctx).Err(_err).Str(\"serial\", string(c.relatedVolume.Serial)).Msg(\"failed to rollback: create bdev\")\n\t\t}\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventCreateBench,\n\t\tbenchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_logical_volume.go",
        "code_start_line": 71,
        "code_end_line": 108,
        "code_key": "Handle",
        "code_value": "func (d *DeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\td.volume, err = repo.FindByID(ctx, d.UUID)\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif e := d.volume.CheckDelete(); e != nil {\n\t\treturn e\n\t}\n\n\tif d.volume.AppID != d.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"refuse to delet: app id mismatch\")\n\t}\n\n\td.drgroup, err = app.GetRegistry(ctx).Repositories.DRGroup.FindByMember(ctx, d.AppID, d.volume.UUID.String())\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\td.drgroup = nil\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := d.checkDRGroupMatch(ctx); err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, d.volume.State, rdiskDomain.LVEMarkToRecycle, d)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_recycled_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmRecycledPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEConfirmRecycled, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_rdisk_backup.go",
        "code_start_line": 52,
        "code_end_line": 75,
        "code_key": "Handle",
        "code_value": "func (c *DeleteRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tsm   = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\tc.relatedBackup, err = repo.FindByUUID(ctx, c.BackupID.String())\n\tif err != nil || c.relatedBackup == nil || c.relatedBackup.AppID != c.AppID {\n\t\treturn errors.New(backupDomain.ErrBackupNotExist, \"backup not exists\")\n\t}\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tc.relatedBackup.Status,\n\t\tbackupDomain.EventSoftDeleteBackup,\n\t\tbackupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: c.relatedBackup})\n\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_rdisk_backup.go",
        "code_start_line": 47,
        "code_end_line": 80,
        "code_key": "Handle",
        "code_value": "func (c *CreateRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tlvSm  = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\tbakSm = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo  = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t_, err = lvSm.Fire(ctx, c.relatedVolume.State, rdiskDomain.LVEBackupStarted, c)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tlv := c.relatedVolume\n\tbackup := backupDomain.New(\n\t\tlv.AppID,\n\t\tbackupDomain.DiskInfo{\n\t\t\tVolumeUUID: lv.UUID,\n\t\t\tVolumeSize: uint64(lv.Size),\n\t\t\tHostIP:     lv.PhysicalVolume.IP,\n\t\t\tHostBDF:    string(lv.PhysicalVolume.BDF),\n\t\t\tSerial:     string(lv.PhysicalVolume.Serial),\n\t\t},\n\t)\n\tif err := repo.Add(ctx, backup); err != nil {\n\t\treturn err\n\t}\n\tc.relatedBackup = backup\n\t_, err = bakSm.Fire(ctx, backupDomain.StatusInit, backupDomain.EventStartBackup, backupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: backup})\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/attach_logical_volume.go",
        "code_start_line": 49,
        "code_end_line": 71,
        "code_key": "Handle",
        "code_value": "func (c *AttachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEAttachLogicalVolume, c)\n\n\t// 如果已经挂载到了指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeAlreadyAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume already attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_delete_logical_volume.go",
        "code_start_line": 34,
        "code_end_line": 55,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\t// 如果逻辑卷不存在，则直接返回成功\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"failed to confirm delete: app id mismatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDeleteLogicalVolume, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/offline_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OfflinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOfflinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *DeletePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\t// 如果物理卷不存在，则直接幂等返回\n\t\treturn nil\n\t}\n\n\tvar event = domain.PVEDeletePhysicalVolume\n\tif c.Force && (c.relatedVolume.State == domain.PVSDefunct) {\n\t\t// 这里的实现不太好，状态机的逻辑不应该侵入 cmd\n\t\t// 时间太赶了，后续重构优化吧\n\t\tevent = domain.PVEForceDeleteForDefunct\n\t}\n\n\tif c.relatedVolume.HasBindedPV() {\n\t\treturn errors.New(domain.ErrVolumeBusy, \"logic volume has binded to this physical volume\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, event, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_logical_volume.go",
        "code_start_line": 55,
        "code_end_line": 70,
        "code_key": "Handle",
        "code_value": "func (c *CleanupLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVECleanupLogicalVolume, c)\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_init_physical_volume.go",
        "code_start_line": 26,
        "code_end_line": 52,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmInitPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\tif c.relatedVolume.IP.String() != c.Host.String() {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume host ip mistmatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVECreatePhysicalVolumeOnHost, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_physical_volume.go",
        "code_start_line": 51,
        "code_end_line": 101,
        "code_key": "Handle",
        "code_value": "func (c *CreatePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\n\t// 获取物理卷状态机\n\tsm := app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\trepo := app.GetRegistry(ctx).Repositories.PhysicalVolume\n\n\t// 检查物理卷是否已经存在，如果存在则直接幂等返回\n\tvol1, err := repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"serial\", c.Serial).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tvol2, err := repo.FindByIPAndBDF(ctx, c.Host, domain.BDF(c.BDF))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"host\", c.Host.String()).Str(\"bdf\", c.BDF).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tfor _, vol := range []*domain.PhysicalVolume{vol1, vol2} {\n\t\texisted, err := c.checkExisting(ctx, vol)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif existed {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// 触发事件，创建物理卷\n\t_, err = sm.Fire(ctx,\n\t\tdomain.PVSUnInited,\n\t\tdomain.PVECreatePhysicalVolume,\n\t\tc,\n\t)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 创建 Bdev 以及格式化移动到创建物理卷的状态机中\n\n\t// _, err = sm.Fire(ctx,\n\t// \tc.GetPhysicalVolume().State,\n\t// \tdomain.PVECreatePhysicalVolumeOnHost,\n\t// \tc,\n\t// )\n\t// if err != nil {\n\t// \treturn err\n\t// }\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_benchmark_task.go",
        "code_start_line": 32,
        "code_end_line": 57,
        "code_key": "Handle",
        "code_value": "func (c *DeleteBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\terr       error\n\t)\n\n\tbench, err := benchRepo.FindByUUID(ctx, c.BenchmarkUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif bench.DiskInfo.Serial != c.Serial {\n\t\treturn errors.Newf(benchmark.ErrTaskNotFound, \"benchmark serial not match %s, want %s\", c.Serial, bench.DiskInfo.Serial)\n\t}\n\n\t_, err = benchSm.Fire(ctx, bench.Status, benchmark.EventDeleteBench, benchmark.Data{Benchmark: bench, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := benchRepo.Delete(ctx, bench); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_logical_volume.go",
        "code_start_line": 52,
        "code_end_line": 98,
        "code_key": "Handle",
        "code_value": "func (c *CreateLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tpvRepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tlvRepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm     = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\t// 1. 查找底层物理卷\n\tc.selectedPhysicalVolume, err = pvRepo.FindBySerial(ctx, rdiskDomain.Serial(c.PhysicalVolumeSerial))\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// 检查底层物理卷大小是否满足要求\n\tif c.selectedPhysicalVolume.Size < rdiskDomain.Size(c.DiskSize) {\n\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume size %d is smaller than requested size %d\", c.selectedPhysicalVolume.Size, c.DiskSize)\n\t}\n\n\t// 检查底层物理卷性能等级是否满足要求\n\tif c.PerformanceRank != \"\" {\n\t\tif string(c.selectedPhysicalVolume.PerformanceRank) != c.PerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not match requested rank %s\", c.selectedPhysicalVolume.PerformanceRank, c.PerformanceRank)\n\t\t}\n\t} else {\n\t\tif c.selectedPhysicalVolume.PerformanceRank != rdiskDomain.DefaultPerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not default rank %s\", c.selectedPhysicalVolume.PerformanceRank, rdiskDomain.DefaultPerformanceRank)\n\t\t}\n\t}\n\n\t// 2. 创建逻辑卷\n\tvol := rdiskDomain.NewLogicalVolume(users.AppID(c.AppID), rdiskDomain.Size(c.DiskSize), rdiskDomain.ZoneID(c.ZoneID))\n\tif c.VolumeType != \"\" {\n\t\tvol.VolumeType = rdiskDomain.VolumeType(c.VolumeType)\n\t}\n\tif c.DiskType != \"\" {\n\t\tvol.DiskType = rdiskDomain.DiskType(c.DiskType)\n\t}\n\terr = lvRepo.Add(ctx, vol)\n\tif err != nil {\n\t\treturn\n\t}\n\tc.createdLogicalVolume = vol\n\n\t// 3. 触发状态机，联动更新逻辑卷和物理卷状态\n\t_, err = sm.Fire(ctx, rdiskDomain.LVSUnInited, rdiskDomain.LVECreateLogicalVolume, c)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_running_backup_task.go",
        "code_start_line": 31,
        "code_end_line": 61,
        "code_key": "Handle",
        "code_value": "func (c *UpdateRunningBackupTaskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventUpdateBackupProgress,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_drgroup.go",
        "code_start_line": 78,
        "code_end_line": 173,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeDRGroupCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tlvView  = app.GetRegistry(ctx).Viewers.LogicalVolume\n\t\tdrgRepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t\tsm      = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\terr     error\n\t)\n\n\t// 0. 初始化\n\tc.drgroupRef = make(map[string]*drgroup.DRGroup)\n\n\t// 1. 加载所有逻辑卷所在的置放群组\n\tallVolumeUUIDs := make([]string, 0, len(c.UUIDs))\n\tfor _, _uuid := range c.UUIDs {\n\t\tallVolumeUUIDs = append(allVolumeUUIDs, _uuid.String())\n\t}\n\tif groups, err := drgRepo.FindByMembers(ctx, c.AppID, allVolumeUUIDs); err == nil {\n\t\tif err != nil {\n\t\t\tif !errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tfor _, group := range groups {\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t\tc.curDRGroupNames = append(c.curDRGroupNames, group.Name)\n\t\t}\n\t} else {\n\t\treturn err\n\t}\n\n\t// 2. 确认已上锁的置放群组和当前一致\n\tif !c.checkLockedDRGroupNames() {\n\t\treturn errors.New(drgroup.ErrGroupModified, \"drgroup changed\")\n\t}\n\n\t// 3. 加载所有逻辑卷的状态，不需要完整实体，因为不会修改 Volume\n\tc.relatedLogicalVolume, err = lvView.FindByIDs(ctx, c.AppID, c.UUIDs)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(c.relatedLogicalVolume) < len(c.UUIDs) {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t// 4. 加载所有目标置放群组，key 为 name\n\tfor _, spec := range c.Specs {\n\t\tvar group *drgroup.DRGroup\n\t\tif _, ok := c.drgroupRef[spec.Name]; ok {\n\t\t\tgroup = c.drgroupRef[spec.Name]\n\t\t} else {\n\t\t\tgroup, err = c.getOrCreateDRGroup(ctx, drgRepo, spec)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t}\n\n\t\tif spec.Affinity > 0 {\n\t\t\tgroup.Affinity = spec.Affinity\n\t\t}\n\t\tif spec.Type != \"\" {\n\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t}\n\t}\n\n\t// 5. 对所有逻辑卷执行置放群组变更事件，检查状态是否允许，\n\t//    实际的更新还是在这里执行。\n\tfor _, vol := range c.relatedLogicalVolume {\n\t\terr := sm.Check(ctx, vol.State, rdiskDomain.LVEUpdateDrGroup, c)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// 将逻辑卷从原有的置放群组中移除\n\t\tfor _, name := range c.curDRGroupNames {\n\t\t\tc.drgroupRef[name].RemoveMember(vol.UUID.String())\n\t\t}\n\t\t// 将逻辑卷添加到新的置放群组中\n\t\tfor _, spec := range c.Specs {\n\t\t\tsubGroup := spec.SubGroup\n\t\t\tif subGroup == \"\" {\n\t\t\t\t// 如果没有指定子组，则使用远端 SSD UUID 作为子组名称\n\t\t\t\t// 相当于每块盘都是一个子组，相当于没有使用子组功能\n\t\t\t\tsubGroup = vol.UUID.String()\n\t\t\t}\n\t\t\tif err := c.drgroupRef[spec.Name].AddMember(vol.UUID.String(), subGroup, vol.PhysicalVolume.IP.String()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tif c.DryRun {\n\t\treturn errors.New(errors.ErrDryRunSuccessExit, \"dry run check success\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/online_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OnlinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOnlinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_benchmark_task.go",
        "code_start_line": 34,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *UpdateBenchmarkTask) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, rdisk.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark, err = benchRepo.FindByUUID(ctx, c.BenchmarkUUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventUpdateBench, benchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_flow_ctrl.go",
        "code_start_line": 80,
        "code_end_line": 103,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeFlowControlCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not found\")\n\t}\n\n\tspec := c.volume.FlowControlSpec\n\tif !c.UpdateRequest.UpdateSpec(&spec, c.volume.GetDefaultFlowControlSpec()) {\n\t\t// 没有任何更新，直接返回成功\n\t\treturn nil\n\t}\n\tc.volume.SetFlowControlSpec(spec)\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEUpdateFlowControl, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_defunct_volume.go",
        "code_start_line": 46,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *CleanupDefunctCommand) Handle(ctx context.Context) error {\n\tvar err error\n\tc.lv, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar sm = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\tvar event = rdiskDomain.LVECleanupDefunct\n\n\tfor _, attachment := range c.lv.Attachments {\n\t\tlogs.Info(ctx).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).Msg(\"cleanup defuncting volume\")\n\t\tsubCmd := &cleanDefunctSubCommand{Parent: c, HostIP: attachment.IP}\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, subCmd)\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，因为只要有一个挂载点清理失败，其他挂载点还是需要继续清理的\n\t\t\t// 失败的挂载点会在后台继续清理\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).\n\t\t\t\tMsg(\"failed to cleanup defunct volume, retry later.\")\n\t\t}\n\t}\n\n\tif len(c.lv.Attachments) == 0 {\n\t\t// 没有挂载点，直接清理\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, &cleanDefunctSubCommand{Parent: c, HostIP: net.IP{}})\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，后续自动重试即可\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Msg(\"failed to complete cleanup defunct volume\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_drgroup_exists.go",
        "code_start_line": 28,
        "code_end_line": 53,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDRGroupExistsCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t)\n\tfor _, spec := range c.DRGroup {\n\t\t_, err := repo.FindByName(ctx, users.AppID(c.AppID), spec.Name)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\tgroup := drgroup.New(spec.Name, users.AppID(c.AppID))\n\t\t\t\tif spec.Affinity > 0 {\n\t\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t\t}\n\t\t\t\tif spec.Type != \"\" {\n\t\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t\t}\n\t\t\t\terr = repo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_physical_volume.go",
        "code_start_line": 31,
        "code_end_line": 54,
        "code_key": "Handle",
        "code_value": "func (c *UpdatePhyRDiskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEUpdatePhysicalVolume, c)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/recycle_backup_data.go",
        "code_start_line": 32,
        "code_end_line": 62,
        "code_key": "Handle",
        "code_value": "func (c *RecycleBackupDataCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventDeleteBackup,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 118,
        "code_end_line": 141,
        "code_key": "handleIdleVolume",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) handleIdleVolume(ctx context.Context) error {\n\tphysicalVolume, err := app.GetRegistry(ctx).Repositories.PhysicalVolume.FindBySerial(ctx, c.Serial)\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.pv = physicalVolume\n\tif err := c.checkPhysicalVolume(ctx); err != nil {\n\t\treturn err\n\t}\n\n\tlogs.Warn(ctx).\n\t\tStringer(\"serial\", c.Serial).\n\t\tMsg(\"defunct idle volume\")\n\n\tif _, err := app.GetRegistry(ctx).StateMachines.PhysicalVolume.Fire(ctx, physicalVolume.State,\n\t\trdiskDomain.PVEMarkDefunct, c); err != nil {\n\t\tlogs.Error(ctx).Err(err).\n\t\t\tStringer(\"serial\", c.Serial).\n\t\t\tMsg(\"failed to mark physical volume as defunct\")\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 433,
        "code_end_line": 449,
        "code_key": "StepThenPhysicalVolShouldBe",
        "code_value": "func StepThenPhysicalVolShouldBe(physicalVol *rdiskDomain.PhysicalVolume, registry *app.Registry, db *gorm.DB, database string, field string, value interface{}) *rdiskDomain.PhysicalVolume {\n\tdb.Exec(fmt.Sprintf(\"USE `%s`\", database))\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\tnewPhysicalVol, err := registry.Repositories.PhysicalVolume.FindBySerial(workerCtx, physicalVol.Serial)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tswitch field {\n\tcase \"cuf\":\n\t\tif newPhysicalVol.Cuf != rdiskDomain.Cuf(value.(string)) {\n\t\t\tpanic(\"Result error\")\n\t\t}\n\t}\n\treturn newPhysicalVol\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/tests/steps/rdisk_master_steps.go",
        "code_start_line": 618,
        "code_end_line": 630,
        "code_key": "StepThenPhysicalVolShouldBeRight",
        "code_value": "func StepThenPhysicalVolShouldBeRight(physicalVol *rdiskDomain.PhysicalVolume, registry *app.Registry, t *testing.T) {\n\tuow := registry.Repositories.UoWFactory.New()\n\tworkerCtx := registry.Repositories.UoWFactory.With(context.Background(), uow)\n\tnewPhysicalVol, err := registry.Repositories.PhysicalVolume.FindBySerial(workerCtx, physicalVol.Serial)\n\terr = uow.Commit(workerCtx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif physicalVol.BDF != newPhysicalVol.BDF || physicalVol.Cuf != newPhysicalVol.Cuf || rdiskDomain.PVSInited != newPhysicalVol.State || physicalVol.DataNodeType != newPhysicalVol.DataNodeType ||\n\t\t!physicalVol.IP.Equal(newPhysicalVol.IP) || physicalVol.VolumeType != newPhysicalVol.VolumeType || physicalVol.Size != newPhysicalVol.Size {\n\t\tpanic(\"data error\")\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 65,
        "code_end_line": 82,
        "code_key": "DmPhydisk",
        "code_value": "type DmPhydisk struct {\n\tID         uint64    `gorm:\"column:id;primaryKey\"`\n\tSerial     string    `gorm:\"column:serial;unique\"`\n\tIP         string    `gorm:\"column:host_ip\"`\n\tBDF        string    `gorm:\"column:bdf\"`\n\tDiskID     uint64    `gorm:\"column:disk_id\"`\n\tPort       int       `gorm:\"column:port\"`\n\tStatus     int       `gorm:\"column:status\"`\n\tSize       uint32    `gorm:\"column:size\"`\n\tRealSize   int64     `gorm:\"column:real_size\"`\n\tBlockSize  int       `gorm:\"column:block_size\"`\n\tZoneID     uint64    `gorm:\"column:zone_id\"`\n\tVolumeType string    `gorm:\"column:volume_type\"`\n\tExtra      string    `gorm:\"column:extra\"`\n\tCreated    time.Time `gorm:\"column:created\"`\n\tUpdated    time.Time `gorm:\"column:updated\"`\n\tPerfRank   string    `gorm:\"column:perf_rank\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 85,
        "code_end_line": 87,
        "code_key": "TableName",
        "code_value": "func (d *DmPhydisk) TableName() string {\n\treturn \"dm_phydisk\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 90,
        "code_end_line": 92,
        "code_key": "DBName",
        "code_value": "func (d *DmPhydisk) DBName() string {\n\treturn \"metadb\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 57,
        "code_end_line": 75,
        "code_key": "DmPhydisk",
        "code_value": "type DmPhydisk struct {\n\tID              uint64    `gorm:\"column:id;primaryKey\"`\n\tSerial          string    `gorm:\"column:serial;unique\"`\n\tIP              string    `gorm:\"column:host_ip\"`\n\tBDF             string    `gorm:\"column:bdf\"`\n\tDiskID          uint64    `gorm:\"column:disk_id\"`\n\tPort            int       `gorm:\"column:port\"`\n\tStatus          int       `gorm:\"column:status\"`\n\tSize            int64     `gorm:\"column:size\"`\n\tRealSize        int64     `gorm:\"column:real_size\"`\n\tBlockSize       int       `gorm:\"column:block_size\"`\n\tZoneID          int64     `gorm:\"column:zone_id\"`\n\tVolumeType      string    `gorm:\"column:volume_type\"`\n\tExtra           string    `gorm:\"column:extra\"`\n\tNodeType        string    `gorm:\"column:node_type\"`\n\tCreated         time.Time `gorm:\"column:created\"`\n\tUpdated         time.Time `gorm:\"column:updated\"`\n\tPerformanceRank string    `gorm:\"column:perf_rank\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 77,
        "code_end_line": 79,
        "code_key": "TableName",
        "code_value": "func (DmPhydisk) TableName() string {\n\treturn \"dm_phydisk\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go:40:57:FindByIPAndBDF": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go",
    "code_start_line": 40,
    "code_end_line": 57,
    "code_start_column": 40,
    "code_key": "FindByIPAndBDF",
    "code_value": "func (p *physicalVolumeRepositoryImpl) FindByIPAndBDF(ctx context.Context, ip net.IP, bdf rdiskDomain.BDF) (*rdiskDomain.PhysicalVolume, error) {\n\tuow := getUow(ctx)\n\tvar vol metadb.DmPhydisk\n\tresult := uow.tx.Where(\"host_ip = ? AND bdf = ?\", ip.String(), string(bdf)).Find(&vol)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\t// 覆盖 gorm 的错误\n\t\t\treturn nil, errors.New(rdiskDomain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tpv := fromDmPhyDiskToPhysicalVolume(ctx, &vol)\n\tpv = uow.trackedPhyVolumes.Add(pv)\n\treturn pv, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go",
        "code_start_line": 51,
        "code_end_line": 72,
        "code_key": "Handle",
        "code_value": "func (c *CbsAppIdConsumer) Handle(ctx context.Context, delivery *rabbitmq.Delivery) error {\n\tu, chargeTime, err := c.ParseDelivery(ctx, delivery)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif u == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"USER_INFO_NOT_FOUND\")\n\t\treturn nil\n\t}\n\n\tchargeDetail := c.GetChargeDetailForSingleUser(u, chargeTime)\n\tif chargeDetail == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tUint64(\"appId\", uint64(u.AppId)).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"NO_RESOURCE_TO_CHARGE\")\n\t\treturn nil\n\t}\n\treturn c.ProcessChargeDetail(chargeDetail)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 105,
        "code_end_line": 116,
        "code_key": "Handle",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tif err := c.ensureLocks(ctx); err != nil {\n\t\treturn err\n\t}\n\tif c.lvUUID != nil {\n\t\t// 涉及到逻辑卷时，需要先标记逻辑卷为故障\n\t\treturn c.handleBindedVolume(ctx)\n\t} else {\n\t\t// 不涉及到逻辑卷时，直接标记物理卷为故障\n\t\treturn c.handleIdleVolume(ctx)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/detach_logical_volume.go",
        "code_start_line": 56,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *DetachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDetachLogicalVolume, c)\n\n\t// 如果没有挂载到指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume not attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_benchmark_task.go",
        "code_start_line": 125,
        "code_end_line": 165,
        "code_key": "Handle",
        "code_value": "func (c *CreateBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tvolSm     = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = volSm.Fire(ctx, c.relatedVolume.State, domain.PVEStartBenchmark, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark = benchmark.New(benchmark.DiskInfo{\n\t\tSerial: string(c.relatedVolume.Serial),\n\t\tHostIP: c.relatedVolume.IP,\n\t\tBDF:    string(c.relatedVolume.BDF),\n\t})\n\n\tif err = benchRepo.Add(ctx, c.relatedBenchmark); err != nil {\n\t\tdelegate := &benchmarkDelegate{cmd: c}\n\t\tif _err := delegate.TaskFinishCallback(ctx, c.relatedBenchmark); _err != nil {\n\t\t\tlogs.Warn(ctx).Err(_err).Str(\"serial\", string(c.relatedVolume.Serial)).Msg(\"failed to rollback: create bdev\")\n\t\t}\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventCreateBench,\n\t\tbenchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_logical_volume.go",
        "code_start_line": 71,
        "code_end_line": 108,
        "code_key": "Handle",
        "code_value": "func (d *DeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\td.volume, err = repo.FindByID(ctx, d.UUID)\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif e := d.volume.CheckDelete(); e != nil {\n\t\treturn e\n\t}\n\n\tif d.volume.AppID != d.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"refuse to delet: app id mismatch\")\n\t}\n\n\td.drgroup, err = app.GetRegistry(ctx).Repositories.DRGroup.FindByMember(ctx, d.AppID, d.volume.UUID.String())\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\td.drgroup = nil\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := d.checkDRGroupMatch(ctx); err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, d.volume.State, rdiskDomain.LVEMarkToRecycle, d)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_recycled_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmRecycledPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEConfirmRecycled, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_rdisk_backup.go",
        "code_start_line": 52,
        "code_end_line": 75,
        "code_key": "Handle",
        "code_value": "func (c *DeleteRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tsm   = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\tc.relatedBackup, err = repo.FindByUUID(ctx, c.BackupID.String())\n\tif err != nil || c.relatedBackup == nil || c.relatedBackup.AppID != c.AppID {\n\t\treturn errors.New(backupDomain.ErrBackupNotExist, \"backup not exists\")\n\t}\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tc.relatedBackup.Status,\n\t\tbackupDomain.EventSoftDeleteBackup,\n\t\tbackupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: c.relatedBackup})\n\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_rdisk_backup.go",
        "code_start_line": 47,
        "code_end_line": 80,
        "code_key": "Handle",
        "code_value": "func (c *CreateRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tlvSm  = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\tbakSm = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo  = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t_, err = lvSm.Fire(ctx, c.relatedVolume.State, rdiskDomain.LVEBackupStarted, c)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tlv := c.relatedVolume\n\tbackup := backupDomain.New(\n\t\tlv.AppID,\n\t\tbackupDomain.DiskInfo{\n\t\t\tVolumeUUID: lv.UUID,\n\t\t\tVolumeSize: uint64(lv.Size),\n\t\t\tHostIP:     lv.PhysicalVolume.IP,\n\t\t\tHostBDF:    string(lv.PhysicalVolume.BDF),\n\t\t\tSerial:     string(lv.PhysicalVolume.Serial),\n\t\t},\n\t)\n\tif err := repo.Add(ctx, backup); err != nil {\n\t\treturn err\n\t}\n\tc.relatedBackup = backup\n\t_, err = bakSm.Fire(ctx, backupDomain.StatusInit, backupDomain.EventStartBackup, backupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: backup})\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/attach_logical_volume.go",
        "code_start_line": 49,
        "code_end_line": 71,
        "code_key": "Handle",
        "code_value": "func (c *AttachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEAttachLogicalVolume, c)\n\n\t// 如果已经挂载到了指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeAlreadyAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume already attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_delete_logical_volume.go",
        "code_start_line": 34,
        "code_end_line": 55,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\t// 如果逻辑卷不存在，则直接返回成功\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"failed to confirm delete: app id mismatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDeleteLogicalVolume, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/offline_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OfflinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOfflinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *DeletePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\t// 如果物理卷不存在，则直接幂等返回\n\t\treturn nil\n\t}\n\n\tvar event = domain.PVEDeletePhysicalVolume\n\tif c.Force && (c.relatedVolume.State == domain.PVSDefunct) {\n\t\t// 这里的实现不太好，状态机的逻辑不应该侵入 cmd\n\t\t// 时间太赶了，后续重构优化吧\n\t\tevent = domain.PVEForceDeleteForDefunct\n\t}\n\n\tif c.relatedVolume.HasBindedPV() {\n\t\treturn errors.New(domain.ErrVolumeBusy, \"logic volume has binded to this physical volume\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, event, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_logical_volume.go",
        "code_start_line": 55,
        "code_end_line": 70,
        "code_key": "Handle",
        "code_value": "func (c *CleanupLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVECleanupLogicalVolume, c)\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_init_physical_volume.go",
        "code_start_line": 26,
        "code_end_line": 52,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmInitPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\tif c.relatedVolume.IP.String() != c.Host.String() {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume host ip mistmatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVECreatePhysicalVolumeOnHost, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_physical_volume.go",
        "code_start_line": 51,
        "code_end_line": 101,
        "code_key": "Handle",
        "code_value": "func (c *CreatePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\n\t// 获取物理卷状态机\n\tsm := app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\trepo := app.GetRegistry(ctx).Repositories.PhysicalVolume\n\n\t// 检查物理卷是否已经存在，如果存在则直接幂等返回\n\tvol1, err := repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"serial\", c.Serial).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tvol2, err := repo.FindByIPAndBDF(ctx, c.Host, domain.BDF(c.BDF))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"host\", c.Host.String()).Str(\"bdf\", c.BDF).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tfor _, vol := range []*domain.PhysicalVolume{vol1, vol2} {\n\t\texisted, err := c.checkExisting(ctx, vol)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif existed {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// 触发事件，创建物理卷\n\t_, err = sm.Fire(ctx,\n\t\tdomain.PVSUnInited,\n\t\tdomain.PVECreatePhysicalVolume,\n\t\tc,\n\t)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 创建 Bdev 以及格式化移动到创建物理卷的状态机中\n\n\t// _, err = sm.Fire(ctx,\n\t// \tc.GetPhysicalVolume().State,\n\t// \tdomain.PVECreatePhysicalVolumeOnHost,\n\t// \tc,\n\t// )\n\t// if err != nil {\n\t// \treturn err\n\t// }\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_benchmark_task.go",
        "code_start_line": 32,
        "code_end_line": 57,
        "code_key": "Handle",
        "code_value": "func (c *DeleteBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\terr       error\n\t)\n\n\tbench, err := benchRepo.FindByUUID(ctx, c.BenchmarkUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif bench.DiskInfo.Serial != c.Serial {\n\t\treturn errors.Newf(benchmark.ErrTaskNotFound, \"benchmark serial not match %s, want %s\", c.Serial, bench.DiskInfo.Serial)\n\t}\n\n\t_, err = benchSm.Fire(ctx, bench.Status, benchmark.EventDeleteBench, benchmark.Data{Benchmark: bench, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := benchRepo.Delete(ctx, bench); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_logical_volume.go",
        "code_start_line": 52,
        "code_end_line": 98,
        "code_key": "Handle",
        "code_value": "func (c *CreateLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tpvRepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tlvRepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm     = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\t// 1. 查找底层物理卷\n\tc.selectedPhysicalVolume, err = pvRepo.FindBySerial(ctx, rdiskDomain.Serial(c.PhysicalVolumeSerial))\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// 检查底层物理卷大小是否满足要求\n\tif c.selectedPhysicalVolume.Size < rdiskDomain.Size(c.DiskSize) {\n\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume size %d is smaller than requested size %d\", c.selectedPhysicalVolume.Size, c.DiskSize)\n\t}\n\n\t// 检查底层物理卷性能等级是否满足要求\n\tif c.PerformanceRank != \"\" {\n\t\tif string(c.selectedPhysicalVolume.PerformanceRank) != c.PerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not match requested rank %s\", c.selectedPhysicalVolume.PerformanceRank, c.PerformanceRank)\n\t\t}\n\t} else {\n\t\tif c.selectedPhysicalVolume.PerformanceRank != rdiskDomain.DefaultPerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not default rank %s\", c.selectedPhysicalVolume.PerformanceRank, rdiskDomain.DefaultPerformanceRank)\n\t\t}\n\t}\n\n\t// 2. 创建逻辑卷\n\tvol := rdiskDomain.NewLogicalVolume(users.AppID(c.AppID), rdiskDomain.Size(c.DiskSize), rdiskDomain.ZoneID(c.ZoneID))\n\tif c.VolumeType != \"\" {\n\t\tvol.VolumeType = rdiskDomain.VolumeType(c.VolumeType)\n\t}\n\tif c.DiskType != \"\" {\n\t\tvol.DiskType = rdiskDomain.DiskType(c.DiskType)\n\t}\n\terr = lvRepo.Add(ctx, vol)\n\tif err != nil {\n\t\treturn\n\t}\n\tc.createdLogicalVolume = vol\n\n\t// 3. 触发状态机，联动更新逻辑卷和物理卷状态\n\t_, err = sm.Fire(ctx, rdiskDomain.LVSUnInited, rdiskDomain.LVECreateLogicalVolume, c)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_running_backup_task.go",
        "code_start_line": 31,
        "code_end_line": 61,
        "code_key": "Handle",
        "code_value": "func (c *UpdateRunningBackupTaskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventUpdateBackupProgress,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_drgroup.go",
        "code_start_line": 78,
        "code_end_line": 173,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeDRGroupCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tlvView  = app.GetRegistry(ctx).Viewers.LogicalVolume\n\t\tdrgRepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t\tsm      = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\terr     error\n\t)\n\n\t// 0. 初始化\n\tc.drgroupRef = make(map[string]*drgroup.DRGroup)\n\n\t// 1. 加载所有逻辑卷所在的置放群组\n\tallVolumeUUIDs := make([]string, 0, len(c.UUIDs))\n\tfor _, _uuid := range c.UUIDs {\n\t\tallVolumeUUIDs = append(allVolumeUUIDs, _uuid.String())\n\t}\n\tif groups, err := drgRepo.FindByMembers(ctx, c.AppID, allVolumeUUIDs); err == nil {\n\t\tif err != nil {\n\t\t\tif !errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tfor _, group := range groups {\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t\tc.curDRGroupNames = append(c.curDRGroupNames, group.Name)\n\t\t}\n\t} else {\n\t\treturn err\n\t}\n\n\t// 2. 确认已上锁的置放群组和当前一致\n\tif !c.checkLockedDRGroupNames() {\n\t\treturn errors.New(drgroup.ErrGroupModified, \"drgroup changed\")\n\t}\n\n\t// 3. 加载所有逻辑卷的状态，不需要完整实体，因为不会修改 Volume\n\tc.relatedLogicalVolume, err = lvView.FindByIDs(ctx, c.AppID, c.UUIDs)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(c.relatedLogicalVolume) < len(c.UUIDs) {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t// 4. 加载所有目标置放群组，key 为 name\n\tfor _, spec := range c.Specs {\n\t\tvar group *drgroup.DRGroup\n\t\tif _, ok := c.drgroupRef[spec.Name]; ok {\n\t\t\tgroup = c.drgroupRef[spec.Name]\n\t\t} else {\n\t\t\tgroup, err = c.getOrCreateDRGroup(ctx, drgRepo, spec)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t}\n\n\t\tif spec.Affinity > 0 {\n\t\t\tgroup.Affinity = spec.Affinity\n\t\t}\n\t\tif spec.Type != \"\" {\n\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t}\n\t}\n\n\t// 5. 对所有逻辑卷执行置放群组变更事件，检查状态是否允许，\n\t//    实际的更新还是在这里执行。\n\tfor _, vol := range c.relatedLogicalVolume {\n\t\terr := sm.Check(ctx, vol.State, rdiskDomain.LVEUpdateDrGroup, c)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// 将逻辑卷从原有的置放群组中移除\n\t\tfor _, name := range c.curDRGroupNames {\n\t\t\tc.drgroupRef[name].RemoveMember(vol.UUID.String())\n\t\t}\n\t\t// 将逻辑卷添加到新的置放群组中\n\t\tfor _, spec := range c.Specs {\n\t\t\tsubGroup := spec.SubGroup\n\t\t\tif subGroup == \"\" {\n\t\t\t\t// 如果没有指定子组，则使用远端 SSD UUID 作为子组名称\n\t\t\t\t// 相当于每块盘都是一个子组，相当于没有使用子组功能\n\t\t\t\tsubGroup = vol.UUID.String()\n\t\t\t}\n\t\t\tif err := c.drgroupRef[spec.Name].AddMember(vol.UUID.String(), subGroup, vol.PhysicalVolume.IP.String()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tif c.DryRun {\n\t\treturn errors.New(errors.ErrDryRunSuccessExit, \"dry run check success\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/online_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OnlinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOnlinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_benchmark_task.go",
        "code_start_line": 34,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *UpdateBenchmarkTask) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, rdisk.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark, err = benchRepo.FindByUUID(ctx, c.BenchmarkUUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventUpdateBench, benchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_flow_ctrl.go",
        "code_start_line": 80,
        "code_end_line": 103,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeFlowControlCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not found\")\n\t}\n\n\tspec := c.volume.FlowControlSpec\n\tif !c.UpdateRequest.UpdateSpec(&spec, c.volume.GetDefaultFlowControlSpec()) {\n\t\t// 没有任何更新，直接返回成功\n\t\treturn nil\n\t}\n\tc.volume.SetFlowControlSpec(spec)\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEUpdateFlowControl, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_defunct_volume.go",
        "code_start_line": 46,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *CleanupDefunctCommand) Handle(ctx context.Context) error {\n\tvar err error\n\tc.lv, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar sm = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\tvar event = rdiskDomain.LVECleanupDefunct\n\n\tfor _, attachment := range c.lv.Attachments {\n\t\tlogs.Info(ctx).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).Msg(\"cleanup defuncting volume\")\n\t\tsubCmd := &cleanDefunctSubCommand{Parent: c, HostIP: attachment.IP}\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, subCmd)\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，因为只要有一个挂载点清理失败，其他挂载点还是需要继续清理的\n\t\t\t// 失败的挂载点会在后台继续清理\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).\n\t\t\t\tMsg(\"failed to cleanup defunct volume, retry later.\")\n\t\t}\n\t}\n\n\tif len(c.lv.Attachments) == 0 {\n\t\t// 没有挂载点，直接清理\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, &cleanDefunctSubCommand{Parent: c, HostIP: net.IP{}})\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，后续自动重试即可\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Msg(\"failed to complete cleanup defunct volume\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_drgroup_exists.go",
        "code_start_line": 28,
        "code_end_line": 53,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDRGroupExistsCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t)\n\tfor _, spec := range c.DRGroup {\n\t\t_, err := repo.FindByName(ctx, users.AppID(c.AppID), spec.Name)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\tgroup := drgroup.New(spec.Name, users.AppID(c.AppID))\n\t\t\t\tif spec.Affinity > 0 {\n\t\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t\t}\n\t\t\t\tif spec.Type != \"\" {\n\t\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t\t}\n\t\t\t\terr = repo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_physical_volume.go",
        "code_start_line": 31,
        "code_end_line": 54,
        "code_key": "Handle",
        "code_value": "func (c *UpdatePhyRDiskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEUpdatePhysicalVolume, c)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/recycle_backup_data.go",
        "code_start_line": 32,
        "code_end_line": 62,
        "code_key": "Handle",
        "code_value": "func (c *RecycleBackupDataCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventDeleteBackup,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 65,
        "code_end_line": 82,
        "code_key": "DmPhydisk",
        "code_value": "type DmPhydisk struct {\n\tID         uint64    `gorm:\"column:id;primaryKey\"`\n\tSerial     string    `gorm:\"column:serial;unique\"`\n\tIP         string    `gorm:\"column:host_ip\"`\n\tBDF        string    `gorm:\"column:bdf\"`\n\tDiskID     uint64    `gorm:\"column:disk_id\"`\n\tPort       int       `gorm:\"column:port\"`\n\tStatus     int       `gorm:\"column:status\"`\n\tSize       uint32    `gorm:\"column:size\"`\n\tRealSize   int64     `gorm:\"column:real_size\"`\n\tBlockSize  int       `gorm:\"column:block_size\"`\n\tZoneID     uint64    `gorm:\"column:zone_id\"`\n\tVolumeType string    `gorm:\"column:volume_type\"`\n\tExtra      string    `gorm:\"column:extra\"`\n\tCreated    time.Time `gorm:\"column:created\"`\n\tUpdated    time.Time `gorm:\"column:updated\"`\n\tPerfRank   string    `gorm:\"column:perf_rank\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 85,
        "code_end_line": 87,
        "code_key": "TableName",
        "code_value": "func (d *DmPhydisk) TableName() string {\n\treturn \"dm_phydisk\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 90,
        "code_end_line": 92,
        "code_key": "DBName",
        "code_value": "func (d *DmPhydisk) DBName() string {\n\treturn \"metadb\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 57,
        "code_end_line": 75,
        "code_key": "DmPhydisk",
        "code_value": "type DmPhydisk struct {\n\tID              uint64    `gorm:\"column:id;primaryKey\"`\n\tSerial          string    `gorm:\"column:serial;unique\"`\n\tIP              string    `gorm:\"column:host_ip\"`\n\tBDF             string    `gorm:\"column:bdf\"`\n\tDiskID          uint64    `gorm:\"column:disk_id\"`\n\tPort            int       `gorm:\"column:port\"`\n\tStatus          int       `gorm:\"column:status\"`\n\tSize            int64     `gorm:\"column:size\"`\n\tRealSize        int64     `gorm:\"column:real_size\"`\n\tBlockSize       int       `gorm:\"column:block_size\"`\n\tZoneID          int64     `gorm:\"column:zone_id\"`\n\tVolumeType      string    `gorm:\"column:volume_type\"`\n\tExtra           string    `gorm:\"column:extra\"`\n\tNodeType        string    `gorm:\"column:node_type\"`\n\tCreated         time.Time `gorm:\"column:created\"`\n\tUpdated         time.Time `gorm:\"column:updated\"`\n\tPerformanceRank string    `gorm:\"column:perf_rank\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 77,
        "code_end_line": 79,
        "code_key": "TableName",
        "code_value": "func (DmPhydisk) TableName() string {\n\treturn \"dm_phydisk\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go:150:191:updatePhysicalVolume": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/phy_disk.go",
    "code_start_line": 150,
    "code_end_line": 191,
    "code_start_column": 6,
    "code_key": "updatePhysicalVolume",
    "code_value": "func updatePhysicalVolume(ctx context.Context, item, originalState *rdiskDomain.PhysicalVolume) error {\n\tuow := getUow(ctx)\n\tcurDO := fromPhysicalVolumeToDmPhyDisk(ctx, item)\n\toriginalDO := fromPhysicalVolumeToDmPhyDisk(ctx, originalState)\n\tchanges := make(map[string]interface{})\n\n\tcheckChange := func(field string, cur interface{}, original interface{}) {\n\t\tif cur != original {\n\t\t\tchanges[field] = cur\n\t\t}\n\t}\n\n\tcheckChange(\"serial\", curDO.Serial, originalDO.Serial)\n\tcheckChange(\"host_ip\", curDO.IP, originalDO.IP)\n\tcheckChange(\"bdf\", curDO.BDF, originalDO.BDF)\n\tcheckChange(\"disk_id\", curDO.DiskID, originalDO.DiskID)\n\tcheckChange(\"port\", curDO.Port, originalDO.Port)\n\tcheckChange(\"status\", curDO.Status, originalDO.Status)\n\tcheckChange(\"size\", curDO.Size, originalDO.Size)\n\tcheckChange(\"real_size\", curDO.RealSize, originalDO.RealSize)\n\tcheckChange(\"block_size\", curDO.BlockSize, originalDO.BlockSize)\n\tcheckChange(\"zone_id\", curDO.ZoneID, originalDO.ZoneID)\n\tcheckChange(\"volume_type\", curDO.VolumeType, originalDO.VolumeType)\n\tcheckChange(\"node_type\", curDO.NodeType, originalDO.NodeType)\n\tcheckChange(\"extra\", curDO.Extra, originalDO.Extra)\n\tcheckChange(\"perf_rank\", curDO.PerformanceRank, originalDO.PerformanceRank)\n\n\tif len(changes) == 0 {\n\t\treturn nil\n\t}\n\n\tchanges[\"updated\"] = uow.tx.NowFunc()\n\n\tresult := uow.tx.Model(curDO).Where(\"id = ?\", curDO.ID).Updates(changes)\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\tlogs.Warn(ctx).Any(\"changes\", changes).Uint64(\"pid\", curDO.ID).Msg(\"no rows affected when updating physical volume\")\n\t}\n\treturn nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/model.go",
        "code_start_line": 10,
        "code_end_line": 12,
        "code_key": "Model",
        "code_value": "type Model struct {\n\tId ID `json:\"id\" gorm:\"primaryKey;autoIncrement;comment:主键\"`\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/drgroup.go:75:90:FindByName": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/drgroup.go",
    "code_start_line": 75,
    "code_end_line": 90,
    "code_start_column": 29,
    "code_key": "FindByName",
    "code_value": "func (d *drgroupViewerImpl) FindByName(ctx context.Context, appId users.AppID, name string) (*drgroup.View, error) {\n\tvar (\n\t\tresultView drgroup.View\n\t\tdataObject metadb.DmDrgroup\n\t)\n\n\tresult := d.db.WithContext(ctx).First(&dataObject, \"app_id = ? and name = ?\", appId, name)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"group not exist\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\td.translate(&dataObject, &resultView)\n\treturn &resultView, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go",
        "code_start_line": 51,
        "code_end_line": 72,
        "code_key": "Handle",
        "code_value": "func (c *CbsAppIdConsumer) Handle(ctx context.Context, delivery *rabbitmq.Delivery) error {\n\tu, chargeTime, err := c.ParseDelivery(ctx, delivery)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif u == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"USER_INFO_NOT_FOUND\")\n\t\treturn nil\n\t}\n\n\tchargeDetail := c.GetChargeDetailForSingleUser(u, chargeTime)\n\tif chargeDetail == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tUint64(\"appId\", uint64(u.AppId)).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"NO_RESOURCE_TO_CHARGE\")\n\t\treturn nil\n\t}\n\treturn c.ProcessChargeDetail(chargeDetail)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 105,
        "code_end_line": 116,
        "code_key": "Handle",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tif err := c.ensureLocks(ctx); err != nil {\n\t\treturn err\n\t}\n\tif c.lvUUID != nil {\n\t\t// 涉及到逻辑卷时，需要先标记逻辑卷为故障\n\t\treturn c.handleBindedVolume(ctx)\n\t} else {\n\t\t// 不涉及到逻辑卷时，直接标记物理卷为故障\n\t\treturn c.handleIdleVolume(ctx)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/detach_logical_volume.go",
        "code_start_line": 56,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *DetachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDetachLogicalVolume, c)\n\n\t// 如果没有挂载到指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume not attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_benchmark_task.go",
        "code_start_line": 125,
        "code_end_line": 165,
        "code_key": "Handle",
        "code_value": "func (c *CreateBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tvolSm     = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = volSm.Fire(ctx, c.relatedVolume.State, domain.PVEStartBenchmark, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark = benchmark.New(benchmark.DiskInfo{\n\t\tSerial: string(c.relatedVolume.Serial),\n\t\tHostIP: c.relatedVolume.IP,\n\t\tBDF:    string(c.relatedVolume.BDF),\n\t})\n\n\tif err = benchRepo.Add(ctx, c.relatedBenchmark); err != nil {\n\t\tdelegate := &benchmarkDelegate{cmd: c}\n\t\tif _err := delegate.TaskFinishCallback(ctx, c.relatedBenchmark); _err != nil {\n\t\t\tlogs.Warn(ctx).Err(_err).Str(\"serial\", string(c.relatedVolume.Serial)).Msg(\"failed to rollback: create bdev\")\n\t\t}\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventCreateBench,\n\t\tbenchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_logical_volume.go",
        "code_start_line": 71,
        "code_end_line": 108,
        "code_key": "Handle",
        "code_value": "func (d *DeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\td.volume, err = repo.FindByID(ctx, d.UUID)\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif e := d.volume.CheckDelete(); e != nil {\n\t\treturn e\n\t}\n\n\tif d.volume.AppID != d.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"refuse to delet: app id mismatch\")\n\t}\n\n\td.drgroup, err = app.GetRegistry(ctx).Repositories.DRGroup.FindByMember(ctx, d.AppID, d.volume.UUID.String())\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\td.drgroup = nil\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := d.checkDRGroupMatch(ctx); err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, d.volume.State, rdiskDomain.LVEMarkToRecycle, d)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_recycled_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmRecycledPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEConfirmRecycled, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_rdisk_backup.go",
        "code_start_line": 52,
        "code_end_line": 75,
        "code_key": "Handle",
        "code_value": "func (c *DeleteRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tsm   = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\tc.relatedBackup, err = repo.FindByUUID(ctx, c.BackupID.String())\n\tif err != nil || c.relatedBackup == nil || c.relatedBackup.AppID != c.AppID {\n\t\treturn errors.New(backupDomain.ErrBackupNotExist, \"backup not exists\")\n\t}\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tc.relatedBackup.Status,\n\t\tbackupDomain.EventSoftDeleteBackup,\n\t\tbackupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: c.relatedBackup})\n\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_rdisk_backup.go",
        "code_start_line": 47,
        "code_end_line": 80,
        "code_key": "Handle",
        "code_value": "func (c *CreateRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tlvSm  = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\tbakSm = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo  = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t_, err = lvSm.Fire(ctx, c.relatedVolume.State, rdiskDomain.LVEBackupStarted, c)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tlv := c.relatedVolume\n\tbackup := backupDomain.New(\n\t\tlv.AppID,\n\t\tbackupDomain.DiskInfo{\n\t\t\tVolumeUUID: lv.UUID,\n\t\t\tVolumeSize: uint64(lv.Size),\n\t\t\tHostIP:     lv.PhysicalVolume.IP,\n\t\t\tHostBDF:    string(lv.PhysicalVolume.BDF),\n\t\t\tSerial:     string(lv.PhysicalVolume.Serial),\n\t\t},\n\t)\n\tif err := repo.Add(ctx, backup); err != nil {\n\t\treturn err\n\t}\n\tc.relatedBackup = backup\n\t_, err = bakSm.Fire(ctx, backupDomain.StatusInit, backupDomain.EventStartBackup, backupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: backup})\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/attach_logical_volume.go",
        "code_start_line": 49,
        "code_end_line": 71,
        "code_key": "Handle",
        "code_value": "func (c *AttachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEAttachLogicalVolume, c)\n\n\t// 如果已经挂载到了指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeAlreadyAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume already attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_delete_logical_volume.go",
        "code_start_line": 34,
        "code_end_line": 55,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\t// 如果逻辑卷不存在，则直接返回成功\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"failed to confirm delete: app id mismatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDeleteLogicalVolume, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/offline_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OfflinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOfflinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *DeletePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\t// 如果物理卷不存在，则直接幂等返回\n\t\treturn nil\n\t}\n\n\tvar event = domain.PVEDeletePhysicalVolume\n\tif c.Force && (c.relatedVolume.State == domain.PVSDefunct) {\n\t\t// 这里的实现不太好，状态机的逻辑不应该侵入 cmd\n\t\t// 时间太赶了，后续重构优化吧\n\t\tevent = domain.PVEForceDeleteForDefunct\n\t}\n\n\tif c.relatedVolume.HasBindedPV() {\n\t\treturn errors.New(domain.ErrVolumeBusy, \"logic volume has binded to this physical volume\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, event, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_logical_volume.go",
        "code_start_line": 55,
        "code_end_line": 70,
        "code_key": "Handle",
        "code_value": "func (c *CleanupLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVECleanupLogicalVolume, c)\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_init_physical_volume.go",
        "code_start_line": 26,
        "code_end_line": 52,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmInitPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\tif c.relatedVolume.IP.String() != c.Host.String() {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume host ip mistmatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVECreatePhysicalVolumeOnHost, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_physical_volume.go",
        "code_start_line": 51,
        "code_end_line": 101,
        "code_key": "Handle",
        "code_value": "func (c *CreatePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\n\t// 获取物理卷状态机\n\tsm := app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\trepo := app.GetRegistry(ctx).Repositories.PhysicalVolume\n\n\t// 检查物理卷是否已经存在，如果存在则直接幂等返回\n\tvol1, err := repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"serial\", c.Serial).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tvol2, err := repo.FindByIPAndBDF(ctx, c.Host, domain.BDF(c.BDF))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"host\", c.Host.String()).Str(\"bdf\", c.BDF).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tfor _, vol := range []*domain.PhysicalVolume{vol1, vol2} {\n\t\texisted, err := c.checkExisting(ctx, vol)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif existed {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// 触发事件，创建物理卷\n\t_, err = sm.Fire(ctx,\n\t\tdomain.PVSUnInited,\n\t\tdomain.PVECreatePhysicalVolume,\n\t\tc,\n\t)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 创建 Bdev 以及格式化移动到创建物理卷的状态机中\n\n\t// _, err = sm.Fire(ctx,\n\t// \tc.GetPhysicalVolume().State,\n\t// \tdomain.PVECreatePhysicalVolumeOnHost,\n\t// \tc,\n\t// )\n\t// if err != nil {\n\t// \treturn err\n\t// }\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_benchmark_task.go",
        "code_start_line": 32,
        "code_end_line": 57,
        "code_key": "Handle",
        "code_value": "func (c *DeleteBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\terr       error\n\t)\n\n\tbench, err := benchRepo.FindByUUID(ctx, c.BenchmarkUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif bench.DiskInfo.Serial != c.Serial {\n\t\treturn errors.Newf(benchmark.ErrTaskNotFound, \"benchmark serial not match %s, want %s\", c.Serial, bench.DiskInfo.Serial)\n\t}\n\n\t_, err = benchSm.Fire(ctx, bench.Status, benchmark.EventDeleteBench, benchmark.Data{Benchmark: bench, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := benchRepo.Delete(ctx, bench); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_logical_volume.go",
        "code_start_line": 52,
        "code_end_line": 98,
        "code_key": "Handle",
        "code_value": "func (c *CreateLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tpvRepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tlvRepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm     = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\t// 1. 查找底层物理卷\n\tc.selectedPhysicalVolume, err = pvRepo.FindBySerial(ctx, rdiskDomain.Serial(c.PhysicalVolumeSerial))\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// 检查底层物理卷大小是否满足要求\n\tif c.selectedPhysicalVolume.Size < rdiskDomain.Size(c.DiskSize) {\n\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume size %d is smaller than requested size %d\", c.selectedPhysicalVolume.Size, c.DiskSize)\n\t}\n\n\t// 检查底层物理卷性能等级是否满足要求\n\tif c.PerformanceRank != \"\" {\n\t\tif string(c.selectedPhysicalVolume.PerformanceRank) != c.PerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not match requested rank %s\", c.selectedPhysicalVolume.PerformanceRank, c.PerformanceRank)\n\t\t}\n\t} else {\n\t\tif c.selectedPhysicalVolume.PerformanceRank != rdiskDomain.DefaultPerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not default rank %s\", c.selectedPhysicalVolume.PerformanceRank, rdiskDomain.DefaultPerformanceRank)\n\t\t}\n\t}\n\n\t// 2. 创建逻辑卷\n\tvol := rdiskDomain.NewLogicalVolume(users.AppID(c.AppID), rdiskDomain.Size(c.DiskSize), rdiskDomain.ZoneID(c.ZoneID))\n\tif c.VolumeType != \"\" {\n\t\tvol.VolumeType = rdiskDomain.VolumeType(c.VolumeType)\n\t}\n\tif c.DiskType != \"\" {\n\t\tvol.DiskType = rdiskDomain.DiskType(c.DiskType)\n\t}\n\terr = lvRepo.Add(ctx, vol)\n\tif err != nil {\n\t\treturn\n\t}\n\tc.createdLogicalVolume = vol\n\n\t// 3. 触发状态机，联动更新逻辑卷和物理卷状态\n\t_, err = sm.Fire(ctx, rdiskDomain.LVSUnInited, rdiskDomain.LVECreateLogicalVolume, c)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_running_backup_task.go",
        "code_start_line": 31,
        "code_end_line": 61,
        "code_key": "Handle",
        "code_value": "func (c *UpdateRunningBackupTaskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventUpdateBackupProgress,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_drgroup.go",
        "code_start_line": 78,
        "code_end_line": 173,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeDRGroupCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tlvView  = app.GetRegistry(ctx).Viewers.LogicalVolume\n\t\tdrgRepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t\tsm      = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\terr     error\n\t)\n\n\t// 0. 初始化\n\tc.drgroupRef = make(map[string]*drgroup.DRGroup)\n\n\t// 1. 加载所有逻辑卷所在的置放群组\n\tallVolumeUUIDs := make([]string, 0, len(c.UUIDs))\n\tfor _, _uuid := range c.UUIDs {\n\t\tallVolumeUUIDs = append(allVolumeUUIDs, _uuid.String())\n\t}\n\tif groups, err := drgRepo.FindByMembers(ctx, c.AppID, allVolumeUUIDs); err == nil {\n\t\tif err != nil {\n\t\t\tif !errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tfor _, group := range groups {\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t\tc.curDRGroupNames = append(c.curDRGroupNames, group.Name)\n\t\t}\n\t} else {\n\t\treturn err\n\t}\n\n\t// 2. 确认已上锁的置放群组和当前一致\n\tif !c.checkLockedDRGroupNames() {\n\t\treturn errors.New(drgroup.ErrGroupModified, \"drgroup changed\")\n\t}\n\n\t// 3. 加载所有逻辑卷的状态，不需要完整实体，因为不会修改 Volume\n\tc.relatedLogicalVolume, err = lvView.FindByIDs(ctx, c.AppID, c.UUIDs)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(c.relatedLogicalVolume) < len(c.UUIDs) {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t// 4. 加载所有目标置放群组，key 为 name\n\tfor _, spec := range c.Specs {\n\t\tvar group *drgroup.DRGroup\n\t\tif _, ok := c.drgroupRef[spec.Name]; ok {\n\t\t\tgroup = c.drgroupRef[spec.Name]\n\t\t} else {\n\t\t\tgroup, err = c.getOrCreateDRGroup(ctx, drgRepo, spec)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t}\n\n\t\tif spec.Affinity > 0 {\n\t\t\tgroup.Affinity = spec.Affinity\n\t\t}\n\t\tif spec.Type != \"\" {\n\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t}\n\t}\n\n\t// 5. 对所有逻辑卷执行置放群组变更事件，检查状态是否允许，\n\t//    实际的更新还是在这里执行。\n\tfor _, vol := range c.relatedLogicalVolume {\n\t\terr := sm.Check(ctx, vol.State, rdiskDomain.LVEUpdateDrGroup, c)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// 将逻辑卷从原有的置放群组中移除\n\t\tfor _, name := range c.curDRGroupNames {\n\t\t\tc.drgroupRef[name].RemoveMember(vol.UUID.String())\n\t\t}\n\t\t// 将逻辑卷添加到新的置放群组中\n\t\tfor _, spec := range c.Specs {\n\t\t\tsubGroup := spec.SubGroup\n\t\t\tif subGroup == \"\" {\n\t\t\t\t// 如果没有指定子组，则使用远端 SSD UUID 作为子组名称\n\t\t\t\t// 相当于每块盘都是一个子组，相当于没有使用子组功能\n\t\t\t\tsubGroup = vol.UUID.String()\n\t\t\t}\n\t\t\tif err := c.drgroupRef[spec.Name].AddMember(vol.UUID.String(), subGroup, vol.PhysicalVolume.IP.String()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tif c.DryRun {\n\t\treturn errors.New(errors.ErrDryRunSuccessExit, \"dry run check success\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/online_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OnlinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOnlinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_benchmark_task.go",
        "code_start_line": 34,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *UpdateBenchmarkTask) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, rdisk.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark, err = benchRepo.FindByUUID(ctx, c.BenchmarkUUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventUpdateBench, benchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_flow_ctrl.go",
        "code_start_line": 80,
        "code_end_line": 103,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeFlowControlCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not found\")\n\t}\n\n\tspec := c.volume.FlowControlSpec\n\tif !c.UpdateRequest.UpdateSpec(&spec, c.volume.GetDefaultFlowControlSpec()) {\n\t\t// 没有任何更新，直接返回成功\n\t\treturn nil\n\t}\n\tc.volume.SetFlowControlSpec(spec)\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEUpdateFlowControl, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_defunct_volume.go",
        "code_start_line": 46,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *CleanupDefunctCommand) Handle(ctx context.Context) error {\n\tvar err error\n\tc.lv, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar sm = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\tvar event = rdiskDomain.LVECleanupDefunct\n\n\tfor _, attachment := range c.lv.Attachments {\n\t\tlogs.Info(ctx).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).Msg(\"cleanup defuncting volume\")\n\t\tsubCmd := &cleanDefunctSubCommand{Parent: c, HostIP: attachment.IP}\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, subCmd)\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，因为只要有一个挂载点清理失败，其他挂载点还是需要继续清理的\n\t\t\t// 失败的挂载点会在后台继续清理\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).\n\t\t\t\tMsg(\"failed to cleanup defunct volume, retry later.\")\n\t\t}\n\t}\n\n\tif len(c.lv.Attachments) == 0 {\n\t\t// 没有挂载点，直接清理\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, &cleanDefunctSubCommand{Parent: c, HostIP: net.IP{}})\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，后续自动重试即可\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Msg(\"failed to complete cleanup defunct volume\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_drgroup_exists.go",
        "code_start_line": 28,
        "code_end_line": 53,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDRGroupExistsCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t)\n\tfor _, spec := range c.DRGroup {\n\t\t_, err := repo.FindByName(ctx, users.AppID(c.AppID), spec.Name)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\tgroup := drgroup.New(spec.Name, users.AppID(c.AppID))\n\t\t\t\tif spec.Affinity > 0 {\n\t\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t\t}\n\t\t\t\tif spec.Type != \"\" {\n\t\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t\t}\n\t\t\t\terr = repo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_physical_volume.go",
        "code_start_line": 31,
        "code_end_line": 54,
        "code_key": "Handle",
        "code_value": "func (c *UpdatePhyRDiskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEUpdatePhysicalVolume, c)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/recycle_backup_data.go",
        "code_start_line": 32,
        "code_end_line": 62,
        "code_key": "Handle",
        "code_value": "func (c *RecycleBackupDataCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventDeleteBackup,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_drgroup.go",
        "code_start_line": 176,
        "code_end_line": 198,
        "code_key": "getOrCreateDRGroup",
        "code_value": "func (c *UpdateLogicalVolumeDRGroupCommand) getOrCreateDRGroup(ctx context.Context, drgRepo drgroup.Repository, spec *drgroup.Spec) (*drgroup.DRGroup, error) {\n\tgroup, err := drgRepo.FindByName(ctx, c.AppID, spec.Name)\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\tgroup = drgroup.New(spec.Name, c.AppID)\n\t\t\tif spec.Affinity > 0 {\n\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t}\n\t\t\tif spec.Type != \"\" {\n\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t}\n\t\t\tif !c.DryRun {\n\t\t\t\terr := drgRepo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn group, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/drgroups.go",
        "code_start_line": 22,
        "code_end_line": 71,
        "code_key": "AddHostToDRGroup",
        "code_value": "func AddHostToDRGroup(ctx context.Context, source rdiskDomain.LogicalVolumeState, target rdiskDomain.LogicalVolumeState, stateCtx app.LogicalVolumeContext) (rdiskDomain.LogicalVolumeState, error) {\n\tdata := stateCtx.(CreateLogicalVolumeContext)\n\tvol := data.GetLogicalVolume()\n\tphy := data.GetPhysicalVolume()\n\tspecs := data.GetDRGroupSpecList()\n\trepo := app.GetRegistry(ctx).Repositories.DRGroup\n\tif len(specs) == 0 {\n\t\treturn target, nil\n\t}\n\tfor _, spec := range specs {\n\t\tgroup, err := repo.FindByName(ctx, vol.AppID, spec.Name)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\tgroup = drgroup.New(spec.Name, vol.AppID)\n\t\t\t\tif spec.Affinity > 0 {\n\t\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t\t}\n\t\t\t\tif spec.Type != \"\" {\n\t\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t\t}\n\t\t\t\terr = repo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn source, err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn source, err\n\t\t\t}\n\t\t}\n\t\tif spec.Affinity > 0 && group.Affinity != spec.Affinity {\n\t\t\tlogs.Info(ctx).Uint64(\"app_id\", uint64(vol.AppID)).\n\t\t\t\tStr(\"group_name\", spec.Name).\n\t\t\t\tInt(\"old_affinity\", group.Affinity).\n\t\t\t\tInt(\"new_affinity\", spec.Affinity).\n\t\t\t\tMsg(\"update affinity of drgroup\")\n\t\t\tgroup.Affinity = spec.Affinity\n\t\t}\n\t\tsubGroup := spec.SubGroup\n\t\tif subGroup == \"\" {\n\t\t\t// 如果没有指定子组，则使用远端 SSD UUID 作为子组名称\n\t\t\t// 相当于每块盘都是一个子组，相当于没有使用子组功能\n\t\t\tsubGroup = vol.UUID.String()\n\t\t}\n\t\terr = group.AddMember(vol.UUID.String(), subGroup, phy.IP.String())\n\t\tif err != nil {\n\t\t\treturn source, err\n\t\t}\n\t}\n\n\treturn target, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/models.go",
        "code_start_line": 281,
        "code_end_line": 291,
        "code_key": "View",
        "code_value": "type View struct {\n\tID            uint64            // 群组 ID，用作实体 ID\n\tName          string            // 群组名称，在同一个 AppID 下必须唯一\n\tAppID         users.AppID       // 群组所属应用 ID\n\tType          LocType           // 群组类型，保留字段\n\tAffinity      int               // 亲和度，表示群组内成员在同一台位置上最多只能有多少个\n\tMemberCount   int               // 成员数量\n\tSubGroupCount int               // 子组数量\n\tSatisfied     bool              // 是否满足约束条件\n\tSubGroupMap   map[string]string // 成员 ID -> 子组名称的映射关系，注意这里可能只是部分成员的子集\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/backup/interfaces.go",
        "code_start_line": 11,
        "code_end_line": 19,
        "code_key": "View",
        "code_value": "type View struct {\n\tUUID       uuid.UUID    // 备份 UUID\n\tAppID      users.AppID  // 所属 AppID\n\tStatus     BackupStatus // 备份状态\n\tCreateTime time.Time    // 创建时间\n\tPercentage int          // 备份进度，0-100\n\tVolumeUUID uuid.UUID    // 远端 SSD UUID\n\tSize       uint64       // 备份大小(GB)\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 19,
        "code_end_line": 33,
        "code_key": "DmDrgroup",
        "code_value": "type DmDrgroup struct {\n\tID        uint64    `gorm:\"column:id;primaryKey\"`                              // 主键 ID\n\tStatus    int       `gorm:\"column:status\"`                                     // 状态, 目前无用\n\tAppID     int64     `gorm:\"column:app_id;index:dm_drgroup_app_id_name,unique\"` // AppID\n\tName      string    `gorm:\"column:name;index:dm_drgroup_app_id_name,unique\"`   // DRGroup 名称，用户名下唯一\n\tAffinity  int       `gorm:\"column:affinity\"`                                   // 亲和性\n\tLocType   string    `gorm:\"column:loc_type\"`                                   // 位置类型，对应 HOST、RACK、SWITCH 等等\n\tSatisfied int       `gorm:\"column:satisfied\"`                                  // 组内元素是否满足约束条件\n\tMemberCnt int       `gorm:\"column:member_cnt\"`                                 // 组内元素数量\n\tExtra     string    `gorm:\"column:extra\"`                                      // 额外信息\n\tCreated   time.Time `gorm:\"column:created\"`\n\tUpdated   time.Time `gorm:\"column:updated\"`\n\n\tMembers []DmDrgroupMembers `gorm:\"foreignKey:AppID,GroupName;references:AppID,Name\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 35,
        "code_end_line": 37,
        "code_key": "TableName",
        "code_value": "func (*DmDrgroup) TableName() string {\n\treturn \"dm_drgroup\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 114,
        "code_end_line": 129,
        "code_key": "DmDrgroup",
        "code_value": "type DmDrgroup struct {\n\tID          uint64    `gorm:\"column:id;primaryKey\"`                              // 主键 ID\n\tStatus      int       `gorm:\"column:status\"`                                     // 状态, 目前无用\n\tAppID       int64     `gorm:\"column:app_id;index:dm_drgroup_app_id_name,unique\"` // AppID\n\tName        string    `gorm:\"column:name;index:dm_drgroup_app_id_name,unique\"`   // DRGroup 名称，用户名下唯一\n\tAffinity    int       `gorm:\"column:affinity\"`                                   // 亲和性\n\tLocType     string    `gorm:\"column:loc_type\"`                                   // 位置类型，对应 HOST、RACK、SWITCH 等等\n\tSatisfied   int       `gorm:\"column:satisfied\"`                                  // 组内元素是否满足约束条件\n\tMemberCnt   int       `gorm:\"column:member_cnt\"`                                 // 组内元素数量\n\tSubGroupCnt int       `gorm:\"column:sub_group_cnt\"`                              // 子组数量\n\tExtra       string    `gorm:\"column:extra\"`                                      // 额外信息\n\tCreated     time.Time `gorm:\"column:created\"`\n\tUpdated     time.Time `gorm:\"column:updated\"`\n\n\tMembers []DmDrgroupMembers `gorm:\"foreignKey:AppID,GroupName;references:AppID,Name\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 131,
        "code_end_line": 133,
        "code_key": "TableName",
        "code_value": "func (*DmDrgroup) TableName() string {\n\treturn \"dm_drgroup\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go:31:52:FindByNames": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
    "code_start_line": 31,
    "code_end_line": 52,
    "code_start_column": 32,
    "code_key": "FindByNames",
    "code_value": "func (d drgroupRepositoryImpl) FindByNames(ctx context.Context, appId users.AppID, names []string) ([]*drgroup.DRGroup, error) {\n\tuow := getUow(ctx)\n\tgroup := []metadb.DmDrgroup{}\n\tresult := uow.tx.\n\t\tPreload(\"Members\").\n\t\tFind(&group, \"app_id = ? and name in ?\", appId, names)\n\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"disaster recovery group not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tresults := make([]*drgroup.DRGroup, len(group))\n\tfor i := range group {\n\t\tresults[i] = uow.trackedDRGroups.Add(fromDmDRGroupToModel(&group[i]))\n\t}\n\treturn results, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
        "code_start_line": 20,
        "code_end_line": 29,
        "code_key": "FindByName",
        "code_value": "func (d drgroupRepositoryImpl) FindByName(ctx context.Context, appId users.AppID, name string) (*drgroup.DRGroup, error) {\n\tresults, err := d.FindByNames(ctx, appId, []string{name})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(results) < 1 {\n\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"disaster recovery group not exists\")\n\t}\n\treturn results[0], nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/drgroup.go",
        "code_start_line": 75,
        "code_end_line": 90,
        "code_key": "FindByName",
        "code_value": "func (d *drgroupViewerImpl) FindByName(ctx context.Context, appId users.AppID, name string) (*drgroup.View, error) {\n\tvar (\n\t\tresultView drgroup.View\n\t\tdataObject metadb.DmDrgroup\n\t)\n\n\tresult := d.db.WithContext(ctx).First(&dataObject, \"app_id = ? and name = ?\", appId, name)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"group not exist\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\td.translate(&dataObject, &resultView)\n\treturn &resultView, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 98,
        "code_end_line": 104,
        "code_key": "FindByName",
        "code_value": "func (m *MockRepository) FindByName(arg0 context.Context, arg1 users.AppID, arg2 string) (*drgroup.DRGroup, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByName\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(*drgroup.DRGroup)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 107,
        "code_end_line": 110,
        "code_key": "FindByName",
        "code_value": "func (mr *MockRepositoryMockRecorder) FindByName(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByName\", reflect.TypeOf((*MockRepository)(nil).FindByName), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/view.go",
        "code_start_line": 70,
        "code_end_line": 76,
        "code_key": "FindByName",
        "code_value": "func (m *MockViewer) FindByName(arg0 context.Context, arg1 users.AppID, arg2 string) (*drgroup.View, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByName\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(*drgroup.View)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/view.go",
        "code_start_line": 79,
        "code_end_line": 82,
        "code_key": "FindByName",
        "code_value": "func (mr *MockViewerMockRecorder) FindByName(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByName\", reflect.TypeOf((*MockViewer)(nil).FindByName), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 19,
        "code_end_line": 33,
        "code_key": "DmDrgroup",
        "code_value": "type DmDrgroup struct {\n\tID        uint64    `gorm:\"column:id;primaryKey\"`                              // 主键 ID\n\tStatus    int       `gorm:\"column:status\"`                                     // 状态, 目前无用\n\tAppID     int64     `gorm:\"column:app_id;index:dm_drgroup_app_id_name,unique\"` // AppID\n\tName      string    `gorm:\"column:name;index:dm_drgroup_app_id_name,unique\"`   // DRGroup 名称，用户名下唯一\n\tAffinity  int       `gorm:\"column:affinity\"`                                   // 亲和性\n\tLocType   string    `gorm:\"column:loc_type\"`                                   // 位置类型，对应 HOST、RACK、SWITCH 等等\n\tSatisfied int       `gorm:\"column:satisfied\"`                                  // 组内元素是否满足约束条件\n\tMemberCnt int       `gorm:\"column:member_cnt\"`                                 // 组内元素数量\n\tExtra     string    `gorm:\"column:extra\"`                                      // 额外信息\n\tCreated   time.Time `gorm:\"column:created\"`\n\tUpdated   time.Time `gorm:\"column:updated\"`\n\n\tMembers []DmDrgroupMembers `gorm:\"foreignKey:AppID,GroupName;references:AppID,Name\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 35,
        "code_end_line": 37,
        "code_key": "TableName",
        "code_value": "func (*DmDrgroup) TableName() string {\n\treturn \"dm_drgroup\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 114,
        "code_end_line": 129,
        "code_key": "DmDrgroup",
        "code_value": "type DmDrgroup struct {\n\tID          uint64    `gorm:\"column:id;primaryKey\"`                              // 主键 ID\n\tStatus      int       `gorm:\"column:status\"`                                     // 状态, 目前无用\n\tAppID       int64     `gorm:\"column:app_id;index:dm_drgroup_app_id_name,unique\"` // AppID\n\tName        string    `gorm:\"column:name;index:dm_drgroup_app_id_name,unique\"`   // DRGroup 名称，用户名下唯一\n\tAffinity    int       `gorm:\"column:affinity\"`                                   // 亲和性\n\tLocType     string    `gorm:\"column:loc_type\"`                                   // 位置类型，对应 HOST、RACK、SWITCH 等等\n\tSatisfied   int       `gorm:\"column:satisfied\"`                                  // 组内元素是否满足约束条件\n\tMemberCnt   int       `gorm:\"column:member_cnt\"`                                 // 组内元素数量\n\tSubGroupCnt int       `gorm:\"column:sub_group_cnt\"`                              // 子组数量\n\tExtra       string    `gorm:\"column:extra\"`                                      // 额外信息\n\tCreated     time.Time `gorm:\"column:created\"`\n\tUpdated     time.Time `gorm:\"column:updated\"`\n\n\tMembers []DmDrgroupMembers `gorm:\"foreignKey:AppID,GroupName;references:AppID,Name\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 131,
        "code_end_line": 133,
        "code_key": "TableName",
        "code_value": "func (*DmDrgroup) TableName() string {\n\treturn \"dm_drgroup\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/models.go",
        "code_start_line": 58,
        "code_end_line": 68,
        "code_key": "DRGroup",
        "code_value": "type DRGroup struct {\n\tID       uint64      // 群组 ID，用作实体 ID\n\tName     string      // 群组名称，在同一个 AppID 下必须唯一\n\tAppID    users.AppID // 群组所属应用 ID\n\tType     LocType     // 群组类型，保留字段\n\tAffinity int         // 亲和度，表示群组内子组在同一台位置上最多只能有多少个\n\n\tsubGroups    map[string]*SubGroup   // 子组\n\tlocationsMap map[string][]*SubGroup // 位置到子组的映射\n\tmembersMap   map[string]*SubGroup   // 成员到子组的映射\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go:58:94:FindByMembers": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
    "code_start_line": 58,
    "code_end_line": 94,
    "code_start_column": 32,
    "code_key": "FindByMembers",
    "code_value": "func (d drgroupRepositoryImpl) FindByMembers(ctx context.Context, appId users.AppID, members []string) ([]*drgroup.DRGroup, error) {\n\tuow := getUow(ctx)\n\tgroup := []metadb.DmDrgroup{}\n\n\tmembersResult := []metadb.DmDrgroupMembers{}\n\tresult := uow.tx.\n\t\tFind(&membersResult, \"app_id = ? and member_id in ?\", appId, members)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tnames := make([]string, 0, len(members))\n\tfor i := range membersResult {\n\t\tnames = append(names, membersResult[i].GroupName)\n\t}\n\tresult = uow.tx.\n\t\tPreload(\"Members\").\n\t\tFind(&group, \"app_id = ? and name in ?\", appId, names)\n\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"disaster recovery group not exists\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tif result.RowsAffected == 0 {\n\t\treturn nil, nil\n\t}\n\tresults := make([]*drgroup.DRGroup, len(group))\n\tfor i := range group {\n\t\tresults[i] = fromDmDRGroupToModel(&group[i])\n\t\tresults[i] = uow.trackedDRGroups.Add(results[i])\n\t}\n\treturn results, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 2,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go",
        "code_start_line": 51,
        "code_end_line": 72,
        "code_key": "Handle",
        "code_value": "func (c *CbsAppIdConsumer) Handle(ctx context.Context, delivery *rabbitmq.Delivery) error {\n\tu, chargeTime, err := c.ParseDelivery(ctx, delivery)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif u == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"USER_INFO_NOT_FOUND\")\n\t\treturn nil\n\t}\n\n\tchargeDetail := c.GetChargeDetailForSingleUser(u, chargeTime)\n\tif chargeDetail == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tUint64(\"appId\", uint64(u.AppId)).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"NO_RESOURCE_TO_CHARGE\")\n\t\treturn nil\n\t}\n\treturn c.ProcessChargeDetail(chargeDetail)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 105,
        "code_end_line": 116,
        "code_key": "Handle",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tif err := c.ensureLocks(ctx); err != nil {\n\t\treturn err\n\t}\n\tif c.lvUUID != nil {\n\t\t// 涉及到逻辑卷时，需要先标记逻辑卷为故障\n\t\treturn c.handleBindedVolume(ctx)\n\t} else {\n\t\t// 不涉及到逻辑卷时，直接标记物理卷为故障\n\t\treturn c.handleIdleVolume(ctx)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/detach_logical_volume.go",
        "code_start_line": 56,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *DetachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDetachLogicalVolume, c)\n\n\t// 如果没有挂载到指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume not attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_benchmark_task.go",
        "code_start_line": 125,
        "code_end_line": 165,
        "code_key": "Handle",
        "code_value": "func (c *CreateBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tvolSm     = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = volSm.Fire(ctx, c.relatedVolume.State, domain.PVEStartBenchmark, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark = benchmark.New(benchmark.DiskInfo{\n\t\tSerial: string(c.relatedVolume.Serial),\n\t\tHostIP: c.relatedVolume.IP,\n\t\tBDF:    string(c.relatedVolume.BDF),\n\t})\n\n\tif err = benchRepo.Add(ctx, c.relatedBenchmark); err != nil {\n\t\tdelegate := &benchmarkDelegate{cmd: c}\n\t\tif _err := delegate.TaskFinishCallback(ctx, c.relatedBenchmark); _err != nil {\n\t\t\tlogs.Warn(ctx).Err(_err).Str(\"serial\", string(c.relatedVolume.Serial)).Msg(\"failed to rollback: create bdev\")\n\t\t}\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventCreateBench,\n\t\tbenchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_logical_volume.go",
        "code_start_line": 71,
        "code_end_line": 108,
        "code_key": "Handle",
        "code_value": "func (d *DeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\td.volume, err = repo.FindByID(ctx, d.UUID)\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif e := d.volume.CheckDelete(); e != nil {\n\t\treturn e\n\t}\n\n\tif d.volume.AppID != d.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"refuse to delet: app id mismatch\")\n\t}\n\n\td.drgroup, err = app.GetRegistry(ctx).Repositories.DRGroup.FindByMember(ctx, d.AppID, d.volume.UUID.String())\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\td.drgroup = nil\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := d.checkDRGroupMatch(ctx); err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, d.volume.State, rdiskDomain.LVEMarkToRecycle, d)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_recycled_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmRecycledPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEConfirmRecycled, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_rdisk_backup.go",
        "code_start_line": 52,
        "code_end_line": 75,
        "code_key": "Handle",
        "code_value": "func (c *DeleteRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tsm   = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\tc.relatedBackup, err = repo.FindByUUID(ctx, c.BackupID.String())\n\tif err != nil || c.relatedBackup == nil || c.relatedBackup.AppID != c.AppID {\n\t\treturn errors.New(backupDomain.ErrBackupNotExist, \"backup not exists\")\n\t}\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tc.relatedBackup.Status,\n\t\tbackupDomain.EventSoftDeleteBackup,\n\t\tbackupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: c.relatedBackup})\n\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_rdisk_backup.go",
        "code_start_line": 47,
        "code_end_line": 80,
        "code_key": "Handle",
        "code_value": "func (c *CreateRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tlvSm  = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\tbakSm = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo  = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t_, err = lvSm.Fire(ctx, c.relatedVolume.State, rdiskDomain.LVEBackupStarted, c)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tlv := c.relatedVolume\n\tbackup := backupDomain.New(\n\t\tlv.AppID,\n\t\tbackupDomain.DiskInfo{\n\t\t\tVolumeUUID: lv.UUID,\n\t\t\tVolumeSize: uint64(lv.Size),\n\t\t\tHostIP:     lv.PhysicalVolume.IP,\n\t\t\tHostBDF:    string(lv.PhysicalVolume.BDF),\n\t\t\tSerial:     string(lv.PhysicalVolume.Serial),\n\t\t},\n\t)\n\tif err := repo.Add(ctx, backup); err != nil {\n\t\treturn err\n\t}\n\tc.relatedBackup = backup\n\t_, err = bakSm.Fire(ctx, backupDomain.StatusInit, backupDomain.EventStartBackup, backupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: backup})\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/attach_logical_volume.go",
        "code_start_line": 49,
        "code_end_line": 71,
        "code_key": "Handle",
        "code_value": "func (c *AttachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEAttachLogicalVolume, c)\n\n\t// 如果已经挂载到了指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeAlreadyAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume already attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_delete_logical_volume.go",
        "code_start_line": 34,
        "code_end_line": 55,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\t// 如果逻辑卷不存在，则直接返回成功\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"failed to confirm delete: app id mismatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDeleteLogicalVolume, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/offline_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OfflinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOfflinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *DeletePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\t// 如果物理卷不存在，则直接幂等返回\n\t\treturn nil\n\t}\n\n\tvar event = domain.PVEDeletePhysicalVolume\n\tif c.Force && (c.relatedVolume.State == domain.PVSDefunct) {\n\t\t// 这里的实现不太好，状态机的逻辑不应该侵入 cmd\n\t\t// 时间太赶了，后续重构优化吧\n\t\tevent = domain.PVEForceDeleteForDefunct\n\t}\n\n\tif c.relatedVolume.HasBindedPV() {\n\t\treturn errors.New(domain.ErrVolumeBusy, \"logic volume has binded to this physical volume\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, event, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_logical_volume.go",
        "code_start_line": 55,
        "code_end_line": 70,
        "code_key": "Handle",
        "code_value": "func (c *CleanupLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVECleanupLogicalVolume, c)\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_init_physical_volume.go",
        "code_start_line": 26,
        "code_end_line": 52,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmInitPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\tif c.relatedVolume.IP.String() != c.Host.String() {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume host ip mistmatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVECreatePhysicalVolumeOnHost, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_physical_volume.go",
        "code_start_line": 51,
        "code_end_line": 101,
        "code_key": "Handle",
        "code_value": "func (c *CreatePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\n\t// 获取物理卷状态机\n\tsm := app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\trepo := app.GetRegistry(ctx).Repositories.PhysicalVolume\n\n\t// 检查物理卷是否已经存在，如果存在则直接幂等返回\n\tvol1, err := repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"serial\", c.Serial).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tvol2, err := repo.FindByIPAndBDF(ctx, c.Host, domain.BDF(c.BDF))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"host\", c.Host.String()).Str(\"bdf\", c.BDF).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tfor _, vol := range []*domain.PhysicalVolume{vol1, vol2} {\n\t\texisted, err := c.checkExisting(ctx, vol)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif existed {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// 触发事件，创建物理卷\n\t_, err = sm.Fire(ctx,\n\t\tdomain.PVSUnInited,\n\t\tdomain.PVECreatePhysicalVolume,\n\t\tc,\n\t)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 创建 Bdev 以及格式化移动到创建物理卷的状态机中\n\n\t// _, err = sm.Fire(ctx,\n\t// \tc.GetPhysicalVolume().State,\n\t// \tdomain.PVECreatePhysicalVolumeOnHost,\n\t// \tc,\n\t// )\n\t// if err != nil {\n\t// \treturn err\n\t// }\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_benchmark_task.go",
        "code_start_line": 32,
        "code_end_line": 57,
        "code_key": "Handle",
        "code_value": "func (c *DeleteBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\terr       error\n\t)\n\n\tbench, err := benchRepo.FindByUUID(ctx, c.BenchmarkUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif bench.DiskInfo.Serial != c.Serial {\n\t\treturn errors.Newf(benchmark.ErrTaskNotFound, \"benchmark serial not match %s, want %s\", c.Serial, bench.DiskInfo.Serial)\n\t}\n\n\t_, err = benchSm.Fire(ctx, bench.Status, benchmark.EventDeleteBench, benchmark.Data{Benchmark: bench, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := benchRepo.Delete(ctx, bench); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_logical_volume.go",
        "code_start_line": 52,
        "code_end_line": 98,
        "code_key": "Handle",
        "code_value": "func (c *CreateLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tpvRepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tlvRepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm     = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\t// 1. 查找底层物理卷\n\tc.selectedPhysicalVolume, err = pvRepo.FindBySerial(ctx, rdiskDomain.Serial(c.PhysicalVolumeSerial))\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// 检查底层物理卷大小是否满足要求\n\tif c.selectedPhysicalVolume.Size < rdiskDomain.Size(c.DiskSize) {\n\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume size %d is smaller than requested size %d\", c.selectedPhysicalVolume.Size, c.DiskSize)\n\t}\n\n\t// 检查底层物理卷性能等级是否满足要求\n\tif c.PerformanceRank != \"\" {\n\t\tif string(c.selectedPhysicalVolume.PerformanceRank) != c.PerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not match requested rank %s\", c.selectedPhysicalVolume.PerformanceRank, c.PerformanceRank)\n\t\t}\n\t} else {\n\t\tif c.selectedPhysicalVolume.PerformanceRank != rdiskDomain.DefaultPerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not default rank %s\", c.selectedPhysicalVolume.PerformanceRank, rdiskDomain.DefaultPerformanceRank)\n\t\t}\n\t}\n\n\t// 2. 创建逻辑卷\n\tvol := rdiskDomain.NewLogicalVolume(users.AppID(c.AppID), rdiskDomain.Size(c.DiskSize), rdiskDomain.ZoneID(c.ZoneID))\n\tif c.VolumeType != \"\" {\n\t\tvol.VolumeType = rdiskDomain.VolumeType(c.VolumeType)\n\t}\n\tif c.DiskType != \"\" {\n\t\tvol.DiskType = rdiskDomain.DiskType(c.DiskType)\n\t}\n\terr = lvRepo.Add(ctx, vol)\n\tif err != nil {\n\t\treturn\n\t}\n\tc.createdLogicalVolume = vol\n\n\t// 3. 触发状态机，联动更新逻辑卷和物理卷状态\n\t_, err = sm.Fire(ctx, rdiskDomain.LVSUnInited, rdiskDomain.LVECreateLogicalVolume, c)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_running_backup_task.go",
        "code_start_line": 31,
        "code_end_line": 61,
        "code_key": "Handle",
        "code_value": "func (c *UpdateRunningBackupTaskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventUpdateBackupProgress,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_drgroup.go",
        "code_start_line": 78,
        "code_end_line": 173,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeDRGroupCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tlvView  = app.GetRegistry(ctx).Viewers.LogicalVolume\n\t\tdrgRepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t\tsm      = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\terr     error\n\t)\n\n\t// 0. 初始化\n\tc.drgroupRef = make(map[string]*drgroup.DRGroup)\n\n\t// 1. 加载所有逻辑卷所在的置放群组\n\tallVolumeUUIDs := make([]string, 0, len(c.UUIDs))\n\tfor _, _uuid := range c.UUIDs {\n\t\tallVolumeUUIDs = append(allVolumeUUIDs, _uuid.String())\n\t}\n\tif groups, err := drgRepo.FindByMembers(ctx, c.AppID, allVolumeUUIDs); err == nil {\n\t\tif err != nil {\n\t\t\tif !errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tfor _, group := range groups {\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t\tc.curDRGroupNames = append(c.curDRGroupNames, group.Name)\n\t\t}\n\t} else {\n\t\treturn err\n\t}\n\n\t// 2. 确认已上锁的置放群组和当前一致\n\tif !c.checkLockedDRGroupNames() {\n\t\treturn errors.New(drgroup.ErrGroupModified, \"drgroup changed\")\n\t}\n\n\t// 3. 加载所有逻辑卷的状态，不需要完整实体，因为不会修改 Volume\n\tc.relatedLogicalVolume, err = lvView.FindByIDs(ctx, c.AppID, c.UUIDs)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(c.relatedLogicalVolume) < len(c.UUIDs) {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t// 4. 加载所有目标置放群组，key 为 name\n\tfor _, spec := range c.Specs {\n\t\tvar group *drgroup.DRGroup\n\t\tif _, ok := c.drgroupRef[spec.Name]; ok {\n\t\t\tgroup = c.drgroupRef[spec.Name]\n\t\t} else {\n\t\t\tgroup, err = c.getOrCreateDRGroup(ctx, drgRepo, spec)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t}\n\n\t\tif spec.Affinity > 0 {\n\t\t\tgroup.Affinity = spec.Affinity\n\t\t}\n\t\tif spec.Type != \"\" {\n\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t}\n\t}\n\n\t// 5. 对所有逻辑卷执行置放群组变更事件，检查状态是否允许，\n\t//    实际的更新还是在这里执行。\n\tfor _, vol := range c.relatedLogicalVolume {\n\t\terr := sm.Check(ctx, vol.State, rdiskDomain.LVEUpdateDrGroup, c)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// 将逻辑卷从原有的置放群组中移除\n\t\tfor _, name := range c.curDRGroupNames {\n\t\t\tc.drgroupRef[name].RemoveMember(vol.UUID.String())\n\t\t}\n\t\t// 将逻辑卷添加到新的置放群组中\n\t\tfor _, spec := range c.Specs {\n\t\t\tsubGroup := spec.SubGroup\n\t\t\tif subGroup == \"\" {\n\t\t\t\t// 如果没有指定子组，则使用远端 SSD UUID 作为子组名称\n\t\t\t\t// 相当于每块盘都是一个子组，相当于没有使用子组功能\n\t\t\t\tsubGroup = vol.UUID.String()\n\t\t\t}\n\t\t\tif err := c.drgroupRef[spec.Name].AddMember(vol.UUID.String(), subGroup, vol.PhysicalVolume.IP.String()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tif c.DryRun {\n\t\treturn errors.New(errors.ErrDryRunSuccessExit, \"dry run check success\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/online_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OnlinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOnlinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_benchmark_task.go",
        "code_start_line": 34,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *UpdateBenchmarkTask) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, rdisk.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark, err = benchRepo.FindByUUID(ctx, c.BenchmarkUUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventUpdateBench, benchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_flow_ctrl.go",
        "code_start_line": 80,
        "code_end_line": 103,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeFlowControlCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not found\")\n\t}\n\n\tspec := c.volume.FlowControlSpec\n\tif !c.UpdateRequest.UpdateSpec(&spec, c.volume.GetDefaultFlowControlSpec()) {\n\t\t// 没有任何更新，直接返回成功\n\t\treturn nil\n\t}\n\tc.volume.SetFlowControlSpec(spec)\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEUpdateFlowControl, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_defunct_volume.go",
        "code_start_line": 46,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *CleanupDefunctCommand) Handle(ctx context.Context) error {\n\tvar err error\n\tc.lv, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar sm = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\tvar event = rdiskDomain.LVECleanupDefunct\n\n\tfor _, attachment := range c.lv.Attachments {\n\t\tlogs.Info(ctx).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).Msg(\"cleanup defuncting volume\")\n\t\tsubCmd := &cleanDefunctSubCommand{Parent: c, HostIP: attachment.IP}\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, subCmd)\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，因为只要有一个挂载点清理失败，其他挂载点还是需要继续清理的\n\t\t\t// 失败的挂载点会在后台继续清理\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).\n\t\t\t\tMsg(\"failed to cleanup defunct volume, retry later.\")\n\t\t}\n\t}\n\n\tif len(c.lv.Attachments) == 0 {\n\t\t// 没有挂载点，直接清理\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, &cleanDefunctSubCommand{Parent: c, HostIP: net.IP{}})\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，后续自动重试即可\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Msg(\"failed to complete cleanup defunct volume\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_drgroup_exists.go",
        "code_start_line": 28,
        "code_end_line": 53,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDRGroupExistsCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t)\n\tfor _, spec := range c.DRGroup {\n\t\t_, err := repo.FindByName(ctx, users.AppID(c.AppID), spec.Name)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\tgroup := drgroup.New(spec.Name, users.AppID(c.AppID))\n\t\t\t\tif spec.Affinity > 0 {\n\t\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t\t}\n\t\t\t\tif spec.Type != \"\" {\n\t\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t\t}\n\t\t\t\terr = repo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_physical_volume.go",
        "code_start_line": 31,
        "code_end_line": 54,
        "code_key": "Handle",
        "code_value": "func (c *UpdatePhyRDiskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEUpdatePhysicalVolume, c)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/recycle_backup_data.go",
        "code_start_line": 32,
        "code_end_line": 62,
        "code_key": "Handle",
        "code_value": "func (c *RecycleBackupDataCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventDeleteBackup,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 70,
        "code_end_line": 74,
        "code_key": "Prepare",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) Prepare(ctx context.Context) error {\n\tvar err error\n\tc.aquiredLocks, err = c.queryRequiredLocks(ctx)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_logical_volume.go",
        "code_start_line": 40,
        "code_end_line": 63,
        "code_key": "Prepare",
        "code_value": "func (d *DeleteLogicalVolumeCommand) Prepare(ctx context.Context) error {\n\t// 为什么需要先查询逻辑卷所在的置放群组呢？\n\t//\n\t// 为了避免进行并发修改置放群组产生竞争，必须要在启动时就得到置放群组名称以进行加锁。\n\t// 但是入参中带上置放群组名称显然已不合适，所以需要在 Prepare 阶段进行查询。\n\t// 然后在加锁后，在 Handle 阶段还需要进行校验，形成乐观锁的。\n\t// 如果 Handle 阶段查询到的置放群组 Name 和 Prepare 阶段查询到的不一致，则需要报错退出。\n\tviewer := app.GetRegistry(ctx).Viewers.DRGroup\n\n\t// 查找逻辑卷所在的置放群组\n\tgroup, err := viewer.FindByMembers(ctx, d.AppID, []string{d.UUID.String()})\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tfor _, group := range group {\n\t\td.relatedDRGroupNames = append(d.relatedDRGroupNames, group.Name)\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_drgroup.go",
        "code_start_line": 40,
        "code_end_line": 65,
        "code_key": "Prepare",
        "code_value": "func (c *UpdateLogicalVolumeDRGroupCommand) Prepare(ctx context.Context) error {\n\tview := app.GetRegistry(ctx).Viewers.DRGroup\n\tc.lockedDRGroupNames = make([]string, 0, len(c.Specs)*2)\n\tallGroupNames := make(map[string]interface{})\n\tallMembers := make([]string, 0, len(c.UUIDs))\n\tfor _, _uuid := range c.UUIDs {\n\t\tallMembers = append(allMembers, _uuid.String())\n\t}\n\tcurrentGroups, err := view.FindByMembers(ctx, c.AppID, allMembers)\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\tfor _, group := range currentGroups {\n\t\tallGroupNames[group.Name] = nil\n\t}\n\tfor _, spec := range c.Specs {\n\t\tallGroupNames[spec.Name] = nil\n\t}\n\tfor name := range allGroupNames {\n\t\tc.lockedDRGroupNames = append(c.lockedDRGroupNames, name)\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 239,
        "code_end_line": 245,
        "code_key": "queryDRGroup",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) queryDRGroup(ctx context.Context, lv string, appId users.AppID) ([]*drgroup.View, error) {\n\tgroups, err := app.GetRegistry(ctx).Viewers.DRGroup.FindByMembers(ctx, appId, []string{lv})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn groups, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
        "code_start_line": 54,
        "code_end_line": 56,
        "code_key": "FindByMember",
        "code_value": "func (d drgroupRepositoryImpl) FindByMember(ctx context.Context, appId users.AppID, member string) ([]*drgroup.DRGroup, error) {\n\treturn d.FindByMembers(ctx, appId, []string{member})\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 68,
        "code_end_line": 74,
        "code_key": "FindByMember",
        "code_value": "func (m *MockRepository) FindByMember(arg0 context.Context, arg1 users.AppID, arg2 string) ([]*drgroup.DRGroup, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByMember\", arg0, arg1, arg2)\n\tret0, _ := ret[0].([]*drgroup.DRGroup)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 77,
        "code_end_line": 80,
        "code_key": "FindByMember",
        "code_value": "func (mr *MockRepositoryMockRecorder) FindByMember(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByMember\", reflect.TypeOf((*MockRepository)(nil).FindByMember), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 19,
        "code_end_line": 33,
        "code_key": "DmDrgroup",
        "code_value": "type DmDrgroup struct {\n\tID        uint64    `gorm:\"column:id;primaryKey\"`                              // 主键 ID\n\tStatus    int       `gorm:\"column:status\"`                                     // 状态, 目前无用\n\tAppID     int64     `gorm:\"column:app_id;index:dm_drgroup_app_id_name,unique\"` // AppID\n\tName      string    `gorm:\"column:name;index:dm_drgroup_app_id_name,unique\"`   // DRGroup 名称，用户名下唯一\n\tAffinity  int       `gorm:\"column:affinity\"`                                   // 亲和性\n\tLocType   string    `gorm:\"column:loc_type\"`                                   // 位置类型，对应 HOST、RACK、SWITCH 等等\n\tSatisfied int       `gorm:\"column:satisfied\"`                                  // 组内元素是否满足约束条件\n\tMemberCnt int       `gorm:\"column:member_cnt\"`                                 // 组内元素数量\n\tExtra     string    `gorm:\"column:extra\"`                                      // 额外信息\n\tCreated   time.Time `gorm:\"column:created\"`\n\tUpdated   time.Time `gorm:\"column:updated\"`\n\n\tMembers []DmDrgroupMembers `gorm:\"foreignKey:AppID,GroupName;references:AppID,Name\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 35,
        "code_end_line": 37,
        "code_key": "TableName",
        "code_value": "func (*DmDrgroup) TableName() string {\n\treturn \"dm_drgroup\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 114,
        "code_end_line": 129,
        "code_key": "DmDrgroup",
        "code_value": "type DmDrgroup struct {\n\tID          uint64    `gorm:\"column:id;primaryKey\"`                              // 主键 ID\n\tStatus      int       `gorm:\"column:status\"`                                     // 状态, 目前无用\n\tAppID       int64     `gorm:\"column:app_id;index:dm_drgroup_app_id_name,unique\"` // AppID\n\tName        string    `gorm:\"column:name;index:dm_drgroup_app_id_name,unique\"`   // DRGroup 名称，用户名下唯一\n\tAffinity    int       `gorm:\"column:affinity\"`                                   // 亲和性\n\tLocType     string    `gorm:\"column:loc_type\"`                                   // 位置类型，对应 HOST、RACK、SWITCH 等等\n\tSatisfied   int       `gorm:\"column:satisfied\"`                                  // 组内元素是否满足约束条件\n\tMemberCnt   int       `gorm:\"column:member_cnt\"`                                 // 组内元素数量\n\tSubGroupCnt int       `gorm:\"column:sub_group_cnt\"`                              // 子组数量\n\tExtra       string    `gorm:\"column:extra\"`                                      // 额外信息\n\tCreated     time.Time `gorm:\"column:created\"`\n\tUpdated     time.Time `gorm:\"column:updated\"`\n\n\tMembers []DmDrgroupMembers `gorm:\"foreignKey:AppID,GroupName;references:AppID,Name\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 131,
        "code_end_line": 133,
        "code_key": "TableName",
        "code_value": "func (*DmDrgroup) TableName() string {\n\treturn \"dm_drgroup\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 39,
        "code_end_line": 49,
        "code_key": "DmDrgroupMembers",
        "code_value": "type DmDrgroupMembers struct {\n\tID        uint64    `gorm:\"column:id;primaryKey\"`                                                          // 主键 ID\n\tAppID     int64     `gorm:\"column:app_id;index:dm_drgroup_members_app_id_group_name_member_id,unique\"`     // AppID\n\tGroupName string    `gorm:\"column:group_name;index:dm_drgroup_members_app_id_group_name_member_id,unique\"` // DRGroup 名称，用户名下唯一\n\tSubGroup  string    `gorm:\"column:sub_group\"`                                                              // 子组名称\n\tLoc       string    `gorm:\"column:loc\"`                                                                    // 位置信息，例如母机 IP\n\tMemberID  string    `gorm:\"column:member_id;index:dm_drgroup_members_app_id_group_name_member_id,unique\"`  // DRGroup 成员 ID，例如逻辑卷 UUID\n\tExtra     string    `gorm:\"column:extra\"`                                                                  // 额外信息\n\tCreated   time.Time `gorm:\"column:created\"`\n\tUpdated   time.Time `gorm:\"column:updated\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 55,
        "code_end_line": 57,
        "code_key": "TableName",
        "code_value": "func (DmDrgroupMembers) TableName() string {\n\treturn \"dm_drgroup_members\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 51,
        "code_end_line": 53,
        "code_key": "DBName",
        "code_value": "func (m DmDrgroupMembers) DBName() string {\n\treturn \"metadb\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 135,
        "code_end_line": 145,
        "code_key": "DmDrgroupMembers",
        "code_value": "type DmDrgroupMembers struct {\n\tID        uint64    `gorm:\"column:id;primaryKey\"`                                                          // 主键 ID\n\tAppID     int64     `gorm:\"column:app_id;index:dm_drgroup_members_app_id_group_name_member_id,unique\"`     // AppID\n\tGroupName string    `gorm:\"column:group_name;index:dm_drgroup_members_app_id_group_name_member_id,unique\"` // DRGroup 名称，用户名下唯一\n\tSubGroup  string    `gorm:\"column:sub_group\"`                                                              // 子组名称\n\tLoc       string    `gorm:\"column:loc\"`                                                                    // 位置信息，例如母机 IP\n\tMemberID  string    `gorm:\"column:member_id;index:dm_drgroup_members_app_id_group_name_member_id,unique\"`  // DRGroup 成员 ID，例如逻辑卷 UUID\n\tExtra     string    `gorm:\"column:extra\"`                                                                  // 额外信息\n\tCreated   time.Time `gorm:\"column:created\"`\n\tUpdated   time.Time `gorm:\"column:updated\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 147,
        "code_end_line": 149,
        "code_key": "TableName",
        "code_value": "func (DmDrgroupMembers) TableName() string {\n\treturn \"dm_drgroup_members\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/models.go",
        "code_start_line": 58,
        "code_end_line": 68,
        "code_key": "DRGroup",
        "code_value": "type DRGroup struct {\n\tID       uint64      // 群组 ID，用作实体 ID\n\tName     string      // 群组名称，在同一个 AppID 下必须唯一\n\tAppID    users.AppID // 群组所属应用 ID\n\tType     LocType     // 群组类型，保留字段\n\tAffinity int         // 亲和度，表示群组内子组在同一台位置上最多只能有多少个\n\n\tsubGroups    map[string]*SubGroup   // 子组\n\tlocationsMap map[string][]*SubGroup // 位置到子组的映射\n\tmembersMap   map[string]*SubGroup   // 成员到子组的映射\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/drgroup.go:92:124:FindByMembers": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/drgroup.go",
    "code_start_line": 92,
    "code_end_line": 124,
    "code_start_column": 29,
    "code_key": "FindByMembers",
    "code_value": "func (d *drgroupViewerImpl) FindByMembers(ctx context.Context, appId users.AppID, members []string) ([]*drgroup.View, error) {\n\tvar (\n\t\tresultViews       []drgroup.View\n\t\tresultViewRef     []*drgroup.View\n\t\tdataObjects       []*metadb.DmDrgroup\n\t\tdataObjectMembers []*metadb.DmDrgroupMembers\n\t)\n\tresult := d.db.WithContext(ctx).Find(&dataObjectMembers, \"app_id = ? and member_id in ?\", appId, members)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"group not exist\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tgroupNames := make([]string, len(dataObjectMembers))\n\tfor i := range dataObjectMembers {\n\t\tgroupNames[i] = dataObjectMembers[i].GroupName\n\t}\n\tresult = d.db.WithContext(ctx).Find(&dataObjects, \"app_id = ? and name in ?\", appId, groupNames)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"group not exist\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tresultViews = make([]drgroup.View, len(dataObjects))\n\tresultViewRef = make([]*drgroup.View, len(dataObjects))\n\tfor i := range dataObjects {\n\t\tresultViewRef[i] = &resultViews[i]\n\t\td.translate(dataObjects[i], resultViewRef[i])\n\t}\n\treturn resultViewRef, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 2,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go",
        "code_start_line": 51,
        "code_end_line": 72,
        "code_key": "Handle",
        "code_value": "func (c *CbsAppIdConsumer) Handle(ctx context.Context, delivery *rabbitmq.Delivery) error {\n\tu, chargeTime, err := c.ParseDelivery(ctx, delivery)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif u == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"USER_INFO_NOT_FOUND\")\n\t\treturn nil\n\t}\n\n\tchargeDetail := c.GetChargeDetailForSingleUser(u, chargeTime)\n\tif chargeDetail == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tUint64(\"appId\", uint64(u.AppId)).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"NO_RESOURCE_TO_CHARGE\")\n\t\treturn nil\n\t}\n\treturn c.ProcessChargeDetail(chargeDetail)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 105,
        "code_end_line": 116,
        "code_key": "Handle",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tif err := c.ensureLocks(ctx); err != nil {\n\t\treturn err\n\t}\n\tif c.lvUUID != nil {\n\t\t// 涉及到逻辑卷时，需要先标记逻辑卷为故障\n\t\treturn c.handleBindedVolume(ctx)\n\t} else {\n\t\t// 不涉及到逻辑卷时，直接标记物理卷为故障\n\t\treturn c.handleIdleVolume(ctx)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/detach_logical_volume.go",
        "code_start_line": 56,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *DetachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDetachLogicalVolume, c)\n\n\t// 如果没有挂载到指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume not attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_benchmark_task.go",
        "code_start_line": 125,
        "code_end_line": 165,
        "code_key": "Handle",
        "code_value": "func (c *CreateBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tvolSm     = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = volSm.Fire(ctx, c.relatedVolume.State, domain.PVEStartBenchmark, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark = benchmark.New(benchmark.DiskInfo{\n\t\tSerial: string(c.relatedVolume.Serial),\n\t\tHostIP: c.relatedVolume.IP,\n\t\tBDF:    string(c.relatedVolume.BDF),\n\t})\n\n\tif err = benchRepo.Add(ctx, c.relatedBenchmark); err != nil {\n\t\tdelegate := &benchmarkDelegate{cmd: c}\n\t\tif _err := delegate.TaskFinishCallback(ctx, c.relatedBenchmark); _err != nil {\n\t\t\tlogs.Warn(ctx).Err(_err).Str(\"serial\", string(c.relatedVolume.Serial)).Msg(\"failed to rollback: create bdev\")\n\t\t}\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventCreateBench,\n\t\tbenchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_logical_volume.go",
        "code_start_line": 71,
        "code_end_line": 108,
        "code_key": "Handle",
        "code_value": "func (d *DeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\td.volume, err = repo.FindByID(ctx, d.UUID)\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif e := d.volume.CheckDelete(); e != nil {\n\t\treturn e\n\t}\n\n\tif d.volume.AppID != d.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"refuse to delet: app id mismatch\")\n\t}\n\n\td.drgroup, err = app.GetRegistry(ctx).Repositories.DRGroup.FindByMember(ctx, d.AppID, d.volume.UUID.String())\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\td.drgroup = nil\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := d.checkDRGroupMatch(ctx); err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, d.volume.State, rdiskDomain.LVEMarkToRecycle, d)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_recycled_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmRecycledPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEConfirmRecycled, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_rdisk_backup.go",
        "code_start_line": 52,
        "code_end_line": 75,
        "code_key": "Handle",
        "code_value": "func (c *DeleteRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tsm   = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\tc.relatedBackup, err = repo.FindByUUID(ctx, c.BackupID.String())\n\tif err != nil || c.relatedBackup == nil || c.relatedBackup.AppID != c.AppID {\n\t\treturn errors.New(backupDomain.ErrBackupNotExist, \"backup not exists\")\n\t}\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tc.relatedBackup.Status,\n\t\tbackupDomain.EventSoftDeleteBackup,\n\t\tbackupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: c.relatedBackup})\n\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_rdisk_backup.go",
        "code_start_line": 47,
        "code_end_line": 80,
        "code_key": "Handle",
        "code_value": "func (c *CreateRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tlvSm  = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\tbakSm = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo  = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t_, err = lvSm.Fire(ctx, c.relatedVolume.State, rdiskDomain.LVEBackupStarted, c)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tlv := c.relatedVolume\n\tbackup := backupDomain.New(\n\t\tlv.AppID,\n\t\tbackupDomain.DiskInfo{\n\t\t\tVolumeUUID: lv.UUID,\n\t\t\tVolumeSize: uint64(lv.Size),\n\t\t\tHostIP:     lv.PhysicalVolume.IP,\n\t\t\tHostBDF:    string(lv.PhysicalVolume.BDF),\n\t\t\tSerial:     string(lv.PhysicalVolume.Serial),\n\t\t},\n\t)\n\tif err := repo.Add(ctx, backup); err != nil {\n\t\treturn err\n\t}\n\tc.relatedBackup = backup\n\t_, err = bakSm.Fire(ctx, backupDomain.StatusInit, backupDomain.EventStartBackup, backupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: backup})\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/attach_logical_volume.go",
        "code_start_line": 49,
        "code_end_line": 71,
        "code_key": "Handle",
        "code_value": "func (c *AttachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEAttachLogicalVolume, c)\n\n\t// 如果已经挂载到了指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeAlreadyAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume already attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_delete_logical_volume.go",
        "code_start_line": 34,
        "code_end_line": 55,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\t// 如果逻辑卷不存在，则直接返回成功\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"failed to confirm delete: app id mismatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDeleteLogicalVolume, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/offline_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OfflinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOfflinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *DeletePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\t// 如果物理卷不存在，则直接幂等返回\n\t\treturn nil\n\t}\n\n\tvar event = domain.PVEDeletePhysicalVolume\n\tif c.Force && (c.relatedVolume.State == domain.PVSDefunct) {\n\t\t// 这里的实现不太好，状态机的逻辑不应该侵入 cmd\n\t\t// 时间太赶了，后续重构优化吧\n\t\tevent = domain.PVEForceDeleteForDefunct\n\t}\n\n\tif c.relatedVolume.HasBindedPV() {\n\t\treturn errors.New(domain.ErrVolumeBusy, \"logic volume has binded to this physical volume\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, event, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_logical_volume.go",
        "code_start_line": 55,
        "code_end_line": 70,
        "code_key": "Handle",
        "code_value": "func (c *CleanupLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVECleanupLogicalVolume, c)\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_init_physical_volume.go",
        "code_start_line": 26,
        "code_end_line": 52,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmInitPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\tif c.relatedVolume.IP.String() != c.Host.String() {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume host ip mistmatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVECreatePhysicalVolumeOnHost, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_physical_volume.go",
        "code_start_line": 51,
        "code_end_line": 101,
        "code_key": "Handle",
        "code_value": "func (c *CreatePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\n\t// 获取物理卷状态机\n\tsm := app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\trepo := app.GetRegistry(ctx).Repositories.PhysicalVolume\n\n\t// 检查物理卷是否已经存在，如果存在则直接幂等返回\n\tvol1, err := repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"serial\", c.Serial).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tvol2, err := repo.FindByIPAndBDF(ctx, c.Host, domain.BDF(c.BDF))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"host\", c.Host.String()).Str(\"bdf\", c.BDF).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tfor _, vol := range []*domain.PhysicalVolume{vol1, vol2} {\n\t\texisted, err := c.checkExisting(ctx, vol)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif existed {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// 触发事件，创建物理卷\n\t_, err = sm.Fire(ctx,\n\t\tdomain.PVSUnInited,\n\t\tdomain.PVECreatePhysicalVolume,\n\t\tc,\n\t)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 创建 Bdev 以及格式化移动到创建物理卷的状态机中\n\n\t// _, err = sm.Fire(ctx,\n\t// \tc.GetPhysicalVolume().State,\n\t// \tdomain.PVECreatePhysicalVolumeOnHost,\n\t// \tc,\n\t// )\n\t// if err != nil {\n\t// \treturn err\n\t// }\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_benchmark_task.go",
        "code_start_line": 32,
        "code_end_line": 57,
        "code_key": "Handle",
        "code_value": "func (c *DeleteBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\terr       error\n\t)\n\n\tbench, err := benchRepo.FindByUUID(ctx, c.BenchmarkUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif bench.DiskInfo.Serial != c.Serial {\n\t\treturn errors.Newf(benchmark.ErrTaskNotFound, \"benchmark serial not match %s, want %s\", c.Serial, bench.DiskInfo.Serial)\n\t}\n\n\t_, err = benchSm.Fire(ctx, bench.Status, benchmark.EventDeleteBench, benchmark.Data{Benchmark: bench, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := benchRepo.Delete(ctx, bench); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_logical_volume.go",
        "code_start_line": 52,
        "code_end_line": 98,
        "code_key": "Handle",
        "code_value": "func (c *CreateLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tpvRepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tlvRepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm     = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\t// 1. 查找底层物理卷\n\tc.selectedPhysicalVolume, err = pvRepo.FindBySerial(ctx, rdiskDomain.Serial(c.PhysicalVolumeSerial))\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// 检查底层物理卷大小是否满足要求\n\tif c.selectedPhysicalVolume.Size < rdiskDomain.Size(c.DiskSize) {\n\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume size %d is smaller than requested size %d\", c.selectedPhysicalVolume.Size, c.DiskSize)\n\t}\n\n\t// 检查底层物理卷性能等级是否满足要求\n\tif c.PerformanceRank != \"\" {\n\t\tif string(c.selectedPhysicalVolume.PerformanceRank) != c.PerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not match requested rank %s\", c.selectedPhysicalVolume.PerformanceRank, c.PerformanceRank)\n\t\t}\n\t} else {\n\t\tif c.selectedPhysicalVolume.PerformanceRank != rdiskDomain.DefaultPerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not default rank %s\", c.selectedPhysicalVolume.PerformanceRank, rdiskDomain.DefaultPerformanceRank)\n\t\t}\n\t}\n\n\t// 2. 创建逻辑卷\n\tvol := rdiskDomain.NewLogicalVolume(users.AppID(c.AppID), rdiskDomain.Size(c.DiskSize), rdiskDomain.ZoneID(c.ZoneID))\n\tif c.VolumeType != \"\" {\n\t\tvol.VolumeType = rdiskDomain.VolumeType(c.VolumeType)\n\t}\n\tif c.DiskType != \"\" {\n\t\tvol.DiskType = rdiskDomain.DiskType(c.DiskType)\n\t}\n\terr = lvRepo.Add(ctx, vol)\n\tif err != nil {\n\t\treturn\n\t}\n\tc.createdLogicalVolume = vol\n\n\t// 3. 触发状态机，联动更新逻辑卷和物理卷状态\n\t_, err = sm.Fire(ctx, rdiskDomain.LVSUnInited, rdiskDomain.LVECreateLogicalVolume, c)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_running_backup_task.go",
        "code_start_line": 31,
        "code_end_line": 61,
        "code_key": "Handle",
        "code_value": "func (c *UpdateRunningBackupTaskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventUpdateBackupProgress,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_drgroup.go",
        "code_start_line": 78,
        "code_end_line": 173,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeDRGroupCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tlvView  = app.GetRegistry(ctx).Viewers.LogicalVolume\n\t\tdrgRepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t\tsm      = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\terr     error\n\t)\n\n\t// 0. 初始化\n\tc.drgroupRef = make(map[string]*drgroup.DRGroup)\n\n\t// 1. 加载所有逻辑卷所在的置放群组\n\tallVolumeUUIDs := make([]string, 0, len(c.UUIDs))\n\tfor _, _uuid := range c.UUIDs {\n\t\tallVolumeUUIDs = append(allVolumeUUIDs, _uuid.String())\n\t}\n\tif groups, err := drgRepo.FindByMembers(ctx, c.AppID, allVolumeUUIDs); err == nil {\n\t\tif err != nil {\n\t\t\tif !errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tfor _, group := range groups {\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t\tc.curDRGroupNames = append(c.curDRGroupNames, group.Name)\n\t\t}\n\t} else {\n\t\treturn err\n\t}\n\n\t// 2. 确认已上锁的置放群组和当前一致\n\tif !c.checkLockedDRGroupNames() {\n\t\treturn errors.New(drgroup.ErrGroupModified, \"drgroup changed\")\n\t}\n\n\t// 3. 加载所有逻辑卷的状态，不需要完整实体，因为不会修改 Volume\n\tc.relatedLogicalVolume, err = lvView.FindByIDs(ctx, c.AppID, c.UUIDs)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(c.relatedLogicalVolume) < len(c.UUIDs) {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t// 4. 加载所有目标置放群组，key 为 name\n\tfor _, spec := range c.Specs {\n\t\tvar group *drgroup.DRGroup\n\t\tif _, ok := c.drgroupRef[spec.Name]; ok {\n\t\t\tgroup = c.drgroupRef[spec.Name]\n\t\t} else {\n\t\t\tgroup, err = c.getOrCreateDRGroup(ctx, drgRepo, spec)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t}\n\n\t\tif spec.Affinity > 0 {\n\t\t\tgroup.Affinity = spec.Affinity\n\t\t}\n\t\tif spec.Type != \"\" {\n\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t}\n\t}\n\n\t// 5. 对所有逻辑卷执行置放群组变更事件，检查状态是否允许，\n\t//    实际的更新还是在这里执行。\n\tfor _, vol := range c.relatedLogicalVolume {\n\t\terr := sm.Check(ctx, vol.State, rdiskDomain.LVEUpdateDrGroup, c)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// 将逻辑卷从原有的置放群组中移除\n\t\tfor _, name := range c.curDRGroupNames {\n\t\t\tc.drgroupRef[name].RemoveMember(vol.UUID.String())\n\t\t}\n\t\t// 将逻辑卷添加到新的置放群组中\n\t\tfor _, spec := range c.Specs {\n\t\t\tsubGroup := spec.SubGroup\n\t\t\tif subGroup == \"\" {\n\t\t\t\t// 如果没有指定子组，则使用远端 SSD UUID 作为子组名称\n\t\t\t\t// 相当于每块盘都是一个子组，相当于没有使用子组功能\n\t\t\t\tsubGroup = vol.UUID.String()\n\t\t\t}\n\t\t\tif err := c.drgroupRef[spec.Name].AddMember(vol.UUID.String(), subGroup, vol.PhysicalVolume.IP.String()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tif c.DryRun {\n\t\treturn errors.New(errors.ErrDryRunSuccessExit, \"dry run check success\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/online_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OnlinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOnlinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_benchmark_task.go",
        "code_start_line": 34,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *UpdateBenchmarkTask) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, rdisk.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark, err = benchRepo.FindByUUID(ctx, c.BenchmarkUUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventUpdateBench, benchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_flow_ctrl.go",
        "code_start_line": 80,
        "code_end_line": 103,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeFlowControlCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not found\")\n\t}\n\n\tspec := c.volume.FlowControlSpec\n\tif !c.UpdateRequest.UpdateSpec(&spec, c.volume.GetDefaultFlowControlSpec()) {\n\t\t// 没有任何更新，直接返回成功\n\t\treturn nil\n\t}\n\tc.volume.SetFlowControlSpec(spec)\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEUpdateFlowControl, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_defunct_volume.go",
        "code_start_line": 46,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *CleanupDefunctCommand) Handle(ctx context.Context) error {\n\tvar err error\n\tc.lv, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar sm = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\tvar event = rdiskDomain.LVECleanupDefunct\n\n\tfor _, attachment := range c.lv.Attachments {\n\t\tlogs.Info(ctx).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).Msg(\"cleanup defuncting volume\")\n\t\tsubCmd := &cleanDefunctSubCommand{Parent: c, HostIP: attachment.IP}\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, subCmd)\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，因为只要有一个挂载点清理失败，其他挂载点还是需要继续清理的\n\t\t\t// 失败的挂载点会在后台继续清理\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).\n\t\t\t\tMsg(\"failed to cleanup defunct volume, retry later.\")\n\t\t}\n\t}\n\n\tif len(c.lv.Attachments) == 0 {\n\t\t// 没有挂载点，直接清理\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, &cleanDefunctSubCommand{Parent: c, HostIP: net.IP{}})\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，后续自动重试即可\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Msg(\"failed to complete cleanup defunct volume\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_drgroup_exists.go",
        "code_start_line": 28,
        "code_end_line": 53,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDRGroupExistsCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t)\n\tfor _, spec := range c.DRGroup {\n\t\t_, err := repo.FindByName(ctx, users.AppID(c.AppID), spec.Name)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\tgroup := drgroup.New(spec.Name, users.AppID(c.AppID))\n\t\t\t\tif spec.Affinity > 0 {\n\t\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t\t}\n\t\t\t\tif spec.Type != \"\" {\n\t\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t\t}\n\t\t\t\terr = repo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_physical_volume.go",
        "code_start_line": 31,
        "code_end_line": 54,
        "code_key": "Handle",
        "code_value": "func (c *UpdatePhyRDiskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEUpdatePhysicalVolume, c)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/recycle_backup_data.go",
        "code_start_line": 32,
        "code_end_line": 62,
        "code_key": "Handle",
        "code_value": "func (c *RecycleBackupDataCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventDeleteBackup,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 70,
        "code_end_line": 74,
        "code_key": "Prepare",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) Prepare(ctx context.Context) error {\n\tvar err error\n\tc.aquiredLocks, err = c.queryRequiredLocks(ctx)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_logical_volume.go",
        "code_start_line": 40,
        "code_end_line": 63,
        "code_key": "Prepare",
        "code_value": "func (d *DeleteLogicalVolumeCommand) Prepare(ctx context.Context) error {\n\t// 为什么需要先查询逻辑卷所在的置放群组呢？\n\t//\n\t// 为了避免进行并发修改置放群组产生竞争，必须要在启动时就得到置放群组名称以进行加锁。\n\t// 但是入参中带上置放群组名称显然已不合适，所以需要在 Prepare 阶段进行查询。\n\t// 然后在加锁后，在 Handle 阶段还需要进行校验，形成乐观锁的。\n\t// 如果 Handle 阶段查询到的置放群组 Name 和 Prepare 阶段查询到的不一致，则需要报错退出。\n\tviewer := app.GetRegistry(ctx).Viewers.DRGroup\n\n\t// 查找逻辑卷所在的置放群组\n\tgroup, err := viewer.FindByMembers(ctx, d.AppID, []string{d.UUID.String()})\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tfor _, group := range group {\n\t\td.relatedDRGroupNames = append(d.relatedDRGroupNames, group.Name)\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_drgroup.go",
        "code_start_line": 40,
        "code_end_line": 65,
        "code_key": "Prepare",
        "code_value": "func (c *UpdateLogicalVolumeDRGroupCommand) Prepare(ctx context.Context) error {\n\tview := app.GetRegistry(ctx).Viewers.DRGroup\n\tc.lockedDRGroupNames = make([]string, 0, len(c.Specs)*2)\n\tallGroupNames := make(map[string]interface{})\n\tallMembers := make([]string, 0, len(c.UUIDs))\n\tfor _, _uuid := range c.UUIDs {\n\t\tallMembers = append(allMembers, _uuid.String())\n\t}\n\tcurrentGroups, err := view.FindByMembers(ctx, c.AppID, allMembers)\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\tfor _, group := range currentGroups {\n\t\tallGroupNames[group.Name] = nil\n\t}\n\tfor _, spec := range c.Specs {\n\t\tallGroupNames[spec.Name] = nil\n\t}\n\tfor name := range allGroupNames {\n\t\tc.lockedDRGroupNames = append(c.lockedDRGroupNames, name)\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 239,
        "code_end_line": 245,
        "code_key": "queryDRGroup",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) queryDRGroup(ctx context.Context, lv string, appId users.AppID) ([]*drgroup.View, error) {\n\tgroups, err := app.GetRegistry(ctx).Viewers.DRGroup.FindByMembers(ctx, appId, []string{lv})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn groups, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
        "code_start_line": 54,
        "code_end_line": 56,
        "code_key": "FindByMember",
        "code_value": "func (d drgroupRepositoryImpl) FindByMember(ctx context.Context, appId users.AppID, member string) ([]*drgroup.DRGroup, error) {\n\treturn d.FindByMembers(ctx, appId, []string{member})\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 68,
        "code_end_line": 74,
        "code_key": "FindByMember",
        "code_value": "func (m *MockRepository) FindByMember(arg0 context.Context, arg1 users.AppID, arg2 string) ([]*drgroup.DRGroup, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindByMember\", arg0, arg1, arg2)\n\tret0, _ := ret[0].([]*drgroup.DRGroup)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/mocks/repo.go",
        "code_start_line": 77,
        "code_end_line": 80,
        "code_key": "FindByMember",
        "code_value": "func (mr *MockRepositoryMockRecorder) FindByMember(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindByMember\", reflect.TypeOf((*MockRepository)(nil).FindByMember), arg0, arg1, arg2)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/models.go",
        "code_start_line": 281,
        "code_end_line": 291,
        "code_key": "View",
        "code_value": "type View struct {\n\tID            uint64            // 群组 ID，用作实体 ID\n\tName          string            // 群组名称，在同一个 AppID 下必须唯一\n\tAppID         users.AppID       // 群组所属应用 ID\n\tType          LocType           // 群组类型，保留字段\n\tAffinity      int               // 亲和度，表示群组内成员在同一台位置上最多只能有多少个\n\tMemberCount   int               // 成员数量\n\tSubGroupCount int               // 子组数量\n\tSatisfied     bool              // 是否满足约束条件\n\tSubGroupMap   map[string]string // 成员 ID -> 子组名称的映射关系，注意这里可能只是部分成员的子集\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/backup/interfaces.go",
        "code_start_line": 11,
        "code_end_line": 19,
        "code_key": "View",
        "code_value": "type View struct {\n\tUUID       uuid.UUID    // 备份 UUID\n\tAppID      users.AppID  // 所属 AppID\n\tStatus     BackupStatus // 备份状态\n\tCreateTime time.Time    // 创建时间\n\tPercentage int          // 备份进度，0-100\n\tVolumeUUID uuid.UUID    // 远端 SSD UUID\n\tSize       uint64       // 备份大小(GB)\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 19,
        "code_end_line": 33,
        "code_key": "DmDrgroup",
        "code_value": "type DmDrgroup struct {\n\tID        uint64    `gorm:\"column:id;primaryKey\"`                              // 主键 ID\n\tStatus    int       `gorm:\"column:status\"`                                     // 状态, 目前无用\n\tAppID     int64     `gorm:\"column:app_id;index:dm_drgroup_app_id_name,unique\"` // AppID\n\tName      string    `gorm:\"column:name;index:dm_drgroup_app_id_name,unique\"`   // DRGroup 名称，用户名下唯一\n\tAffinity  int       `gorm:\"column:affinity\"`                                   // 亲和性\n\tLocType   string    `gorm:\"column:loc_type\"`                                   // 位置类型，对应 HOST、RACK、SWITCH 等等\n\tSatisfied int       `gorm:\"column:satisfied\"`                                  // 组内元素是否满足约束条件\n\tMemberCnt int       `gorm:\"column:member_cnt\"`                                 // 组内元素数量\n\tExtra     string    `gorm:\"column:extra\"`                                      // 额外信息\n\tCreated   time.Time `gorm:\"column:created\"`\n\tUpdated   time.Time `gorm:\"column:updated\"`\n\n\tMembers []DmDrgroupMembers `gorm:\"foreignKey:AppID,GroupName;references:AppID,Name\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 35,
        "code_end_line": 37,
        "code_key": "TableName",
        "code_value": "func (*DmDrgroup) TableName() string {\n\treturn \"dm_drgroup\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 114,
        "code_end_line": 129,
        "code_key": "DmDrgroup",
        "code_value": "type DmDrgroup struct {\n\tID          uint64    `gorm:\"column:id;primaryKey\"`                              // 主键 ID\n\tStatus      int       `gorm:\"column:status\"`                                     // 状态, 目前无用\n\tAppID       int64     `gorm:\"column:app_id;index:dm_drgroup_app_id_name,unique\"` // AppID\n\tName        string    `gorm:\"column:name;index:dm_drgroup_app_id_name,unique\"`   // DRGroup 名称，用户名下唯一\n\tAffinity    int       `gorm:\"column:affinity\"`                                   // 亲和性\n\tLocType     string    `gorm:\"column:loc_type\"`                                   // 位置类型，对应 HOST、RACK、SWITCH 等等\n\tSatisfied   int       `gorm:\"column:satisfied\"`                                  // 组内元素是否满足约束条件\n\tMemberCnt   int       `gorm:\"column:member_cnt\"`                                 // 组内元素数量\n\tSubGroupCnt int       `gorm:\"column:sub_group_cnt\"`                              // 子组数量\n\tExtra       string    `gorm:\"column:extra\"`                                      // 额外信息\n\tCreated     time.Time `gorm:\"column:created\"`\n\tUpdated     time.Time `gorm:\"column:updated\"`\n\n\tMembers []DmDrgroupMembers `gorm:\"foreignKey:AppID,GroupName;references:AppID,Name\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 131,
        "code_end_line": 133,
        "code_key": "TableName",
        "code_value": "func (*DmDrgroup) TableName() string {\n\treturn \"dm_drgroup\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 39,
        "code_end_line": 49,
        "code_key": "DmDrgroupMembers",
        "code_value": "type DmDrgroupMembers struct {\n\tID        uint64    `gorm:\"column:id;primaryKey\"`                                                          // 主键 ID\n\tAppID     int64     `gorm:\"column:app_id;index:dm_drgroup_members_app_id_group_name_member_id,unique\"`     // AppID\n\tGroupName string    `gorm:\"column:group_name;index:dm_drgroup_members_app_id_group_name_member_id,unique\"` // DRGroup 名称，用户名下唯一\n\tSubGroup  string    `gorm:\"column:sub_group\"`                                                              // 子组名称\n\tLoc       string    `gorm:\"column:loc\"`                                                                    // 位置信息，例如母机 IP\n\tMemberID  string    `gorm:\"column:member_id;index:dm_drgroup_members_app_id_group_name_member_id,unique\"`  // DRGroup 成员 ID，例如逻辑卷 UUID\n\tExtra     string    `gorm:\"column:extra\"`                                                                  // 额外信息\n\tCreated   time.Time `gorm:\"column:created\"`\n\tUpdated   time.Time `gorm:\"column:updated\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 55,
        "code_end_line": 57,
        "code_key": "TableName",
        "code_value": "func (DmDrgroupMembers) TableName() string {\n\treturn \"dm_drgroup_members\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 51,
        "code_end_line": 53,
        "code_key": "DBName",
        "code_value": "func (m DmDrgroupMembers) DBName() string {\n\treturn \"metadb\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 135,
        "code_end_line": 145,
        "code_key": "DmDrgroupMembers",
        "code_value": "type DmDrgroupMembers struct {\n\tID        uint64    `gorm:\"column:id;primaryKey\"`                                                          // 主键 ID\n\tAppID     int64     `gorm:\"column:app_id;index:dm_drgroup_members_app_id_group_name_member_id,unique\"`     // AppID\n\tGroupName string    `gorm:\"column:group_name;index:dm_drgroup_members_app_id_group_name_member_id,unique\"` // DRGroup 名称，用户名下唯一\n\tSubGroup  string    `gorm:\"column:sub_group\"`                                                              // 子组名称\n\tLoc       string    `gorm:\"column:loc\"`                                                                    // 位置信息，例如母机 IP\n\tMemberID  string    `gorm:\"column:member_id;index:dm_drgroup_members_app_id_group_name_member_id,unique\"`  // DRGroup 成员 ID，例如逻辑卷 UUID\n\tExtra     string    `gorm:\"column:extra\"`                                                                  // 额外信息\n\tCreated   time.Time `gorm:\"column:created\"`\n\tUpdated   time.Time `gorm:\"column:updated\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 147,
        "code_end_line": 149,
        "code_key": "TableName",
        "code_value": "func (DmDrgroupMembers) TableName() string {\n\treturn \"dm_drgroup_members\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go:165:277:updateDRGroup": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
    "code_start_line": 165,
    "code_end_line": 277,
    "code_start_column": 6,
    "code_key": "updateDRGroup",
    "code_value": "func updateDRGroup(ctx context.Context, item, originalState *drgroup.DRGroup) error {\n\tuow := getUow(ctx)\n\tcurDO := fromModelToDmDRGroup(item)\n\toriginalDO := fromModelToDmDRGroup(originalState)\n\tchanges := make(map[string]interface{})\n\tcheckChange := func(field string, cur interface{}, original interface{}) {\n\t\tif cur != original {\n\t\t\tif field == \"member_cnt\" || field == \"sub_group_cnt\" {\n\t\t\t\tdiff := cur.(int) - original.(int)\n\t\t\t\tif diff < 0 {\n\t\t\t\t\tchanges[field] = gorm.Expr(fmt.Sprintf(\"%s - %d\", field, -1*diff))\n\t\t\t\t} else {\n\t\t\t\t\tchanges[field] = gorm.Expr(fmt.Sprintf(\"%s + %d\", field, diff))\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tchanges[field] = cur\n\t\t\t}\n\t\t}\n\t}\n\tcheckChange(\"status\", curDO.Status, originalDO.Status)\n\tcheckChange(\"app_id\", curDO.AppID, originalDO.AppID)\n\tcheckChange(\"name\", curDO.Name, originalDO.Name)\n\tcheckChange(\"affinity\", curDO.Affinity, originalDO.Affinity)\n\tcheckChange(\"loc_type\", curDO.LocType, originalDO.LocType)\n\tcheckChange(\"satisfied\", curDO.Satisfied, originalDO.Satisfied)\n\tcheckChange(\"member_cnt\", curDO.MemberCnt, originalDO.MemberCnt)\n\tcheckChange(\"sub_group_cnt\", curDO.SubGroupCnt, originalDO.SubGroupCnt)\n\tcheckChange(\"extra\", curDO.Extra, originalDO.Extra)\n\n\tif len(changes) != 0 {\n\t\tchanges[\"updated\"] = uow.tx.NowFunc()\n\n\t\tresult := uow.tx.Model(curDO).Where(\"id = ?\", curDO.ID).Updates(changes)\n\t\tif result.Error != nil {\n\t\t\treturn result.Error\n\t\t}\n\t}\n\n\t// 更新成员信息\n\tallMembers := make(map[string]struct{})\n\ttype memberInfo struct {\n\t\tLoc      string\n\t\tSubGroup string\n\t}\n\toriginMembers := make(map[string]memberInfo)\n\tcurMembers := make(map[string]memberInfo)\n\tfor _, a := range item.GetMembers() {\n\t\tallMembers[a.ID] = struct{}{}\n\t\tcurMembers[a.ID] = memberInfo{\n\t\t\tLoc:      a.Location,\n\t\t\tSubGroup: a.SubGroup,\n\t\t}\n\t}\n\tfor _, a := range originalState.GetMembers() {\n\t\tallMembers[a.ID] = struct{}{}\n\t\toriginMembers[a.ID] = memberInfo{\n\t\t\tLoc:      a.Location,\n\t\t\tSubGroup: a.SubGroup,\n\t\t}\n\t}\n\n\tfor memberId := range allMembers {\n\t\tcurInfo, _ := curMembers[memberId]\n\t\toriginInfo, _ := originMembers[memberId]\n\t\tif originInfo.Loc == \"\" && curInfo.Loc != \"\" {\n\t\t\tdo := &metadb.DmDrgroupMembers{\n\t\t\t\tAppID:     int64(item.AppID),\n\t\t\t\tGroupName: item.Name,\n\t\t\t\tSubGroup:  curInfo.SubGroup,\n\t\t\t\tLoc:       curInfo.Loc,\n\t\t\t\tMemberID:  memberId,\n\t\t\t\tExtra:     \"{}\",\n\t\t\t\tCreated:   uow.tx.NowFunc(),\n\t\t\t\tUpdated:   uow.tx.NowFunc(),\n\t\t\t}\n\t\t\tresult := uow.tx.Create(do)\n\t\t\tif result.Error != nil {\n\t\t\t\treturn result.Error\n\t\t\t}\n\t\t} else if originInfo.Loc != \"\" && curInfo.Loc == \"\" {\n\t\t\tresult := uow.tx.Delete(&metadb.DmDrgroupMembers{},\n\t\t\t\t\"app_id = ? and group_name = ? and member_id = ?\",\n\t\t\t\toriginalState.AppID, originalState.Name, memberId)\n\t\t\tif result.Error != nil {\n\t\t\t\treturn result.Error\n\t\t\t}\n\t\t} else if originInfo.Loc != \"\" && curInfo.Loc != \"\" {\n\t\t\tchanges := make(map[string]interface{})\n\t\t\tcheckChange := func(field string, cur interface{}, original interface{}) {\n\t\t\t\tif cur != original {\n\t\t\t\t\tchanges[field] = cur\n\t\t\t\t}\n\t\t\t}\n\t\t\tcheckChange(\"loc\", curInfo.Loc, originInfo.Loc)\n\t\t\tcheckChange(\"app_id\", item.AppID, originalState.AppID)\n\t\t\tcheckChange(\"group_name\", item.Name, originalState.Name)\n\t\t\tcheckChange(\"sub_group\", curInfo.SubGroup, originInfo.SubGroup)\n\t\t\t//checkChange(\"extra\", \"{}\", \"{}\")\n\n\t\t\tif len(changes) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tchanges[\"updated\"] = uow.tx.NowFunc()\n\t\t\tresult := uow.tx.Model(&metadb.DmDrgroupMembers{}).Where(\n\t\t\t\t\"app_id = ? and group_name = ? and member_id = ?\",\n\t\t\t\toriginalState.AppID, originalState.Name, memberId).Updates(changes)\n\t\t\tif result.Error != nil {\n\t\t\t\treturn result.Error\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 4,
    "callers": [],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/model.go",
        "code_start_line": 10,
        "code_end_line": 12,
        "code_key": "Model",
        "code_value": "type Model struct {\n\tId ID `json:\"id\" gorm:\"primaryKey;autoIncrement;comment:主键\"`\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/repositories/drgroup.go",
        "code_start_line": 205,
        "code_end_line": 208,
        "code_key": "memberInfo",
        "code_value": "type memberInfo struct {\n\t\tLoc      string\n\t\tSubGroup string\n\t}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 39,
        "code_end_line": 49,
        "code_key": "DmDrgroupMembers",
        "code_value": "type DmDrgroupMembers struct {\n\tID        uint64    `gorm:\"column:id;primaryKey\"`                                                          // 主键 ID\n\tAppID     int64     `gorm:\"column:app_id;index:dm_drgroup_members_app_id_group_name_member_id,unique\"`     // AppID\n\tGroupName string    `gorm:\"column:group_name;index:dm_drgroup_members_app_id_group_name_member_id,unique\"` // DRGroup 名称，用户名下唯一\n\tSubGroup  string    `gorm:\"column:sub_group\"`                                                              // 子组名称\n\tLoc       string    `gorm:\"column:loc\"`                                                                    // 位置信息，例如母机 IP\n\tMemberID  string    `gorm:\"column:member_id;index:dm_drgroup_members_app_id_group_name_member_id,unique\"`  // DRGroup 成员 ID，例如逻辑卷 UUID\n\tExtra     string    `gorm:\"column:extra\"`                                                                  // 额外信息\n\tCreated   time.Time `gorm:\"column:created\"`\n\tUpdated   time.Time `gorm:\"column:updated\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 55,
        "code_end_line": 57,
        "code_key": "TableName",
        "code_value": "func (DmDrgroupMembers) TableName() string {\n\treturn \"dm_drgroup_members\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 51,
        "code_end_line": 53,
        "code_key": "DBName",
        "code_value": "func (m DmDrgroupMembers) DBName() string {\n\treturn \"metadb\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 135,
        "code_end_line": 145,
        "code_key": "DmDrgroupMembers",
        "code_value": "type DmDrgroupMembers struct {\n\tID        uint64    `gorm:\"column:id;primaryKey\"`                                                          // 主键 ID\n\tAppID     int64     `gorm:\"column:app_id;index:dm_drgroup_members_app_id_group_name_member_id,unique\"`     // AppID\n\tGroupName string    `gorm:\"column:group_name;index:dm_drgroup_members_app_id_group_name_member_id,unique\"` // DRGroup 名称，用户名下唯一\n\tSubGroup  string    `gorm:\"column:sub_group\"`                                                              // 子组名称\n\tLoc       string    `gorm:\"column:loc\"`                                                                    // 位置信息，例如母机 IP\n\tMemberID  string    `gorm:\"column:member_id;index:dm_drgroup_members_app_id_group_name_member_id,unique\"`  // DRGroup 成员 ID，例如逻辑卷 UUID\n\tExtra     string    `gorm:\"column:extra\"`                                                                  // 额外信息\n\tCreated   time.Time `gorm:\"column:created\"`\n\tUpdated   time.Time `gorm:\"column:updated\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 147,
        "code_end_line": 149,
        "code_key": "TableName",
        "code_value": "func (DmDrgroupMembers) TableName() string {\n\treturn \"dm_drgroup_members\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/benchmark.go:19:36:FindByDisk": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/benchmark.go",
    "code_start_line": 19,
    "code_end_line": 36,
    "code_start_column": 31,
    "code_key": "FindByDisk",
    "code_value": "func (v *benchmarkViewerImpl) FindByDisk(ctx context.Context, diskSerial string, bakUuids []string) ([]*benchmark.Benchmark, error) {\n\tvar (\n\t\tviews          []*benchmark.Benchmark\n\t\tdtos           []*metadb.DmRdiskBenchmark\n\t\tMaxResultCount = 20\n\t)\n\tquery := v.db.WithContext(ctx).Where(\"phy_id = ?\", diskSerial)\n\tif len(bakUuids) > 0 {\n\t\tquery = query.Where(\"uuid IN ?\", bakUuids)\n\t}\n\tquery = query.Order(\"created DESC\").Limit(MaxResultCount)\n\tresult := query.Find(&dtos)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\tviews = functools.MapTo(dtos, functools.MapRef(make([]benchmark.Benchmark, len(dtos))), v.translate)\n\treturn views, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 759,
        "code_end_line": 761,
        "code_key": "QueryPhyRDiskBenchmark",
        "code_value": "func (s *UnimplementedMaster) QueryPhyRDiskBenchmark(ctx context.Context, req *QueryPhyRDiskBenchmarkRequest) (*QueryPhyRDiskBenchmarkResponse, error) {\n\treturn nil, errors.New(\"rpc QueryPhyRDiskBenchmark of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1297,
        "code_end_line": 1315,
        "code_key": "QueryPhyRDiskBenchmark",
        "code_value": "func (c *MasterClientProxyImpl) QueryPhyRDiskBenchmark(ctx context.Context, req *QueryPhyRDiskBenchmarkRequest, opts ...client.Option) (*QueryPhyRDiskBenchmarkResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/QueryPhyRDiskBenchmark\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"QueryPhyRDiskBenchmark\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &QueryPhyRDiskBenchmarkResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 294,
        "code_end_line": 300,
        "code_key": "QueryPhyRDiskBenchmark",
        "code_value": "func (m *MockMasterService) QueryPhyRDiskBenchmark(ctx context.Context, req *QueryPhyRDiskBenchmarkRequest) (*QueryPhyRDiskBenchmarkResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"QueryPhyRDiskBenchmark\", ctx, req)\n\tret0, _ := ret[0].(*QueryPhyRDiskBenchmarkResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 303,
        "code_end_line": 306,
        "code_key": "QueryPhyRDiskBenchmark",
        "code_value": "func (mr *MockMasterServiceMockRecorder) QueryPhyRDiskBenchmark(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryPhyRDiskBenchmark\", reflect.TypeOf((*MockMasterService)(nil).QueryPhyRDiskBenchmark), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 777,
        "code_end_line": 787,
        "code_key": "QueryPhyRDiskBenchmark",
        "code_value": "func (m *MockMasterClientProxy) QueryPhyRDiskBenchmark(ctx context.Context, req *QueryPhyRDiskBenchmarkRequest, opts ...client.Option) (*QueryPhyRDiskBenchmarkResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"QueryPhyRDiskBenchmark\", varargs...)\n\tret0, _ := ret[0].(*QueryPhyRDiskBenchmarkResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 790,
        "code_end_line": 794,
        "code_key": "QueryPhyRDiskBenchmark",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) QueryPhyRDiskBenchmark(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryPhyRDiskBenchmark\", reflect.TypeOf((*MockMasterClientProxy)(nil).QueryPhyRDiskBenchmark), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 127,
        "code_end_line": 177,
        "code_key": "QueryPhyRDiskBenchmark",
        "code_value": "func (*masterApiServerImpl) QueryPhyRDiskBenchmark(ctx context.Context, req *pb.QueryPhyRDiskBenchmarkRequest) (*pb.QueryPhyRDiskBenchmarkResponse, error) {\n\tvar (\n\t\tviewer     = app.GetRegistry(ctx).Viewers.Benchmark\n\t\tdiskSerial = req.PhyId\n\t\tbakUuids   = req.TaskId\n\t\tresp       = &pb.QueryPhyRDiskBenchmarkResponse{}\n\t)\n\n\tif len(bakUuids) == 0 {\n\t\tbakUuids = nil\n\t}\n\n\tresults, err := viewer.FindByDisk(ctx, diskSerial, bakUuids)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tencodeFunc := func(b *benchmark.Benchmark, r *pb.BenchmarkResult) {\n\t\tr.TaskId = b.UUID.String()\n\t\tr.PhyId = b.DiskInfo.Serial\n\t\tr.ErrorMsg = b.Error\n\t\tr.HostIp = b.DiskInfo.HostIP.String()\n\t\tr.BdfId = b.DiskInfo.BDF\n\t\tr.Created = timestamppb.New(b.Created)\n\t\tr.Finished = timestamppb.New(b.Finished)\n\t\tr.ReadBw = b.Stat.ReadBandwidth\n\t\tr.WriteBw = b.Stat.WriteBandwidth\n\t\tr.ReadLat = b.Stat.ReadLatency\n\t\tr.WriteLat = b.Stat.WriteLatency\n\t\tswitch b.Status {\n\t\tcase benchmark.StatusInited:\n\t\t\tr.Status = \"inited\"\n\t\tcase benchmark.StatusRunning:\n\t\t\tr.Status = \"running\"\n\t\tcase benchmark.StatusFailed:\n\t\t\tr.Status = \"failed\"\n\t\tcase benchmark.StatusSuccess:\n\t\t\tr.Status = \"success\"\n\t\tdefault:\n\t\t\tr.Status = \"unknown\"\n\t\t}\n\t}\n\n\tresp.Result = functools.MapTo(\n\t\tresults,\n\t\tfunctools.MapRef(make([]pb.BenchmarkResult, len(results))),\n\t\tencodeFunc,\n\t)\n\n\treturn resp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/benchmark/benchmark.go",
        "code_start_line": 73,
        "code_end_line": 83,
        "code_key": "Benchmark",
        "code_value": "type Benchmark struct {\n\tID       uint64          // 主键 ID\n\tUUID     uuid.UUID       // 压测 UUID\n\tStatus   Status          // 压测状态\n\tDiskInfo DiskInfo        // 压测磁盘信息\n\tTaskID   uint64          // 任务 ID (BlockAgent 任务 ID)\n\tStat     PerformanceStat // 性能统计数据\n\tError    string          // 错误信息\n\tCreated  time.Time       // 创建时间\n\tFinished time.Time       // 完成时间\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 176,
        "code_end_line": 193,
        "code_key": "DmRdiskBenchmark",
        "code_value": "type DmRdiskBenchmark struct {\n\tID             uint64    `gorm:\"column:id;primaryKey\"`   // 主键 ID\n\tUUID           string    `gorm:\"column:uuid\"`            // 备份 UUID\n\tPhyID          string    `gorm:\"column:phy_id\"`          // 物理卷 Serial\n\tBDF            string    `gorm:\"column:host_bdf\"`        // 物理盘 BDF 号\n\tError          string    `gorm:\"column:error\"`           // 错误信息\n\tTaskID         int64     `gorm:\"column:task_id\"`         // BlockAgent 任务 ID\n\tHostIP         string    `gorm:\"column:host_ip\"`         // 主机 IP\n\tStatus         int       `gorm:\"column:status\"`          // 备份状态\n\tReadBandwidth  float64   `gorm:\"column:read_bandwidth\"`  // 最大读带宽 in MBps\n\tWriteBandwidth float64   `gorm:\"column:write_bandwidth\"` // 最大写带宽 in MBps\n\tReadLatency    float64   `gorm:\"column:read_latency\"`    // 最大读延迟 in micro second\n\tWriteLatency   float64   `gorm:\"column:write_latency\"`   // 最大写延迟 in micro second\n\tCreated        time.Time `gorm:\"column:created\"`         // 压测创建时间\n\tFinished       time.Time `gorm:\"column:finished\"`        // 压测结束时间\n\tUpdated        time.Time `gorm:\"column:updated\"`         // 数据更新时间\n\tExtra          string    `gorm:\"column:extra\"`           // 额外信息\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 195,
        "code_end_line": 197,
        "code_key": "TableName",
        "code_value": "func (DmRdiskBenchmark) TableName() string {\n\treturn \"dm_phydisk_benchmark\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/benchmark.go:39:50:FindByStatus": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/benchmark.go",
    "code_start_line": 39,
    "code_end_line": 50,
    "code_start_column": 31,
    "code_key": "FindByStatus",
    "code_value": "func (v *benchmarkViewerImpl) FindByStatus(ctx context.Context, status []benchmark.Status) ([]*benchmark.Benchmark, error) {\n\tvar (\n\t\tviews []*benchmark.Benchmark\n\t\tdtos  []*metadb.DmRdiskBenchmark\n\t)\n\tresult := v.db.WithContext(ctx).Where(\"status in ?\", status).Find(&dtos)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\tviews = functools.MapTo(dtos, functools.MapRef(make([]benchmark.Benchmark, len(dtos))), v.translate)\n\treturn views, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/tasks/update_benchmark.go",
        "code_start_line": 25,
        "code_end_line": 52,
        "code_key": "Work",
        "code_value": "func (*UpdateBenchmarkTask) Work(ctx context.Context) error {\n\tvar (\n\t\tviewer     = app.GetRegistry(ctx).Viewers.Benchmark\n\t\tdispatcher = app.GetRegistry(ctx).Dispatcher\n\t)\n\n\t// 1. Find all running benchmarks\n\trunningStatus := []benchmark.Status{benchmark.StatusRunning}\n\tbenchs, err := viewer.FindByStatus(ctx, runningStatus)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 2. Fire events to update running benchmarks\n\tlogs.Info(ctx).Int(\"count\", len(benchs)).Msg(\"starts to update benchmark data\")\n\tfor _, b := range benchs {\n\t\tcmd := &commands.UpdateBenchmarkTask{\n\t\t\tSerial:        b.DiskInfo.Serial,\n\t\t\tBenchmarkUUID: b.UUID,\n\t\t}\n\t\terr := dispatcher.Dispatch(ctx, cmd)\n\t\tif err != nil {\n\t\t\tlogs.Warn(ctx).Err(err).Str(\"uuid\", b.UUID.String()).Msg(\"update benchmark task failed\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/tasks/cleanup_defunct.go",
        "code_start_line": 27,
        "code_end_line": 69,
        "code_key": "Work",
        "code_value": "func (*CleanupDefunctTask) Work(ctx context.Context) error {\n\tvar err error\n\tvar batchSize uint64 = 1000\n\tvar defunctingVolumes []*rdiskDomain.LogicalVolume\n\tdefunctingVolumes, err = app.GetRegistry(ctx).Viewers.LogicalVolume.FindByStatus(\n\t\tctx, []rdiskDomain.LogicalVolumeState{rdiskDomain.LVSDefuncting}, rdiskDomain.Pagination{Limit: batchSize})\n\tif err != nil {\n\t\tlogs.Error(ctx).Err(err).Msg(\"failed to find defuncting volumes\")\n\t\treturn err\n\t}\n\tif len(defunctingVolumes) == 0 {\n\t\tlogs.Debug(ctx).Msg(\"no defuncting volumes found\")\n\t\treturn nil\n\t}\n\n\tlogs.Info(ctx).Int(\"count\", len(defunctingVolumes)).Msg(\"starts to cleanup defuncting volumes\")\n\n\tvar waitInterval = time.Second * 10\n\tvar dispatcher = app.GetRegistry(ctx).Dispatcher\n\tfor _, volume := range defunctingVolumes {\n\t\tif ctx.Err() != nil {\n\t\t\t// 上下文已经被取消, 退出\n\t\t\treturn ctx.Err()\n\t\t}\n\t\tfunc(volume *rdiskDomain.LogicalVolume) {\n\t\t\tlogs.Info(ctx).Stringer(\"uuid\", volume.UUID).Msg(\"cleanuping defunct volume\")\n\t\t\tsubCtx, cancel := context.WithTimeout(ctx, waitInterval)\n\t\t\tdefer cancel()\n\t\t\tcmd := &commands.CleanupDefunctCommand{UUID: volume.UUID}\n\t\t\tif err := dispatcher.Dispatch(subCtx, cmd); err != nil {\n\t\t\t\tif err == subCtx.Err() {\n\t\t\t\t\t// 等待超时了，在后台 dispatcher 会继续清理，这里直接返回\n\t\t\t\t\tlogs.Info(subCtx).Stringer(\"uuid\", volume.UUID).Msg(\"timeout waiting for cleanup defunct volume, move up to next\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlogs.Error(subCtx).Err(err).Str(\"uuid\", volume.UUID.String()).Msg(\"failed to cleanup defunct volume\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tlogs.Info(subCtx).Stringer(\"uuid\", volume.UUID).Msg(\"cleanup defunct volume done\")\n\t\t}(volume)\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/tasks/update_backup.go",
        "code_start_line": 25,
        "code_end_line": 51,
        "code_key": "Work",
        "code_value": "func (*UpdateBackupTask) Work(ctx context.Context) error {\n\tvar (\n\t\tviewer     = app.GetRegistry(ctx).Viewers.Backup\n\t\tdispatcher = app.GetRegistry(ctx).Dispatcher\n\t)\n\n\t// 1. 查询所有正在备份的备份\n\tstatusList := []backup.BackupStatus{backup.StatusRunning}\n\tbaks, err := viewer.FindByStatus(ctx, statusList)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 2. 更新备份进度\n\tlogs.Info(ctx).Int(\"count\", len(baks)).Msg(\"starts to update running backup task\")\n\tfor _, bak := range baks {\n\t\tcmd := &commands.UpdateRunningBackupTaskCommand{\n\t\t\tUUID: bak.UUID,\n\t\t}\n\t\terr := dispatcher.Dispatch(ctx, cmd)\n\t\tif err != nil {\n\t\t\tlogs.Warn(ctx).Err(err).Str(\"uuid\", bak.UUID.String()).Msg(\"update backup task failed\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/tasks/confirm_init_physical_disk.go",
        "code_start_line": 25,
        "code_end_line": 63,
        "code_key": "Work",
        "code_value": "func (*ConfirmInitPhysicalDiskTask) Work(ctx context.Context) error {\n\tvar (\n\t\tviewer     = app.GetRegistry(ctx).Viewers.PhysicalVolume\n\t\tdispatcher = app.GetRegistry(ctx).Dispatcher\n\t)\n\n\t// 1. 查询所有待初始化的物理卷\n\tcriteria := rdiskDomain.PVSearchCriteria{}\n\tcriteria.States = []rdiskDomain.PhysicalVolumeState{rdiskDomain.PVSInited}\n\tpagination := rdiskDomain.Pagination{Limit: 10}\n\n\tresults, err := viewer.Search(ctx, criteria, pagination)\n\tif err != nil {\n\t\tlogs.Warn(ctx).Err(err).Msg(\"search physical volume failed\")\n\t\treturn err\n\t}\n\n\tif len(results) == 0 {\n\t\tlogs.Debug(ctx).Msg(\"no physical volume to be initialized\")\n\t\treturn nil\n\t}\n\n\t// TODO: 是否可以增加一个退避机制，对于长时间没有成功初始化的物理卷，增加重试时间间隔\n\n\t// 2. 发起初始化\n\tlogs.Info(ctx).Int(\"count\", len(results)).Msg(\"starts to initialize disks\")\n\tfor _, vol := range results {\n\t\tcmd := &commands.ConfirmInitPhysicalVolumeCommand{\n\t\t\tSerial: string(vol.Serial),\n\t\t\tHost:   vol.IP,\n\t\t}\n\t\terr := dispatcher.Dispatch(ctx, cmd)\n\t\tif err != nil {\n\t\t\tlogs.Warn(ctx).Err(err).Str(\"serial\", string(vol.Serial)).Str(\"host_ip\", vol.IP.String()).Msg(\"confirm init physical volume failed\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/tasks/recycle_backup_data.go",
        "code_start_line": 25,
        "code_end_line": 51,
        "code_key": "Work",
        "code_value": "func (*RecycleBackupTask) Work(ctx context.Context) error {\n\tvar (\n\t\tviewer     = app.GetRegistry(ctx).Viewers.Backup\n\t\tdispatcher = app.GetRegistry(ctx).Dispatcher\n\t)\n\n\t// 1. 查询所有待删除的备份\n\tstatusList := []backup.BackupStatus{backup.StatusToDelete, backup.StatusFailed}\n\tbaks, err := viewer.FindByStatus(ctx, statusList)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 2. 发起清理数据\n\tlogs.Info(ctx).Int(\"count\", len(baks)).Msg(\"starts to recycle backup data\")\n\tfor _, bak := range baks {\n\t\tcmd := &commands.RecycleBackupDataCommand{\n\t\t\tUUID: bak.UUID,\n\t\t}\n\t\terr := dispatcher.Dispatch(ctx, cmd)\n\t\tif err != nil {\n\t\t\tlogs.Warn(ctx).Err(err).Str(\"uuid\", bak.UUID.String()).Msg(\"update backup task failed\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/benchmark/benchmark.go",
        "code_start_line": 73,
        "code_end_line": 83,
        "code_key": "Benchmark",
        "code_value": "type Benchmark struct {\n\tID       uint64          // 主键 ID\n\tUUID     uuid.UUID       // 压测 UUID\n\tStatus   Status          // 压测状态\n\tDiskInfo DiskInfo        // 压测磁盘信息\n\tTaskID   uint64          // 任务 ID (BlockAgent 任务 ID)\n\tStat     PerformanceStat // 性能统计数据\n\tError    string          // 错误信息\n\tCreated  time.Time       // 创建时间\n\tFinished time.Time       // 完成时间\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 176,
        "code_end_line": 193,
        "code_key": "DmRdiskBenchmark",
        "code_value": "type DmRdiskBenchmark struct {\n\tID             uint64    `gorm:\"column:id;primaryKey\"`   // 主键 ID\n\tUUID           string    `gorm:\"column:uuid\"`            // 备份 UUID\n\tPhyID          string    `gorm:\"column:phy_id\"`          // 物理卷 Serial\n\tBDF            string    `gorm:\"column:host_bdf\"`        // 物理盘 BDF 号\n\tError          string    `gorm:\"column:error\"`           // 错误信息\n\tTaskID         int64     `gorm:\"column:task_id\"`         // BlockAgent 任务 ID\n\tHostIP         string    `gorm:\"column:host_ip\"`         // 主机 IP\n\tStatus         int       `gorm:\"column:status\"`          // 备份状态\n\tReadBandwidth  float64   `gorm:\"column:read_bandwidth\"`  // 最大读带宽 in MBps\n\tWriteBandwidth float64   `gorm:\"column:write_bandwidth\"` // 最大写带宽 in MBps\n\tReadLatency    float64   `gorm:\"column:read_latency\"`    // 最大读延迟 in micro second\n\tWriteLatency   float64   `gorm:\"column:write_latency\"`   // 最大写延迟 in micro second\n\tCreated        time.Time `gorm:\"column:created\"`         // 压测创建时间\n\tFinished       time.Time `gorm:\"column:finished\"`        // 压测结束时间\n\tUpdated        time.Time `gorm:\"column:updated\"`         // 数据更新时间\n\tExtra          string    `gorm:\"column:extra\"`           // 额外信息\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 195,
        "code_end_line": 197,
        "code_key": "TableName",
        "code_value": "func (DmRdiskBenchmark) TableName() string {\n\treturn \"dm_phydisk_benchmark\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/benchmark/benchmark.go",
        "code_start_line": 25,
        "code_end_line": 25,
        "code_key": "Status",
        "code_value": "type Status int",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/logi_vol.go:21:46:FindByStatus": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/logi_vol.go",
    "code_start_line": 21,
    "code_end_line": 46,
    "code_start_column": 35,
    "code_key": "FindByStatus",
    "code_value": "func (v *logicalVolumeViewerImpl) FindByStatus(ctx context.Context, status []rdiskDomain.LogicalVolumeState, pagination rdiskDomain.Pagination) ([]*rdiskDomain.LogicalVolume, error) {\n\tif len(status) == 0 {\n\t\treturn nil, nil\n\t}\n\tvar volumes []*metadb.DmRdisk\n\tstmt := v.db.WithContext(ctx).Where(\"status in ?\",\n\t\tfunctools.Map(status, func(i rdiskDomain.LogicalVolumeState) int { return int(i) }))\n\tif pagination.Offset > 0 {\n\t\tstmt = stmt.Offset(int(pagination.Offset))\n\t}\n\tif pagination.Limit <= 0 {\n\t\tpagination.Limit = 10\n\t}\n\tresult := stmt.Preload(\"DmPhyDisk\").Limit(int(pagination.Limit)).Find(&volumes)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tresultViews := functools.MapRef(make([]rdiskDomain.LogicalVolume, len(volumes)))\n\tfor i := range volumes {\n\t\tv.translate(volumes[i], resultViews[i])\n\t}\n\treturn resultViews, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/tasks/update_benchmark.go",
        "code_start_line": 25,
        "code_end_line": 52,
        "code_key": "Work",
        "code_value": "func (*UpdateBenchmarkTask) Work(ctx context.Context) error {\n\tvar (\n\t\tviewer     = app.GetRegistry(ctx).Viewers.Benchmark\n\t\tdispatcher = app.GetRegistry(ctx).Dispatcher\n\t)\n\n\t// 1. Find all running benchmarks\n\trunningStatus := []benchmark.Status{benchmark.StatusRunning}\n\tbenchs, err := viewer.FindByStatus(ctx, runningStatus)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 2. Fire events to update running benchmarks\n\tlogs.Info(ctx).Int(\"count\", len(benchs)).Msg(\"starts to update benchmark data\")\n\tfor _, b := range benchs {\n\t\tcmd := &commands.UpdateBenchmarkTask{\n\t\t\tSerial:        b.DiskInfo.Serial,\n\t\t\tBenchmarkUUID: b.UUID,\n\t\t}\n\t\terr := dispatcher.Dispatch(ctx, cmd)\n\t\tif err != nil {\n\t\t\tlogs.Warn(ctx).Err(err).Str(\"uuid\", b.UUID.String()).Msg(\"update benchmark task failed\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/tasks/cleanup_defunct.go",
        "code_start_line": 27,
        "code_end_line": 69,
        "code_key": "Work",
        "code_value": "func (*CleanupDefunctTask) Work(ctx context.Context) error {\n\tvar err error\n\tvar batchSize uint64 = 1000\n\tvar defunctingVolumes []*rdiskDomain.LogicalVolume\n\tdefunctingVolumes, err = app.GetRegistry(ctx).Viewers.LogicalVolume.FindByStatus(\n\t\tctx, []rdiskDomain.LogicalVolumeState{rdiskDomain.LVSDefuncting}, rdiskDomain.Pagination{Limit: batchSize})\n\tif err != nil {\n\t\tlogs.Error(ctx).Err(err).Msg(\"failed to find defuncting volumes\")\n\t\treturn err\n\t}\n\tif len(defunctingVolumes) == 0 {\n\t\tlogs.Debug(ctx).Msg(\"no defuncting volumes found\")\n\t\treturn nil\n\t}\n\n\tlogs.Info(ctx).Int(\"count\", len(defunctingVolumes)).Msg(\"starts to cleanup defuncting volumes\")\n\n\tvar waitInterval = time.Second * 10\n\tvar dispatcher = app.GetRegistry(ctx).Dispatcher\n\tfor _, volume := range defunctingVolumes {\n\t\tif ctx.Err() != nil {\n\t\t\t// 上下文已经被取消, 退出\n\t\t\treturn ctx.Err()\n\t\t}\n\t\tfunc(volume *rdiskDomain.LogicalVolume) {\n\t\t\tlogs.Info(ctx).Stringer(\"uuid\", volume.UUID).Msg(\"cleanuping defunct volume\")\n\t\t\tsubCtx, cancel := context.WithTimeout(ctx, waitInterval)\n\t\t\tdefer cancel()\n\t\t\tcmd := &commands.CleanupDefunctCommand{UUID: volume.UUID}\n\t\t\tif err := dispatcher.Dispatch(subCtx, cmd); err != nil {\n\t\t\t\tif err == subCtx.Err() {\n\t\t\t\t\t// 等待超时了，在后台 dispatcher 会继续清理，这里直接返回\n\t\t\t\t\tlogs.Info(subCtx).Stringer(\"uuid\", volume.UUID).Msg(\"timeout waiting for cleanup defunct volume, move up to next\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlogs.Error(subCtx).Err(err).Str(\"uuid\", volume.UUID.String()).Msg(\"failed to cleanup defunct volume\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tlogs.Info(subCtx).Stringer(\"uuid\", volume.UUID).Msg(\"cleanup defunct volume done\")\n\t\t}(volume)\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/tasks/update_backup.go",
        "code_start_line": 25,
        "code_end_line": 51,
        "code_key": "Work",
        "code_value": "func (*UpdateBackupTask) Work(ctx context.Context) error {\n\tvar (\n\t\tviewer     = app.GetRegistry(ctx).Viewers.Backup\n\t\tdispatcher = app.GetRegistry(ctx).Dispatcher\n\t)\n\n\t// 1. 查询所有正在备份的备份\n\tstatusList := []backup.BackupStatus{backup.StatusRunning}\n\tbaks, err := viewer.FindByStatus(ctx, statusList)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 2. 更新备份进度\n\tlogs.Info(ctx).Int(\"count\", len(baks)).Msg(\"starts to update running backup task\")\n\tfor _, bak := range baks {\n\t\tcmd := &commands.UpdateRunningBackupTaskCommand{\n\t\t\tUUID: bak.UUID,\n\t\t}\n\t\terr := dispatcher.Dispatch(ctx, cmd)\n\t\tif err != nil {\n\t\t\tlogs.Warn(ctx).Err(err).Str(\"uuid\", bak.UUID.String()).Msg(\"update backup task failed\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/tasks/confirm_init_physical_disk.go",
        "code_start_line": 25,
        "code_end_line": 63,
        "code_key": "Work",
        "code_value": "func (*ConfirmInitPhysicalDiskTask) Work(ctx context.Context) error {\n\tvar (\n\t\tviewer     = app.GetRegistry(ctx).Viewers.PhysicalVolume\n\t\tdispatcher = app.GetRegistry(ctx).Dispatcher\n\t)\n\n\t// 1. 查询所有待初始化的物理卷\n\tcriteria := rdiskDomain.PVSearchCriteria{}\n\tcriteria.States = []rdiskDomain.PhysicalVolumeState{rdiskDomain.PVSInited}\n\tpagination := rdiskDomain.Pagination{Limit: 10}\n\n\tresults, err := viewer.Search(ctx, criteria, pagination)\n\tif err != nil {\n\t\tlogs.Warn(ctx).Err(err).Msg(\"search physical volume failed\")\n\t\treturn err\n\t}\n\n\tif len(results) == 0 {\n\t\tlogs.Debug(ctx).Msg(\"no physical volume to be initialized\")\n\t\treturn nil\n\t}\n\n\t// TODO: 是否可以增加一个退避机制，对于长时间没有成功初始化的物理卷，增加重试时间间隔\n\n\t// 2. 发起初始化\n\tlogs.Info(ctx).Int(\"count\", len(results)).Msg(\"starts to initialize disks\")\n\tfor _, vol := range results {\n\t\tcmd := &commands.ConfirmInitPhysicalVolumeCommand{\n\t\t\tSerial: string(vol.Serial),\n\t\t\tHost:   vol.IP,\n\t\t}\n\t\terr := dispatcher.Dispatch(ctx, cmd)\n\t\tif err != nil {\n\t\t\tlogs.Warn(ctx).Err(err).Str(\"serial\", string(vol.Serial)).Str(\"host_ip\", vol.IP.String()).Msg(\"confirm init physical volume failed\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/tasks/recycle_backup_data.go",
        "code_start_line": 25,
        "code_end_line": 51,
        "code_key": "Work",
        "code_value": "func (*RecycleBackupTask) Work(ctx context.Context) error {\n\tvar (\n\t\tviewer     = app.GetRegistry(ctx).Viewers.Backup\n\t\tdispatcher = app.GetRegistry(ctx).Dispatcher\n\t)\n\n\t// 1. 查询所有待删除的备份\n\tstatusList := []backup.BackupStatus{backup.StatusToDelete, backup.StatusFailed}\n\tbaks, err := viewer.FindByStatus(ctx, statusList)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 2. 发起清理数据\n\tlogs.Info(ctx).Int(\"count\", len(baks)).Msg(\"starts to recycle backup data\")\n\tfor _, bak := range baks {\n\t\tcmd := &commands.RecycleBackupDataCommand{\n\t\t\tUUID: bak.UUID,\n\t\t}\n\t\terr := dispatcher.Dispatch(ctx, cmd)\n\t\tif err != nil {\n\t\t\tlogs.Warn(ctx).Err(err).Str(\"uuid\", bak.UUID.String()).Msg(\"update backup task failed\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/benchmark/benchmark.go",
        "code_start_line": 25,
        "code_end_line": 25,
        "code_key": "Status",
        "code_value": "type Status int",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 5,
        "code_end_line": 27,
        "code_key": "DmRdisk",
        "code_value": "type DmRdisk struct {\n\tID                 uint64    `gorm:\"column:id;primaryKey\"`\n\tUUID               string    `gorm:\"column:uuid;unique\"`\n\tStatus             int       `gorm:\"column:status\"`\n\tAppID              int64     `gorm:\"column:app_id\"`\n\tSize               int64     `gorm:\"column:size\"`\n\tPhydiskSerial      string    `gorm:\"column:phydisk_serial\"`\n\tExtra              string    `gorm:\"column:extra\"`\n\tZoneID             int64     `gorm:\"column:zone_id\"`\n\tVolumeType         string    `gorm:\"column:volume_type\"`\n\tDiskType           string    `gorm:\"column:disk_type\"`\n\tReadIOPS           int64     `gorm:\"column:read_iops\"`\n\tReadBandwidth      int64     `gorm:\"column:read_bandwidth\"`\n\tWriteIOPS          int64     `gorm:\"column:write_iops\"`\n\tWriteBandwidth     int64     `gorm:\"column:write_bandwidth\"`\n\tReadWriteIOPS      int64     `gorm:\"column:rw_iops\"`\n\tReadWriteBandwidth int64     `gorm:\"column:rw_bandwidth\"`\n\tCreated            time.Time `gorm:\"column:created\"`\n\tUpdated            time.Time `gorm:\"column:updated\"`\n\n\tDmPhyDisk   *DmPhydisk          `gorm:\"foreignKey:Serial;references:PhydiskSerial\"`\n\tAttachments []DmRdiskAttachment `gorm:\"foreignKey:UUID;references:UUID\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 29,
        "code_end_line": 31,
        "code_key": "TableName",
        "code_value": "func (DmRdisk) TableName() string {\n\treturn \"dm_rdisk\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/constants.go",
        "code_start_line": 19,
        "code_end_line": 19,
        "code_key": "LogicalVolumeState",
        "code_value": "type LogicalVolumeState int",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 178,
        "code_end_line": 190,
        "code_key": "LogicalVolume",
        "code_value": "type LogicalVolume struct {\n\tEntityMixin\n\tUUID            uuid.UUID\n\tState           LogicalVolumeState\n\tSize            Size\n\tAppID           users.AppID\n\tZoneID          ZoneID\n\tDiskType        DiskType\n\tVolumeType      VolumeType\n\tFlowControlSpec FlowControlSpec\n\tPhysicalVolume  *PhysicalVolume\n\tAttachments     []*VolumeAttachment\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/backup.go:64:78:FindByStatus": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/backup.go",
    "code_start_line": 64,
    "code_end_line": 78,
    "code_start_column": 28,
    "code_key": "FindByStatus",
    "code_value": "func (v *backupViewerImpl) FindByStatus(ctx context.Context, status []backup.BackupStatus) ([]*backup.View, error) {\n\tvar (\n\t\tviews []*backup.View\n\t\tdtos  []*metadb.DmRdiskBackup\n\t)\n\tresult := v.db.WithContext(ctx).Find(&dtos, \"status in ?\", status)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\tviews = functools.MapRef(make([]backup.View, len(dtos)))\n\tfor i := range dtos {\n\t\tv.translate(dtos[i], views[i])\n\t}\n\treturn views, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/tasks/update_benchmark.go",
        "code_start_line": 25,
        "code_end_line": 52,
        "code_key": "Work",
        "code_value": "func (*UpdateBenchmarkTask) Work(ctx context.Context) error {\n\tvar (\n\t\tviewer     = app.GetRegistry(ctx).Viewers.Benchmark\n\t\tdispatcher = app.GetRegistry(ctx).Dispatcher\n\t)\n\n\t// 1. Find all running benchmarks\n\trunningStatus := []benchmark.Status{benchmark.StatusRunning}\n\tbenchs, err := viewer.FindByStatus(ctx, runningStatus)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 2. Fire events to update running benchmarks\n\tlogs.Info(ctx).Int(\"count\", len(benchs)).Msg(\"starts to update benchmark data\")\n\tfor _, b := range benchs {\n\t\tcmd := &commands.UpdateBenchmarkTask{\n\t\t\tSerial:        b.DiskInfo.Serial,\n\t\t\tBenchmarkUUID: b.UUID,\n\t\t}\n\t\terr := dispatcher.Dispatch(ctx, cmd)\n\t\tif err != nil {\n\t\t\tlogs.Warn(ctx).Err(err).Str(\"uuid\", b.UUID.String()).Msg(\"update benchmark task failed\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/tasks/cleanup_defunct.go",
        "code_start_line": 27,
        "code_end_line": 69,
        "code_key": "Work",
        "code_value": "func (*CleanupDefunctTask) Work(ctx context.Context) error {\n\tvar err error\n\tvar batchSize uint64 = 1000\n\tvar defunctingVolumes []*rdiskDomain.LogicalVolume\n\tdefunctingVolumes, err = app.GetRegistry(ctx).Viewers.LogicalVolume.FindByStatus(\n\t\tctx, []rdiskDomain.LogicalVolumeState{rdiskDomain.LVSDefuncting}, rdiskDomain.Pagination{Limit: batchSize})\n\tif err != nil {\n\t\tlogs.Error(ctx).Err(err).Msg(\"failed to find defuncting volumes\")\n\t\treturn err\n\t}\n\tif len(defunctingVolumes) == 0 {\n\t\tlogs.Debug(ctx).Msg(\"no defuncting volumes found\")\n\t\treturn nil\n\t}\n\n\tlogs.Info(ctx).Int(\"count\", len(defunctingVolumes)).Msg(\"starts to cleanup defuncting volumes\")\n\n\tvar waitInterval = time.Second * 10\n\tvar dispatcher = app.GetRegistry(ctx).Dispatcher\n\tfor _, volume := range defunctingVolumes {\n\t\tif ctx.Err() != nil {\n\t\t\t// 上下文已经被取消, 退出\n\t\t\treturn ctx.Err()\n\t\t}\n\t\tfunc(volume *rdiskDomain.LogicalVolume) {\n\t\t\tlogs.Info(ctx).Stringer(\"uuid\", volume.UUID).Msg(\"cleanuping defunct volume\")\n\t\t\tsubCtx, cancel := context.WithTimeout(ctx, waitInterval)\n\t\t\tdefer cancel()\n\t\t\tcmd := &commands.CleanupDefunctCommand{UUID: volume.UUID}\n\t\t\tif err := dispatcher.Dispatch(subCtx, cmd); err != nil {\n\t\t\t\tif err == subCtx.Err() {\n\t\t\t\t\t// 等待超时了，在后台 dispatcher 会继续清理，这里直接返回\n\t\t\t\t\tlogs.Info(subCtx).Stringer(\"uuid\", volume.UUID).Msg(\"timeout waiting for cleanup defunct volume, move up to next\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlogs.Error(subCtx).Err(err).Str(\"uuid\", volume.UUID.String()).Msg(\"failed to cleanup defunct volume\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tlogs.Info(subCtx).Stringer(\"uuid\", volume.UUID).Msg(\"cleanup defunct volume done\")\n\t\t}(volume)\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/tasks/update_backup.go",
        "code_start_line": 25,
        "code_end_line": 51,
        "code_key": "Work",
        "code_value": "func (*UpdateBackupTask) Work(ctx context.Context) error {\n\tvar (\n\t\tviewer     = app.GetRegistry(ctx).Viewers.Backup\n\t\tdispatcher = app.GetRegistry(ctx).Dispatcher\n\t)\n\n\t// 1. 查询所有正在备份的备份\n\tstatusList := []backup.BackupStatus{backup.StatusRunning}\n\tbaks, err := viewer.FindByStatus(ctx, statusList)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 2. 更新备份进度\n\tlogs.Info(ctx).Int(\"count\", len(baks)).Msg(\"starts to update running backup task\")\n\tfor _, bak := range baks {\n\t\tcmd := &commands.UpdateRunningBackupTaskCommand{\n\t\t\tUUID: bak.UUID,\n\t\t}\n\t\terr := dispatcher.Dispatch(ctx, cmd)\n\t\tif err != nil {\n\t\t\tlogs.Warn(ctx).Err(err).Str(\"uuid\", bak.UUID.String()).Msg(\"update backup task failed\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/tasks/confirm_init_physical_disk.go",
        "code_start_line": 25,
        "code_end_line": 63,
        "code_key": "Work",
        "code_value": "func (*ConfirmInitPhysicalDiskTask) Work(ctx context.Context) error {\n\tvar (\n\t\tviewer     = app.GetRegistry(ctx).Viewers.PhysicalVolume\n\t\tdispatcher = app.GetRegistry(ctx).Dispatcher\n\t)\n\n\t// 1. 查询所有待初始化的物理卷\n\tcriteria := rdiskDomain.PVSearchCriteria{}\n\tcriteria.States = []rdiskDomain.PhysicalVolumeState{rdiskDomain.PVSInited}\n\tpagination := rdiskDomain.Pagination{Limit: 10}\n\n\tresults, err := viewer.Search(ctx, criteria, pagination)\n\tif err != nil {\n\t\tlogs.Warn(ctx).Err(err).Msg(\"search physical volume failed\")\n\t\treturn err\n\t}\n\n\tif len(results) == 0 {\n\t\tlogs.Debug(ctx).Msg(\"no physical volume to be initialized\")\n\t\treturn nil\n\t}\n\n\t// TODO: 是否可以增加一个退避机制，对于长时间没有成功初始化的物理卷，增加重试时间间隔\n\n\t// 2. 发起初始化\n\tlogs.Info(ctx).Int(\"count\", len(results)).Msg(\"starts to initialize disks\")\n\tfor _, vol := range results {\n\t\tcmd := &commands.ConfirmInitPhysicalVolumeCommand{\n\t\t\tSerial: string(vol.Serial),\n\t\t\tHost:   vol.IP,\n\t\t}\n\t\terr := dispatcher.Dispatch(ctx, cmd)\n\t\tif err != nil {\n\t\t\tlogs.Warn(ctx).Err(err).Str(\"serial\", string(vol.Serial)).Str(\"host_ip\", vol.IP.String()).Msg(\"confirm init physical volume failed\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/tasks/recycle_backup_data.go",
        "code_start_line": 25,
        "code_end_line": 51,
        "code_key": "Work",
        "code_value": "func (*RecycleBackupTask) Work(ctx context.Context) error {\n\tvar (\n\t\tviewer     = app.GetRegistry(ctx).Viewers.Backup\n\t\tdispatcher = app.GetRegistry(ctx).Dispatcher\n\t)\n\n\t// 1. 查询所有待删除的备份\n\tstatusList := []backup.BackupStatus{backup.StatusToDelete, backup.StatusFailed}\n\tbaks, err := viewer.FindByStatus(ctx, statusList)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 2. 发起清理数据\n\tlogs.Info(ctx).Int(\"count\", len(baks)).Msg(\"starts to recycle backup data\")\n\tfor _, bak := range baks {\n\t\tcmd := &commands.RecycleBackupDataCommand{\n\t\t\tUUID: bak.UUID,\n\t\t}\n\t\terr := dispatcher.Dispatch(ctx, cmd)\n\t\tif err != nil {\n\t\t\tlogs.Warn(ctx).Err(err).Str(\"uuid\", bak.UUID.String()).Msg(\"update backup task failed\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/models.go",
        "code_start_line": 281,
        "code_end_line": 291,
        "code_key": "View",
        "code_value": "type View struct {\n\tID            uint64            // 群组 ID，用作实体 ID\n\tName          string            // 群组名称，在同一个 AppID 下必须唯一\n\tAppID         users.AppID       // 群组所属应用 ID\n\tType          LocType           // 群组类型，保留字段\n\tAffinity      int               // 亲和度，表示群组内成员在同一台位置上最多只能有多少个\n\tMemberCount   int               // 成员数量\n\tSubGroupCount int               // 子组数量\n\tSatisfied     bool              // 是否满足约束条件\n\tSubGroupMap   map[string]string // 成员 ID -> 子组名称的映射关系，注意这里可能只是部分成员的子集\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/backup/interfaces.go",
        "code_start_line": 11,
        "code_end_line": 19,
        "code_key": "View",
        "code_value": "type View struct {\n\tUUID       uuid.UUID    // 备份 UUID\n\tAppID      users.AppID  // 所属 AppID\n\tStatus     BackupStatus // 备份状态\n\tCreateTime time.Time    // 创建时间\n\tPercentage int          // 备份进度，0-100\n\tVolumeUUID uuid.UUID    // 远端 SSD UUID\n\tSize       uint64       // 备份大小(GB)\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 151,
        "code_end_line": 169,
        "code_key": "DmRdiskBackup",
        "code_value": "type DmRdiskBackup struct {\n\tID        uint64    `gorm:\"column:id;primaryKey\"` // 主键 ID\n\tAppID     int64     `gorm:\"column:app_id;\"`       // AppID\n\tUUID      string    `gorm:\"column:uuid;\"`         // 备份 UUID\n\tDiskUUID  string    `gorm:\"column:rdisk_uuid\"`    // RDisk UUID\n\tStatus    int       `gorm:\"column:status\"`        // 备份状态\n\tSize      uint64    `gorm:\"column:size\"`          // 远端 SSD 大小 in GiB\n\tPhyID     string    `gorm:\"column:phy_id\"`        // 物理卷 Serial\n\tHostIP    string    `gorm:\"column:host_ip\"`       // 主机 IP\n\tHostBDF   string    `gorm:\"column:host_bdf\"`      // 主机上物理盘 BDF 号\n\tCosAppId  int64     `gorm:\"column:cos_appid\"`     // COS AppId\n\tCosRegion string    `gorm:\"column:cos_region\"`    // COS 所在的地域，例如 gz\n\tCosBucket string    `gorm:\"column:cos_bucket\"`    // COS Bucket\n\tCosPath   string    `gorm:\"column:cos_path\"`      // COS Path\n\tPercent   int       `gorm:\"column:percent\"`       // 备份进度\n\tExtra     string    `gorm:\"column:extra\"`         // 额外信息\n\tCreated   time.Time `gorm:\"column:created\"`       // 备份创建时间\n\tUpdated   time.Time `gorm:\"column:updated\"`       // 备份更新时间\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 171,
        "code_end_line": 173,
        "code_key": "TableName",
        "code_value": "func (DmRdiskBackup) TableName() string {\n\treturn \"dm_rdisk_backup\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/benchmark/benchmark.go",
        "code_start_line": 25,
        "code_end_line": 25,
        "code_key": "Status",
        "code_value": "type Status int",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/phy_vol.go:59:64:GetAll": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/phy_vol.go",
    "code_start_line": 59,
    "code_end_line": 64,
    "code_start_column": 27,
    "code_key": "GetAll",
    "code_value": "func (impl *phyVolViewer) GetAll(ctx context.Context) ([]*rdiskDomain.PhysicalVolume, error) {\n\tvolumes := []*metadb.DmPhydisk{}\n\tresult := impl.db.WithContext(ctx).Find(&volumes)\n\tlogs.Info(ctx).Int64(\"count\", result.RowsAffected).Msg(\"query all physical volumes\")\n\treturn impl.dbToEntity(ctx, volumes), nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 65,
        "code_end_line": 82,
        "code_key": "DmPhydisk",
        "code_value": "type DmPhydisk struct {\n\tID         uint64    `gorm:\"column:id;primaryKey\"`\n\tSerial     string    `gorm:\"column:serial;unique\"`\n\tIP         string    `gorm:\"column:host_ip\"`\n\tBDF        string    `gorm:\"column:bdf\"`\n\tDiskID     uint64    `gorm:\"column:disk_id\"`\n\tPort       int       `gorm:\"column:port\"`\n\tStatus     int       `gorm:\"column:status\"`\n\tSize       uint32    `gorm:\"column:size\"`\n\tRealSize   int64     `gorm:\"column:real_size\"`\n\tBlockSize  int       `gorm:\"column:block_size\"`\n\tZoneID     uint64    `gorm:\"column:zone_id\"`\n\tVolumeType string    `gorm:\"column:volume_type\"`\n\tExtra      string    `gorm:\"column:extra\"`\n\tCreated    time.Time `gorm:\"column:created\"`\n\tUpdated    time.Time `gorm:\"column:updated\"`\n\tPerfRank   string    `gorm:\"column:perf_rank\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 85,
        "code_end_line": 87,
        "code_key": "TableName",
        "code_value": "func (d *DmPhydisk) TableName() string {\n\treturn \"dm_phydisk\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 90,
        "code_end_line": 92,
        "code_key": "DBName",
        "code_value": "func (d *DmPhydisk) DBName() string {\n\treturn \"metadb\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 57,
        "code_end_line": 75,
        "code_key": "DmPhydisk",
        "code_value": "type DmPhydisk struct {\n\tID              uint64    `gorm:\"column:id;primaryKey\"`\n\tSerial          string    `gorm:\"column:serial;unique\"`\n\tIP              string    `gorm:\"column:host_ip\"`\n\tBDF             string    `gorm:\"column:bdf\"`\n\tDiskID          uint64    `gorm:\"column:disk_id\"`\n\tPort            int       `gorm:\"column:port\"`\n\tStatus          int       `gorm:\"column:status\"`\n\tSize            int64     `gorm:\"column:size\"`\n\tRealSize        int64     `gorm:\"column:real_size\"`\n\tBlockSize       int       `gorm:\"column:block_size\"`\n\tZoneID          int64     `gorm:\"column:zone_id\"`\n\tVolumeType      string    `gorm:\"column:volume_type\"`\n\tExtra           string    `gorm:\"column:extra\"`\n\tNodeType        string    `gorm:\"column:node_type\"`\n\tCreated         time.Time `gorm:\"column:created\"`\n\tUpdated         time.Time `gorm:\"column:updated\"`\n\tPerformanceRank string    `gorm:\"column:perf_rank\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 77,
        "code_end_line": 79,
        "code_key": "TableName",
        "code_value": "func (DmPhydisk) TableName() string {\n\treturn \"dm_phydisk\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/phy_vol.go:66:71:GetAllAvailable": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/phy_vol.go",
    "code_start_line": 66,
    "code_end_line": 71,
    "code_start_column": 27,
    "code_key": "GetAllAvailable",
    "code_value": "func (impl *phyVolViewer) GetAllAvailable(ctx context.Context) ([]*rdiskDomain.PhysicalVolume, error) {\n\tvolumes := []*metadb.DmPhydisk{}\n\tresult := impl.db.WithContext(ctx).Find(&volumes, \"status = ?\", rdiskDomain.PVSOnline)\n\tlogs.Info(ctx).Int64(\"count\", result.RowsAffected).Msg(\"query all available physical volumes\")\n\treturn impl.dbToEntity(ctx, volumes), nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 65,
        "code_end_line": 82,
        "code_key": "DmPhydisk",
        "code_value": "type DmPhydisk struct {\n\tID         uint64    `gorm:\"column:id;primaryKey\"`\n\tSerial     string    `gorm:\"column:serial;unique\"`\n\tIP         string    `gorm:\"column:host_ip\"`\n\tBDF        string    `gorm:\"column:bdf\"`\n\tDiskID     uint64    `gorm:\"column:disk_id\"`\n\tPort       int       `gorm:\"column:port\"`\n\tStatus     int       `gorm:\"column:status\"`\n\tSize       uint32    `gorm:\"column:size\"`\n\tRealSize   int64     `gorm:\"column:real_size\"`\n\tBlockSize  int       `gorm:\"column:block_size\"`\n\tZoneID     uint64    `gorm:\"column:zone_id\"`\n\tVolumeType string    `gorm:\"column:volume_type\"`\n\tExtra      string    `gorm:\"column:extra\"`\n\tCreated    time.Time `gorm:\"column:created\"`\n\tUpdated    time.Time `gorm:\"column:updated\"`\n\tPerfRank   string    `gorm:\"column:perf_rank\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 85,
        "code_end_line": 87,
        "code_key": "TableName",
        "code_value": "func (d *DmPhydisk) TableName() string {\n\treturn \"dm_phydisk\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 90,
        "code_end_line": 92,
        "code_key": "DBName",
        "code_value": "func (d *DmPhydisk) DBName() string {\n\treturn \"metadb\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 57,
        "code_end_line": 75,
        "code_key": "DmPhydisk",
        "code_value": "type DmPhydisk struct {\n\tID              uint64    `gorm:\"column:id;primaryKey\"`\n\tSerial          string    `gorm:\"column:serial;unique\"`\n\tIP              string    `gorm:\"column:host_ip\"`\n\tBDF             string    `gorm:\"column:bdf\"`\n\tDiskID          uint64    `gorm:\"column:disk_id\"`\n\tPort            int       `gorm:\"column:port\"`\n\tStatus          int       `gorm:\"column:status\"`\n\tSize            int64     `gorm:\"column:size\"`\n\tRealSize        int64     `gorm:\"column:real_size\"`\n\tBlockSize       int       `gorm:\"column:block_size\"`\n\tZoneID          int64     `gorm:\"column:zone_id\"`\n\tVolumeType      string    `gorm:\"column:volume_type\"`\n\tExtra           string    `gorm:\"column:extra\"`\n\tNodeType        string    `gorm:\"column:node_type\"`\n\tCreated         time.Time `gorm:\"column:created\"`\n\tUpdated         time.Time `gorm:\"column:updated\"`\n\tPerformanceRank string    `gorm:\"column:perf_rank\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 77,
        "code_end_line": 79,
        "code_key": "TableName",
        "code_value": "func (DmPhydisk) TableName() string {\n\treturn \"dm_phydisk\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/phy_vol.go:74:79:QueryBySerial": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/phy_vol.go",
    "code_start_line": 74,
    "code_end_line": 79,
    "code_start_column": 27,
    "code_key": "QueryBySerial",
    "code_value": "func (impl *phyVolViewer) QueryBySerial(ctx context.Context, serials []string) ([]*rdiskDomain.PhysicalVolume, error) {\n\tvolumes := []*metadb.DmPhydisk{}\n\tresult := impl.db.WithContext(ctx).Find(&volumes, \"serial in ?\", serials)\n\tlogs.Info(ctx).Int64(\"count\", result.RowsAffected).Msg(\"query physical volumes by serial\")\n\treturn impl.dbToEntity(ctx, volumes), nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 644,
        "code_end_line": 646,
        "code_key": "CreateRDiskVol",
        "code_value": "func (s *UnimplementedMaster) CreateRDiskVol(ctx context.Context, req *CreateRDiskVolRequest) (*CreateRDiskVolResponse, error) {\n\treturn nil, errors.New(\"rpc CreateRDiskVol of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 837,
        "code_end_line": 855,
        "code_key": "CreateRDiskVol",
        "code_value": "func (c *MasterClientProxyImpl) CreateRDiskVol(ctx context.Context, req *CreateRDiskVolRequest, opts ...client.Option) (*CreateRDiskVolResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/CreateRDiskVol\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"CreateRDiskVol\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &CreateRDiskVolResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 174,
        "code_end_line": 180,
        "code_key": "CreateRDiskVol",
        "code_value": "func (m *MockMasterService) CreateRDiskVol(ctx context.Context, req *CreateRDiskVolRequest) (*CreateRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CreateRDiskVol\", ctx, req)\n\tret0, _ := ret[0].(*CreateRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 183,
        "code_end_line": 186,
        "code_key": "CreateRDiskVol",
        "code_value": "func (mr *MockMasterServiceMockRecorder) CreateRDiskVol(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateRDiskVol\", reflect.TypeOf((*MockMasterService)(nil).CreateRDiskVol), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 617,
        "code_end_line": 627,
        "code_key": "CreateRDiskVol",
        "code_value": "func (m *MockMasterClientProxy) CreateRDiskVol(ctx context.Context, req *CreateRDiskVolRequest, opts ...client.Option) (*CreateRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"CreateRDiskVol\", varargs...)\n\tret0, _ := ret[0].(*CreateRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 630,
        "code_end_line": 634,
        "code_key": "CreateRDiskVol",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) CreateRDiskVol(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateRDiskVol\", reflect.TypeOf((*MockMasterClientProxy)(nil).CreateRDiskVol), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 184,
        "code_end_line": 235,
        "code_key": "CreateRDiskVol",
        "code_value": "func (s *masterApiServerImpl) CreateRDiskVol(ctx context.Context, req *pb.CreateRDiskVolRequest) (*pb.CreateRDiskVolResponse, error) {\n\tvar (\n\t\terr           error\n\t\tresponse      *pb.CreateRDiskVolResponse\n\t\tcreateCmd     *commands.CreateLogicalVolumeCommand\n\t\tconfirmCmd    *commands.ConfirmDRGroupExistsCommand\n\t\tcreatedVolume *rdiskDomain.LogicalVolume\n\t\tpvViewer      = app.GetRegistry(ctx).Viewers.PhysicalVolume\n\t)\n\n\tconfirmCmd = &commands.ConfirmDRGroupExistsCommand{\n\t\tAppID:   int64(req.AppId),\n\t\tDRGroup: functools.MapTo(req.AffinitySpec, functools.MapRef(make([]drgroup.Spec, len(req.AffinitySpec))), parseAffinitySpec),\n\t}\n\terr = app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, confirmCmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tselectedPhysicalVolume, err := pvViewer.QueryBySerial(ctx, []string{req.PhyId})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(selectedPhysicalVolume) == 0 {\n\t\treturn nil, errs.New(errors.ErrInvalidArgument, \"physical volume not found\")\n\t}\n\n\tcreateCmd = &commands.CreateLogicalVolumeCommand{\n\t\tAppID:                  int64(req.AppId),\n\t\tPhysicalVolumeSerial:   req.PhyId,\n\t\tZoneID:                 req.ZoneId,\n\t\tVolumeType:             req.VolumeType,\n\t\tDiskSize:               req.DiskSize,\n\t\tDiskType:               req.DiskType,\n\t\tDRGroup:                functools.MapTo(req.AffinitySpec, functools.MapRef(make([]drgroup.Spec, len(req.AffinitySpec))), parseAffinitySpec),\n\t\tSelectedPhysicalVolume: selectedPhysicalVolume[0],\n\t\tPerformanceRank:        req.PerformanceRank,\n\t}\n\n\terr = app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, createCmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcreatedVolume = createCmd.GetLogicalVolume()\n\tresponse = &pb.CreateRDiskVolResponse{\n\t\tDisk: encodeLogicalVolume(createdVolume, &pb.RDisk{}),\n\t}\n\n\treturn response, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 724,
        "code_end_line": 726,
        "code_key": "CreatePhyRDisk",
        "code_value": "func (s *UnimplementedMaster) CreatePhyRDisk(ctx context.Context, req *CreatePhyRDiskRequest) (*CreatePhyRDiskResponse, error) {\n\treturn nil, errors.New(\"rpc CreatePhyRDisk of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1157,
        "code_end_line": 1175,
        "code_key": "CreatePhyRDisk",
        "code_value": "func (c *MasterClientProxyImpl) CreatePhyRDisk(ctx context.Context, req *CreatePhyRDiskRequest, opts ...client.Option) (*CreatePhyRDiskResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/CreatePhyRDisk\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"CreatePhyRDisk\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &CreatePhyRDiskResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 114,
        "code_end_line": 120,
        "code_key": "CreatePhyRDisk",
        "code_value": "func (m *MockMasterService) CreatePhyRDisk(ctx context.Context, req *CreatePhyRDiskRequest) (*CreatePhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CreatePhyRDisk\", ctx, req)\n\tret0, _ := ret[0].(*CreatePhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 123,
        "code_end_line": 126,
        "code_key": "CreatePhyRDisk",
        "code_value": "func (mr *MockMasterServiceMockRecorder) CreatePhyRDisk(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreatePhyRDisk\", reflect.TypeOf((*MockMasterService)(nil).CreatePhyRDisk), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 537,
        "code_end_line": 547,
        "code_key": "CreatePhyRDisk",
        "code_value": "func (m *MockMasterClientProxy) CreatePhyRDisk(ctx context.Context, req *CreatePhyRDiskRequest, opts ...client.Option) (*CreatePhyRDiskResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"CreatePhyRDisk\", varargs...)\n\tret0, _ := ret[0].(*CreatePhyRDiskResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 550,
        "code_end_line": 554,
        "code_key": "CreatePhyRDisk",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) CreatePhyRDisk(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreatePhyRDisk\", reflect.TypeOf((*MockMasterClientProxy)(nil).CreatePhyRDisk), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 603,
        "code_end_line": 654,
        "code_key": "CreatePhyRDisk",
        "code_value": "func (s *masterApiServerImpl) CreatePhyRDisk(ctx context.Context, req *pb.CreatePhyRDiskRequest) (*pb.CreatePhyRDiskResponse, error) {\n\tcmd := commands.CreatePhysicalVolumeCommand{\n\t\tSerial:          req.PhyId,\n\t\tHost:            net.ParseIP(req.HostIp),\n\t\tBDF:             req.BdfId,\n\t\tSize:            req.Size,\n\t\tZoneID:          req.ZoneId,\n\t\tVolumeType:      req.VolumeType,\n\t\tCuf:             req.Cuf,\n\t\tPerformanceRank: req.PerformanceRank,\n\t}\n\n\tswitch req.Type {\n\tcase pb.DataNodeType_unknown:\n\t\tcmd.DataNodeType = rdiskDomain.DataNodeTypeUnknown\n\tcase pb.DataNodeType_mix:\n\t\tcmd.DataNodeType = rdiskDomain.DataNodeTypeMix\n\tcase pb.DataNodeType_monopoly:\n\t\tcmd.DataNodeType = rdiskDomain.DataNodeTypeMonopoly\n\t}\n\n\terr := app.GetRegistry(ctx).Dispatcher.Dispatch(ctx, &cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &pb.CreatePhyRDiskResponse{\n\t\tPhyDisk: &pb.PhyRDisk{\n\t\t\tPhyId:  req.PhyId,\n\t\t\tBdfId:  req.BdfId,\n\t\t\tStatus: \"inited\",\n\t\t\tSize:   req.Size,\n\t\t\tZoneId: req.ZoneId,\n\t\t\tNode: &pb.DataNode{\n\t\t\t\tHostIp: req.HostIp,\n\t\t\t\tStatus: \"online\",\n\t\t\t},\n\t\t\tCuf: req.Cuf,\n\t\t},\n\t}\n\n\t// 查询物理卷状态\n\tresults, err := app.GetRegistry(ctx).Viewers.PhysicalVolume.QueryBySerial(ctx, []string{req.PhyId})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(results) == 1 {\n\t\tvol := results[0]\n\t\tencodePhysicalVolume(vol, response.PhyDisk)\n\t}\n\treturn response, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 65,
        "code_end_line": 82,
        "code_key": "DmPhydisk",
        "code_value": "type DmPhydisk struct {\n\tID         uint64    `gorm:\"column:id;primaryKey\"`\n\tSerial     string    `gorm:\"column:serial;unique\"`\n\tIP         string    `gorm:\"column:host_ip\"`\n\tBDF        string    `gorm:\"column:bdf\"`\n\tDiskID     uint64    `gorm:\"column:disk_id\"`\n\tPort       int       `gorm:\"column:port\"`\n\tStatus     int       `gorm:\"column:status\"`\n\tSize       uint32    `gorm:\"column:size\"`\n\tRealSize   int64     `gorm:\"column:real_size\"`\n\tBlockSize  int       `gorm:\"column:block_size\"`\n\tZoneID     uint64    `gorm:\"column:zone_id\"`\n\tVolumeType string    `gorm:\"column:volume_type\"`\n\tExtra      string    `gorm:\"column:extra\"`\n\tCreated    time.Time `gorm:\"column:created\"`\n\tUpdated    time.Time `gorm:\"column:updated\"`\n\tPerfRank   string    `gorm:\"column:perf_rank\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 85,
        "code_end_line": 87,
        "code_key": "TableName",
        "code_value": "func (d *DmPhydisk) TableName() string {\n\treturn \"dm_phydisk\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 90,
        "code_end_line": 92,
        "code_key": "DBName",
        "code_value": "func (d *DmPhydisk) DBName() string {\n\treturn \"metadb\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 57,
        "code_end_line": 75,
        "code_key": "DmPhydisk",
        "code_value": "type DmPhydisk struct {\n\tID              uint64    `gorm:\"column:id;primaryKey\"`\n\tSerial          string    `gorm:\"column:serial;unique\"`\n\tIP              string    `gorm:\"column:host_ip\"`\n\tBDF             string    `gorm:\"column:bdf\"`\n\tDiskID          uint64    `gorm:\"column:disk_id\"`\n\tPort            int       `gorm:\"column:port\"`\n\tStatus          int       `gorm:\"column:status\"`\n\tSize            int64     `gorm:\"column:size\"`\n\tRealSize        int64     `gorm:\"column:real_size\"`\n\tBlockSize       int       `gorm:\"column:block_size\"`\n\tZoneID          int64     `gorm:\"column:zone_id\"`\n\tVolumeType      string    `gorm:\"column:volume_type\"`\n\tExtra           string    `gorm:\"column:extra\"`\n\tNodeType        string    `gorm:\"column:node_type\"`\n\tCreated         time.Time `gorm:\"column:created\"`\n\tUpdated         time.Time `gorm:\"column:updated\"`\n\tPerformanceRank string    `gorm:\"column:perf_rank\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 77,
        "code_end_line": 79,
        "code_key": "TableName",
        "code_value": "func (DmPhydisk) TableName() string {\n\treturn \"dm_phydisk\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/phy_vol.go:81:86:QueryByHost": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/phy_vol.go",
    "code_start_line": 81,
    "code_end_line": 86,
    "code_start_column": 27,
    "code_key": "QueryByHost",
    "code_value": "func (impl *phyVolViewer) QueryByHost(ctx context.Context, host net.IP) ([]*rdiskDomain.PhysicalVolume, error) {\n\tvolumes := []*metadb.DmPhydisk{}\n\tresult := impl.db.WithContext(ctx).Find(&volumes, \"host_ip = ?\", host.String())\n\tlogs.Info(ctx).Int64(\"count\", result.RowsAffected).Msg(\"query physical volumes by serial\")\n\treturn impl.dbToEntity(ctx, volumes), nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 65,
        "code_end_line": 82,
        "code_key": "DmPhydisk",
        "code_value": "type DmPhydisk struct {\n\tID         uint64    `gorm:\"column:id;primaryKey\"`\n\tSerial     string    `gorm:\"column:serial;unique\"`\n\tIP         string    `gorm:\"column:host_ip\"`\n\tBDF        string    `gorm:\"column:bdf\"`\n\tDiskID     uint64    `gorm:\"column:disk_id\"`\n\tPort       int       `gorm:\"column:port\"`\n\tStatus     int       `gorm:\"column:status\"`\n\tSize       uint32    `gorm:\"column:size\"`\n\tRealSize   int64     `gorm:\"column:real_size\"`\n\tBlockSize  int       `gorm:\"column:block_size\"`\n\tZoneID     uint64    `gorm:\"column:zone_id\"`\n\tVolumeType string    `gorm:\"column:volume_type\"`\n\tExtra      string    `gorm:\"column:extra\"`\n\tCreated    time.Time `gorm:\"column:created\"`\n\tUpdated    time.Time `gorm:\"column:updated\"`\n\tPerfRank   string    `gorm:\"column:perf_rank\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 85,
        "code_end_line": 87,
        "code_key": "TableName",
        "code_value": "func (d *DmPhydisk) TableName() string {\n\treturn \"dm_phydisk\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 90,
        "code_end_line": 92,
        "code_key": "DBName",
        "code_value": "func (d *DmPhydisk) DBName() string {\n\treturn \"metadb\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 57,
        "code_end_line": 75,
        "code_key": "DmPhydisk",
        "code_value": "type DmPhydisk struct {\n\tID              uint64    `gorm:\"column:id;primaryKey\"`\n\tSerial          string    `gorm:\"column:serial;unique\"`\n\tIP              string    `gorm:\"column:host_ip\"`\n\tBDF             string    `gorm:\"column:bdf\"`\n\tDiskID          uint64    `gorm:\"column:disk_id\"`\n\tPort            int       `gorm:\"column:port\"`\n\tStatus          int       `gorm:\"column:status\"`\n\tSize            int64     `gorm:\"column:size\"`\n\tRealSize        int64     `gorm:\"column:real_size\"`\n\tBlockSize       int       `gorm:\"column:block_size\"`\n\tZoneID          int64     `gorm:\"column:zone_id\"`\n\tVolumeType      string    `gorm:\"column:volume_type\"`\n\tExtra           string    `gorm:\"column:extra\"`\n\tNodeType        string    `gorm:\"column:node_type\"`\n\tCreated         time.Time `gorm:\"column:created\"`\n\tUpdated         time.Time `gorm:\"column:updated\"`\n\tPerformanceRank string    `gorm:\"column:perf_rank\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 77,
        "code_end_line": 79,
        "code_key": "TableName",
        "code_value": "func (DmPhydisk) TableName() string {\n\treturn \"dm_phydisk\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/phy_vol.go:88:118:Search": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/phy_vol.go",
    "code_start_line": 88,
    "code_end_line": 118,
    "code_start_column": 27,
    "code_key": "Search",
    "code_value": "func (impl *phyVolViewer) Search(ctx context.Context, criteria rdiskDomain.PVSearchCriteria, pagination rdiskDomain.Pagination) ([]*rdiskDomain.PhysicalVolume, error) {\n\tvar volumes []*metadb.DmPhydisk\n\tstmt := impl.db.WithContext(ctx).Where(\"1 = 1\")\n\tif len(criteria.IPs) > 0 {\n\t\tstmt = stmt.Where(\"host_ip in ?\", functools.Map(criteria.IPs, func(ip net.IP) string { return ip.String() }))\n\t}\n\tif len(criteria.Serials) > 0 {\n\t\tstmt = stmt.Where(\"serial in ?\", functools.Map(criteria.Serials, func(serial rdiskDomain.Serial) string { return string(serial) }))\n\t}\n\tif len(criteria.BDFs) > 0 {\n\t\tstmt = stmt.Where(\"bdf in ?\", functools.Map(criteria.BDFs, func(bdf rdiskDomain.BDF) string { return string(bdf) }))\n\t}\n\tif len(criteria.ZoneIDs) > 0 {\n\t\tstmt = stmt.Where(\"zone_id in ?\", functools.Map(criteria.ZoneIDs, func(zoneID rdiskDomain.ZoneID) uint64 { return uint64(zoneID) }))\n\t}\n\tif criteria.AvailableOnly {\n\t\tstmt = stmt.Where(\"status = ?\", rdiskDomain.PVSOnline)\n\t}\n\tif len(criteria.States) > 0 {\n\t\tstmt = stmt.Where(\"status in ?\", functools.Map(criteria.States, func(state rdiskDomain.PhysicalVolumeState) int { return int(state) }))\n\t}\n\tif pagination.Offset > 0 {\n\t\tstmt = stmt.Offset(int(pagination.Offset))\n\t}\n\tif pagination.Limit <= 0 {\n\t\tpagination.Limit = 10\n\t}\n\tstmt = stmt.Limit(int(pagination.Limit))\n\tresult := stmt.Find(&volumes)\n\treturn impl.dbToEntity(ctx, volumes), result.Error\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 649,
        "code_end_line": 651,
        "code_key": "QueryRDiskVol",
        "code_value": "func (s *UnimplementedMaster) QueryRDiskVol(ctx context.Context, req *QueryRDiskVolRequest) (*QueryRDiskVolResponse, error) {\n\treturn nil, errors.New(\"rpc QueryRDiskVol of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 857,
        "code_end_line": 875,
        "code_key": "QueryRDiskVol",
        "code_value": "func (c *MasterClientProxyImpl) QueryRDiskVol(ctx context.Context, req *QueryRDiskVolRequest, opts ...client.Option) (*QueryRDiskVolResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/QueryRDiskVol\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"QueryRDiskVol\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &QueryRDiskVolResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 354,
        "code_end_line": 360,
        "code_key": "QueryRDiskVol",
        "code_value": "func (m *MockMasterService) QueryRDiskVol(ctx context.Context, req *QueryRDiskVolRequest) (*QueryRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"QueryRDiskVol\", ctx, req)\n\tret0, _ := ret[0].(*QueryRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 363,
        "code_end_line": 366,
        "code_key": "QueryRDiskVol",
        "code_value": "func (mr *MockMasterServiceMockRecorder) QueryRDiskVol(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryRDiskVol\", reflect.TypeOf((*MockMasterService)(nil).QueryRDiskVol), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 857,
        "code_end_line": 867,
        "code_key": "QueryRDiskVol",
        "code_value": "func (m *MockMasterClientProxy) QueryRDiskVol(ctx context.Context, req *QueryRDiskVolRequest, opts ...client.Option) (*QueryRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"QueryRDiskVol\", varargs...)\n\tret0, _ := ret[0].(*QueryRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 870,
        "code_end_line": 874,
        "code_key": "QueryRDiskVol",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) QueryRDiskVol(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryRDiskVol\", reflect.TypeOf((*MockMasterClientProxy)(nil).QueryRDiskVol), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 498,
        "code_end_line": 596,
        "code_key": "QueryRDiskVol",
        "code_value": "func (*masterApiServerImpl) QueryRDiskVol(ctx context.Context, req *pb.QueryRDiskVolRequest) (*pb.QueryRDiskVolResponse, error) {\n\tview := app.GetRegistry(ctx).Viewers.LogicalVolume\n\tphyView := app.GetRegistry(ctx).Viewers.PhysicalVolume\n\tvar err error\n\n\ttype checker func(*pb.QueryRDiskVolRequest) error\n\tfor _, rule := range []checker{\n\t\t// 不允许不带任何参数的空查询\n\t\tcheckQueryRDiskVolNoEmptyQuery,\n\t\t// 如果带有 BdfIds 参数，必须带有 HostIps 参数缩小范围，单纯 Bdf 查询意义不大，区分度太低了\n\t\tcheckQueryRDiskVolBdfIdsMustComeWithHostIps,\n\t} {\n\t\tif err := rule(req); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Stage 1 - （如有）确认物理卷 Serials\n\tserials := []rdiskDomain.Serial{}\n\tif len(req.HostIps) > 0 {\n\t\tcriteria := rdiskDomain.PVSearchCriteria{\n\t\t\tIPs:           functools.Map(req.HostIps, net.ParseIP),\n\t\t\tSerials:       functools.Map(req.PhyIds, func(x string) rdiskDomain.Serial { return rdiskDomain.Serial(x) }),\n\t\t\tBDFs:          functools.Map(req.BdfIds, func(x string) rdiskDomain.BDF { return rdiskDomain.BDF(x) }),\n\t\t\tAvailableOnly: false,\n\t\t}\n\t\tphyDisks, err := phyView.Search(ctx, criteria, rdiskDomain.Pagination{Limit: 1000})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tserials = functools.Map(phyDisks, func(x *rdiskDomain.PhysicalVolume) rdiskDomain.Serial { return x.Serial })\n\t} else if len(req.PhyIds) > 0 {\n\t\tserials = functools.Map(req.PhyIds, func(x string) rdiskDomain.Serial { return rdiskDomain.Serial(x) })\n\t}\n\n\t// Stage 2 - 确认用户 AppId\n\tuuidSlice := functools.Map(req.CbsUuids, uuid.MustParse)\n\tappId := users.AppID(req.AppId)\n\tif req.AppId <= 0 {\n\t\tif appId, err = view.ProbeAppID(ctx, uuidSlice, serials); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Stage 3 - 发起查询\n\tcriteria := rdiskDomain.LVSearchCriteria{\n\t\tUUIDs:   uuidSlice,\n\t\tSerials: serials,\n\t}\n\tvar limit uint64 = 100\n\tvar offset uint64 = 0\n\tif req.Page != nil {\n\t\tlimit = req.Page.PageSize\n\t\toffset = req.Page.Page * limit\n\t}\n\n\tresults, err := view.Search(ctx, appId, criteria, rdiskDomain.Pagination{Limit: limit, Offset: offset})\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn &pb.QueryRDiskVolResponse{}, nil\n\t\t}\n\t}\n\n\tif len(results) == 0 {\n\t\treturn &pb.QueryRDiskVolResponse{}, nil\n\t}\n\n\t// Stage 4 - 查询关联的置放群组\n\trelatedUuidStrings := functools.Map(results, func(x *rdiskDomain.LogicalVolume) string { return x.UUID.String() })\n\tdrgroupRelations, err := app.GetRegistry(ctx).Viewers.DRGroup.QueryRelationsMap(ctx, appId, relatedUuidStrings)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Stage 5 - 组装数据返回\n\n\tgroupNameToSpecMap := make(map[string]*pb.AffinitySpec)\n\tresponseDataRef := functools.MapRef(make([]pb.RDisk, len(results)))\n\tfor i := range results {\n\t\tencodeLogicalVolume(results[i], responseDataRef[i])\n\n\t\t// 找到关联的置放群组并返回\n\t\tif drgroupViews, ok := drgroupRelations[results[i].UUID.String()]; ok {\n\t\t\tresponseDataRef[i].AffinitySpec = make([]*pb.AffinitySpec, len(drgroupViews))\n\t\t\tfor j := range drgroupViews {\n\t\t\t\tgroupName := drgroupViews[j].Name\n\t\t\t\tif spec, ok := groupNameToSpecMap[groupName]; ok {\n\t\t\t\t\tresponseDataRef[i].AffinitySpec[j] = spec\n\t\t\t\t} else {\n\t\t\t\t\tspec := encodeDRGroupView(drgroupViews[j], &pb.AffinitySpec{}, results[i].UUID.String())\n\t\t\t\t\tgroupNameToSpecMap[groupName] = spec\n\t\t\t\t\tresponseDataRef[i].AffinitySpec[j] = spec\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\treturn &pb.QueryRDiskVolResponse{Disks: responseDataRef}, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 734,
        "code_end_line": 736,
        "code_key": "QueryPhyRDiskInfo",
        "code_value": "func (s *UnimplementedMaster) QueryPhyRDiskInfo(ctx context.Context, req *QueryPhyRDiskInfoRequest) (*QueryPhyRDiskInfoResponse, error) {\n\treturn nil, errors.New(\"rpc QueryPhyRDiskInfo of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1197,
        "code_end_line": 1215,
        "code_key": "QueryPhyRDiskInfo",
        "code_value": "func (c *MasterClientProxyImpl) QueryPhyRDiskInfo(ctx context.Context, req *QueryPhyRDiskInfoRequest, opts ...client.Option) (*QueryPhyRDiskInfoResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/QueryPhyRDiskInfo\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"QueryPhyRDiskInfo\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &QueryPhyRDiskInfoResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 309,
        "code_end_line": 315,
        "code_key": "QueryPhyRDiskInfo",
        "code_value": "func (m *MockMasterService) QueryPhyRDiskInfo(ctx context.Context, req *QueryPhyRDiskInfoRequest) (*QueryPhyRDiskInfoResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"QueryPhyRDiskInfo\", ctx, req)\n\tret0, _ := ret[0].(*QueryPhyRDiskInfoResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 318,
        "code_end_line": 321,
        "code_key": "QueryPhyRDiskInfo",
        "code_value": "func (mr *MockMasterServiceMockRecorder) QueryPhyRDiskInfo(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryPhyRDiskInfo\", reflect.TypeOf((*MockMasterService)(nil).QueryPhyRDiskInfo), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 797,
        "code_end_line": 807,
        "code_key": "QueryPhyRDiskInfo",
        "code_value": "func (m *MockMasterClientProxy) QueryPhyRDiskInfo(ctx context.Context, req *QueryPhyRDiskInfoRequest, opts ...client.Option) (*QueryPhyRDiskInfoResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"QueryPhyRDiskInfo\", varargs...)\n\tret0, _ := ret[0].(*QueryPhyRDiskInfoResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 810,
        "code_end_line": 814,
        "code_key": "QueryPhyRDiskInfo",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) QueryPhyRDiskInfo(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryPhyRDiskInfo\", reflect.TypeOf((*MockMasterClientProxy)(nil).QueryPhyRDiskInfo), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 715,
        "code_end_line": 752,
        "code_key": "QueryPhyRDiskInfo",
        "code_value": "func (*masterApiServerImpl) QueryPhyRDiskInfo(ctx context.Context, req *pb.QueryPhyRDiskInfoRequest) (*pb.QueryPhyRDiskInfoResponse, error) {\n\tvar (\n\t\terr        error\n\t\tresponse   = &pb.QueryPhyRDiskInfoResponse{}\n\t\tview       = app.GetRegistry(ctx).Viewers.PhysicalVolume\n\t\tpagination rdiskDomain.Pagination\n\t)\n\tif req.Page != nil {\n\t\tpagination = rdiskDomain.Pagination{\n\t\t\tLimit:  req.Page.PageSize,\n\t\t\tOffset: req.Page.Page * req.Page.PageSize,\n\t\t}\n\t} else {\n\t\tpagination = rdiskDomain.Pagination{\n\t\t\tLimit:  100,\n\t\t\tOffset: 0,\n\t\t}\n\t}\n\tcriteria := rdiskDomain.PVSearchCriteria{}\n\tif len(req.HostIps) > 0 {\n\t\tcriteria.IPs = functools.Map(req.HostIps, net.ParseIP)\n\t}\n\tif len(req.PhyIds) > 0 {\n\t\tcriteria.Serials = functools.Map(req.PhyIds, func(id string) rdiskDomain.Serial { return rdiskDomain.Serial(id) })\n\t}\n\tif len(req.ZoneIds) > 0 {\n\t\tcriteria.ZoneIDs = functools.Map(req.ZoneIds, func(id uint64) rdiskDomain.ZoneID { return rdiskDomain.ZoneID(id) })\n\t}\n\tcriteria.AvailableOnly = req.AvailableOnly\n\tresults, err := view.Search(ctx, criteria, pagination)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse.PhyDisk = functools.MapRef(make([]pb.PhyRDisk, len(results)))\n\tfunctools.MapTo(results, response.PhyDisk, encodePhysicalVolume)\n\treturn response, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/tasks/update_benchmark.go",
        "code_start_line": 25,
        "code_end_line": 52,
        "code_key": "Work",
        "code_value": "func (*UpdateBenchmarkTask) Work(ctx context.Context) error {\n\tvar (\n\t\tviewer     = app.GetRegistry(ctx).Viewers.Benchmark\n\t\tdispatcher = app.GetRegistry(ctx).Dispatcher\n\t)\n\n\t// 1. Find all running benchmarks\n\trunningStatus := []benchmark.Status{benchmark.StatusRunning}\n\tbenchs, err := viewer.FindByStatus(ctx, runningStatus)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 2. Fire events to update running benchmarks\n\tlogs.Info(ctx).Int(\"count\", len(benchs)).Msg(\"starts to update benchmark data\")\n\tfor _, b := range benchs {\n\t\tcmd := &commands.UpdateBenchmarkTask{\n\t\t\tSerial:        b.DiskInfo.Serial,\n\t\t\tBenchmarkUUID: b.UUID,\n\t\t}\n\t\terr := dispatcher.Dispatch(ctx, cmd)\n\t\tif err != nil {\n\t\t\tlogs.Warn(ctx).Err(err).Str(\"uuid\", b.UUID.String()).Msg(\"update benchmark task failed\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/tasks/cleanup_defunct.go",
        "code_start_line": 27,
        "code_end_line": 69,
        "code_key": "Work",
        "code_value": "func (*CleanupDefunctTask) Work(ctx context.Context) error {\n\tvar err error\n\tvar batchSize uint64 = 1000\n\tvar defunctingVolumes []*rdiskDomain.LogicalVolume\n\tdefunctingVolumes, err = app.GetRegistry(ctx).Viewers.LogicalVolume.FindByStatus(\n\t\tctx, []rdiskDomain.LogicalVolumeState{rdiskDomain.LVSDefuncting}, rdiskDomain.Pagination{Limit: batchSize})\n\tif err != nil {\n\t\tlogs.Error(ctx).Err(err).Msg(\"failed to find defuncting volumes\")\n\t\treturn err\n\t}\n\tif len(defunctingVolumes) == 0 {\n\t\tlogs.Debug(ctx).Msg(\"no defuncting volumes found\")\n\t\treturn nil\n\t}\n\n\tlogs.Info(ctx).Int(\"count\", len(defunctingVolumes)).Msg(\"starts to cleanup defuncting volumes\")\n\n\tvar waitInterval = time.Second * 10\n\tvar dispatcher = app.GetRegistry(ctx).Dispatcher\n\tfor _, volume := range defunctingVolumes {\n\t\tif ctx.Err() != nil {\n\t\t\t// 上下文已经被取消, 退出\n\t\t\treturn ctx.Err()\n\t\t}\n\t\tfunc(volume *rdiskDomain.LogicalVolume) {\n\t\t\tlogs.Info(ctx).Stringer(\"uuid\", volume.UUID).Msg(\"cleanuping defunct volume\")\n\t\t\tsubCtx, cancel := context.WithTimeout(ctx, waitInterval)\n\t\t\tdefer cancel()\n\t\t\tcmd := &commands.CleanupDefunctCommand{UUID: volume.UUID}\n\t\t\tif err := dispatcher.Dispatch(subCtx, cmd); err != nil {\n\t\t\t\tif err == subCtx.Err() {\n\t\t\t\t\t// 等待超时了，在后台 dispatcher 会继续清理，这里直接返回\n\t\t\t\t\tlogs.Info(subCtx).Stringer(\"uuid\", volume.UUID).Msg(\"timeout waiting for cleanup defunct volume, move up to next\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlogs.Error(subCtx).Err(err).Str(\"uuid\", volume.UUID.String()).Msg(\"failed to cleanup defunct volume\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tlogs.Info(subCtx).Stringer(\"uuid\", volume.UUID).Msg(\"cleanup defunct volume done\")\n\t\t}(volume)\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/tasks/update_backup.go",
        "code_start_line": 25,
        "code_end_line": 51,
        "code_key": "Work",
        "code_value": "func (*UpdateBackupTask) Work(ctx context.Context) error {\n\tvar (\n\t\tviewer     = app.GetRegistry(ctx).Viewers.Backup\n\t\tdispatcher = app.GetRegistry(ctx).Dispatcher\n\t)\n\n\t// 1. 查询所有正在备份的备份\n\tstatusList := []backup.BackupStatus{backup.StatusRunning}\n\tbaks, err := viewer.FindByStatus(ctx, statusList)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 2. 更新备份进度\n\tlogs.Info(ctx).Int(\"count\", len(baks)).Msg(\"starts to update running backup task\")\n\tfor _, bak := range baks {\n\t\tcmd := &commands.UpdateRunningBackupTaskCommand{\n\t\t\tUUID: bak.UUID,\n\t\t}\n\t\terr := dispatcher.Dispatch(ctx, cmd)\n\t\tif err != nil {\n\t\t\tlogs.Warn(ctx).Err(err).Str(\"uuid\", bak.UUID.String()).Msg(\"update backup task failed\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/tasks/confirm_init_physical_disk.go",
        "code_start_line": 25,
        "code_end_line": 63,
        "code_key": "Work",
        "code_value": "func (*ConfirmInitPhysicalDiskTask) Work(ctx context.Context) error {\n\tvar (\n\t\tviewer     = app.GetRegistry(ctx).Viewers.PhysicalVolume\n\t\tdispatcher = app.GetRegistry(ctx).Dispatcher\n\t)\n\n\t// 1. 查询所有待初始化的物理卷\n\tcriteria := rdiskDomain.PVSearchCriteria{}\n\tcriteria.States = []rdiskDomain.PhysicalVolumeState{rdiskDomain.PVSInited}\n\tpagination := rdiskDomain.Pagination{Limit: 10}\n\n\tresults, err := viewer.Search(ctx, criteria, pagination)\n\tif err != nil {\n\t\tlogs.Warn(ctx).Err(err).Msg(\"search physical volume failed\")\n\t\treturn err\n\t}\n\n\tif len(results) == 0 {\n\t\tlogs.Debug(ctx).Msg(\"no physical volume to be initialized\")\n\t\treturn nil\n\t}\n\n\t// TODO: 是否可以增加一个退避机制，对于长时间没有成功初始化的物理卷，增加重试时间间隔\n\n\t// 2. 发起初始化\n\tlogs.Info(ctx).Int(\"count\", len(results)).Msg(\"starts to initialize disks\")\n\tfor _, vol := range results {\n\t\tcmd := &commands.ConfirmInitPhysicalVolumeCommand{\n\t\t\tSerial: string(vol.Serial),\n\t\t\tHost:   vol.IP,\n\t\t}\n\t\terr := dispatcher.Dispatch(ctx, cmd)\n\t\tif err != nil {\n\t\t\tlogs.Warn(ctx).Err(err).Str(\"serial\", string(vol.Serial)).Str(\"host_ip\", vol.IP.String()).Msg(\"confirm init physical volume failed\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/tasks/recycle_backup_data.go",
        "code_start_line": 25,
        "code_end_line": 51,
        "code_key": "Work",
        "code_value": "func (*RecycleBackupTask) Work(ctx context.Context) error {\n\tvar (\n\t\tviewer     = app.GetRegistry(ctx).Viewers.Backup\n\t\tdispatcher = app.GetRegistry(ctx).Dispatcher\n\t)\n\n\t// 1. 查询所有待删除的备份\n\tstatusList := []backup.BackupStatus{backup.StatusToDelete, backup.StatusFailed}\n\tbaks, err := viewer.FindByStatus(ctx, statusList)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 2. 发起清理数据\n\tlogs.Info(ctx).Int(\"count\", len(baks)).Msg(\"starts to recycle backup data\")\n\tfor _, bak := range baks {\n\t\tcmd := &commands.RecycleBackupDataCommand{\n\t\t\tUUID: bak.UUID,\n\t\t}\n\t\terr := dispatcher.Dispatch(ctx, cmd)\n\t\tif err != nil {\n\t\t\tlogs.Warn(ctx).Err(err).Str(\"uuid\", bak.UUID.String()).Msg(\"update backup task failed\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 223,
        "code_end_line": 236,
        "code_key": "queryLogicalVolumeUUID",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) queryLogicalVolumeUUID(ctx context.Context, appId users.AppID) (string, error) {\n\tcriteria := rdiskDomain.LVSearchCriteria{\n\t\tSerials: []rdiskDomain.Serial{c.Serial},\n\t}\n\tpagination := rdiskDomain.Pagination{Limit: 1}\n\tlv, err := app.GetRegistry(ctx).Viewers.LogicalVolume.Search(ctx, appId, criteria, pagination)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif len(lv) == 0 {\n\t\treturn \"\", nil\n\t}\n\treturn lv[0].UUID.String(), nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 65,
        "code_end_line": 82,
        "code_key": "DmPhydisk",
        "code_value": "type DmPhydisk struct {\n\tID         uint64    `gorm:\"column:id;primaryKey\"`\n\tSerial     string    `gorm:\"column:serial;unique\"`\n\tIP         string    `gorm:\"column:host_ip\"`\n\tBDF        string    `gorm:\"column:bdf\"`\n\tDiskID     uint64    `gorm:\"column:disk_id\"`\n\tPort       int       `gorm:\"column:port\"`\n\tStatus     int       `gorm:\"column:status\"`\n\tSize       uint32    `gorm:\"column:size\"`\n\tRealSize   int64     `gorm:\"column:real_size\"`\n\tBlockSize  int       `gorm:\"column:block_size\"`\n\tZoneID     uint64    `gorm:\"column:zone_id\"`\n\tVolumeType string    `gorm:\"column:volume_type\"`\n\tExtra      string    `gorm:\"column:extra\"`\n\tCreated    time.Time `gorm:\"column:created\"`\n\tUpdated    time.Time `gorm:\"column:updated\"`\n\tPerfRank   string    `gorm:\"column:perf_rank\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 85,
        "code_end_line": 87,
        "code_key": "TableName",
        "code_value": "func (d *DmPhydisk) TableName() string {\n\treturn \"dm_phydisk\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 90,
        "code_end_line": 92,
        "code_key": "DBName",
        "code_value": "func (d *DmPhydisk) DBName() string {\n\treturn \"metadb\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 57,
        "code_end_line": 75,
        "code_key": "DmPhydisk",
        "code_value": "type DmPhydisk struct {\n\tID              uint64    `gorm:\"column:id;primaryKey\"`\n\tSerial          string    `gorm:\"column:serial;unique\"`\n\tIP              string    `gorm:\"column:host_ip\"`\n\tBDF             string    `gorm:\"column:bdf\"`\n\tDiskID          uint64    `gorm:\"column:disk_id\"`\n\tPort            int       `gorm:\"column:port\"`\n\tStatus          int       `gorm:\"column:status\"`\n\tSize            int64     `gorm:\"column:size\"`\n\tRealSize        int64     `gorm:\"column:real_size\"`\n\tBlockSize       int       `gorm:\"column:block_size\"`\n\tZoneID          int64     `gorm:\"column:zone_id\"`\n\tVolumeType      string    `gorm:\"column:volume_type\"`\n\tExtra           string    `gorm:\"column:extra\"`\n\tNodeType        string    `gorm:\"column:node_type\"`\n\tCreated         time.Time `gorm:\"column:created\"`\n\tUpdated         time.Time `gorm:\"column:updated\"`\n\tPerformanceRank string    `gorm:\"column:perf_rank\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 77,
        "code_end_line": 79,
        "code_key": "TableName",
        "code_value": "func (DmPhydisk) TableName() string {\n\treturn \"dm_phydisk\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 25,
        "code_end_line": 25,
        "code_key": "Serial",
        "code_value": "type Serial string",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 31,
        "code_end_line": 31,
        "code_key": "BDF",
        "code_value": "type BDF string",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 39,
        "code_end_line": 39,
        "code_key": "ZoneID",
        "code_value": "type ZoneID uint64",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/model.go",
        "code_start_line": 8,
        "code_end_line": 8,
        "code_key": "PhysicalVolumeState",
        "code_value": "type PhysicalVolumeState int",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/common/model.go",
        "code_start_line": 8,
        "code_end_line": 8,
        "code_key": "PhysicalVolumeState",
        "code_value": "type PhysicalVolumeState int",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/constants.go",
        "code_start_line": 4,
        "code_end_line": 4,
        "code_key": "PhysicalVolumeState",
        "code_value": "type PhysicalVolumeState int",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/logi_vol.go:49:77:Search": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/logi_vol.go",
    "code_start_line": 49,
    "code_end_line": 77,
    "code_start_column": 35,
    "code_key": "Search",
    "code_value": "func (v *logicalVolumeViewerImpl) Search(ctx context.Context, appID users.AppID, criteria rdiskDomain.LVSearchCriteria, pagination rdiskDomain.Pagination) ([]*rdiskDomain.LogicalVolume, error) {\n\tvar volumes []*metadb.DmRdisk\n\tstmt := v.db.WithContext(ctx).Where(\"app_id = ?\", appID)\n\tif len(criteria.UUIDs) > 0 {\n\t\tstmt = stmt.Where(\"uuid in ?\", functools.Map(criteria.UUIDs, func(i uuid.UUID) string { return i.String() }))\n\t}\n\tif len(criteria.Serials) > 0 {\n\t\tstmt = stmt.Where(\"phydisk_serial in ?\", functools.Map(criteria.Serials, func(i rdiskDomain.Serial) string { return string(i) }))\n\t}\n\tif pagination.Offset > 0 {\n\t\tstmt = stmt.Offset(int(pagination.Offset))\n\t}\n\tif pagination.Limit <= 0 {\n\t\tpagination.Limit = 10\n\t}\n\tresult := stmt.Preload(\"DmPhyDisk\").Limit(int(pagination.Limit)).Find(&volumes)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\n\tresultViews := functools.MapRef(make([]rdiskDomain.LogicalVolume, len(volumes)))\n\tfor i := range volumes {\n\t\tv.translate(volumes[i], resultViews[i])\n\t}\n\treturn resultViews, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 649,
        "code_end_line": 651,
        "code_key": "QueryRDiskVol",
        "code_value": "func (s *UnimplementedMaster) QueryRDiskVol(ctx context.Context, req *QueryRDiskVolRequest) (*QueryRDiskVolResponse, error) {\n\treturn nil, errors.New(\"rpc QueryRDiskVol of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 857,
        "code_end_line": 875,
        "code_key": "QueryRDiskVol",
        "code_value": "func (c *MasterClientProxyImpl) QueryRDiskVol(ctx context.Context, req *QueryRDiskVolRequest, opts ...client.Option) (*QueryRDiskVolResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/QueryRDiskVol\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"QueryRDiskVol\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &QueryRDiskVolResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 354,
        "code_end_line": 360,
        "code_key": "QueryRDiskVol",
        "code_value": "func (m *MockMasterService) QueryRDiskVol(ctx context.Context, req *QueryRDiskVolRequest) (*QueryRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"QueryRDiskVol\", ctx, req)\n\tret0, _ := ret[0].(*QueryRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 363,
        "code_end_line": 366,
        "code_key": "QueryRDiskVol",
        "code_value": "func (mr *MockMasterServiceMockRecorder) QueryRDiskVol(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryRDiskVol\", reflect.TypeOf((*MockMasterService)(nil).QueryRDiskVol), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 857,
        "code_end_line": 867,
        "code_key": "QueryRDiskVol",
        "code_value": "func (m *MockMasterClientProxy) QueryRDiskVol(ctx context.Context, req *QueryRDiskVolRequest, opts ...client.Option) (*QueryRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"QueryRDiskVol\", varargs...)\n\tret0, _ := ret[0].(*QueryRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 870,
        "code_end_line": 874,
        "code_key": "QueryRDiskVol",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) QueryRDiskVol(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryRDiskVol\", reflect.TypeOf((*MockMasterClientProxy)(nil).QueryRDiskVol), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 498,
        "code_end_line": 596,
        "code_key": "QueryRDiskVol",
        "code_value": "func (*masterApiServerImpl) QueryRDiskVol(ctx context.Context, req *pb.QueryRDiskVolRequest) (*pb.QueryRDiskVolResponse, error) {\n\tview := app.GetRegistry(ctx).Viewers.LogicalVolume\n\tphyView := app.GetRegistry(ctx).Viewers.PhysicalVolume\n\tvar err error\n\n\ttype checker func(*pb.QueryRDiskVolRequest) error\n\tfor _, rule := range []checker{\n\t\t// 不允许不带任何参数的空查询\n\t\tcheckQueryRDiskVolNoEmptyQuery,\n\t\t// 如果带有 BdfIds 参数，必须带有 HostIps 参数缩小范围，单纯 Bdf 查询意义不大，区分度太低了\n\t\tcheckQueryRDiskVolBdfIdsMustComeWithHostIps,\n\t} {\n\t\tif err := rule(req); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Stage 1 - （如有）确认物理卷 Serials\n\tserials := []rdiskDomain.Serial{}\n\tif len(req.HostIps) > 0 {\n\t\tcriteria := rdiskDomain.PVSearchCriteria{\n\t\t\tIPs:           functools.Map(req.HostIps, net.ParseIP),\n\t\t\tSerials:       functools.Map(req.PhyIds, func(x string) rdiskDomain.Serial { return rdiskDomain.Serial(x) }),\n\t\t\tBDFs:          functools.Map(req.BdfIds, func(x string) rdiskDomain.BDF { return rdiskDomain.BDF(x) }),\n\t\t\tAvailableOnly: false,\n\t\t}\n\t\tphyDisks, err := phyView.Search(ctx, criteria, rdiskDomain.Pagination{Limit: 1000})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tserials = functools.Map(phyDisks, func(x *rdiskDomain.PhysicalVolume) rdiskDomain.Serial { return x.Serial })\n\t} else if len(req.PhyIds) > 0 {\n\t\tserials = functools.Map(req.PhyIds, func(x string) rdiskDomain.Serial { return rdiskDomain.Serial(x) })\n\t}\n\n\t// Stage 2 - 确认用户 AppId\n\tuuidSlice := functools.Map(req.CbsUuids, uuid.MustParse)\n\tappId := users.AppID(req.AppId)\n\tif req.AppId <= 0 {\n\t\tif appId, err = view.ProbeAppID(ctx, uuidSlice, serials); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Stage 3 - 发起查询\n\tcriteria := rdiskDomain.LVSearchCriteria{\n\t\tUUIDs:   uuidSlice,\n\t\tSerials: serials,\n\t}\n\tvar limit uint64 = 100\n\tvar offset uint64 = 0\n\tif req.Page != nil {\n\t\tlimit = req.Page.PageSize\n\t\toffset = req.Page.Page * limit\n\t}\n\n\tresults, err := view.Search(ctx, appId, criteria, rdiskDomain.Pagination{Limit: limit, Offset: offset})\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn &pb.QueryRDiskVolResponse{}, nil\n\t\t}\n\t}\n\n\tif len(results) == 0 {\n\t\treturn &pb.QueryRDiskVolResponse{}, nil\n\t}\n\n\t// Stage 4 - 查询关联的置放群组\n\trelatedUuidStrings := functools.Map(results, func(x *rdiskDomain.LogicalVolume) string { return x.UUID.String() })\n\tdrgroupRelations, err := app.GetRegistry(ctx).Viewers.DRGroup.QueryRelationsMap(ctx, appId, relatedUuidStrings)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Stage 5 - 组装数据返回\n\n\tgroupNameToSpecMap := make(map[string]*pb.AffinitySpec)\n\tresponseDataRef := functools.MapRef(make([]pb.RDisk, len(results)))\n\tfor i := range results {\n\t\tencodeLogicalVolume(results[i], responseDataRef[i])\n\n\t\t// 找到关联的置放群组并返回\n\t\tif drgroupViews, ok := drgroupRelations[results[i].UUID.String()]; ok {\n\t\t\tresponseDataRef[i].AffinitySpec = make([]*pb.AffinitySpec, len(drgroupViews))\n\t\t\tfor j := range drgroupViews {\n\t\t\t\tgroupName := drgroupViews[j].Name\n\t\t\t\tif spec, ok := groupNameToSpecMap[groupName]; ok {\n\t\t\t\t\tresponseDataRef[i].AffinitySpec[j] = spec\n\t\t\t\t} else {\n\t\t\t\t\tspec := encodeDRGroupView(drgroupViews[j], &pb.AffinitySpec{}, results[i].UUID.String())\n\t\t\t\t\tgroupNameToSpecMap[groupName] = spec\n\t\t\t\t\tresponseDataRef[i].AffinitySpec[j] = spec\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\treturn &pb.QueryRDiskVolResponse{Disks: responseDataRef}, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 734,
        "code_end_line": 736,
        "code_key": "QueryPhyRDiskInfo",
        "code_value": "func (s *UnimplementedMaster) QueryPhyRDiskInfo(ctx context.Context, req *QueryPhyRDiskInfoRequest) (*QueryPhyRDiskInfoResponse, error) {\n\treturn nil, errors.New(\"rpc QueryPhyRDiskInfo of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1197,
        "code_end_line": 1215,
        "code_key": "QueryPhyRDiskInfo",
        "code_value": "func (c *MasterClientProxyImpl) QueryPhyRDiskInfo(ctx context.Context, req *QueryPhyRDiskInfoRequest, opts ...client.Option) (*QueryPhyRDiskInfoResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/QueryPhyRDiskInfo\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"QueryPhyRDiskInfo\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &QueryPhyRDiskInfoResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 309,
        "code_end_line": 315,
        "code_key": "QueryPhyRDiskInfo",
        "code_value": "func (m *MockMasterService) QueryPhyRDiskInfo(ctx context.Context, req *QueryPhyRDiskInfoRequest) (*QueryPhyRDiskInfoResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"QueryPhyRDiskInfo\", ctx, req)\n\tret0, _ := ret[0].(*QueryPhyRDiskInfoResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 318,
        "code_end_line": 321,
        "code_key": "QueryPhyRDiskInfo",
        "code_value": "func (mr *MockMasterServiceMockRecorder) QueryPhyRDiskInfo(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryPhyRDiskInfo\", reflect.TypeOf((*MockMasterService)(nil).QueryPhyRDiskInfo), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 797,
        "code_end_line": 807,
        "code_key": "QueryPhyRDiskInfo",
        "code_value": "func (m *MockMasterClientProxy) QueryPhyRDiskInfo(ctx context.Context, req *QueryPhyRDiskInfoRequest, opts ...client.Option) (*QueryPhyRDiskInfoResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"QueryPhyRDiskInfo\", varargs...)\n\tret0, _ := ret[0].(*QueryPhyRDiskInfoResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 810,
        "code_end_line": 814,
        "code_key": "QueryPhyRDiskInfo",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) QueryPhyRDiskInfo(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryPhyRDiskInfo\", reflect.TypeOf((*MockMasterClientProxy)(nil).QueryPhyRDiskInfo), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 715,
        "code_end_line": 752,
        "code_key": "QueryPhyRDiskInfo",
        "code_value": "func (*masterApiServerImpl) QueryPhyRDiskInfo(ctx context.Context, req *pb.QueryPhyRDiskInfoRequest) (*pb.QueryPhyRDiskInfoResponse, error) {\n\tvar (\n\t\terr        error\n\t\tresponse   = &pb.QueryPhyRDiskInfoResponse{}\n\t\tview       = app.GetRegistry(ctx).Viewers.PhysicalVolume\n\t\tpagination rdiskDomain.Pagination\n\t)\n\tif req.Page != nil {\n\t\tpagination = rdiskDomain.Pagination{\n\t\t\tLimit:  req.Page.PageSize,\n\t\t\tOffset: req.Page.Page * req.Page.PageSize,\n\t\t}\n\t} else {\n\t\tpagination = rdiskDomain.Pagination{\n\t\t\tLimit:  100,\n\t\t\tOffset: 0,\n\t\t}\n\t}\n\tcriteria := rdiskDomain.PVSearchCriteria{}\n\tif len(req.HostIps) > 0 {\n\t\tcriteria.IPs = functools.Map(req.HostIps, net.ParseIP)\n\t}\n\tif len(req.PhyIds) > 0 {\n\t\tcriteria.Serials = functools.Map(req.PhyIds, func(id string) rdiskDomain.Serial { return rdiskDomain.Serial(id) })\n\t}\n\tif len(req.ZoneIds) > 0 {\n\t\tcriteria.ZoneIDs = functools.Map(req.ZoneIds, func(id uint64) rdiskDomain.ZoneID { return rdiskDomain.ZoneID(id) })\n\t}\n\tcriteria.AvailableOnly = req.AvailableOnly\n\tresults, err := view.Search(ctx, criteria, pagination)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse.PhyDisk = functools.MapRef(make([]pb.PhyRDisk, len(results)))\n\tfunctools.MapTo(results, response.PhyDisk, encodePhysicalVolume)\n\treturn response, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/tasks/update_benchmark.go",
        "code_start_line": 25,
        "code_end_line": 52,
        "code_key": "Work",
        "code_value": "func (*UpdateBenchmarkTask) Work(ctx context.Context) error {\n\tvar (\n\t\tviewer     = app.GetRegistry(ctx).Viewers.Benchmark\n\t\tdispatcher = app.GetRegistry(ctx).Dispatcher\n\t)\n\n\t// 1. Find all running benchmarks\n\trunningStatus := []benchmark.Status{benchmark.StatusRunning}\n\tbenchs, err := viewer.FindByStatus(ctx, runningStatus)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 2. Fire events to update running benchmarks\n\tlogs.Info(ctx).Int(\"count\", len(benchs)).Msg(\"starts to update benchmark data\")\n\tfor _, b := range benchs {\n\t\tcmd := &commands.UpdateBenchmarkTask{\n\t\t\tSerial:        b.DiskInfo.Serial,\n\t\t\tBenchmarkUUID: b.UUID,\n\t\t}\n\t\terr := dispatcher.Dispatch(ctx, cmd)\n\t\tif err != nil {\n\t\t\tlogs.Warn(ctx).Err(err).Str(\"uuid\", b.UUID.String()).Msg(\"update benchmark task failed\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/tasks/cleanup_defunct.go",
        "code_start_line": 27,
        "code_end_line": 69,
        "code_key": "Work",
        "code_value": "func (*CleanupDefunctTask) Work(ctx context.Context) error {\n\tvar err error\n\tvar batchSize uint64 = 1000\n\tvar defunctingVolumes []*rdiskDomain.LogicalVolume\n\tdefunctingVolumes, err = app.GetRegistry(ctx).Viewers.LogicalVolume.FindByStatus(\n\t\tctx, []rdiskDomain.LogicalVolumeState{rdiskDomain.LVSDefuncting}, rdiskDomain.Pagination{Limit: batchSize})\n\tif err != nil {\n\t\tlogs.Error(ctx).Err(err).Msg(\"failed to find defuncting volumes\")\n\t\treturn err\n\t}\n\tif len(defunctingVolumes) == 0 {\n\t\tlogs.Debug(ctx).Msg(\"no defuncting volumes found\")\n\t\treturn nil\n\t}\n\n\tlogs.Info(ctx).Int(\"count\", len(defunctingVolumes)).Msg(\"starts to cleanup defuncting volumes\")\n\n\tvar waitInterval = time.Second * 10\n\tvar dispatcher = app.GetRegistry(ctx).Dispatcher\n\tfor _, volume := range defunctingVolumes {\n\t\tif ctx.Err() != nil {\n\t\t\t// 上下文已经被取消, 退出\n\t\t\treturn ctx.Err()\n\t\t}\n\t\tfunc(volume *rdiskDomain.LogicalVolume) {\n\t\t\tlogs.Info(ctx).Stringer(\"uuid\", volume.UUID).Msg(\"cleanuping defunct volume\")\n\t\t\tsubCtx, cancel := context.WithTimeout(ctx, waitInterval)\n\t\t\tdefer cancel()\n\t\t\tcmd := &commands.CleanupDefunctCommand{UUID: volume.UUID}\n\t\t\tif err := dispatcher.Dispatch(subCtx, cmd); err != nil {\n\t\t\t\tif err == subCtx.Err() {\n\t\t\t\t\t// 等待超时了，在后台 dispatcher 会继续清理，这里直接返回\n\t\t\t\t\tlogs.Info(subCtx).Stringer(\"uuid\", volume.UUID).Msg(\"timeout waiting for cleanup defunct volume, move up to next\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlogs.Error(subCtx).Err(err).Str(\"uuid\", volume.UUID.String()).Msg(\"failed to cleanup defunct volume\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tlogs.Info(subCtx).Stringer(\"uuid\", volume.UUID).Msg(\"cleanup defunct volume done\")\n\t\t}(volume)\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/tasks/update_backup.go",
        "code_start_line": 25,
        "code_end_line": 51,
        "code_key": "Work",
        "code_value": "func (*UpdateBackupTask) Work(ctx context.Context) error {\n\tvar (\n\t\tviewer     = app.GetRegistry(ctx).Viewers.Backup\n\t\tdispatcher = app.GetRegistry(ctx).Dispatcher\n\t)\n\n\t// 1. 查询所有正在备份的备份\n\tstatusList := []backup.BackupStatus{backup.StatusRunning}\n\tbaks, err := viewer.FindByStatus(ctx, statusList)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 2. 更新备份进度\n\tlogs.Info(ctx).Int(\"count\", len(baks)).Msg(\"starts to update running backup task\")\n\tfor _, bak := range baks {\n\t\tcmd := &commands.UpdateRunningBackupTaskCommand{\n\t\t\tUUID: bak.UUID,\n\t\t}\n\t\terr := dispatcher.Dispatch(ctx, cmd)\n\t\tif err != nil {\n\t\t\tlogs.Warn(ctx).Err(err).Str(\"uuid\", bak.UUID.String()).Msg(\"update backup task failed\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/tasks/confirm_init_physical_disk.go",
        "code_start_line": 25,
        "code_end_line": 63,
        "code_key": "Work",
        "code_value": "func (*ConfirmInitPhysicalDiskTask) Work(ctx context.Context) error {\n\tvar (\n\t\tviewer     = app.GetRegistry(ctx).Viewers.PhysicalVolume\n\t\tdispatcher = app.GetRegistry(ctx).Dispatcher\n\t)\n\n\t// 1. 查询所有待初始化的物理卷\n\tcriteria := rdiskDomain.PVSearchCriteria{}\n\tcriteria.States = []rdiskDomain.PhysicalVolumeState{rdiskDomain.PVSInited}\n\tpagination := rdiskDomain.Pagination{Limit: 10}\n\n\tresults, err := viewer.Search(ctx, criteria, pagination)\n\tif err != nil {\n\t\tlogs.Warn(ctx).Err(err).Msg(\"search physical volume failed\")\n\t\treturn err\n\t}\n\n\tif len(results) == 0 {\n\t\tlogs.Debug(ctx).Msg(\"no physical volume to be initialized\")\n\t\treturn nil\n\t}\n\n\t// TODO: 是否可以增加一个退避机制，对于长时间没有成功初始化的物理卷，增加重试时间间隔\n\n\t// 2. 发起初始化\n\tlogs.Info(ctx).Int(\"count\", len(results)).Msg(\"starts to initialize disks\")\n\tfor _, vol := range results {\n\t\tcmd := &commands.ConfirmInitPhysicalVolumeCommand{\n\t\t\tSerial: string(vol.Serial),\n\t\t\tHost:   vol.IP,\n\t\t}\n\t\terr := dispatcher.Dispatch(ctx, cmd)\n\t\tif err != nil {\n\t\t\tlogs.Warn(ctx).Err(err).Str(\"serial\", string(vol.Serial)).Str(\"host_ip\", vol.IP.String()).Msg(\"confirm init physical volume failed\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/tasks/recycle_backup_data.go",
        "code_start_line": 25,
        "code_end_line": 51,
        "code_key": "Work",
        "code_value": "func (*RecycleBackupTask) Work(ctx context.Context) error {\n\tvar (\n\t\tviewer     = app.GetRegistry(ctx).Viewers.Backup\n\t\tdispatcher = app.GetRegistry(ctx).Dispatcher\n\t)\n\n\t// 1. 查询所有待删除的备份\n\tstatusList := []backup.BackupStatus{backup.StatusToDelete, backup.StatusFailed}\n\tbaks, err := viewer.FindByStatus(ctx, statusList)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 2. 发起清理数据\n\tlogs.Info(ctx).Int(\"count\", len(baks)).Msg(\"starts to recycle backup data\")\n\tfor _, bak := range baks {\n\t\tcmd := &commands.RecycleBackupDataCommand{\n\t\t\tUUID: bak.UUID,\n\t\t}\n\t\terr := dispatcher.Dispatch(ctx, cmd)\n\t\tif err != nil {\n\t\t\tlogs.Warn(ctx).Err(err).Str(\"uuid\", bak.UUID.String()).Msg(\"update backup task failed\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 223,
        "code_end_line": 236,
        "code_key": "queryLogicalVolumeUUID",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) queryLogicalVolumeUUID(ctx context.Context, appId users.AppID) (string, error) {\n\tcriteria := rdiskDomain.LVSearchCriteria{\n\t\tSerials: []rdiskDomain.Serial{c.Serial},\n\t}\n\tpagination := rdiskDomain.Pagination{Limit: 1}\n\tlv, err := app.GetRegistry(ctx).Viewers.LogicalVolume.Search(ctx, appId, criteria, pagination)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif len(lv) == 0 {\n\t\treturn \"\", nil\n\t}\n\treturn lv[0].UUID.String(), nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 5,
        "code_end_line": 27,
        "code_key": "DmRdisk",
        "code_value": "type DmRdisk struct {\n\tID                 uint64    `gorm:\"column:id;primaryKey\"`\n\tUUID               string    `gorm:\"column:uuid;unique\"`\n\tStatus             int       `gorm:\"column:status\"`\n\tAppID              int64     `gorm:\"column:app_id\"`\n\tSize               int64     `gorm:\"column:size\"`\n\tPhydiskSerial      string    `gorm:\"column:phydisk_serial\"`\n\tExtra              string    `gorm:\"column:extra\"`\n\tZoneID             int64     `gorm:\"column:zone_id\"`\n\tVolumeType         string    `gorm:\"column:volume_type\"`\n\tDiskType           string    `gorm:\"column:disk_type\"`\n\tReadIOPS           int64     `gorm:\"column:read_iops\"`\n\tReadBandwidth      int64     `gorm:\"column:read_bandwidth\"`\n\tWriteIOPS          int64     `gorm:\"column:write_iops\"`\n\tWriteBandwidth     int64     `gorm:\"column:write_bandwidth\"`\n\tReadWriteIOPS      int64     `gorm:\"column:rw_iops\"`\n\tReadWriteBandwidth int64     `gorm:\"column:rw_bandwidth\"`\n\tCreated            time.Time `gorm:\"column:created\"`\n\tUpdated            time.Time `gorm:\"column:updated\"`\n\n\tDmPhyDisk   *DmPhydisk          `gorm:\"foreignKey:Serial;references:PhydiskSerial\"`\n\tAttachments []DmRdiskAttachment `gorm:\"foreignKey:UUID;references:UUID\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 29,
        "code_end_line": 31,
        "code_key": "TableName",
        "code_value": "func (DmRdisk) TableName() string {\n\treturn \"dm_rdisk\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/model.go",
        "code_start_line": 6,
        "code_end_line": 6,
        "code_key": "UUID",
        "code_value": "type UUID string",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/common/model.go",
        "code_start_line": 6,
        "code_end_line": 6,
        "code_key": "UUID",
        "code_value": "type UUID string",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 25,
        "code_end_line": 25,
        "code_key": "Serial",
        "code_value": "type Serial string",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 178,
        "code_end_line": 190,
        "code_key": "LogicalVolume",
        "code_value": "type LogicalVolume struct {\n\tEntityMixin\n\tUUID            uuid.UUID\n\tState           LogicalVolumeState\n\tSize            Size\n\tAppID           users.AppID\n\tZoneID          ZoneID\n\tDiskType        DiskType\n\tVolumeType      VolumeType\n\tFlowControlSpec FlowControlSpec\n\tPhysicalVolume  *PhysicalVolume\n\tAttachments     []*VolumeAttachment\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/logi_vol.go:80:102:ProbeAppID": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/logi_vol.go",
    "code_start_line": 80,
    "code_end_line": 102,
    "code_start_column": 35,
    "code_key": "ProbeAppID",
    "code_value": "func (v *logicalVolumeViewerImpl) ProbeAppID(ctx context.Context, uuids []uuid.UUID, serial []rdiskDomain.Serial) (users.AppID, error) {\n\tvar (\n\t\tdataObjects *metadb.DmRdisk\n\t)\n\tstmt := v.db.WithContext(ctx).Where(\"1 = 1\")\n\tif len(uuids) > 0 {\n\t\tstmt = stmt.Where(\"uuid in ?\", functools.Map(uuids, func(i uuid.UUID) string { return i.String() }))\n\t}\n\tif len(serial) > 0 {\n\t\tstmt = stmt.Where(\"phydisk_serial in ?\", functools.Map(serial, func(i rdiskDomain.Serial) string { return string(i) }))\n\t}\n\tresult := stmt.Select(\"app_id\").Limit(1).Find(&dataObjects)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn users.AppID(0), nil\n\t\t}\n\t\treturn users.AppID(0), result.Error\n\t}\n\tif dataObjects.AppID == 0 {\n\t\treturn users.AppID(0), errors.New(rdiskDomain.ErrVolumeNotExists, \"logical volume not exist\")\n\t}\n\treturn users.AppID(dataObjects.AppID), nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 649,
        "code_end_line": 651,
        "code_key": "QueryRDiskVol",
        "code_value": "func (s *UnimplementedMaster) QueryRDiskVol(ctx context.Context, req *QueryRDiskVolRequest) (*QueryRDiskVolResponse, error) {\n\treturn nil, errors.New(\"rpc QueryRDiskVol of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 857,
        "code_end_line": 875,
        "code_key": "QueryRDiskVol",
        "code_value": "func (c *MasterClientProxyImpl) QueryRDiskVol(ctx context.Context, req *QueryRDiskVolRequest, opts ...client.Option) (*QueryRDiskVolResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/QueryRDiskVol\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"QueryRDiskVol\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &QueryRDiskVolResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 354,
        "code_end_line": 360,
        "code_key": "QueryRDiskVol",
        "code_value": "func (m *MockMasterService) QueryRDiskVol(ctx context.Context, req *QueryRDiskVolRequest) (*QueryRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"QueryRDiskVol\", ctx, req)\n\tret0, _ := ret[0].(*QueryRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 363,
        "code_end_line": 366,
        "code_key": "QueryRDiskVol",
        "code_value": "func (mr *MockMasterServiceMockRecorder) QueryRDiskVol(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryRDiskVol\", reflect.TypeOf((*MockMasterService)(nil).QueryRDiskVol), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 857,
        "code_end_line": 867,
        "code_key": "QueryRDiskVol",
        "code_value": "func (m *MockMasterClientProxy) QueryRDiskVol(ctx context.Context, req *QueryRDiskVolRequest, opts ...client.Option) (*QueryRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"QueryRDiskVol\", varargs...)\n\tret0, _ := ret[0].(*QueryRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 870,
        "code_end_line": 874,
        "code_key": "QueryRDiskVol",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) QueryRDiskVol(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryRDiskVol\", reflect.TypeOf((*MockMasterClientProxy)(nil).QueryRDiskVol), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 498,
        "code_end_line": 596,
        "code_key": "QueryRDiskVol",
        "code_value": "func (*masterApiServerImpl) QueryRDiskVol(ctx context.Context, req *pb.QueryRDiskVolRequest) (*pb.QueryRDiskVolResponse, error) {\n\tview := app.GetRegistry(ctx).Viewers.LogicalVolume\n\tphyView := app.GetRegistry(ctx).Viewers.PhysicalVolume\n\tvar err error\n\n\ttype checker func(*pb.QueryRDiskVolRequest) error\n\tfor _, rule := range []checker{\n\t\t// 不允许不带任何参数的空查询\n\t\tcheckQueryRDiskVolNoEmptyQuery,\n\t\t// 如果带有 BdfIds 参数，必须带有 HostIps 参数缩小范围，单纯 Bdf 查询意义不大，区分度太低了\n\t\tcheckQueryRDiskVolBdfIdsMustComeWithHostIps,\n\t} {\n\t\tif err := rule(req); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Stage 1 - （如有）确认物理卷 Serials\n\tserials := []rdiskDomain.Serial{}\n\tif len(req.HostIps) > 0 {\n\t\tcriteria := rdiskDomain.PVSearchCriteria{\n\t\t\tIPs:           functools.Map(req.HostIps, net.ParseIP),\n\t\t\tSerials:       functools.Map(req.PhyIds, func(x string) rdiskDomain.Serial { return rdiskDomain.Serial(x) }),\n\t\t\tBDFs:          functools.Map(req.BdfIds, func(x string) rdiskDomain.BDF { return rdiskDomain.BDF(x) }),\n\t\t\tAvailableOnly: false,\n\t\t}\n\t\tphyDisks, err := phyView.Search(ctx, criteria, rdiskDomain.Pagination{Limit: 1000})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tserials = functools.Map(phyDisks, func(x *rdiskDomain.PhysicalVolume) rdiskDomain.Serial { return x.Serial })\n\t} else if len(req.PhyIds) > 0 {\n\t\tserials = functools.Map(req.PhyIds, func(x string) rdiskDomain.Serial { return rdiskDomain.Serial(x) })\n\t}\n\n\t// Stage 2 - 确认用户 AppId\n\tuuidSlice := functools.Map(req.CbsUuids, uuid.MustParse)\n\tappId := users.AppID(req.AppId)\n\tif req.AppId <= 0 {\n\t\tif appId, err = view.ProbeAppID(ctx, uuidSlice, serials); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Stage 3 - 发起查询\n\tcriteria := rdiskDomain.LVSearchCriteria{\n\t\tUUIDs:   uuidSlice,\n\t\tSerials: serials,\n\t}\n\tvar limit uint64 = 100\n\tvar offset uint64 = 0\n\tif req.Page != nil {\n\t\tlimit = req.Page.PageSize\n\t\toffset = req.Page.Page * limit\n\t}\n\n\tresults, err := view.Search(ctx, appId, criteria, rdiskDomain.Pagination{Limit: limit, Offset: offset})\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn &pb.QueryRDiskVolResponse{}, nil\n\t\t}\n\t}\n\n\tif len(results) == 0 {\n\t\treturn &pb.QueryRDiskVolResponse{}, nil\n\t}\n\n\t// Stage 4 - 查询关联的置放群组\n\trelatedUuidStrings := functools.Map(results, func(x *rdiskDomain.LogicalVolume) string { return x.UUID.String() })\n\tdrgroupRelations, err := app.GetRegistry(ctx).Viewers.DRGroup.QueryRelationsMap(ctx, appId, relatedUuidStrings)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Stage 5 - 组装数据返回\n\n\tgroupNameToSpecMap := make(map[string]*pb.AffinitySpec)\n\tresponseDataRef := functools.MapRef(make([]pb.RDisk, len(results)))\n\tfor i := range results {\n\t\tencodeLogicalVolume(results[i], responseDataRef[i])\n\n\t\t// 找到关联的置放群组并返回\n\t\tif drgroupViews, ok := drgroupRelations[results[i].UUID.String()]; ok {\n\t\t\tresponseDataRef[i].AffinitySpec = make([]*pb.AffinitySpec, len(drgroupViews))\n\t\t\tfor j := range drgroupViews {\n\t\t\t\tgroupName := drgroupViews[j].Name\n\t\t\t\tif spec, ok := groupNameToSpecMap[groupName]; ok {\n\t\t\t\t\tresponseDataRef[i].AffinitySpec[j] = spec\n\t\t\t\t} else {\n\t\t\t\t\tspec := encodeDRGroupView(drgroupViews[j], &pb.AffinitySpec{}, results[i].UUID.String())\n\t\t\t\t\tgroupNameToSpecMap[groupName] = spec\n\t\t\t\t\tresponseDataRef[i].AffinitySpec[j] = spec\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\treturn &pb.QueryRDiskVolResponse{Disks: responseDataRef}, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 214,
        "code_end_line": 220,
        "code_key": "queryUserAppId",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) queryUserAppId(ctx context.Context) (users.AppID, error) {\n\tappId, err := app.GetRegistry(ctx).Viewers.LogicalVolume.ProbeAppID(ctx, nil, []rdiskDomain.Serial{c.Serial})\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn appId, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 5,
        "code_end_line": 27,
        "code_key": "DmRdisk",
        "code_value": "type DmRdisk struct {\n\tID                 uint64    `gorm:\"column:id;primaryKey\"`\n\tUUID               string    `gorm:\"column:uuid;unique\"`\n\tStatus             int       `gorm:\"column:status\"`\n\tAppID              int64     `gorm:\"column:app_id\"`\n\tSize               int64     `gorm:\"column:size\"`\n\tPhydiskSerial      string    `gorm:\"column:phydisk_serial\"`\n\tExtra              string    `gorm:\"column:extra\"`\n\tZoneID             int64     `gorm:\"column:zone_id\"`\n\tVolumeType         string    `gorm:\"column:volume_type\"`\n\tDiskType           string    `gorm:\"column:disk_type\"`\n\tReadIOPS           int64     `gorm:\"column:read_iops\"`\n\tReadBandwidth      int64     `gorm:\"column:read_bandwidth\"`\n\tWriteIOPS          int64     `gorm:\"column:write_iops\"`\n\tWriteBandwidth     int64     `gorm:\"column:write_bandwidth\"`\n\tReadWriteIOPS      int64     `gorm:\"column:rw_iops\"`\n\tReadWriteBandwidth int64     `gorm:\"column:rw_bandwidth\"`\n\tCreated            time.Time `gorm:\"column:created\"`\n\tUpdated            time.Time `gorm:\"column:updated\"`\n\n\tDmPhyDisk   *DmPhydisk          `gorm:\"foreignKey:Serial;references:PhydiskSerial\"`\n\tAttachments []DmRdiskAttachment `gorm:\"foreignKey:UUID;references:UUID\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 29,
        "code_end_line": 31,
        "code_key": "TableName",
        "code_value": "func (DmRdisk) TableName() string {\n\treturn \"dm_rdisk\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/model.go",
        "code_start_line": 6,
        "code_end_line": 6,
        "code_key": "UUID",
        "code_value": "type UUID string",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/common/model.go",
        "code_start_line": 6,
        "code_end_line": 6,
        "code_key": "UUID",
        "code_value": "type UUID string",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 25,
        "code_end_line": 25,
        "code_key": "Serial",
        "code_value": "type Serial string",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/logi_vol.go:109:132:FindByIDs": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/logi_vol.go",
    "code_start_line": 109,
    "code_end_line": 132,
    "code_start_column": 35,
    "code_key": "FindByIDs",
    "code_value": "func (v *logicalVolumeViewerImpl) FindByIDs(ctx context.Context, appID users.AppID, id []uuid.UUID) ([]*rdiskDomain.LogicalVolume, error) {\n\tvar (\n\t\tresultViews   []rdiskDomain.LogicalVolume\n\t\tresultViewRef []*rdiskDomain.LogicalVolume\n\t\tdataObjects   []*metadb.DmRdisk\n\t)\n\n\tuuidStrSlice := functools.Map(id, func(i uuid.UUID) string { return i.String() })\n\tresult := v.db.WithContext(ctx).Preload(\"DmPhyDisk\").Find(&dataObjects, \"app_id = ? and uuid in ?\", appID, uuidStrSlice)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(rdiskDomain.ErrVolumeNotExists, \"logical volume not exist\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\n\tresultViews = make([]rdiskDomain.LogicalVolume, len(dataObjects))\n\tresultViewRef = make([]*rdiskDomain.LogicalVolume, len(dataObjects))\n\tfor i := range dataObjects {\n\t\tresultViewRef[i] = &resultViews[i]\n\t\tv.translate(dataObjects[i], resultViewRef[i])\n\t}\n\treturn resultViewRef, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/consumer_srv/core/handlers/measure/cbs_appId_consumer.go",
        "code_start_line": 51,
        "code_end_line": 72,
        "code_key": "Handle",
        "code_value": "func (c *CbsAppIdConsumer) Handle(ctx context.Context, delivery *rabbitmq.Delivery) error {\n\tu, chargeTime, err := c.ParseDelivery(ctx, delivery)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif u == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"USER_INFO_NOT_FOUND\")\n\t\treturn nil\n\t}\n\n\tchargeDetail := c.GetChargeDetailForSingleUser(u, chargeTime)\n\tif chargeDetail == nil {\n\t\tlogs.Info(c.Ctx).\n\t\t\tUint64(\"appId\", uint64(u.AppId)).\n\t\t\tTime(\"chargeTime\", chargeTime).\n\t\t\tMsg(\"NO_RESOURCE_TO_CHARGE\")\n\t\treturn nil\n\t}\n\treturn c.ProcessChargeDetail(chargeDetail)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/defunct_physical_volume.go",
        "code_start_line": 105,
        "code_end_line": 116,
        "code_key": "Handle",
        "code_value": "func (c *DefunctPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tif err := c.ensureLocks(ctx); err != nil {\n\t\treturn err\n\t}\n\tif c.lvUUID != nil {\n\t\t// 涉及到逻辑卷时，需要先标记逻辑卷为故障\n\t\treturn c.handleBindedVolume(ctx)\n\t} else {\n\t\t// 不涉及到逻辑卷时，直接标记物理卷为故障\n\t\treturn c.handleIdleVolume(ctx)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/detach_logical_volume.go",
        "code_start_line": 56,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *DetachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDetachLogicalVolume, c)\n\n\t// 如果没有挂载到指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume not attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_benchmark_task.go",
        "code_start_line": 125,
        "code_end_line": 165,
        "code_key": "Handle",
        "code_value": "func (c *CreateBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tvolSm     = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = volSm.Fire(ctx, c.relatedVolume.State, domain.PVEStartBenchmark, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark = benchmark.New(benchmark.DiskInfo{\n\t\tSerial: string(c.relatedVolume.Serial),\n\t\tHostIP: c.relatedVolume.IP,\n\t\tBDF:    string(c.relatedVolume.BDF),\n\t})\n\n\tif err = benchRepo.Add(ctx, c.relatedBenchmark); err != nil {\n\t\tdelegate := &benchmarkDelegate{cmd: c}\n\t\tif _err := delegate.TaskFinishCallback(ctx, c.relatedBenchmark); _err != nil {\n\t\t\tlogs.Warn(ctx).Err(_err).Str(\"serial\", string(c.relatedVolume.Serial)).Msg(\"failed to rollback: create bdev\")\n\t\t}\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventCreateBench,\n\t\tbenchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_logical_volume.go",
        "code_start_line": 71,
        "code_end_line": 108,
        "code_key": "Handle",
        "code_value": "func (d *DeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\td.volume, err = repo.FindByID(ctx, d.UUID)\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif e := d.volume.CheckDelete(); e != nil {\n\t\treturn e\n\t}\n\n\tif d.volume.AppID != d.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"refuse to delet: app id mismatch\")\n\t}\n\n\td.drgroup, err = app.GetRegistry(ctx).Repositories.DRGroup.FindByMember(ctx, d.AppID, d.volume.UUID.String())\n\tif err != nil {\n\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\td.drgroup = nil\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := d.checkDRGroupMatch(ctx); err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, d.volume.State, rdiskDomain.LVEMarkToRecycle, d)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_recycled_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmRecycledPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEConfirmRecycled, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_rdisk_backup.go",
        "code_start_line": 52,
        "code_end_line": 75,
        "code_key": "Handle",
        "code_value": "func (c *DeleteRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tsm   = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\tc.relatedBackup, err = repo.FindByUUID(ctx, c.BackupID.String())\n\tif err != nil || c.relatedBackup == nil || c.relatedBackup.AppID != c.AppID {\n\t\treturn errors.New(backupDomain.ErrBackupNotExist, \"backup not exists\")\n\t}\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tc.relatedBackup.Status,\n\t\tbackupDomain.EventSoftDeleteBackup,\n\t\tbackupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: c.relatedBackup})\n\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_rdisk_backup.go",
        "code_start_line": 47,
        "code_end_line": 80,
        "code_key": "Handle",
        "code_value": "func (c *CreateRDiskBackupCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tlvSm  = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\tbakSm = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo  = app.GetRegistry(ctx).Repositories.Backup\n\t)\n\tc.relatedVolume, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil || c.relatedVolume == nil || c.relatedVolume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t_, err = lvSm.Fire(ctx, c.relatedVolume.State, rdiskDomain.LVEBackupStarted, c)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tlv := c.relatedVolume\n\tbackup := backupDomain.New(\n\t\tlv.AppID,\n\t\tbackupDomain.DiskInfo{\n\t\t\tVolumeUUID: lv.UUID,\n\t\t\tVolumeSize: uint64(lv.Size),\n\t\t\tHostIP:     lv.PhysicalVolume.IP,\n\t\t\tHostBDF:    string(lv.PhysicalVolume.BDF),\n\t\t\tSerial:     string(lv.PhysicalVolume.Serial),\n\t\t},\n\t)\n\tif err := repo.Add(ctx, backup); err != nil {\n\t\treturn err\n\t}\n\tc.relatedBackup = backup\n\t_, err = bakSm.Fire(ctx, backupDomain.StatusInit, backupDomain.EventStartBackup, backupDomain.Data{Delegate: &backupDelegate{Data: c}, Backup: backup})\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/attach_logical_volume.go",
        "code_start_line": 49,
        "code_end_line": 71,
        "code_key": "Handle",
        "code_value": "func (c *AttachLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByAppIDAndUUID(ctx, c.AppID, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEAttachLogicalVolume, c)\n\n\t// 如果已经挂载到了指定的主机上，则直接返回成功\n\tif errors.IsCode(err, rdiskDomain.ErrVolumeAlreadyAttachedToHost) {\n\t\tlogs.Info(ctx).Str(\"uuid\", c.UUID.String()).Str(\"host_ip\", c.IP.String()).\n\t\t\tMsg(\"volume already attached to host\")\n\t\treturn nil\n\t}\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_delete_logical_volume.go",
        "code_start_line": 34,
        "code_end_line": 55,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDeleteLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\t// 如果逻辑卷不存在，则直接返回成功\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrAppIDMismatch, \"failed to confirm delete: app id mismatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEDeleteLogicalVolume, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/offline_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OfflinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOfflinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *DeletePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\t// 如果物理卷不存在，则直接幂等返回\n\t\treturn nil\n\t}\n\n\tvar event = domain.PVEDeletePhysicalVolume\n\tif c.Force && (c.relatedVolume.State == domain.PVSDefunct) {\n\t\t// 这里的实现不太好，状态机的逻辑不应该侵入 cmd\n\t\t// 时间太赶了，后续重构优化吧\n\t\tevent = domain.PVEForceDeleteForDefunct\n\t}\n\n\tif c.relatedVolume.HasBindedPV() {\n\t\treturn errors.New(domain.ErrVolumeBusy, \"logic volume has binded to this physical volume\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, event, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_logical_volume.go",
        "code_start_line": 55,
        "code_end_line": 70,
        "code_key": "Handle",
        "code_value": "func (c *CleanupLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVECleanupLogicalVolume, c)\n\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_init_physical_volume.go",
        "code_start_line": 26,
        "code_end_line": 52,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmInitPhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\tif c.relatedVolume.IP.String() != c.Host.String() {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume host ip mistmatch\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVECreatePhysicalVolumeOnHost, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_physical_volume.go",
        "code_start_line": 51,
        "code_end_line": 101,
        "code_key": "Handle",
        "code_value": "func (c *CreatePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\n\t// 获取物理卷状态机\n\tsm := app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\trepo := app.GetRegistry(ctx).Repositories.PhysicalVolume\n\n\t// 检查物理卷是否已经存在，如果存在则直接幂等返回\n\tvol1, err := repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"serial\", c.Serial).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tvol2, err := repo.FindByIPAndBDF(ctx, c.Host, domain.BDF(c.BDF))\n\tif err != nil && !errors.IsCode(err, domain.ErrPhysicalVolumeNotExists) {\n\t\tlogs.Warn(ctx).Err(err).Str(\"host\", c.Host.String()).Str(\"bdf\", c.BDF).Msg(\"failed query existing physical volume\")\n\t\treturn errors.Newf(domain.ErrQueryPhysicalVolumeFailed, \"failed query existing physical volume: %v\", err)\n\t}\n\tfor _, vol := range []*domain.PhysicalVolume{vol1, vol2} {\n\t\texisted, err := c.checkExisting(ctx, vol)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif existed {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// 触发事件，创建物理卷\n\t_, err = sm.Fire(ctx,\n\t\tdomain.PVSUnInited,\n\t\tdomain.PVECreatePhysicalVolume,\n\t\tc,\n\t)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 创建 Bdev 以及格式化移动到创建物理卷的状态机中\n\n\t// _, err = sm.Fire(ctx,\n\t// \tc.GetPhysicalVolume().State,\n\t// \tdomain.PVECreatePhysicalVolumeOnHost,\n\t// \tc,\n\t// )\n\t// if err != nil {\n\t// \treturn err\n\t// }\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/delete_benchmark_task.go",
        "code_start_line": 32,
        "code_end_line": 57,
        "code_key": "Handle",
        "code_value": "func (c *DeleteBenchmarkCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\terr       error\n\t)\n\n\tbench, err := benchRepo.FindByUUID(ctx, c.BenchmarkUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif bench.DiskInfo.Serial != c.Serial {\n\t\treturn errors.Newf(benchmark.ErrTaskNotFound, \"benchmark serial not match %s, want %s\", c.Serial, bench.DiskInfo.Serial)\n\t}\n\n\t_, err = benchSm.Fire(ctx, bench.Status, benchmark.EventDeleteBench, benchmark.Data{Benchmark: bench, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := benchRepo.Delete(ctx, bench); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/create_logical_volume.go",
        "code_start_line": 52,
        "code_end_line": 98,
        "code_key": "Handle",
        "code_value": "func (c *CreateLogicalVolumeCommand) Handle(ctx context.Context) (err error) {\n\tvar (\n\t\tpvRepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tlvRepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm     = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\t// 1. 查找底层物理卷\n\tc.selectedPhysicalVolume, err = pvRepo.FindBySerial(ctx, rdiskDomain.Serial(c.PhysicalVolumeSerial))\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// 检查底层物理卷大小是否满足要求\n\tif c.selectedPhysicalVolume.Size < rdiskDomain.Size(c.DiskSize) {\n\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume size %d is smaller than requested size %d\", c.selectedPhysicalVolume.Size, c.DiskSize)\n\t}\n\n\t// 检查底层物理卷性能等级是否满足要求\n\tif c.PerformanceRank != \"\" {\n\t\tif string(c.selectedPhysicalVolume.PerformanceRank) != c.PerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not match requested rank %s\", c.selectedPhysicalVolume.PerformanceRank, c.PerformanceRank)\n\t\t}\n\t} else {\n\t\tif c.selectedPhysicalVolume.PerformanceRank != rdiskDomain.DefaultPerformanceRank {\n\t\t\treturn errors.Newf(rdiskDomain.ErrPhysicalVolumeSizeNotMatch, \"physical volume performance rank %s is not default rank %s\", c.selectedPhysicalVolume.PerformanceRank, rdiskDomain.DefaultPerformanceRank)\n\t\t}\n\t}\n\n\t// 2. 创建逻辑卷\n\tvol := rdiskDomain.NewLogicalVolume(users.AppID(c.AppID), rdiskDomain.Size(c.DiskSize), rdiskDomain.ZoneID(c.ZoneID))\n\tif c.VolumeType != \"\" {\n\t\tvol.VolumeType = rdiskDomain.VolumeType(c.VolumeType)\n\t}\n\tif c.DiskType != \"\" {\n\t\tvol.DiskType = rdiskDomain.DiskType(c.DiskType)\n\t}\n\terr = lvRepo.Add(ctx, vol)\n\tif err != nil {\n\t\treturn\n\t}\n\tc.createdLogicalVolume = vol\n\n\t// 3. 触发状态机，联动更新逻辑卷和物理卷状态\n\t_, err = sm.Fire(ctx, rdiskDomain.LVSUnInited, rdiskDomain.LVECreateLogicalVolume, c)\n\treturn\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_running_backup_task.go",
        "code_start_line": 31,
        "code_end_line": 61,
        "code_key": "Handle",
        "code_value": "func (c *UpdateRunningBackupTaskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventUpdateBackupProgress,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_drgroup.go",
        "code_start_line": 78,
        "code_end_line": 173,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeDRGroupCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\tlvView  = app.GetRegistry(ctx).Viewers.LogicalVolume\n\t\tdrgRepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t\tsm      = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t\terr     error\n\t)\n\n\t// 0. 初始化\n\tc.drgroupRef = make(map[string]*drgroup.DRGroup)\n\n\t// 1. 加载所有逻辑卷所在的置放群组\n\tallVolumeUUIDs := make([]string, 0, len(c.UUIDs))\n\tfor _, _uuid := range c.UUIDs {\n\t\tallVolumeUUIDs = append(allVolumeUUIDs, _uuid.String())\n\t}\n\tif groups, err := drgRepo.FindByMembers(ctx, c.AppID, allVolumeUUIDs); err == nil {\n\t\tif err != nil {\n\t\t\tif !errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tfor _, group := range groups {\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t\tc.curDRGroupNames = append(c.curDRGroupNames, group.Name)\n\t\t}\n\t} else {\n\t\treturn err\n\t}\n\n\t// 2. 确认已上锁的置放群组和当前一致\n\tif !c.checkLockedDRGroupNames() {\n\t\treturn errors.New(drgroup.ErrGroupModified, \"drgroup changed\")\n\t}\n\n\t// 3. 加载所有逻辑卷的状态，不需要完整实体，因为不会修改 Volume\n\tc.relatedLogicalVolume, err = lvView.FindByIDs(ctx, c.AppID, c.UUIDs)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(c.relatedLogicalVolume) < len(c.UUIDs) {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not exists\")\n\t}\n\n\t// 4. 加载所有目标置放群组，key 为 name\n\tfor _, spec := range c.Specs {\n\t\tvar group *drgroup.DRGroup\n\t\tif _, ok := c.drgroupRef[spec.Name]; ok {\n\t\t\tgroup = c.drgroupRef[spec.Name]\n\t\t} else {\n\t\t\tgroup, err = c.getOrCreateDRGroup(ctx, drgRepo, spec)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.drgroupRef[group.Name] = group\n\t\t}\n\n\t\tif spec.Affinity > 0 {\n\t\t\tgroup.Affinity = spec.Affinity\n\t\t}\n\t\tif spec.Type != \"\" {\n\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t}\n\t}\n\n\t// 5. 对所有逻辑卷执行置放群组变更事件，检查状态是否允许，\n\t//    实际的更新还是在这里执行。\n\tfor _, vol := range c.relatedLogicalVolume {\n\t\terr := sm.Check(ctx, vol.State, rdiskDomain.LVEUpdateDrGroup, c)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// 将逻辑卷从原有的置放群组中移除\n\t\tfor _, name := range c.curDRGroupNames {\n\t\t\tc.drgroupRef[name].RemoveMember(vol.UUID.String())\n\t\t}\n\t\t// 将逻辑卷添加到新的置放群组中\n\t\tfor _, spec := range c.Specs {\n\t\t\tsubGroup := spec.SubGroup\n\t\t\tif subGroup == \"\" {\n\t\t\t\t// 如果没有指定子组，则使用远端 SSD UUID 作为子组名称\n\t\t\t\t// 相当于每块盘都是一个子组，相当于没有使用子组功能\n\t\t\t\tsubGroup = vol.UUID.String()\n\t\t\t}\n\t\t\tif err := c.drgroupRef[spec.Name].AddMember(vol.UUID.String(), subGroup, vol.PhysicalVolume.IP.String()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tif c.DryRun {\n\t\treturn errors.New(errors.ErrDryRunSuccessExit, \"dry run check success\")\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/online_physical_volume.go",
        "code_start_line": 24,
        "code_end_line": 46,
        "code_key": "Handle",
        "code_value": "func (c *OnlinePhysicalVolumeCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEOnlinePhysicalVolume, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_benchmark_task.go",
        "code_start_line": 34,
        "code_end_line": 58,
        "code_key": "Handle",
        "code_value": "func (c *UpdateBenchmarkTask) Handle(ctx context.Context) error {\n\tvar (\n\t\tbenchSm   = app.GetRegistry(ctx).StateMachines.Benchmark\n\t\tvolRepo   = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tbenchRepo = app.GetRegistry(ctx).Repositories.Benchmark\n\t\terr       error\n\t)\n\n\tc.relatedVolume, err = volRepo.FindBySerial(ctx, rdisk.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBenchmark, err = benchRepo.FindByUUID(ctx, c.BenchmarkUUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = benchSm.Fire(ctx, c.relatedBenchmark.Status, benchmark.EventUpdateBench, benchmark.Data{Benchmark: c.relatedBenchmark, Delegate: &benchmarkDelegate{cmd: c}})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_logical_volume_flow_ctrl.go",
        "code_start_line": 80,
        "code_end_line": 103,
        "code_key": "Handle",
        "code_value": "func (c *UpdateLogicalVolumeFlowControlCommand) Handle(ctx context.Context) (err error) {\n\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.LogicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\t)\n\n\tc.volume, err = repo.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif c.volume.AppID != c.AppID {\n\t\treturn errors.New(rdiskDomain.ErrVolumeNotExists, \"volume not found\")\n\t}\n\n\tspec := c.volume.FlowControlSpec\n\tif !c.UpdateRequest.UpdateSpec(&spec, c.volume.GetDefaultFlowControlSpec()) {\n\t\t// 没有任何更新，直接返回成功\n\t\treturn nil\n\t}\n\tc.volume.SetFlowControlSpec(spec)\n\t_, err = sm.Fire(ctx, c.volume.State, rdiskDomain.LVEUpdateFlowControl, c)\n\treturn err\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/cleanup_defunct_volume.go",
        "code_start_line": 46,
        "code_end_line": 78,
        "code_key": "Handle",
        "code_value": "func (c *CleanupDefunctCommand) Handle(ctx context.Context) error {\n\tvar err error\n\tc.lv, err = app.GetRegistry(ctx).Repositories.LogicalVolume.FindByID(ctx, c.UUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar sm = app.GetRegistry(ctx).StateMachines.LogicalVolume\n\tvar event = rdiskDomain.LVECleanupDefunct\n\n\tfor _, attachment := range c.lv.Attachments {\n\t\tlogs.Info(ctx).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).Msg(\"cleanup defuncting volume\")\n\t\tsubCmd := &cleanDefunctSubCommand{Parent: c, HostIP: attachment.IP}\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, subCmd)\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，因为只要有一个挂载点清理失败，其他挂载点还是需要继续清理的\n\t\t\t// 失败的挂载点会在后台继续清理\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Stringer(\"host\", attachment.IP).\n\t\t\t\tMsg(\"failed to cleanup defunct volume, retry later.\")\n\t\t}\n\t}\n\n\tif len(c.lv.Attachments) == 0 {\n\t\t// 没有挂载点，直接清理\n\t\t_, err = sm.Fire(ctx, c.lv.State, event, &cleanDefunctSubCommand{Parent: c, HostIP: net.IP{}})\n\t\tif err != nil {\n\t\t\t// 这里不需要返回错误，后续自动重试即可\n\t\t\tlogs.Error(ctx).Err(err).Stringer(\"uuid\", c.UUID).Msg(\"failed to complete cleanup defunct volume\")\n\t\t}\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/confirm_drgroup_exists.go",
        "code_start_line": 28,
        "code_end_line": 53,
        "code_key": "Handle",
        "code_value": "func (c *ConfirmDRGroupExistsCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.DRGroup\n\t)\n\tfor _, spec := range c.DRGroup {\n\t\t_, err := repo.FindByName(ctx, users.AppID(c.AppID), spec.Name)\n\t\tif err != nil {\n\t\t\tif errors.IsCode(err, drgroup.ErrGroupNotExist) {\n\t\t\t\tgroup := drgroup.New(spec.Name, users.AppID(c.AppID))\n\t\t\t\tif spec.Affinity > 0 {\n\t\t\t\t\tgroup.Affinity = spec.Affinity\n\t\t\t\t}\n\t\t\t\tif spec.Type != \"\" {\n\t\t\t\t\tgroup.Type = drgroup.LocType(spec.Type)\n\t\t\t\t}\n\t\t\t\terr = repo.Add(ctx, group)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/update_physical_volume.go",
        "code_start_line": 31,
        "code_end_line": 54,
        "code_key": "Handle",
        "code_value": "func (c *UpdatePhyRDiskCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepo = app.GetRegistry(ctx).Repositories.PhysicalVolume\n\t\tsm   = app.GetRegistry(ctx).StateMachines.PhysicalVolume\n\t\terr  error\n\t)\n\n\tc.relatedVolume, err = repo.FindBySerial(ctx, domain.Serial(c.Serial))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.relatedVolume == nil {\n\t\treturn errors.New(domain.ErrPhysicalVolumeNotExists, \"physical volume not exists\")\n\t}\n\n\t_, err = sm.Fire(ctx, c.relatedVolume.State, domain.PVEUpdatePhysicalVolume, c)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/commands/recycle_backup_data.go",
        "code_start_line": 32,
        "code_end_line": 62,
        "code_key": "Handle",
        "code_value": "func (c *RecycleBackupDataCommand) Handle(ctx context.Context) error {\n\tvar (\n\t\trepos = app.GetRegistry(ctx).Repositories\n\t\tsm    = app.GetRegistry(ctx).StateMachines.Backup\n\t)\n\n\tbak, err := repos.Backup.FindByUUID(ctx, c.UUID.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := repos.LogicalVolume.FindByID(ctx, bak.DiskInfo.VolumeUUID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.relatedBackup = bak\n\tc.relatedVolume = vol\n\n\t_, err = sm.Fire(\n\t\tctx,\n\t\tbak.Status,\n\t\tbackupDomain.EventDeleteBackup,\n\t\tbackupDomain.Data{Backup: bak, Delegate: &backupDelegate{Data: c}})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/rdisk/models.go",
        "code_start_line": 178,
        "code_end_line": 190,
        "code_key": "LogicalVolume",
        "code_value": "type LogicalVolume struct {\n\tEntityMixin\n\tUUID            uuid.UUID\n\tState           LogicalVolumeState\n\tSize            Size\n\tAppID           users.AppID\n\tZoneID          ZoneID\n\tDiskType        DiskType\n\tVolumeType      VolumeType\n\tFlowControlSpec FlowControlSpec\n\tPhysicalVolume  *PhysicalVolume\n\tAttachments     []*VolumeAttachment\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 5,
        "code_end_line": 27,
        "code_key": "DmRdisk",
        "code_value": "type DmRdisk struct {\n\tID                 uint64    `gorm:\"column:id;primaryKey\"`\n\tUUID               string    `gorm:\"column:uuid;unique\"`\n\tStatus             int       `gorm:\"column:status\"`\n\tAppID              int64     `gorm:\"column:app_id\"`\n\tSize               int64     `gorm:\"column:size\"`\n\tPhydiskSerial      string    `gorm:\"column:phydisk_serial\"`\n\tExtra              string    `gorm:\"column:extra\"`\n\tZoneID             int64     `gorm:\"column:zone_id\"`\n\tVolumeType         string    `gorm:\"column:volume_type\"`\n\tDiskType           string    `gorm:\"column:disk_type\"`\n\tReadIOPS           int64     `gorm:\"column:read_iops\"`\n\tReadBandwidth      int64     `gorm:\"column:read_bandwidth\"`\n\tWriteIOPS          int64     `gorm:\"column:write_iops\"`\n\tWriteBandwidth     int64     `gorm:\"column:write_bandwidth\"`\n\tReadWriteIOPS      int64     `gorm:\"column:rw_iops\"`\n\tReadWriteBandwidth int64     `gorm:\"column:rw_bandwidth\"`\n\tCreated            time.Time `gorm:\"column:created\"`\n\tUpdated            time.Time `gorm:\"column:updated\"`\n\n\tDmPhyDisk   *DmPhydisk          `gorm:\"foreignKey:Serial;references:PhydiskSerial\"`\n\tAttachments []DmRdiskAttachment `gorm:\"foreignKey:UUID;references:UUID\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 29,
        "code_end_line": 31,
        "code_key": "TableName",
        "code_value": "func (DmRdisk) TableName() string {\n\treturn \"dm_rdisk\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/model.go",
        "code_start_line": 6,
        "code_end_line": 6,
        "code_key": "UUID",
        "code_value": "type UUID string",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/common/model.go",
        "code_start_line": 6,
        "code_end_line": 6,
        "code_key": "UUID",
        "code_value": "type UUID string",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/backup.go:19:41:FindByAppID": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/backup.go",
    "code_start_line": 19,
    "code_end_line": 41,
    "code_start_column": 28,
    "code_key": "FindByAppID",
    "code_value": "func (v *backupViewerImpl) FindByAppID(ctx context.Context, appID users.AppID, uuids, rdisks []string) ([]*backup.View, error) {\n\tvar (\n\t\tviews []*backup.View\n\t\tdtos  []*metadb.DmRdiskBackup\n\t)\n\tquery := v.db.WithContext(ctx).Where(\"app_id = ?\", appID)\n\tif len(uuids) > 0 {\n\t\tquery = query.Where(\"uuid in ?\", uuids)\n\t}\n\tif len(rdisks) > 0 {\n\t\tquery = query.Where(\"rdisk_uuid in ?\", rdisks)\n\t}\n\tresult := query.Find(&dtos)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\tviews = functools.MapRef(make([]backup.View, len(dtos)))\n\tfor i := range dtos {\n\t\tv.translate(dtos[i], views[i])\n\t}\n\n\treturn views, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 704,
        "code_end_line": 706,
        "code_key": "QueryRDiskBackup",
        "code_value": "func (s *UnimplementedMaster) QueryRDiskBackup(ctx context.Context, req *QueryRDiskBackupRequest) (*QueryRDiskBackupResponse, error) {\n\treturn nil, errors.New(\"rpc QueryRDiskBackup of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1077,
        "code_end_line": 1095,
        "code_key": "QueryRDiskBackup",
        "code_value": "func (c *MasterClientProxyImpl) QueryRDiskBackup(ctx context.Context, req *QueryRDiskBackupRequest, opts ...client.Option) (*QueryRDiskBackupResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/QueryRDiskBackup\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"QueryRDiskBackup\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &QueryRDiskBackupResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 324,
        "code_end_line": 330,
        "code_key": "QueryRDiskBackup",
        "code_value": "func (m *MockMasterService) QueryRDiskBackup(ctx context.Context, req *QueryRDiskBackupRequest) (*QueryRDiskBackupResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"QueryRDiskBackup\", ctx, req)\n\tret0, _ := ret[0].(*QueryRDiskBackupResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 333,
        "code_end_line": 336,
        "code_key": "QueryRDiskBackup",
        "code_value": "func (mr *MockMasterServiceMockRecorder) QueryRDiskBackup(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryRDiskBackup\", reflect.TypeOf((*MockMasterService)(nil).QueryRDiskBackup), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 817,
        "code_end_line": 827,
        "code_key": "QueryRDiskBackup",
        "code_value": "func (m *MockMasterClientProxy) QueryRDiskBackup(ctx context.Context, req *QueryRDiskBackupRequest, opts ...client.Option) (*QueryRDiskBackupResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"QueryRDiskBackup\", varargs...)\n\tret0, _ := ret[0].(*QueryRDiskBackupResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 830,
        "code_end_line": 834,
        "code_key": "QueryRDiskBackup",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) QueryRDiskBackup(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryRDiskBackup\", reflect.TypeOf((*MockMasterClientProxy)(nil).QueryRDiskBackup), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 443,
        "code_end_line": 460,
        "code_key": "QueryRDiskBackup",
        "code_value": "func (*masterApiServerImpl) QueryRDiskBackup(ctx context.Context, req *pb.QueryRDiskBackupRequest) (*pb.QueryRDiskBackupResponse, error) {\n\tvar (\n\t\tview  = app.GetRegistry(ctx).Viewers.Backup\n\t\tappId = users.AppID(req.AppId)\n\t\tresp  = &pb.QueryRDiskBackupResponse{}\n\t)\n\n\tviews, err := view.FindByAppID(ctx, appId, req.FilterBackupId, req.FilterCbsUuid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdtos := functools.MapRef(make([]pb.RDiskBackup, len(views)))\n\tfunctools.MapTo(views, dtos, encodeRDiskBackupView)\n\tresp.Backup = dtos\n\n\treturn resp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/models.go",
        "code_start_line": 281,
        "code_end_line": 291,
        "code_key": "View",
        "code_value": "type View struct {\n\tID            uint64            // 群组 ID，用作实体 ID\n\tName          string            // 群组名称，在同一个 AppID 下必须唯一\n\tAppID         users.AppID       // 群组所属应用 ID\n\tType          LocType           // 群组类型，保留字段\n\tAffinity      int               // 亲和度，表示群组内成员在同一台位置上最多只能有多少个\n\tMemberCount   int               // 成员数量\n\tSubGroupCount int               // 子组数量\n\tSatisfied     bool              // 是否满足约束条件\n\tSubGroupMap   map[string]string // 成员 ID -> 子组名称的映射关系，注意这里可能只是部分成员的子集\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/backup/interfaces.go",
        "code_start_line": 11,
        "code_end_line": 19,
        "code_key": "View",
        "code_value": "type View struct {\n\tUUID       uuid.UUID    // 备份 UUID\n\tAppID      users.AppID  // 所属 AppID\n\tStatus     BackupStatus // 备份状态\n\tCreateTime time.Time    // 创建时间\n\tPercentage int          // 备份进度，0-100\n\tVolumeUUID uuid.UUID    // 远端 SSD UUID\n\tSize       uint64       // 备份大小(GB)\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 151,
        "code_end_line": 169,
        "code_key": "DmRdiskBackup",
        "code_value": "type DmRdiskBackup struct {\n\tID        uint64    `gorm:\"column:id;primaryKey\"` // 主键 ID\n\tAppID     int64     `gorm:\"column:app_id;\"`       // AppID\n\tUUID      string    `gorm:\"column:uuid;\"`         // 备份 UUID\n\tDiskUUID  string    `gorm:\"column:rdisk_uuid\"`    // RDisk UUID\n\tStatus    int       `gorm:\"column:status\"`        // 备份状态\n\tSize      uint64    `gorm:\"column:size\"`          // 远端 SSD 大小 in GiB\n\tPhyID     string    `gorm:\"column:phy_id\"`        // 物理卷 Serial\n\tHostIP    string    `gorm:\"column:host_ip\"`       // 主机 IP\n\tHostBDF   string    `gorm:\"column:host_bdf\"`      // 主机上物理盘 BDF 号\n\tCosAppId  int64     `gorm:\"column:cos_appid\"`     // COS AppId\n\tCosRegion string    `gorm:\"column:cos_region\"`    // COS 所在的地域，例如 gz\n\tCosBucket string    `gorm:\"column:cos_bucket\"`    // COS Bucket\n\tCosPath   string    `gorm:\"column:cos_path\"`      // COS Path\n\tPercent   int       `gorm:\"column:percent\"`       // 备份进度\n\tExtra     string    `gorm:\"column:extra\"`         // 额外信息\n\tCreated   time.Time `gorm:\"column:created\"`       // 备份创建时间\n\tUpdated   time.Time `gorm:\"column:updated\"`       // 备份更新时间\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 171,
        "code_end_line": 173,
        "code_key": "TableName",
        "code_value": "func (DmRdiskBackup) TableName() string {\n\treturn \"dm_rdisk_backup\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/drgroup.go:126:147:FindByAppID": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/drgroup.go",
    "code_start_line": 126,
    "code_end_line": 147,
    "code_start_column": 29,
    "code_key": "FindByAppID",
    "code_value": "func (d *drgroupViewerImpl) FindByAppID(ctx context.Context, appId users.AppID) ([]*drgroup.View, error) {\n\tvar (\n\t\tresultViews       []drgroup.View\n\t\tresultViewRef     []*drgroup.View\n\t\tdataObjects       []*metadb.DmDrgroup\n\t\tdataObjectMembers []*metadb.DmDrgroupMembers\n\t)\n\tresult := d.db.WithContext(ctx).Find(&dataObjects).Where(\"app_id = ?\", appId, dataObjectMembers)\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\treturn nil, errors.New(drgroup.ErrGroupNotExist, \"group not exist\")\n\t\t}\n\t\treturn nil, result.Error\n\t}\n\tresultViews = make([]drgroup.View, len(dataObjects))\n\tresultViewRef = make([]*drgroup.View, len(dataObjects))\n\tfor i := range dataObjects {\n\t\tresultViewRef[i] = &resultViews[i]\n\t\td.translate(dataObjects[i], resultViewRef[i])\n\t}\n\treturn resultViewRef, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 704,
        "code_end_line": 706,
        "code_key": "QueryRDiskBackup",
        "code_value": "func (s *UnimplementedMaster) QueryRDiskBackup(ctx context.Context, req *QueryRDiskBackupRequest) (*QueryRDiskBackupResponse, error) {\n\treturn nil, errors.New(\"rpc QueryRDiskBackup of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 1077,
        "code_end_line": 1095,
        "code_key": "QueryRDiskBackup",
        "code_value": "func (c *MasterClientProxyImpl) QueryRDiskBackup(ctx context.Context, req *QueryRDiskBackupRequest, opts ...client.Option) (*QueryRDiskBackupResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/QueryRDiskBackup\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"QueryRDiskBackup\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &QueryRDiskBackupResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 324,
        "code_end_line": 330,
        "code_key": "QueryRDiskBackup",
        "code_value": "func (m *MockMasterService) QueryRDiskBackup(ctx context.Context, req *QueryRDiskBackupRequest) (*QueryRDiskBackupResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"QueryRDiskBackup\", ctx, req)\n\tret0, _ := ret[0].(*QueryRDiskBackupResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 333,
        "code_end_line": 336,
        "code_key": "QueryRDiskBackup",
        "code_value": "func (mr *MockMasterServiceMockRecorder) QueryRDiskBackup(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryRDiskBackup\", reflect.TypeOf((*MockMasterService)(nil).QueryRDiskBackup), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 817,
        "code_end_line": 827,
        "code_key": "QueryRDiskBackup",
        "code_value": "func (m *MockMasterClientProxy) QueryRDiskBackup(ctx context.Context, req *QueryRDiskBackupRequest, opts ...client.Option) (*QueryRDiskBackupResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"QueryRDiskBackup\", varargs...)\n\tret0, _ := ret[0].(*QueryRDiskBackupResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 830,
        "code_end_line": 834,
        "code_key": "QueryRDiskBackup",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) QueryRDiskBackup(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryRDiskBackup\", reflect.TypeOf((*MockMasterClientProxy)(nil).QueryRDiskBackup), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 443,
        "code_end_line": 460,
        "code_key": "QueryRDiskBackup",
        "code_value": "func (*masterApiServerImpl) QueryRDiskBackup(ctx context.Context, req *pb.QueryRDiskBackupRequest) (*pb.QueryRDiskBackupResponse, error) {\n\tvar (\n\t\tview  = app.GetRegistry(ctx).Viewers.Backup\n\t\tappId = users.AppID(req.AppId)\n\t\tresp  = &pb.QueryRDiskBackupResponse{}\n\t)\n\n\tviews, err := view.FindByAppID(ctx, appId, req.FilterBackupId, req.FilterCbsUuid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdtos := functools.MapRef(make([]pb.RDiskBackup, len(views)))\n\tfunctools.MapTo(views, dtos, encodeRDiskBackupView)\n\tresp.Backup = dtos\n\n\treturn resp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/models.go",
        "code_start_line": 281,
        "code_end_line": 291,
        "code_key": "View",
        "code_value": "type View struct {\n\tID            uint64            // 群组 ID，用作实体 ID\n\tName          string            // 群组名称，在同一个 AppID 下必须唯一\n\tAppID         users.AppID       // 群组所属应用 ID\n\tType          LocType           // 群组类型，保留字段\n\tAffinity      int               // 亲和度，表示群组内成员在同一台位置上最多只能有多少个\n\tMemberCount   int               // 成员数量\n\tSubGroupCount int               // 子组数量\n\tSatisfied     bool              // 是否满足约束条件\n\tSubGroupMap   map[string]string // 成员 ID -> 子组名称的映射关系，注意这里可能只是部分成员的子集\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/backup/interfaces.go",
        "code_start_line": 11,
        "code_end_line": 19,
        "code_key": "View",
        "code_value": "type View struct {\n\tUUID       uuid.UUID    // 备份 UUID\n\tAppID      users.AppID  // 所属 AppID\n\tStatus     BackupStatus // 备份状态\n\tCreateTime time.Time    // 创建时间\n\tPercentage int          // 备份进度，0-100\n\tVolumeUUID uuid.UUID    // 远端 SSD UUID\n\tSize       uint64       // 备份大小(GB)\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 19,
        "code_end_line": 33,
        "code_key": "DmDrgroup",
        "code_value": "type DmDrgroup struct {\n\tID        uint64    `gorm:\"column:id;primaryKey\"`                              // 主键 ID\n\tStatus    int       `gorm:\"column:status\"`                                     // 状态, 目前无用\n\tAppID     int64     `gorm:\"column:app_id;index:dm_drgroup_app_id_name,unique\"` // AppID\n\tName      string    `gorm:\"column:name;index:dm_drgroup_app_id_name,unique\"`   // DRGroup 名称，用户名下唯一\n\tAffinity  int       `gorm:\"column:affinity\"`                                   // 亲和性\n\tLocType   string    `gorm:\"column:loc_type\"`                                   // 位置类型，对应 HOST、RACK、SWITCH 等等\n\tSatisfied int       `gorm:\"column:satisfied\"`                                  // 组内元素是否满足约束条件\n\tMemberCnt int       `gorm:\"column:member_cnt\"`                                 // 组内元素数量\n\tExtra     string    `gorm:\"column:extra\"`                                      // 额外信息\n\tCreated   time.Time `gorm:\"column:created\"`\n\tUpdated   time.Time `gorm:\"column:updated\"`\n\n\tMembers []DmDrgroupMembers `gorm:\"foreignKey:AppID,GroupName;references:AppID,Name\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 35,
        "code_end_line": 37,
        "code_key": "TableName",
        "code_value": "func (*DmDrgroup) TableName() string {\n\treturn \"dm_drgroup\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 114,
        "code_end_line": 129,
        "code_key": "DmDrgroup",
        "code_value": "type DmDrgroup struct {\n\tID          uint64    `gorm:\"column:id;primaryKey\"`                              // 主键 ID\n\tStatus      int       `gorm:\"column:status\"`                                     // 状态, 目前无用\n\tAppID       int64     `gorm:\"column:app_id;index:dm_drgroup_app_id_name,unique\"` // AppID\n\tName        string    `gorm:\"column:name;index:dm_drgroup_app_id_name,unique\"`   // DRGroup 名称，用户名下唯一\n\tAffinity    int       `gorm:\"column:affinity\"`                                   // 亲和性\n\tLocType     string    `gorm:\"column:loc_type\"`                                   // 位置类型，对应 HOST、RACK、SWITCH 等等\n\tSatisfied   int       `gorm:\"column:satisfied\"`                                  // 组内元素是否满足约束条件\n\tMemberCnt   int       `gorm:\"column:member_cnt\"`                                 // 组内元素数量\n\tSubGroupCnt int       `gorm:\"column:sub_group_cnt\"`                              // 子组数量\n\tExtra       string    `gorm:\"column:extra\"`                                      // 额外信息\n\tCreated     time.Time `gorm:\"column:created\"`\n\tUpdated     time.Time `gorm:\"column:updated\"`\n\n\tMembers []DmDrgroupMembers `gorm:\"foreignKey:AppID,GroupName;references:AppID,Name\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 131,
        "code_end_line": 133,
        "code_key": "TableName",
        "code_value": "func (*DmDrgroup) TableName() string {\n\treturn \"dm_drgroup\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 39,
        "code_end_line": 49,
        "code_key": "DmDrgroupMembers",
        "code_value": "type DmDrgroupMembers struct {\n\tID        uint64    `gorm:\"column:id;primaryKey\"`                                                          // 主键 ID\n\tAppID     int64     `gorm:\"column:app_id;index:dm_drgroup_members_app_id_group_name_member_id,unique\"`     // AppID\n\tGroupName string    `gorm:\"column:group_name;index:dm_drgroup_members_app_id_group_name_member_id,unique\"` // DRGroup 名称，用户名下唯一\n\tSubGroup  string    `gorm:\"column:sub_group\"`                                                              // 子组名称\n\tLoc       string    `gorm:\"column:loc\"`                                                                    // 位置信息，例如母机 IP\n\tMemberID  string    `gorm:\"column:member_id;index:dm_drgroup_members_app_id_group_name_member_id,unique\"`  // DRGroup 成员 ID，例如逻辑卷 UUID\n\tExtra     string    `gorm:\"column:extra\"`                                                                  // 额外信息\n\tCreated   time.Time `gorm:\"column:created\"`\n\tUpdated   time.Time `gorm:\"column:updated\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 55,
        "code_end_line": 57,
        "code_key": "TableName",
        "code_value": "func (DmDrgroupMembers) TableName() string {\n\treturn \"dm_drgroup_members\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/db/metadb/models/metadb.go",
        "code_start_line": 51,
        "code_end_line": 53,
        "code_key": "DBName",
        "code_value": "func (m DmDrgroupMembers) DBName() string {\n\treturn \"metadb\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 135,
        "code_end_line": 145,
        "code_key": "DmDrgroupMembers",
        "code_value": "type DmDrgroupMembers struct {\n\tID        uint64    `gorm:\"column:id;primaryKey\"`                                                          // 主键 ID\n\tAppID     int64     `gorm:\"column:app_id;index:dm_drgroup_members_app_id_group_name_member_id,unique\"`     // AppID\n\tGroupName string    `gorm:\"column:group_name;index:dm_drgroup_members_app_id_group_name_member_id,unique\"` // DRGroup 名称，用户名下唯一\n\tSubGroup  string    `gorm:\"column:sub_group\"`                                                              // 子组名称\n\tLoc       string    `gorm:\"column:loc\"`                                                                    // 位置信息，例如母机 IP\n\tMemberID  string    `gorm:\"column:member_id;index:dm_drgroup_members_app_id_group_name_member_id,unique\"`  // DRGroup 成员 ID，例如逻辑卷 UUID\n\tExtra     string    `gorm:\"column:extra\"`                                                                  // 额外信息\n\tCreated   time.Time `gorm:\"column:created\"`\n\tUpdated   time.Time `gorm:\"column:updated\"`\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 147,
        "code_end_line": 149,
        "code_key": "TableName",
        "code_value": "func (DmDrgroupMembers) TableName() string {\n\treturn \"dm_drgroup_members\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/backup.go:44:61:FindByDiskUUIDs": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/backup.go",
    "code_start_line": 44,
    "code_end_line": 61,
    "code_start_column": 28,
    "code_key": "FindByDiskUUIDs",
    "code_value": "func (v *backupViewerImpl) FindByDiskUUIDs(ctx context.Context, uuids []string) ([]*backup.View, error) {\n\tvar (\n\t\tviews []*backup.View\n\t\tdtos  []*metadb.DmRdiskBackup\n\t)\n\n\tresult := v.db.WithContext(ctx).Find(&dtos, \"rdisk_uuid in ?\", uuids)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\n\tviews = functools.MapRef(make([]backup.View, len(dtos)))\n\tfor i := range dtos {\n\t\tv.translate(dtos[i], views[i])\n\t}\n\n\treturn views, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/flow/actions/defunct.go",
        "code_start_line": 40,
        "code_end_line": 74,
        "code_key": "FireCancelBackupEventForDefunct",
        "code_value": "func FireCancelBackupEventForDefunct(ctx context.Context, source rdiskDomain.LogicalVolumeState, target rdiskDomain.LogicalVolumeState, stateCtx app.LogicalVolumeContext) (rdiskDomain.LogicalVolumeState, error) {\n\tvar (\n\t\terr          error\n\t\tstateMachine = app.GetRegistry(ctx).StateMachines.Backup\n\t\trepo         = app.GetRegistry(ctx).Repositories.Backup\n\t\tview         = app.GetRegistry(ctx).Viewers.Backup\n\t\tevent        = backup.EventForceSoftDeleteBackup\n\t)\n\n\tbackupViews, err := view.FindByDiskUUIDs(ctx, []string{stateCtx.GetLogicalVolume().UUID.String()})\n\tif err != nil {\n\t\treturn source, err\n\t}\n\trunningBackupUuid := lo.FilterMap(backupViews, func(backupView *backup.View, _ int) (string, bool) {\n\t\tif backupView.Status == backup.StatusRunning {\n\t\t\treturn backupView.UUID.String(), true\n\t\t}\n\t\treturn \"\", false\n\t})\n\n\tfor _, u := range runningBackupUuid {\n\t\tb, err := repo.FindByUUID(ctx, u)\n\t\tif err != nil {\n\t\t\tlogs.Warn(ctx).Str(\"uuid\", u).Msg(\"find backup by uuid failed\")\n\t\t\tcontinue\n\t\t}\n\t\t_, err = stateMachine.Fire(ctx, b.Status, event, backup.Data{Backup: b, Delegate: &backupDelegate{}})\n\t\tif err != nil {\n\t\t\tlogs.Warn(ctx).Err(err).Str(\"uuid\", u).Msg(\"fire cancel backup event failed\")\n\t\t\treturn source, err\n\t\t}\n\t}\n\n\treturn target, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/models.go",
        "code_start_line": 281,
        "code_end_line": 291,
        "code_key": "View",
        "code_value": "type View struct {\n\tID            uint64            // 群组 ID，用作实体 ID\n\tName          string            // 群组名称，在同一个 AppID 下必须唯一\n\tAppID         users.AppID       // 群组所属应用 ID\n\tType          LocType           // 群组类型，保留字段\n\tAffinity      int               // 亲和度，表示群组内成员在同一台位置上最多只能有多少个\n\tMemberCount   int               // 成员数量\n\tSubGroupCount int               // 子组数量\n\tSatisfied     bool              // 是否满足约束条件\n\tSubGroupMap   map[string]string // 成员 ID -> 子组名称的映射关系，注意这里可能只是部分成员的子集\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/backup/interfaces.go",
        "code_start_line": 11,
        "code_end_line": 19,
        "code_key": "View",
        "code_value": "type View struct {\n\tUUID       uuid.UUID    // 备份 UUID\n\tAppID      users.AppID  // 所属 AppID\n\tStatus     BackupStatus // 备份状态\n\tCreateTime time.Time    // 创建时间\n\tPercentage int          // 备份进度，0-100\n\tVolumeUUID uuid.UUID    // 远端 SSD UUID\n\tSize       uint64       // 备份大小(GB)\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 151,
        "code_end_line": 169,
        "code_key": "DmRdiskBackup",
        "code_value": "type DmRdiskBackup struct {\n\tID        uint64    `gorm:\"column:id;primaryKey\"` // 主键 ID\n\tAppID     int64     `gorm:\"column:app_id;\"`       // AppID\n\tUUID      string    `gorm:\"column:uuid;\"`         // 备份 UUID\n\tDiskUUID  string    `gorm:\"column:rdisk_uuid\"`    // RDisk UUID\n\tStatus    int       `gorm:\"column:status\"`        // 备份状态\n\tSize      uint64    `gorm:\"column:size\"`          // 远端 SSD 大小 in GiB\n\tPhyID     string    `gorm:\"column:phy_id\"`        // 物理卷 Serial\n\tHostIP    string    `gorm:\"column:host_ip\"`       // 主机 IP\n\tHostBDF   string    `gorm:\"column:host_bdf\"`      // 主机上物理盘 BDF 号\n\tCosAppId  int64     `gorm:\"column:cos_appid\"`     // COS AppId\n\tCosRegion string    `gorm:\"column:cos_region\"`    // COS 所在的地域，例如 gz\n\tCosBucket string    `gorm:\"column:cos_bucket\"`    // COS Bucket\n\tCosPath   string    `gorm:\"column:cos_path\"`      // COS Path\n\tPercent   int       `gorm:\"column:percent\"`       // 备份进度\n\tExtra     string    `gorm:\"column:extra\"`         // 额外信息\n\tCreated   time.Time `gorm:\"column:created\"`       // 备份创建时间\n\tUpdated   time.Time `gorm:\"column:updated\"`       // 备份更新时间\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 171,
        "code_end_line": 173,
        "code_key": "TableName",
        "code_value": "func (DmRdiskBackup) TableName() string {\n\treturn \"dm_rdisk_backup\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/backup.go:81:95:FindByUUIDs": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/backup.go",
    "code_start_line": 81,
    "code_end_line": 95,
    "code_start_column": 28,
    "code_key": "FindByUUIDs",
    "code_value": "func (v *backupViewerImpl) FindByUUIDs(ctx context.Context, uuids []string) ([]*backup.View, error) {\n\tvar (\n\t\tviews []*backup.View\n\t\tdtos  []*metadb.DmRdiskBackup\n\t)\n\tresult := v.db.WithContext(ctx).Find(&dtos, \"uuid in ?\", uuids)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\tviews = functools.MapRef(make([]backup.View, len(dtos)))\n\tfor i := range dtos {\n\t\tv.translate(dtos[i], views[i])\n\t}\n\treturn views, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/models.go",
        "code_start_line": 281,
        "code_end_line": 291,
        "code_key": "View",
        "code_value": "type View struct {\n\tID            uint64            // 群组 ID，用作实体 ID\n\tName          string            // 群组名称，在同一个 AppID 下必须唯一\n\tAppID         users.AppID       // 群组所属应用 ID\n\tType          LocType           // 群组类型，保留字段\n\tAffinity      int               // 亲和度，表示群组内成员在同一台位置上最多只能有多少个\n\tMemberCount   int               // 成员数量\n\tSubGroupCount int               // 子组数量\n\tSatisfied     bool              // 是否满足约束条件\n\tSubGroupMap   map[string]string // 成员 ID -> 子组名称的映射关系，注意这里可能只是部分成员的子集\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/backup/interfaces.go",
        "code_start_line": 11,
        "code_end_line": 19,
        "code_key": "View",
        "code_value": "type View struct {\n\tUUID       uuid.UUID    // 备份 UUID\n\tAppID      users.AppID  // 所属 AppID\n\tStatus     BackupStatus // 备份状态\n\tCreateTime time.Time    // 创建时间\n\tPercentage int          // 备份进度，0-100\n\tVolumeUUID uuid.UUID    // 远端 SSD UUID\n\tSize       uint64       // 备份大小(GB)\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 151,
        "code_end_line": 169,
        "code_key": "DmRdiskBackup",
        "code_value": "type DmRdiskBackup struct {\n\tID        uint64    `gorm:\"column:id;primaryKey\"` // 主键 ID\n\tAppID     int64     `gorm:\"column:app_id;\"`       // AppID\n\tUUID      string    `gorm:\"column:uuid;\"`         // 备份 UUID\n\tDiskUUID  string    `gorm:\"column:rdisk_uuid\"`    // RDisk UUID\n\tStatus    int       `gorm:\"column:status\"`        // 备份状态\n\tSize      uint64    `gorm:\"column:size\"`          // 远端 SSD 大小 in GiB\n\tPhyID     string    `gorm:\"column:phy_id\"`        // 物理卷 Serial\n\tHostIP    string    `gorm:\"column:host_ip\"`       // 主机 IP\n\tHostBDF   string    `gorm:\"column:host_bdf\"`      // 主机上物理盘 BDF 号\n\tCosAppId  int64     `gorm:\"column:cos_appid\"`     // COS AppId\n\tCosRegion string    `gorm:\"column:cos_region\"`    // COS 所在的地域，例如 gz\n\tCosBucket string    `gorm:\"column:cos_bucket\"`    // COS Bucket\n\tCosPath   string    `gorm:\"column:cos_path\"`      // COS Path\n\tPercent   int       `gorm:\"column:percent\"`       // 备份进度\n\tExtra     string    `gorm:\"column:extra\"`         // 额外信息\n\tCreated   time.Time `gorm:\"column:created\"`       // 备份创建时间\n\tUpdated   time.Time `gorm:\"column:updated\"`       // 备份更新时间\n}",
        "code_label": 3,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/db/metadb/model.go",
        "code_start_line": 171,
        "code_end_line": 173,
        "code_key": "TableName",
        "code_value": "func (DmRdiskBackup) TableName() string {\n\treturn \"dm_rdisk_backup\"\n}",
        "code_label": null,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/drgroup.go:24:73:QueryRelationsMap": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/viewers/drgroup.go",
    "code_start_line": 24,
    "code_end_line": 73,
    "code_start_column": 29,
    "code_key": "QueryRelationsMap",
    "code_value": "func (d *drgroupViewerImpl) QueryRelationsMap(ctx context.Context, appId users.AppID, members []string) (map[string][]*drgroup.View, error) {\n\tmembersRec := make([]*struct {\n\t\tMemberID    string\n\t\tGroupName   string\n\t\tSubGroup    string\n\t\tLocType     string\n\t\tAffinity    int\n\t\tMemberCnt   int\n\t\tSatisfied   int\n\t\tSubGroupCnt int\n\t}, 0, 10)\n\tresult := d.db.WithContext(ctx).Table(\"dm_drgroup_members\").\n\t\tSelect(\"dm_drgroup_members.member_id, dm_drgroup_members.group_name, dm_drgroup_members.sub_group, dm_drgroup.loc_type, dm_drgroup.affinity, dm_drgroup.member_cnt, dm_drgroup.satisfied, dm_drgroup.sub_group_cnt\").\n\t\tJoins(\"left join dm_drgroup on dm_drgroup_members.app_id = dm_drgroup.app_id and dm_drgroup_members.group_name = dm_drgroup.name\").\n\t\tWhere(\"dm_drgroup_members.app_id = ? and dm_drgroup_members.member_id in ?\", appId, members).\n\t\tScan(&membersRec)\n\tif result.Error != nil {\n\t\treturn nil, result.Error\n\t}\n\n\tresultMap := make(map[string][]*drgroup.View)\n\tviewMap := make(map[string]*drgroup.View)\n\tfor i := range membersRec {\n\t\tmember := membersRec[i].MemberID\n\t\tgroup := membersRec[i].GroupName\n\t\tif _, ok := resultMap[member]; !ok {\n\t\t\tresultMap[member] = make([]*drgroup.View, 0, 10)\n\t\t}\n\t\tif ref, ok := viewMap[group]; ok {\n\t\t\tref.SubGroupMap[member] = membersRec[i].SubGroup\n\t\t\tresultMap[member] = append(resultMap[member], ref)\n\t\t} else {\n\t\t\tref = &drgroup.View{\n\t\t\t\tName:          group,\n\t\t\t\tAppID:         appId,\n\t\t\t\tType:          drgroup.LocType(membersRec[i].LocType),\n\t\t\t\tAffinity:      membersRec[i].Affinity,\n\t\t\t\tMemberCount:   membersRec[i].MemberCnt,\n\t\t\t\tSatisfied:     membersRec[i].Satisfied >= 1,\n\t\t\t\tSubGroupCount: membersRec[i].SubGroupCnt,\n\t\t\t\tSubGroupMap:   make(map[string]string),\n\t\t\t}\n\t\t\tviewMap[group] = ref\n\t\t\tref.SubGroupMap[member] = membersRec[i].SubGroup\n\t\t\tresultMap[member] = append(resultMap[member], ref)\n\t\t}\n\t}\n\n\treturn resultMap, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 649,
        "code_end_line": 651,
        "code_key": "QueryRDiskVol",
        "code_value": "func (s *UnimplementedMaster) QueryRDiskVol(ctx context.Context, req *QueryRDiskVolRequest) (*QueryRDiskVolResponse, error) {\n\treturn nil, errors.New(\"rpc QueryRDiskVol of service Master is not implemented\")\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master.trpc.go",
        "code_start_line": 857,
        "code_end_line": 875,
        "code_key": "QueryRDiskVol",
        "code_value": "func (c *MasterClientProxyImpl) QueryRDiskVol(ctx context.Context, req *QueryRDiskVolRequest, opts ...client.Option) (*QueryRDiskVolResponse, error) {\n\tctx, msg := codec.WithCloneMessage(ctx)\n\tdefer codec.PutBackMessage(msg)\n\tmsg.WithClientRPCName(\"/trpc.rdisk.master.Master/QueryRDiskVol\")\n\tmsg.WithCalleeServiceName(MasterServer_ServiceDesc.ServiceName)\n\tmsg.WithCalleeApp(\"rdisk\")\n\tmsg.WithCalleeServer(\"master\")\n\tmsg.WithCalleeService(\"Master\")\n\tmsg.WithCalleeMethod(\"QueryRDiskVol\")\n\tmsg.WithSerializationType(codec.SerializationTypePB)\n\tcallopts := make([]client.Option, 0, len(c.opts)+len(opts))\n\tcallopts = append(callopts, c.opts...)\n\tcallopts = append(callopts, opts...)\n\trsp := &QueryRDiskVolResponse{}\n\tif err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn rsp, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 354,
        "code_end_line": 360,
        "code_key": "QueryRDiskVol",
        "code_value": "func (m *MockMasterService) QueryRDiskVol(ctx context.Context, req *QueryRDiskVolRequest) (*QueryRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"QueryRDiskVol\", ctx, req)\n\tret0, _ := ret[0].(*QueryRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 363,
        "code_end_line": 366,
        "code_key": "QueryRDiskVol",
        "code_value": "func (mr *MockMasterServiceMockRecorder) QueryRDiskVol(ctx, req interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryRDiskVol\", reflect.TypeOf((*MockMasterService)(nil).QueryRDiskVol), ctx, req)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 857,
        "code_end_line": 867,
        "code_key": "QueryRDiskVol",
        "code_value": "func (m *MockMasterClientProxy) QueryRDiskVol(ctx context.Context, req *QueryRDiskVolRequest, opts ...client.Option) (*QueryRDiskVolResponse, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{ctx, req}\n\tfor _, a := range opts {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"QueryRDiskVol\", varargs...)\n\tret0, _ := ret[0].(*QueryRDiskVolResponse)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/protogen/rdisk_master/rdisk_master_mock.go",
        "code_start_line": 870,
        "code_end_line": 874,
        "code_key": "QueryRDiskVol",
        "code_value": "func (mr *MockMasterClientProxyMockRecorder) QueryRDiskVol(ctx, req interface{}, opts ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{ctx, req}, opts...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"QueryRDiskVol\", reflect.TypeOf((*MockMasterClientProxy)(nil).QueryRDiskVol), varargs...)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/apiserver/app.go",
        "code_start_line": 498,
        "code_end_line": 596,
        "code_key": "QueryRDiskVol",
        "code_value": "func (*masterApiServerImpl) QueryRDiskVol(ctx context.Context, req *pb.QueryRDiskVolRequest) (*pb.QueryRDiskVolResponse, error) {\n\tview := app.GetRegistry(ctx).Viewers.LogicalVolume\n\tphyView := app.GetRegistry(ctx).Viewers.PhysicalVolume\n\tvar err error\n\n\ttype checker func(*pb.QueryRDiskVolRequest) error\n\tfor _, rule := range []checker{\n\t\t// 不允许不带任何参数的空查询\n\t\tcheckQueryRDiskVolNoEmptyQuery,\n\t\t// 如果带有 BdfIds 参数，必须带有 HostIps 参数缩小范围，单纯 Bdf 查询意义不大，区分度太低了\n\t\tcheckQueryRDiskVolBdfIdsMustComeWithHostIps,\n\t} {\n\t\tif err := rule(req); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Stage 1 - （如有）确认物理卷 Serials\n\tserials := []rdiskDomain.Serial{}\n\tif len(req.HostIps) > 0 {\n\t\tcriteria := rdiskDomain.PVSearchCriteria{\n\t\t\tIPs:           functools.Map(req.HostIps, net.ParseIP),\n\t\t\tSerials:       functools.Map(req.PhyIds, func(x string) rdiskDomain.Serial { return rdiskDomain.Serial(x) }),\n\t\t\tBDFs:          functools.Map(req.BdfIds, func(x string) rdiskDomain.BDF { return rdiskDomain.BDF(x) }),\n\t\t\tAvailableOnly: false,\n\t\t}\n\t\tphyDisks, err := phyView.Search(ctx, criteria, rdiskDomain.Pagination{Limit: 1000})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tserials = functools.Map(phyDisks, func(x *rdiskDomain.PhysicalVolume) rdiskDomain.Serial { return x.Serial })\n\t} else if len(req.PhyIds) > 0 {\n\t\tserials = functools.Map(req.PhyIds, func(x string) rdiskDomain.Serial { return rdiskDomain.Serial(x) })\n\t}\n\n\t// Stage 2 - 确认用户 AppId\n\tuuidSlice := functools.Map(req.CbsUuids, uuid.MustParse)\n\tappId := users.AppID(req.AppId)\n\tif req.AppId <= 0 {\n\t\tif appId, err = view.ProbeAppID(ctx, uuidSlice, serials); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Stage 3 - 发起查询\n\tcriteria := rdiskDomain.LVSearchCriteria{\n\t\tUUIDs:   uuidSlice,\n\t\tSerials: serials,\n\t}\n\tvar limit uint64 = 100\n\tvar offset uint64 = 0\n\tif req.Page != nil {\n\t\tlimit = req.Page.PageSize\n\t\toffset = req.Page.Page * limit\n\t}\n\n\tresults, err := view.Search(ctx, appId, criteria, rdiskDomain.Pagination{Limit: limit, Offset: offset})\n\tif err != nil {\n\t\tif errors.IsCode(err, rdiskDomain.ErrVolumeNotExists) {\n\t\t\treturn &pb.QueryRDiskVolResponse{}, nil\n\t\t}\n\t}\n\n\tif len(results) == 0 {\n\t\treturn &pb.QueryRDiskVolResponse{}, nil\n\t}\n\n\t// Stage 4 - 查询关联的置放群组\n\trelatedUuidStrings := functools.Map(results, func(x *rdiskDomain.LogicalVolume) string { return x.UUID.String() })\n\tdrgroupRelations, err := app.GetRegistry(ctx).Viewers.DRGroup.QueryRelationsMap(ctx, appId, relatedUuidStrings)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Stage 5 - 组装数据返回\n\n\tgroupNameToSpecMap := make(map[string]*pb.AffinitySpec)\n\tresponseDataRef := functools.MapRef(make([]pb.RDisk, len(results)))\n\tfor i := range results {\n\t\tencodeLogicalVolume(results[i], responseDataRef[i])\n\n\t\t// 找到关联的置放群组并返回\n\t\tif drgroupViews, ok := drgroupRelations[results[i].UUID.String()]; ok {\n\t\t\tresponseDataRef[i].AffinitySpec = make([]*pb.AffinitySpec, len(drgroupViews))\n\t\t\tfor j := range drgroupViews {\n\t\t\t\tgroupName := drgroupViews[j].Name\n\t\t\t\tif spec, ok := groupNameToSpecMap[groupName]; ok {\n\t\t\t\t\tresponseDataRef[i].AffinitySpec[j] = spec\n\t\t\t\t} else {\n\t\t\t\t\tspec := encodeDRGroupView(drgroupViews[j], &pb.AffinitySpec{}, results[i].UUID.String())\n\t\t\t\t\tgroupNameToSpecMap[groupName] = spec\n\t\t\t\t\tresponseDataRef[i].AffinitySpec[j] = spec\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\treturn &pb.QueryRDiskVolResponse{Disks: responseDataRef}, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/drgroup/models.go",
        "code_start_line": 281,
        "code_end_line": 291,
        "code_key": "View",
        "code_value": "type View struct {\n\tID            uint64            // 群组 ID，用作实体 ID\n\tName          string            // 群组名称，在同一个 AppID 下必须唯一\n\tAppID         users.AppID       // 群组所属应用 ID\n\tType          LocType           // 群组类型，保留字段\n\tAffinity      int               // 亲和度，表示群组内成员在同一台位置上最多只能有多少个\n\tMemberCount   int               // 成员数量\n\tSubGroupCount int               // 子组数量\n\tSatisfied     bool              // 是否满足约束条件\n\tSubGroupMap   map[string]string // 成员 ID -> 子组名称的映射关系，注意这里可能只是部分成员的子集\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/domain/backup/interfaces.go",
        "code_start_line": 11,
        "code_end_line": 19,
        "code_key": "View",
        "code_value": "type View struct {\n\tUUID       uuid.UUID    // 备份 UUID\n\tAppID      users.AppID  // 所属 AppID\n\tStatus     BackupStatus // 备份状态\n\tCreateTime time.Time    // 创建时间\n\tPercentage int          // 备份进度，0-100\n\tVolumeUUID uuid.UUID    // 远端 SSD UUID\n\tSize       uint64       // 备份大小(GB)\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/testutil/db.go:112:132:createTables": {
    "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/testutil/db.go",
    "code_start_line": 112,
    "code_end_line": 132,
    "code_start_column": 24,
    "code_key": "createTables",
    "code_value": "func (i dbInitializer) createTables(t *testing.T, db *gorm.DB) {\n\t// sqlContent, err := os.ReadFile(\"../../../../changelog/db/metadb/2309_0001_init_table.sql\")\n\tsqlContent, err := i.collectSqlInDir(t, \"../../../../changelog/db/metadb\")\n\n\trequire.NoError(t, err, \"failed to read db file\")\n\tstmts := strings.Split(sqlContent, \";\\n\")\n\tfor _, stmt := range stmts {\n\t\tstmt = strings.Trim(stmt, \" \\n\")\n\t\tif stmt == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tif strings.HasPrefix(stmt, \"USE \") {\n\t\t\t// Ignore USE statement\n\t\t\tcontinue\n\t\t}\n\t\terr = db.Exec(stmt).Error\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/test_utils/initdb.go",
        "code_start_line": 91,
        "code_end_line": 98,
        "code_key": "SetupTestDatabase",
        "code_value": "func (i dbInitializer) SetupTestDatabase(t *testing.T, database string) (*gorm.DB, func()) {\n\tidx := pool.Get()\n\tdb := i.openMySQLConnection(t, database)\n\treturn db, func() {\n\t\t_idx := idx\n\t\tpool.Release(_idx)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/testutil/db.go",
        "code_start_line": 102,
        "code_end_line": 110,
        "code_key": "SetupTestDatabase",
        "code_value": "func (i dbInitializer) SetupTestDatabase(t *testing.T) (*gorm.DB, func()) {\n\tidx := pool.Get()\n\tdb := i.openMySQLConnection(t, idx)\n\ti.createTables(t, db)\n\treturn db, func() {\n\t\t_idx := idx\n\t\tpool.Release(_idx)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": []
  },
  "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go:101:143:fetchExistingLocks": {
    "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
    "code_start_line": 101,
    "code_end_line": 143,
    "code_start_column": 23,
    "code_key": "fetchExistingLocks",
    "code_value": "func (l *mysqlLocker) fetchExistingLocks(tx *gorm.DB, keys []*dlock.LockKey) ([]string, []string, []string, error) {\n\treadKeys := make(map[string]string)\n\tfor _, key := range keys {\n\t\tif key.Type == dlock.ReadLock {\n\t\t\treadKeys[key.Key] = \"\"\n\t\t}\n\t}\n\n\ttype Result struct {\n\t\tLock    string\n\t\tExpired bool\n\t\tType    int\n\t}\n\n\tvar Results []Result\n\tkeysKey := dlock.LockKeySlice.GetKeys(keys)\n\terr := tx.Raw(\"SELECT `\"+l.lockColumn+\"` AS `lock`, `\"+l.expireColumn+\"` < NOW() AS `expired`, `\"+l.lockTypeColumn+\"` AS `type` FROM \"+l.tableName+\" WHERE `\"+l.lockColumn+\"` IN (?)\", keysKey).Scan(&Results).Error\n\tif err != nil {\n\t\treturn nil, nil, nil, errors.Wrap(err, \"fail to query locks\")\n\t}\n\n\tvar existingReadKeys []string = nil\n\tvar existingWriteKeys []string = nil\n\tvar expiredKeys []string = nil\n\n\tfor _, r := range Results {\n\t\tif !r.Expired {\n\t\t\tif _, exist := readKeys[r.Lock]; exist {\n\t\t\t\tif dlock.LockType(r.Type) == dlock.WriteLock {\n\t\t\t\t\texistingWriteKeys = append(existingWriteKeys, r.Lock)\n\t\t\t\t} else {\n\t\t\t\t\texistingReadKeys = append(existingReadKeys, r.Lock)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\texistingWriteKeys = append(existingWriteKeys, r.Lock)\n\t\t\t}\n\t\t} else {\n\t\t\texpiredKeys = append(expiredKeys, r.Lock)\n\t\t}\n\t}\n\n\treturn existingReadKeys, existingWriteKeys, expiredKeys, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 417,
        "code_end_line": 470,
        "code_key": "tryObtainMulti",
        "code_value": "func (l *mysqlLocker) tryObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, tokens []string, opts *dlock.Option) ([]string, error) {\n\t// Starts a new transaction.\n\ttx := l.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\n\n\t// Fetch existing locks.\n\texistingReadKeys, existingWriteKeys, expiredKeys, err := l.fetchExistingLocks(tx, keys)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// If there are existing valid locks, return an error.\n\tif len(existingWriteKeys) > 0 {\n\t\t_ = tx.Rollback()\n\t\treturn nil, errors.Wrap(dlock.ErrLockNotHeld, fmt.Sprintf(\"writeKeys %v are already locked\", existingWriteKeys))\n\t}\n\n\t// Delete expired locks if exists.\n\tif err := l.deleteExpiredLocks(tx, expiredKeys); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Remove existing readLocks from insert.\n\t// NOCA:QCloudAkCheck(误报)\n\tlockKeys, err := l.removeExistingReadLocksFromInsert(tx, keys, existingReadKeys)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Insert locks into database.\n\tneedInsertReadKeys, err := l.insertLocks(tx, lockKeys, ttl, tokens)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Update readLocks.\n\tvar needUpdateExpirationReadKeys []string = nil\n\tvar needUpdateCountReadKeys []string = nil\n\tif needUpdateExpirationReadKeys, needUpdateCountReadKeys, tokens, err = l.updateReadLocks(tx, ttl, existingReadKeys, tokens); err != nil {\n\t\tl.rollback(needUpdateCountReadKeys, tokens)\n\t\tl.rollback(needUpdateExpirationReadKeys, tokens)\n\t\tl.rollback(needInsertReadKeys, tokens)\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\tif result := tx.Commit(); result.Error != nil {\n\t\treturn nil, errors.Wrap(result.Error, \"failed to commit transaction\")\n\t}\n\n\treturn tokens, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mem/memdlock.go",
        "code_start_line": 106,
        "code_end_line": 166,
        "code_key": "tryObtainMulti",
        "code_value": "func (l *memLocker) tryObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, token string) (dlock.Lock, error) {\n\tl.mutex.Lock()\n\tdefer l.mutex.Unlock()\n\tvar readLocks []*dlock.LockKey\n\tvar writeLocks []*dlock.LockKey\n\tvar insertLocks []*dlock.LockKey\n\tvar tokens []string\n\ttokens = append(tokens, token)\n\tfor _, key := range keys {\n\t\tif key.Type == dlock.WriteLock {\n\t\t\twriteLocks = append(writeLocks, key)\n\t\t} else {\n\t\t\treadLocks = append(readLocks, key)\n\t\t}\n\t}\n\tfor _, key := range writeLocks {\n\t\tif item, ok := l.data[key.Key]; ok {\n\t\t\tif time.Until(item.ttl) > 0 {\n\t\t\t\treturn nil, dlock.ErrNotObtained\n\t\t\t} else {\n\t\t\t\tinsertLocks = append(insertLocks, key)\n\t\t\t}\n\t\t} else {\n\t\t\tinsertLocks = append(insertLocks, key)\n\t\t}\n\t}\n\tfor _, key := range readLocks {\n\t\tif item, ok := l.data[key.Key]; ok {\n\t\t\tif item.lockType == dlock.ReadLock {\n\t\t\t\tif time.Until(item.ttl) > 0 {\n\t\t\t\t\titem.count++\n\t\t\t\t\titem.ttl = time.Now().Add(ttl)\n\t\t\t\t\ttokens = append(tokens, item.token)\n\t\t\t\t} else {\n\t\t\t\t\tinsertLocks = append(insertLocks, key)\n\t\t\t\t}\n\t\t\t} else if time.Until(item.ttl) > 0 {\n\t\t\t\treturn nil, dlock.ErrNotObtained\n\t\t\t}\n\t\t} else {\n\t\t\tinsertLocks = append(insertLocks, key)\n\t\t}\n\t}\n\n\tfor _, key := range insertLocks {\n\t\tl.data[key.Key] = &lockItem{\n\t\t\tkey:      key.Key,\n\t\t\tttl:      time.Now().Add(ttl),\n\t\t\ttoken:    token,\n\t\t\tlockType: key.Type,\n\t\t\tcount:    1,\n\t\t}\n\t}\n\n\tlock := &memLock{\n\t\tlocker: l,\n\t\tkeys:   keys,\n\t\ttokens: tokens,\n\t}\n\treturn lock, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/infra/response/result.go",
        "code_start_line": 9,
        "code_end_line": 13,
        "code_key": "Result",
        "code_value": "type Result struct {\n\tCode    ErrorCode   `json:\"code\"`    // 错误码\n\tMessage string      `json:\"message\"` // 错误信息\n\tData    interface{} `json:\"data\"`    // 返回数据\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 109,
        "code_end_line": 113,
        "code_key": "Result",
        "code_value": "type Result struct {\n\t\tLock    string\n\t\tExpired bool\n\t\tType    int\n\t}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 149,
        "code_end_line": 151,
        "code_key": "Result",
        "code_value": "type Result struct {\n\t\tLock string\n\t}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 182,
        "code_end_line": 186,
        "code_key": "Result",
        "code_value": "type Result struct {\n\t\tLock       string\n\t\tExpiration time.Time\n\t\tToken      string\n\t}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go:148:162:fetchExistingLocksByKeysAndTokens": {
    "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
    "code_start_line": 148,
    "code_end_line": 162,
    "code_start_column": 23,
    "code_key": "fetchExistingLocksByKeysAndTokens",
    "code_value": "func (l *mysqlLocker) fetchExistingLocksByKeysAndTokens(tx *gorm.DB, keys []string, tokens []string) ([]string, error) {\n\ttype Result struct {\n\t\tLock string\n\t}\n\tvar results []Result\n\terr := tx.Raw(\"SELECT `\"+l.lockColumn+\"` AS `lock` FROM \"+l.tableName+\" WHERE `\"+l.lockColumn+\"` IN (?) AND `\"+l.tokenColumn+\"` IN (?) FOR UPDATE\", keys, tokens).Scan(&results).Error\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"fail to query locks\")\n\t}\n\tvar existingKeys []string = nil\n\tfor _, r := range results {\n\t\texistingKeys = append(existingKeys, r.Lock)\n\t}\n\treturn existingKeys, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/tracker.go",
        "code_start_line": 67,
        "code_end_line": 77,
        "code_key": "Refresh",
        "code_value": "func (rdp *PhyDiskTracker) Refresh(ctx context.Context) {\n\trdp.Track(ctx)\n\tlock.RDPhyCacheGlobalLock.GetLocker(lock.RDPhyLockKeyGenerator{}).Lock()\n\trdp.Merge(ctx, rdp.OriPhyDisks)\n\tlogs.Info(ctx).\n\t\tInt(\"disk_num\", len(rdp.ToCachedPhyDisks)).\n\t\tInt(\"member_num\", len(rdp.DrgroupMembers)).\n\t\tMsg(\"CACHE_AVAILABLE_PHY_DISK_AFTER_MERGE\")\n\trdp.CacheManager.RefreshCache(ctx, rdp.ToCachedPhyDisks, rdp.DrgroupMembers)\n\tlock.RDPhyCacheGlobalLock.GetLocker(lock.RDPhyLockKeyGenerator{}).Unlock()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/set/cache/tracker.go",
        "code_start_line": 35,
        "code_end_line": 38,
        "code_key": "Refresh",
        "code_value": "func (d *DiskSetTracker) Refresh(ctx context.Context) {\n\td.Track(ctx)\n\td.CacheManager.RefreshCache(ctx, d.DiskSetEntityInf)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 644,
        "code_end_line": 674,
        "code_key": "Refresh",
        "code_value": "func (l *mysqlLock) Refresh(ctx context.Context, ttl time.Duration) error {\n\n\ttx := l.locker.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\n\n\tkeysKey := dlock.LockKeySlice(l.keys).GetKeys()\n\t// NOCA:QCloudAkCheck(误报)\n\texistingLocks, err := l.locker.fetchExistingLocksByKeysAndTokens(tx, keysKey, l.tokens)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn err\n\t}\n\n\t// Compare existing locks with the keys.\n\tif !checkStrSetEqual(existingLocks, keysKey) {\n\t\t_ = tx.Rollback()\n\t\treturn errors.Wrap(dlock.ErrLockNotHeld, \"lock is not held\")\n\t}\n\n\t// Update the expiration time.\n\tif err := l.locker.updateLocksTTLByKeysAndTokens(tx, keysKey, l.tokens, ttl); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn err\n\t}\n\n\tif result := tx.Commit(); result.Error != nil {\n\t\treturn errors.Wrap(result.Error, \"failed to commit refresh locks\")\n\t}\n\n\tl.expiration = time.Now().Add(ttl)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mem/memdlock.go",
        "code_start_line": 189,
        "code_end_line": 210,
        "code_key": "Refresh",
        "code_value": "func (l *memLock) Refresh(ctx context.Context, ttl time.Duration) error {\n\tl.locker.mutex.Lock()\n\tdefer l.locker.mutex.Unlock()\n\n\ttokens := make(map[string]struct{}, len(l.tokens))\n\tfor _, item := range l.tokens {\n\t\ttokens[item] = struct{}{}\n\t}\n\tfor _, key := range l.keys {\n\t\tif item, ok := l.locker.data[key.Key]; ok {\n\t\t\tif _, exist := tokens[item.token]; !exist {\n\t\t\t\treturn dlock.ErrLockNotHeld\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, key := range l.keys {\n\t\tl.locker.data[key.Key].ttl = time.Now().Add(ttl)\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 309,
        "code_end_line": 332,
        "code_key": "updateLocksTTLByKeysAndTokens",
        "code_value": "func (l *mysqlLocker) updateLocksTTLByKeysAndTokens(tx *gorm.DB, keys []string, tokens []string, ttl time.Duration) error {\n\tif len(keys) == 0 {\n\t\treturn nil\n\t}\n\n\tresult := tx.Exec(\"UPDATE \"+l.tableName+\" SET \"+l.expireColumn+\" = NOW() + INTERVAL ? SECOND WHERE `\"+l.lockColumn+\"` IN (?) AND \"+l.tokenColumn+\" IN (?)\", ttl.Seconds(), keys, tokens)\n\tif result.Error != nil {\n\t\treturn errors.Wrap(result.Error, fmt.Sprintf(\"failed to update locks ttl: %s, token: %s\", keys, tokens))\n\t}\n\n\tif result.RowsAffected != int64(len(keys)) {\n\t\t// If the number of rows affected is not equal to the number of keys, it means that the locks are not updated.\n\t\t// We should check if the locks are still held. If not, return an error.\n\t\t// NOCA:QCloudAkCheck(误报)\n\t\tif existingsKeys, err := l.fetchExistingLocksByKeysAndTokens(tx, keys, tokens); err != nil {\n\t\t\treturn err\n\t\t} else if checkStrSetEqual(existingsKeys, keys) {\n\t\t\treturn nil\n\t\t}\n\t\treturn errors.Wrap(dlock.ErrLockNotHeld, fmt.Sprintf(\"keys %v are not updated\", keys))\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/infra/response/result.go",
        "code_start_line": 9,
        "code_end_line": 13,
        "code_key": "Result",
        "code_value": "type Result struct {\n\tCode    ErrorCode   `json:\"code\"`    // 错误码\n\tMessage string      `json:\"message\"` // 错误信息\n\tData    interface{} `json:\"data\"`    // 返回数据\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 109,
        "code_end_line": 113,
        "code_key": "Result",
        "code_value": "type Result struct {\n\t\tLock    string\n\t\tExpired bool\n\t\tType    int\n\t}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 149,
        "code_end_line": 151,
        "code_key": "Result",
        "code_value": "type Result struct {\n\t\tLock string\n\t}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 182,
        "code_end_line": 186,
        "code_key": "Result",
        "code_value": "type Result struct {\n\t\tLock       string\n\t\tExpiration time.Time\n\t\tToken      string\n\t}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go:165:176:deleteExpiredLocks": {
    "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
    "code_start_line": 165,
    "code_end_line": 176,
    "code_start_column": 23,
    "code_key": "deleteExpiredLocks",
    "code_value": "func (l *mysqlLocker) deleteExpiredLocks(tx *gorm.DB, keys []string) error {\n\tif len(keys) == 0 {\n\t\treturn nil\n\t}\n\n\tresult := tx.Exec(\"DELETE FROM \"+l.tableName+\" WHERE `\"+l.lockColumn+\"` IN (?) AND `\"+l.expireColumn+\"` < NOW()\", keys)\n\tif result.Error != nil {\n\t\treturn errors.Wrap(result.Error, \"failed to delete expired locks\")\n\t}\n\n\treturn nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 417,
        "code_end_line": 470,
        "code_key": "tryObtainMulti",
        "code_value": "func (l *mysqlLocker) tryObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, tokens []string, opts *dlock.Option) ([]string, error) {\n\t// Starts a new transaction.\n\ttx := l.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\n\n\t// Fetch existing locks.\n\texistingReadKeys, existingWriteKeys, expiredKeys, err := l.fetchExistingLocks(tx, keys)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// If there are existing valid locks, return an error.\n\tif len(existingWriteKeys) > 0 {\n\t\t_ = tx.Rollback()\n\t\treturn nil, errors.Wrap(dlock.ErrLockNotHeld, fmt.Sprintf(\"writeKeys %v are already locked\", existingWriteKeys))\n\t}\n\n\t// Delete expired locks if exists.\n\tif err := l.deleteExpiredLocks(tx, expiredKeys); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Remove existing readLocks from insert.\n\t// NOCA:QCloudAkCheck(误报)\n\tlockKeys, err := l.removeExistingReadLocksFromInsert(tx, keys, existingReadKeys)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Insert locks into database.\n\tneedInsertReadKeys, err := l.insertLocks(tx, lockKeys, ttl, tokens)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Update readLocks.\n\tvar needUpdateExpirationReadKeys []string = nil\n\tvar needUpdateCountReadKeys []string = nil\n\tif needUpdateExpirationReadKeys, needUpdateCountReadKeys, tokens, err = l.updateReadLocks(tx, ttl, existingReadKeys, tokens); err != nil {\n\t\tl.rollback(needUpdateCountReadKeys, tokens)\n\t\tl.rollback(needUpdateExpirationReadKeys, tokens)\n\t\tl.rollback(needInsertReadKeys, tokens)\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\tif result := tx.Commit(); result.Error != nil {\n\t\treturn nil, errors.Wrap(result.Error, \"failed to commit transaction\")\n\t}\n\n\treturn tokens, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mem/memdlock.go",
        "code_start_line": 106,
        "code_end_line": 166,
        "code_key": "tryObtainMulti",
        "code_value": "func (l *memLocker) tryObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, token string) (dlock.Lock, error) {\n\tl.mutex.Lock()\n\tdefer l.mutex.Unlock()\n\tvar readLocks []*dlock.LockKey\n\tvar writeLocks []*dlock.LockKey\n\tvar insertLocks []*dlock.LockKey\n\tvar tokens []string\n\ttokens = append(tokens, token)\n\tfor _, key := range keys {\n\t\tif key.Type == dlock.WriteLock {\n\t\t\twriteLocks = append(writeLocks, key)\n\t\t} else {\n\t\t\treadLocks = append(readLocks, key)\n\t\t}\n\t}\n\tfor _, key := range writeLocks {\n\t\tif item, ok := l.data[key.Key]; ok {\n\t\t\tif time.Until(item.ttl) > 0 {\n\t\t\t\treturn nil, dlock.ErrNotObtained\n\t\t\t} else {\n\t\t\t\tinsertLocks = append(insertLocks, key)\n\t\t\t}\n\t\t} else {\n\t\t\tinsertLocks = append(insertLocks, key)\n\t\t}\n\t}\n\tfor _, key := range readLocks {\n\t\tif item, ok := l.data[key.Key]; ok {\n\t\t\tif item.lockType == dlock.ReadLock {\n\t\t\t\tif time.Until(item.ttl) > 0 {\n\t\t\t\t\titem.count++\n\t\t\t\t\titem.ttl = time.Now().Add(ttl)\n\t\t\t\t\ttokens = append(tokens, item.token)\n\t\t\t\t} else {\n\t\t\t\t\tinsertLocks = append(insertLocks, key)\n\t\t\t\t}\n\t\t\t} else if time.Until(item.ttl) > 0 {\n\t\t\t\treturn nil, dlock.ErrNotObtained\n\t\t\t}\n\t\t} else {\n\t\t\tinsertLocks = append(insertLocks, key)\n\t\t}\n\t}\n\n\tfor _, key := range insertLocks {\n\t\tl.data[key.Key] = &lockItem{\n\t\t\tkey:      key.Key,\n\t\t\tttl:      time.Now().Add(ttl),\n\t\t\ttoken:    token,\n\t\t\tlockType: key.Type,\n\t\t\tcount:    1,\n\t\t}\n\t}\n\n\tlock := &memLock{\n\t\tlocker: l,\n\t\tkeys:   keys,\n\t\ttokens: tokens,\n\t}\n\treturn lock, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": []
  },
  "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go:178:233:updateReadLocks": {
    "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
    "code_start_line": 178,
    "code_end_line": 233,
    "code_start_column": 23,
    "code_key": "updateReadLocks",
    "code_value": "func (l *mysqlLocker) updateReadLocks(tx *gorm.DB, ttl time.Duration, keys []string, lockTokens []string) ([]string, []string, []string, error) {\n\tif len(keys) == 0 {\n\t\treturn nil, nil, lockTokens, nil\n\t}\n\ttype Result struct {\n\t\tLock       string\n\t\tExpiration time.Time\n\t\tToken      string\n\t}\n\tvar Results []Result\n\terr := tx.Raw(\"SELECT `\"+l.lockColumn+\"` AS `lock`, `\"+l.expireColumn+\"` AS `expiration`, `\"+l.tokenColumn+\"` AS `token` FROM \"+l.tableName+\" WHERE `\"+l.lockColumn+\"` IN (?)\", keys).Scan(&Results).Error\n\tif err != nil {\n\t\treturn nil, nil, nil, errors.Wrap(err, \"fail to query locks\")\n\t}\n\n\tvar needUpdateExpirationReadKeys []string = nil\n\tvar needUpdateCountReadKeys []string = nil\n\tl.mutex.Lock()\n\tt := time.Now()\n\tfor _, r := range Results {\n\t\tif r.Token != lockTokens[0] {\n\t\t\tlockTokens = append(lockTokens, r.Token)\n\t\t}\n\t\tif readKey, exist := l.readKeysMemLock[r.Lock]; exist {\n\t\t\treadKey.count++\n\t\t\treadKey.expiration = r.Expiration\n\t\t} else {\n\t\t\tl.readKeysMemLock[r.Lock] = &readKeysMemLock{\n\t\t\t\tcount:      1,\n\t\t\t\texpiration: r.Expiration,\n\t\t\t\ttoken:      r.Token,\n\t\t\t}\n\t\t\tneedUpdateCountReadKeys = append(needUpdateCountReadKeys, r.Lock)\n\t\t}\n\t\tif l.readKeysMemLock[r.Lock].expiration.Sub(t) < ttl/3 {\n\t\t\tl.readKeysMemLock[r.Lock].expiration = t.Add(ttl)\n\t\t\tneedUpdateExpirationReadKeys = append(needUpdateExpirationReadKeys, r.Lock)\n\t\t}\n\t}\n\tl.mutex.Unlock()\n\tif len(needUpdateExpirationReadKeys) > 0 {\n\t\tresult := tx.Exec(\"UPDATE \"+l.tableName+\" SET \"+l.expireColumn+\" = NOW() + INTERVAL ? SECOND WHERE `\"+l.lockColumn+\"` IN (?)\", ttl.Seconds(), needUpdateExpirationReadKeys)\n\t\tif result.Error != nil {\n\t\t\treturn nil, needUpdateExpirationReadKeys, needUpdateCountReadKeys, errors.Wrap(result.Error, fmt.Sprintf(\"failed to update readLocks: %s\", keys))\n\t\t}\n\t}\n\n\tif len(needUpdateCountReadKeys) > 0 {\n\t\tresult := tx.Exec(\"UPDATE \"+l.tableName+\" SET \"+l.lockNumsColumn+\" = \"+l.lockNumsColumn+\" + 1 WHERE `\"+l.lockColumn+\"` IN (?)\", needUpdateCountReadKeys)\n\t\tif result.Error != nil {\n\t\t\treturn nil, needUpdateExpirationReadKeys, needUpdateCountReadKeys, errors.Wrap(result.Error, fmt.Sprintf(\"failed to update readLocks: %s\", keys))\n\t\t}\n\t}\n\n\treturn nil, nil, lockTokens, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 3,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 417,
        "code_end_line": 470,
        "code_key": "tryObtainMulti",
        "code_value": "func (l *mysqlLocker) tryObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, tokens []string, opts *dlock.Option) ([]string, error) {\n\t// Starts a new transaction.\n\ttx := l.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\n\n\t// Fetch existing locks.\n\texistingReadKeys, existingWriteKeys, expiredKeys, err := l.fetchExistingLocks(tx, keys)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// If there are existing valid locks, return an error.\n\tif len(existingWriteKeys) > 0 {\n\t\t_ = tx.Rollback()\n\t\treturn nil, errors.Wrap(dlock.ErrLockNotHeld, fmt.Sprintf(\"writeKeys %v are already locked\", existingWriteKeys))\n\t}\n\n\t// Delete expired locks if exists.\n\tif err := l.deleteExpiredLocks(tx, expiredKeys); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Remove existing readLocks from insert.\n\t// NOCA:QCloudAkCheck(误报)\n\tlockKeys, err := l.removeExistingReadLocksFromInsert(tx, keys, existingReadKeys)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Insert locks into database.\n\tneedInsertReadKeys, err := l.insertLocks(tx, lockKeys, ttl, tokens)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Update readLocks.\n\tvar needUpdateExpirationReadKeys []string = nil\n\tvar needUpdateCountReadKeys []string = nil\n\tif needUpdateExpirationReadKeys, needUpdateCountReadKeys, tokens, err = l.updateReadLocks(tx, ttl, existingReadKeys, tokens); err != nil {\n\t\tl.rollback(needUpdateCountReadKeys, tokens)\n\t\tl.rollback(needUpdateExpirationReadKeys, tokens)\n\t\tl.rollback(needInsertReadKeys, tokens)\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\tif result := tx.Commit(); result.Error != nil {\n\t\treturn nil, errors.Wrap(result.Error, \"failed to commit transaction\")\n\t}\n\n\treturn tokens, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mem/memdlock.go",
        "code_start_line": 106,
        "code_end_line": 166,
        "code_key": "tryObtainMulti",
        "code_value": "func (l *memLocker) tryObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, token string) (dlock.Lock, error) {\n\tl.mutex.Lock()\n\tdefer l.mutex.Unlock()\n\tvar readLocks []*dlock.LockKey\n\tvar writeLocks []*dlock.LockKey\n\tvar insertLocks []*dlock.LockKey\n\tvar tokens []string\n\ttokens = append(tokens, token)\n\tfor _, key := range keys {\n\t\tif key.Type == dlock.WriteLock {\n\t\t\twriteLocks = append(writeLocks, key)\n\t\t} else {\n\t\t\treadLocks = append(readLocks, key)\n\t\t}\n\t}\n\tfor _, key := range writeLocks {\n\t\tif item, ok := l.data[key.Key]; ok {\n\t\t\tif time.Until(item.ttl) > 0 {\n\t\t\t\treturn nil, dlock.ErrNotObtained\n\t\t\t} else {\n\t\t\t\tinsertLocks = append(insertLocks, key)\n\t\t\t}\n\t\t} else {\n\t\t\tinsertLocks = append(insertLocks, key)\n\t\t}\n\t}\n\tfor _, key := range readLocks {\n\t\tif item, ok := l.data[key.Key]; ok {\n\t\t\tif item.lockType == dlock.ReadLock {\n\t\t\t\tif time.Until(item.ttl) > 0 {\n\t\t\t\t\titem.count++\n\t\t\t\t\titem.ttl = time.Now().Add(ttl)\n\t\t\t\t\ttokens = append(tokens, item.token)\n\t\t\t\t} else {\n\t\t\t\t\tinsertLocks = append(insertLocks, key)\n\t\t\t\t}\n\t\t\t} else if time.Until(item.ttl) > 0 {\n\t\t\t\treturn nil, dlock.ErrNotObtained\n\t\t\t}\n\t\t} else {\n\t\t\tinsertLocks = append(insertLocks, key)\n\t\t}\n\t}\n\n\tfor _, key := range insertLocks {\n\t\tl.data[key.Key] = &lockItem{\n\t\t\tkey:      key.Key,\n\t\t\tttl:      time.Now().Add(ttl),\n\t\t\ttoken:    token,\n\t\t\tlockType: key.Type,\n\t\t\tcount:    1,\n\t\t}\n\t}\n\n\tlock := &memLock{\n\t\tlocker: l,\n\t\tkeys:   keys,\n\t\ttokens: tokens,\n\t}\n\treturn lock, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/infra/response/result.go",
        "code_start_line": 9,
        "code_end_line": 13,
        "code_key": "Result",
        "code_value": "type Result struct {\n\tCode    ErrorCode   `json:\"code\"`    // 错误码\n\tMessage string      `json:\"message\"` // 错误信息\n\tData    interface{} `json:\"data\"`    // 返回数据\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 109,
        "code_end_line": 113,
        "code_key": "Result",
        "code_value": "type Result struct {\n\t\tLock    string\n\t\tExpired bool\n\t\tType    int\n\t}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 149,
        "code_end_line": 151,
        "code_key": "Result",
        "code_value": "type Result struct {\n\t\tLock string\n\t}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 182,
        "code_end_line": 186,
        "code_key": "Result",
        "code_value": "type Result struct {\n\t\tLock       string\n\t\tExpiration time.Time\n\t\tToken      string\n\t}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 41,
        "code_end_line": 45,
        "code_key": "readKeysMemLock",
        "code_value": "type readKeysMemLock struct {\n\tcount      int\n\texpiration time.Time\n\ttoken      string\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go:254:282:releaseReadLocks": {
    "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
    "code_start_line": 254,
    "code_end_line": 282,
    "code_start_column": 23,
    "code_key": "releaseReadLocks",
    "code_value": "func (l *mysqlLocker) releaseReadLocks(tx *gorm.DB, readLockKeys []string, tokens []string) error {\n\tvar needUpdateCountReadKeys []string = nil\n\tl.mutex.Lock()\n\tfor _, key := range readLockKeys {\n\t\tif readKey, exist := l.readKeysMemLock[key]; exist && containsString(tokens, readKey.token) {\n\t\t\treadKey.count--\n\t\t\tif readKey.count == 0 {\n\t\t\t\tdelete(l.readKeysMemLock, key)\n\t\t\t\tneedUpdateCountReadKeys = append(needUpdateCountReadKeys, key)\n\t\t\t}\n\t\t}\n\t}\n\tl.mutex.Unlock()\n\t// 批量更新\n\tif len(needUpdateCountReadKeys) > 0 {\n\t\tresult := tx.Exec(\"UPDATE \"+l.tableName+\" SET `\"+l.lockNumsColumn+\"` = `\"+l.lockNumsColumn+\"` - 1 WHERE `\"+l.lockColumn+\"` IN (?) AND `\"+l.tokenColumn+\"` IN (?)\", needUpdateCountReadKeys, tokens)\n\t\tif result.Error != nil {\n\t\t\treturn errors.Wrap(result.Error, fmt.Sprintf(\"failed to release readLocks: %s\", readLockKeys))\n\t\t}\n\n\t\t// 删除计数器为 0 的记录\n\t\tresult = tx.Exec(\"DELETE FROM \"+l.tableName+\" WHERE `\"+l.lockColumn+\"` IN (?) AND `\"+l.lockNumsColumn+\"` = 0\", needUpdateCountReadKeys)\n\t\tif result.Error != nil {\n\t\t\treturn errors.Wrap(result.Error, fmt.Sprintf(\"failed to release readLocks: %s\", readLockKeys))\n\t\t}\n\t}\n\n\treturn nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 2,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/test_utils/initdb.go",
        "code_start_line": 53,
        "code_end_line": 58,
        "code_key": "Release",
        "code_value": "func (p *dbPool) Release(idx int) {\n\tp.lock.Lock()\n\tdefer p.lock.Unlock()\n\tdelete(p.busyIdx, idx)\n\tp.freeIdx[idx] = struct{}{}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/testutil/db.go",
        "code_start_line": 59,
        "code_end_line": 64,
        "code_key": "Release",
        "code_value": "func (p *dbPool) Release(idx int) {\n\tp.lock.Lock()\n\tdefer p.lock.Unlock()\n\tdelete(p.busyIdx, idx)\n\tp.freeIdx[idx] = struct{}{}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 677,
        "code_end_line": 710,
        "code_key": "Release",
        "code_value": "func (l *mysqlLock) Release(ctx context.Context) error {\n\tif atomic.LoadInt32(&l.released) == 1 {\n\t\t// fast path\n\t\treturn nil\n\t}\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\n\t// slow path\n\tif l.released == 1 {\n\t\treturn nil\n\t}\n\n\ttx := l.locker.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\n\n\treadLocks, writeLocks := l.locker.getReadLocksAndWriteLocks(tx, l.keys)\n\n\tif err := l.locker.deleteLocksByKeysAndToken(tx, dlock.LockKeySlice(writeLocks).GetKeys(), l.tokens); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn errors.Wrap(err, \"failed to release locks\")\n\t}\n\n\tif err := l.locker.releaseReadLocks(tx, dlock.LockKeySlice(readLocks).GetKeys(), l.tokens); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn errors.Wrap(err, \"failed to release locks\")\n\t}\n\n\tif result := tx.Commit(); result.Error != nil {\n\t\treturn errors.Wrap(result.Error, \"failed to commit release locks\")\n\t}\n\tl.expiration = time.Now()\n\tatomic.StoreInt32(&l.released, 1)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mem/memdlock.go",
        "code_start_line": 213,
        "code_end_line": 246,
        "code_key": "Release",
        "code_value": "func (l *memLock) Release(ctx context.Context) error {\n\tif atomic.LoadInt32(&l.released) == 1 {\n\t\t// fast path\n\t\treturn nil\n\t}\n\tl.locker.mutex.Lock()\n\tdefer l.locker.mutex.Unlock()\n\n\t// slow path\n\tif l.released == 1 {\n\t\treturn nil\n\t}\n\n\ttokens := make(map[string]struct{}, len(l.tokens))\n\tfor _, item := range l.tokens {\n\t\ttokens[item] = struct{}{}\n\t}\n\tfor _, key := range l.keys {\n\t\tif item, ok := l.locker.data[key.Key]; ok {\n\t\t\tif _, exist := tokens[item.token]; !exist {\n\t\t\t\tcontinue\n\t\t\t} else {\n\t\t\t\tif item.lockType == dlock.ReadLock && item.count > 1 {\n\t\t\t\t\titem.count--\n\t\t\t\t} else {\n\t\t\t\t\tdelete(l.locker.data, key.Key)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tatomic.StoreInt32(&l.released, 1)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/infra/utils/lock.go",
        "code_start_line": 7,
        "code_end_line": 7,
        "code_key": "LockKey",
        "code_value": "type LockKey string",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/dlock.go",
        "code_start_line": 18,
        "code_end_line": 21,
        "code_key": "LockKey",
        "code_value": "type LockKey struct {\n\tKey  string\n\tType LockType\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go:295:306:deleteLocksByKeysAndToken": {
    "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
    "code_start_line": 295,
    "code_end_line": 306,
    "code_start_column": 23,
    "code_key": "deleteLocksByKeysAndToken",
    "code_value": "func (l *mysqlLocker) deleteLocksByKeysAndToken(tx *gorm.DB, keys []string, token []string) error {\n\tif len(keys) == 0 {\n\t\treturn nil\n\t}\n\n\tresult := tx.Exec(\"DELETE FROM \"+l.tableName+\" WHERE `\"+l.lockColumn+\"` IN (?) AND \"+l.tokenColumn+\" IN (?)\", keys, token)\n\tif result.Error != nil {\n\t\treturn errors.Wrap(result.Error, fmt.Sprintf(\"failed to delete specified locks: %s, token: %s\", keys, token))\n\t}\n\n\treturn nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/adapter/test_utils/initdb.go",
        "code_start_line": 53,
        "code_end_line": 58,
        "code_key": "Release",
        "code_value": "func (p *dbPool) Release(idx int) {\n\tp.lock.Lock()\n\tdefer p.lock.Unlock()\n\tdelete(p.busyIdx, idx)\n\tp.freeIdx[idx] = struct{}{}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/adapters/testutil/db.go",
        "code_start_line": 59,
        "code_end_line": 64,
        "code_key": "Release",
        "code_value": "func (p *dbPool) Release(idx int) {\n\tp.lock.Lock()\n\tdefer p.lock.Unlock()\n\tdelete(p.busyIdx, idx)\n\tp.freeIdx[idx] = struct{}{}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 677,
        "code_end_line": 710,
        "code_key": "Release",
        "code_value": "func (l *mysqlLock) Release(ctx context.Context) error {\n\tif atomic.LoadInt32(&l.released) == 1 {\n\t\t// fast path\n\t\treturn nil\n\t}\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\n\t// slow path\n\tif l.released == 1 {\n\t\treturn nil\n\t}\n\n\ttx := l.locker.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\n\n\treadLocks, writeLocks := l.locker.getReadLocksAndWriteLocks(tx, l.keys)\n\n\tif err := l.locker.deleteLocksByKeysAndToken(tx, dlock.LockKeySlice(writeLocks).GetKeys(), l.tokens); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn errors.Wrap(err, \"failed to release locks\")\n\t}\n\n\tif err := l.locker.releaseReadLocks(tx, dlock.LockKeySlice(readLocks).GetKeys(), l.tokens); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn errors.Wrap(err, \"failed to release locks\")\n\t}\n\n\tif result := tx.Commit(); result.Error != nil {\n\t\treturn errors.Wrap(result.Error, \"failed to commit release locks\")\n\t}\n\tl.expiration = time.Now()\n\tatomic.StoreInt32(&l.released, 1)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mem/memdlock.go",
        "code_start_line": 213,
        "code_end_line": 246,
        "code_key": "Release",
        "code_value": "func (l *memLock) Release(ctx context.Context) error {\n\tif atomic.LoadInt32(&l.released) == 1 {\n\t\t// fast path\n\t\treturn nil\n\t}\n\tl.locker.mutex.Lock()\n\tdefer l.locker.mutex.Unlock()\n\n\t// slow path\n\tif l.released == 1 {\n\t\treturn nil\n\t}\n\n\ttokens := make(map[string]struct{}, len(l.tokens))\n\tfor _, item := range l.tokens {\n\t\ttokens[item] = struct{}{}\n\t}\n\tfor _, key := range l.keys {\n\t\tif item, ok := l.locker.data[key.Key]; ok {\n\t\t\tif _, exist := tokens[item.token]; !exist {\n\t\t\t\tcontinue\n\t\t\t} else {\n\t\t\t\tif item.lockType == dlock.ReadLock && item.count > 1 {\n\t\t\t\t\titem.count--\n\t\t\t\t} else {\n\t\t\t\t\tdelete(l.locker.data, key.Key)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tatomic.StoreInt32(&l.released, 1)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": []
  },
  "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go:309:332:updateLocksTTLByKeysAndTokens": {
    "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
    "code_start_line": 309,
    "code_end_line": 332,
    "code_start_column": 23,
    "code_key": "updateLocksTTLByKeysAndTokens",
    "code_value": "func (l *mysqlLocker) updateLocksTTLByKeysAndTokens(tx *gorm.DB, keys []string, tokens []string, ttl time.Duration) error {\n\tif len(keys) == 0 {\n\t\treturn nil\n\t}\n\n\tresult := tx.Exec(\"UPDATE \"+l.tableName+\" SET \"+l.expireColumn+\" = NOW() + INTERVAL ? SECOND WHERE `\"+l.lockColumn+\"` IN (?) AND \"+l.tokenColumn+\" IN (?)\", ttl.Seconds(), keys, tokens)\n\tif result.Error != nil {\n\t\treturn errors.Wrap(result.Error, fmt.Sprintf(\"failed to update locks ttl: %s, token: %s\", keys, tokens))\n\t}\n\n\tif result.RowsAffected != int64(len(keys)) {\n\t\t// If the number of rows affected is not equal to the number of keys, it means that the locks are not updated.\n\t\t// We should check if the locks are still held. If not, return an error.\n\t\t// NOCA:QCloudAkCheck(误报)\n\t\tif existingsKeys, err := l.fetchExistingLocksByKeysAndTokens(tx, keys, tokens); err != nil {\n\t\t\treturn err\n\t\t} else if checkStrSetEqual(existingsKeys, keys) {\n\t\t\treturn nil\n\t\t}\n\t\treturn errors.Wrap(dlock.ErrLockNotHeld, fmt.Sprintf(\"keys %v are not updated\", keys))\n\t}\n\n\treturn nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/affi/cache/tracker.go",
        "code_start_line": 67,
        "code_end_line": 77,
        "code_key": "Refresh",
        "code_value": "func (rdp *PhyDiskTracker) Refresh(ctx context.Context) {\n\trdp.Track(ctx)\n\tlock.RDPhyCacheGlobalLock.GetLocker(lock.RDPhyLockKeyGenerator{}).Lock()\n\trdp.Merge(ctx, rdp.OriPhyDisks)\n\tlogs.Info(ctx).\n\t\tInt(\"disk_num\", len(rdp.ToCachedPhyDisks)).\n\t\tInt(\"member_num\", len(rdp.DrgroupMembers)).\n\t\tMsg(\"CACHE_AVAILABLE_PHY_DISK_AFTER_MERGE\")\n\trdp.CacheManager.RefreshCache(ctx, rdp.ToCachedPhyDisks, rdp.DrgroupMembers)\n\tlock.RDPhyCacheGlobalLock.GetLocker(lock.RDPhyLockKeyGenerator{}).Unlock()\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/cbs_packing_srv/domain/set/cache/tracker.go",
        "code_start_line": 35,
        "code_end_line": 38,
        "code_key": "Refresh",
        "code_value": "func (d *DiskSetTracker) Refresh(ctx context.Context) {\n\td.Track(ctx)\n\td.CacheManager.RefreshCache(ctx, d.DiskSetEntityInf)\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 644,
        "code_end_line": 674,
        "code_key": "Refresh",
        "code_value": "func (l *mysqlLock) Refresh(ctx context.Context, ttl time.Duration) error {\n\n\ttx := l.locker.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\n\n\tkeysKey := dlock.LockKeySlice(l.keys).GetKeys()\n\t// NOCA:QCloudAkCheck(误报)\n\texistingLocks, err := l.locker.fetchExistingLocksByKeysAndTokens(tx, keysKey, l.tokens)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn err\n\t}\n\n\t// Compare existing locks with the keys.\n\tif !checkStrSetEqual(existingLocks, keysKey) {\n\t\t_ = tx.Rollback()\n\t\treturn errors.Wrap(dlock.ErrLockNotHeld, \"lock is not held\")\n\t}\n\n\t// Update the expiration time.\n\tif err := l.locker.updateLocksTTLByKeysAndTokens(tx, keysKey, l.tokens, ttl); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn err\n\t}\n\n\tif result := tx.Commit(); result.Error != nil {\n\t\treturn errors.Wrap(result.Error, \"failed to commit refresh locks\")\n\t}\n\n\tl.expiration = time.Now().Add(ttl)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mem/memdlock.go",
        "code_start_line": 189,
        "code_end_line": 210,
        "code_key": "Refresh",
        "code_value": "func (l *memLock) Refresh(ctx context.Context, ttl time.Duration) error {\n\tl.locker.mutex.Lock()\n\tdefer l.locker.mutex.Unlock()\n\n\ttokens := make(map[string]struct{}, len(l.tokens))\n\tfor _, item := range l.tokens {\n\t\ttokens[item] = struct{}{}\n\t}\n\tfor _, key := range l.keys {\n\t\tif item, ok := l.locker.data[key.Key]; ok {\n\t\t\tif _, exist := tokens[item.token]; !exist {\n\t\t\t\treturn dlock.ErrLockNotHeld\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, key := range l.keys {\n\t\tl.locker.data[key.Key].ttl = time.Now().Add(ttl)\n\t}\n\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": []
  },
  "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go:335:369:insertLocks": {
    "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
    "code_start_line": 335,
    "code_end_line": 369,
    "code_start_column": 23,
    "code_key": "insertLocks",
    "code_value": "func (l *mysqlLocker) insertLocks(tx *gorm.DB, lockKeys []*dlock.LockKey, ttl time.Duration, lockToken []string) ([]string, error) {\n\tif len(lockKeys) <= 0 {\n\t\treturn nil, nil\n\t}\n\tstmt := strings.Builder{}\n\targs := make([]interface{}, 0, len(lockKeys)*5)\n\tt := time.Now().Add(ttl)\n\tstmt.WriteString(fmt.Sprintf(\"INSERT INTO `%s` (`%s`, `%s`, `%s`, `%s`, `%s`) VALUES \", l.tableName, l.lockColumn, l.expireColumn, l.tokenColumn, l.lockTypeColumn, l.lockNumsColumn))\n\tfor i, key := range lockKeys {\n\t\tif i > 0 {\n\t\t\tstmt.WriteString(\", \")\n\t\t}\n\t\tstmt.WriteString(\"(?, NOW() + INTERVAL ? SECOND, ?, ?, ?)\")\n\t\targs = append(args, key.Key, ttl.Seconds(), lockToken[0], int(key.Type), 1)\n\t}\n\n\tresult := tx.Exec(stmt.String(), args...)\n\tif result.Error != nil {\n\t\treturn nil, errors.Wrap(result.Error, \"failed to insert locks\")\n\t}\n\tvar needInsertReadKeys []string = nil\n\tl.mutex.Lock()\n\tfor _, key := range lockKeys {\n\t\tif key.Type == dlock.ReadLock {\n\t\t\tl.readKeysMemLock[key.Key] = &readKeysMemLock{\n\t\t\t\tcount:      1,\n\t\t\t\texpiration: t,\n\t\t\t\ttoken:      lockToken[0],\n\t\t\t}\n\t\t\tneedInsertReadKeys = append(needInsertReadKeys, key.Key)\n\t\t}\n\t}\n\tl.mutex.Unlock()\n\treturn needInsertReadKeys, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 1,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 417,
        "code_end_line": 470,
        "code_key": "tryObtainMulti",
        "code_value": "func (l *mysqlLocker) tryObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, tokens []string, opts *dlock.Option) ([]string, error) {\n\t// Starts a new transaction.\n\ttx := l.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\n\n\t// Fetch existing locks.\n\texistingReadKeys, existingWriteKeys, expiredKeys, err := l.fetchExistingLocks(tx, keys)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// If there are existing valid locks, return an error.\n\tif len(existingWriteKeys) > 0 {\n\t\t_ = tx.Rollback()\n\t\treturn nil, errors.Wrap(dlock.ErrLockNotHeld, fmt.Sprintf(\"writeKeys %v are already locked\", existingWriteKeys))\n\t}\n\n\t// Delete expired locks if exists.\n\tif err := l.deleteExpiredLocks(tx, expiredKeys); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Remove existing readLocks from insert.\n\t// NOCA:QCloudAkCheck(误报)\n\tlockKeys, err := l.removeExistingReadLocksFromInsert(tx, keys, existingReadKeys)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Insert locks into database.\n\tneedInsertReadKeys, err := l.insertLocks(tx, lockKeys, ttl, tokens)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Update readLocks.\n\tvar needUpdateExpirationReadKeys []string = nil\n\tvar needUpdateCountReadKeys []string = nil\n\tif needUpdateExpirationReadKeys, needUpdateCountReadKeys, tokens, err = l.updateReadLocks(tx, ttl, existingReadKeys, tokens); err != nil {\n\t\tl.rollback(needUpdateCountReadKeys, tokens)\n\t\tl.rollback(needUpdateExpirationReadKeys, tokens)\n\t\tl.rollback(needInsertReadKeys, tokens)\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\tif result := tx.Commit(); result.Error != nil {\n\t\treturn nil, errors.Wrap(result.Error, \"failed to commit transaction\")\n\t}\n\n\treturn tokens, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mem/memdlock.go",
        "code_start_line": 106,
        "code_end_line": 166,
        "code_key": "tryObtainMulti",
        "code_value": "func (l *memLocker) tryObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, token string) (dlock.Lock, error) {\n\tl.mutex.Lock()\n\tdefer l.mutex.Unlock()\n\tvar readLocks []*dlock.LockKey\n\tvar writeLocks []*dlock.LockKey\n\tvar insertLocks []*dlock.LockKey\n\tvar tokens []string\n\ttokens = append(tokens, token)\n\tfor _, key := range keys {\n\t\tif key.Type == dlock.WriteLock {\n\t\t\twriteLocks = append(writeLocks, key)\n\t\t} else {\n\t\t\treadLocks = append(readLocks, key)\n\t\t}\n\t}\n\tfor _, key := range writeLocks {\n\t\tif item, ok := l.data[key.Key]; ok {\n\t\t\tif time.Until(item.ttl) > 0 {\n\t\t\t\treturn nil, dlock.ErrNotObtained\n\t\t\t} else {\n\t\t\t\tinsertLocks = append(insertLocks, key)\n\t\t\t}\n\t\t} else {\n\t\t\tinsertLocks = append(insertLocks, key)\n\t\t}\n\t}\n\tfor _, key := range readLocks {\n\t\tif item, ok := l.data[key.Key]; ok {\n\t\t\tif item.lockType == dlock.ReadLock {\n\t\t\t\tif time.Until(item.ttl) > 0 {\n\t\t\t\t\titem.count++\n\t\t\t\t\titem.ttl = time.Now().Add(ttl)\n\t\t\t\t\ttokens = append(tokens, item.token)\n\t\t\t\t} else {\n\t\t\t\t\tinsertLocks = append(insertLocks, key)\n\t\t\t\t}\n\t\t\t} else if time.Until(item.ttl) > 0 {\n\t\t\t\treturn nil, dlock.ErrNotObtained\n\t\t\t}\n\t\t} else {\n\t\t\tinsertLocks = append(insertLocks, key)\n\t\t}\n\t}\n\n\tfor _, key := range insertLocks {\n\t\tl.data[key.Key] = &lockItem{\n\t\t\tkey:      key.Key,\n\t\t\tttl:      time.Now().Add(ttl),\n\t\t\ttoken:    token,\n\t\t\tlockType: key.Type,\n\t\t\tcount:    1,\n\t\t}\n\t}\n\n\tlock := &memLock{\n\t\tlocker: l,\n\t\tkeys:   keys,\n\t\ttokens: tokens,\n\t}\n\treturn lock, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 41,
        "code_end_line": 45,
        "code_key": "readKeysMemLock",
        "code_value": "type readKeysMemLock struct {\n\tcount      int\n\texpiration time.Time\n\ttoken      string\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go:417:470:tryObtainMulti": {
    "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
    "code_start_line": 417,
    "code_end_line": 470,
    "code_start_column": 23,
    "code_key": "tryObtainMulti",
    "code_value": "func (l *mysqlLocker) tryObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, tokens []string, opts *dlock.Option) ([]string, error) {\n\t// Starts a new transaction.\n\ttx := l.db.Begin(&sql.TxOptions{Isolation: sql.LevelRepeatableRead})\n\n\t// Fetch existing locks.\n\texistingReadKeys, existingWriteKeys, expiredKeys, err := l.fetchExistingLocks(tx, keys)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// If there are existing valid locks, return an error.\n\tif len(existingWriteKeys) > 0 {\n\t\t_ = tx.Rollback()\n\t\treturn nil, errors.Wrap(dlock.ErrLockNotHeld, fmt.Sprintf(\"writeKeys %v are already locked\", existingWriteKeys))\n\t}\n\n\t// Delete expired locks if exists.\n\tif err := l.deleteExpiredLocks(tx, expiredKeys); err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Remove existing readLocks from insert.\n\t// NOCA:QCloudAkCheck(误报)\n\tlockKeys, err := l.removeExistingReadLocksFromInsert(tx, keys, existingReadKeys)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Insert locks into database.\n\tneedInsertReadKeys, err := l.insertLocks(tx, lockKeys, ttl, tokens)\n\tif err != nil {\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\n\t// Update readLocks.\n\tvar needUpdateExpirationReadKeys []string = nil\n\tvar needUpdateCountReadKeys []string = nil\n\tif needUpdateExpirationReadKeys, needUpdateCountReadKeys, tokens, err = l.updateReadLocks(tx, ttl, existingReadKeys, tokens); err != nil {\n\t\tl.rollback(needUpdateCountReadKeys, tokens)\n\t\tl.rollback(needUpdateExpirationReadKeys, tokens)\n\t\tl.rollback(needInsertReadKeys, tokens)\n\t\t_ = tx.Rollback()\n\t\treturn nil, err\n\t}\n\tif result := tx.Commit(); result.Error != nil {\n\t\treturn nil, errors.Wrap(result.Error, \"failed to commit transaction\")\n\t}\n\n\treturn tokens, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 8,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
        "code_start_line": 473,
        "code_end_line": 520,
        "code_key": "ObtainMulti",
        "code_value": "func (l *mysqlLocker) ObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, opts *dlock.Option) (dlock.Lock, error) {\n\tif len(keys) == 0 {\n\t\treturn nil, errors.New(\"keys cannot be empty\")\n\t}\n\tkeys = dedupAndSort(keys)\n\n\t// Get the lock token.\n\tlockToken, err := l.getOrCreateLockToken(opts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tretryStrategy := dlock.NoRetry()\n\tif opts != nil && opts.RetryStrategy != nil {\n\t\tretryStrategy = opts.RetryStrategy\n\t}\n\n\tretries := 0\n\tlogger := logs.GetLogger(ctx).With().Strs(\"keys\", dlock.LockKeySlice(keys).GetKeys()).Strs(\"tokens\", lockToken).Logger()\n\n\tfor {\n\t\t// Try to obtain the locks.\n\t\t// If the locks are not obtained, retry based on the retry strategy.\n\t\tif tokens, err := l.tryObtainMulti(ctx, keys, ttl, lockToken, opts); err != nil {\n\t\t\t// If context is canceled, return immediately.\n\t\t\tif ctx.Err() != nil {\n\t\t\t\treturn nil, errors.Wrap(dlock.ErrNotObtained, \"context is canceled\")\n\t\t\t}\n\n\t\t\t// If the lock is not obtained, retry.\n\t\t\twaitDuration := retryStrategy.NextBackoff()\n\t\t\tif waitDuration <= 0 {\n\t\t\t\tlogger.Debug().Int(\"retry\", retries).Msg(\"stop retrying lock\")\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tlogger.Debug().Int(\"retry\", retries).Msg(\"retry obtaining lock\")\n\t\t\ttime.Sleep(waitDuration)\n\t\t} else {\n\t\t\tlockToken = tokens\n\t\t\tlogger.Debug().Msg(\"lock obtained\")\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// TODO xuanzeng: 这里采用内部记录 TTL 的方式，可能和底层的数据库时间不同步，后续应该从数据库中获取过期时间。\n\tlock := &mysqlLock{keys: keys, locker: l, tokens: lockToken, expiration: time.Now().Add(ttl)}\n\treturn lock, nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mem/memdlock.go",
        "code_start_line": 74,
        "code_end_line": 103,
        "code_key": "ObtainMulti",
        "code_value": "func (l *memLocker) ObtainMulti(ctx context.Context, keys []*dlock.LockKey, ttl time.Duration, opts *dlock.Option) (dlock.Lock, error) {\n\tvar token string\n\tif opts == nil || opts.Token == \"\" {\n\t\ttoken = uuid.New().String()\n\t} else {\n\t\ttoken = opts.Token\n\t}\n\n\tretryStrategy := dlock.NoRetry()\n\tif opts != nil && opts.RetryStrategy != nil {\n\t\tretryStrategy = opts.RetryStrategy\n\t}\n\n\tfor {\n\t\tlock, err := l.tryObtainMulti(ctx, keys, ttl, token)\n\t\tif err == nil {\n\t\t\treturn lock, nil\n\t\t}\n\n\t\tif ctx.Err() != nil {\n\t\t\treturn nil, ctx.Err()\n\t\t}\n\n\t\twaitInterval := retryStrategy.NextBackoff()\n\t\tif waitInterval <= 0 {\n\t\t\treturn nil, dlock.ErrNotObtained\n\t\t}\n\t\ttime.Sleep(waitInterval)\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": []
  },
  "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go:528:552:Cleanup": {
    "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
    "code_start_line": 528,
    "code_end_line": 552,
    "code_start_column": 23,
    "code_key": "Cleanup",
    "code_value": "func (l *mysqlLocker) Cleanup(ctx context.Context, opts *dlock.CleanupOption) error {\n\t// Apply default options if not provided.\n\tif opts == nil {\n\t\topts = defaultCleanupOption\n\t} else {\n\t\tif opts.MaxCount <= 0 {\n\t\t\topts.MaxCount = defaultCleanupOption.MaxCount\n\t\t}\n\t\tif opts.TimeAfterExpire <= 0 {\n\t\t\topts.TimeAfterExpire = defaultCleanupOption.TimeAfterExpire\n\t\t}\n\t}\n\n\treturn l.db.Transaction(func(tx *gorm.DB) error {\n\t\t// The order is important, we need to make sure that delete order is the same as the obtain order.\n\t\t// Otherwise deadlock may happen.\n\t\tresult := tx.Exec(\"DELETE FROM \"+l.tableName+\" WHERE \"+l.lockNumsColumn+\" = 0 ORDER BY `\"+l.lockColumn+\"` ASC LIMIT ?\", opts.MaxCount)\n\t\tif result.Error != nil {\n\t\t\treturn result.Error\n\t\t}\n\t\tresult = tx.Exec(\"DELETE FROM \"+l.tableName+\" WHERE \"+l.expireColumn+\" < NOW() - INTERVAL ? SECOND ORDER BY `\"+l.lockColumn+\"` ASC LIMIT ?\", opts.TimeAfterExpire.Seconds(), opts.MaxCount)\n\t\treturn result.Error\n\n\t}, &sql.TxOptions{Isolation: sql.LevelRepeatableRead})\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 3,
    "callers": [],
    "code_meta_data": []
  },
  "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go:555:588:Observe": {
    "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
    "code_start_line": 555,
    "code_end_line": 588,
    "code_start_column": 23,
    "code_key": "Observe",
    "code_value": "func (l *mysqlLocker) Observe(ctx context.Context, key string) (*dlock.LockView, error) {\n\n\tvar view dlock.LockView\n\tvar result struct {\n\t\tName   string\n\t\tExpire time.Time\n\t\tToken  string\n\t\tNums   int\n\t\tType   int\n\t}\n\n\terr := l.db.Transaction(func(tx *gorm.DB) error {\n\t\top := tx.Raw(\"SELECT `\"+l.lockColumn+\"` AS name, `\"+l.expireColumn+\"` AS expire, `\"+l.tokenColumn+\"` AS token, `\"+l.lockTypeColumn+\"` AS type, `\"+l.lockNumsColumn+\"` AS nums FROM \"+l.tableName+\" WHERE `\"+l.lockColumn+\"` = ? AND `\"+l.expireColumn+\"` > NOW() LIMIT 1\", key).Scan(&result)\n\t\tif op.Error != nil {\n\t\t\treturn op.Error\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif result.Name == \"\" {\n\t\treturn nil, errors.Errorf(\"lock not found for key %s\", key)\n\t}\n\n\tview.Key = result.Name\n\tview.TTL = time.Until(result.Expire)\n\tview.Token = result.Token\n\tview.Nums = result.Nums\n\tview.Type = dlock.LockType(result.Type)\n\n\treturn &view, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 2,
    "callers": [
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/convertor.go",
        "code_start_line": 28,
        "code_end_line": 38,
        "code_key": "Start",
        "code_value": "func (a *Convertor) Start(ctx context.Context) error {\n\t// 启动转换器\n\tfor _, scanner := range a.scanners {\n\t\tscanner := scanner\n\t\tgo func() {\n\t\t\ta.convertToTask(ctx, scanner)\n\t\t}()\n\t}\n\tlogs.Info(ctx).Msgf(\"Convertor Start Success\")\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_rec_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *CbsMeasureReconciliationTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\t//s.resultChan <- struct{}{}\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_rec_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 35,
        "code_key": "Start",
        "code_value": "func (s *SnapMeasureReconciliationTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_compute_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *SnapComputeTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\t//s.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_measure_send_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *CbsMeasureSendTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_bill_valid_appId_fetch_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 37,
        "code_key": "Start",
        "code_value": "func (s *CbsValidAppIdFetchTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_calculate_cost_locally_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 36,
        "code_key": "Start",
        "code_value": "func (s *SnapCalculateCostLocallyTaskScanner) Start(ctx context.Context) error {\n\t//s.resultChan <- struct{}{}\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_create_task_scanner.go",
        "code_start_line": 23,
        "code_end_line": 42,
        "code_key": "Start",
        "code_value": "func (s *UpdateCreateTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\trunning := true\n\t\tfor running {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\trunning = false\n\t\t\tdefault:\n\t\t\t\terr := s.FullScan(ctx)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogs.Fatal(ctx).Msgf(\"%s full scan failed!\\n\", s.name)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\ttime.Sleep(s.scanInterval)\n\t\t}\n\t}()\n\tlogs.Info(ctx).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_measure_send_task_scanner.go",
        "code_start_line": 18,
        "code_end_line": 36,
        "code_key": "Start",
        "code_value": "func (s *SnapMeasureSendTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\t//s.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/repush_user_billing_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 39,
        "code_key": "Start",
        "code_value": "func (s *RepushUserBillingTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/update_rollback_task_scanner.go",
        "code_start_line": 23,
        "code_end_line": 42,
        "code_key": "Start",
        "code_value": "func (s *UpdateRollbackTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\trunning := true\n\t\tfor running {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\trunning = false\n\t\t\tdefault:\n\t\t\t\terr := s.FullScan(ctx)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogs.Fatal(ctx).Msgf(\"%s full scan failed!\\n\", s.name)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\ttime.Sleep(s.scanInterval)\n\t\t}\n\t}()\n\tlogs.Info(ctx).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/snap_valid_appId_fetch_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 36,
        "code_key": "Start",
        "code_value": "func (s *SnapValidAppIdFetchTaskScanner) Start(ctx context.Context) error {\n\t//s.resultChan <- struct{}{}\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tif s.taskExecutable() {\n\t\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/core/scanner/cbs_bill_compute_task_scanner.go",
        "code_start_line": 19,
        "code_end_line": 39,
        "code_key": "Start",
        "code_value": "func (s *CbsBillComputeTaskScanner) Start(ctx context.Context) error {\n\tgo func() {\n\t\ts.resultChan <- struct{}{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.stopChan:\n\t\t\t\tbreak\n\t\t\tcase <-time.After(s.scanInterval):\n\t\t\t\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\ts.resultChan <- struct{}{}\n\t\t\t\t//if s.taskExecutable() {\n\t\t\t\t//\tlogs.Info(ctx).Str(\"taskName\", s.name).Msg(\"ADD_NEW_TASK\")\n\t\t\t\t//\ts.resultChan <- struct{}{}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}()\n\tlogs.Info(ctx).Int64(\"scanInterval\", int64(s.scanInterval)).Msgf(\"%s Start Success\", s.name)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/app/app.go",
        "code_start_line": 31,
        "code_end_line": 39,
        "code_key": "Start",
        "code_value": "func (m *PipelineManager) Start(ctx context.Context) error {\n\tfor region, pipeline := range m.Pipelines {\n\t\tregionCtx := context.WithValue(ctx, \"region\", region)\n\t\tif err := pipeline.Start(regionCtx); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/app/app.go",
        "code_start_line": 46,
        "code_end_line": 51,
        "code_key": "Start",
        "code_value": "func (app *NebulaApp) Start(ctx context.Context) error {\n\tif err := app.pipelineManager.Start(ctx); err != nil {\n\t\treturn err\n\t}\n\treturn <-app.stopChan\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/scheduler/internal/app/pipeline.go",
        "code_start_line": 20,
        "code_end_line": 46,
        "code_key": "Start",
        "code_value": "func (p *RegionPipeline) Start(ctx context.Context) error {\n\tregion := ctx.Value(\"region\").(string)\n\tscannerLogCtx := initLogger(ctx, region, \"scanner.log\")\n\tfor _, scanner := range p.scanners {\n\t\tsingleCtx := logs.AddDefaultMessage(scannerLogCtx, \"name\", scanner.GetName())\n\t\terr := scanner.Start(singleCtx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tinitMetric(scanner, region, \"scanner\", scanner.GetName())\n\t}\n\n\tconvertorLogCtx := initLogger(ctx, region, \"convertor.log\")\n\terr := p.convertor.Start(convertorLogCtx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// start scheduler\n\tschedulerLogCtx := initLogger(ctx, region, \"scheduler.log\")\n\terr = p.scheduler.Start(schedulerLogCtx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tinitMetric(p.scheduler, region, \"scheduler\", \"scheduler\")\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go",
        "code_start_line": 109,
        "code_end_line": 112,
        "code_key": "Start",
        "code_value": "func (sc *Scheduler) Start(ctx context.Context) error {\n\tgo sc.mainLoop(ctx)\n\treturn nil\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/rdisk_master/app/scheduler/scheduler.go",
        "code_start_line": 154,
        "code_end_line": 191,
        "code_key": "Start",
        "code_value": "func (s *scheduler) Start(ctx context.Context) error {\n\twg := sync.WaitGroup{}\n\trunning := true\n\tgo s.haManager.Start(ctx)\n\tdefer s.haManager.Close(ctx)\n\tfor {\n\t\tselect {\n\t\tcase taskName := <-s.eventChan:\n\t\t\twg.Add(1)\n\t\t\tgo func(name string) {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tif task, ok := s.loads[name]; ok {\n\n\t\t\t\t\tif s.isMaster {\n\t\t\t\t\t\t_ctx := logs.With(ctx).Str(\"seqId\", uuid.New().String()).Str(\"taskName\", name).Logger().WithContext(ctx)\n\t\t\t\t\t\ttask.Work(_ctx)\n\t\t\t\t\t}\n\n\t\t\t\t\ttriggerTime := time.Now().Add(task.Interval())\n\t\t\t\t\tfor {\n\t\t\t\t\t\tif !running {\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif time.Now().After(triggerTime) {\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttime.Sleep(time.Second)\n\t\t\t\t\t}\n\t\t\t\t\ts.eventChan <- name\n\t\t\t\t}\n\t\t\t}(taskName)\n\t\tcase <-s.stopChan:\n\t\t\trunning = false\n\t\t\twg.Wait()\n\t\t\treturn nil\n\t\t}\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/easyha/model.go",
        "code_start_line": 108,
        "code_end_line": 180,
        "code_key": "Start",
        "code_value": "func (m *haManagerImpl) Start(ctx context.Context) {\n\tm.keepRunning = true\n\tm.ctx = ctx\n\tvar (\n\t\tmyIdentity            = m.delegate.GetIdentity()                                    // 当前节点的业务标识\n\t\tmyKey                 = fmt.Sprintf(\"easyhaMaster/%s\", url.PathEscape(m.namespace)) // 分布式锁的key\n\t\tmyToken               = m.encodeToken(myIdentity)                                   // 分布式锁 Token，包含业务标识和随机信息\n\t\tmyLock                dlock.Lock                                                    // 获取到的分布式锁, 用于刷新和释放\n\t\tcurrentMasterIdentity string                                                        // 当前 master 的业务标识，如果为空则是还未获取过当前 master\n\t)\n\n\t// Start slave loop.\n\tfor m.keepRunning {\n\t\t// Try observe the master lock first.\n\t\tif view, err := m.locker.Observe(ctx, myKey); err != nil {\n\t\t\tm.logger.Info().Err(err).Str(\"key\", myKey).Msg(\"failed to observe current master lock\")\n\t\t\t// Failed to observe the master lock, try to  obtain the lock.\n\t\t\tmyLock, err = m.locker.Obtain(ctx, dlock.NewWriteLockKey(myKey), m.lockExpired, &dlock.Option{Token: myToken})\n\t\t\tif err == nil {\n\t\t\t\t// Successfully obtained the lock.\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tnewIdentity, err := m.decodeToken(view.Token)\n\t\t\tif err != nil {\n\t\t\t\tm.logger.Warn().Err(err).Str(\"token\", view.Token).Msg(\"failed to decode token\")\n\t\t\t} else if currentMasterIdentity == \"\" {\n\t\t\t\t// First time to observe the master.\n\t\t\t\tcurrentMasterIdentity = newIdentity\n\t\t\t\tif err := m.delegate.OnBecomeSlave(ctx, currentMasterIdentity); err != nil {\n\t\t\t\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle become slave, force quit for safety\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if currentMasterIdentity != newIdentity {\n\t\t\t\t// Master changed. Need update.\n\t\t\t\tcurrentMasterIdentity = newIdentity\n\t\t\t\tif err := m.delegate.OnSwitchMaster(ctx, currentMasterIdentity); err != nil {\n\t\t\t\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle switch master, force quit for safety\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttime.Sleep(m.checkInterval)\n\t}\n\n\tif myLock == nil {\n\t\tm.logger.Fatal().Msg(\"myLock is nil, found bug, force quit for safety\")\n\t\treturn\n\t}\n\n\t// I am the master now.\n\tif err := m.delegate.OnBecomeMaster(ctx); err != nil {\n\t\tmyLock.Release(ctx)\n\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle become master, force quit for safety\")\n\t\treturn\n\t}\n\n\tdefer func() {\n\t\tmyLock.Release(ctx)\n\t\tif err := m.delegate.OnLostMaster(ctx); err != nil {\n\t\t\tm.logger.Fatal().Err(err).Msg(\"failed to handle lost master, force quit for safety\")\n\t\t}\n\t}()\n\n\t// Start the master loop.\n\tfor m.keepRunning {\n\t\ttime.Sleep(m.checkInterval)\n\t\tif err := myLock.Refresh(ctx, m.lockExpired); err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      },
      {
        "code_file": "/Users/freedom/llms/singularity/internal/common/scheduler/scheduler.go",
        "code_start_line": 208,
        "code_end_line": 215,
        "code_key": "deleteFinishTask",
        "code_value": "func (sc *Scheduler) deleteFinishTask(ctx context.Context, task interfaces.Task) {\n\tsubTaskName := task.GetSubTaskName()\n\tif _, ok := sc.metrics.taskExecuteCountMap[subTaskName]; !ok {\n\t\tsc.metrics.taskExecuteCountMap[subTaskName], _ = initHistogramVec(subTaskName).GetMetricWith(sc.metrics.labels)\n\t}\n\tsc.metrics.taskExecuteCountMap[subTaskName].Observe(float64(task.GetExecuteCounts()))\n\tsc.taskMap.Delete(task.GetTaskId())\n}",
        "code_label": 4,
        "code_type": 2,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ],
    "code_meta_data": [
      {
        "code_file": "/Users/freedom/llms/singularity/pkg/dlock/dlock.go",
        "code_start_line": 153,
        "code_end_line": 159,
        "code_key": "LockView",
        "code_value": "type LockView struct {\n\tKey   string        // Key 是锁的键\n\tToken string        // Token 是锁的唯一令牌\n\tType  LockType      // Type 是锁的类型\n\tNums  int           // Nums 是持有锁的协程数（读锁）\n\tTTL   time.Duration // TTL 是锁的剩余时间\n}",
        "code_label": null,
        "code_type": 3,
        "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6"
      }
    ]
  },
  "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go:719:737:TTLs": {
    "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
    "code_start_line": 719,
    "code_end_line": 737,
    "code_start_column": 21,
    "code_key": "TTLs",
    "code_value": "func (l *mysqlLock) TTLs(ctx context.Context) ([]time.Duration, error) {\n\tkeysKey := dlock.LockKeySlice(l.keys).GetKeys()\n\tvar expirations []time.Time\n\tvar results []time.Duration\n\terr := l.locker.db.Transaction(func(tx *gorm.DB) error {\n\t\top := tx.Raw(\"SELECT `\"+l.locker.expireColumn+\"` AS `expiration` FROM \"+l.locker.tableName+\" WHERE `\"+l.locker.lockColumn+\"` = ?\", keysKey).Scan(&expirations)\n\t\tif op.Error != nil {\n\t\t\treturn op.Error\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor _, expiration := range expirations {\n\t\tresults = append(results, time.Until(expiration))\n\t}\n\treturn results, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 2,
    "callers": [],
    "code_meta_data": []
  },
  "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go:740:753:Num": {
    "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
    "code_start_line": 740,
    "code_end_line": 753,
    "code_start_column": 21,
    "code_key": "Num",
    "code_value": "func (l *mysqlLock) Num(ctx context.Context) (int, error) {\n\tvar results int\n\terr := l.locker.db.Transaction(func(tx *gorm.DB) error {\n\t\top := tx.Raw(\"SELECT `\"+l.locker.lockNumsColumn+\"` AS `num` FROM \"+l.locker.tableName+\" WHERE `\"+l.locker.lockColumn+\"` IN (?)\", l.keys[0].Key).Scan(&results)\n\t\tif op.Error != nil {\n\t\t\treturn op.Error\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\treturn results, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 2,
    "callers": [],
    "code_meta_data": []
  },
  "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go:756:770:Nums": {
    "code_file": "/Users/freedom/llms/singularity/pkg/dlock/mysql/dlock.go",
    "code_start_line": 756,
    "code_end_line": 770,
    "code_start_column": 21,
    "code_key": "Nums",
    "code_value": "func (l *mysqlLock) Nums(ctx context.Context) ([]int, error) {\n\tkeysKey := dlock.LockKeySlice(l.keys).GetKeys()\n\tvar results []int\n\terr := l.locker.db.Transaction(func(tx *gorm.DB) error {\n\t\top := tx.Raw(\"SELECT `\"+l.locker.lockNumsColumn+\"` AS `num` FROM \"+l.locker.tableName+\" WHERE `\"+l.locker.lockColumn+\"` IN (?)\", keysKey).Scan(&results)\n\t\tif op.Error != nil {\n\t\t\treturn op.Error\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn results, nil\n}",
    "code_label": 2,
    "code_type": 2,
    "code_version": "7a6ce9d47c30a5bf582db3b759442d236a89c6c6",
    "sql_pattern_cnt": 2,
    "callers": [],
    "code_meta_data": []
  }
}